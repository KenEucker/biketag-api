(function webpackUniversalModuleDefinition(root, factory) {
	//CommonJS2 Comment
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	//AMD Comment
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	//CommonJS Comment
	else if(typeof exports === 'object')
		exports["biketag"] = factory();
	//Root Comment
	else
		root["biketag"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@rexxars/eventsource-polyfill/src/eventsource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rexxars/eventsource-polyfill/src/eventsource.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * EventSource polyfill
 * Originally published by sc AmvTek srl (https://github.com/amvtek/EventSource) - devel@amvtek.com
 * Forked by Espen Hovlandsdal to fix a few issues + publish latest version
 */

;(function (root, factory) {
  /* global define */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else { var evsImportName; }
})(typeof self === 'undefined' ? this : self, function () {
  var EventSource = function (url, options) {
    if (!url || typeof url != 'string') {
      throw new SyntaxError('Not enough arguments')
    }

    this.URL = url
    this.setOptions(options)
    var evs = this
    setTimeout(function () {
      evs.poll()
    }, 0)
  }

  EventSource.prototype = {
    CONNECTING: 0,

    OPEN: 1,

    CLOSED: 2,

    defaultOptions: {
      loggingEnabled: false,

      loggingPrefix: 'eventsource',

      interval: 500, // milliseconds

      bufferSizeLimit: 256 * 1024, // bytes

      silentTimeout: 300000, // milliseconds

      getArgs: {
        evs_buffer_size_limit: 256 * 1024,
      },

      xhrHeaders: {
        Accept: 'text/event-stream',
        'Cache-Control': 'no-cache',
        'X-Requested-With': 'XMLHttpRequest',
      },
    },

    setOptions: function (options) {
      var defaults = this.defaultOptions
      var option

      // set all default options...
      for (option in defaults) {
        if (defaults.hasOwnProperty(option)) {
          this[option] = defaults[option]
        }
      }

      // override with what is in options
      for (option in options) {
        if (option in defaults && options.hasOwnProperty(option)) {
          this[option] = options[option]
        }
      }

      // if getArgs option is enabled
      // ensure evs_buffer_size_limit corresponds to bufferSizeLimit
      if (this.getArgs && this.bufferSizeLimit) {
        this.getArgs.evs_buffer_size_limit = this.bufferSizeLimit
      }

      // if console is not available, force loggingEnabled to false
      // eslint-disable-next-line no-console
      if (typeof console === 'undefined' || typeof console.log === 'undefined') {
        this.loggingEnabled = false
      }
    },

    log: function (message) {
      if (this.loggingEnabled) {
        // eslint-disable-next-line no-console
        console.log('[' + this.loggingPrefix + ']:' + message)
      }
    },

    poll: function () {
      try {
        if (this.readyState == this.CLOSED) {
          return
        }

        this.cleanup()
        this.readyState = this.CONNECTING
        this.cursor = 0
        this.cache = ''
        this._xhr = new this.XHR(this)
        this.resetNoActivityTimer()
      } catch (err) {
        // in an attempt to silence the errors
        this.log('There were errors inside the pool try-catch')
        this.dispatchEvent('error', {type: 'error', data: err.message})
      }
    },

    pollAgain: function (interval) {
      // schedule poll to be called after interval milliseconds
      var evs = this
      evs.readyState = evs.CONNECTING
      evs.dispatchEvent('error', {
        type: 'error',
        data: 'Reconnecting ',
      })
      this._pollTimer = setTimeout(function () {
        evs.poll()
      }, interval || 0)
    },

    cleanup: function () {
      this.log('evs cleaning up')

      if (this._pollTimer) {
        clearInterval(this._pollTimer)
        this._pollTimer = null
      }

      if (this._noActivityTimer) {
        clearInterval(this._noActivityTimer)
        this._noActivityTimer = null
      }

      if (this._xhr) {
        this._xhr.abort()
        this._xhr = null
      }
    },

    resetNoActivityTimer: function () {
      if (this.silentTimeout) {
        if (this._noActivityTimer) {
          clearInterval(this._noActivityTimer)
        }
        var evs = this
        this._noActivityTimer = setTimeout(function () {
          evs.log('Timeout! silentTImeout:' + evs.silentTimeout)
          evs.pollAgain()
        }, this.silentTimeout)
      }
    },

    close: function () {
      this.readyState = this.CLOSED
      this.log('Closing connection. readyState: ' + this.readyState)
      this.cleanup()
    },

    _onxhrdata: function () {
      var request = this._xhr

      if (request.isReady() && !request.hasError()) {
        // reset the timer, as we have activity
        this.resetNoActivityTimer()

        // move this EventSource to OPEN state...
        if (this.readyState == this.CONNECTING) {
          this.readyState = this.OPEN
          this.dispatchEvent('open', {type: 'open'})
        }

        var buffer = request.getBuffer()

        if (buffer.length > this.bufferSizeLimit) {
          this.log('buffer.length > this.bufferSizeLimit')
          this.pollAgain()
        }

        if (this.cursor == 0 && buffer.length > 0) {
          // skip byte order mark \uFEFF character if it starts the stream
          if (buffer.substring(0, 1) == '\uFEFF') {
            this.cursor = 1
          }
        }

        var lastMessageIndex = this.lastMessageIndex(buffer)
        if (lastMessageIndex[0] >= this.cursor) {
          var newcursor = lastMessageIndex[1]
          var toparse = buffer.substring(this.cursor, newcursor)
          this.parseStream(toparse)
          this.cursor = newcursor
        }

        // if request is finished, reopen the connection
        if (request.isDone()) {
          this.log('request.isDone(). reopening the connection')
          this.pollAgain(this.interval)
        }
      } else if (this.readyState !== this.CLOSED) {
        this.log('this.readyState !== this.CLOSED')
        this.pollAgain(this.interval)

        //MV: Unsure why an error was previously dispatched
      }
    },

    parseStream: function (chunk) {
      // normalize line separators (\r\n,\r,\n) to \n
      // remove white spaces that may precede \n
      chunk = this.cache + this.normalizeToLF(chunk)

      var events = chunk.split('\n\n')

      var i, j, eventType, datas, line, retry

      for (i = 0; i < events.length - 1; i++) {
        eventType = 'message'
        datas = []
        var parts = events[i].split('\n')

        for (j = 0; j < parts.length; j++) {
          line = this.trimWhiteSpace(parts[j])

          if (line.indexOf('event') == 0) {
            eventType = line.replace(/event:?\s*/, '')
          } else if (line.indexOf('retry') == 0) {
            retry = parseInt(line.replace(/retry:?\s*/, ''), 10)
            if (!isNaN(retry)) {
              this.interval = retry
            }
          } else if (line.indexOf('data') == 0) {
            datas.push(line.replace(/data:?\s*/, ''))
          } else if (line.indexOf('id:') == 0) {
            this.lastEventId = line.replace(/id:?\s*/, '')
          } else if (line.indexOf('id') == 0) {
            // this resets the id

            this.lastEventId = null
          }
        }

        if (datas.length && this.readyState != this.CLOSED) {
          // dispatch a new event
          var event = new MessageEvent(
            eventType,
            datas.join('\n'),
            typeof window !== 'undefined' && typeof window.location !== 'undefined'
              ? window.location.origin
              : null,
            this.lastEventId
          )
          this.dispatchEvent(eventType, event)
        }
      }

      this.cache = events[events.length - 1]
    },

    dispatchEvent: function (type, event) {
      var handlers = this['_' + type + 'Handlers']

      if (handlers) {
        for (var i = 0; i < handlers.length; i++) {
          handlers[i].call(this, event)
        }
      }

      if (this['on' + type]) {
        this['on' + type].call(this, event)
      }
    },

    addEventListener: function (type, handler) {
      if (!this['_' + type + 'Handlers']) {
        this['_' + type + 'Handlers'] = []
      }

      this['_' + type + 'Handlers'].push(handler)
    },

    removeEventListener: function (type, handler) {
      var handlers = this['_' + type + 'Handlers']
      if (!handlers) {
        return
      }
      for (var i = handlers.length - 1; i >= 0; --i) {
        if (handlers[i] === handler) {
          handlers.splice(i, 1)
          break
        }
      }
    },

    _pollTimer: null,

    _noactivityTimer: null,

    _xhr: null,

    lastEventId: null,

    cache: '',

    cursor: 0,

    onerror: null,

    onmessage: null,

    onopen: null,

    readyState: 0,

    // ===================================================================
    // helpers functions
    // those are attached to prototype to ease reuse and testing...

    urlWithParams: function (baseURL, params) {
      var encodedArgs = []

      if (params) {
        var key, urlarg
        var urlize = encodeURIComponent

        for (key in params) {
          if (params.hasOwnProperty(key)) {
            urlarg = urlize(key) + '=' + urlize(params[key])
            encodedArgs.push(urlarg)
          }
        }
      }

      if (encodedArgs.length > 0) {
        if (baseURL.indexOf('?') == -1) return baseURL + '?' + encodedArgs.join('&')
        return baseURL + '&' + encodedArgs.join('&')
      }
      return baseURL
    },

    lastMessageIndex: function (text) {
      var ln2 = text.lastIndexOf('\n\n')
      var lr2 = text.lastIndexOf('\r\r')
      var lrln2 = text.lastIndexOf('\r\n\r\n')

      if (lrln2 > Math.max(ln2, lr2)) {
        return [lrln2, lrln2 + 4]
      }
      return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]
    },

    trimWhiteSpace: function (str) {
      // to remove whitespaces left and right of string

      var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g
      return str.replace(reTrim, '')
    },

    normalizeToLF: function (str) {
      // replace \r and \r\n with \n
      return str.replace(/\r\n|\r/g, '\n')
    },
  }

  if (isOldIE()) {
    EventSource.isPolyfill = 'IE_8-9'

    // patch EventSource defaultOptions
    var defaults = EventSource.prototype.defaultOptions
    defaults.xhrHeaders = null // no headers will be sent
    defaults.getArgs.evs_preamble = 2048 + 8

    // EventSource will send request using Internet Explorer XDomainRequest
    EventSource.prototype.XHR = function (evs) {
      /* global XDomainRequest */
      var request = new XDomainRequest()
      this._request = request

      // set handlers
      request.onprogress = function () {
        request._ready = true
        evs._onxhrdata()
      }

      request.onload = function () {
        this._loaded = true
        evs._onxhrdata()
      }

      request.onerror = function () {
        this._failed = true
        evs.readyState = evs.CLOSED
        evs.dispatchEvent('error', {
          type: 'error',
          data: 'XDomainRequest error',
        })
      }

      request.ontimeout = function () {
        this._failed = true
        evs.readyState = evs.CLOSED
        evs.dispatchEvent('error', {
          type: 'error',
          data: 'XDomainRequest timed out',
        })
      }

      // XDomainRequest does not allow setting custom headers
      // If EventSource has enabled the use of GET arguments
      // we add parameters to URL so that server can adapt the stream...
      var reqGetArgs = {}
      if (evs.getArgs) {
        // copy evs.getArgs in reqGetArgs
        var defaultArgs = evs.getArgs
        for (var key in defaultArgs) {
          if (defaultArgs.hasOwnProperty(key)) {
            reqGetArgs[key] = defaultArgs[key]
          }
        }
        if (evs.lastEventId) {
          reqGetArgs.evs_last_event_id = evs.lastEventId
        }
      }
      // send the request

      request.open('GET', evs.urlWithParams(evs.URL, reqGetArgs))
      request.send()
    }

    EventSource.prototype.XHR.prototype = {
      useXDomainRequest: true,

      _request: null,

      _ready: false, // true when progress events are dispatched

      _loaded: false, // true when request has been loaded

      _failed: false, // true if when request is in error

      isReady: function () {
        return this._request._ready
      },

      isDone: function () {
        return this._request._loaded
      },

      hasError: function () {
        return this._request._failed
      },

      getBuffer: function () {
        var rv = ''
        try {
          rv = this._request.responseText || ''
        } catch (err) {
          // intentional noop
        }
        return rv
      },

      abort: function () {
        if (this._request) {
          this._request.abort()
        }
      },
    }
  } else {
    EventSource.isPolyfill = 'XHR'

    // EventSource will send request using XMLHttpRequest
    EventSource.prototype.XHR = function (evs) {
      var request = new XMLHttpRequest()
      this._request = request
      evs._xhr = this

      // set handlers
      request.onreadystatechange = function () {
        if (request.readyState > 1 && evs.readyState != evs.CLOSED) {
          if (request.status == 200 || (request.status >= 300 && request.status < 400)) {
            evs._onxhrdata()
          } else {
            request._failed = true
            evs.readyState = evs.CLOSED
            evs.dispatchEvent('error', {
              type: 'error',
              data: 'The server responded with ' + request.status,
            })
            evs.close()
          }
        }
      }

      request.onprogress = function () {
        // intentional noop
      }

      request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true)

      var headers = evs.xhrHeaders // maybe null
      for (var header in headers) {
        if (headers.hasOwnProperty(header)) {
          request.setRequestHeader(header, headers[header])
        }
      }
      if (evs.lastEventId) {
        request.setRequestHeader('Last-Event-Id', evs.lastEventId)
      }

      request.send()
    }

    EventSource.prototype.XHR.prototype = {
      useXDomainRequest: false,

      _request: null,

      _failed: false, // true if we have had errors...

      isReady: function () {
        return this._request.readyState >= 2
      },

      isDone: function () {
        return this._request.readyState == 4
      },

      hasError: function () {
        return this._failed || this._request.status >= 400
      },

      getBuffer: function () {
        var rv = ''
        try {
          rv = this._request.responseText || ''
        } catch (err) {
          // intentional noop
        }
        return rv
      },

      abort: function () {
        if (this._request) {
          this._request.abort()
        }
      },
    }
  }

  function MessageEvent(type, data, origin, lastEventId) {
    this.bubbles = false
    this.cancelBubble = false
    this.cancelable = false
    this.data = data || null
    this.origin = origin || ''
    this.lastEventId = lastEventId || ''
    this.type = type || 'message'
  }

  function isOldIE() {
    //return true if we are in IE8 or IE9
    return Boolean(
      typeof window !== 'undefined' &&
        window.XDomainRequest &&
        window.XMLHttpRequest &&
        new XMLHttpRequest().responseType === undefined
    )
  }

  return EventSource
})


/***/ }),

/***/ "./node_modules/@sanity/client/lib/assets/assetsClient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/assets/assetsClient.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require = __webpack_require__(/*! @sanity/observable/operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require.map;

var _require2 = __webpack_require__(/*! @sanity/observable/operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require2.filter;

var queryString = __webpack_require__(/*! ../http/queryString */ "./node_modules/@sanity/client/lib/http/queryString.js");

var validators = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

function AssetsClient(client) {
  this.client = client;
}

function toDocument(body) {
  // todo: rewrite to just return body.document in a while
  var document = body.document;
  Object.defineProperty(document, 'document', {
    enumerable: false,
    get: function get() {
      // eslint-disable-next-line no-console
      console.warn('The promise returned from client.asset.upload(...) now resolves with the asset document');
      return document;
    }
  });
  return document;
}

function optionsFromFile(opts, file) {
  if (typeof window === 'undefined' || !(file instanceof window.File)) {
    return opts;
  }

  return assign({
    filename: opts.preserveFilename === false ? undefined : file.name,
    contentType: file.type
  }, opts);
}

assign(AssetsClient.prototype, {
  /**
   * Upload an asset
   *
   * @param  {String} assetType `image` or `file`
   * @param  {File|Blob|Buffer|ReadableStream} body File to upload
   * @param  {Object}  opts Options for the upload
   * @param  {Boolean} opts.preserveFilename Whether or not to preserve the original filename (default: true)
   * @param  {String}  opts.filename Filename for this file (optional)
   * @param  {Number}  opts.timeout  Milliseconds to wait before timing the request out (default: 0)
   * @param  {String}  opts.contentType Mime type of the file
   * @param  {Array}   opts.extract Array of metadata parts to extract from image.
   *                                 Possible values: `location`, `exif`, `image`, `palette`
   * @param  {String}  opts.label Label
   * @param  {String}  opts.title Title
   * @param  {String}  opts.description Description
   * @param  {String}  opts.creditLine The credit to person(s) and/or organization(s) required by the supplier of the image to be used when published
   * @param  {Object}  opts.source Source data (when the asset is from an external service)
   * @param  {String}  opts.source.id The (u)id of the asset within the source, i.e. 'i-f323r1E'
   *                                  Required if source is defined
   * @param  {String}  opts.source.name The name of the source, i.e. 'unsplash'
   *                                  Required if source is defined
   * @param  {String}  opts.source.url A url to where to find the asset, or get more info about it in the source
   *                                  Optional
   * @return {Promise} Resolves with the created asset document
   */
  upload: function upload(assetType, body) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    validators.validateAssetType(assetType); // If an empty array is given, explicitly set `none` to override API defaults

    var meta = opts.extract || undefined;

    if (meta && !meta.length) {
      meta = ['none'];
    }

    var dataset = validators.hasDataset(this.client.clientConfig);
    var assetEndpoint = assetType === 'image' ? 'images' : 'files';
    var options = optionsFromFile(opts, body);
    var label = options.label,
        title = options.title,
        description = options.description,
        creditLine = options.creditLine,
        filename = options.filename,
        source = options.source;
    var query = {
      label: label,
      title: title,
      description: description,
      filename: filename,
      meta: meta,
      creditLine: creditLine
    };

    if (source) {
      query.sourceId = source.id;
      query.sourceName = source.name;
      query.sourceUrl = source.url;
    }

    var observable = this.client._requestObservable({
      method: 'POST',
      timeout: options.timeout || 0,
      uri: "/assets/".concat(assetEndpoint, "/").concat(dataset),
      headers: options.contentType ? {
        'Content-Type': options.contentType
      } : {},
      query: query,
      body: body
    });

    return this.client.isPromiseAPI() ? observable.pipe(filter(function (event) {
      return event.type === 'response';
    }), map(function (event) {
      return toDocument(event.body);
    })).toPromise() : observable;
  },
  delete: function _delete(type, id) {
    // eslint-disable-next-line no-console
    console.warn('client.assets.delete() is deprecated, please use client.delete(<document-id>)');
    var docId = id || '';

    if (!/^(image|file)-/.test(docId)) {
      docId = "".concat(type, "-").concat(docId);
    } else if (type._id) {
      // We could be passing an entire asset document instead of an ID
      docId = type._id;
    }

    validators.hasDataset(this.client.clientConfig);
    return this.client.delete(docId);
  },
  getImageUrl: function getImageUrl(ref, query) {
    var id = ref._ref || ref;

    if (typeof id !== 'string') {
      throw new Error('getImageUrl() needs either an object with a _ref, or a string with an asset document ID');
    }

    if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(id)) {
      throw new Error("Unsupported asset ID \"".concat(id, "\". URL generation only works for auto-generated IDs."));
    }

    var _id$split = id.split('-'),
        _id$split2 = _slicedToArray(_id$split, 4),
        assetId = _id$split2[1],
        size = _id$split2[2],
        format = _id$split2[3];

    validators.hasDataset(this.client.clientConfig);
    var _this$client$clientCo = this.client.clientConfig,
        projectId = _this$client$clientCo.projectId,
        dataset = _this$client$clientCo.dataset;
    var qs = query ? queryString(query) : '';
    return "https://cdn.sanity.io/images/".concat(projectId, "/").concat(dataset, "/").concat(assetId, "-").concat(size, ".").concat(format).concat(qs);
  }
});
module.exports = AssetsClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/auth/authClient.js":
/*!************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/auth/authClient.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function AuthClient(client) {
  this.client = client;
}

assign(AuthClient.prototype, {
  getLoginProviders: function getLoginProviders() {
    return this.client.request({
      uri: '/auth/providers'
    });
  },
  logout: function logout() {
    return this.client.request({
      uri: '/auth/logout',
      method: 'POST'
    });
  }
});
module.exports = AuthClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@sanity/client/lib/config.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var generateHelpUrl = __webpack_require__(/*! @sanity/generate-help-url */ "./node_modules/@sanity/generate-help-url/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var validate = __webpack_require__(/*! ./validators */ "./node_modules/@sanity/client/lib/validators.js");

var warnings = __webpack_require__(/*! ./warnings */ "./node_modules/@sanity/client/lib/warnings.js");

var defaultCdnHost = 'apicdn.sanity.io';
var defaultConfig = {
  apiHost: 'https://api.sanity.io',
  apiVersion: '1',
  useProjectHostname: true,
  gradientMode: false,
  isPromiseAPI: true
};
var LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0'];

var isLocal = function isLocal(host) {
  return LOCALHOSTS.indexOf(host) !== -1;
};

exports.defaultConfig = defaultConfig; // eslint-disable-next-line complexity

exports.initConfig = function (config, prevConfig) {
  var specifiedConfig = assign({}, prevConfig, config);

  if (!specifiedConfig.apiVersion) {
    warnings.printNoApiVersionSpecifiedWarning();
  }

  var newConfig = assign({}, defaultConfig, specifiedConfig);
  var gradientMode = newConfig.gradientMode;
  var projectBased = !gradientMode && newConfig.useProjectHostname;

  if (typeof Promise === 'undefined') {
    var helpUrl = generateHelpUrl('js-client-promise-polyfill');
    throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(helpUrl));
  }

  if (gradientMode && !newConfig.namespace) {
    throw new Error('Configuration must contain `namespace` when running in gradient mode');
  }

  if (projectBased && !newConfig.projectId) {
    throw new Error('Configuration must contain `projectId`');
  }

  var isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname;
  var isLocalhost = isBrowser && isLocal(window.location.hostname);

  if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
    warnings.printBrowserTokenWarning();
  } else if ((!isBrowser || isLocalhost) && newConfig.useCdn && newConfig.token) {
    warnings.printCdnTokenWarning();
  } else if (typeof newConfig.useCdn === 'undefined') {
    warnings.printCdnWarning();
  }

  if (projectBased) {
    validate.projectId(newConfig.projectId);
  }

  if (!gradientMode && newConfig.dataset) {
    validate.dataset(newConfig.dataset, newConfig.gradientMode);
  }

  newConfig.apiVersion = "".concat(newConfig.apiVersion).replace(/^v/, '');
  newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;
  newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.token && !newConfig.withCredentials;
  exports.validateApiVersion(newConfig.apiVersion);

  if (newConfig.gradientMode) {
    newConfig.url = newConfig.apiHost;
    newConfig.cdnUrl = newConfig.apiHost;
  } else {
    var hostParts = newConfig.apiHost.split('://', 2);
    var protocol = hostParts[0];
    var host = hostParts[1];
    var cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;

    if (newConfig.useProjectHostname) {
      newConfig.url = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(host, "/v").concat(newConfig.apiVersion);
      newConfig.cdnUrl = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(cdnHost, "/v").concat(newConfig.apiVersion);
    } else {
      newConfig.url = "".concat(newConfig.apiHost, "/v").concat(newConfig.apiVersion);
      newConfig.cdnUrl = newConfig.url;
    }
  }

  return newConfig;
};

exports.validateApiVersion = function validateApiVersion(apiVersion) {
  if (apiVersion === '1' || apiVersion === 'X') {
    return;
  }

  var apiDate = new Date(apiVersion);
  var apiVersionValid = /^\d{4}-\d{2}-\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;

  if (!apiVersionValid) {
    throw new Error('Invalid API version string, expected `1` or date in format `YYYY-MM-DD`');
  }
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/dataMethods.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/dataMethods.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require = __webpack_require__(/*! @sanity/observable/operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require.filter;

var _require2 = __webpack_require__(/*! @sanity/observable/operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require2.map;

var validators = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

var getSelection = __webpack_require__(/*! ../util/getSelection */ "./node_modules/@sanity/client/lib/util/getSelection.js");

var encodeQueryString = __webpack_require__(/*! ./encodeQueryString */ "./node_modules/@sanity/client/lib/data/encodeQueryString.js");

var Transaction = __webpack_require__(/*! ./transaction */ "./node_modules/@sanity/client/lib/data/transaction.js");

var Patch = __webpack_require__(/*! ./patch */ "./node_modules/@sanity/client/lib/data/patch.js");

var listen = __webpack_require__(/*! ./listen */ "./node_modules/@sanity/client/lib/data/listen.js");

var excludeFalsey = function excludeFalsey(param, defValue) {
  var value = typeof param === 'undefined' ? defValue : param;
  return param === false ? undefined : value;
};

var getMutationQuery = function getMutationQuery() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    returnIds: true,
    returnDocuments: excludeFalsey(options.returnDocuments, true),
    visibility: options.visibility || 'sync'
  };
};

var isResponse = function isResponse(event) {
  return event.type === 'response';
};

var getBody = function getBody(event) {
  return event.body;
};

var indexBy = function indexBy(docs, attr) {
  return docs.reduce(function (indexed, doc) {
    indexed[attr(doc)] = doc;
    return indexed;
  }, Object.create(null));
};

var toPromise = function toPromise(observable) {
  return observable.toPromise();
};

var getQuerySizeLimit = 11264;
module.exports = {
  listen: listen,
  getDataUrl: function getDataUrl(operation, path) {
    var config = this.clientConfig;
    var catalog = config.gradientMode ? config.namespace : validators.hasDataset(config);
    var baseUri = "/".concat(operation, "/").concat(catalog);
    var uri = path ? "".concat(baseUri, "/").concat(path) : baseUri;
    return (this.clientConfig.gradientMode ? uri : "/data".concat(uri)).replace(/\/($|\?)/, '$1');
  },
  fetch: function fetch(query, params) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var mapResponse = options.filterResponse === false ? function (res) {
      return res;
    } : function (res) {
      return res.result;
    };

    var observable = this._dataRequest('query', {
      query: query,
      params: params
    }, options).pipe(map(mapResponse));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  },
  getDocument: function getDocument(id) {
    var options = {
      uri: this.getDataUrl('doc', id),
      json: true
    };

    var observable = this._requestObservable(options).pipe(filter(isResponse), map(function (event) {
      return event.body.documents && event.body.documents[0];
    }));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  },
  getDocuments: function getDocuments(ids) {
    var options = {
      uri: this.getDataUrl('doc', ids.join(',')),
      json: true
    };

    var observable = this._requestObservable(options).pipe(filter(isResponse), map(function (event) {
      var indexed = indexBy(event.body.documents || [], function (doc) {
        return doc._id;
      });
      return ids.map(function (id) {
        return indexed[id] || null;
      });
    }));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  },
  create: function create(doc, options) {
    return this._create(doc, 'create', options);
  },
  createIfNotExists: function createIfNotExists(doc, options) {
    validators.requireDocumentId('createIfNotExists', doc);
    return this._create(doc, 'createIfNotExists', options);
  },
  createOrReplace: function createOrReplace(doc, options) {
    validators.requireDocumentId('createOrReplace', doc);
    return this._create(doc, 'createOrReplace', options);
  },
  patch: function patch(selector, operations) {
    return new Patch(selector, operations, this);
  },
  delete: function _delete(selection, options) {
    return this.dataRequest('mutate', {
      mutations: [{
        delete: getSelection(selection)
      }]
    }, options);
  },
  mutate: function mutate(mutations, options) {
    var mut = mutations instanceof Patch || mutations instanceof Transaction ? mutations.serialize() : mutations;
    var muts = Array.isArray(mut) ? mut : [mut];
    var transactionId = options && options.transactionId;
    return this.dataRequest('mutate', {
      mutations: muts,
      transactionId: transactionId
    }, options);
  },
  transaction: function transaction(operations) {
    return new Transaction(operations, this);
  },
  dataRequest: function dataRequest(endpoint, body) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var request = this._dataRequest(endpoint, body, options);

    return this.isPromiseAPI() ? toPromise(request) : request;
  },
  _dataRequest: function _dataRequest(endpoint, body) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var isMutation = endpoint === 'mutate'; // Check if the query string is within a configured threshold,
    // in which case we can use GET. Otherwise, use POST.

    var strQuery = !isMutation && encodeQueryString(body);
    var useGet = !isMutation && strQuery.length < getQuerySizeLimit;
    var stringQuery = useGet ? strQuery : '';
    var returnFirst = options.returnFirst;
    var timeout = options.timeout,
        token = options.token;
    var uri = this.getDataUrl(endpoint, stringQuery);
    var reqOptions = {
      method: useGet ? 'GET' : 'POST',
      uri: uri,
      json: true,
      body: useGet ? undefined : body,
      query: isMutation && getMutationQuery(options),
      timeout: timeout,
      token: token
    };
    return this._requestObservable(reqOptions).pipe(filter(isResponse), map(getBody), map(function (res) {
      if (!isMutation) {
        return res;
      } // Should we return documents?


      var results = res.results || [];

      if (options.returnDocuments) {
        return returnFirst ? results[0] && results[0].document : results.map(function (mut) {
          return mut.document;
        });
      } // Return a reduced subset


      var key = returnFirst ? 'documentId' : 'documentIds';
      var ids = returnFirst ? results[0] && results[0].id : results.map(function (mut) {
        return mut.id;
      });
      return _defineProperty({
        transactionId: res.transactionId,
        results: results
      }, key, ids);
    }));
  },
  _create: function _create(doc, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var mutation = _defineProperty({}, op, doc);

    var opts = assign({
      returnFirst: true,
      returnDocuments: true
    }, options);
    return this.dataRequest('mutate', {
      mutations: [mutation]
    }, opts);
  }
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/encodeQueryString.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/encodeQueryString.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";


var enc = encodeURIComponent;

module.exports = function (_ref) {
  var query = _ref.query,
      _ref$params = _ref.params,
      params = _ref$params === void 0 ? {} : _ref$params,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options;
  var base = "?query=".concat(enc(query));
  var qString = Object.keys(params).reduce(function (qs, param) {
    return "".concat(qs, "&").concat(enc("$".concat(param)), "=").concat(enc(JSON.stringify(params[param])));
  }, base);
  return Object.keys(options).reduce(function (qs, option) {
    // Only include the option if it is truthy
    return options[option] ? "".concat(qs, "&").concat(enc(option), "=").concat(enc(options[option])) : qs;
  }, qString);
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/listen.js":
/*!********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/listen.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var Observable = __webpack_require__(/*! @sanity/observable/minimal */ "./node_modules/@sanity/observable/minimal.js");

var polyfilledEventSource = __webpack_require__(/*! @sanity/eventsource */ "./node_modules/@sanity/eventsource/browser.js");

var pick = __webpack_require__(/*! ../util/pick */ "./node_modules/@sanity/client/lib/util/pick.js");

var defaults = __webpack_require__(/*! ../util/defaults */ "./node_modules/@sanity/client/lib/util/defaults.js");

var encodeQueryString = __webpack_require__(/*! ./encodeQueryString */ "./node_modules/@sanity/client/lib/data/encodeQueryString.js");

var generateHelpUrl = __webpack_require__(/*! @sanity/generate-help-url */ "./node_modules/@sanity/generate-help-url/index.js");

var once = __webpack_require__(/*! ../util/once */ "./node_modules/@sanity/client/lib/util/once.js");

var tokenWarning = ['Using token with listeners is not supported in browsers. ', "For more info, see ".concat(generateHelpUrl('js-client-listener-tokens-browser'), ".")]; // eslint-disable-next-line no-console

var printTokenWarning = once(function () {
  return console.warn(tokenWarning.join(' '));
});
var isWindowEventSource = Boolean(typeof window !== 'undefined' && window.EventSource);
var EventSource = isWindowEventSource ? window.EventSource // Native browser EventSource
: polyfilledEventSource; // Node.js, IE etc

var possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat'];
var defaultOptions = {
  includeResult: true
};

module.exports = function listen(query, params) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var options = defaults(opts, defaultOptions);
  var listenOpts = pick(options, possibleOptions);
  var qs = encodeQueryString({
    query: query,
    params: params,
    options: listenOpts
  });
  var _this$clientConfig = this.clientConfig,
      url = _this$clientConfig.url,
      token = _this$clientConfig.token,
      withCredentials = _this$clientConfig.withCredentials;
  var uri = "".concat(url).concat(this.getDataUrl('listen', qs));
  var listenFor = options.events ? options.events : ['mutation'];
  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;

  if (token && isWindowEventSource) {
    printTokenWarning();
  }

  var esOptions = {};

  if (token || withCredentials) {
    esOptions.withCredentials = true;
  }

  if (token) {
    esOptions.headers = {
      Authorization: "Bearer ".concat(token)
    };
  }

  return new Observable(function (observer) {
    var es = getEventSource();
    var reconnectTimer;
    var stopped = false;

    function onError() {
      if (stopped) {
        return;
      }

      emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt

      if (stopped) {
        return;
      } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),
      // we should never be in a disconnected state. By default, EventSource will reconnect
      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases
      // (like when a laptop lid is closed), it closes the connection. In these cases we need
      // to explicitly reconnect.


      if (es.readyState === EventSource.CLOSED) {
        unsubscribe();
        clearTimeout(reconnectTimer);
        reconnectTimer = setTimeout(open, 100);
      }
    }

    function onChannelError(err) {
      observer.error(cooerceError(err));
    }

    function onMessage(evt) {
      var event = parseEvent(evt);
      return event instanceof Error ? observer.error(event) : observer.next(event);
    }

    function onDisconnect(evt) {
      stopped = true;
      unsubscribe();
      observer.complete();
    }

    function unsubscribe() {
      es.removeEventListener('error', onError, false);
      es.removeEventListener('channelError', onChannelError, false);
      es.removeEventListener('disconnect', onDisconnect, false);
      listenFor.forEach(function (type) {
        return es.removeEventListener(type, onMessage, false);
      });
      es.close();
    }

    function emitReconnect() {
      if (shouldEmitReconnect) {
        observer.next({
          type: 'reconnect'
        });
      }
    }

    function getEventSource() {
      var evs = new EventSource(uri, esOptions);
      evs.addEventListener('error', onError, false);
      evs.addEventListener('channelError', onChannelError, false);
      evs.addEventListener('disconnect', onDisconnect, false);
      listenFor.forEach(function (type) {
        return evs.addEventListener(type, onMessage, false);
      });
      return evs;
    }

    function open() {
      es = getEventSource();
    }

    function stop() {
      stopped = true;
      unsubscribe();
    }

    return stop;
  });
};

function parseEvent(event) {
  try {
    var data = event.data && JSON.parse(event.data) || {};
    return assign({
      type: event.type
    }, data);
  } catch (err) {
    return err;
  }
}

function cooerceError(err) {
  if (err instanceof Error) {
    return err;
  }

  var evt = parseEvent(err);
  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
}

function extractErrorMessage(err) {
  if (!err.error) {
    return err.message || 'Unknown listener error';
  }

  if (err.error.description) {
    return err.error.description;
  }

  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);
}

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/patch.js":
/*!*******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/patch.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var deepAssign = __webpack_require__(/*! deep-assign */ "./node_modules/deep-assign/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var getSelection = __webpack_require__(/*! ../util/getSelection */ "./node_modules/@sanity/client/lib/util/getSelection.js");

var validate = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

var validateObject = validate.validateObject;
var validateInsert = validate.validateInsert;

function Patch(selection) {
  var operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var client = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  this.selection = selection;
  this.operations = assign({}, operations);
  this.client = client;
}

assign(Patch.prototype, {
  clone: function clone() {
    return new Patch(this.selection, assign({}, this.operations), this.client);
  },
  merge: function merge(props) {
    validateObject('merge', props);
    var stack = new Error().stack.toString().split('\n').filter(function (str) {
      return str.trim();
    }).slice(2);
    console.warn("The \"merge\" patch has been deprecated and will be removed in the future\n".concat(stack.join('\n')));
    return this._assign('merge', deepAssign(this.operations.merge || {}, props));
  },
  set: function set(props) {
    return this._assign('set', props);
  },
  diffMatchPatch: function diffMatchPatch(props) {
    validateObject('diffMatchPatch', props);
    return this._assign('diffMatchPatch', props);
  },
  unset: function unset(attrs) {
    if (!Array.isArray(attrs)) {
      throw new Error('unset(attrs) takes an array of attributes to unset, non-array given');
    }

    this.operations = assign({}, this.operations, {
      unset: attrs
    });
    return this;
  },
  setIfMissing: function setIfMissing(props) {
    return this._assign('setIfMissing', props);
  },
  replace: function replace(props) {
    validateObject('replace', props);
    return this._set('set', {
      $: props
    }); // eslint-disable-line id-length
  },
  inc: function inc(props) {
    return this._assign('inc', props);
  },
  dec: function dec(props) {
    return this._assign('dec', props);
  },
  insert: function insert(at, selector, items) {
    var _this$_assign;

    validateInsert(at, selector, items);
    return this._assign('insert', (_this$_assign = {}, _defineProperty(_this$_assign, at, selector), _defineProperty(_this$_assign, "items", items), _this$_assign));
  },
  append: function append(selector, items) {
    return this.insert('after', "".concat(selector, "[-1]"), items);
  },
  prepend: function prepend(selector, items) {
    return this.insert('before', "".concat(selector, "[0]"), items);
  },
  splice: function splice(selector, start, deleteCount, items) {
    // Negative indexes doesn't mean the same in Sanity as they do in JS;
    // -1 means "actually at the end of the array", which allows inserting
    // at the end of the array without knowing its length. We therefore have
    // to substract negative indexes by one to match JS. If you want Sanity-
    // behaviour, just use `insert('replace', selector, items)` directly
    var delAll = typeof deleteCount === 'undefined' || deleteCount === -1;
    var startIndex = start < 0 ? start - 1 : start;
    var delCount = delAll ? -1 : Math.max(0, start + deleteCount);
    var delRange = startIndex < 0 && delCount >= 0 ? '' : delCount;
    var rangeSelector = "".concat(selector, "[").concat(startIndex, ":").concat(delRange, "]");
    return this.insert('replace', rangeSelector, items || []);
  },
  ifRevisionId: function ifRevisionId(rev) {
    this.operations.ifRevisionID = rev;
    return this;
  },
  serialize: function serialize() {
    return assign(getSelection(this.selection), this.operations);
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!this.client) {
      throw new Error('No `client` passed to patch, either provide one or pass the ' + 'patch to a clients `mutate()` method');
    }

    var returnFirst = typeof this.selection === 'string';
    var opts = assign({
      returnFirst: returnFirst,
      returnDocuments: true
    }, options);
    return this.client.mutate({
      patch: this.serialize()
    }, opts);
  },
  reset: function reset() {
    this.operations = {};
    return this;
  },
  _set: function _set(op, props) {
    return this._assign(op, props, false);
  },
  _assign: function _assign(op, props) {
    var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    validateObject(op, props);
    this.operations = assign({}, this.operations, _defineProperty({}, op, assign({}, merge && this.operations[op] || {}, props)));
    return this;
  }
});
module.exports = Patch;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/transaction.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/transaction.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var validators = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

var Patch = __webpack_require__(/*! ./patch */ "./node_modules/@sanity/client/lib/data/patch.js");

var defaultMutateOptions = {
  returnDocuments: false
};

function Transaction() {
  var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var client = arguments.length > 1 ? arguments[1] : undefined;
  var transactionId = arguments.length > 2 ? arguments[2] : undefined;
  this.trxId = transactionId;
  this.operations = operations;
  this.client = client;
}

assign(Transaction.prototype, {
  clone: function clone() {
    return new Transaction(this.operations.slice(0), this.client, this.trxId);
  },
  create: function create(doc) {
    validators.validateObject('create', doc);
    return this._add({
      create: doc
    });
  },
  createIfNotExists: function createIfNotExists(doc) {
    var op = 'createIfNotExists';
    validators.validateObject(op, doc);
    validators.requireDocumentId(op, doc);
    return this._add(_defineProperty({}, op, doc));
  },
  createOrReplace: function createOrReplace(doc) {
    var op = 'createOrReplace';
    validators.validateObject(op, doc);
    validators.requireDocumentId(op, doc);
    return this._add(_defineProperty({}, op, doc));
  },
  delete: function _delete(documentId) {
    validators.validateDocumentId('delete', documentId);
    return this._add({
      delete: {
        id: documentId
      }
    });
  },
  patch: function patch(documentId, patchOps) {
    var isBuilder = typeof patchOps === 'function';
    var isPatch = documentId instanceof Patch; // transaction.patch(client.patch('documentId').inc({visits: 1}))

    if (isPatch) {
      return this._add({
        patch: documentId.serialize()
      });
    } // patch => patch.inc({visits: 1}).set({foo: 'bar'})


    if (isBuilder) {
      var patch = patchOps(new Patch(documentId, {}, this.client));

      if (!(patch instanceof Patch)) {
        throw new Error('function passed to `patch()` must return the patch');
      }

      return this._add({
        patch: patch.serialize()
      });
    }

    return this._add({
      patch: assign({
        id: documentId
      }, patchOps)
    });
  },
  transactionId: function transactionId(id) {
    if (!id) {
      return this.trxId;
    }

    this.trxId = id;
    return this;
  },
  serialize: function serialize() {
    return this.operations.slice();
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit(options) {
    if (!this.client) {
      throw new Error('No `client` passed to transaction, either provide one or pass the ' + 'transaction to a clients `mutate()` method');
    }

    return this.client.mutate(this.serialize(), assign({
      transactionId: this.trxId
    }, defaultMutateOptions, options || {}));
  },
  reset: function reset() {
    this.operations = [];
    return this;
  },
  _add: function _add(mut) {
    this.operations.push(mut);
    return this;
  }
});
module.exports = Transaction;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/datasets/datasetsClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/datasets/datasetsClient.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var validate = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

function DatasetsClient(client) {
  this.request = client.request.bind(client);
}

assign(DatasetsClient.prototype, {
  create: function create(name, options) {
    return this._modify('PUT', name, options);
  },
  edit: function edit(name, options) {
    return this._modify('PATCH', name, options);
  },
  delete: function _delete(name) {
    return this._modify('DELETE', name);
  },
  list: function list() {
    return this.request({
      uri: '/datasets'
    });
  },
  _modify: function _modify(method, name, body) {
    validate.dataset(name);
    return this.request({
      method: method,
      uri: "/datasets/".concat(name),
      body: body
    });
  }
});
module.exports = DatasetsClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/browserMiddleware.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/browserMiddleware.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = [];

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/errors.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var makeError = __webpack_require__(/*! make-error */ "./node_modules/make-error/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function ClientError(res) {
  var props = extractErrorProps(res);
  ClientError.super.call(this, props.message);
  assign(this, props);
}

function ServerError(res) {
  var props = extractErrorProps(res);
  ServerError.super.call(this, props.message);
  assign(this, props);
}

function extractErrorProps(res) {
  var body = res.body;
  var props = {
    response: res,
    statusCode: res.statusCode,
    responseBody: stringifyBody(body, res)
  }; // API/Boom style errors ({statusCode, error, message})

  if (body.error && body.message) {
    props.message = "".concat(body.error, " - ").concat(body.message);
    return props;
  } // Query/database errors ({error: {description, other, arb, props}})


  if (body.error && body.error.description) {
    props.message = body.error.description;
    props.details = body.error;
    return props;
  } // Other, more arbitrary errors


  props.message = body.error || body.message || httpErrorMessage(res);
  return props;
}

function httpErrorMessage(res) {
  var statusMessage = res.statusMessage ? " ".concat(res.statusMessage) : '';
  return "".concat(res.method, "-request to ").concat(res.url, " resulted in HTTP ").concat(res.statusCode).concat(statusMessage);
}

function stringifyBody(body, res) {
  var contentType = (res.headers['content-type'] || '').toLowerCase();
  var isJson = contentType.indexOf('application/json') !== -1;
  return isJson ? JSON.stringify(body, null, 2) : body;
}

makeError(ClientError);
makeError(ServerError);
exports.ClientError = ClientError;
exports.ServerError = ServerError;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/queryString.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/queryString.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (params) {
  var qs = [];

  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(params[key])));
    }
  }

  return qs.length > 0 ? "?".concat(qs.join('&')) : '';
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/request.js":
/*!*********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/request.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


/* eslint-disable no-empty-function, no-process-env */
var getIt = __webpack_require__(/*! get-it */ "./node_modules/get-it/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var observable = __webpack_require__(/*! get-it/lib/middleware/observable */ "./node_modules/get-it/lib/middleware/observable.js");

var jsonRequest = __webpack_require__(/*! get-it/lib/middleware/jsonRequest */ "./node_modules/get-it/lib/middleware/jsonRequest.js");

var jsonResponse = __webpack_require__(/*! get-it/lib/middleware/jsonResponse */ "./node_modules/get-it/lib/middleware/jsonResponse.js");

var progress = __webpack_require__(/*! get-it/lib/middleware/progress */ "./node_modules/get-it/lib/middleware/progress/index.js");

var Observable = __webpack_require__(/*! @sanity/observable/minimal */ "./node_modules/@sanity/observable/minimal.js");

var _require = __webpack_require__(/*! ./errors */ "./node_modules/@sanity/client/lib/http/errors.js"),
    ClientError = _require.ClientError,
    ServerError = _require.ServerError;

var httpError = {
  onResponse: function onResponse(res) {
    if (res.statusCode >= 500) {
      throw new ServerError(res);
    } else if (res.statusCode >= 400) {
      throw new ClientError(res);
    }

    return res;
  }
};
var printWarnings = {
  onResponse: function onResponse(res) {
    var warn = res.headers['x-sanity-warning'];
    var warnings = Array.isArray(warn) ? warn : [warn];
    warnings.filter(Boolean).forEach(function (msg) {
      return console.warn(msg);
    }); // eslint-disable-line no-console

    return res;
  }
}; // Environment-specific middleware.

var envSpecific = __webpack_require__(/*! ./nodeMiddleware */ "./node_modules/@sanity/client/lib/http/browserMiddleware.js");

var middleware = envSpecific.concat([printWarnings, jsonRequest(), jsonResponse(), progress(), httpError, observable({
  implementation: Observable
})]);
var request = getIt(middleware);

function httpRequest(options) {
  var requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : request;
  return requester(assign({
    maxRedirects: 0
  }, options));
}

httpRequest.defaultRequester = request;
httpRequest.ClientError = ClientError;
httpRequest.ServerError = ServerError;
module.exports = httpRequest;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/requestOptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/requestOptions.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var projectHeader = 'X-Sanity-Project-ID';

module.exports = function (config) {
  var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var headers = {};
  var token = overrides.token || config.token;

  if (token) {
    headers.Authorization = "Bearer ".concat(token);
  }

  if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
    headers[projectHeader] = config.projectId;
  }

  var withCredentials = Boolean(typeof overrides.withCredentials === 'undefined' ? config.token || config.withCredentials : overrides.withCredentials);
  var timeout = typeof overrides.timeout === 'undefined' ? config.timeout : overrides.timeout;
  return assign({}, overrides, {
    headers: assign({}, headers, overrides.headers || {}),
    timeout: typeof timeout === 'undefined' ? 5 * 60 * 1000 : timeout,
    json: true,
    withCredentials: withCredentials
  });
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/projects/projectsClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/projects/projectsClient.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function ProjectsClient(client) {
  this.client = client;
}

assign(ProjectsClient.prototype, {
  list: function list() {
    return this.client.request({
      uri: '/projects'
    });
  },
  getById: function getById(id) {
    return this.client.request({
      uri: "/projects/".concat(id)
    });
  }
});
module.exports = ProjectsClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/sanityClient.js":
/*!*********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/sanityClient.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require = __webpack_require__(/*! @sanity/observable/operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require.filter;

var _require2 = __webpack_require__(/*! @sanity/observable/operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require2.map;

var Patch = __webpack_require__(/*! ./data/patch */ "./node_modules/@sanity/client/lib/data/patch.js");

var Transaction = __webpack_require__(/*! ./data/transaction */ "./node_modules/@sanity/client/lib/data/transaction.js");

var dataMethods = __webpack_require__(/*! ./data/dataMethods */ "./node_modules/@sanity/client/lib/data/dataMethods.js");

var DatasetsClient = __webpack_require__(/*! ./datasets/datasetsClient */ "./node_modules/@sanity/client/lib/datasets/datasetsClient.js");

var ProjectsClient = __webpack_require__(/*! ./projects/projectsClient */ "./node_modules/@sanity/client/lib/projects/projectsClient.js");

var AssetsClient = __webpack_require__(/*! ./assets/assetsClient */ "./node_modules/@sanity/client/lib/assets/assetsClient.js");

var UsersClient = __webpack_require__(/*! ./users/usersClient */ "./node_modules/@sanity/client/lib/users/usersClient.js");

var AuthClient = __webpack_require__(/*! ./auth/authClient */ "./node_modules/@sanity/client/lib/auth/authClient.js");

var httpRequest = __webpack_require__(/*! ./http/request */ "./node_modules/@sanity/client/lib/http/request.js");

var getRequestOptions = __webpack_require__(/*! ./http/requestOptions */ "./node_modules/@sanity/client/lib/http/requestOptions.js");

var _require3 = __webpack_require__(/*! ./config */ "./node_modules/@sanity/client/lib/config.js"),
    defaultConfig = _require3.defaultConfig,
    initConfig = _require3.initConfig;

var toPromise = function toPromise(observable) {
  return observable.toPromise();
};

function SanityClient() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;

  if (!(this instanceof SanityClient)) {
    return new SanityClient(config);
  }

  this.config(config);
  this.assets = new AssetsClient(this);
  this.datasets = new DatasetsClient(this);
  this.projects = new ProjectsClient(this);
  this.users = new UsersClient(this);
  this.auth = new AuthClient(this);

  if (this.clientConfig.isPromiseAPI) {
    var observableConfig = assign({}, this.clientConfig, {
      isPromiseAPI: false
    });
    this.observable = new SanityClient(observableConfig);
  }
}

assign(SanityClient.prototype, dataMethods);
assign(SanityClient.prototype, {
  clone: function clone() {
    return new SanityClient(this.config());
  },
  config: function config(newConfig) {
    if (typeof newConfig === 'undefined') {
      return assign({}, this.clientConfig);
    }

    if (this.observable) {
      var observableConfig = assign({}, newConfig, {
        isPromiseAPI: false
      });
      this.observable.config(observableConfig);
    }

    this.clientConfig = initConfig(newConfig, this.clientConfig || {});
    return this;
  },
  withConfig: function withConfig(newConfig) {
    return this.clone().config(newConfig);
  },
  getUrl: function getUrl(uri) {
    var canUseCdn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var base = canUseCdn ? this.clientConfig.cdnUrl : this.clientConfig.url;
    return "".concat(base, "/").concat(uri.replace(/^\//, ''));
  },
  isPromiseAPI: function isPromiseAPI() {
    return this.clientConfig.isPromiseAPI;
  },
  _requestObservable: function _requestObservable(options) {
    var uri = options.url || options.uri;
    var canUseCdn = this.clientConfig.useCdn && ['GET', 'HEAD'].indexOf(options.method || 'GET') >= 0 && uri.indexOf('/data/') === 0;
    var reqOptions = getRequestOptions(this.clientConfig, assign({}, options, {
      url: this.getUrl(uri, canUseCdn)
    }));
    return httpRequest(reqOptions, this.clientConfig.requester);
  },
  request: function request(options) {
    var observable = this._requestObservable(options).pipe(filter(function (event) {
      return event.type === 'response';
    }), map(function (event) {
      return event.body;
    }));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  }
});
SanityClient.Patch = Patch;
SanityClient.Transaction = Transaction;
SanityClient.ClientError = httpRequest.ClientError;
SanityClient.ServerError = httpRequest.ServerError;
SanityClient.requester = httpRequest.defaultRequester;
module.exports = SanityClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/users/usersClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/users/usersClient.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function UsersClient(client) {
  this.client = client;
}

assign(UsersClient.prototype, {
  getById: function getById(id) {
    return this.client.request({
      uri: "/users/".concat(id)
    });
  }
});
module.exports = UsersClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/defaults.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/defaults.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (obj, defaults) {
  return Object.keys(defaults).concat(Object.keys(obj)).reduce(function (target, prop) {
    target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop];
    return target;
  }, {});
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/getSelection.js":
/*!**************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/getSelection.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function getSelection(sel) {
  if (typeof sel === 'string' || Array.isArray(sel)) {
    return {
      id: sel
    };
  }

  if (sel && sel.query) {
    return {
      query: sel.query
    };
  }

  var selectionOpts = ['* Document ID (<docId>)', '* Array of document IDs', '* Object containing `query`'].join('\n');
  throw new Error("Unknown selection - must be one of:\n\n".concat(selectionOpts));
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/once.js":
/*!******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/once.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (fn) {
  var didCall = false;
  var returnValue;
  return function () {
    if (didCall) {
      return returnValue;
    }

    returnValue = fn.apply(void 0, arguments);
    didCall = true;
    return returnValue;
  };
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/pick.js":
/*!******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/pick.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (obj, props) {
  return props.reduce(function (selection, prop) {
    if (typeof obj[prop] === 'undefined') {
      return selection;
    }

    selection[prop] = obj[prop];
    return selection;
  }, {});
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/validators.js":
/*!*******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/validators.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var VALID_ASSET_TYPES = ['image', 'file'];
var VALID_INSERT_LOCATIONS = ['before', 'after', 'replace'];

exports.dataset = function (name) {
  if (!/^(~[a-z0-9]{1}[-\w]{0,25}|[a-z0-9]{1}[-\w]{0,19})$/.test(name)) {
    throw new Error('Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 20 characters');
  }
};

exports.projectId = function (id) {
  if (!/^[-a-z0-9]+$/i.test(id)) {
    throw new Error('`projectId` can only contain only a-z, 0-9 and dashes');
  }
};

exports.validateAssetType = function (type) {
  if (VALID_ASSET_TYPES.indexOf(type) === -1) {
    throw new Error("Invalid asset type: ".concat(type, ". Must be one of ").concat(VALID_ASSET_TYPES.join(', ')));
  }
};

exports.validateObject = function (op, val) {
  if (val === null || _typeof(val) !== 'object' || Array.isArray(val)) {
    throw new Error("".concat(op, "() takes an object of properties"));
  }
};

exports.requireDocumentId = function (op, doc) {
  if (!doc._id) {
    throw new Error("".concat(op, "() requires that the document contains an ID (\"_id\" property)"));
  }

  exports.validateDocumentId(op, doc._id);
};

exports.validateDocumentId = function (op, id) {
  if (typeof id !== 'string' || !/^[a-z0-9_.-]+$/i.test(id)) {
    throw new Error("".concat(op, "(): \"").concat(id, "\" is not a valid document ID"));
  }
};

exports.validateInsert = function (at, selector, items) {
  var signature = 'insert(at, selector, items)';

  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
    var valid = VALID_INSERT_LOCATIONS.map(function (loc) {
      return "\"".concat(loc, "\"");
    }).join(', ');
    throw new Error("".concat(signature, " takes an \"at\"-argument which is one of: ").concat(valid));
  }

  if (typeof selector !== 'string') {
    throw new Error("".concat(signature, " takes a \"selector\"-argument which must be a string"));
  }

  if (!Array.isArray(items)) {
    throw new Error("".concat(signature, " takes an \"items\"-argument which must be an array"));
  }
};

exports.hasDataset = function (config) {
  if (!config.gradientMode && !config.dataset) {
    throw new Error('`dataset` must be provided to perform queries');
  }

  return config.dataset || '';
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/warnings.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sanity/client/lib/warnings.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


var generateHelpUrl = __webpack_require__(/*! @sanity/generate-help-url */ "./node_modules/@sanity/generate-help-url/index.js");

var once = __webpack_require__(/*! ./util/once */ "./node_modules/@sanity/client/lib/util/once.js");

var createWarningPrinter = function createWarningPrinter(message) {
  return (// eslint-disable-next-line no-console
    once(function () {
      var _console;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_console = console).warn.apply(_console, [message.join(' ')].concat(args));
    })
  );
};

exports.printCdnWarning = createWarningPrinter(['You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and', "cheaper. Think about it! For more info, see ".concat(generateHelpUrl('js-client-cdn-configuration'), "."), 'To hide this warning, please set the `useCdn` option to either `true` or `false` when creating', 'the client.']);
exports.printBrowserTokenWarning = createWarningPrinter(['You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.', "See ".concat(generateHelpUrl('js-client-browser-token'), " for more information and how to hide this warning.")]);
exports.printCdnTokenWarning = createWarningPrinter(['You have set `useCdn` to `true` while also specifying a token. This is usually not what you', 'want. The CDN cannot be used with an authorization token, since private data cannot be cached.', "See ".concat(generateHelpUrl('js-client-usecdn-token'), " for more information.")]);
exports.printNoApiVersionSpecifiedWarning = createWarningPrinter(['Using the Sanity client without specifying an API version is deprecated.', "See ".concat(generateHelpUrl('js-client-api-version'))]);

/***/ }),

/***/ "./node_modules/@sanity/eventsource/browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sanity/eventsource/browser.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-var */
var evs = __webpack_require__(/*! @rexxars/eventsource-polyfill */ "./node_modules/@rexxars/eventsource-polyfill/src/eventsource.js")

module.exports = window.EventSource || evs.EventSource


/***/ }),

/***/ "./node_modules/@sanity/generate-help-url/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@sanity/generate-help-url/index.js ***!
  \*********************************************************/
/***/ ((module) => {

var baseUrl = 'https://docs.sanity.io/help/'

module.exports = function generateHelpUrl(slug) {
  return baseUrl + slug
}


/***/ }),

/***/ "./node_modules/@sanity/observable/lib/SanityObservableMinimal.js":
/*!************************************************************************!*\
  !*** ./node_modules/@sanity/observable/lib/SanityObservableMinimal.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


var _require = __webpack_require__(/*! rxjs/internal/Observable */ "./node_modules/rxjs/internal/Observable.js"),
    Observable = _require.Observable;

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require2 = __webpack_require__(/*! ../operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require2.map;

var _require3 = __webpack_require__(/*! ../operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require3.filter;

var _require4 = __webpack_require__(/*! ../operators/reduce */ "./node_modules/@sanity/observable/operators/reduce.js"),
    reduce = _require4.reduce;
/*
 A minimal rxjs based observable that align as closely as possible with the current es-observable spec,
 without the static factory methods
 */


function SanityObservableMinimal() {
  Observable.apply(this, arguments); // eslint-disable-line prefer-rest-params
}

SanityObservableMinimal.prototype = Object.create(assign(Object.create(null), Observable.prototype));
Object.defineProperty(SanityObservableMinimal.prototype, 'constructor', {
  value: SanityObservableMinimal,
  enumerable: false,
  writable: true,
  configurable: true
});

SanityObservableMinimal.prototype.lift = function lift(operator) {
  var observable = new SanityObservableMinimal();
  observable.source = this;
  observable.operator = operator;
  return observable;
};

function createDeprecatedMemberOp(name, op) {
  var hasWarned = false;
  return function deprecatedOperator() {
    if (!hasWarned) {
      hasWarned = true;
      console.warn(new Error("Calling observable.".concat(name, "(...) is deprecated. Please use observable.pipe(").concat(name, "(...)) instead")));
    }

    return this.pipe(op.apply(this, arguments));
  };
}

SanityObservableMinimal.prototype.map = createDeprecatedMemberOp('map', map);
SanityObservableMinimal.prototype.filter = createDeprecatedMemberOp('filter', filter);
SanityObservableMinimal.prototype.reduce = createDeprecatedMemberOp('filter', reduce);
module.exports = SanityObservableMinimal;

/***/ }),

/***/ "./node_modules/@sanity/observable/minimal.js":
/*!****************************************************!*\
  !*** ./node_modules/@sanity/observable/minimal.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/SanityObservableMinimal */ "./node_modules/@sanity/observable/lib/SanityObservableMinimal.js")


/***/ }),

/***/ "./node_modules/@sanity/observable/operators/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/observable/operators/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.filter = __webpack_require__(/*! rxjs/internal/operators/filter */ "./node_modules/rxjs/internal/operators/filter.js").filter


/***/ }),

/***/ "./node_modules/@sanity/observable/operators/map.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sanity/observable/operators/map.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.map = __webpack_require__(/*! rxjs/internal/operators/map */ "./node_modules/rxjs/internal/operators/map.js").map


/***/ }),

/***/ "./node_modules/@sanity/observable/operators/reduce.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/observable/operators/reduce.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.reduce = __webpack_require__(/*! rxjs/internal/operators/reduce */ "./node_modules/rxjs/internal/operators/reduce.js").reduce


/***/ }),

/***/ "./node_modules/array-filter/index.js":
/*!********************************************!*\
  !*** ./node_modules/array-filter/index.js ***!
  \********************************************/
/***/ ((module) => {


/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;


/***/ }),

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/assert/build/internal/errors.js"),
    _require$codes = _require.codes,
    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;

var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/assert/build/internal/assert/assertion_error.js");

var _require2 = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require2.inspect;

var _require$types = __webpack_require__(/*! util/ */ "./node_modules/util/util.js").types,
    isPromise = _require$types.isPromise,
    isRegExp = _require$types.isRegExp;

var objectAssign = Object.assign ? Object.assign : __webpack_require__(/*! es6-object-assign */ "./node_modules/es6-object-assign/index.js").assign;
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;

function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/assert/build/internal/util/comparisons.js");

  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex


var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];

var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};

var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}

function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }

    if (argsLen === 2) operator = '!=';
  }

  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };

  if (message !== undefined) {
    errArgs.message = message;
  }

  var err = new AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
}

assert.fail = fail; // The AssertionError is defined in internal/error.

assert.AssertionError = AssertionError;

function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.


function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  innerOk.apply(void 0, [ok, args.length].concat(args));
}

assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.

/* eslint-disable no-restricted-properties */

assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.


assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
}; // The equivalence assertion tests a deep equality relation.


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
}; // The non-equivalence assertion tests for any deep inequality.


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */


assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

var Comparison = function Comparison(obj, keys, actual) {
  var _this = this;

  _classCallCheck(this, Comparison);

  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }

    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.


    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }

    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }

    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }

      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.


  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}

function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;

    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }

    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }

    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }

    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }

    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }

  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};

assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};

assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};

assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};

assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';

    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    }); // Make sure we actually have a stack trace!

    var origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift(); // Filter all frames existing in err.stack.

      var tmp1 = newErr.stack.split('\n');

      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);

        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }

      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }

    throw newErr;
  }
}; // Expose a strict only variant of assert


function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  innerOk.apply(void 0, [strict, args.length].concat(args));
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require.inspect;

var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/assert/build/internal/errors.js"),
    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat


function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));

  while (count) {
    str += str;
    count--;
  }

  str += str.substring(0, maxCount - str.length);
  return str;
}

var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

var kMaxShortLength = 10;

function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}

function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}

function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.


  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;

      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.


        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).


  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];

  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }

    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.


    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);

      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }

    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }

  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }

  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }

  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");

  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;

    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the expected line to the cache.

      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the actual line to the result.

      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }

      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }

          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.


        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)


    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }

  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}

var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    _classCallCheck(this, AssertionError);

    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    var message = options.message,
        operator = options.operator,
        stackStartFn = options.stackStartFn;
    var actual = options.actual,
        expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;

    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.


      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.


        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);

          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.


        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = inspectValue(actual);

        var other = '';
        var knownOperators = kReadableOperator[operator];

        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);

          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));

          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }

          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }

          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }

    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;

    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.


    _this.stack; // Reset the name.

    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }

  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);

  return AssertionError;
}(_wrapNativeSuper(Error));

module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */

/* eslint node-core/alphabetize-errors: "error" */

/* eslint node-core/prefer-util-format-errors: "error" */
 // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var codes = {}; // Lazy loaded

var assert;
var util;

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inherits(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }

    return NodeError;
  }(Base);

  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
  var inspected = util.inspect(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;

  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }

  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });

  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;

    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }

  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var regexFlagsSupported = /a/g.flags !== undefined;

var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};

var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};

var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/is-nan/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);

var _require$types = __webpack_require__(/*! util/ */ "./node_modules/util/util.js").types,
    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
    isArrayBufferView = _require$types.isArrayBufferView,
    isDate = _require$types.isDate,
    isMap = _require$types.isMap,
    isRegExp = _require$types.isRegExp,
    isSet = _require$types.isSet,
    isNativeError = _require$types.isNativeError,
    isBoxedPrimitive = _require$types.isBoxedPrimitive,
    isNumberObject = _require$types.isNumberObject,
    isStringObject = _require$types.isStringObject,
    isBooleanObject = _require$types.isBooleanObject,
    isBigIntObject = _require$types.isBigIntObject,
    isSymbolObject = _require$types.isSymbolObject,
    isFloat32Array = _require$types.isFloat32Array,
    isFloat64Array = _require$types.isFloat64Array;

function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;

  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.


  return key.length === 10 && key >= Math.pow(2, 32);
}

function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags

function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}

function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }

  return true;
}

function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}

function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}

function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }

  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }

  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }

  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }

  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.


function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.


  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }

    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }

    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }

  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);

  if (val1Tag !== val2Tag) {
    return false;
  }

  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }

    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (keys1.length !== keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.


  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }

  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.


    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);

    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (_keys.length !== _keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return keyCheck(val1, val2, strict, memos, kNoIterator);
}

function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}

function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test


  var i = 0;

  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);

    if (symbolKeysA.length !== 0) {
      var count = 0;

      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];

        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }

          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      var symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.


  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}

function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];

    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }

  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').


function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;

    case 'object':
      // Only pass in null as object!
      return undefined;

    case 'symbol':
      return false;

    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }

  }

  return true;
}

function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}

function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = b.get(altValue);

  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}

function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);

  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.


      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }

      set.add(val);
    }
  }

  if (set !== null) {
    var bValues = arrayFromSet(b);

    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];

    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);

  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
        key = _aEntries$i[0],
        item1 = _aEntries$i[1];

    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }

      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);

      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;

        if (set === null) {
          set = new Set();
        }

        set.add(key);
      }
    }
  }

  if (set !== null) {
    var bEntries = arrayFromMap(b);

    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
          key = _bEntries$_i[0],
          item = _bEntries$_i[1];

      if (_typeof(key) === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;

  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);

        for (; i < keysA.length; i++) {
          var key = keysA[i];

          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== Object.keys(b).length) {
          return false;
        }

        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:


  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }

  return true;
}

function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}

function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var filter = __webpack_require__(/*! array-filter */ "./node_modules/array-filter/index.js");

module.exports = function availableTypedArrays() {
	return filter([
		'BigInt64Array',
		'BigUint64Array',
		'Float32Array',
		'Float64Array',
		'Int16Array',
		'Int32Array',
		'Int8Array',
		'Uint16Array',
		'Uint32Array',
		'Uint8Array',
		'Uint8ClampedArray'
	], function (typedArray) {
		return typeof __webpack_require__.g[typedArray] === 'function';
	});
};


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global window, global*/
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


/***/ }),

/***/ "./node_modules/deep-assign/index.js":
/*!*******************************************!*\
  !*** ./node_modules/deep-assign/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObj = __webpack_require__(/*! is-obj */ "./node_modules/is-obj/index.js");
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Sources cannot be null or undefined');
	}

	return Object(val);
}

function assignKey(to, from, key) {
	var val = from[key];

	if (val === undefined || val === null) {
		return;
	}

	if (hasOwnProperty.call(to, key)) {
		if (to[key] === undefined || to[key] === null) {
			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
		}
	}

	if (!hasOwnProperty.call(to, key) || !isObj(val)) {
		to[key] = val;
	} else {
		to[key] = assign(Object(to[key]), from[key]);
	}
}

function assign(to, from) {
	if (to === from) {
		return to;
	}

	from = Object(from);

	for (var key in from) {
		if (hasOwnProperty.call(from, key)) {
			assignKey(to, from, key);
		}
	}

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(from);

		for (var i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(from, symbols[i])) {
				assignKey(to, from, symbols[i]);
			}
		}
	}

	return to;
}

module.exports = function deepAssign(target) {
	target = toObject(target);

	for (var s = 1; s < arguments.length; s++) {
		assign(target, arguments[s]);
	}

	return target;
};


/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/foreach/index.js":
/*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
/***/ ((module) => {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};



/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/get-it/index.js":
/*!**************************************!*\
  !*** ./node_modules/get-it/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib-node */ "./node_modules/get-it/lib/index.js")


/***/ }),

/***/ "./node_modules/get-it/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/get-it/lib/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pubsub = __webpack_require__(/*! nano-pubsub */ "./node_modules/nano-pubsub/index.js");
var middlewareReducer = __webpack_require__(/*! ./util/middlewareReducer */ "./node_modules/get-it/lib/util/middlewareReducer.js");
var processOptions = __webpack_require__(/*! ./middleware/defaultOptionsProcessor */ "./node_modules/get-it/lib/middleware/defaultOptionsProcessor.js");
var validateOptions = __webpack_require__(/*! ./middleware/defaultOptionsValidator */ "./node_modules/get-it/lib/middleware/defaultOptionsValidator.js");
var httpRequest = __webpack_require__(/*! ./request */ "./node_modules/get-it/lib/request/index.js"); // node-request in node, browser-request in browsers

var channelNames = ['request', 'response', 'progress', 'error', 'abort'];
var middlehooks = ['processOptions', 'validateOptions', 'interceptRequest', 'finalizeOptions', 'onRequest', 'onResponse', 'onError', 'onReturn', 'onHeaders'];

module.exports = function createRequester() {
  var initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var loadedMiddleware = [];
  var middleware = middlehooks.reduce(function (ware, name) {
    ware[name] = ware[name] || [];
    return ware;
  }, {
    processOptions: [processOptions],
    validateOptions: [validateOptions]
  });

  function request(opts) {
    var channels = channelNames.reduce(function (target, name) {
      target[name] = pubsub();
      return target;
    }, {});

    // Prepare a middleware reducer that can be reused throughout the lifecycle
    var applyMiddleware = middlewareReducer(middleware);

    // Parse the passed options
    var options = applyMiddleware('processOptions', opts);

    // Validate the options
    applyMiddleware('validateOptions', options);

    // Build a context object we can pass to child handlers
    var context = { options: options, channels: channels, applyMiddleware: applyMiddleware

      // We need to hold a reference to the current, ongoing request,
      // in order to allow cancellation. In the case of the retry middleware,
      // a new request might be triggered
    };var ongoingRequest = null;
    var unsubscribe = channels.request.subscribe(function (ctx) {
      // Let request adapters (node/browser) perform the actual request
      ongoingRequest = httpRequest(ctx, function (err, res) {
        return onResponse(err, res, ctx);
      });
    });

    // If we abort the request, prevent further requests from happening,
    // and be sure to cancel any ongoing request (obviously)
    channels.abort.subscribe(function () {
      unsubscribe();
      if (ongoingRequest) {
        ongoingRequest.abort();
      }
    });

    // See if any middleware wants to modify the return value - for instance
    // the promise or observable middlewares
    var returnValue = applyMiddleware('onReturn', channels, context);

    // If return value has been modified by a middleware, we expect the middleware
    // to publish on the 'request' channel. If it hasn't been modified, we want to
    // trigger it right away
    if (returnValue === channels) {
      channels.request.publish(context);
    }

    return returnValue;

    function onResponse(reqErr, res, ctx) {
      var error = reqErr;
      var response = res;

      // We're processing non-errors first, in case a middleware converts the
      // response into an error (for instance, status >= 400 == HttpError)
      if (!error) {
        try {
          response = applyMiddleware('onResponse', res, ctx);
        } catch (err) {
          response = null;
          error = err;
        }
      }

      // Apply error middleware - if middleware return the same (or a different) error,
      // publish as an error event. If we *don't* return an error, assume it has been handled
      error = error && applyMiddleware('onError', error, ctx);

      // Figure out if we should publish on error/response channels
      if (error) {
        channels.error.publish(error);
      } else if (response) {
        channels.response.publish(response);
      }
    }
  }

  request.use = function use(newMiddleware) {
    if (!newMiddleware) {
      throw new Error('Tried to add middleware that resolved to falsey value');
    }

    if (typeof newMiddleware === 'function') {
      throw new Error('Tried to add middleware that was a function. It probably expects you to pass options to it.');
    }

    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {
      throw new Error('Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event');
    }

    middlehooks.forEach(function (key) {
      if (newMiddleware[key]) {
        middleware[key].push(newMiddleware[key]);
      }
    });

    loadedMiddleware.push(newMiddleware);
    return request;
  };

  request.clone = function clone() {
    return createRequester(loadedMiddleware);
  };

  initMiddleware.forEach(request.use);

  return request;
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/defaultOptionsProcessor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/defaultOptionsProcessor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var urlParse = __webpack_require__(/*! url-parse */ "./node_modules/url-parse/index.js");

var isReactNative = typeof navigator === 'undefined' ? false : navigator.product === 'ReactNative';

var has = Object.prototype.hasOwnProperty;
var defaultOptions = { timeout: isReactNative ? 60000 : 120000 };

module.exports = function (opts) {
  var options = typeof opts === 'string' ? objectAssign({ url: opts }, defaultOptions) : objectAssign({}, defaultOptions, opts);

  // Parse URL into parts
  var url = urlParse(options.url, {}, // Don't use current browser location
  true // Parse query strings
  );

  // Normalize timeouts
  options.timeout = normalizeTimeout(options.timeout);

  // Shallow-merge (override) existing query params
  if (options.query) {
    url.query = objectAssign({}, url.query, removeUndefined(options.query));
  }

  // Implicit POST if we have not specified a method but have a body
  options.method = options.body && !options.method ? 'POST' : (options.method || 'GET').toUpperCase();

  // Stringify URL
  options.url = url.toString(stringifyQueryString);

  return options;
};

function stringifyQueryString(obj) {
  var pairs = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      push(key, obj[key]);
    }
  }

  return pairs.length ? pairs.join('&') : '';

  function push(key, val) {
    if (Array.isArray(val)) {
      val.forEach(function (item) {
        return push(key, item);
      });
    } else {
      pairs.push([key, val].map(encodeURIComponent).join('='));
    }
  }
}

function normalizeTimeout(time) {
  if (time === false || time === 0) {
    return false;
  }

  if (time.connect || time.socket) {
    return time;
  }

  var delay = Number(time);
  if (isNaN(delay)) {
    return normalizeTimeout(defaultOptions.timeout);
  }

  return { connect: delay, socket: delay };
}

function removeUndefined(obj) {
  var target = {};
  for (var key in obj) {
    if (obj[key] !== undefined) {
      target[key] = obj[key];
    }
  }
  return target;
}
//# sourceMappingURL=defaultOptionsProcessor.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/defaultOptionsValidator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/defaultOptionsValidator.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";


var validUrl = /^https?:\/\//i;

module.exports = function (options) {
  if (!validUrl.test(options.url)) {
    throw new Error("\"" + options.url + "\" is not a valid URL");
  }
};
//# sourceMappingURL=defaultOptionsValidator.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/jsonRequest.js":
/*!***********************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/jsonRequest.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var isPlainObject = __webpack_require__(/*! is-plain-object */ "./node_modules/is-plain-object/index.js");

var serializeTypes = ['boolean', 'string', 'number'];
var isBuffer = function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
};

module.exports = function () {
  return {
    processOptions: function processOptions(options) {
      var body = options.body;
      if (!body) {
        return options;
      }

      var isStream = typeof body.pipe === 'function';
      var shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body === 'undefined' ? 'undefined' : _typeof(body)) !== -1 || Array.isArray(body) || isPlainObject(body));

      if (!shouldSerialize) {
        return options;
      }

      return objectAssign({}, options, {
        body: JSON.stringify(options.body),
        headers: objectAssign({}, options.headers, {
          'Content-Type': 'application/json'
        })
      });
    }
  };
};
//# sourceMappingURL=jsonRequest.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/jsonResponse.js":
/*!************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/jsonResponse.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

module.exports = function (opts) {
  return {
    onResponse: function onResponse(response) {
      var contentType = response.headers['content-type'] || '';
      var shouldDecode = opts && opts.force || contentType.indexOf('application/json') !== -1;
      if (!response.body || !contentType || !shouldDecode) {
        return response;
      }

      return objectAssign({}, response, { body: tryParse(response.body) });
    },

    processOptions: function processOptions(options) {
      return objectAssign({}, options, {
        headers: objectAssign({ Accept: 'application/json' }, options.headers)
      });
    }
  };
};

function tryParse(body) {
  try {
    return JSON.parse(body);
  } catch (err) {
    err.message = 'Failed to parsed response body as JSON: ' + err.message;
    throw err;
  }
}
//# sourceMappingURL=jsonResponse.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/observable.js":
/*!**********************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/observable.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(/*! ../util/global */ "./node_modules/get-it/lib/util/global.js");
var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

module.exports = function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Observable = opts.implementation || global.Observable;
  if (!Observable) {
    throw new Error('`Observable` is not available in global scope, and no implementation was passed');
  }

  return {
    onReturn: function onReturn(channels, context) {
      return new Observable(function (observer) {
        channels.error.subscribe(function (err) {
          return observer.error(err);
        });
        channels.progress.subscribe(function (event) {
          return observer.next(objectAssign({ type: 'progress' }, event));
        });
        channels.response.subscribe(function (response) {
          observer.next(objectAssign({ type: 'response' }, response));
          observer.complete();
        });

        channels.request.publish(context);
        return function () {
          return channels.abort.publish();
        };
      });
    }
  };
};
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/progress/browser-progress.js":
/*!*************************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/progress/browser-progress.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  return {
    onRequest: function onRequest(evt) {
      if (evt.adapter !== 'xhr') {
        return;
      }

      var xhr = evt.request;
      var context = evt.context;

      if ('upload' in xhr && 'onprogress' in xhr.upload) {
        xhr.upload.onprogress = handleProgress('upload');
      }

      if ('onprogress' in xhr) {
        xhr.onprogress = handleProgress('download');
      }

      function handleProgress(stage) {
        return function (event) {
          var percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;
          context.channels.progress.publish({
            stage: stage,
            percent: percent,
            total: event.total,
            loaded: event.loaded,
            lengthComputable: event.lengthComputable
          });
        };
      }
    }
  };
};
//# sourceMappingURL=browser-progress.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/progress/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/progress/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./node-progress */ "./node_modules/get-it/lib/middleware/progress/browser-progress.js");
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/request/browser-request.js":
/*!************************************************************!*\
  !*** ./node_modules/get-it/lib/request/browser-request.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint max-depth: ["error", 4] */
var sameOrigin = __webpack_require__(/*! same-origin */ "./node_modules/same-origin/index.js");
var parseHeaders = __webpack_require__(/*! parse-headers */ "./node_modules/parse-headers/parse-headers.js");
var noop = function noop() {
  /* intentional noop */
};

var win = window;
var XmlHttpRequest = win.XMLHttpRequest || noop;
var hasXhr2 = 'withCredentials' in new XmlHttpRequest();
var XDomainRequest = hasXhr2 ? XmlHttpRequest : win.XDomainRequest;
var adapter = 'xhr';

module.exports = function (context, callback) {
  var opts = context.options;
  var options = context.applyMiddleware('finalizeOptions', opts);
  var timers = {};

  // Deep-checking window.location because of react native, where `location` doesn't exist
  var cors = win && win.location && !sameOrigin(win.location.href, options.url);

  // Allow middleware to inject a response, for instance in the case of caching or mocking
  var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {
    adapter: adapter,
    context: context
  });

  // If middleware injected a response, treat it as we normally would and return it
  // Do note that the injected response has to be reduced to a cross-environment friendly response
  if (injectedResponse) {
    var cbTimer = setTimeout(callback, 0, null, injectedResponse);
    var cancel = function cancel() {
      return clearTimeout(cbTimer);
    };
    return { abort: cancel };
  }

  // We'll want to null out the request on success/failure
  var xhr = cors ? new XDomainRequest() : new XmlHttpRequest();

  var isXdr = win.XDomainRequest && xhr instanceof win.XDomainRequest;
  var headers = options.headers;

  // Request state
  var aborted = false;
  var loaded = false;
  var timedOut = false;

  // Apply event handlers
  xhr.onerror = onError;
  xhr.ontimeout = onError;
  xhr.onabort = function () {
    aborted = true;
  };

  // IE9 must have onprogress be set to a unique function
  xhr.onprogress = function () {
    /* intentional noop */
  };

  var loadEvent = isXdr ? 'onload' : 'onreadystatechange';
  xhr[loadEvent] = function () {
    // Prevent request from timing out
    resetTimers();

    if (aborted || xhr.readyState !== 4 && !isXdr) {
      return;
    }

    // Will be handled by onError
    if (xhr.status === 0) {
      return;
    }

    onLoad();
  };

  // @todo two last options to open() is username/password
  xhr.open(options.method, options.url, true // Always async
  );

  // Some options need to be applied after open
  xhr.withCredentials = !!options.withCredentials;

  // Set headers
  if (headers && xhr.setRequestHeader) {
    for (var key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  } else if (headers && isXdr) {
    throw new Error('Headers cannot be set on an XDomainRequest object');
  }

  if (options.rawBody) {
    xhr.responseType = 'arraybuffer';
  }

  // Let middleware know we're about to do a request
  context.applyMiddleware('onRequest', { options: options, adapter: adapter, request: xhr, context: context });

  xhr.send(options.body || null);

  // Figure out which timeouts to use (if any)
  var delays = options.timeout;
  if (delays) {
    timers.connect = setTimeout(function () {
      return timeoutRequest('ETIMEDOUT');
    }, delays.connect);
  }

  return { abort: abort };

  function abort() {
    aborted = true;

    if (xhr) {
      xhr.abort();
    }
  }

  function timeoutRequest(code) {
    timedOut = true;
    xhr.abort();
    var error = new Error(code === 'ESOCKETTIMEDOUT' ? 'Socket timed out on request to ' + options.url : 'Connection timed out on request to ' + options.url);
    error.code = code;
    context.channels.error.publish(error);
  }

  function resetTimers() {
    if (!delays) {
      return;
    }

    stopTimers();
    timers.socket = setTimeout(function () {
      return timeoutRequest('ESOCKETTIMEDOUT');
    }, delays.socket);
  }

  function stopTimers() {
    // Only clear the connect timeout if we've got a connection
    if (aborted || xhr.readyState >= 2 && timers.connect) {
      clearTimeout(timers.connect);
    }

    if (timers.socket) {
      clearTimeout(timers.socket);
    }
  }

  function onError() {
    if (loaded) {
      return;
    }

    // Clean up
    stopTimers();
    loaded = true;
    xhr = null;

    // Annoyingly, details are extremely scarce and hidden from us.
    // We only really know that it is a network error
    var err = new Error('Network error while attempting to reach ' + options.url);
    err.isNetworkError = true;
    err.request = options;
    callback(err);
  }

  function reduceResponse() {
    var statusCode = xhr.status;
    var statusMessage = xhr.statusText;

    if (isXdr && statusCode === undefined) {
      // IE8 CORS GET successful response doesn't have a status field, but body is fine
      statusCode = 200;
    } else if (statusCode > 12000 && statusCode < 12156) {
      // Yet another IE quirk where it emits weird status codes on network errors
      // https://support.microsoft.com/en-us/kb/193625
      return onError();
    } else {
      // Another IE bug where HTTP 204 somehow ends up as 1223
      statusCode = xhr.status === 1223 ? 204 : xhr.status;
      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;
    }

    return {
      body: xhr.response || xhr.responseText,
      url: options.url,
      method: options.method,
      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),
      statusCode: statusCode,
      statusMessage: statusMessage
    };
  }

  function onLoad() {
    if (aborted || loaded || timedOut) {
      return;
    }

    if (xhr.status === 0) {
      onError(new Error('Unknown XHR error'));
      return;
    }

    // Prevent being called twice
    stopTimers();
    loaded = true;
    callback(null, reduceResponse());
  }
};
//# sourceMappingURL=browser-request.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/request/index.js":
/*!**************************************************!*\
  !*** ./node_modules/get-it/lib/request/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./node-request */ "./node_modules/get-it/lib/request/browser-request.js");
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/util/global.js":
/*!************************************************!*\
  !*** ./node_modules/get-it/lib/util/global.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable no-negated-condition */
if (typeof window !== 'undefined') {
  module.exports = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  module.exports = __webpack_require__.g;
} else if (typeof self !== 'undefined') {
  module.exports = self;
} else {
  module.exports = {};
}
//# sourceMappingURL=global.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/util/middlewareReducer.js":
/*!***********************************************************!*\
  !*** ./node_modules/get-it/lib/util/middlewareReducer.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (middleware) {
  var applyMiddleware = function applyMiddleware(hook, defaultValue) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var bailEarly = hook === 'onError';

    var value = defaultValue;
    for (var i = 0; i < middleware[hook].length; i++) {
      var handler = middleware[hook][i];
      value = handler.apply(undefined, [value].concat(args));

      if (bailEarly && !value) {
        break;
      }
    }

    return value;
  };

  return applyMiddleware;
};
//# sourceMappingURL=middlewareReducer.js.map

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var generatorFunc = getGeneratorFunc();
var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	return getProto && getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/is-obj/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-obj/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";

module.exports = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};


/***/ }),

/***/ "./node_modules/is-plain-object/index.js":
/*!***********************************************!*\
  !*** ./node_modules/is-plain-object/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



var isObject = __webpack_require__(/*! isobject */ "./node_modules/isobject/index.js");

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};


/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! foreach */ "./node_modules/foreach/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js");
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new __webpack_require__.g[typedArray]();
		if (!(Symbol.toStringTag in arr)) {
			throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
		}
		var proto = getPrototypeOf(arr);
		var descriptor = gOPD(proto, Symbol.toStringTag);
		if (!descriptor) {
			var superProto = getPrototypeOf(proto);
			descriptor = gOPD(superProto, Symbol.toStringTag);
		}
		toStrTags[typedArray] = descriptor.get;
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./node_modules/isobject/index.js":
/*!****************************************!*\
  !*** ./node_modules/isobject/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};


/***/ }),

/***/ "./node_modules/make-error/index.js":
/*!******************************************!*\
  !*** ./node_modules/make-error/index.js ***!
  \******************************************/
/***/ ((module, exports) => {

"use strict";
// ISC @ Julien Fontanet



// ===================================================================

var construct = typeof Reflect !== "undefined" ? Reflect.construct : undefined;
var defineProperty = Object.defineProperty;

// -------------------------------------------------------------------

var captureStackTrace = Error.captureStackTrace;
if (captureStackTrace === undefined) {
  captureStackTrace = function captureStackTrace(error) {
    var container = new Error();

    defineProperty(error, "stack", {
      configurable: true,
      get: function getStack() {
        var stack = container.stack;

        // Replace property with value for faster future accesses.
        defineProperty(this, "stack", {
          configurable: true,
          value: stack,
          writable: true,
        });

        return stack;
      },
      set: function setStack(stack) {
        defineProperty(error, "stack", {
          configurable: true,
          value: stack,
          writable: true,
        });
      },
    });
  };
}

// -------------------------------------------------------------------

function BaseError(message) {
  if (message !== undefined) {
    defineProperty(this, "message", {
      configurable: true,
      value: message,
      writable: true,
    });
  }

  var cname = this.constructor.name;
  if (cname !== undefined && cname !== this.name) {
    defineProperty(this, "name", {
      configurable: true,
      value: cname,
      writable: true,
    });
  }

  captureStackTrace(this, this.constructor);
}

BaseError.prototype = Object.create(Error.prototype, {
  // See: https://github.com/JsCommunity/make-error/issues/4
  constructor: {
    configurable: true,
    value: BaseError,
    writable: true,
  },
});

// -------------------------------------------------------------------

// Sets the name of a function if possible (depends of the JS engine).
var setFunctionName = (function() {
  function setFunctionName(fn, name) {
    return defineProperty(fn, "name", {
      configurable: true,
      value: name,
    });
  }
  try {
    var f = function() {};
    setFunctionName(f, "foo");
    if (f.name === "foo") {
      return setFunctionName;
    }
  } catch (_) {}
})();

// -------------------------------------------------------------------

function makeError(constructor, super_) {
  if (super_ == null || super_ === Error) {
    super_ = BaseError;
  } else if (typeof super_ !== "function") {
    throw new TypeError("super_ should be a function");
  }

  var name;
  if (typeof constructor === "string") {
    name = constructor;
    constructor =
      construct !== undefined
        ? function() {
            return construct(super_, arguments, this.constructor);
          }
        : function() {
            super_.apply(this, arguments);
          };

    // If the name can be set, do it once and for all.
    if (setFunctionName !== undefined) {
      setFunctionName(constructor, name);
      name = undefined;
    }
  } else if (typeof constructor !== "function") {
    throw new TypeError("constructor should be either a string or a function");
  }

  // Also register the super constructor also as `constructor.super_` just
  // like Node's `util.inherits()`.
  //
  // eslint-disable-next-line dot-notation
  constructor.super_ = constructor["super"] = super_;

  var properties = {
    constructor: {
      configurable: true,
      value: constructor,
      writable: true,
    },
  };

  // If the name could not be set on the constructor, set it on the
  // prototype.
  if (name !== undefined) {
    properties.name = {
      configurable: true,
      value: name,
      writable: true,
    };
  }
  constructor.prototype = Object.create(super_.prototype, properties);

  return constructor;
}
exports = module.exports = makeError;
exports.BaseError = BaseError;


/***/ }),

/***/ "./node_modules/nano-pubsub/index.js":
/*!*******************************************!*\
  !*** ./node_modules/nano-pubsub/index.js ***!
  \*******************************************/
/***/ ((module) => {

module.exports = function Pubsub() {
  var subscribers = []
  return {
    subscribe: subscribe,
    publish: publish
  }
  function subscribe(subscriber) {
    subscribers.push(subscriber)
    return function unsubscribe() {
      var idx = subscribers.indexOf(subscriber)
      if (idx > -1) {
        subscribers.splice(idx, 1)
      }
    }
  }
  function publish() {
    for (var i = 0; i < subscribers.length; i++) {
      subscribers[i].apply(null, arguments)
    }
  }
}

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/***/ ((module) => {

var trim = function(string) {
  return string.replace(/^\s+|\s+$/g, '');
}
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  var headersArr = trim(headers).split('\n')

  for (var i = 0; i < headersArr.length; i++) {
    var row = headersArr[i]
    var index = row.indexOf(':')
    , key = trim(row.slice(0, index)).toLowerCase()
    , value = trim(row.slice(index + 1))

    if (typeof(result[key]) === 'undefined') {
      result[key] = value
    } else if (isArray(result[key])) {
      result[key].push(value)
    } else {
      result[key] = [ result[key], value ]
    }
  }

  return result
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./node_modules/rxjs/internal/Observable.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/internal/Observable.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");

Object.defineProperty(exports, "__esModule", ({ value: true }));
var canReportError_1 = __webpack_require__(/*! ./util/canReportError */ "./node_modules/rxjs/internal/util/canReportError.js");
var toSubscriber_1 = __webpack_require__(/*! ./util/toSubscriber */ "./node_modules/rxjs/internal/util/toSubscriber.js");
var observable_1 = __webpack_require__(/*! ./symbol/observable */ "./node_modules/rxjs/internal/symbol/observable.js");
var pipe_1 = __webpack_require__(/*! ./util/pipe */ "./node_modules/rxjs/internal/util/pipe.js");
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Observer.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/internal/Observer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var hostReportError_1 = __webpack_require__(/*! ./util/hostReportError */ "./node_modules/rxjs/internal/util/hostReportError.js");
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Subscriber.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/internal/Subscriber.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
var Observer_1 = __webpack_require__(/*! ./Observer */ "./node_modules/rxjs/internal/Observer.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var rxSubscriber_1 = __webpack_require__(/*! ../internal/symbol/rxSubscriber */ "./node_modules/rxjs/internal/symbol/rxSubscriber.js");
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var hostReportError_1 = __webpack_require__(/*! ./util/hostReportError */ "./node_modules/rxjs/internal/util/hostReportError.js");
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Subscription.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/internal/Subscription.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var isArray_1 = __webpack_require__(/*! ./util/isArray */ "./node_modules/rxjs/internal/util/isArray.js");
var isObject_1 = __webpack_require__(/*! ./util/isObject */ "./node_modules/rxjs/internal/util/isObject.js");
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
var UnsubscriptionError_1 = __webpack_require__(/*! ./util/UnsubscriptionError */ "./node_modules/rxjs/internal/util/UnsubscriptionError.js");
var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/config.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/internal/config.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/empty.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/empty.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/defaultIfEmpty.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/filter.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/map.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/map.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/reduce.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var scan_1 = __webpack_require__(/*! ./scan */ "./node_modules/rxjs/internal/operators/scan.js");
var takeLast_1 = __webpack_require__(/*! ./takeLast */ "./node_modules/rxjs/internal/operators/takeLast.js");
var defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js");
var pipe_1 = __webpack_require__(/*! ../util/pipe */ "./node_modules/rxjs/internal/util/pipe.js");
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;
//# sourceMappingURL=reduce.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/scan.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/scan.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=scan.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/takeLast.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/takeLast.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js");
var empty_1 = __webpack_require__(/*! ../observable/empty */ "./node_modules/rxjs/internal/observable/empty.js");
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeLast.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/symbol/observable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/symbol/observable.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/symbol/rxSubscriber.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/symbol/rxSubscriber.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/UnsubscriptionError.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/UnsubscriptionError.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/canReportError.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/canReportError.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;
//# sourceMappingURL=canReportError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/hostReportError.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/hostReportError.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;
//# sourceMappingURL=hostReportError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/identity.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/identity.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function identity(x) {
    return x;
}
exports.identity = identity;
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isArray.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isArray.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
//# sourceMappingURL=isArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isFunction.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isFunction.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isObject.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/pipe.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/internal/util/pipe.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var identity_1 = __webpack_require__(/*! ./identity */ "./node_modules/rxjs/internal/util/identity.js");
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity_1.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;
//# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/toSubscriber.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/toSubscriber.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var rxSubscriber_1 = __webpack_require__(/*! ../symbol/rxSubscriber */ "./node_modules/rxjs/internal/symbol/rxSubscriber.js");
var Observer_1 = __webpack_require__(/*! ../Observer */ "./node_modules/rxjs/internal/Observer.js");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),

/***/ "./node_modules/same-origin/index.js":
/*!*******************************************!*\
  !*** ./node_modules/same-origin/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var url = __webpack_require__(/*! url */ "./node_modules/same-origin/url-parser.js");

module.exports = function(uri1, uri2, ieMode) {
    if (uri1 === uri2) {
        return true;
    }

    var url1 = url.parse(uri1, false, true);
    var url2 = url.parse(uri2, false, true);

    var url1Port = url1.port|0 || (url1.protocol === 'https' ? 443 : 80);
    var url2Port = url2.port|0 || (url2.protocol === 'https' ? 443 : 80);

    var match = {
        proto: url1.protocol === url2.protocol,
        hostname: url1.hostname === url2.hostname,
        port: url1Port === url2Port
    };

    return ((match.proto && match.hostname) && (match.port || ieMode));
};

/***/ }),

/***/ "./node_modules/same-origin/url-parser.js":
/*!************************************************!*\
  !*** ./node_modules/same-origin/url-parser.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
/**
 * This file is only used for the browser version of `same-origin`.
 * Used to bring down the size of the browser bundle.
 */


var regex = /^(?:(?:(?:([^:\/#\?]+:)?(?:(?:\/\/)((?:((?:[^:@\/#\?]+)(?:\:(?:[^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((?:\/?(?:[^\/\?#]+\/+)*)(?:[^\?#]*)))?(\?[^#]+)?)(#.*)?/;

module.exports = {
    regex: regex,
    parse: function(url) {
        var match = regex.exec(url);
        if (!match) {
            return {};
        }

        return {
            protocol: (match[1] || '').toLowerCase() || undefined,
            hostname: (match[5] || '').toLowerCase() || undefined,
            port: match[6] || undefined
        };
    }
};

/***/ }),

/***/ "./src/biketag/deleteTag.ts":
/*!**********************************!*\
  !*** ./src/biketag/deleteTag.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* binding */ deleteTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function deleteTag(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}`;
        return (yield client.request({ url, method: 'DELETE' })).data;
    });
}


/***/ }),

/***/ "./src/biketag/favoriteImage.ts":
/*!**************************************!*\
  !*** ./src/biketag/favoriteImage.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "favoriteImage": () => (/* binding */ favoriteImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function favoriteImage(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}/favorite`;
        return (yield client.request({ url, method: 'POST' })).data;
    });
}


/***/ }),

/***/ "./src/biketag/getTag.ts":
/*!*******************************!*\
  !*** ./src/biketag/getTag.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTag": () => (/* binding */ getTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function getTag(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}`;
        return (yield client.request({ url })).data;
    });
}


/***/ }),

/***/ "./src/biketag/index.ts":
/*!******************************!*\
  !*** ./src/biketag/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* reexport safe */ _deleteTag__WEBPACK_IMPORTED_MODULE_0__.deleteTag),
/* harmony export */   "getTag": () => (/* reexport safe */ _getTag__WEBPACK_IMPORTED_MODULE_1__.getTag),
/* harmony export */   "updateTag": () => (/* reexport safe */ _updateTag__WEBPACK_IMPORTED_MODULE_2__.updateTag),
/* harmony export */   "updateTagImage": () => (/* reexport safe */ _updateTagImage__WEBPACK_IMPORTED_MODULE_3__.updateTagImage),
/* harmony export */   "queueTagImage": () => (/* reexport safe */ _queueTagImage__WEBPACK_IMPORTED_MODULE_4__.queueTagImage),
/* harmony export */   "favoriteImage": () => (/* reexport safe */ _favoriteImage__WEBPACK_IMPORTED_MODULE_5__.favoriteImage)
/* harmony export */ });
/* harmony import */ var _deleteTag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deleteTag */ "./src/biketag/deleteTag.ts");
/* harmony import */ var _getTag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTag */ "./src/biketag/getTag.ts");
/* harmony import */ var _updateTag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateTag */ "./src/biketag/updateTag.ts");
/* harmony import */ var _updateTagImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./updateTagImage */ "./src/biketag/updateTagImage.ts");
/* harmony import */ var _queueTagImage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./queueTagImage */ "./src/biketag/queueTagImage.ts");
/* harmony import */ var _favoriteImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./favoriteImage */ "./src/biketag/favoriteImage.ts");








/***/ }),

/***/ "./src/biketag/queueTagImage.ts":
/*!**************************************!*\
  !*** ./src/biketag/queueTagImage.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "queueTagImage": () => (/* binding */ queueTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

// import { UPLOAD_ENDPOINT } from '../common/endpoints';
function queueTagImage(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        if (Array.isArray(payload)) {
            const promises = payload.map((p) => {
                // const form = createForm(p);
                // const req = client.request(UPLOAD_ENDPOINT, {
                //   method: 'POST',
                //   body: form,
                //   resolveBodyOnly: true,
                // });
                // const id = ;
                // req.on('uploadProgress', (progress: Progress) => {
                //   client.emit('uploadProgress', { ...progress, id });
                // });
                return p;
            });
            return yield Promise.all(promises);
        }
        // const form = createForm(payload);
        // const req = client.request(UPLOAD_ENDPOINT, {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // });
        // req.on('uploadProgress', (progress: Progress) => {
        //   client.emit('uploadProgress', { ...progress, id });
        // });
        return client;
    });
}


/***/ }),

/***/ "./src/biketag/updateTag.ts":
/*!**********************************!*\
  !*** ./src/biketag/updateTag.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTag": () => (/* binding */ updateTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function isValidUpdatePayload(p) {
    return typeof p.title === 'string' || typeof p.description === 'string';
}
function updateTag(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        // if (Array.isArray(payload)) {
        //   const promises = payload.map((p: UpdateTagPayload) => {
        //     if (!isValidUpdatePayload(p)) {
        //       throw new Error('Update requires a title and/or description');
        //     }
        //     const url = `${IMAGE_ENDPOINT}/${p.imageHash}`;
        //     const form = createForm(p);
        //     return (client.request(url, {
        //       method: 'POST',
        //       body: form,
        //       resolveBodyOnly: true,
        //     }) as unknown) as Promise<BikeTagApiResponse<boolean>>;
        //   });
        //   return await Promise.all(promises);
        // }
        if (!isValidUpdatePayload(payload)) {
            throw new Error('Update requires a title and/or description');
        }
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${payload.slug}`;
        return (yield client.request({ url, method: 'DELETE' })).data;
    });
}


/***/ }),

/***/ "./src/biketag/updateTagImage.ts":
/*!***************************************!*\
  !*** ./src/biketag/updateTagImage.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTagImage": () => (/* binding */ updateTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


// function isValidUpdatePayload(p: UpdateTagImagePayload) {
//   return typeof p.title === 'string' || typeof p.description === 'string';
// }
function updateTagImage(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        // if (Array.isArray(payload)) {
        //   const promises = payload.map((p: UpdateTagImagePayload) => {
        //     if (!isValidUpdatePayload(p)) {
        //       throw new Error('Update requires a title and/or description');
        //     }
        //     const url = `${IMAGE_ENDPOINT}/${p.imageHash}`;
        //     const form = createForm(p);
        //     return (client.request(url, {
        //       method: 'POST',
        //       body: form,
        //       resolveBodyOnly: true,
        //     }) as unknown) as Promise<BikeTagApiResponse<boolean>>;
        //   });
        //   return await Promise.all(promises);
        // }
        // if (!isValidUpdatePayload(payload)) {
        //   throw new Error('Update requires a title and/or description');
        // }
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${payload.slug}`;
        return (yield client.request({ url, method: 'DELETE' })).data;
        // // const form = createForm(payload);
        // return ((await client.request(url, {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // })) as unknown) as BikeTagApiResponse<boolean>;
    });
}


/***/ }),

/***/ "./src/client.ts":
/*!***********************!*\
  !*** ./src/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BikeTagClient": () => (/* binding */ BikeTagClient)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/endpoints */ "./src/common/endpoints.ts");
/* harmony import */ var _common_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/data */ "./src/common/data.ts");
/* harmony import */ var _common_methods__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common/methods */ "./src/common/methods.ts");
/* harmony import */ var _sanity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sanity */ "./src/sanity/index.ts");
/* harmony import */ var _imgur__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./imgur */ "./src/imgur/index.ts");
/* harmony import */ var _biketag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./biketag */ "./src/biketag/index.ts");
/* harmony import */ var _imgurClient__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./imgurClient */ "./src/imgurClient/index.js");
/* harmony import */ var _imgurClient__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_imgurClient__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sanity/client */ "./node_modules/@sanity/client/lib/sanityClient.js");
/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_sanity_client__WEBPACK_IMPORTED_MODULE_9__);


// import { getAuthorizationHeader } from './getAuthorizationHeader'






// @ts-ignore


const USERAGENT = 'biketag-api (https://github.com/keneucker/biketag-api)';
class BikeTagClient extends events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
    constructor(credentials) {
        super();
        this.credentials = credentials;
        this.mostAvailableApi = "";
        this.biketagConfig = (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isBikeTagCredentials)(credentials) ? credentials : undefined;
        this.imgurConfig = (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isImgurCredentials)(credentials) ? credentials : undefined;
        this.sanityConfig = (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isSanityCredentials)(credentials) ? credentials : undefined;
        if (this.imgurConfig) {
            this.imgurClient = new _imgurClient__WEBPACK_IMPORTED_MODULE_8__.ImgurClient(this.imgurConfig);
        }
        if (this.sanityConfig) {
            this.sanityClient = _sanity_client__WEBPACK_IMPORTED_MODULE_9___default()(this.sanityConfig);
        }
        this.fetcher = axios__WEBPACK_IMPORTED_MODULE_0___default().create({
            baseURL: _common_endpoints__WEBPACK_IMPORTED_MODULE_2__.BIKETAG_API_PREFIX,
            headers: {
                'user-agent': USERAGENT,
            },
            responseType: 'json',
            // hooks: {
            //   beforeRequest: [
            //     async (options: any) => {
            //       options.headers['authorization'] = await getAuthorizationHeader(
            //         this
            //       )
            //     },
            //   ],
            // },
        });
    }
    getDefaultAPI(options) {
        const availableAPI = options.forceAPI ? options.forceAPI : this.getMostAvailableAPI();
        let client = null;
        let api = null;
        options = typeof options === 'string' ? { slug: options } : options;
        options = typeof options === 'number' ? { slug: (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.constructTagNumberSlug)(options) } : options;
        options.slug = options.slug ? options.slug : (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.constructTagNumberSlug)(options.tagnumber, options.game);
        options.fields = options.fields ? options.fields : _common_data__WEBPACK_IMPORTED_MODULE_3__.tagDataFields;
        switch (availableAPI) {
            case "sanity":
                client = this.sanityClient;
                api = _sanity__WEBPACK_IMPORTED_MODULE_5__;
                break;
            case "imgur":
                client = this.imgurClient;
                api = _imgur__WEBPACK_IMPORTED_MODULE_6__;
                break;
            default:
            case "biketag":
                client = api = _biketag__WEBPACK_IMPORTED_MODULE_7__;
                break;
        }
        return {
            client, api, options
        };
    }
    getMostAvailableAPI() {
        if (this.mostAvailableApi.length) {
            return this.mostAvailableApi;
        }
        if (this.biketagConfig) {
            return this.mostAvailableApi = "biketag";
        }
        else if (this.imgurConfig) {
            return this.mostAvailableApi = "imgur";
        }
        else if (this.sanityConfig) {
            return this.mostAvailableApi = "sanity";
        }
        return "";
    }
    getConfiguration() {
        return {
            sanity: this.sanityConfig,
            imgur: this.imgurConfig,
            biketag: this.biketagConfig,
        };
    }
    plainRequest(options = {}) {
        return this.fetcher(options).then(response => response.data);
    }
    request(options = {}) {
        return this.fetcher(options);
    }
    // deleteImage(imageHash: string): Promise<BikeTagApiResponse<boolean>> {
    //   switch (this.getMostAvailableAPI()) {
    //     case "imgur":
    //       return imgur.deleteImage(this, imageHash)
    //     break
    //   }
    // }
    // /// TODO: this should be for getting an album
    // getArchive(options: ArchiveOptions): Promise<BikeTagApiResponse<ArchiveData>> {
    //   return getArchive(this, options)
    // }
    getTag(opts) {
        const { client, options, api } = this.getDefaultAPI(opts);
        return api.getTag(client, options);
    }
    // updateImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return updateImage(this, payload)
    // }
    // upload(
    //   payload: string | string[] | Payload | Payload[]
    // ): Promise<BikeTagApiResponse<TagData> | BikeTagApiResponse<TagData>[]> {
    //   return upload(this, payload)
    // }
    // getBikeTag(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   switch (this.getMostAvailableAPI()) {
    //     case "imgur":
    //       return getBikeTag(this, payload)
    //       break
    //     case "sanity":
    //       return 
    //   }
    // }
    // getBikeTagMysteryImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getBikeTagMysteryImage(this, payload)
    // }
    // getBikeTagFoundImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getBikeTagFoundImage(this, payload)
    // }
    // queueBikeTagFoundImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return queueBikeTagFoundImage(this, payload)
    // }
    // queueBikeTagMysteryImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return queueBikeTagMysteryImage(this, payload)
    // }
    // getQueuedImages(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getQueuedImages(this, payload)
    // }
    // getQueue(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getQueue(this, payload)
    // }
    // completeBikeTagRound(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return completeBikeTagRound(this, payload)
    // }
    // getBikeTagRound(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getBikeTagRound(this, payload)
    // }
    content(options = {}) {
        if ((0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isSanityCredentials)(options)) {
            return _sanity_client__WEBPACK_IMPORTED_MODULE_9___default()(options);
        }
        throw new Error('options are invalid for creating a sanity client');
    }
    images(options = {}) {
        if ((0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isImgurCredentials)(options)) {
            return new _imgurClient__WEBPACK_IMPORTED_MODULE_8__.ImgurClient(options);
        }
        throw new Error('options are invalid for creating an imgur client');
    }
    data() {
        return this;
    }
}


/***/ }),

/***/ "./src/common/data.ts":
/*!****************************!*\
  !*** ./src/common/data.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tagDataFields": () => (/* binding */ tagDataFields),
/* harmony export */   "tagDataReferenceFields": () => (/* binding */ tagDataReferenceFields)
/* harmony export */ });
const tagDataFields = [
    "slug",
    "tagnumber",
    "mysteryImage",
    "mysteryImageUrl",
    "game",
    "player",
    "hint",
    "discussionUrl",
    "foundLocation",
    "gps",
    "foundImage",
    "foundImageUrl",
];
const tagDataReferenceFields = [
    "game",
    "player"
];


/***/ }),

/***/ "./src/common/endpoints.ts":
/*!*********************************!*\
  !*** ./src/common/endpoints.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BIKETAG_API_PREFIX": () => (/* binding */ BIKETAG_API_PREFIX),
/* harmony export */   "API_VERSION": () => (/* binding */ API_VERSION),
/* harmony export */   "AUTHORIZE_ENDPOINT": () => (/* binding */ AUTHORIZE_ENDPOINT),
/* harmony export */   "IMAGE_ENDPOINT": () => (/* binding */ IMAGE_ENDPOINT),
/* harmony export */   "TAG_ENDPOINT": () => (/* binding */ TAG_ENDPOINT),
/* harmony export */   "UPLOAD_ENDPOINT": () => (/* binding */ UPLOAD_ENDPOINT),
/* harmony export */   "ALBUM_ENDPOINT": () => (/* binding */ ALBUM_ENDPOINT),
/* harmony export */   "CONFIG_ENDPOINT": () => (/* binding */ CONFIG_ENDPOINT)
/* harmony export */ });
const BIKETAG_API_PREFIX = 'https://api.biketag.org';
const API_VERSION = '2';
const AUTHORIZE_ENDPOINT = 'oauth2/authorize';
const IMAGE_ENDPOINT = `${API_VERSION}/image`;
const TAG_ENDPOINT = `${API_VERSION}/tag`;
const UPLOAD_ENDPOINT = `${API_VERSION}/upload`;
const ALBUM_ENDPOINT = `${API_VERSION}/archive`;
const CONFIG_ENDPOINT = `${API_VERSION}/config`;


/***/ }),

/***/ "./src/common/methods.ts":
/*!*******************************!*\
  !*** ./src/common/methods.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isBikeTagAccessToken": () => (/* binding */ isBikeTagAccessToken),
/* harmony export */   "isBikeTagClientKey": () => (/* binding */ isBikeTagClientKey),
/* harmony export */   "isSanityAccessToken": () => (/* binding */ isSanityAccessToken),
/* harmony export */   "isSanityClientId": () => (/* binding */ isSanityClientId),
/* harmony export */   "isImgurAccessToken": () => (/* binding */ isImgurAccessToken),
/* harmony export */   "isImgurClientId": () => (/* binding */ isImgurClientId),
/* harmony export */   "constructTagDataObject": () => (/* binding */ constructTagDataObject),
/* harmony export */   "constructTagNumberSlug": () => (/* binding */ constructTagNumberSlug),
/* harmony export */   "isImgurCredentials": () => (/* binding */ isImgurCredentials),
/* harmony export */   "isSanityCredentials": () => (/* binding */ isSanityCredentials),
/* harmony export */   "isBikeTagCredentials": () => (/* binding */ isBikeTagCredentials)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ "./src/common/data.ts");

function isBikeTagAccessToken(arg) {
    return arg.clientToken !== undefined;
}
function isBikeTagClientKey(arg) {
    return arg.clientKey !== undefined;
}
function isSanityAccessToken(arg) {
    return arg.accessToken !== undefined;
}
function isSanityClientId(arg) {
    return arg.projectId !== undefined;
}
// export function isSanityLogin(arg: unknown): arg is SanityLogin {
//   return (
//     (arg as SanityLogin).projectId !== undefined &&
//     (arg as SanityLogin).username !== undefined &&
//     (arg as SanityLogin).password !== undefined
//   )
// }
function isImgurAccessToken(arg) {
    return arg.accessToken !== undefined;
}
function isImgurClientId(arg) {
    return arg.clientId !== undefined;
}
function constructTagDataObject(data, fields = []) {
    const tagData = fields.length
        ? fields.reduce((o, f) => {
            o[f] = data[f];
            return o;
        }, {})
        : data;
    _data__WEBPACK_IMPORTED_MODULE_0__.tagDataReferenceFields.forEach((f) => {
        if (typeof tagData[f] !== 'undefined') {
            tagData[f] = tagData[f].name;
        }
    });
    // tagData.slug = tagData.slug?.current ? tagData.slug.current : undefined // Undefined would be a problem
    tagData.slug = tagData.slug.current;
    return tagData;
}
function constructTagNumberSlug(number, game = 'portland') {
    return `${game}-tag-${number}`;
}
function isImgurCredentials(credentials) {
    return !!(credentials.clientId !== undefined || credentials.clientSecret !== undefined);
}
function isSanityCredentials(credentials) {
    return !!(credentials.projectId !== undefined && credentials.accessToken !== undefined);
}
function isBikeTagCredentials(credentials) {
    return !!(credentials.clientToken !== undefined && credentials.clientKey !== undefined);
}


/***/ }),

/***/ "./src/imgur/deleteTag.ts":
/*!********************************!*\
  !*** ./src/imgur/deleteTag.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* binding */ deleteTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function deleteTag(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}`;
        return (yield client.request({ url, method: 'DELETE' })).data;
        // return (await client
        //   .request(url, { method: 'DELETE' })
        //   .json()) as BikeTagApiResponse<boolean>;
    });
}


/***/ }),

/***/ "./src/imgur/getTag.ts":
/*!*****************************!*\
  !*** ./src/imgur/getTag.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTag": () => (/* binding */ getTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function getTag(client, options) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        /// TODO: Get the tag image hash for Reddit from the tagnumber provided
        /// TODO: Get the images associated with the tagnumber
        /// TODO: Implement data translation for Imgur image to TagData
        /// TODO: Wrap the response in a BikeTagApiResponse
        return yield client.getImage(options.slug);
    });
}


/***/ }),

/***/ "./src/imgur/index.ts":
/*!****************************!*\
  !*** ./src/imgur/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* reexport safe */ _deleteTag__WEBPACK_IMPORTED_MODULE_0__.deleteTag),
/* harmony export */   "getTag": () => (/* reexport safe */ _getTag__WEBPACK_IMPORTED_MODULE_1__.getTag),
/* harmony export */   "updateTag": () => (/* reexport safe */ _updateTag__WEBPACK_IMPORTED_MODULE_2__.updateTag),
/* harmony export */   "uploadTagImage": () => (/* reexport safe */ _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__.uploadTagImage)
/* harmony export */ });
/* harmony import */ var _deleteTag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deleteTag */ "./src/imgur/deleteTag.ts");
/* harmony import */ var _getTag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTag */ "./src/imgur/getTag.ts");
/* harmony import */ var _updateTag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateTag */ "./src/imgur/updateTag.ts");
/* harmony import */ var _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uploadTagImage */ "./src/imgur/uploadTagImage.ts");






/***/ }),

/***/ "./src/imgur/updateTag.ts":
/*!********************************!*\
  !*** ./src/imgur/updateTag.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTag": () => (/* binding */ updateTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

// function isValidUpdatePayload(p: UpdateTagPayload) {
//   return typeof p.title === 'string' || typeof p.description === 'string';
// }
function updateTag(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        // if (Array.isArray(payload)) {
        //   const promises = payload.map((p: UpdateTagPayload) => {
        //     if (!isValidUpdatePayload(p)) {
        //       throw new Error('Update requires a title and/or description');
        //     }
        //     const form = createForm(p);
        //     return (client.request('url', {
        //       method: 'POST',
        //       body: form,
        //       resolveBodyOnly: true,
        //     }) as unknown) as Promise<BikeTagApiResponse<boolean>>;
        //   });
        //   return await Promise.all(promises);
        // }
        // if (!isValidUpdatePayload(payload)) {
        //   throw new Error('Update requires a title and/or description');
        // }
        // const form = createForm(payload);
        // return ((await client.request('url', {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // })) as unknown) as BikeTagApiResponse<boolean>;
        return (yield client.request({ url: payload, method: 'POST' })).data;
    });
}


/***/ }),

/***/ "./src/imgur/uploadTagImage.ts":
/*!*************************************!*\
  !*** ./src/imgur/uploadTagImage.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uploadTagImage": () => (/* binding */ uploadTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

// import { Progress } from 'axios';
function uploadTagImage(
// client: ImgurClient,
payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        if (Array.isArray(payload)) {
            const promises = payload.map((p) => {
                // const form = createForm(p);
                // const req = client.request('UPLOAD_ENDPOINT', {
                //   method: 'POST',
                //   body: form,
                //   resolveBodyOnly: true,
                // });
                const id = "a" + p;
                // req.on('uploadProgress', (progress: Progress) => {
                //   client.emit('uploadProgress', { ...progress, id });
                // });
                return id;
            });
            return yield Promise.all(promises);
        }
        // const form = createForm(payload);
        // const req = client.request('UPLOAD_ENDPOINT', {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // });
        const id = "Ads";
        // req.on('uploadProgress', (progress: Progress) => {
        //   client.emit('uploadProgress', { ...progress, id });
        // });
        return id;
    });
}


/***/ }),

/***/ "./src/sanity/deleteTag.ts":
/*!*********************************!*\
  !*** ./src/sanity/deleteTag.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* binding */ deleteTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function deleteTag(client) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        return { client };
    });
}


/***/ }),

/***/ "./src/sanity/getTag.ts":
/*!******************************!*\
  !*** ./src/sanity/getTag.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTag": () => (/* binding */ getTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_methods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/methods */ "./src/common/methods.ts");
/* harmony import */ var _common_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/data */ "./src/common/data.ts");



function getTag(client, options) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function* () {
        if (!options) {
            throw new Error('no options');
        }
        if (!options.slug.length) {
            throw new Error('no slug');
        }
        const fields = options.fields.reduce((o, f) => {
            o += `${f}${_common_data__WEBPACK_IMPORTED_MODULE_1__.tagDataReferenceFields.indexOf(f) != -1 ? '->{name}' : ''},`;
            return o;
        }, '').slice(0, -1);
        const query = `*[_type == "tag" && slug.current == "${options.slug}"][0]{${fields}}`;
        const params = {};
        return client.fetch(query, params).then((tag) => {
            // construct tagData object from tag
            const tagData = (0,_common_methods__WEBPACK_IMPORTED_MODULE_0__.constructTagDataObject)(tag, options.fields);
            // wrap tag in BikeTagApiResponse
            const response = {
                data: tagData,
                status: 1,
                success: true,
                source: 'sanity',
            };
            // return BikeTagApiResponse
            return response;
        });
    });
}


/***/ }),

/***/ "./src/sanity/index.ts":
/*!*****************************!*\
  !*** ./src/sanity/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* reexport safe */ _deleteTag__WEBPACK_IMPORTED_MODULE_0__.deleteTag),
/* harmony export */   "getTag": () => (/* reexport safe */ _getTag__WEBPACK_IMPORTED_MODULE_1__.getTag),
/* harmony export */   "updateTag": () => (/* reexport safe */ _updateTag__WEBPACK_IMPORTED_MODULE_2__.updateTag),
/* harmony export */   "uploadTagImage": () => (/* reexport safe */ _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__.uploadTagImage)
/* harmony export */ });
/* harmony import */ var _deleteTag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deleteTag */ "./src/sanity/deleteTag.ts");
/* harmony import */ var _getTag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTag */ "./src/sanity/getTag.ts");
/* harmony import */ var _updateTag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateTag */ "./src/sanity/updateTag.ts");
/* harmony import */ var _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uploadTagImage */ "./src/sanity/uploadTagImage.ts");






/***/ }),

/***/ "./src/sanity/updateTag.ts":
/*!*********************************!*\
  !*** ./src/sanity/updateTag.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTag": () => (/* binding */ updateTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function updateTag(client) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        return { client };
    });
}


/***/ }),

/***/ "./src/sanity/uploadTagImage.ts":
/*!**************************************!*\
  !*** ./src/sanity/uploadTagImage.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uploadTagImage": () => (/* binding */ uploadTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function uploadTagImage(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        const req = null;
        if (Array.isArray(payload)) {
            const promises = payload.map((p) => {
                return p;
            });
            return yield Promise.all(promises);
        }
        return yield { client, req };
    });
}


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__values": () => (/* binding */ __values),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(/*! requires-port */ "./node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/querystringify/index.js")
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);

  var match = protocolre.exec(address)
    , protocol = match[1] ? match[1].toLowerCase() : ''
    , slashes = !!(match[2] && match[2].length >= 2)
    , rest =  match[2] && match[2].length === 1 ? '/' + match[3] : match[3];

  return {
    protocol: protocol,
    slashes: slashes,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && url.hostname) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
isSharedArrayBufferToString.working = (
  typeof SharedArrayBuffer !== 'undefined' &&
  isSharedArrayBufferToString(new SharedArrayBuffer())
);
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBuffer === 'undefined') {
    return false;
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBuffer;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! foreach */ "./node_modules/foreach/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js");
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof __webpack_require__.g[typedArray] === 'function') {
			var arr = new __webpack_require__.g[typedArray]();
			if (!(Symbol.toStringTag in arr)) {
				throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
			}
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./src/imgurClient/index.js":
/*!**********************************!*\
  !*** ./src/imgurClient/index.js ***!
  \**********************************/
/***/ (function(module) {

;(function webpackUniversalModuleDefinition(root, factory) {
  //CommonJS2 Comment
  if (true)
    module.exports = factory()
  //AMD Comment
  else {}
})(typeof self !== 'undefined' ? self : this, function () {
  return /******/ (() => {
    // webpackBootstrap
    /******/ var __webpack_modules__ = {
      /***/ './node_modules/array-filter/index.js':
        /*!********************************************!*\
  !*** ./node_modules/array-filter/index.js ***!
  \********************************************/
        /***/ (module) => {
          /**
           * Array#filter.
           *
           * @param {Array} arr
           * @param {Function} fn
           * @param {Object=} self
           * @return {Array}
           * @throw TypeError
           */

          module.exports = function (arr, fn, self) {
            if (arr.filter) return arr.filter(fn, self)
            if (void 0 === arr || null === arr) throw new TypeError()
            if ('function' != typeof fn) throw new TypeError()
            var ret = []
            for (var i = 0; i < arr.length; i++) {
              if (!hasOwn.call(arr, i)) continue
              var val = arr[i]
              if (fn.call(self, val, i, arr)) ret.push(val)
            }
            return ret
          }

          var hasOwn = Object.prototype.hasOwnProperty

          /***/
        },

      /***/ './node_modules/assert/build/assert.js':
        /*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_1883__) => {
          'use strict'
          /* provided dependency */ var process = __nested_webpack_require_1883__(
            /*! process/browser */ './node_modules/process/browser.js'
          )
          /* provided dependency */ var console = __nested_webpack_require_1883__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )
          // Currently in sync with Node.js lib/assert.js
          // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
          // Originally from narwhal.js (http://narwhaljs.org)
          // Copyright (c) 2009 Thomas Robinson <280north.com>
          //
          // Permission is hereby granted, free of charge, to any person obtaining a copy
          // of this software and associated documentation files (the 'Software'), to
          // deal in the Software without restriction, including without limitation the
          // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          // sell copies of the Software, and to permit persons to whom the Software is
          // furnished to do so, subject to the following conditions:
          //
          // The above copyright notice and this permission notice shall be included in
          // all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
          // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
          // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          var _require = __nested_webpack_require_1883__(
              /*! ./internal/errors */ './node_modules/assert/build/internal/errors.js'
            ),
            _require$codes = _require.codes,
            ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
            ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
            ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
            ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
            ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS

          var AssertionError = __nested_webpack_require_1883__(
            /*! ./internal/assert/assertion_error */ './node_modules/assert/build/internal/assert/assertion_error.js'
          )

          var _require2 = __nested_webpack_require_1883__(
              /*! util/ */ './node_modules/util/util.js'
            ),
            inspect = _require2.inspect

          var _require$types = __nested_webpack_require_1883__(
              /*! util/ */ './node_modules/util/util.js'
            ).types,
            isPromise = _require$types.isPromise,
            isRegExp = _require$types.isRegExp

          var objectAssign = Object.assign
            ? Object.assign
            : __nested_webpack_require_1883__(
                /*! es6-object-assign */ './node_modules/es6-object-assign/index.js'
              ).assign
          var objectIs = Object.is
            ? Object.is
            : __nested_webpack_require_1883__(
                /*! object-is */ './node_modules/object-is/index.js'
              )
          var errorCache = new Map()
          var isDeepEqual
          var isDeepStrictEqual
          var parseExpressionAt
          var findNodeAround
          var decoder

          function lazyLoadComparison() {
            var comparison = __nested_webpack_require_1883__(
              /*! ./internal/util/comparisons */ './node_modules/assert/build/internal/util/comparisons.js'
            )

            isDeepEqual = comparison.isDeepEqual
            isDeepStrictEqual = comparison.isDeepStrictEqual
          } // Escape control characters but not \n and \t to keep the line breaks and
          // indentation intact.
          // eslint-disable-next-line no-control-regex

          var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g
          var meta = [
            '\\u0000',
            '\\u0001',
            '\\u0002',
            '\\u0003',
            '\\u0004',
            '\\u0005',
            '\\u0006',
            '\\u0007',
            '\\b',
            '',
            '',
            '\\u000b',
            '\\f',
            '',
            '\\u000e',
            '\\u000f',
            '\\u0010',
            '\\u0011',
            '\\u0012',
            '\\u0013',
            '\\u0014',
            '\\u0015',
            '\\u0016',
            '\\u0017',
            '\\u0018',
            '\\u0019',
            '\\u001a',
            '\\u001b',
            '\\u001c',
            '\\u001d',
            '\\u001e',
            '\\u001f',
          ]

          var escapeFn = function escapeFn(str) {
            return meta[str.charCodeAt(0)]
          }

          var warned = false // The assert module provides functions that throw
          // AssertionError's when particular conditions are not met. The
          // assert module must conform to the following interface.

          var assert = (module.exports = ok)
          var NO_EXCEPTION_SENTINEL = {} // All of the following functions must throw an AssertionError
          // when a corresponding condition is not met, with a message that
          // may be undefined if not provided. All assertion methods provide
          // both the actual and expected values to the assertion error for
          // display purposes.

          function innerFail(obj) {
            if (obj.message instanceof Error) throw obj.message
            throw new AssertionError(obj)
          }

          function fail(actual, expected, message, operator, stackStartFn) {
            var argsLen = arguments.length
            var internalMessage

            if (argsLen === 0) {
              internalMessage = 'Failed'
            } else if (argsLen === 1) {
              message = actual
              actual = undefined
            } else {
              if (warned === false) {
                warned = true
                var warn = process.emitWarning
                  ? process.emitWarning
                  : console.warn.bind(console)
                warn(
                  'assert.fail() with more than one argument is deprecated. ' +
                    'Please use assert.strictEqual() instead or only pass a message.',
                  'DeprecationWarning',
                  'DEP0094'
                )
              }

              if (argsLen === 2) operator = '!='
            }

            if (message instanceof Error) throw message
            var errArgs = {
              actual: actual,
              expected: expected,
              operator: operator === undefined ? 'fail' : operator,
              stackStartFn: stackStartFn || fail,
            }

            if (message !== undefined) {
              errArgs.message = message
            }

            var err = new AssertionError(errArgs)

            if (internalMessage) {
              err.message = internalMessage
              err.generatedMessage = true
            }

            throw err
          }

          assert.fail = fail // The AssertionError is defined in internal/error.

          assert.AssertionError = AssertionError

          function innerOk(fn, argLen, value, message) {
            if (!value) {
              var generatedMessage = false

              if (argLen === 0) {
                generatedMessage = true
                message = 'No value argument passed to `assert.ok()`'
              } else if (message instanceof Error) {
                throw message
              }

              var err = new AssertionError({
                actual: value,
                expected: true,
                message: message,
                operator: '==',
                stackStartFn: fn,
              })
              err.generatedMessage = generatedMessage
              throw err
            }
          } // Pure assertion tests whether a value is truthy, as determined
          // by !!value.

          function ok() {
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key]
            }

            innerOk.apply(void 0, [ok, args.length].concat(args))
          }

          assert.ok = ok // The equality assertion tests shallow, coercive equality with ==.

          /* eslint-disable no-restricted-properties */

          assert.equal = function equal(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            } // eslint-disable-next-line eqeqeq

            if (actual != expected) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: '==',
                stackStartFn: equal,
              })
            }
          } // The non-equality assertion tests for whether two objects are not
          // equal with !=.

          assert.notEqual = function notEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            } // eslint-disable-next-line eqeqeq

            if (actual == expected) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: '!=',
                stackStartFn: notEqual,
              })
            }
          } // The equivalence assertion tests a deep equality relation.

          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (!isDeepEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'deepEqual',
                stackStartFn: deepEqual,
              })
            }
          } // The non-equivalence assertion tests for any deep inequality.

          assert.notDeepEqual = function notDeepEqual(
            actual,
            expected,
            message
          ) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (isDeepEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'notDeepEqual',
                stackStartFn: notDeepEqual,
              })
            }
          }
          /* eslint-enable */

          assert.deepStrictEqual = function deepStrictEqual(
            actual,
            expected,
            message
          ) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (!isDeepStrictEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'deepStrictEqual',
                stackStartFn: deepStrictEqual,
              })
            }
          }

          assert.notDeepStrictEqual = notDeepStrictEqual

          function notDeepStrictEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (isDeepStrictEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'notDeepStrictEqual',
                stackStartFn: notDeepStrictEqual,
              })
            }
          }

          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (!objectIs(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'strictEqual',
                stackStartFn: strictEqual,
              })
            }
          }

          assert.notStrictEqual = function notStrictEqual(
            actual,
            expected,
            message
          ) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (objectIs(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'notStrictEqual',
                stackStartFn: notStrictEqual,
              })
            }
          }

          var Comparison = function Comparison(obj, keys, actual) {
            var _this = this

            _classCallCheck(this, Comparison)

            keys.forEach(function (key) {
              if (key in obj) {
                if (
                  actual !== undefined &&
                  typeof actual[key] === 'string' &&
                  isRegExp(obj[key]) &&
                  obj[key].test(actual[key])
                ) {
                  _this[key] = actual[key]
                } else {
                  _this[key] = obj[key]
                }
              }
            })
          }

          function compareExceptionKey(
            actual,
            expected,
            key,
            message,
            keys,
            fn
          ) {
            if (
              !(key in actual) ||
              !isDeepStrictEqual(actual[key], expected[key])
            ) {
              if (!message) {
                // Create placeholder objects to create a nice output.
                var a = new Comparison(actual, keys)
                var b = new Comparison(expected, keys, actual)
                var err = new AssertionError({
                  actual: a,
                  expected: b,
                  operator: 'deepStrictEqual',
                  stackStartFn: fn,
                })
                err.actual = actual
                err.expected = expected
                err.operator = fn.name
                throw err
              }

              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: fn.name,
                stackStartFn: fn,
              })
            }
          }

          function expectedException(actual, expected, msg, fn) {
            if (typeof expected !== 'function') {
              if (isRegExp(expected)) return expected.test(actual) // assert.doesNotThrow does not accept objects.

              if (arguments.length === 2) {
                throw new ERR_INVALID_ARG_TYPE(
                  'expected',
                  ['Function', 'RegExp'],
                  expected
                )
              } // Handle primitives properly.

              if (_typeof(actual) !== 'object' || actual === null) {
                var err = new AssertionError({
                  actual: actual,
                  expected: expected,
                  message: msg,
                  operator: 'deepStrictEqual',
                  stackStartFn: fn,
                })
                err.operator = fn.name
                throw err
              }

              var keys = Object.keys(expected) // Special handle errors to make sure the name and the message are compared
              // as well.

              if (expected instanceof Error) {
                keys.push('name', 'message')
              } else if (keys.length === 0) {
                throw new ERR_INVALID_ARG_VALUE(
                  'error',
                  expected,
                  'may not be an empty object'
                )
              }

              if (isDeepEqual === undefined) lazyLoadComparison()
              keys.forEach(function (key) {
                if (
                  typeof actual[key] === 'string' &&
                  isRegExp(expected[key]) &&
                  expected[key].test(actual[key])
                ) {
                  return
                }

                compareExceptionKey(actual, expected, key, msg, keys, fn)
              })
              return true
            } // Guard instanceof against arrow functions as they don't have a prototype.

            if (
              expected.prototype !== undefined &&
              actual instanceof expected
            ) {
              return true
            }

            if (Error.isPrototypeOf(expected)) {
              return false
            }

            return expected.call({}, actual) === true
          }

          function getActual(fn) {
            if (typeof fn !== 'function') {
              throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn)
            }

            try {
              fn()
            } catch (e) {
              return e
            }

            return NO_EXCEPTION_SENTINEL
          }

          function checkIsPromise(obj) {
            // Accept native ES6 promises and promises that are implemented in a similar
            // way. Do not accept thenables that use a function as `obj` and that have no
            // `catch` handler.
            // TODO: thenables are checked up until they have the correct methods,
            // but according to documentation, the `then` method should receive
            // the `fulfill` and `reject` arguments as well or it may be never resolved.
            return (
              isPromise(obj) ||
              (obj !== null &&
                _typeof(obj) === 'object' &&
                typeof obj.then === 'function' &&
                typeof obj.catch === 'function')
            )
          }

          function waitForActual(promiseFn) {
            return Promise.resolve().then(function () {
              var resultPromise

              if (typeof promiseFn === 'function') {
                // Return a rejected promise if `promiseFn` throws synchronously.
                resultPromise = promiseFn() // Fail in case no promise is returned.

                if (!checkIsPromise(resultPromise)) {
                  throw new ERR_INVALID_RETURN_VALUE(
                    'instance of Promise',
                    'promiseFn',
                    resultPromise
                  )
                }
              } else if (checkIsPromise(promiseFn)) {
                resultPromise = promiseFn
              } else {
                throw new ERR_INVALID_ARG_TYPE(
                  'promiseFn',
                  ['Function', 'Promise'],
                  promiseFn
                )
              }

              return Promise.resolve()
                .then(function () {
                  return resultPromise
                })
                .then(function () {
                  return NO_EXCEPTION_SENTINEL
                })
                .catch(function (e) {
                  return e
                })
            })
          }

          function expectsError(stackStartFn, actual, error, message) {
            if (typeof error === 'string') {
              if (arguments.length === 4) {
                throw new ERR_INVALID_ARG_TYPE(
                  'error',
                  ['Object', 'Error', 'Function', 'RegExp'],
                  error
                )
              }

              if (_typeof(actual) === 'object' && actual !== null) {
                if (actual.message === error) {
                  throw new ERR_AMBIGUOUS_ARGUMENT(
                    'error/message',
                    'The error message "'.concat(
                      actual.message,
                      '" is identical to the message.'
                    )
                  )
                }
              } else if (actual === error) {
                throw new ERR_AMBIGUOUS_ARGUMENT(
                  'error/message',
                  'The error "'.concat(actual, '" is identical to the message.')
                )
              }

              message = error
              error = undefined
            } else if (
              error != null &&
              _typeof(error) !== 'object' &&
              typeof error !== 'function'
            ) {
              throw new ERR_INVALID_ARG_TYPE(
                'error',
                ['Object', 'Error', 'Function', 'RegExp'],
                error
              )
            }

            if (actual === NO_EXCEPTION_SENTINEL) {
              var details = ''

              if (error && error.name) {
                details += ' ('.concat(error.name, ')')
              }

              details += message ? ': '.concat(message) : '.'
              var fnType =
                stackStartFn.name === 'rejects' ? 'rejection' : 'exception'
              innerFail({
                actual: undefined,
                expected: error,
                operator: stackStartFn.name,
                message: 'Missing expected '.concat(fnType).concat(details),
                stackStartFn: stackStartFn,
              })
            }

            if (
              error &&
              !expectedException(actual, error, message, stackStartFn)
            ) {
              throw actual
            }
          }

          function expectsNoError(stackStartFn, actual, error, message) {
            if (actual === NO_EXCEPTION_SENTINEL) return

            if (typeof error === 'string') {
              message = error
              error = undefined
            }

            if (!error || expectedException(actual, error)) {
              var details = message ? ': '.concat(message) : '.'
              var fnType =
                stackStartFn.name === 'doesNotReject'
                  ? 'rejection'
                  : 'exception'
              innerFail({
                actual: actual,
                expected: error,
                operator: stackStartFn.name,
                message:
                  'Got unwanted '.concat(fnType).concat(details, '\n') +
                  'Actual message: "'.concat(actual && actual.message, '"'),
                stackStartFn: stackStartFn,
              })
            }

            throw actual
          }

          assert.throws = function throws(promiseFn) {
            for (
              var _len2 = arguments.length,
                args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                _key2 = 1;
              _key2 < _len2;
              _key2++
            ) {
              args[_key2 - 1] = arguments[_key2]
            }

            expectsError.apply(
              void 0,
              [throws, getActual(promiseFn)].concat(args)
            )
          }

          assert.rejects = function rejects(promiseFn) {
            for (
              var _len3 = arguments.length,
                args = new Array(_len3 > 1 ? _len3 - 1 : 0),
                _key3 = 1;
              _key3 < _len3;
              _key3++
            ) {
              args[_key3 - 1] = arguments[_key3]
            }

            return waitForActual(promiseFn).then(function (result) {
              return expectsError.apply(void 0, [rejects, result].concat(args))
            })
          }

          assert.doesNotThrow = function doesNotThrow(fn) {
            for (
              var _len4 = arguments.length,
                args = new Array(_len4 > 1 ? _len4 - 1 : 0),
                _key4 = 1;
              _key4 < _len4;
              _key4++
            ) {
              args[_key4 - 1] = arguments[_key4]
            }

            expectsNoError.apply(
              void 0,
              [doesNotThrow, getActual(fn)].concat(args)
            )
          }

          assert.doesNotReject = function doesNotReject(fn) {
            for (
              var _len5 = arguments.length,
                args = new Array(_len5 > 1 ? _len5 - 1 : 0),
                _key5 = 1;
              _key5 < _len5;
              _key5++
            ) {
              args[_key5 - 1] = arguments[_key5]
            }

            return waitForActual(fn).then(function (result) {
              return expectsNoError.apply(
                void 0,
                [doesNotReject, result].concat(args)
              )
            })
          }

          assert.ifError = function ifError(err) {
            if (err !== null && err !== undefined) {
              var message = 'ifError got unwanted exception: '

              if (
                _typeof(err) === 'object' &&
                typeof err.message === 'string'
              ) {
                if (err.message.length === 0 && err.constructor) {
                  message += err.constructor.name
                } else {
                  message += err.message
                }
              } else {
                message += inspect(err)
              }

              var newErr = new AssertionError({
                actual: err,
                expected: null,
                operator: 'ifError',
                message: message,
                stackStartFn: ifError,
              }) // Make sure we actually have a stack trace!

              var origStack = err.stack

              if (typeof origStack === 'string') {
                // This will remove any duplicated frames from the error frames taken
                // from within `ifError` and add the original error frames to the newly
                // created ones.
                var tmp2 = origStack.split('\n')
                tmp2.shift() // Filter all frames existing in err.stack.

                var tmp1 = newErr.stack.split('\n')

                for (var i = 0; i < tmp2.length; i++) {
                  // Find the first occurrence of the frame.
                  var pos = tmp1.indexOf(tmp2[i])

                  if (pos !== -1) {
                    // Only keep new frames.
                    tmp1 = tmp1.slice(0, pos)
                    break
                  }
                }

                newErr.stack = ''
                  .concat(tmp1.join('\n'), '\n')
                  .concat(tmp2.join('\n'))
              }

              throw newErr
            }
          } // Expose a strict only variant of assert

          function strict() {
            for (
              var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;
              _key6 < _len6;
              _key6++
            ) {
              args[_key6] = arguments[_key6]
            }

            innerOk.apply(void 0, [strict, args.length].concat(args))
          }

          assert.strict = objectAssign(strict, assert, {
            equal: assert.strictEqual,
            deepEqual: assert.deepStrictEqual,
            notEqual: assert.notStrictEqual,
            notDeepEqual: assert.notDeepStrictEqual,
          })
          assert.strict.strict = assert.strict

          /***/
        },

      /***/ './node_modules/assert/build/internal/assert/assertion_error.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_30709__) => {
          'use strict'
          /* provided dependency */ var process = __nested_webpack_require_30709__(
            /*! process/browser */ './node_modules/process/browser.js'
          )
          // Currently in sync with Node.js lib/internal/assert/assertion_error.js
          // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {}
              var ownKeys = Object.keys(source)
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(
                  Object.getOwnPropertySymbols(source).filter(function (sym) {
                    return Object.getOwnPropertyDescriptor(
                      source,
                      sym
                    ).enumerable
                  })
                )
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key])
              })
            }
            return target
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i]
              descriptor.enumerable = descriptor.enumerable || false
              descriptor.configurable = true
              if ('value' in descriptor) descriptor.writable = true
              Object.defineProperty(target, descriptor.key, descriptor)
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps)
            if (staticProps) _defineProperties(Constructor, staticProps)
            return Constructor
          }

          function _possibleConstructorReturn(self, call) {
            if (
              call &&
              (_typeof(call) === 'object' || typeof call === 'function')
            ) {
              return call
            }
            return _assertThisInitialized(self)
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function'
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass) _setPrototypeOf(subClass, superClass)
          }

          function _wrapNativeSuper(Class) {
            var _cache = typeof Map === 'function' ? new Map() : undefined
            _wrapNativeSuper = function _wrapNativeSuper(Class) {
              if (Class === null || !_isNativeFunction(Class)) return Class
              if (typeof Class !== 'function') {
                throw new TypeError(
                  'Super expression must either be null or a function'
                )
              }
              if (typeof _cache !== 'undefined') {
                if (_cache.has(Class)) return _cache.get(Class)
                _cache.set(Class, Wrapper)
              }
              function Wrapper() {
                return _construct(
                  Class,
                  arguments,
                  _getPrototypeOf(this).constructor
                )
              }
              Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                  value: Wrapper,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              })
              return _setPrototypeOf(Wrapper, Class)
            }
            return _wrapNativeSuper(Class)
          }

          function isNativeReflectConstruct() {
            if (typeof Reflect === 'undefined' || !Reflect.construct)
              return false
            if (Reflect.construct.sham) return false
            if (typeof Proxy === 'function') return true
            try {
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              )
              return true
            } catch (e) {
              return false
            }
          }

          function _construct(Parent, args, Class) {
            if (isNativeReflectConstruct()) {
              _construct = Reflect.construct
            } else {
              _construct = function _construct(Parent, args, Class) {
                var a = [null]
                a.push.apply(a, args)
                var Constructor = Function.bind.apply(Parent, a)
                var instance = new Constructor()
                if (Class) _setPrototypeOf(instance, Class.prototype)
                return instance
              }
            }
            return _construct.apply(null, arguments)
          }

          function _isNativeFunction(fn) {
            return Function.toString.call(fn).indexOf('[native code]') !== -1
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                o.__proto__ = p
                return o
              }
            return _setPrototypeOf(o, p)
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o)
                }
            return _getPrototypeOf(o)
          }

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          var _require = __nested_webpack_require_30709__(
              /*! util/ */ './node_modules/util/util.js'
            ),
            inspect = _require.inspect

          var _require2 = __nested_webpack_require_30709__(
              /*! ../errors */ './node_modules/assert/build/internal/errors.js'
            ),
            ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

          function endsWith(str, search, this_len) {
            if (this_len === undefined || this_len > str.length) {
              this_len = str.length
            }

            return str.substring(this_len - search.length, this_len) === search
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

          function repeat(str, count) {
            count = Math.floor(count)
            if (str.length == 0 || count == 0) return ''
            var maxCount = str.length * count
            count = Math.floor(Math.log(count) / Math.log(2))

            while (count) {
              str += str
              count--
            }

            str += str.substring(0, maxCount - str.length)
            return str
          }

          var blue = ''
          var green = ''
          var red = ''
          var white = ''
          var kReadableOperator = {
            deepStrictEqual: 'Expected values to be strictly deep-equal:',
            strictEqual: 'Expected values to be strictly equal:',
            strictEqualObject:
              'Expected "actual" to be reference-equal to "expected":',
            deepEqual: 'Expected values to be loosely deep-equal:',
            equal: 'Expected values to be loosely equal:',
            notDeepStrictEqual:
              'Expected "actual" not to be strictly deep-equal to:',
            notStrictEqual: 'Expected "actual" to be strictly unequal to:',
            notStrictEqualObject:
              'Expected "actual" not to be reference-equal to "expected":',
            notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
            notEqual: 'Expected "actual" to be loosely unequal to:',
            notIdentical: 'Values identical but not reference-equal:',
          } // Comparing short primitives should just show === / !== instead of using the
          // diff.

          var kMaxShortLength = 10

          function copyError(source) {
            var keys = Object.keys(source)
            var target = Object.create(Object.getPrototypeOf(source))
            keys.forEach(function (key) {
              target[key] = source[key]
            })
            Object.defineProperty(target, 'message', {
              value: source.message,
            })
            return target
          }

          function inspectValue(val) {
            // The util.inspect default values could be changed. This makes sure the
            // error messages contain the necessary information nevertheless.
            return inspect(val, {
              compact: false,
              customInspect: false,
              depth: 1000,
              maxArrayLength: Infinity,
              // Assert compares only enumerable properties (with a few exceptions).
              showHidden: false,
              // Having a long line as error is better than wrapping the line for
              // comparison for now.
              // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
              // have meta information about the inspected properties (i.e., know where
              // in what line the property starts and ends).
              breakLength: Infinity,
              // Assert does not detect proxies currently.
              showProxy: false,
              sorted: true,
              // Inspect getters as we also check them when comparing entries.
              getters: true,
            })
          }

          function createErrDiff(actual, expected, operator) {
            var other = ''
            var res = ''
            var lastPos = 0
            var end = ''
            var skipped = false
            var actualInspected = inspectValue(actual)
            var actualLines = actualInspected.split('\n')
            var expectedLines = inspectValue(expected).split('\n')
            var i = 0
            var indicator = '' // In case both values are objects explicitly mark them as not reference equal
            // for the `strictEqual` operator.

            if (
              operator === 'strictEqual' &&
              _typeof(actual) === 'object' &&
              _typeof(expected) === 'object' &&
              actual !== null &&
              expected !== null
            ) {
              operator = 'strictEqualObject'
            } // If "actual" and "expected" fit on a single line and they are not strictly
            // equal, check further special handling.

            if (
              actualLines.length === 1 &&
              expectedLines.length === 1 &&
              actualLines[0] !== expectedLines[0]
            ) {
              var inputLength = actualLines[0].length + expectedLines[0].length // If the character length of "actual" and "expected" together is less than
              // kMaxShortLength and if neither is an object and at least one of them is
              // not `zero`, use the strict equal comparison to visualize the output.

              if (inputLength <= kMaxShortLength) {
                if (
                  (_typeof(actual) !== 'object' || actual === null) &&
                  (_typeof(expected) !== 'object' || expected === null) &&
                  (actual !== 0 || expected !== 0)
                ) {
                  // -0 === +0
                  return (
                    ''.concat(kReadableOperator[operator], '\n\n') +
                    ''
                      .concat(actualLines[0], ' !== ')
                      .concat(expectedLines[0], '\n')
                  )
                }
              } else if (operator !== 'strictEqualObject') {
                // If the stderr is a tty and the input length is lower than the current
                // columns per line, add a mismatch indicator below the output. If it is
                // not a tty, use a default value of 80 characters.
                var maxLength =
                  process.stderr && process.stderr.isTTY
                    ? process.stderr.columns
                    : 80

                if (inputLength < maxLength) {
                  while (actualLines[0][i] === expectedLines[0][i]) {
                    i++
                  } // Ignore the first characters.

                  if (i > 2) {
                    // Add position indicator for the first mismatch in case it is a
                    // single line and the input length is less than the column length.
                    indicator = '\n  '.concat(repeat(' ', i), '^')
                    i = 0
                  }
                }
              }
            } // Remove all ending lines that match (this optimizes the output for
            // readability by reducing the number of total changed lines).

            var a = actualLines[actualLines.length - 1]
            var b = expectedLines[expectedLines.length - 1]

            while (a === b) {
              if (i++ < 2) {
                end = '\n  '.concat(a).concat(end)
              } else {
                other = a
              }

              actualLines.pop()
              expectedLines.pop()
              if (actualLines.length === 0 || expectedLines.length === 0) break
              a = actualLines[actualLines.length - 1]
              b = expectedLines[expectedLines.length - 1]
            }

            var maxLines = Math.max(actualLines.length, expectedLines.length) // Strict equal with identical objects that are not identical by reference.
            // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

            if (maxLines === 0) {
              // We have to get the result again. The lines were all removed before.
              var _actualLines = actualInspected.split('\n') // Only remove lines in case it makes sense to collapse those.
              // TODO: Accept env to always show the full error.

              if (_actualLines.length > 30) {
                _actualLines[26] = ''.concat(blue, '...').concat(white)

                while (_actualLines.length > 27) {
                  _actualLines.pop()
                }
              }

              return ''
                .concat(kReadableOperator.notIdentical, '\n\n')
                .concat(_actualLines.join('\n'), '\n')
            }

            if (i > 3) {
              end = '\n'.concat(blue, '...').concat(white).concat(end)
              skipped = true
            }

            if (other !== '') {
              end = '\n  '.concat(other).concat(end)
              other = ''
            }

            var printedLines = 0
            var msg =
              kReadableOperator[operator] +
              '\n'
                .concat(green, '+ actual')
                .concat(white, ' ')
                .concat(red, '- expected')
                .concat(white)
            var skippedMsg = ' '
              .concat(blue, '...')
              .concat(white, ' Lines skipped')

            for (i = 0; i < maxLines; i++) {
              // Only extra expected lines exist
              var cur = i - lastPos

              if (actualLines.length < i + 1) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                  if (cur > 4) {
                    res += '\n'.concat(blue, '...').concat(white)
                    skipped = true
                  } else if (cur > 3) {
                    res += '\n  '.concat(expectedLines[i - 2])
                    printedLines++
                  }

                  res += '\n  '.concat(expectedLines[i - 1])
                  printedLines++
                } // Mark the current line as the last diverging one.

                lastPos = i // Add the expected line to the cache.

                other += '\n'
                  .concat(red, '-')
                  .concat(white, ' ')
                  .concat(expectedLines[i])
                printedLines++ // Only extra actual lines exist
              } else if (expectedLines.length < i + 1) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                  if (cur > 4) {
                    res += '\n'.concat(blue, '...').concat(white)
                    skipped = true
                  } else if (cur > 3) {
                    res += '\n  '.concat(actualLines[i - 2])
                    printedLines++
                  }

                  res += '\n  '.concat(actualLines[i - 1])
                  printedLines++
                } // Mark the current line as the last diverging one.

                lastPos = i // Add the actual line to the result.

                res += '\n'
                  .concat(green, '+')
                  .concat(white, ' ')
                  .concat(actualLines[i])
                printedLines++ // Lines diverge
              } else {
                var expectedLine = expectedLines[i]
                var actualLine = actualLines[i] // If the lines diverge, specifically check for lines that only diverge by
                // a trailing comma. In that case it is actually identical and we should
                // mark it as such.

                var divergingLines =
                  actualLine !== expectedLine &&
                  (!endsWith(actualLine, ',') ||
                    actualLine.slice(0, -1) !== expectedLine) // If the expected line has a trailing comma but is otherwise identical,
                // add a comma at the end of the actual line. Otherwise the output could
                // look weird as in:
                //
                //   [
                //     1         // No comma at the end!
                // +   2
                //   ]
                //

                if (
                  divergingLines &&
                  endsWith(expectedLine, ',') &&
                  expectedLine.slice(0, -1) === actualLine
                ) {
                  divergingLines = false
                  actualLine += ','
                }

                if (divergingLines) {
                  // If the last diverging line is more than one line above and the
                  // current line is at least line three, add some of the former lines and
                  // also add dots to indicate skipped entries.
                  if (cur > 1 && i > 2) {
                    if (cur > 4) {
                      res += '\n'.concat(blue, '...').concat(white)
                      skipped = true
                    } else if (cur > 3) {
                      res += '\n  '.concat(actualLines[i - 2])
                      printedLines++
                    }

                    res += '\n  '.concat(actualLines[i - 1])
                    printedLines++
                  } // Mark the current line as the last diverging one.

                  lastPos = i // Add the actual line to the result and cache the expected diverging
                  // line so consecutive diverging lines show up as +++--- and not +-+-+-.

                  res += '\n'
                    .concat(green, '+')
                    .concat(white, ' ')
                    .concat(actualLine)
                  other += '\n'
                    .concat(red, '-')
                    .concat(white, ' ')
                    .concat(expectedLine)
                  printedLines += 2 // Lines are identical
                } else {
                  // Add all cached information to the result before adding other things
                  // and reset the cache.
                  res += other
                  other = '' // If the last diverging line is exactly one line above or if it is the
                  // very first line, add the line to the result.

                  if (cur === 1 || i === 0) {
                    res += '\n  '.concat(actualLine)
                    printedLines++
                  }
                }
              } // Inspected object to big (Show ~20 rows max)

              if (printedLines > 20 && i < maxLines - 2) {
                return (
                  ''
                    .concat(msg)
                    .concat(skippedMsg, '\n')
                    .concat(res, '\n')
                    .concat(blue, '...')
                    .concat(white)
                    .concat(other, '\n') + ''.concat(blue, '...').concat(white)
                )
              }
            }

            return ''
              .concat(msg)
              .concat(skipped ? skippedMsg : '', '\n')
              .concat(res)
              .concat(other)
              .concat(end)
              .concat(indicator)
          }

          var AssertionError =
            /*#__PURE__*/
            (function (_Error) {
              _inherits(AssertionError, _Error)

              function AssertionError(options) {
                var _this

                _classCallCheck(this, AssertionError)

                if (_typeof(options) !== 'object' || options === null) {
                  throw new ERR_INVALID_ARG_TYPE('options', 'Object', options)
                }

                var message = options.message,
                  operator = options.operator,
                  stackStartFn = options.stackStartFn
                var actual = options.actual,
                  expected = options.expected
                var limit = Error.stackTraceLimit
                Error.stackTraceLimit = 0

                if (message != null) {
                  _this = _possibleConstructorReturn(
                    this,
                    _getPrototypeOf(AssertionError).call(this, String(message))
                  )
                } else {
                  if (process.stderr && process.stderr.isTTY) {
                    // Reset on each call to make sure we handle dynamically set environment
                    // variables correct.
                    if (
                      process.stderr &&
                      process.stderr.getColorDepth &&
                      process.stderr.getColorDepth() !== 1
                    ) {
                      blue = '\x1B[34m'
                      green = '\x1B[32m'
                      white = '\x1B[39m'
                      red = '\x1B[31m'
                    } else {
                      blue = ''
                      green = ''
                      white = ''
                      red = ''
                    }
                  } // Prevent the error stack from being visible by duplicating the error
                  // in a very close way to the original in case both sides are actually
                  // instances of Error.

                  if (
                    _typeof(actual) === 'object' &&
                    actual !== null &&
                    _typeof(expected) === 'object' &&
                    expected !== null &&
                    'stack' in actual &&
                    actual instanceof Error &&
                    'stack' in expected &&
                    expected instanceof Error
                  ) {
                    actual = copyError(actual)
                    expected = copyError(expected)
                  }

                  if (
                    operator === 'deepStrictEqual' ||
                    operator === 'strictEqual'
                  ) {
                    _this = _possibleConstructorReturn(
                      this,
                      _getPrototypeOf(AssertionError).call(
                        this,
                        createErrDiff(actual, expected, operator)
                      )
                    )
                  } else if (
                    operator === 'notDeepStrictEqual' ||
                    operator === 'notStrictEqual'
                  ) {
                    // In case the objects are equal but the operator requires unequal, show
                    // the first object and say A equals B
                    var base = kReadableOperator[operator]
                    var res = inspectValue(actual).split('\n') // In case "actual" is an object, it should not be reference equal.

                    if (
                      operator === 'notStrictEqual' &&
                      _typeof(actual) === 'object' &&
                      actual !== null
                    ) {
                      base = kReadableOperator.notStrictEqualObject
                    } // Only remove lines in case it makes sense to collapse those.
                    // TODO: Accept env to always show the full error.

                    if (res.length > 30) {
                      res[26] = ''.concat(blue, '...').concat(white)

                      while (res.length > 27) {
                        res.pop()
                      }
                    } // Only print a single input.

                    if (res.length === 1) {
                      _this = _possibleConstructorReturn(
                        this,
                        _getPrototypeOf(AssertionError).call(
                          this,
                          ''.concat(base, ' ').concat(res[0])
                        )
                      )
                    } else {
                      _this = _possibleConstructorReturn(
                        this,
                        _getPrototypeOf(AssertionError).call(
                          this,
                          ''.concat(base, '\n\n').concat(res.join('\n'), '\n')
                        )
                      )
                    }
                  } else {
                    var _res = inspectValue(actual)

                    var other = ''
                    var knownOperators = kReadableOperator[operator]

                    if (
                      operator === 'notDeepEqual' ||
                      operator === 'notEqual'
                    ) {
                      _res = ''
                        .concat(kReadableOperator[operator], '\n\n')
                        .concat(_res)

                      if (_res.length > 1024) {
                        _res = ''.concat(_res.slice(0, 1021), '...')
                      }
                    } else {
                      other = ''.concat(inspectValue(expected))

                      if (_res.length > 512) {
                        _res = ''.concat(_res.slice(0, 509), '...')
                      }

                      if (other.length > 512) {
                        other = ''.concat(other.slice(0, 509), '...')
                      }

                      if (operator === 'deepEqual' || operator === 'equal') {
                        _res = ''
                          .concat(knownOperators, '\n\n')
                          .concat(_res, '\n\nshould equal\n\n')
                      } else {
                        other = ' '.concat(operator, ' ').concat(other)
                      }
                    }

                    _this = _possibleConstructorReturn(
                      this,
                      _getPrototypeOf(AssertionError).call(
                        this,
                        ''.concat(_res).concat(other)
                      )
                    )
                  }
                }

                Error.stackTraceLimit = limit
                _this.generatedMessage = !message
                Object.defineProperty(_assertThisInitialized(_this), 'name', {
                  value: 'AssertionError [ERR_ASSERTION]',
                  enumerable: false,
                  writable: true,
                  configurable: true,
                })
                _this.code = 'ERR_ASSERTION'
                _this.actual = actual
                _this.expected = expected
                _this.operator = operator

                if (Error.captureStackTrace) {
                  // eslint-disable-next-line no-restricted-syntax
                  Error.captureStackTrace(
                    _assertThisInitialized(_this),
                    stackStartFn
                  )
                } // Create error message including the error code in the name.

                _this.stack // Reset the name.

                _this.name = 'AssertionError'
                return _possibleConstructorReturn(_this)
              }

              _createClass(AssertionError, [
                {
                  key: 'toString',
                  value: function toString() {
                    return ''
                      .concat(this.name, ' [')
                      .concat(this.code, ']: ')
                      .concat(this.message)
                  },
                },
                {
                  key: inspect.custom,
                  value: function value(recurseTimes, ctx) {
                    // This limits the `actual` and `expected` property default inspection to
                    // the minimum depth. Otherwise those values would be too verbose compared
                    // to the actual error message which contains a combined view of these two
                    // input values.
                    return inspect(
                      this,
                      _objectSpread({}, ctx, {
                        customInspect: false,
                        depth: 0,
                      })
                    )
                  },
                },
              ])

              return AssertionError
            })(_wrapNativeSuper(Error))

          module.exports = AssertionError

          /***/
        },

      /***/ './node_modules/assert/build/internal/errors.js':
        /*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_62541__) => {
          'use strict'
          // Currently in sync with Node.js lib/internal/errors.js
          // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

          /* eslint node-core/documented-errors: "error" */

          /* eslint node-core/alphabetize-errors: "error" */

          /* eslint node-core/prefer-util-format-errors: "error" */
          // The whole point behind this internal module is to allow Node.js to no
          // longer be forced to treat every error message change as a semver-major
          // change. The NodeError classes here all expose a `code` property whose
          // value statically and permanently identifies the error. While the error
          // message may change, the code should not.

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (
              call &&
              (_typeof(call) === 'object' || typeof call === 'function')
            ) {
              return call
            }
            return _assertThisInitialized(self)
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return self
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o)
                }
            return _getPrototypeOf(o)
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function'
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass) _setPrototypeOf(subClass, superClass)
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                o.__proto__ = p
                return o
              }
            return _setPrototypeOf(o, p)
          }

          var codes = {} // Lazy loaded

          var assert
          var util

          function createErrorType(code, message, Base) {
            if (!Base) {
              Base = Error
            }

            function getMessage(arg1, arg2, arg3) {
              if (typeof message === 'string') {
                return message
              } else {
                return message(arg1, arg2, arg3)
              }
            }

            var NodeError =
              /*#__PURE__*/
              (function (_Base) {
                _inherits(NodeError, _Base)

                function NodeError(arg1, arg2, arg3) {
                  var _this

                  _classCallCheck(this, NodeError)

                  _this = _possibleConstructorReturn(
                    this,
                    _getPrototypeOf(NodeError).call(
                      this,
                      getMessage(arg1, arg2, arg3)
                    )
                  )
                  _this.code = code
                  return _this
                }

                return NodeError
              })(Base)

            codes[code] = NodeError
          } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

          function oneOf(expected, thing) {
            if (Array.isArray(expected)) {
              var len = expected.length
              expected = expected.map(function (i) {
                return String(i)
              })

              if (len > 2) {
                return (
                  'one of '
                    .concat(thing, ' ')
                    .concat(expected.slice(0, len - 1).join(', '), ', or ') +
                  expected[len - 1]
                )
              } else if (len === 2) {
                return 'one of '
                  .concat(thing, ' ')
                  .concat(expected[0], ' or ')
                  .concat(expected[1])
              } else {
                return 'of '.concat(thing, ' ').concat(expected[0])
              }
            } else {
              return 'of '.concat(thing, ' ').concat(String(expected))
            }
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

          function startsWith(str, search, pos) {
            return (
              str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search
            )
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

          function endsWith(str, search, this_len) {
            if (this_len === undefined || this_len > str.length) {
              this_len = str.length
            }

            return str.substring(this_len - search.length, this_len) === search
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

          function includes(str, search, start) {
            if (typeof start !== 'number') {
              start = 0
            }

            if (start + search.length > str.length) {
              return false
            } else {
              return str.indexOf(search, start) !== -1
            }
          }

          createErrorType(
            'ERR_AMBIGUOUS_ARGUMENT',
            'The "%s" argument is ambiguous. %s',
            TypeError
          )
          createErrorType(
            'ERR_INVALID_ARG_TYPE',
            function (name, expected, actual) {
              if (assert === undefined)
                assert = __nested_webpack_require_62541__(
                  /*! ../assert */ './node_modules/assert/build/assert.js'
                )
              assert(typeof name === 'string', "'name' must be a string") // determiner: 'must be' or 'must not be'

              var determiner

              if (
                typeof expected === 'string' &&
                startsWith(expected, 'not ')
              ) {
                determiner = 'must not be'
                expected = expected.replace(/^not /, '')
              } else {
                determiner = 'must be'
              }

              var msg

              if (endsWith(name, ' argument')) {
                // For cases like 'first argument'
                msg = 'The '
                  .concat(name, ' ')
                  .concat(determiner, ' ')
                  .concat(oneOf(expected, 'type'))
              } else {
                var type = includes(name, '.') ? 'property' : 'argument'
                msg = 'The "'
                  .concat(name, '" ')
                  .concat(type, ' ')
                  .concat(determiner, ' ')
                  .concat(oneOf(expected, 'type'))
              } // TODO(BridgeAR): Improve the output by showing `null` and similar.

              msg += '. Received type '.concat(_typeof(actual))
              return msg
            },
            TypeError
          )
          createErrorType(
            'ERR_INVALID_ARG_VALUE',
            function (name, value) {
              var reason =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : 'is invalid'
              if (util === undefined)
                util = __nested_webpack_require_62541__(
                  /*! util/ */ './node_modules/util/util.js'
                )
              var inspected = util.inspect(value)

              if (inspected.length > 128) {
                inspected = ''.concat(inspected.slice(0, 128), '...')
              }

              return "The argument '"
                .concat(name, "' ")
                .concat(reason, '. Received ')
                .concat(inspected)
            },
            TypeError,
            RangeError
          )
          createErrorType(
            'ERR_INVALID_RETURN_VALUE',
            function (input, name, value) {
              var type

              if (value && value.constructor && value.constructor.name) {
                type = 'instance of '.concat(value.constructor.name)
              } else {
                type = 'type '.concat(_typeof(value))
              }

              return (
                'Expected '
                  .concat(input, ' to be returned from the "')
                  .concat(name, '"') + ' function but got '.concat(type, '.')
              )
            },
            TypeError
          )
          createErrorType(
            'ERR_MISSING_ARGS',
            function () {
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key]
              }

              if (assert === undefined)
                assert = __nested_webpack_require_62541__(
                  /*! ../assert */ './node_modules/assert/build/assert.js'
                )
              assert(args.length > 0, 'At least one arg needs to be specified')
              var msg = 'The '
              var len = args.length
              args = args.map(function (a) {
                return '"'.concat(a, '"')
              })

              switch (len) {
                case 1:
                  msg += ''.concat(args[0], ' argument')
                  break

                case 2:
                  msg += ''
                    .concat(args[0], ' and ')
                    .concat(args[1], ' arguments')
                  break

                default:
                  msg += args.slice(0, len - 1).join(', ')
                  msg += ', and '.concat(args[len - 1], ' arguments')
                  break
              }

              return ''.concat(msg, ' must be specified')
            },
            TypeError
          )
          module.exports.codes = codes

          /***/
        },

      /***/ './node_modules/assert/build/internal/util/comparisons.js':
        /*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_74092__) => {
          'use strict'
          // Currently in sync with Node.js lib/internal/util/comparisons.js
          // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

          function _slicedToArray(arr, i) {
            return (
              _arrayWithHoles(arr) ||
              _iterableToArrayLimit(arr, i) ||
              _nonIterableRest()
            )
          }

          function _nonIterableRest() {
            throw new TypeError(
              'Invalid attempt to destructure non-iterable instance'
            )
          }

          function _iterableToArrayLimit(arr, i) {
            var _arr = []
            var _n = true
            var _d = false
            var _e = undefined
            try {
              for (
                var _i = arr[Symbol.iterator](), _s;
                !(_n = (_s = _i.next()).done);
                _n = true
              ) {
                _arr.push(_s.value)
                if (i && _arr.length === i) break
              }
            } catch (err) {
              _d = true
              _e = err
            } finally {
              try {
                if (!_n && _i['return'] != null) _i['return']()
              } finally {
                if (_d) throw _e
              }
            }
            return _arr
          }

          function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr
          }

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          var regexFlagsSupported = /a/g.flags !== undefined

          var arrayFromSet = function arrayFromSet(set) {
            var array = []
            set.forEach(function (value) {
              return array.push(value)
            })
            return array
          }

          var arrayFromMap = function arrayFromMap(map) {
            var array = []
            map.forEach(function (value, key) {
              return array.push([key, value])
            })
            return array
          }

          var objectIs = Object.is
            ? Object.is
            : __nested_webpack_require_74092__(
                /*! object-is */ './node_modules/object-is/index.js'
              )
          var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols
            ? Object.getOwnPropertySymbols
            : function () {
                return []
              }
          var numberIsNaN = Number.isNaN
            ? Number.isNaN
            : __nested_webpack_require_74092__(
                /*! is-nan */ './node_modules/is-nan/index.js'
              )

          function uncurryThis(f) {
            return f.call.bind(f)
          }

          var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty)
          var propertyIsEnumerable = uncurryThis(
            Object.prototype.propertyIsEnumerable
          )
          var objectToString = uncurryThis(Object.prototype.toString)

          var _require$types = __nested_webpack_require_74092__(
              /*! util/ */ './node_modules/util/util.js'
            ).types,
            isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
            isArrayBufferView = _require$types.isArrayBufferView,
            isDate = _require$types.isDate,
            isMap = _require$types.isMap,
            isRegExp = _require$types.isRegExp,
            isSet = _require$types.isSet,
            isNativeError = _require$types.isNativeError,
            isBoxedPrimitive = _require$types.isBoxedPrimitive,
            isNumberObject = _require$types.isNumberObject,
            isStringObject = _require$types.isStringObject,
            isBooleanObject = _require$types.isBooleanObject,
            isBigIntObject = _require$types.isBigIntObject,
            isSymbolObject = _require$types.isSymbolObject,
            isFloat32Array = _require$types.isFloat32Array,
            isFloat64Array = _require$types.isFloat64Array

          function isNonIndex(key) {
            if (key.length === 0 || key.length > 10) return true

            for (var i = 0; i < key.length; i++) {
              var code = key.charCodeAt(i)
              if (code < 48 || code > 57) return true
            } // The maximum size for an array is 2 ** 32 -1.

            return key.length === 10 && key >= Math.pow(2, 32)
          }

          function getOwnNonIndexProperties(value) {
            return Object.keys(value)
              .filter(isNonIndex)
              .concat(
                objectGetOwnPropertySymbols(value).filter(
                  Object.prototype.propertyIsEnumerable.bind(value)
                )
              )
          } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
          // original notice:

          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */

          function compare(a, b) {
            if (a === b) {
              return 0
            }

            var x = a.length
            var y = b.length

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i]
                y = b[i]
                break
              }
            }

            if (x < y) {
              return -1
            }

            if (y < x) {
              return 1
            }

            return 0
          }

          var ONLY_ENUMERABLE = undefined
          var kStrict = true
          var kLoose = false
          var kNoIterator = 0
          var kIsArray = 1
          var kIsSet = 2
          var kIsMap = 3 // Check if they have the same source and flags

          function areSimilarRegExps(a, b) {
            return regexFlagsSupported
              ? a.source === b.source && a.flags === b.flags
              : RegExp.prototype.toString.call(a) ===
                  RegExp.prototype.toString.call(b)
          }

          function areSimilarFloatArrays(a, b) {
            if (a.byteLength !== b.byteLength) {
              return false
            }

            for (var offset = 0; offset < a.byteLength; offset++) {
              if (a[offset] !== b[offset]) {
                return false
              }
            }

            return true
          }

          function areSimilarTypedArrays(a, b) {
            if (a.byteLength !== b.byteLength) {
              return false
            }

            return (
              compare(
                new Uint8Array(a.buffer, a.byteOffset, a.byteLength),
                new Uint8Array(b.buffer, b.byteOffset, b.byteLength)
              ) === 0
            )
          }

          function areEqualArrayBuffers(buf1, buf2) {
            return (
              buf1.byteLength === buf2.byteLength &&
              compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0
            )
          }

          function isEqualBoxedPrimitive(val1, val2) {
            if (isNumberObject(val1)) {
              return (
                isNumberObject(val2) &&
                objectIs(
                  Number.prototype.valueOf.call(val1),
                  Number.prototype.valueOf.call(val2)
                )
              )
            }

            if (isStringObject(val1)) {
              return (
                isStringObject(val2) &&
                String.prototype.valueOf.call(val1) ===
                  String.prototype.valueOf.call(val2)
              )
            }

            if (isBooleanObject(val1)) {
              return (
                isBooleanObject(val2) &&
                Boolean.prototype.valueOf.call(val1) ===
                  Boolean.prototype.valueOf.call(val2)
              )
            }

            if (isBigIntObject(val1)) {
              return (
                isBigIntObject(val2) &&
                BigInt.prototype.valueOf.call(val1) ===
                  BigInt.prototype.valueOf.call(val2)
              )
            }

            return (
              isSymbolObject(val2) &&
              Symbol.prototype.valueOf.call(val1) ===
                Symbol.prototype.valueOf.call(val2)
            )
          } // Notes: Type tags are historical [[Class]] properties that can be set by
          // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
          // and retrieved using Object.prototype.toString.call(obj) in JS
          // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
          // for a list of tags pre-defined in the spec.
          // There are some unspecified tags in the wild too (e.g. typed array tags).
          // Since tags can be altered, they only serve fast failures
          //
          // Typed arrays and buffers are checked by comparing the content in their
          // underlying ArrayBuffer. This optimization requires that it's
          // reasonable to interpret their underlying memory in the same way,
          // which is checked by comparing their type tags.
          // (e.g. a Uint8Array and a Uint16Array with the same memory content
          // could still be different because they will be interpreted differently).
          //
          // For strict comparison, objects should have
          // a) The same built-in type tags
          // b) The same prototypes.

          function innerDeepEqual(val1, val2, strict, memos) {
            // All identical values are equivalent, as determined by ===.
            if (val1 === val2) {
              if (val1 !== 0) return true
              return strict ? objectIs(val1, val2) : true
            } // Check more closely if val1 and val2 are equal.

            if (strict) {
              if (_typeof(val1) !== 'object') {
                return (
                  typeof val1 === 'number' &&
                  numberIsNaN(val1) &&
                  numberIsNaN(val2)
                )
              }

              if (
                _typeof(val2) !== 'object' ||
                val1 === null ||
                val2 === null
              ) {
                return false
              }

              if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                return false
              }
            } else {
              if (val1 === null || _typeof(val1) !== 'object') {
                if (val2 === null || _typeof(val2) !== 'object') {
                  // eslint-disable-next-line eqeqeq
                  return val1 == val2
                }

                return false
              }

              if (val2 === null || _typeof(val2) !== 'object') {
                return false
              }
            }

            var val1Tag = objectToString(val1)
            var val2Tag = objectToString(val2)

            if (val1Tag !== val2Tag) {
              return false
            }

            if (Array.isArray(val1)) {
              // Check for sparse arrays and general fast path
              if (val1.length !== val2.length) {
                return false
              }

              var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE)
              var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE)

              if (keys1.length !== keys2.length) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kIsArray, keys1)
            } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
            // wan't to early return out of the rest of the checks. However we can check
            // if the second value is one of these values and the first isn't.

            if (val1Tag === '[object Object]') {
              // return keyCheck(val1, val2, strict, memos, kNoIterator);
              if (
                (!isMap(val1) && isMap(val2)) ||
                (!isSet(val1) && isSet(val2))
              ) {
                return false
              }
            }

            if (isDate(val1)) {
              if (
                !isDate(val2) ||
                Date.prototype.getTime.call(val1) !==
                  Date.prototype.getTime.call(val2)
              ) {
                return false
              }
            } else if (isRegExp(val1)) {
              if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                return false
              }
            } else if (isNativeError(val1) || val1 instanceof Error) {
              // Do not compare the stack as it might differ even though the error itself
              // is otherwise identical.
              if (val1.message !== val2.message || val1.name !== val2.name) {
                return false
              }
            } else if (isArrayBufferView(val1)) {
              if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                if (!areSimilarFloatArrays(val1, val2)) {
                  return false
                }
              } else if (!areSimilarTypedArrays(val1, val2)) {
                return false
              } // Buffer.compare returns true, so val1.length === val2.length. If they both
              // only contain numeric keys, we don't need to exam further than checking
              // the symbols.

              var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE)

              var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE)

              if (_keys.length !== _keys2.length) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kNoIterator, _keys)
            } else if (isSet(val1)) {
              if (!isSet(val2) || val1.size !== val2.size) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kIsSet)
            } else if (isMap(val1)) {
              if (!isMap(val2) || val1.size !== val2.size) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kIsMap)
            } else if (isAnyArrayBuffer(val1)) {
              if (!areEqualArrayBuffers(val1, val2)) {
                return false
              }
            } else if (
              isBoxedPrimitive(val1) &&
              !isEqualBoxedPrimitive(val1, val2)
            ) {
              return false
            }

            return keyCheck(val1, val2, strict, memos, kNoIterator)
          }

          function getEnumerables(val, keys) {
            return keys.filter(function (k) {
              return propertyIsEnumerable(val, k)
            })
          }

          function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
            // For all remaining Object pairs, including Array, objects and Maps,
            // equivalence is determined by having:
            // a) The same number of owned enumerable properties
            // b) The same set of keys/indexes (although not necessarily the same order)
            // c) Equivalent values for every corresponding key/index
            // d) For Sets and Maps, equal contents
            // Note: this accounts for both named and indexed properties on Arrays.
            if (arguments.length === 5) {
              aKeys = Object.keys(val1)
              var bKeys = Object.keys(val2) // The pair must have the same number of owned properties.

              if (aKeys.length !== bKeys.length) {
                return false
              }
            } // Cheap key test

            var i = 0

            for (; i < aKeys.length; i++) {
              if (!hasOwnProperty(val2, aKeys[i])) {
                return false
              }
            }

            if (strict && arguments.length === 5) {
              var symbolKeysA = objectGetOwnPropertySymbols(val1)

              if (symbolKeysA.length !== 0) {
                var count = 0

                for (i = 0; i < symbolKeysA.length; i++) {
                  var key = symbolKeysA[i]

                  if (propertyIsEnumerable(val1, key)) {
                    if (!propertyIsEnumerable(val2, key)) {
                      return false
                    }

                    aKeys.push(key)
                    count++
                  } else if (propertyIsEnumerable(val2, key)) {
                    return false
                  }
                }

                var symbolKeysB = objectGetOwnPropertySymbols(val2)

                if (
                  symbolKeysA.length !== symbolKeysB.length &&
                  getEnumerables(val2, symbolKeysB).length !== count
                ) {
                  return false
                }
              } else {
                var _symbolKeysB = objectGetOwnPropertySymbols(val2)

                if (
                  _symbolKeysB.length !== 0 &&
                  getEnumerables(val2, _symbolKeysB).length !== 0
                ) {
                  return false
                }
              }
            }

            if (
              aKeys.length === 0 &&
              (iterationType === kNoIterator ||
                (iterationType === kIsArray && val1.length === 0) ||
                val1.size === 0)
            ) {
              return true
            } // Use memos to handle cycles.

            if (memos === undefined) {
              memos = {
                val1: new Map(),
                val2: new Map(),
                position: 0,
              }
            } else {
              // We prevent up to two map.has(x) calls by directly retrieving the value
              // and checking for undefined. The map can only contain numbers, so it is
              // safe to check for undefined only.
              var val2MemoA = memos.val1.get(val1)

              if (val2MemoA !== undefined) {
                var val2MemoB = memos.val2.get(val2)

                if (val2MemoB !== undefined) {
                  return val2MemoA === val2MemoB
                }
              }

              memos.position++
            }

            memos.val1.set(val1, memos.position)
            memos.val2.set(val2, memos.position)
            var areEq = objEquiv(
              val1,
              val2,
              strict,
              aKeys,
              memos,
              iterationType
            )
            memos.val1.delete(val1)
            memos.val2.delete(val2)
            return areEq
          }

          function setHasEqualElement(set, val1, strict, memo) {
            // Go looking.
            var setValues = arrayFromSet(set)

            for (var i = 0; i < setValues.length; i++) {
              var val2 = setValues[i]

              if (innerDeepEqual(val1, val2, strict, memo)) {
                // Remove the matching element to make sure we do not check that again.
                set.delete(val2)
                return true
              }
            }

            return false
          } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
          // Sadly it is not possible to detect corresponding values properly in case the
          // type is a string, number, bigint or boolean. The reason is that those values
          // can match lots of different string values (e.g., 1n == '+00001').

          function findLooseMatchingPrimitives(prim) {
            switch (_typeof(prim)) {
              case 'undefined':
                return null

              case 'object':
                // Only pass in null as object!
                return undefined

              case 'symbol':
                return false

              case 'string':
                prim = +prim
              // Loose equal entries exist only if the string is possible to convert to
              // a regular number and not NaN.
              // Fall through

              case 'number':
                if (numberIsNaN(prim)) {
                  return false
                }
            }

            return true
          }

          function setMightHaveLoosePrim(a, b, prim) {
            var altValue = findLooseMatchingPrimitives(prim)
            if (altValue != null) return altValue
            return b.has(altValue) && !a.has(altValue)
          }

          function mapMightHaveLoosePrim(a, b, prim, item, memo) {
            var altValue = findLooseMatchingPrimitives(prim)

            if (altValue != null) {
              return altValue
            }

            var curB = b.get(altValue)

            if (
              (curB === undefined && !b.has(altValue)) ||
              !innerDeepEqual(item, curB, false, memo)
            ) {
              return false
            }

            return !a.has(altValue) && innerDeepEqual(item, curB, false, memo)
          }

          function setEquiv(a, b, strict, memo) {
            // This is a lazily initiated Set of entries which have to be compared
            // pairwise.
            var set = null
            var aValues = arrayFromSet(a)

            for (var i = 0; i < aValues.length; i++) {
              var val = aValues[i] // Note: Checking for the objects first improves the performance for object
              // heavy sets but it is a minor slow down for primitives. As they are fast
              // to check this improves the worst case scenario instead.

              if (_typeof(val) === 'object' && val !== null) {
                if (set === null) {
                  set = new Set()
                } // If the specified value doesn't exist in the second set its an not null
                // object (or non strict only: a not matching primitive) we'll need to go
                // hunting for something thats deep-(strict-)equal to it. To make this
                // O(n log n) complexity we have to copy these values in a new set first.

                set.add(val)
              } else if (!b.has(val)) {
                if (strict) return false // Fast path to detect missing string, symbol, undefined and null values.

                if (!setMightHaveLoosePrim(a, b, val)) {
                  return false
                }

                if (set === null) {
                  set = new Set()
                }

                set.add(val)
              }
            }

            if (set !== null) {
              var bValues = arrayFromSet(b)

              for (var _i = 0; _i < bValues.length; _i++) {
                var _val = bValues[_i] // We have to check if a primitive value is already
                // matching and only if it's not, go hunting for it.

                if (_typeof(_val) === 'object' && _val !== null) {
                  if (!setHasEqualElement(set, _val, strict, memo)) return false
                } else if (
                  !strict &&
                  !a.has(_val) &&
                  !setHasEqualElement(set, _val, strict, memo)
                ) {
                  return false
                }
              }

              return set.size === 0
            }

            return true
          }

          function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
            // To be able to handle cases like:
            //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
            // ... we need to consider *all* matching keys, not just the first we find.
            var setValues = arrayFromSet(set)

            for (var i = 0; i < setValues.length; i++) {
              var key2 = setValues[i]

              if (
                innerDeepEqual(key1, key2, strict, memo) &&
                innerDeepEqual(item1, map.get(key2), strict, memo)
              ) {
                set.delete(key2)
                return true
              }
            }

            return false
          }

          function mapEquiv(a, b, strict, memo) {
            var set = null
            var aEntries = arrayFromMap(a)

            for (var i = 0; i < aEntries.length; i++) {
              var _aEntries$i = _slicedToArray(aEntries[i], 2),
                key = _aEntries$i[0],
                item1 = _aEntries$i[1]

              if (_typeof(key) === 'object' && key !== null) {
                if (set === null) {
                  set = new Set()
                }

                set.add(key)
              } else {
                // By directly retrieving the value we prevent another b.has(key) check in
                // almost all possible cases.
                var item2 = b.get(key)

                if (
                  (item2 === undefined && !b.has(key)) ||
                  !innerDeepEqual(item1, item2, strict, memo)
                ) {
                  if (strict) return false // Fast path to detect missing string, symbol, undefined and null
                  // keys.

                  if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
                    return false

                  if (set === null) {
                    set = new Set()
                  }

                  set.add(key)
                }
              }
            }

            if (set !== null) {
              var bEntries = arrayFromMap(b)

              for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
                var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
                  key = _bEntries$_i[0],
                  item = _bEntries$_i[1]

                if (_typeof(key) === 'object' && key !== null) {
                  if (!mapHasEqualEntry(set, a, key, item, strict, memo))
                    return false
                } else if (
                  !strict &&
                  (!a.has(key) ||
                    !innerDeepEqual(a.get(key), item, false, memo)) &&
                  !mapHasEqualEntry(set, a, key, item, false, memo)
                ) {
                  return false
                }
              }

              return set.size === 0
            }

            return true
          }

          function objEquiv(a, b, strict, keys, memos, iterationType) {
            // Sets and maps don't have their entries accessible via normal object
            // properties.
            var i = 0

            if (iterationType === kIsSet) {
              if (!setEquiv(a, b, strict, memos)) {
                return false
              }
            } else if (iterationType === kIsMap) {
              if (!mapEquiv(a, b, strict, memos)) {
                return false
              }
            } else if (iterationType === kIsArray) {
              for (; i < a.length; i++) {
                if (hasOwnProperty(a, i)) {
                  if (
                    !hasOwnProperty(b, i) ||
                    !innerDeepEqual(a[i], b[i], strict, memos)
                  ) {
                    return false
                  }
                } else if (hasOwnProperty(b, i)) {
                  return false
                } else {
                  // Array is sparse.
                  var keysA = Object.keys(a)

                  for (; i < keysA.length; i++) {
                    var key = keysA[i]

                    if (
                      !hasOwnProperty(b, key) ||
                      !innerDeepEqual(a[key], b[key], strict, memos)
                    ) {
                      return false
                    }
                  }

                  if (keysA.length !== Object.keys(b).length) {
                    return false
                  }

                  return true
                }
              }
            } // The pair must have equivalent values for every corresponding key.
            // Possibly expensive deep test:

            for (i = 0; i < keys.length; i++) {
              var _key = keys[i]

              if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                return false
              }
            }

            return true
          }

          function isDeepEqual(val1, val2) {
            return innerDeepEqual(val1, val2, kLoose)
          }

          function isDeepStrictEqual(val1, val2) {
            return innerDeepEqual(val1, val2, kStrict)
          }

          module.exports = {
            isDeepEqual: isDeepEqual,
            isDeepStrictEqual: isDeepStrictEqual,
          }

          /***/
        },

      /***/ './node_modules/available-typed-arrays/index.js':
        /*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_103145__) => {
          'use strict'

          var filter = __nested_webpack_require_103145__(
            /*! array-filter */ './node_modules/array-filter/index.js'
          )

          module.exports = function availableTypedArrays() {
            return filter(
              [
                'BigInt64Array',
                'BigUint64Array',
                'Float32Array',
                'Float64Array',
                'Int16Array',
                'Int32Array',
                'Int8Array',
                'Uint16Array',
                'Uint32Array',
                'Uint8Array',
                'Uint8ClampedArray',
              ],
              function (typedArray) {
                return typeof __nested_webpack_require_103145__.g[typedArray] === 'function'
              }
            )
          }

          /***/
        },

      /***/ './node_modules/axios/index.js':
        /*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_104211__) => {
          module.exports = __nested_webpack_require_104211__(
            /*! ./lib/axios */ './node_modules/axios/lib/axios.js'
          )

          /***/
        },

      /***/ './node_modules/axios/lib/adapters/xhr.js':
        /*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_104667__) => {
          'use strict'

          var utils = __nested_webpack_require_104667__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )
          var settle = __nested_webpack_require_104667__(
            /*! ./../core/settle */ './node_modules/axios/lib/core/settle.js'
          )
          var cookies = __nested_webpack_require_104667__(
            /*! ./../helpers/cookies */ './node_modules/axios/lib/helpers/cookies.js'
          )
          var buildURL = __nested_webpack_require_104667__(
            /*! ./../helpers/buildURL */ './node_modules/axios/lib/helpers/buildURL.js'
          )
          var buildFullPath = __nested_webpack_require_104667__(
            /*! ../core/buildFullPath */ './node_modules/axios/lib/core/buildFullPath.js'
          )
          var parseHeaders = __nested_webpack_require_104667__(
            /*! ./../helpers/parseHeaders */ './node_modules/axios/lib/helpers/parseHeaders.js'
          )
          var isURLSameOrigin = __nested_webpack_require_104667__(
            /*! ./../helpers/isURLSameOrigin */ './node_modules/axios/lib/helpers/isURLSameOrigin.js'
          )
          var createError = __nested_webpack_require_104667__(
            /*! ../core/createError */ './node_modules/axios/lib/core/createError.js'
          )

          module.exports = function xhrAdapter(config) {
            return new Promise(function dispatchXhrRequest(resolve, reject) {
              var requestData = config.data
              var requestHeaders = config.headers

              if (utils.isFormData(requestData)) {
                delete requestHeaders['Content-Type'] // Let the browser set it
              }

              var request = new XMLHttpRequest()

              // HTTP basic authentication
              if (config.auth) {
                var username = config.auth.username || ''
                var password = config.auth.password
                  ? unescape(encodeURIComponent(config.auth.password))
                  : ''
                requestHeaders.Authorization =
                  'Basic ' + btoa(username + ':' + password)
              }

              var fullPath = buildFullPath(config.baseURL, config.url)
              request.open(
                config.method.toUpperCase(),
                buildURL(fullPath, config.params, config.paramsSerializer),
                true
              )

              // Set the request timeout in MS
              request.timeout = config.timeout

              // Listen for ready state
              request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                  return
                }

                // The request errored out and we didn't get a response, this will be
                // handled by onerror instead
                // With one exception: request that using file: protocol, most browsers
                // will return status as 0 even though it's a successful request
                if (
                  request.status === 0 &&
                  !(
                    request.responseURL &&
                    request.responseURL.indexOf('file:') === 0
                  )
                ) {
                  return
                }

                // Prepare the response
                var responseHeaders =
                  'getAllResponseHeaders' in request
                    ? parseHeaders(request.getAllResponseHeaders())
                    : null
                var responseData =
                  !config.responseType || config.responseType === 'text'
                    ? request.responseText
                    : request.response
                var response = {
                  data: responseData,
                  status: request.status,
                  statusText: request.statusText,
                  headers: responseHeaders,
                  config: config,
                  request: request,
                }

                settle(resolve, reject, response)

                // Clean up request
                request = null
              }

              // Handle browser request cancellation (as opposed to a manual cancellation)
              request.onabort = function handleAbort() {
                if (!request) {
                  return
                }

                reject(
                  createError(
                    'Request aborted',
                    config,
                    'ECONNABORTED',
                    request
                  )
                )

                // Clean up request
                request = null
              }

              // Handle low level network errors
              request.onerror = function handleError() {
                // Real errors are hidden from us by the browser
                // onerror should only fire if it's a network error
                reject(createError('Network Error', config, null, request))

                // Clean up request
                request = null
              }

              // Handle timeout
              request.ontimeout = function handleTimeout() {
                var timeoutErrorMessage =
                  'timeout of ' + config.timeout + 'ms exceeded'
                if (config.timeoutErrorMessage) {
                  timeoutErrorMessage = config.timeoutErrorMessage
                }
                reject(
                  createError(
                    timeoutErrorMessage,
                    config,
                    'ECONNABORTED',
                    request
                  )
                )

                // Clean up request
                request = null
              }

              // Add xsrf header
              // This is only done if running in a standard browser environment.
              // Specifically not if we're in a web worker, or react-native.
              if (utils.isStandardBrowserEnv()) {
                // Add xsrf header
                var xsrfValue =
                  (config.withCredentials || isURLSameOrigin(fullPath)) &&
                  config.xsrfCookieName
                    ? cookies.read(config.xsrfCookieName)
                    : undefined

                if (xsrfValue) {
                  requestHeaders[config.xsrfHeaderName] = xsrfValue
                }
              }

              // Add headers to the request
              if ('setRequestHeader' in request) {
                utils.forEach(
                  requestHeaders,
                  function setRequestHeader(val, key) {
                    if (
                      typeof requestData === 'undefined' &&
                      key.toLowerCase() === 'content-type'
                    ) {
                      // Remove Content-Type if data is undefined
                      delete requestHeaders[key]
                    } else {
                      // Otherwise add header to the request
                      request.setRequestHeader(key, val)
                    }
                  }
                )
              }

              // Add withCredentials to request if needed
              if (!utils.isUndefined(config.withCredentials)) {
                request.withCredentials = !!config.withCredentials
              }

              // Add responseType to request if needed
              if (config.responseType) {
                try {
                  request.responseType = config.responseType
                } catch (e) {
                  // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
                  // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
                  if (config.responseType !== 'json') {
                    throw e
                  }
                }
              }

              // Handle progress if needed
              if (typeof config.onDownloadProgress === 'function') {
                request.addEventListener('progress', config.onDownloadProgress)
              }

              // Not all browsers support upload events
              if (
                typeof config.onUploadProgress === 'function' &&
                request.upload
              ) {
                request.upload.addEventListener(
                  'progress',
                  config.onUploadProgress
                )
              }

              if (config.cancelToken) {
                // Handle cancellation
                config.cancelToken.promise.then(function onCanceled(cancel) {
                  if (!request) {
                    return
                  }

                  request.abort()
                  reject(cancel)
                  // Clean up request
                  request = null
                })
              }

              if (!requestData) {
                requestData = null
              }

              // Send the request
              request.send(requestData)
            })
          }

          /***/
        },

      /***/ './node_modules/axios/lib/axios.js':
        /*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_113868__) => {
          'use strict'

          var utils = __nested_webpack_require_113868__(
            /*! ./utils */ './node_modules/axios/lib/utils.js'
          )
          var bind = __nested_webpack_require_113868__(
            /*! ./helpers/bind */ './node_modules/axios/lib/helpers/bind.js'
          )
          var Axios = __nested_webpack_require_113868__(
            /*! ./core/Axios */ './node_modules/axios/lib/core/Axios.js'
          )
          var mergeConfig = __nested_webpack_require_113868__(
            /*! ./core/mergeConfig */ './node_modules/axios/lib/core/mergeConfig.js'
          )
          var defaults = __nested_webpack_require_113868__(
            /*! ./defaults */ './node_modules/axios/lib/defaults.js'
          )

          /**
           * Create an instance of Axios
           *
           * @param {Object} defaultConfig The default config for the instance
           * @return {Axios} A new instance of Axios
           */
          function createInstance(defaultConfig) {
            var context = new Axios(defaultConfig)
            var instance = bind(Axios.prototype.request, context)

            // Copy axios.prototype to instance
            utils.extend(instance, Axios.prototype, context)

            // Copy context to instance
            utils.extend(instance, context)

            return instance
          }

          // Create the default instance to be exported
          var axios = createInstance(defaults)

          // Expose Axios class to allow class inheritance
          axios.Axios = Axios

          // Factory for creating new instances
          axios.create = function create(instanceConfig) {
            return createInstance(mergeConfig(axios.defaults, instanceConfig))
          }

          // Expose Cancel & CancelToken
          axios.Cancel = __nested_webpack_require_113868__(
            /*! ./cancel/Cancel */ './node_modules/axios/lib/cancel/Cancel.js'
          )
          axios.CancelToken = __nested_webpack_require_113868__(
            /*! ./cancel/CancelToken */ './node_modules/axios/lib/cancel/CancelToken.js'
          )
          axios.isCancel = __nested_webpack_require_113868__(
            /*! ./cancel/isCancel */ './node_modules/axios/lib/cancel/isCancel.js'
          )

          // Expose all/spread
          axios.all = function all(promises) {
            return Promise.all(promises)
          }
          axios.spread = __nested_webpack_require_113868__(
            /*! ./helpers/spread */ './node_modules/axios/lib/helpers/spread.js'
          )

          // Expose isAxiosError
          axios.isAxiosError = __nested_webpack_require_113868__(
            /*! ./helpers/isAxiosError */ './node_modules/axios/lib/helpers/isAxiosError.js'
          )

          module.exports = axios

          // Allow use of default import syntax in TypeScript
          module.exports.default = axios

          /***/
        },

      /***/ './node_modules/axios/lib/cancel/Cancel.js':
        /*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * A `Cancel` is an object that is thrown when an operation is canceled.
           *
           * @class
           * @param {string=} message The message.
           */
          function Cancel(message) {
            this.message = message
          }

          Cancel.prototype.toString = function toString() {
            return 'Cancel' + (this.message ? ': ' + this.message : '')
          }

          Cancel.prototype.__CANCEL__ = true

          module.exports = Cancel

          /***/
        },

      /***/ './node_modules/axios/lib/cancel/CancelToken.js':
        /*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_117796__) => {
          'use strict'

          var Cancel = __nested_webpack_require_117796__(
            /*! ./Cancel */ './node_modules/axios/lib/cancel/Cancel.js'
          )

          /**
           * A `CancelToken` is an object that can be used to request cancellation of an operation.
           *
           * @class
           * @param {Function} executor The executor function.
           */
          function CancelToken(executor) {
            if (typeof executor !== 'function') {
              throw new TypeError('executor must be a function.')
            }

            var resolvePromise
            this.promise = new Promise(function promiseExecutor(resolve) {
              resolvePromise = resolve
            })

            var token = this
            executor(function cancel(message) {
              if (token.reason) {
                // Cancellation has already been requested
                return
              }

              token.reason = new Cancel(message)
              resolvePromise(token.reason)
            })
          }

          /**
           * Throws a `Cancel` if cancellation has been requested.
           */
          CancelToken.prototype.throwIfRequested = function throwIfRequested() {
            if (this.reason) {
              throw this.reason
            }
          }

          /**
           * Returns an object that contains a new `CancelToken` and a function that, when called,
           * cancels the `CancelToken`.
           */
          CancelToken.source = function source() {
            var cancel
            var token = new CancelToken(function executor(c) {
              cancel = c
            })
            return {
              token: token,
              cancel: cancel,
            }
          }

          module.exports = CancelToken

          /***/
        },

      /***/ './node_modules/axios/lib/cancel/isCancel.js':
        /*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
        /***/ (module) => {
          'use strict'

          module.exports = function isCancel(value) {
            return !!(value && value.__CANCEL__)
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/Axios.js':
        /*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_120347__) => {
          'use strict'

          var utils = __nested_webpack_require_120347__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )
          var buildURL = __nested_webpack_require_120347__(
            /*! ../helpers/buildURL */ './node_modules/axios/lib/helpers/buildURL.js'
          )
          var InterceptorManager = __nested_webpack_require_120347__(
            /*! ./InterceptorManager */ './node_modules/axios/lib/core/InterceptorManager.js'
          )
          var dispatchRequest = __nested_webpack_require_120347__(
            /*! ./dispatchRequest */ './node_modules/axios/lib/core/dispatchRequest.js'
          )
          var mergeConfig = __nested_webpack_require_120347__(
            /*! ./mergeConfig */ './node_modules/axios/lib/core/mergeConfig.js'
          )

          /**
           * Create a new instance of Axios
           *
           * @param {Object} instanceConfig The default config for the instance
           */
          function Axios(instanceConfig) {
            this.defaults = instanceConfig
            this.interceptors = {
              request: new InterceptorManager(),
              response: new InterceptorManager(),
            }
          }

          /**
           * Dispatch a request
           *
           * @param {Object} config The config specific for this request (merged with this.defaults)
           */
          Axios.prototype.request = function request(config) {
            /*eslint no-param-reassign:0*/
            // Allow for axios('example/url'[, config]) a la fetch API
            if (typeof config === 'string') {
              config = arguments[1] || {}
              config.url = arguments[0]
            } else {
              config = config || {}
            }

            config = mergeConfig(this.defaults, config)

            // Set config.method
            if (config.method) {
              config.method = config.method.toLowerCase()
            } else if (this.defaults.method) {
              config.method = this.defaults.method.toLowerCase()
            } else {
              config.method = 'get'
            }

            // Hook up interceptors middleware
            var chain = [dispatchRequest, undefined]
            var promise = Promise.resolve(config)

            this.interceptors.request.forEach(
              function unshiftRequestInterceptors(interceptor) {
                chain.unshift(interceptor.fulfilled, interceptor.rejected)
              }
            )

            this.interceptors.response.forEach(
              function pushResponseInterceptors(interceptor) {
                chain.push(interceptor.fulfilled, interceptor.rejected)
              }
            )

            while (chain.length) {
              promise = promise.then(chain.shift(), chain.shift())
            }

            return promise
          }

          Axios.prototype.getUri = function getUri(config) {
            config = mergeConfig(this.defaults, config)
            return buildURL(
              config.url,
              config.params,
              config.paramsSerializer
            ).replace(/^\?/, '')
          }

          // Provide aliases for supported request methods
          utils.forEach(
            ['delete', 'get', 'head', 'options'],
            function forEachMethodNoData(method) {
              /*eslint func-names:0*/
              Axios.prototype[method] = function (url, config) {
                return this.request(
                  mergeConfig(config || {}, {
                    method: method,
                    url: url,
                    data: (config || {}).data,
                  })
                )
              }
            }
          )

          utils.forEach(
            ['post', 'put', 'patch'],
            function forEachMethodWithData(method) {
              /*eslint func-names:0*/
              Axios.prototype[method] = function (url, data, config) {
                return this.request(
                  mergeConfig(config || {}, {
                    method: method,
                    url: url,
                    data: data,
                  })
                )
              }
            }
          )

          module.exports = Axios

          /***/
        },

      /***/ './node_modules/axios/lib/core/InterceptorManager.js':
        /*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_124905__) => {
          'use strict'

          var utils = __nested_webpack_require_124905__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          function InterceptorManager() {
            this.handlers = []
          }

          /**
           * Add a new interceptor to the stack
           *
           * @param {Function} fulfilled The function to handle `then` for a `Promise`
           * @param {Function} rejected The function to handle `reject` for a `Promise`
           *
           * @return {Number} An ID used to remove interceptor later
           */
          InterceptorManager.prototype.use = function use(fulfilled, rejected) {
            this.handlers.push({
              fulfilled: fulfilled,
              rejected: rejected,
            })
            return this.handlers.length - 1
          }

          /**
           * Remove an interceptor from the stack
           *
           * @param {Number} id The ID that was returned by `use`
           */
          InterceptorManager.prototype.eject = function eject(id) {
            if (this.handlers[id]) {
              this.handlers[id] = null
            }
          }

          /**
           * Iterate over all the registered interceptors
           *
           * This method is particularly useful for skipping over any
           * interceptors that may have become `null` calling `eject`.
           *
           * @param {Function} fn The function to call for each interceptor
           */
          InterceptorManager.prototype.forEach = function forEach(fn) {
            utils.forEach(this.handlers, function forEachHandler(h) {
              if (h !== null) {
                fn(h)
              }
            })
          }

          module.exports = InterceptorManager

          /***/
        },

      /***/ './node_modules/axios/lib/core/buildFullPath.js':
        /*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_127035__) => {
          'use strict'

          var isAbsoluteURL = __nested_webpack_require_127035__(
            /*! ../helpers/isAbsoluteURL */ './node_modules/axios/lib/helpers/isAbsoluteURL.js'
          )
          var combineURLs = __nested_webpack_require_127035__(
            /*! ../helpers/combineURLs */ './node_modules/axios/lib/helpers/combineURLs.js'
          )

          /**
           * Creates a new URL by combining the baseURL with the requestedURL,
           * only when the requestedURL is not already an absolute URL.
           * If the requestURL is absolute, this function returns the requestedURL untouched.
           *
           * @param {string} baseURL The base URL
           * @param {string} requestedURL Absolute or relative URL to combine
           * @returns {string} The combined full path
           */
          module.exports = function buildFullPath(baseURL, requestedURL) {
            if (baseURL && !isAbsoluteURL(requestedURL)) {
              return combineURLs(baseURL, requestedURL)
            }
            return requestedURL
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/createError.js':
        /*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_128433__) => {
          'use strict'

          var enhanceError = __nested_webpack_require_128433__(
            /*! ./enhanceError */ './node_modules/axios/lib/core/enhanceError.js'
          )

          /**
           * Create an Error with the specified message, config, error code, request and response.
           *
           * @param {string} message The error message.
           * @param {Object} config The config.
           * @param {string} [code] The error code (for example, 'ECONNABORTED').
           * @param {Object} [request] The request.
           * @param {Object} [response] The response.
           * @returns {Error} The created error.
           */
          module.exports = function createError(
            message,
            config,
            code,
            request,
            response
          ) {
            var error = new Error(message)
            return enhanceError(error, config, code, request, response)
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/dispatchRequest.js':
        /*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_129735__) => {
          'use strict'

          var utils = __nested_webpack_require_129735__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )
          var transformData = __nested_webpack_require_129735__(
            /*! ./transformData */ './node_modules/axios/lib/core/transformData.js'
          )
          var isCancel = __nested_webpack_require_129735__(
            /*! ../cancel/isCancel */ './node_modules/axios/lib/cancel/isCancel.js'
          )
          var defaults = __nested_webpack_require_129735__(
            /*! ../defaults */ './node_modules/axios/lib/defaults.js'
          )

          /**
           * Throws a `Cancel` if cancellation has been requested.
           */
          function throwIfCancellationRequested(config) {
            if (config.cancelToken) {
              config.cancelToken.throwIfRequested()
            }
          }

          /**
           * Dispatch a request to the server using the configured adapter.
           *
           * @param {object} config The config that is to be used for the request
           * @returns {Promise} The Promise to be fulfilled
           */
          module.exports = function dispatchRequest(config) {
            throwIfCancellationRequested(config)

            // Ensure headers exist
            config.headers = config.headers || {}

            // Transform request data
            config.data = transformData(
              config.data,
              config.headers,
              config.transformRequest
            )

            // Flatten headers
            config.headers = utils.merge(
              config.headers.common || {},
              config.headers[config.method] || {},
              config.headers
            )

            utils.forEach(
              ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
              function cleanHeaderConfig(method) {
                delete config.headers[method]
              }
            )

            var adapter = config.adapter || defaults.adapter

            return adapter(config).then(
              function onAdapterResolution(response) {
                throwIfCancellationRequested(config)

                // Transform response data
                response.data = transformData(
                  response.data,
                  response.headers,
                  config.transformResponse
                )

                return response
              },
              function onAdapterRejection(reason) {
                if (!isCancel(reason)) {
                  throwIfCancellationRequested(config)

                  // Transform response data
                  if (reason && reason.response) {
                    reason.response.data = transformData(
                      reason.response.data,
                      reason.response.headers,
                      config.transformResponse
                    )
                  }
                }

                return Promise.reject(reason)
              }
            )
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/enhanceError.js':
        /*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Update an Error with the specified config, error code, and response.
           *
           * @param {Error} error The error to update.
           * @param {Object} config The config.
           * @param {string} [code] The error code (for example, 'ECONNABORTED').
           * @param {Object} [request] The request.
           * @param {Object} [response] The response.
           * @returns {Error} The error.
           */
          module.exports = function enhanceError(
            error,
            config,
            code,
            request,
            response
          ) {
            error.config = config
            if (code) {
              error.code = code
            }

            error.request = request
            error.response = response
            error.isAxiosError = true

            error.toJSON = function toJSON() {
              return {
                // Standard
                message: this.message,
                name: this.name,
                // Microsoft
                description: this.description,
                number: this.number,
                // Mozilla
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                // Axios
                config: this.config,
                code: this.code,
              }
            }
            return error
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/mergeConfig.js':
        /*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_134877__) => {
          'use strict'

          var utils = __nested_webpack_require_134877__(
            /*! ../utils */ './node_modules/axios/lib/utils.js'
          )

          /**
           * Config-specific merge-function which creates a new config-object
           * by merging two configuration objects together.
           *
           * @param {Object} config1
           * @param {Object} config2
           * @returns {Object} New object resulting from merging config2 to config1
           */
          module.exports = function mergeConfig(config1, config2) {
            // eslint-disable-next-line no-param-reassign
            config2 = config2 || {}
            var config = {}

            var valueFromConfig2Keys = ['url', 'method', 'data']
            var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params']
            var defaultToConfig2Keys = [
              'baseURL',
              'transformRequest',
              'transformResponse',
              'paramsSerializer',
              'timeout',
              'timeoutMessage',
              'withCredentials',
              'adapter',
              'responseType',
              'xsrfCookieName',
              'xsrfHeaderName',
              'onUploadProgress',
              'onDownloadProgress',
              'decompress',
              'maxContentLength',
              'maxBodyLength',
              'maxRedirects',
              'transport',
              'httpAgent',
              'httpsAgent',
              'cancelToken',
              'socketPath',
              'responseEncoding',
            ]
            var directMergeKeys = ['validateStatus']

            function getMergedValue(target, source) {
              if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
                return utils.merge(target, source)
              } else if (utils.isPlainObject(source)) {
                return utils.merge({}, source)
              } else if (utils.isArray(source)) {
                return source.slice()
              }
              return source
            }

            function mergeDeepProperties(prop) {
              if (!utils.isUndefined(config2[prop])) {
                config[prop] = getMergedValue(config1[prop], config2[prop])
              } else if (!utils.isUndefined(config1[prop])) {
                config[prop] = getMergedValue(undefined, config1[prop])
              }
            }

            utils.forEach(
              valueFromConfig2Keys,
              function valueFromConfig2(prop) {
                if (!utils.isUndefined(config2[prop])) {
                  config[prop] = getMergedValue(undefined, config2[prop])
                }
              }
            )

            utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties)

            utils.forEach(
              defaultToConfig2Keys,
              function defaultToConfig2(prop) {
                if (!utils.isUndefined(config2[prop])) {
                  config[prop] = getMergedValue(undefined, config2[prop])
                } else if (!utils.isUndefined(config1[prop])) {
                  config[prop] = getMergedValue(undefined, config1[prop])
                }
              }
            )

            utils.forEach(directMergeKeys, function merge(prop) {
              if (prop in config2) {
                config[prop] = getMergedValue(config1[prop], config2[prop])
              } else if (prop in config1) {
                config[prop] = getMergedValue(undefined, config1[prop])
              }
            })

            var axiosKeys = valueFromConfig2Keys
              .concat(mergeDeepPropertiesKeys)
              .concat(defaultToConfig2Keys)
              .concat(directMergeKeys)

            var otherKeys = Object.keys(config1)
              .concat(Object.keys(config2))
              .filter(function filterAxiosKeys(key) {
                return axiosKeys.indexOf(key) === -1
              })

            utils.forEach(otherKeys, mergeDeepProperties)

            return config
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/settle.js':
        /*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_139227__) => {
          'use strict'

          var createError = __nested_webpack_require_139227__(
            /*! ./createError */ './node_modules/axios/lib/core/createError.js'
          )

          /**
           * Resolve or reject a Promise based on response status.
           *
           * @param {Function} resolve A function that resolves the promise.
           * @param {Function} reject A function that rejects the promise.
           * @param {object} response The response.
           */
          module.exports = function settle(resolve, reject, response) {
            var validateStatus = response.config.validateStatus
            if (
              !response.status ||
              !validateStatus ||
              validateStatus(response.status)
            ) {
              resolve(response)
            } else {
              reject(
                createError(
                  'Request failed with status code ' + response.status,
                  response.config,
                  null,
                  response.request,
                  response
                )
              )
            }
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/transformData.js':
        /*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_140698__) => {
          'use strict'

          var utils = __nested_webpack_require_140698__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          /**
           * Transform the data for a request or a response
           *
           * @param {Object|String} data The data to be transformed
           * @param {Array} headers The headers for the request or response
           * @param {Array|Function} fns A single function or Array of functions
           * @returns {*} The resulting transformed data
           */
          module.exports = function transformData(data, headers, fns) {
            /*eslint no-param-reassign:0*/
            utils.forEach(fns, function transform(fn) {
              data = fn(data, headers)
            })

            return data
          }

          /***/
        },

      /***/ './node_modules/axios/lib/defaults.js':
        /*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_141802__) => {
          'use strict'
          /* provided dependency */ var process = __nested_webpack_require_141802__(
            /*! process/browser */ './node_modules/process/browser.js'
          )

          var utils = __nested_webpack_require_141802__(
            /*! ./utils */ './node_modules/axios/lib/utils.js'
          )
          var normalizeHeaderName = __nested_webpack_require_141802__(
            /*! ./helpers/normalizeHeaderName */ './node_modules/axios/lib/helpers/normalizeHeaderName.js'
          )

          var DEFAULT_CONTENT_TYPE = {
            'Content-Type': 'application/x-www-form-urlencoded',
          }

          function setContentTypeIfUnset(headers, value) {
            if (
              !utils.isUndefined(headers) &&
              utils.isUndefined(headers['Content-Type'])
            ) {
              headers['Content-Type'] = value
            }
          }

          function getDefaultAdapter() {
            var adapter
            if (typeof XMLHttpRequest !== 'undefined') {
              // For browsers use XHR adapter
              adapter = __nested_webpack_require_141802__(
                /*! ./adapters/xhr */ './node_modules/axios/lib/adapters/xhr.js'
              )
            } else if (
              typeof process !== 'undefined' &&
              Object.prototype.toString.call(process) === '[object process]'
            ) {
              // For node use HTTP adapter
              adapter = __nested_webpack_require_141802__(
                /*! ./adapters/http */ './node_modules/axios/lib/adapters/xhr.js'
              )
            }
            return adapter
          }

          var defaults = {
            adapter: getDefaultAdapter(),

            transformRequest: [
              function transformRequest(data, headers) {
                normalizeHeaderName(headers, 'Accept')
                normalizeHeaderName(headers, 'Content-Type')
                if (
                  utils.isFormData(data) ||
                  utils.isArrayBuffer(data) ||
                  utils.isBuffer(data) ||
                  utils.isStream(data) ||
                  utils.isFile(data) ||
                  utils.isBlob(data)
                ) {
                  return data
                }
                if (utils.isArrayBufferView(data)) {
                  return data.buffer
                }
                if (utils.isURLSearchParams(data)) {
                  setContentTypeIfUnset(
                    headers,
                    'application/x-www-form-urlencoded;charset=utf-8'
                  )
                  return data.toString()
                }
                if (utils.isObject(data)) {
                  setContentTypeIfUnset(
                    headers,
                    'application/json;charset=utf-8'
                  )
                  return JSON.stringify(data)
                }
                return data
              },
            ],

            transformResponse: [
              function transformResponse(data) {
                /*eslint no-param-reassign:0*/
                if (typeof data === 'string') {
                  try {
                    data = JSON.parse(data)
                  } catch (e) {
                    /* Ignore */
                  }
                }
                return data
              },
            ],

            /**
             * A timeout in milliseconds to abort a request. If set to 0 (default) a
             * timeout is not created.
             */
            timeout: 0,

            xsrfCookieName: 'XSRF-TOKEN',
            xsrfHeaderName: 'X-XSRF-TOKEN',

            maxContentLength: -1,
            maxBodyLength: -1,

            validateStatus: function validateStatus(status) {
              return status >= 200 && status < 300
            },
          }

          defaults.headers = {
            common: {
              Accept: 'application/json, text/plain, */*',
            },
          }

          utils.forEach(
            ['delete', 'get', 'head'],
            function forEachMethodNoData(method) {
              defaults.headers[method] = {}
            }
          )

          utils.forEach(
            ['post', 'put', 'patch'],
            function forEachMethodWithData(method) {
              defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE)
            }
          )

          module.exports = defaults

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/bind.js':
        /*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
        /***/ (module) => {
          'use strict'

          module.exports = function bind(fn, thisArg) {
            return function wrap() {
              var args = new Array(arguments.length)
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i]
              }
              return fn.apply(thisArg, args)
            }
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/buildURL.js':
        /*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_147123__) => {
          'use strict'

          var utils = __nested_webpack_require_147123__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          function encode(val) {
            return encodeURIComponent(val)
              .replace(/%3A/gi, ':')
              .replace(/%24/g, '$')
              .replace(/%2C/gi, ',')
              .replace(/%20/g, '+')
              .replace(/%5B/gi, '[')
              .replace(/%5D/gi, ']')
          }

          /**
           * Build a URL by appending params to the end
           *
           * @param {string} url The base of the url (e.g., http://www.google.com)
           * @param {object} [params] The params to be appended
           * @returns {string} The formatted url
           */
          module.exports = function buildURL(url, params, paramsSerializer) {
            /*eslint no-param-reassign:0*/
            if (!params) {
              return url
            }

            var serializedParams
            if (paramsSerializer) {
              serializedParams = paramsSerializer(params)
            } else if (utils.isURLSearchParams(params)) {
              serializedParams = params.toString()
            } else {
              var parts = []

              utils.forEach(params, function serialize(val, key) {
                if (val === null || typeof val === 'undefined') {
                  return
                }

                if (utils.isArray(val)) {
                  key = key + '[]'
                } else {
                  val = [val]
                }

                utils.forEach(val, function parseValue(v) {
                  if (utils.isDate(v)) {
                    v = v.toISOString()
                  } else if (utils.isObject(v)) {
                    v = JSON.stringify(v)
                  }
                  parts.push(encode(key) + '=' + encode(v))
                })
              })

              serializedParams = parts.join('&')
            }

            if (serializedParams) {
              var hashmarkIndex = url.indexOf('#')
              if (hashmarkIndex !== -1) {
                url = url.slice(0, hashmarkIndex)
              }

              url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams
            }

            return url
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/combineURLs.js':
        /*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Creates a new URL by combining the specified URLs
           *
           * @param {string} baseURL The base URL
           * @param {string} relativeURL The relative URL
           * @returns {string} The combined URL
           */
          module.exports = function combineURLs(baseURL, relativeURL) {
            return relativeURL
              ? baseURL.replace(/\/+$/, '') +
                  '/' +
                  relativeURL.replace(/^\/+/, '')
              : baseURL
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/cookies.js':
        /*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_150606__) => {
          'use strict'

          var utils = __nested_webpack_require_150606__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          module.exports = utils.isStandardBrowserEnv()
            ? // Standard browser envs support document.cookie
              (function standardBrowserEnv() {
                return {
                  write: function write(
                    name,
                    value,
                    expires,
                    path,
                    domain,
                    secure
                  ) {
                    var cookie = []
                    cookie.push(name + '=' + encodeURIComponent(value))

                    if (utils.isNumber(expires)) {
                      cookie.push('expires=' + new Date(expires).toGMTString())
                    }

                    if (utils.isString(path)) {
                      cookie.push('path=' + path)
                    }

                    if (utils.isString(domain)) {
                      cookie.push('domain=' + domain)
                    }

                    if (secure === true) {
                      cookie.push('secure')
                    }

                    document.cookie = cookie.join('; ')
                  },

                  read: function read(name) {
                    var match = document.cookie.match(
                      new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')
                    )
                    return match ? decodeURIComponent(match[3]) : null
                  },

                  remove: function remove(name) {
                    this.write(name, '', Date.now() - 86400000)
                  },
                }
              })()
            : // Non standard browser env (web workers, react-native) lack needed support.
              (function nonStandardBrowserEnv() {
                return {
                  write: function write() {},
                  read: function read() {
                    return null
                  },
                  remove: function remove() {},
                }
              })()

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/isAbsoluteURL.js':
        /*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Determines whether the specified URL is absolute
           *
           * @param {string} url The URL to test
           * @returns {boolean} True if the specified URL is absolute, otherwise false
           */
          module.exports = function isAbsoluteURL(url) {
            // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
            // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
            // by any combination of letters, digits, plus, period, or hyphen.
            return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/isAxiosError.js':
        /*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Determines whether the payload is an error thrown by Axios
           *
           * @param {*} payload The value to test
           * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
           */
          module.exports = function isAxiosError(payload) {
            return typeof payload === 'object' && payload.isAxiosError === true
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/isURLSameOrigin.js':
        /*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_154847__) => {
          'use strict'

          var utils = __nested_webpack_require_154847__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          module.exports = utils.isStandardBrowserEnv()
            ? // Standard browser envs have full support of the APIs needed to test
              // whether the request URL is of the same origin as current location.
              (function standardBrowserEnv() {
                var msie = /(msie|trident)/i.test(navigator.userAgent)
                var urlParsingNode = document.createElement('a')
                var originURL

                /**
                 * Parse a URL to discover it's components
                 *
                 * @param {String} url The URL to be parsed
                 * @returns {Object}
                 */
                function resolveURL(url) {
                  var href = url

                  if (msie) {
                    // IE needs attribute set twice to normalize properties
                    urlParsingNode.setAttribute('href', href)
                    href = urlParsingNode.href
                  }

                  urlParsingNode.setAttribute('href', href)

                  // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
                  return {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol
                      ? urlParsingNode.protocol.replace(/:$/, '')
                      : '',
                    host: urlParsingNode.host,
                    search: urlParsingNode.search
                      ? urlParsingNode.search.replace(/^\?/, '')
                      : '',
                    hash: urlParsingNode.hash
                      ? urlParsingNode.hash.replace(/^#/, '')
                      : '',
                    hostname: urlParsingNode.hostname,
                    port: urlParsingNode.port,
                    pathname:
                      urlParsingNode.pathname.charAt(0) === '/'
                        ? urlParsingNode.pathname
                        : '/' + urlParsingNode.pathname,
                  }
                }

                originURL = resolveURL(window.location.href)

                /**
                 * Determine if a URL shares the same origin as the current location
                 *
                 * @param {String} requestURL The URL to test
                 * @returns {boolean} True if URL shares the same origin, otherwise false
                 */
                return function isURLSameOrigin(requestURL) {
                  var parsed = utils.isString(requestURL)
                    ? resolveURL(requestURL)
                    : requestURL
                  return (
                    parsed.protocol === originURL.protocol &&
                    parsed.host === originURL.host
                  )
                }
              })()
            : // Non standard browser envs (web workers, react-native) lack needed support.
              (function nonStandardBrowserEnv() {
                return function isURLSameOrigin() {
                  return true
                }
              })()

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/normalizeHeaderName.js':
        /*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_158420__) => {
          'use strict'

          var utils = __nested_webpack_require_158420__(
            /*! ../utils */ './node_modules/axios/lib/utils.js'
          )

          module.exports = function normalizeHeaderName(
            headers,
            normalizedName
          ) {
            utils.forEach(headers, function processHeader(value, name) {
              if (
                name !== normalizedName &&
                name.toUpperCase() === normalizedName.toUpperCase()
              ) {
                headers[normalizedName] = value
                delete headers[name]
              }
            })
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/parseHeaders.js':
        /*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_159393__) => {
          'use strict'

          var utils = __nested_webpack_require_159393__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          // Headers whose duplicates are ignored by node
          // c.f. https://nodejs.org/api/http.html#http_message_headers
          var ignoreDuplicateOf = [
            'age',
            'authorization',
            'content-length',
            'content-type',
            'etag',
            'expires',
            'from',
            'host',
            'if-modified-since',
            'if-unmodified-since',
            'last-modified',
            'location',
            'max-forwards',
            'proxy-authorization',
            'referer',
            'retry-after',
            'user-agent',
          ]

          /**
           * Parse headers into an object
           *
           * ```
           * Date: Wed, 27 Aug 2014 08:58:49 GMT
           * Content-Type: application/json
           * Connection: keep-alive
           * Transfer-Encoding: chunked
           * ```
           *
           * @param {String} headers Headers needing to be parsed
           * @returns {Object} Headers parsed into an object
           */
          module.exports = function parseHeaders(headers) {
            var parsed = {}
            var key
            var val
            var i

            if (!headers) {
              return parsed
            }

            utils.forEach(headers.split('\n'), function parser(line) {
              i = line.indexOf(':')
              key = utils.trim(line.substr(0, i)).toLowerCase()
              val = utils.trim(line.substr(i + 1))

              if (key) {
                if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                  return
                }
                if (key === 'set-cookie') {
                  parsed[key] = (parsed[key] ? parsed[key] : []).concat([val])
                } else {
                  parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val
                }
              }
            })

            return parsed
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/spread.js':
        /*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Syntactic sugar for invoking a function and expanding an array for arguments.
           *
           * Common use case would be to use `Function.prototype.apply`.
           *
           *  ```js
           *  function f(x, y, z) {}
           *  var args = [1, 2, 3];
           *  f.apply(null, args);
           *  ```
           *
           * With `spread` this example can be re-written.
           *
           *  ```js
           *  spread(function(x, y, z) {})([1, 2, 3]);
           *  ```
           *
           * @param {Function} callback
           * @returns {Function}
           */
          module.exports = function spread(callback) {
            return function wrap(arr) {
              return callback.apply(null, arr)
            }
          }

          /***/
        },

      /***/ './node_modules/axios/lib/utils.js':
        /*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_162900__) => {
          'use strict'

          var bind = __nested_webpack_require_162900__(
            /*! ./helpers/bind */ './node_modules/axios/lib/helpers/bind.js'
          )

          /*global toString:true*/

          // utils is a library of generic helper functions non-specific to axios

          var toString = Object.prototype.toString

          /**
           * Determine if a value is an Array
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an Array, otherwise false
           */
          function isArray(val) {
            return toString.call(val) === '[object Array]'
          }

          /**
           * Determine if a value is undefined
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if the value is undefined, otherwise false
           */
          function isUndefined(val) {
            return typeof val === 'undefined'
          }

          /**
           * Determine if a value is a Buffer
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Buffer, otherwise false
           */
          function isBuffer(val) {
            return (
              val !== null &&
              !isUndefined(val) &&
              val.constructor !== null &&
              !isUndefined(val.constructor) &&
              typeof val.constructor.isBuffer === 'function' &&
              val.constructor.isBuffer(val)
            )
          }

          /**
           * Determine if a value is an ArrayBuffer
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an ArrayBuffer, otherwise false
           */
          function isArrayBuffer(val) {
            return toString.call(val) === '[object ArrayBuffer]'
          }

          /**
           * Determine if a value is a FormData
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an FormData, otherwise false
           */
          function isFormData(val) {
            return typeof FormData !== 'undefined' && val instanceof FormData
          }

          /**
           * Determine if a value is a view on an ArrayBuffer
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
           */
          function isArrayBufferView(val) {
            var result
            if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
              result = ArrayBuffer.isView(val)
            } else {
              result = val && val.buffer && val.buffer instanceof ArrayBuffer
            }
            return result
          }

          /**
           * Determine if a value is a String
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a String, otherwise false
           */
          function isString(val) {
            return typeof val === 'string'
          }

          /**
           * Determine if a value is a Number
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Number, otherwise false
           */
          function isNumber(val) {
            return typeof val === 'number'
          }

          /**
           * Determine if a value is an Object
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an Object, otherwise false
           */
          function isObject(val) {
            return val !== null && typeof val === 'object'
          }

          /**
           * Determine if a value is a plain Object
           *
           * @param {Object} val The value to test
           * @return {boolean} True if value is a plain Object, otherwise false
           */
          function isPlainObject(val) {
            if (toString.call(val) !== '[object Object]') {
              return false
            }

            var prototype = Object.getPrototypeOf(val)
            return prototype === null || prototype === Object.prototype
          }

          /**
           * Determine if a value is a Date
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Date, otherwise false
           */
          function isDate(val) {
            return toString.call(val) === '[object Date]'
          }

          /**
           * Determine if a value is a File
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a File, otherwise false
           */
          function isFile(val) {
            return toString.call(val) === '[object File]'
          }

          /**
           * Determine if a value is a Blob
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Blob, otherwise false
           */
          function isBlob(val) {
            return toString.call(val) === '[object Blob]'
          }

          /**
           * Determine if a value is a Function
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Function, otherwise false
           */
          function isFunction(val) {
            return toString.call(val) === '[object Function]'
          }

          /**
           * Determine if a value is a Stream
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Stream, otherwise false
           */
          function isStream(val) {
            return isObject(val) && isFunction(val.pipe)
          }

          /**
           * Determine if a value is a URLSearchParams object
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a URLSearchParams object, otherwise false
           */
          function isURLSearchParams(val) {
            return (
              typeof URLSearchParams !== 'undefined' &&
              val instanceof URLSearchParams
            )
          }

          /**
           * Trim excess whitespace off the beginning and end of a string
           *
           * @param {String} str The String to trim
           * @returns {String} The String freed of excess whitespace
           */
          function trim(str) {
            return str.replace(/^\s*/, '').replace(/\s*$/, '')
          }

          /**
           * Determine if we're running in a standard browser environment
           *
           * This allows axios to run in a web worker, and react-native.
           * Both environments support XMLHttpRequest, but not fully standard globals.
           *
           * web workers:
           *  typeof window -> undefined
           *  typeof document -> undefined
           *
           * react-native:
           *  navigator.product -> 'ReactNative'
           * nativescript
           *  navigator.product -> 'NativeScript' or 'NS'
           */
          function isStandardBrowserEnv() {
            if (
              typeof navigator !== 'undefined' &&
              (navigator.product === 'ReactNative' ||
                navigator.product === 'NativeScript' ||
                navigator.product === 'NS')
            ) {
              return false
            }
            return (
              typeof window !== 'undefined' && typeof document !== 'undefined'
            )
          }

          /**
           * Iterate over an Array or an Object invoking a function for each item.
           *
           * If `obj` is an Array callback will be called passing
           * the value, index, and complete array for each item.
           *
           * If 'obj' is an Object callback will be called passing
           * the value, key, and complete object for each property.
           *
           * @param {Object|Array} obj The object to iterate
           * @param {Function} fn The callback to invoke for each item
           */
          function forEach(obj, fn) {
            // Don't bother if no value provided
            if (obj === null || typeof obj === 'undefined') {
              return
            }

            // Force an array if not already something iterable
            if (typeof obj !== 'object') {
              /*eslint no-param-reassign:0*/
              obj = [obj]
            }

            if (isArray(obj)) {
              // Iterate over array values
              for (var i = 0, l = obj.length; i < l; i++) {
                fn.call(null, obj[i], i, obj)
              }
            } else {
              // Iterate over object keys
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  fn.call(null, obj[key], key, obj)
                }
              }
            }
          }

          /**
           * Accepts varargs expecting each argument to be an object, then
           * immutably merges the properties of each object and returns result.
           *
           * When multiple objects contain the same key the later object in
           * the arguments list will take precedence.
           *
           * Example:
           *
           * ```js
           * var result = merge({foo: 123}, {foo: 456});
           * console.log(result.foo); // outputs 456
           * ```
           *
           * @param {Object} obj1 Object to merge
           * @returns {Object} Result of all merge properties
           */
          function merge(/* obj1, obj2, obj3, ... */) {
            var result = {}
            function assignValue(val, key) {
              if (isPlainObject(result[key]) && isPlainObject(val)) {
                result[key] = merge(result[key], val)
              } else if (isPlainObject(val)) {
                result[key] = merge({}, val)
              } else if (isArray(val)) {
                result[key] = val.slice()
              } else {
                result[key] = val
              }
            }

            for (var i = 0, l = arguments.length; i < l; i++) {
              forEach(arguments[i], assignValue)
            }
            return result
          }

          /**
           * Extends object a by mutably adding to it the properties of object b.
           *
           * @param {Object} a The object to be extended
           * @param {Object} b The object to copy properties from
           * @param {Object} thisArg The object to bind function to
           * @return {Object} The resulting value of object a
           */
          function extend(a, b, thisArg) {
            forEach(b, function assignValue(val, key) {
              if (thisArg && typeof val === 'function') {
                a[key] = bind(val, thisArg)
              } else {
                a[key] = val
              }
            })
            return a
          }

          /**
           * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
           *
           * @param {string} content with BOM
           * @return {string} content value without BOM
           */
          function stripBOM(content) {
            if (content.charCodeAt(0) === 0xfeff) {
              content = content.slice(1)
            }
            return content
          }

          module.exports = {
            isArray: isArray,
            isArrayBuffer: isArrayBuffer,
            isBuffer: isBuffer,
            isFormData: isFormData,
            isArrayBufferView: isArrayBufferView,
            isString: isString,
            isNumber: isNumber,
            isObject: isObject,
            isPlainObject: isPlainObject,
            isUndefined: isUndefined,
            isDate: isDate,
            isFile: isFile,
            isBlob: isBlob,
            isFunction: isFunction,
            isStream: isStream,
            isURLSearchParams: isURLSearchParams,
            isStandardBrowserEnv: isStandardBrowserEnv,
            forEach: forEach,
            merge: merge,
            extend: extend,
            trim: trim,
            stripBOM: stripBOM,
          }

          /***/
        },

      /***/ './node_modules/call-bind/callBound.js':
        /*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_175474__) => {
          'use strict'

          var GetIntrinsic = __nested_webpack_require_175474__(
            /*! get-intrinsic */ './node_modules/get-intrinsic/index.js'
          )

          var callBind = __nested_webpack_require_175474__(
            /*! ./ */ './node_modules/call-bind/index.js'
          )

          var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'))

          module.exports = function callBoundIntrinsic(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing)
            if (
              typeof intrinsic === 'function' &&
              $indexOf(name, '.prototype.') > -1
            ) {
              return callBind(intrinsic)
            }
            return intrinsic
          }

          /***/
        },

      /***/ './node_modules/call-bind/index.js':
        /*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_176496__) => {
          'use strict'

          var bind = __nested_webpack_require_176496__(
            /*! function-bind */ './node_modules/function-bind/index.js'
          )
          var GetIntrinsic = __nested_webpack_require_176496__(
            /*! get-intrinsic */ './node_modules/get-intrinsic/index.js'
          )

          var $apply = GetIntrinsic('%Function.prototype.apply%')
          var $call = GetIntrinsic('%Function.prototype.call%')
          var $reflectApply =
            GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply)

          var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true)
          var $defineProperty = GetIntrinsic('%Object.defineProperty%', true)
          var $max = GetIntrinsic('%Math.max%')

          if ($defineProperty) {
            try {
              $defineProperty({}, 'a', { value: 1 })
            } catch (e) {
              // IE 8 has a broken defineProperty
              $defineProperty = null
            }
          }

          module.exports = function callBind(originalFunction) {
            var func = $reflectApply(bind, $call, arguments)
            if ($gOPD && $defineProperty) {
              var desc = $gOPD(func, 'length')
              if (desc.configurable) {
                // original length, plus the receiver, minus any additional arguments (after the receiver)
                $defineProperty(func, 'length', {
                  value:
                    1 +
                    $max(0, originalFunction.length - (arguments.length - 1)),
                })
              }
            }
            return func
          }

          var applyBind = function applyBind() {
            return $reflectApply(bind, $apply, arguments)
          }

          if ($defineProperty) {
            $defineProperty(module.exports, 'apply', { value: applyBind })
          } else {
            module.exports.apply = applyBind
          }

          /***/
        },

      /***/ './node_modules/console-browserify/index.js':
        /*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_178739__) => {
          /*global window, global*/
          var util = __nested_webpack_require_178739__(
            /*! util */ './node_modules/util/util.js'
          )
          var assert = __nested_webpack_require_178739__(
            /*! assert */ './node_modules/assert/build/assert.js'
          )
          function now() {
            return new Date().getTime()
          }

          var slice = Array.prototype.slice
          var console
          var times = {}

          if (
            typeof __nested_webpack_require_178739__.g !== 'undefined' &&
            __nested_webpack_require_178739__.g.console
          ) {
            console = __nested_webpack_require_178739__.g.console
          } else if (typeof window !== 'undefined' && window.console) {
            console = window.console
          } else {
            console = {}
          }

          var functions = [
            [log, 'log'],
            [info, 'info'],
            [warn, 'warn'],
            [error, 'error'],
            [time, 'time'],
            [timeEnd, 'timeEnd'],
            [trace, 'trace'],
            [dir, 'dir'],
            [consoleAssert, 'assert'],
          ]

          for (var i = 0; i < functions.length; i++) {
            var tuple = functions[i]
            var f = tuple[0]
            var name = tuple[1]

            if (!console[name]) {
              console[name] = f
            }
          }

          module.exports = console

          function log() {}

          function info() {
            console.log.apply(console, arguments)
          }

          function warn() {
            console.log.apply(console, arguments)
          }

          function error() {
            console.warn.apply(console, arguments)
          }

          function time(label) {
            times[label] = now()
          }

          function timeEnd(label) {
            var time = times[label]
            if (!time) {
              throw new Error('No such label: ' + label)
            }

            delete times[label]
            var duration = now() - time
            console.log(label + ': ' + duration + 'ms')
          }

          function trace() {
            var err = new Error()
            err.name = 'Trace'
            err.message = util.format.apply(null, arguments)
            console.error(err.stack)
          }

          function dir(object) {
            console.log(util.inspect(object) + '\n')
          }

          function consoleAssert(expression) {
            if (!expression) {
              var arr = slice.call(arguments, 1)
              assert.ok(false, util.format.apply(null, arr))
            }
          }

          /***/
        },

      /***/ './node_modules/define-properties/index.js':
        /*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_181663__) => {
          'use strict'

          var keys = __nested_webpack_require_181663__(
            /*! object-keys */ './node_modules/object-keys/index.js'
          )
          var hasSymbols =
            typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol'

          var toStr = Object.prototype.toString
          var concat = Array.prototype.concat
          var origDefineProperty = Object.defineProperty

          var isFunction = function (fn) {
            return (
              typeof fn === 'function' && toStr.call(fn) === '[object Function]'
            )
          }

          var arePropertyDescriptorsSupported = function () {
            var obj = {}
            try {
              origDefineProperty(obj, 'x', { enumerable: false, value: obj })
              // eslint-disable-next-line no-unused-vars, no-restricted-syntax
              for (var _ in obj) {
                // jscs:ignore disallowUnusedVariables
                return false
              }
              return obj.x === obj
            } catch (e) {
              /* this is IE 8. */
              return false
            }
          }
          var supportsDescriptors =
            origDefineProperty && arePropertyDescriptorsSupported()

          var defineProperty = function (object, name, value, predicate) {
            if (name in object && (!isFunction(predicate) || !predicate())) {
              return
            }
            if (supportsDescriptors) {
              origDefineProperty(object, name, {
                configurable: true,
                enumerable: false,
                value: value,
                writable: true,
              })
            } else {
              object[name] = value
            }
          }

          var defineProperties = function (object, map) {
            var predicates = arguments.length > 2 ? arguments[2] : {}
            var props = keys(map)
            if (hasSymbols) {
              props = concat.call(props, Object.getOwnPropertySymbols(map))
            }
            for (var i = 0; i < props.length; i += 1) {
              defineProperty(
                object,
                props[i],
                map[props[i]],
                predicates[props[i]]
              )
            }
          }

          defineProperties.supportsDescriptors = !!supportsDescriptors

          module.exports = defineProperties

          /***/
        },

      /***/ './node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_184461__) => {
          'use strict'

          var GetIntrinsic = __nested_webpack_require_184461__(
            /*! get-intrinsic */ './node_modules/get-intrinsic/index.js'
          )

          var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%')
          if ($gOPD) {
            try {
              $gOPD([], 'length')
            } catch (e) {
              // IE 8 has a broken gOPD
              $gOPD = null
            }
          }

          module.exports = $gOPD

          /***/
        },

      /***/ './node_modules/es6-object-assign/index.js':
        /*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
        /***/ (module) => {
          'use strict'
          /**
           * Code refactored from Mozilla Developer Network:
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
           */

          function assign(target, firstSource) {
            if (target === undefined || target === null) {
              throw new TypeError('Cannot convert first argument to object')
            }

            var to = Object(target)
            for (var i = 1; i < arguments.length; i++) {
              var nextSource = arguments[i]
              if (nextSource === undefined || nextSource === null) {
                continue
              }

              var keysArray = Object.keys(Object(nextSource))
              for (
                var nextIndex = 0, len = keysArray.length;
                nextIndex < len;
                nextIndex++
              ) {
                var nextKey = keysArray[nextIndex]
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey)
                if (desc !== undefined && desc.enumerable) {
                  to[nextKey] = nextSource[nextKey]
                }
              }
            }
            return to
          }

          function polyfill() {
            if (!Object.assign) {
              Object.defineProperty(Object, 'assign', {
                enumerable: false,
                configurable: true,
                writable: true,
                value: assign,
              })
            }
          }

          module.exports = {
            assign: assign,
            polyfill: polyfill,
          }

          /***/
        },

      /***/ './node_modules/events/events.js':
        /*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_187117__) => {
          'use strict'
          /* provided dependency */ var console = __nested_webpack_require_187117__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var R = typeof Reflect === 'object' ? Reflect : null
          var ReflectApply =
            R && typeof R.apply === 'function'
              ? R.apply
              : function ReflectApply(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args)
                }

          var ReflectOwnKeys
          if (R && typeof R.ownKeys === 'function') {
            ReflectOwnKeys = R.ownKeys
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target).concat(
                Object.getOwnPropertySymbols(target)
              )
            }
          } else {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target)
            }
          }

          function ProcessEmitWarning(warning) {
            if (console && console.warn) console.warn(warning)
          }

          var NumberIsNaN =
            Number.isNaN ||
            function NumberIsNaN(value) {
              return value !== value
            }

          function EventEmitter() {
            EventEmitter.init.call(this)
          }
          module.exports = EventEmitter
          module.exports.once = once

          // Backwards-compat with node 0.10.x
          EventEmitter.EventEmitter = EventEmitter

          EventEmitter.prototype._events = undefined
          EventEmitter.prototype._eventsCount = 0
          EventEmitter.prototype._maxListeners = undefined

          // By default EventEmitters will print a warning if more than 10 listeners are
          // added to it. This is a useful default which helps finding memory leaks.
          var defaultMaxListeners = 10

          function checkListener(listener) {
            if (typeof listener !== 'function') {
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof listener
              )
            }
          }

          Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
            enumerable: true,
            get: function () {
              return defaultMaxListeners
            },
            set: function (arg) {
              if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError(
                  'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                    arg +
                    '.'
                )
              }
              defaultMaxListeners = arg
            },
          })

          EventEmitter.init = function () {
            if (
              this._events === undefined ||
              this._events === Object.getPrototypeOf(this)._events
            ) {
              this._events = Object.create(null)
              this._eventsCount = 0
            }

            this._maxListeners = this._maxListeners || undefined
          }

          // Obviously not all Emitters should be limited to 10. This function allows
          // that to be increased. Set to zero for unlimited.
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
              throw new RangeError(
                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                  n +
                  '.'
              )
            }
            this._maxListeners = n
            return this
          }

          function _getMaxListeners(that) {
            if (that._maxListeners === undefined)
              return EventEmitter.defaultMaxListeners
            return that._maxListeners
          }

          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this)
          }

          EventEmitter.prototype.emit = function emit(type) {
            var args = []
            for (var i = 1; i < arguments.length; i++) args.push(arguments[i])
            var doError = type === 'error'

            var events = this._events
            if (events !== undefined)
              doError = doError && events.error === undefined
            else if (!doError) return false

            // If there is no 'error' event listener then throw.
            if (doError) {
              var er
              if (args.length > 0) er = args[0]
              if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er // Unhandled 'error' event
              }
              // At least give some kind of context to the user
              var err = new Error(
                'Unhandled error.' + (er ? ' (' + er.message + ')' : '')
              )
              err.context = er
              throw err // Unhandled 'error' event
            }

            var handler = events[type]

            if (handler === undefined) return false

            if (typeof handler === 'function') {
              ReflectApply(handler, this, args)
            } else {
              var len = handler.length
              var listeners = arrayClone(handler, len)
              for (var i = 0; i < len; ++i)
                ReflectApply(listeners[i], this, args)
            }

            return true
          }

          function _addListener(target, type, listener, prepend) {
            var m
            var events
            var existing

            checkListener(listener)

            events = target._events
            if (events === undefined) {
              events = target._events = Object.create(null)
              target._eventsCount = 0
            } else {
              // To avoid recursion in the case that type === "newListener"! Before
              // adding it to the listeners, first emit "newListener".
              if (events.newListener !== undefined) {
                target.emit(
                  'newListener',
                  type,
                  listener.listener ? listener.listener : listener
                )

                // Re-assign `events` because a newListener handler could have caused the
                // this._events to be assigned to a new object
                events = target._events
              }
              existing = events[type]
            }

            if (existing === undefined) {
              // Optimize the case of one listener. Don't need the extra array object.
              existing = events[type] = listener
              ++target._eventsCount
            } else {
              if (typeof existing === 'function') {
                // Adding the second element, need to change to array.
                existing = events[type] = prepend
                  ? [listener, existing]
                  : [existing, listener]
                // If we've already got an array, just append.
              } else if (prepend) {
                existing.unshift(listener)
              } else {
                existing.push(listener)
              }

              // Check for listener leak
              m = _getMaxListeners(target)
              if (m > 0 && existing.length > m && !existing.warned) {
                existing.warned = true
                // No error code for this since it is a Warning
                // eslint-disable-next-line no-restricted-syntax
                var w = new Error(
                  'Possible EventEmitter memory leak detected. ' +
                    existing.length +
                    ' ' +
                    String(type) +
                    ' listeners ' +
                    'added. Use emitter.setMaxListeners() to ' +
                    'increase limit'
                )
                w.name = 'MaxListenersExceededWarning'
                w.emitter = target
                w.type = type
                w.count = existing.length
                ProcessEmitWarning(w)
              }
            }

            return target
          }

          EventEmitter.prototype.addListener = function addListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, false)
          }

          EventEmitter.prototype.on = EventEmitter.prototype.addListener

          EventEmitter.prototype.prependListener = function prependListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, true)
          }

          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn)
              this.fired = true
              if (arguments.length === 0) return this.listener.call(this.target)
              return this.listener.apply(this.target, arguments)
            }
          }

          function _onceWrap(target, type, listener) {
            var state = {
              fired: false,
              wrapFn: undefined,
              target: target,
              type: type,
              listener: listener,
            }
            var wrapped = onceWrapper.bind(state)
            wrapped.listener = listener
            state.wrapFn = wrapped
            return wrapped
          }

          EventEmitter.prototype.once = function once(type, listener) {
            checkListener(listener)
            this.on(type, _onceWrap(this, type, listener))
            return this
          }

          EventEmitter.prototype.prependOnceListener = function prependOnceListener(
            type,
            listener
          ) {
            checkListener(listener)
            this.prependListener(type, _onceWrap(this, type, listener))
            return this
          }

          // Emits a 'removeListener' event if and only if the listener was removed.
          EventEmitter.prototype.removeListener = function removeListener(
            type,
            listener
          ) {
            var list, events, position, i, originalListener

            checkListener(listener)

            events = this._events
            if (events === undefined) return this

            list = events[type]
            if (list === undefined) return this

            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0) this._events = Object.create(null)
              else {
                delete events[type]
                if (events.removeListener)
                  this.emit('removeListener', type, list.listener || listener)
              }
            } else if (typeof list !== 'function') {
              position = -1

              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener
                  position = i
                  break
                }
              }

              if (position < 0) return this

              if (position === 0) list.shift()
              else {
                spliceOne(list, position)
              }

              if (list.length === 1) events[type] = list[0]

              if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener)
            }

            return this
          }

          EventEmitter.prototype.off = EventEmitter.prototype.removeListener

          EventEmitter.prototype.removeAllListeners = function removeAllListeners(
            type
          ) {
            var listeners, events, i

            events = this._events
            if (events === undefined) return this

            // not listening for removeListener, no need to emit
            if (events.removeListener === undefined) {
              if (arguments.length === 0) {
                this._events = Object.create(null)
                this._eventsCount = 0
              } else if (events[type] !== undefined) {
                if (--this._eventsCount === 0)
                  this._events = Object.create(null)
                else delete events[type]
              }
              return this
            }

            // emit removeListener for all listeners on all events
            if (arguments.length === 0) {
              var keys = Object.keys(events)
              var key
              for (i = 0; i < keys.length; ++i) {
                key = keys[i]
                if (key === 'removeListener') continue
                this.removeAllListeners(key)
              }
              this.removeAllListeners('removeListener')
              this._events = Object.create(null)
              this._eventsCount = 0
              return this
            }

            listeners = events[type]

            if (typeof listeners === 'function') {
              this.removeListener(type, listeners)
            } else if (listeners !== undefined) {
              // LIFO order
              for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i])
              }
            }

            return this
          }

          function _listeners(target, type, unwrap) {
            var events = target._events

            if (events === undefined) return []

            var evlistener = events[type]
            if (evlistener === undefined) return []

            if (typeof evlistener === 'function')
              return unwrap ? [evlistener.listener || evlistener] : [evlistener]

            return unwrap
              ? unwrapListeners(evlistener)
              : arrayClone(evlistener, evlistener.length)
          }

          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true)
          }

          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false)
          }

          EventEmitter.listenerCount = function (emitter, type) {
            if (typeof emitter.listenerCount === 'function') {
              return emitter.listenerCount(type)
            } else {
              return listenerCount.call(emitter, type)
            }
          }

          EventEmitter.prototype.listenerCount = listenerCount
          function listenerCount(type) {
            var events = this._events

            if (events !== undefined) {
              var evlistener = events[type]

              if (typeof evlistener === 'function') {
                return 1
              } else if (evlistener !== undefined) {
                return evlistener.length
              }
            }

            return 0
          }

          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
          }

          function arrayClone(arr, n) {
            var copy = new Array(n)
            for (var i = 0; i < n; ++i) copy[i] = arr[i]
            return copy
          }

          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++)
              list[index] = list[index + 1]
            list.pop()
          }

          function unwrapListeners(arr) {
            var ret = new Array(arr.length)
            for (var i = 0; i < ret.length; ++i) {
              ret[i] = arr[i].listener || arr[i]
            }
            return ret
          }

          function once(emitter, name) {
            return new Promise(function (resolve, reject) {
              function errorListener(err) {
                emitter.removeListener(name, resolver)
                reject(err)
              }

              function resolver() {
                if (typeof emitter.removeListener === 'function') {
                  emitter.removeListener('error', errorListener)
                }
                resolve([].slice.call(arguments))
              }

              eventTargetAgnosticAddListener(emitter, name, resolver, {
                once: true,
              })
              if (name !== 'error') {
                addErrorHandlerIfEventEmitter(emitter, errorListener, {
                  once: true,
                })
              }
            })
          }

          function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
            if (typeof emitter.on === 'function') {
              eventTargetAgnosticAddListener(emitter, 'error', handler, flags)
            }
          }

          function eventTargetAgnosticAddListener(
            emitter,
            name,
            listener,
            flags
          ) {
            if (typeof emitter.on === 'function') {
              if (flags.once) {
                emitter.once(name, listener)
              } else {
                emitter.on(name, listener)
              }
            } else if (typeof emitter.addEventListener === 'function') {
              // EventTarget does not have `error` event semantics like Node
              // EventEmitters, we do not listen for `error` events here.
              emitter.addEventListener(name, function wrapListener(arg) {
                // IE does not have builtin `{ once: true }` support so we
                // have to do it manually.
                if (flags.once) {
                  emitter.removeEventListener(name, wrapListener)
                }
                listener(arg)
              })
            } else {
              throw new TypeError(
                'The "emitter" argument must be of type EventEmitter. Received type ' +
                  typeof emitter
              )
            }
          }

          /***/
        },

      /***/ './node_modules/foreach/index.js':
        /*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
        /***/ (module) => {
          var hasOwn = Object.prototype.hasOwnProperty
          var toString = Object.prototype.toString

          module.exports = function forEach(obj, fn, ctx) {
            if (toString.call(fn) !== '[object Function]') {
              throw new TypeError('iterator must be a function')
            }
            var l = obj.length
            if (l === +l) {
              for (var i = 0; i < l; i++) {
                fn.call(ctx, obj[i], i, obj)
              }
            } else {
              for (var k in obj) {
                if (hasOwn.call(obj, k)) {
                  fn.call(ctx, obj[k], k, obj)
                }
              }
            }
          }

          /***/
        },

      /***/ './node_modules/form-data/lib/browser.js':
        /*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
        /***/ (module) => {
          /* eslint-env browser */
          module.exports =
            typeof self == 'object' ? self.FormData : window.FormData

          /***/
        },

      /***/ './node_modules/function-bind/implementation.js':
        /*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
        /***/ (module) => {
          'use strict'

          /* eslint no-invalid-this: 1 */

          var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible '
          var slice = Array.prototype.slice
          var toStr = Object.prototype.toString
          var funcType = '[object Function]'

          module.exports = function bind(that) {
            var target = this
            if (
              typeof target !== 'function' ||
              toStr.call(target) !== funcType
            ) {
              throw new TypeError(ERROR_MESSAGE + target)
            }
            var args = slice.call(arguments, 1)

            var bound
            var binder = function () {
              if (this instanceof bound) {
                var result = target.apply(
                  this,
                  args.concat(slice.call(arguments))
                )
                if (Object(result) === result) {
                  return result
                }
                return this
              } else {
                return target.apply(that, args.concat(slice.call(arguments)))
              }
            }

            var boundLength = Math.max(0, target.length - args.length)
            var boundArgs = []
            for (var i = 0; i < boundLength; i++) {
              boundArgs.push('$' + i)
            }

            bound = Function(
              'binder',
              'return function (' +
                boundArgs.join(',') +
                '){ return binder.apply(this,arguments); }'
            )(binder)

            if (target.prototype) {
              var Empty = function Empty() {}
              Empty.prototype = target.prototype
              bound.prototype = new Empty()
              Empty.prototype = null
            }

            return bound
          }

          /***/
        },

      /***/ './node_modules/function-bind/index.js':
        /*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_210165__) => {
          'use strict'

          var implementation = __nested_webpack_require_210165__(
            /*! ./implementation */ './node_modules/function-bind/implementation.js'
          )

          module.exports = Function.prototype.bind || implementation

          /***/
        },

      /***/ './node_modules/get-intrinsic/index.js':
        /*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_210725__) => {
          'use strict'

          var undefined

          var $SyntaxError = SyntaxError
          var $Function = Function
          var $TypeError = TypeError

          // eslint-disable-next-line consistent-return
          var getEvalledConstructor = function (expressionSyntax) {
            try {
              return $Function(
                '"use strict"; return (' + expressionSyntax + ').constructor;'
              )()
            } catch (e) {}
          }

          var $gOPD = Object.getOwnPropertyDescriptor
          if ($gOPD) {
            try {
              $gOPD({}, '')
            } catch (e) {
              $gOPD = null // this is IE 8, which has a broken gOPD
            }
          }

          var throwTypeError = function () {
            throw new $TypeError()
          }
          var ThrowTypeError = $gOPD
            ? (function () {
                try {
                  // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                  arguments.callee // IE 8 does not throw here
                  return throwTypeError
                } catch (calleeThrows) {
                  try {
                    // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                    return $gOPD(arguments, 'callee').get
                  } catch (gOPDthrows) {
                    return throwTypeError
                  }
                }
              })()
            : throwTypeError

          var hasSymbols = __nested_webpack_require_210725__(
            /*! has-symbols */ './node_modules/has-symbols/index.js'
          )()

          var getProto =
            Object.getPrototypeOf ||
            function (x) {
              return x.__proto__
            } // eslint-disable-line no-proto

          var needsEval = {}

          var TypedArray =
            typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array)

          var INTRINSICS = {
            '%AggregateError%':
              typeof AggregateError === 'undefined'
                ? undefined
                : AggregateError,
            '%Array%': Array,
            '%ArrayBuffer%':
              typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
            '%ArrayIteratorPrototype%': hasSymbols
              ? getProto([][Symbol.iterator]())
              : undefined,
            '%AsyncFromSyncIteratorPrototype%': undefined,
            '%AsyncFunction%': needsEval,
            '%AsyncGenerator%': needsEval,
            '%AsyncGeneratorFunction%': needsEval,
            '%AsyncIteratorPrototype%': needsEval,
            '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
            '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
            '%Boolean%': Boolean,
            '%DataView%':
              typeof DataView === 'undefined' ? undefined : DataView,
            '%Date%': Date,
            '%decodeURI%': decodeURI,
            '%decodeURIComponent%': decodeURIComponent,
            '%encodeURI%': encodeURI,
            '%encodeURIComponent%': encodeURIComponent,
            '%Error%': Error,
            '%eval%': eval, // eslint-disable-line no-eval
            '%EvalError%': EvalError,
            '%Float32Array%':
              typeof Float32Array === 'undefined' ? undefined : Float32Array,
            '%Float64Array%':
              typeof Float64Array === 'undefined' ? undefined : Float64Array,
            '%FinalizationRegistry%':
              typeof FinalizationRegistry === 'undefined'
                ? undefined
                : FinalizationRegistry,
            '%Function%': $Function,
            '%GeneratorFunction%': needsEval,
            '%Int8Array%':
              typeof Int8Array === 'undefined' ? undefined : Int8Array,
            '%Int16Array%':
              typeof Int16Array === 'undefined' ? undefined : Int16Array,
            '%Int32Array%':
              typeof Int32Array === 'undefined' ? undefined : Int32Array,
            '%isFinite%': isFinite,
            '%isNaN%': isNaN,
            '%IteratorPrototype%': hasSymbols
              ? getProto(getProto([][Symbol.iterator]()))
              : undefined,
            '%JSON%': typeof JSON === 'object' ? JSON : undefined,
            '%Map%': typeof Map === 'undefined' ? undefined : Map,
            '%MapIteratorPrototype%':
              typeof Map === 'undefined' || !hasSymbols
                ? undefined
                : getProto(new Map()[Symbol.iterator]()),
            '%Math%': Math,
            '%Number%': Number,
            '%Object%': Object,
            '%parseFloat%': parseFloat,
            '%parseInt%': parseInt,
            '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
            '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
            '%RangeError%': RangeError,
            '%ReferenceError%': ReferenceError,
            '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
            '%RegExp%': RegExp,
            '%Set%': typeof Set === 'undefined' ? undefined : Set,
            '%SetIteratorPrototype%':
              typeof Set === 'undefined' || !hasSymbols
                ? undefined
                : getProto(new Set()[Symbol.iterator]()),
            '%SharedArrayBuffer%':
              typeof SharedArrayBuffer === 'undefined'
                ? undefined
                : SharedArrayBuffer,
            '%String%': String,
            '%StringIteratorPrototype%': hasSymbols
              ? getProto(''[Symbol.iterator]())
              : undefined,
            '%Symbol%': hasSymbols ? Symbol : undefined,
            '%SyntaxError%': $SyntaxError,
            '%ThrowTypeError%': ThrowTypeError,
            '%TypedArray%': TypedArray,
            '%TypeError%': $TypeError,
            '%Uint8Array%':
              typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
            '%Uint8ClampedArray%':
              typeof Uint8ClampedArray === 'undefined'
                ? undefined
                : Uint8ClampedArray,
            '%Uint16Array%':
              typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
            '%Uint32Array%':
              typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
            '%URIError%': URIError,
            '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
            '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
            '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
          }

          var doEval = function doEval(name) {
            var value
            if (name === '%AsyncFunction%') {
              value = getEvalledConstructor('async function () {}')
            } else if (name === '%GeneratorFunction%') {
              value = getEvalledConstructor('function* () {}')
            } else if (name === '%AsyncGeneratorFunction%') {
              value = getEvalledConstructor('async function* () {}')
            } else if (name === '%AsyncGenerator%') {
              var fn = doEval('%AsyncGeneratorFunction%')
              if (fn) {
                value = fn.prototype
              }
            } else if (name === '%AsyncIteratorPrototype%') {
              var gen = doEval('%AsyncGenerator%')
              if (gen) {
                value = getProto(gen.prototype)
              }
            }

            INTRINSICS[name] = value

            return value
          }

          var LEGACY_ALIASES = {
            '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
            '%ArrayPrototype%': ['Array', 'prototype'],
            '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
            '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
            '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
            '%ArrayProto_values%': ['Array', 'prototype', 'values'],
            '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
            '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
            '%AsyncGeneratorPrototype%': [
              'AsyncGeneratorFunction',
              'prototype',
              'prototype',
            ],
            '%BooleanPrototype%': ['Boolean', 'prototype'],
            '%DataViewPrototype%': ['DataView', 'prototype'],
            '%DatePrototype%': ['Date', 'prototype'],
            '%ErrorPrototype%': ['Error', 'prototype'],
            '%EvalErrorPrototype%': ['EvalError', 'prototype'],
            '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
            '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
            '%FunctionPrototype%': ['Function', 'prototype'],
            '%Generator%': ['GeneratorFunction', 'prototype'],
            '%GeneratorPrototype%': [
              'GeneratorFunction',
              'prototype',
              'prototype',
            ],
            '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
            '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
            '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
            '%JSONParse%': ['JSON', 'parse'],
            '%JSONStringify%': ['JSON', 'stringify'],
            '%MapPrototype%': ['Map', 'prototype'],
            '%NumberPrototype%': ['Number', 'prototype'],
            '%ObjectPrototype%': ['Object', 'prototype'],
            '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
            '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
            '%PromisePrototype%': ['Promise', 'prototype'],
            '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
            '%Promise_all%': ['Promise', 'all'],
            '%Promise_reject%': ['Promise', 'reject'],
            '%Promise_resolve%': ['Promise', 'resolve'],
            '%RangeErrorPrototype%': ['RangeError', 'prototype'],
            '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
            '%RegExpPrototype%': ['RegExp', 'prototype'],
            '%SetPrototype%': ['Set', 'prototype'],
            '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
            '%StringPrototype%': ['String', 'prototype'],
            '%SymbolPrototype%': ['Symbol', 'prototype'],
            '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
            '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
            '%TypeErrorPrototype%': ['TypeError', 'prototype'],
            '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
            '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
            '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
            '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
            '%URIErrorPrototype%': ['URIError', 'prototype'],
            '%WeakMapPrototype%': ['WeakMap', 'prototype'],
            '%WeakSetPrototype%': ['WeakSet', 'prototype'],
          }

          var bind = __nested_webpack_require_210725__(
            /*! function-bind */ './node_modules/function-bind/index.js'
          )
          var hasOwn = __nested_webpack_require_210725__(
            /*! has */ './node_modules/has/src/index.js'
          )
          var $concat = bind.call(Function.call, Array.prototype.concat)
          var $spliceApply = bind.call(Function.apply, Array.prototype.splice)
          var $replace = bind.call(Function.call, String.prototype.replace)
          var $strSlice = bind.call(Function.call, String.prototype.slice)

          /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
          var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
          var reEscapeChar = /\\(\\)?/g /** Used to match backslashes in property paths. */
          var stringToPath = function stringToPath(string) {
            var first = $strSlice(string, 0, 1)
            var last = $strSlice(string, -1)
            if (first === '%' && last !== '%') {
              throw new $SyntaxError(
                'invalid intrinsic syntax, expected closing `%`'
              )
            } else if (last === '%' && first !== '%') {
              throw new $SyntaxError(
                'invalid intrinsic syntax, expected opening `%`'
              )
            }
            var result = []
            $replace(
              string,
              rePropName,
              function (match, number, quote, subString) {
                result[result.length] = quote
                  ? $replace(subString, reEscapeChar, '$1')
                  : number || match
              }
            )
            return result
          }
          /* end adaptation */

          var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
            var intrinsicName = name
            var alias
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
              alias = LEGACY_ALIASES[intrinsicName]
              intrinsicName = '%' + alias[0] + '%'
            }

            if (hasOwn(INTRINSICS, intrinsicName)) {
              var value = INTRINSICS[intrinsicName]
              if (value === needsEval) {
                value = doEval(intrinsicName)
              }
              if (typeof value === 'undefined' && !allowMissing) {
                throw new $TypeError(
                  'intrinsic ' +
                    name +
                    ' exists, but is not available. Please file an issue!'
                )
              }

              return {
                alias: alias,
                name: intrinsicName,
                value: value,
              }
            }

            throw new $SyntaxError('intrinsic ' + name + ' does not exist!')
          }

          module.exports = function GetIntrinsic(name, allowMissing) {
            if (typeof name !== 'string' || name.length === 0) {
              throw new $TypeError('intrinsic name must be a non-empty string')
            }
            if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
              throw new $TypeError('"allowMissing" argument must be a boolean')
            }

            var parts = stringToPath(name)
            var intrinsicBaseName = parts.length > 0 ? parts[0] : ''

            var intrinsic = getBaseIntrinsic(
              '%' + intrinsicBaseName + '%',
              allowMissing
            )
            var intrinsicRealName = intrinsic.name
            var value = intrinsic.value
            var skipFurtherCaching = false

            var alias = intrinsic.alias
            if (alias) {
              intrinsicBaseName = alias[0]
              $spliceApply(parts, $concat([0, 1], alias))
            }

            for (var i = 1, isOwn = true; i < parts.length; i += 1) {
              var part = parts[i]
              var first = $strSlice(part, 0, 1)
              var last = $strSlice(part, -1)
              if (
                (first === '"' ||
                  first === "'" ||
                  first === '`' ||
                  last === '"' ||
                  last === "'" ||
                  last === '`') &&
                first !== last
              ) {
                throw new $SyntaxError(
                  'property names with quotes must have matching quotes'
                )
              }
              if (part === 'constructor' || !isOwn) {
                skipFurtherCaching = true
              }

              intrinsicBaseName += '.' + part
              intrinsicRealName = '%' + intrinsicBaseName + '%'

              if (hasOwn(INTRINSICS, intrinsicRealName)) {
                value = INTRINSICS[intrinsicRealName]
              } else if (value != null) {
                if (!(part in value)) {
                  if (!allowMissing) {
                    throw new $TypeError(
                      'base intrinsic for ' +
                        name +
                        ' exists, but the property is not available.'
                    )
                  }
                  return void undefined
                }
                if ($gOPD && i + 1 >= parts.length) {
                  var desc = $gOPD(value, part)
                  isOwn = !!desc

                  // By convention, when a data property is converted to an accessor
                  // property to emulate a data property that does not suffer from
                  // the override mistake, that accessor's getter is marked with
                  // an `originalValue` property. Here, when we detect this, we
                  // uphold the illusion by pretending to see that original data
                  // property, i.e., returning the value rather than the getter
                  // itself.
                  if (
                    isOwn &&
                    'get' in desc &&
                    !('originalValue' in desc.get)
                  ) {
                    value = desc.get
                  } else {
                    value = value[part]
                  }
                } else {
                  isOwn = hasOwn(value, part)
                  value = value[part]
                }

                if (isOwn && !skipFurtherCaching) {
                  INTRINSICS[intrinsicRealName] = value
                }
              }
            }
            return value
          }

          /***/
        },

      /***/ './node_modules/has-symbols/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_228377__) => {
          'use strict'

          var origSymbol = typeof Symbol !== 'undefined' && Symbol
          var hasSymbolSham = __nested_webpack_require_228377__(
            /*! ./shams */ './node_modules/has-symbols/shams.js'
          )

          module.exports = function hasNativeSymbols() {
            if (typeof origSymbol !== 'function') {
              return false
            }
            if (typeof Symbol !== 'function') {
              return false
            }
            if (typeof origSymbol('foo') !== 'symbol') {
              return false
            }
            if (typeof Symbol('bar') !== 'symbol') {
              return false
            }

            return hasSymbolSham()
          }

          /***/
        },

      /***/ './node_modules/has-symbols/shams.js':
        /*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
        /***/ (module) => {
          'use strict'

          /* eslint complexity: [2, 18], max-statements: [2, 33] */
          module.exports = function hasSymbols() {
            if (
              typeof Symbol !== 'function' ||
              typeof Object.getOwnPropertySymbols !== 'function'
            ) {
              return false
            }
            if (typeof Symbol.iterator === 'symbol') {
              return true
            }

            var obj = {}
            var sym = Symbol('test')
            var symObj = Object(sym)
            if (typeof sym === 'string') {
              return false
            }

            if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
              return false
            }
            if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
              return false
            }

            // temp disabled per https://github.com/ljharb/object.assign/issues/17
            // if (sym instanceof Symbol) { return false; }
            // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
            // if (!(symObj instanceof Symbol)) { return false; }

            // if (typeof Symbol.prototype.toString !== 'function') { return false; }
            // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

            var symVal = 42
            obj[sym] = symVal
            for (sym in obj) {
              return false
            } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
            if (
              typeof Object.keys === 'function' &&
              Object.keys(obj).length !== 0
            ) {
              return false
            }

            if (
              typeof Object.getOwnPropertyNames === 'function' &&
              Object.getOwnPropertyNames(obj).length !== 0
            ) {
              return false
            }

            var syms = Object.getOwnPropertySymbols(obj)
            if (syms.length !== 1 || syms[0] !== sym) {
              return false
            }

            if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
              return false
            }

            if (typeof Object.getOwnPropertyDescriptor === 'function') {
              var descriptor = Object.getOwnPropertyDescriptor(obj, sym)
              if (
                descriptor.value !== symVal ||
                descriptor.enumerable !== true
              ) {
                return false
              }
            }

            return true
          }

          /***/
        },

      /***/ './node_modules/has/src/index.js':
        /*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_232174__) => {
          'use strict'

          var bind = __nested_webpack_require_232174__(
            /*! function-bind */ './node_modules/function-bind/index.js'
          )

          module.exports = bind.call(
            Function.call,
            Object.prototype.hasOwnProperty
          )

          /***/
        },

      /***/ './node_modules/inherits/inherits_browser.js':
        /*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
        /***/ (module) => {
          if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                  },
                })
              }
            }
          } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () {}
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
              }
            }
          }

          /***/
        },

      /***/ './node_modules/is-arguments/index.js':
        /*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_234078__) => {
          'use strict'

          var hasToStringTag =
            typeof Symbol === 'function' &&
            typeof Symbol.toStringTag === 'symbol'
          var callBound = __nested_webpack_require_234078__(
            /*! call-bind/callBound */ './node_modules/call-bind/callBound.js'
          )

          var $toString = callBound('Object.prototype.toString')

          var isStandardArguments = function isArguments(value) {
            if (
              hasToStringTag &&
              value &&
              typeof value === 'object' &&
              Symbol.toStringTag in value
            ) {
              return false
            }
            return $toString(value) === '[object Arguments]'
          }

          var isLegacyArguments = function isArguments(value) {
            if (isStandardArguments(value)) {
              return true
            }
            return (
              value !== null &&
              typeof value === 'object' &&
              typeof value.length === 'number' &&
              value.length >= 0 &&
              $toString(value) !== '[object Array]' &&
              $toString(value.callee) === '[object Function]'
            )
          }

          var supportsStandardArguments = (function () {
            return isStandardArguments(arguments)
          })()

          isStandardArguments.isLegacyArguments = isLegacyArguments // for tests

          module.exports = supportsStandardArguments
            ? isStandardArguments
            : isLegacyArguments

          /***/
        },

      /***/ './node_modules/is-generator-function/index.js':
        /*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
        /***/ (module) => {
          'use strict'

          var toStr = Object.prototype.toString
          var fnToStr = Function.prototype.toString
          var isFnRegex = /^\s*(?:function)?\*/
          var hasToStringTag =
            typeof Symbol === 'function' &&
            typeof Symbol.toStringTag === 'symbol'
          var getProto = Object.getPrototypeOf
          var getGeneratorFunc = function () {
            // eslint-disable-line consistent-return
            if (!hasToStringTag) {
              return false
            }
            try {
              return Function('return function*() {}')()
            } catch (e) {}
          }
          var generatorFunc = getGeneratorFunc()
          var GeneratorFunction =
            getProto && generatorFunc ? getProto(generatorFunc) : false

          module.exports = function isGeneratorFunction(fn) {
            if (typeof fn !== 'function') {
              return false
            }
            if (isFnRegex.test(fnToStr.call(fn))) {
              return true
            }
            if (!hasToStringTag) {
              var str = toStr.call(fn)
              return str === '[object GeneratorFunction]'
            }
            return getProto && getProto(fn) === GeneratorFunction
          }

          /***/
        },

      /***/ './node_modules/is-nan/implementation.js':
        /*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
        /***/ (module) => {
          'use strict'

          /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

          module.exports = function isNaN(value) {
            return value !== value
          }

          /***/
        },

      /***/ './node_modules/is-nan/index.js':
        /*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_237913__) => {
          'use strict'

          var callBind = __nested_webpack_require_237913__(
            /*! call-bind */ './node_modules/call-bind/index.js'
          )
          var define = __nested_webpack_require_237913__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )

          var implementation = __nested_webpack_require_237913__(
            /*! ./implementation */ './node_modules/is-nan/implementation.js'
          )
          var getPolyfill = __nested_webpack_require_237913__(
            /*! ./polyfill */ './node_modules/is-nan/polyfill.js'
          )
          var shim = __nested_webpack_require_237913__(
            /*! ./shim */ './node_modules/is-nan/shim.js'
          )

          var polyfill = callBind(getPolyfill(), Number)

          /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

          define(polyfill, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim,
          })

          module.exports = polyfill

          /***/
        },

      /***/ './node_modules/is-nan/polyfill.js':
        /*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_239206__) => {
          'use strict'

          var implementation = __nested_webpack_require_239206__(
            /*! ./implementation */ './node_modules/is-nan/implementation.js'
          )

          module.exports = function getPolyfill() {
            if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
              return Number.isNaN
            }
            return implementation
          }

          /***/
        },

      /***/ './node_modules/is-nan/shim.js':
        /*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_239879__) => {
          'use strict'

          var define = __nested_webpack_require_239879__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )
          var getPolyfill = __nested_webpack_require_239879__(
            /*! ./polyfill */ './node_modules/is-nan/polyfill.js'
          )

          /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

          module.exports = function shimNumberIsNaN() {
            var polyfill = getPolyfill()
            define(Number, { isNaN: polyfill }, {
              isNaN: function testIsNaN() {
                return Number.isNaN !== polyfill
              },
            })
            return polyfill
          }

          /***/
        },

      /***/ './node_modules/is-typed-array/index.js':
        /*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_240883__) => {
          'use strict'

          var forEach = __nested_webpack_require_240883__(
            /*! foreach */ './node_modules/foreach/index.js'
          )
          var availableTypedArrays = __nested_webpack_require_240883__(
            /*! available-typed-arrays */ './node_modules/available-typed-arrays/index.js'
          )
          var callBound = __nested_webpack_require_240883__(
            /*! call-bind/callBound */ './node_modules/call-bind/callBound.js'
          )

          var $toString = callBound('Object.prototype.toString')
          var hasSymbols = __nested_webpack_require_240883__(
            /*! has-symbols */ './node_modules/has-symbols/index.js'
          )()
          var hasToStringTag =
            hasSymbols && typeof Symbol.toStringTag === 'symbol'

          var typedArrays = availableTypedArrays()

          var $indexOf =
            callBound('Array.prototype.indexOf', true) ||
            function indexOf(array, value) {
              for (var i = 0; i < array.length; i += 1) {
                if (array[i] === value) {
                  return i
                }
              }
              return -1
            }
          var $slice = callBound('String.prototype.slice')
          var toStrTags = {}
          var gOPD = __nested_webpack_require_240883__(
            /*! es-abstract/helpers/getOwnPropertyDescriptor */ './node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js'
          )
          var getPrototypeOf = Object.getPrototypeOf // require('getprototypeof');
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function (typedArray) {
              var arr = new __nested_webpack_require_240883__.g[typedArray]()
              if (!(Symbol.toStringTag in arr)) {
                throw new EvalError(
                  'this engine has support for Symbol.toStringTag, but ' +
                    typedArray +
                    ' does not have the property! Please report this.'
                )
              }
              var proto = getPrototypeOf(arr)
              var descriptor = gOPD(proto, Symbol.toStringTag)
              if (!descriptor) {
                var superProto = getPrototypeOf(proto)
                descriptor = gOPD(superProto, Symbol.toStringTag)
              }
              toStrTags[typedArray] = descriptor.get
            })
          }

          var tryTypedArrays = function tryAllTypedArrays(value) {
            var anyTrue = false
            forEach(toStrTags, function (getter, typedArray) {
              if (!anyTrue) {
                try {
                  anyTrue = getter.call(value) === typedArray
                } catch (e) {
                  /**/
                }
              }
            })
            return anyTrue
          }

          module.exports = function isTypedArray(value) {
            if (!value || typeof value !== 'object') {
              return false
            }
            if (!hasToStringTag) {
              var tag = $slice($toString(value), 8, -1)
              return $indexOf(typedArrays, tag) > -1
            }
            if (!gOPD) {
              return false
            }
            return tryTypedArrays(value)
          }

          /***/
        },

      /***/ './node_modules/object-is/implementation.js':
        /*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
        /***/ (module) => {
          'use strict'

          var numberIsNaN = function (value) {
            return value !== value
          }

          module.exports = function is(a, b) {
            if (a === 0 && b === 0) {
              return 1 / a === 1 / b
            }
            if (a === b) {
              return true
            }
            if (numberIsNaN(a) && numberIsNaN(b)) {
              return true
            }
            return false
          }

          /***/
        },

      /***/ './node_modules/object-is/index.js':
        /*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_245081__) => {
          'use strict'

          var define = __nested_webpack_require_245081__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )
          var callBind = __nested_webpack_require_245081__(
            /*! call-bind */ './node_modules/call-bind/index.js'
          )

          var implementation = __nested_webpack_require_245081__(
            /*! ./implementation */ './node_modules/object-is/implementation.js'
          )
          var getPolyfill = __nested_webpack_require_245081__(
            /*! ./polyfill */ './node_modules/object-is/polyfill.js'
          )
          var shim = __nested_webpack_require_245081__(
            /*! ./shim */ './node_modules/object-is/shim.js'
          )

          var polyfill = callBind(getPolyfill(), Object)

          define(polyfill, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim,
          })

          module.exports = polyfill

          /***/
        },

      /***/ './node_modules/object-is/polyfill.js':
        /*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_246313__) => {
          'use strict'

          var implementation = __nested_webpack_require_246313__(
            /*! ./implementation */ './node_modules/object-is/implementation.js'
          )

          module.exports = function getPolyfill() {
            return typeof Object.is === 'function' ? Object.is : implementation
          }

          /***/
        },

      /***/ './node_modules/object-is/shim.js':
        /*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_246924__) => {
          'use strict'

          var getPolyfill = __nested_webpack_require_246924__(
            /*! ./polyfill */ './node_modules/object-is/polyfill.js'
          )
          var define = __nested_webpack_require_246924__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )

          module.exports = function shimObjectIs() {
            var polyfill = getPolyfill()
            define(Object, { is: polyfill }, {
              is: function testObjectIs() {
                return Object.is !== polyfill
              },
            })
            return polyfill
          }

          /***/
        },

      /***/ './node_modules/object-keys/implementation.js':
        /*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_247864__) => {
          'use strict'

          var keysShim
          if (!Object.keys) {
            // modified from https://github.com/es-shims/es5-shim
            var has = Object.prototype.hasOwnProperty
            var toStr = Object.prototype.toString
            var isArgs = __nested_webpack_require_247864__(
              /*! ./isArguments */ './node_modules/object-keys/isArguments.js'
            ) // eslint-disable-line global-require
            var isEnumerable = Object.prototype.propertyIsEnumerable
            var hasDontEnumBug = !isEnumerable.call(
              { toString: null },
              'toString'
            )
            var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype')
            var dontEnums = [
              'toString',
              'toLocaleString',
              'valueOf',
              'hasOwnProperty',
              'isPrototypeOf',
              'propertyIsEnumerable',
              'constructor',
            ]
            var equalsConstructorPrototype = function (o) {
              var ctor = o.constructor
              return ctor && ctor.prototype === o
            }
            var excludedKeys = {
              $applicationCache: true,
              $console: true,
              $external: true,
              $frame: true,
              $frameElement: true,
              $frames: true,
              $innerHeight: true,
              $innerWidth: true,
              $onmozfullscreenchange: true,
              $onmozfullscreenerror: true,
              $outerHeight: true,
              $outerWidth: true,
              $pageXOffset: true,
              $pageYOffset: true,
              $parent: true,
              $scrollLeft: true,
              $scrollTop: true,
              $scrollX: true,
              $scrollY: true,
              $self: true,
              $webkitIndexedDB: true,
              $webkitStorageInfo: true,
              $window: true,
            }
            var hasAutomationEqualityBug = (function () {
              /* global window */
              if (typeof window === 'undefined') {
                return false
              }
              for (var k in window) {
                try {
                  if (
                    !excludedKeys['$' + k] &&
                    has.call(window, k) &&
                    window[k] !== null &&
                    typeof window[k] === 'object'
                  ) {
                    try {
                      equalsConstructorPrototype(window[k])
                    } catch (e) {
                      return true
                    }
                  }
                } catch (e) {
                  return true
                }
              }
              return false
            })()
            var equalsConstructorPrototypeIfNotBuggy = function (o) {
              /* global window */
              if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                return equalsConstructorPrototype(o)
              }
              try {
                return equalsConstructorPrototype(o)
              } catch (e) {
                return false
              }
            }

            keysShim = function keys(object) {
              var isObject = object !== null && typeof object === 'object'
              var isFunction = toStr.call(object) === '[object Function]'
              var isArguments = isArgs(object)
              var isString =
                isObject && toStr.call(object) === '[object String]'
              var theKeys = []

              if (!isObject && !isFunction && !isArguments) {
                throw new TypeError('Object.keys called on a non-object')
              }

              var skipProto = hasProtoEnumBug && isFunction
              if (isString && object.length > 0 && !has.call(object, 0)) {
                for (var i = 0; i < object.length; ++i) {
                  theKeys.push(String(i))
                }
              }

              if (isArguments && object.length > 0) {
                for (var j = 0; j < object.length; ++j) {
                  theKeys.push(String(j))
                }
              } else {
                for (var name in object) {
                  if (
                    !(skipProto && name === 'prototype') &&
                    has.call(object, name)
                  ) {
                    theKeys.push(String(name))
                  }
                }
              }

              if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(
                  object
                )

                for (var k = 0; k < dontEnums.length; ++k) {
                  if (
                    !(skipConstructor && dontEnums[k] === 'constructor') &&
                    has.call(object, dontEnums[k])
                  ) {
                    theKeys.push(dontEnums[k])
                  }
                }
              }
              return theKeys
            }
          }
          module.exports = keysShim

          /***/
        },

      /***/ './node_modules/object-keys/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_253196__) => {
          'use strict'

          var slice = Array.prototype.slice
          var isArgs = __nested_webpack_require_253196__(
            /*! ./isArguments */ './node_modules/object-keys/isArguments.js'
          )

          var origKeys = Object.keys
          var keysShim = origKeys
            ? function keys(o) {
                return origKeys(o)
              }
            : __nested_webpack_require_253196__(
                /*! ./implementation */ './node_modules/object-keys/implementation.js'
              )

          var originalKeys = Object.keys

          keysShim.shim = function shimObjectKeys() {
            if (Object.keys) {
              var keysWorksWithArguments = (function () {
                // Safari 5.0 bug
                var args = Object.keys(arguments)
                return args && args.length === arguments.length
              })(1, 2)
              if (!keysWorksWithArguments) {
                Object.keys = function keys(object) {
                  // eslint-disable-line func-name-matching
                  if (isArgs(object)) {
                    return originalKeys(slice.call(object))
                  }
                  return originalKeys(object)
                }
              }
            } else {
              Object.keys = keysShim
            }
            return Object.keys || keysShim
          }

          module.exports = keysShim

          /***/
        },

      /***/ './node_modules/object-keys/isArguments.js':
        /*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
        /***/ (module) => {
          'use strict'

          var toStr = Object.prototype.toString

          module.exports = function isArguments(value) {
            var str = toStr.call(value)
            var isArgs = str === '[object Arguments]'
            if (!isArgs) {
              isArgs =
                str !== '[object Array]' &&
                value !== null &&
                typeof value === 'object' &&
                typeof value.length === 'number' &&
                value.length >= 0 &&
                toStr.call(value.callee) === '[object Function]'
            }
            return isArgs
          }

          /***/
        },

      /***/ './node_modules/process/browser.js':
        /*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
        /***/ (module) => {
          // shim for using process in browser
          var process = (module.exports = {})

          // cached from whatever global is present so that test runners that stub it
          // don't break things.  But we need to wrap it in a try catch in case it is
          // wrapped in strict mode code which doesn't define any globals.  It's inside a
          // function because try/catches deoptimize in certain engines.

          var cachedSetTimeout
          var cachedClearTimeout

          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined')
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined')
          }
          ;(function () {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout
              } else {
                cachedSetTimeout = defaultSetTimout
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout
              } else {
                cachedClearTimeout = defaultClearTimeout
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout
            }
          })()
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              //normal enviroments in sane situations
              return setTimeout(fun, 0)
            }
            // if setTimeout wasn't available but was latter defined
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout
              return setTimeout(fun, 0)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedSetTimeout(fun, 0)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0)
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              //normal enviroments in sane situations
              return clearTimeout(marker)
            }
            // if clearTimeout wasn't available but was latter defined
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout
              return clearTimeout(marker)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedClearTimeout(marker)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker)
              }
            }
          }
          var queue = []
          var draining = false
          var currentQueue
          var queueIndex = -1

          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return
            }
            draining = false
            if (currentQueue.length) {
              queue = currentQueue.concat(queue)
            } else {
              queueIndex = -1
            }
            if (queue.length) {
              drainQueue()
            }
          }

          function drainQueue() {
            if (draining) {
              return
            }
            var timeout = runTimeout(cleanUpNextTick)
            draining = true

            var len = queue.length
            while (len) {
              currentQueue = queue
              queue = []
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run()
                }
              }
              queueIndex = -1
              len = queue.length
            }
            currentQueue = null
            draining = false
            runClearTimeout(timeout)
          }

          process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1)
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i]
              }
            }
            queue.push(new Item(fun, args))
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue)
            }
          }

          // v8 likes predictible objects
          function Item(fun, array) {
            this.fun = fun
            this.array = array
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array)
          }
          process.title = 'browser'
          process.browser = true
          process.env = {}
          process.argv = []
          process.version = '' // empty string to avoid regexp issues
          process.versions = {}

          function noop() {}

          process.on = noop
          process.addListener = noop
          process.once = noop
          process.off = noop
          process.removeListener = noop
          process.removeAllListeners = noop
          process.emit = noop
          process.prependListener = noop
          process.prependOnceListener = noop

          process.listeners = function (name) {
            return []
          }

          process.binding = function (name) {
            throw new Error('process.binding is not supported')
          }

          process.cwd = function () {
            return '/'
          }
          process.chdir = function (dir) {
            throw new Error('process.chdir is not supported')
          }
          process.umask = function () {
            return 0
          }

          /***/
        },

      /***/ './node_modules/querystring/decode.js':
        /*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
        /***/ (module) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // If obj.hasOwnProperty has been overridden, then calling
          // obj.hasOwnProperty(prop) will break.
          // See: https://github.com/joyent/node/issues/1707
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop)
          }

          module.exports = function (qs, sep, eq, options) {
            sep = sep || '&'
            eq = eq || '='
            var obj = {}

            if (typeof qs !== 'string' || qs.length === 0) {
              return obj
            }

            var regexp = /\+/g
            qs = qs.split(sep)

            var maxKeys = 1000
            if (options && typeof options.maxKeys === 'number') {
              maxKeys = options.maxKeys
            }

            var len = qs.length
            // maxKeys <= 0 means that we should not limit keys count
            if (maxKeys > 0 && len > maxKeys) {
              len = maxKeys
            }

            for (var i = 0; i < len; ++i) {
              var x = qs[i].replace(regexp, '%20'),
                idx = x.indexOf(eq),
                kstr,
                vstr,
                k,
                v

              if (idx >= 0) {
                kstr = x.substr(0, idx)
                vstr = x.substr(idx + 1)
              } else {
                kstr = x
                vstr = ''
              }

              k = decodeURIComponent(kstr)
              v = decodeURIComponent(vstr)

              if (!hasOwnProperty(obj, k)) {
                obj[k] = v
              } else if (Array.isArray(obj[k])) {
                obj[k].push(v)
              } else {
                obj[k] = [obj[k], v]
              }
            }

            return obj
          }

          /***/
        },

      /***/ './node_modules/querystring/encode.js':
        /*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
        /***/ (module) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var stringifyPrimitive = function (v) {
            switch (typeof v) {
              case 'string':
                return v

              case 'boolean':
                return v ? 'true' : 'false'

              case 'number':
                return isFinite(v) ? v : ''

              default:
                return ''
            }
          }

          module.exports = function (obj, sep, eq, name) {
            sep = sep || '&'
            eq = eq || '='
            if (obj === null) {
              obj = undefined
            }

            if (typeof obj === 'object') {
              return Object.keys(obj)
                .map(function (k) {
                  var ks = encodeURIComponent(stringifyPrimitive(k)) + eq
                  if (Array.isArray(obj[k])) {
                    return obj[k]
                      .map(function (v) {
                        return ks + encodeURIComponent(stringifyPrimitive(v))
                      })
                      .join(sep)
                  } else {
                    return ks + encodeURIComponent(stringifyPrimitive(obj[k]))
                  }
                })
                .join(sep)
            }

            if (!name) return ''
            return (
              encodeURIComponent(stringifyPrimitive(name)) +
              eq +
              encodeURIComponent(stringifyPrimitive(obj))
            )
          }

          /***/
        },

      /***/ './node_modules/querystring/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_269223__) => {
          'use strict'

          exports.decode = exports.parse = __nested_webpack_require_269223__(
            /*! ./decode */ './node_modules/querystring/decode.js'
          )
          exports.encode = exports.stringify = __nested_webpack_require_269223__(
            /*! ./encode */ './node_modules/querystring/encode.js'
          )

          /***/
        },

      /***/ './src/album/getAlbum.ts':
        /*!*******************************!*\
  !*** ./src/album/getAlbum.ts ***!
  \*******************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_269798__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getAlbum = void 0
          const endpoints_1 = __nested_webpack_require_269798__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_269798__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function getAlbum(client, albumHash) {
            const url = `${endpoints_1.ALBUM_ENDPOINT}/${albumHash}`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url })
            )
          }
          exports.getAlbum = getAlbum

          /***/
        },

      /***/ './src/album/index.ts':
        /*!****************************!*\
  !*** ./src/album/index.ts ***!
  \****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_270719__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          const tslib_1 = __nested_webpack_require_270719__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          tslib_1.__exportStar(
            __nested_webpack_require_270719__(/*! ./getAlbum */ './src/album/getAlbum.ts'),
            exports
          )

          /***/
        },

      /***/ './src/client.ts':
        /*!***********************!*\
  !*** ./src/client.ts ***!
  \***********************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_271306__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ImgurClient = void 0
          const tslib_1 = __nested_webpack_require_271306__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          const events_1 = __nested_webpack_require_271306__(
            /*! events */ './node_modules/events/events.js'
          )
          const getAuthorizationHeader_1 = __nested_webpack_require_271306__(
            /*! ./getAuthorizationHeader */ './src/getAuthorizationHeader.ts'
          )
          const image_1 = __nested_webpack_require_271306__(
            /*! ./image */ './src/image/index.ts'
          )
          const gallery_1 = __nested_webpack_require_271306__(
            /*! ./gallery */ './src/gallery/index.ts'
          )
          const album_1 = __nested_webpack_require_271306__(
            /*! ./album */ './src/album/index.ts'
          )
          const endpoints_1 = __nested_webpack_require_271306__(
            /*! ./common/endpoints */ './src/common/endpoints.ts'
          )
          const USERAGENT =
            'imgur/next (https://github.com/kaimallea/node-imgur)'
          const axios_1 = tslib_1.__importDefault(
            __nested_webpack_require_271306__(/*! axios */ './node_modules/axios/index.js')
          )
          class ImgurClient extends events_1.EventEmitter {
            constructor(credentials) {
              super()
              this.credentials = credentials
              this.plainFetcher = axios_1.default.create({
                baseURL: endpoints_1.IMGUR_API_PREFIX,
                headers: {
                  'user-agent': USERAGENT,
                },
                responseType: 'json',
              })
              this.fetcher = axios_1.default.create({
                baseURL: endpoints_1.IMGUR_API_PREFIX,
                headers: {
                  'user-agent': USERAGENT,
                },
                responseType: 'json',
              })
              this.fetcher.interceptors.request.use(
                async (config) => {
                  config.headers = config.headers ? config.headers : {}
                  config.headers.authorization = await getAuthorizationHeader_1.getAuthorizationHeader(
                    this
                  )
                  return config
                },
                (e) => Promise.reject(e)
              )
            }
            plainRequest(options) {
              return this.plainFetcher(options)
            }
            request(options = {}) {
              return this.fetcher(options)
            }
            deleteImage(imageHash) {
              return image_1.deleteImage(this, imageHash)
            }
            favoriteImage(imageHash) {
              return image_1.favoriteImage(this, imageHash)
            }
            getAlbum(albumHash) {
              return album_1.getAlbum(this, albumHash)
            }
            getGallery(options) {
              return gallery_1.getGallery(this, options)
            }
            getSubredditGallery(options) {
              return gallery_1.getSubredditGallery(this, options)
            }
            searchGallery(options) {
              return gallery_1.searchGallery(this, options)
            }
            getImage(imageHash) {
              return image_1.getImage(this, imageHash)
            }
            updateImage(payload) {
              return image_1.updateImage(this, payload)
            }
            upload(payload) {
              return image_1.upload(this, payload)
            }
          }
          exports.ImgurClient = ImgurClient

          /***/
        },

      /***/ './src/common/endpoints.ts':
        /*!*********************************!*\
  !*** ./src/common/endpoints.ts ***!
  \*********************************/
        /***/ (__unused_webpack_module, exports) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.SEARCH_GALLERY_ENDPOINT = exports.SUBREDDIT_GALLERY_ENDPOINT = exports.GALLERY_ENDPOINT = exports.UPLOAD_ENDPOINT = exports.IMAGE_ENDPOINT = exports.ALBUM_ENDPOINT = exports.AUTHORIZE_ENDPOINT = exports.API_VERSION = exports.IMGUR_API_PREFIX = void 0
          exports.IMGUR_API_PREFIX = 'https://api.imgur.com'
          exports.API_VERSION = '3'
          exports.AUTHORIZE_ENDPOINT = 'oauth2/authorize'
          exports.ALBUM_ENDPOINT = `${exports.API_VERSION}/album`
          exports.IMAGE_ENDPOINT = `${exports.API_VERSION}/image`
          exports.UPLOAD_ENDPOINT = `${exports.API_VERSION}/upload`
          exports.GALLERY_ENDPOINT = `${exports.API_VERSION}/gallery`
          exports.SUBREDDIT_GALLERY_ENDPOINT = `${exports.API_VERSION}/gallery/r`
          exports.SEARCH_GALLERY_ENDPOINT = `${exports.API_VERSION}/gallery/search`

          /***/
        },

      /***/ './src/common/types.ts':
        /*!*****************************!*\
  !*** ./src/common/types.ts ***!
  \*****************************/
        /***/ (__unused_webpack_module, exports) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.isLogin = exports.isClientId = exports.isAccessToken = void 0
          function isAccessToken(arg) {
            return arg.accessToken !== undefined
          }
          exports.isAccessToken = isAccessToken
          function isClientId(arg) {
            return arg.clientId !== undefined
          }
          exports.isClientId = isClientId
          function isLogin(arg) {
            return (
              arg.clientId !== undefined &&
              arg.username !== undefined &&
              arg.password !== undefined
            )
          }
          exports.isLogin = isLogin

          /***/
        },

      /***/ './src/common/utils.ts':
        /*!*****************************!*\
  !*** ./src/common/utils.ts ***!
  \*****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_277253__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getImgurApiResponseFromResponse = exports.createForm = exports.getSource = exports.isStream = exports.isImageUrl = exports.isBase64 = void 0
          const tslib_1 = __nested_webpack_require_277253__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          const form_data_1 = tslib_1.__importDefault(
            __nested_webpack_require_277253__(
              /*! form-data */ './node_modules/form-data/lib/browser.js'
            )
          )
          function isBase64(payload) {
            if (typeof payload === 'string') {
              return false
            }
            return (
              typeof payload.base64 !== 'undefined' && payload.type === 'base64'
            )
          }
          exports.isBase64 = isBase64
          function isImageUrl(payload) {
            if (typeof payload === 'string') {
              return true
            }
            return (
              typeof payload.image !== 'undefined' && payload.type === 'url'
            )
          }
          exports.isImageUrl = isImageUrl
          function isStream(payload) {
            if (typeof payload === 'string') {
              return false
            }
            return typeof payload.stream !== 'undefined'
          }
          exports.isStream = isStream
          // TODO: Refactor this to be a unique name of some kind (a hash?)
          function getSource(payload) {
            if (typeof payload === 'string') {
              return payload
            }
            if (isBase64(payload)) {
              return 'payload.base64'
            } else if (isStream(payload)) {
              return 'payload.stream'
            } else {
              return payload.image
            }
          }
          exports.getSource = getSource
          function createForm(payload) {
            const form = new form_data_1.default()
            if (typeof payload === 'string') {
              form.append('image', payload)
              return form
            }
            for (const [key, value] of Object.entries(payload)) {
              const supportedUploadObjectTypes = ['base64', 'stream']
              if (supportedUploadObjectTypes.indexOf(key) !== -1) {
                if (supportedUploadObjectTypes.indexOf(payload.type) !== -1) {
                  form.append(key, payload)
                }
              } else {
                form.append(key, value)
              }
            }
            return form
          }
          exports.createForm = createForm
          function getImgurApiResponseFromResponse(response) {
            var _a, _b
            if (
              typeof ((_a = response.data) === null || _a === void 0
                ? void 0
                : _a.status) !== 'undefined' &&
              typeof ((_b = response.data) === null || _b === void 0
                ? void 0
                : _b.success) !== 'undefined'
            ) {
              return response.data
            }
            return {
              data: response.data,
              status: response.status,
              // TODO: determine the success of the call?
              success: true,
            }
          }
          exports.getImgurApiResponseFromResponse = getImgurApiResponseFromResponse

          /***/
        },

      /***/ './src/gallery/getGallery.ts':
        /*!***********************************!*\
  !*** ./src/gallery/getGallery.ts ***!
  \***********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_280879__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getGallery = exports.constructGalleryUrl = void 0
          const endpoints_1 = __nested_webpack_require_280879__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const url_1 = __nested_webpack_require_280879__(
            /*! url */ './node_modules/url/url.js'
          )
          const utils_1 = __nested_webpack_require_280879__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          const defaultOptions = {
            section: 'hot',
            sort: 'viral',
          }
          function constructGalleryUrl(options) {
            const mergedOptions = Object.assign({}, defaultOptions, options)
            let uri = `${mergedOptions.section}`
            if (mergedOptions.sort) {
              uri += `/${mergedOptions.sort}`
            }
            if (mergedOptions.section === 'top' && mergedOptions.window) {
              uri += `/${mergedOptions.window}`
            }
            if (mergedOptions.page) {
              uri += `/${mergedOptions.page}`
            }
            const url = new url_1.URL(
              `${endpoints_1.IMGUR_API_PREFIX}/${endpoints_1.GALLERY_ENDPOINT}/${uri}`
            )
            if (mergedOptions.showViral !== undefined) {
              url.searchParams.append(
                'showViral',
                mergedOptions.showViral.toString()
              )
            }
            if (mergedOptions.mature !== undefined) {
              url.searchParams.append('mature', mergedOptions.mature.toString())
            }
            if (mergedOptions.album_previews !== undefined) {
              url.searchParams.append(
                'album_previews',
                mergedOptions.album_previews.toString()
              )
            }
            return url
          }
          exports.constructGalleryUrl = constructGalleryUrl
          async function getGallery(client, options = defaultOptions) {
            const { pathname } = constructGalleryUrl(options)
            // since we're using prefixUrl with got, we have to remove the starting slash or it'll throw
            const finalPathname = pathname.slice(1)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url: finalPathname })
            )
          }
          exports.getGallery = getGallery

          /***/
        },

      /***/ './src/gallery/getSubredditGallery.ts':
        /*!********************************************!*\
  !*** ./src/gallery/getSubredditGallery.ts ***!
  \********************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_283612__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getSubredditGallery = exports.constructSubredditGalleryUrl = void 0
          const endpoints_1 = __nested_webpack_require_283612__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const url_1 = __nested_webpack_require_283612__(
            /*! url */ './node_modules/url/url.js'
          )
          const utils_1 = __nested_webpack_require_283612__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          function constructSubredditGalleryUrl(options) {
            let uri = `${options.subreddit}`
            if (options.sort) {
              uri += `/${options.sort}`
            }
            if (options.sort === 'top' && options.window) {
              uri += `/${options.window}`
            }
            if (options.page) {
              uri += `/${options.page}`
            }
            const url = new url_1.URL(
              `${endpoints_1.IMGUR_API_PREFIX}/${endpoints_1.SUBREDDIT_GALLERY_ENDPOINT}/${uri}`
            )
            return url
          }
          exports.constructSubredditGalleryUrl = constructSubredditGalleryUrl
          async function getSubredditGallery(client, options) {
            const { pathname } = constructSubredditGalleryUrl(options)
            // since we're using prefixUrl with got, we have to remove the starting slash or it'll throw
            const finalPathname = pathname.slice(1)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url: finalPathname })
            )
          }
          exports.getSubredditGallery = getSubredditGallery

          /***/
        },

      /***/ './src/gallery/index.ts':
        /*!******************************!*\
  !*** ./src/gallery/index.ts ***!
  \******************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_285559__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          const tslib_1 = __nested_webpack_require_285559__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          tslib_1.__exportStar(
            __nested_webpack_require_285559__(
              /*! ./getGallery */ './src/gallery/getGallery.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_285559__(
              /*! ./getSubredditGallery */ './src/gallery/getSubredditGallery.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_285559__(
              /*! ./searchGallery */ './src/gallery/searchGallery.ts'
            ),
            exports
          )

          /***/
        },

      /***/ './src/gallery/searchGallery.ts':
        /*!**************************************!*\
  !*** ./src/gallery/searchGallery.ts ***!
  \**************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_286616__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.searchGallery = exports.constructSearchGalleryUrl = void 0
          const endpoints_1 = __nested_webpack_require_286616__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_286616__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          const url_1 = __nested_webpack_require_286616__(
            /*! url */ './node_modules/url/url.js'
          )
          const advancedParameters = [
            'q_all',
            'q_any',
            'q_exactly',
            'q_not',
            'q_type',
            'q_size_px',
          ]
          function constructSearchGalleryUrl(options) {
            let uri = ''
            if (options.sort) {
              uri += `/${options.sort}`
            }
            if (options.sort === 'top' && options.window) {
              uri += `/${options.window}`
            }
            if (options.page) {
              uri += `/${options.page}`
            }
            const url = new url_1.URL(
              `${endpoints_1.IMGUR_API_PREFIX}/${endpoints_1.SEARCH_GALLERY_ENDPOINT}${uri}`
            )
            advancedParameters.forEach((param) => {
              var _a
              if (
                (_a = options[param]) === null || _a === void 0
                  ? void 0
                  : _a.length
              ) {
                url.searchParams.append(param, options[param])
              }
            })
            if (!url.search) {
              const query = options.q || options.query
              if (!query) {
                throw new Error('No query was provided')
              }
              url.searchParams.append('q', query)
            }
            return url
          }
          exports.constructSearchGalleryUrl = constructSearchGalleryUrl
          async function searchGallery(client, options) {
            const { pathname } = constructSearchGalleryUrl(options)
            // since we're using prefixUrl with got, we have to remove the starting slash or it'll throw
            const finalPathname = pathname.slice(1)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url: finalPathname })
            )
          }
          exports.searchGallery = searchGallery

          /***/
        },

      /***/ './src/getAuthorizationHeader.ts':
        /*!***************************************!*\
  !*** ./src/getAuthorizationHeader.ts ***!
  \***************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_289298__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getAuthorizationHeader = void 0
          const types_1 = __nested_webpack_require_289298__(
            /*! ./common/types */ './src/common/types.ts'
          )
          const endpoints_1 = __nested_webpack_require_289298__(
            /*! ./common/endpoints */ './src/common/endpoints.ts'
          )
          async function getAuthorizationHeader(client) {
            if (types_1.isAccessToken(client.credentials)) {
              return `Bearer ${client.credentials.accessToken}`
            }
            if (
              types_1.isClientId(client.credentials) &&
              !types_1.isLogin(client.credentials)
            ) {
              return `Client-ID ${client.credentials.clientId}`
            }
            const { clientId, username, password } = client.credentials
            const options = {
              url: endpoints_1.AUTHORIZE_ENDPOINT,
              baseURL: endpoints_1.IMGUR_API_PREFIX,
              params: {
                client_id: clientId,
                response_type: 'token',
              },
            }
            let response = await client.plainRequest(options)
            const cookies = Array.isArray(response.headers['set-cookie'])
              ? response.headers['set-cookie'][0]
              : response.headers['set-cookie']
            if (!cookies) {
              throw new Error('No cookies were set during authorization')
            }
            const matches = cookies.match('(^|;)[s]*authorize_token=([^;]*)')
            if (!matches || matches.length < 3) {
              throw new Error('Unable to find authorize_token cookie')
            }
            const authorizeToken = matches[2]
            options.method = 'POST'
            options.data = {
              username,
              password,
              allow: authorizeToken,
            }
            options.followRedirect = false
            options.headers = {
              cookie: `authorize_token=${authorizeToken}`,
            }
            response = await client.plainRequest(options)
            const location = response.headers.location
            if (!location) {
              throw new Error('Unable to parse location')
            }
            const token = JSON.parse(
              '{"' +
                decodeURI(location.slice(location.indexOf('#') + 1))
                  .replace(/"/g, '\\"')
                  .replace(/&/g, '","')
                  .replace(/=/g, '":"') +
                '"}'
            )
            const accessToken = token.access_token
            client.credentials.accessToken = accessToken
            return `Bearer ${accessToken}`
          }
          exports.getAuthorizationHeader = getAuthorizationHeader

          /***/
        },

      /***/ './src/image/deleteImage.ts':
        /*!**********************************!*\
  !*** ./src/image/deleteImage.ts ***!
  \**********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_292364__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.deleteImage = void 0
          const endpoints_1 = __nested_webpack_require_292364__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_292364__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function deleteImage(client, imageHash) {
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${imageHash}`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url, method: 'DELETE' })
            )
          }
          exports.deleteImage = deleteImage

          /***/
        },

      /***/ './src/image/favoriteImage.ts':
        /*!************************************!*\
  !*** ./src/image/favoriteImage.ts ***!
  \************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_293347__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.favoriteImage = void 0
          const endpoints_1 = __nested_webpack_require_293347__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_293347__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function favoriteImage(client, imageHash) {
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${imageHash}/favorite`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url, method: 'POST' })
            )
          }
          exports.favoriteImage = favoriteImage

          /***/
        },

      /***/ './src/image/getImage.ts':
        /*!*******************************!*\
  !*** ./src/image/getImage.ts ***!
  \*******************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_294325__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getImage = void 0
          const endpoints_1 = __nested_webpack_require_294325__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_294325__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function getImage(client, imageHash) {
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${imageHash}`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url })
            )
          }
          exports.getImage = getImage

          /***/
        },

      /***/ './src/image/index.ts':
        /*!****************************!*\
  !*** ./src/image/index.ts ***!
  \****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_295246__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          const tslib_1 = __nested_webpack_require_295246__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(
              /*! ./deleteImage */ './src/image/deleteImage.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(
              /*! ./favoriteImage */ './src/image/favoriteImage.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(/*! ./getImage */ './src/image/getImage.ts'),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(
              /*! ./updateImage */ './src/image/updateImage.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(/*! ./upload */ './src/image/upload.ts'),
            exports
          )

          /***/
        },

      /***/ './src/image/updateImage.ts':
        /*!**********************************!*\
  !*** ./src/image/updateImage.ts ***!
  \**********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_296547__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.updateImage = void 0
          const endpoints_1 = __nested_webpack_require_296547__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_296547__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          function isValidUpdatePayload(p) {
            return (
              typeof p.title === 'string' || typeof p.description === 'string'
            )
          }
          async function updateImage(client, payload) {
            if (Array.isArray(payload)) {
              const promises = payload.map((p) => {
                if (!isValidUpdatePayload(p)) {
                  throw new Error('Update requires a title and/or description')
                }
                const url = `${endpoints_1.IMAGE_ENDPOINT}/${p.imageHash}`
                const form = utils_1.createForm(p)
                /* eslint no-async-promise-executor: 0 */
                return new Promise(async function (resolve) {
                  return resolve(
                    utils_1.getImgurApiResponseFromResponse(
                      await client.request({
                        url,
                        method: 'POST',
                        data: form,
                        // resolveBodyOnly: true,
                      })
                    )
                  )
                })
              })
              return await Promise.all(promises)
            }
            if (!isValidUpdatePayload(payload)) {
              throw new Error('Update requires a title and/or description')
            }
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${payload.imageHash}`
            const form = utils_1.createForm(payload)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({
                url,
                method: 'POST',
                data: form,
                // resolveBodyOnly: true,
              })
            )
          }
          exports.updateImage = updateImage

          /***/
        },

      /***/ './src/image/upload.ts':
        /*!*****************************!*\
  !*** ./src/image/upload.ts ***!
  \*****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_298934__) => {
          'use strict'
          /* provided dependency */ var console = __nested_webpack_require_298934__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.upload = void 0
          const utils_1 = __nested_webpack_require_298934__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          const endpoints_1 = __nested_webpack_require_298934__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          async function upload(client, payload) {
            if (Array.isArray(payload)) {
              const promises = payload.map((p) => {
                const form = utils_1.createForm(p)
                /* eslint no-async-promise-executor: 0 */
                return new Promise(async (resolve) => {
                  resolve(
                    utils_1.getImgurApiResponseFromResponse(
                      await client.request({
                        url: endpoints_1.UPLOAD_ENDPOINT,
                        method: 'POST',
                        data: form,
                        onUploadProgress: (progressEvent) => {
                          console.log({ progressEvent })
                          client.emit('uploadProgress', { ...progressEvent })
                        },
                      })
                    )
                  )
                })
              })
              return await Promise.all(promises)
            }
            const form = utils_1.createForm(payload)
            // const id = Date.now.toString();
            const request = await client.request({
              url: endpoints_1.UPLOAD_ENDPOINT,
              method: 'POST',
              data: form,
              onUploadProgress: (progressEvent) => {
                console.log({ progressEvent })
                client.emit('uploadProgress', { ...progressEvent })
              },
            })
            return Promise.resolve(
              utils_1.getImgurApiResponseFromResponse(request)
            )
          }
          exports.upload = upload

          /***/
        },

      /***/ './node_modules/tslib/tslib.es6.js':
        /*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
        /***/ (
          __unused_webpack_module,
          __webpack_exports__,
          __nested_webpack_require_301404__
        ) => {
          'use strict'
          __nested_webpack_require_301404__.r(__webpack_exports__)
          /* harmony export */ __nested_webpack_require_301404__.d(__webpack_exports__, {
            /* harmony export */ __extends: () => /* binding */ __extends,
            /* harmony export */ __assign: () => /* binding */ __assign,
            /* harmony export */ __rest: () => /* binding */ __rest,
            /* harmony export */ __decorate: () => /* binding */ __decorate,
            /* harmony export */ __param: () => /* binding */ __param,
            /* harmony export */ __metadata: () => /* binding */ __metadata,
            /* harmony export */ __awaiter: () => /* binding */ __awaiter,
            /* harmony export */ __generator: () => /* binding */ __generator,
            /* harmony export */ __createBinding: () =>
              /* binding */ __createBinding,
            /* harmony export */ __exportStar: () => /* binding */ __exportStar,
            /* harmony export */ __values: () => /* binding */ __values,
            /* harmony export */ __read: () => /* binding */ __read,
            /* harmony export */ __spread: () => /* binding */ __spread,
            /* harmony export */ __spreadArrays: () =>
              /* binding */ __spreadArrays,
            /* harmony export */ __await: () => /* binding */ __await,
            /* harmony export */ __asyncGenerator: () =>
              /* binding */ __asyncGenerator,
            /* harmony export */ __asyncDelegator: () =>
              /* binding */ __asyncDelegator,
            /* harmony export */ __asyncValues: () =>
              /* binding */ __asyncValues,
            /* harmony export */ __makeTemplateObject: () =>
              /* binding */ __makeTemplateObject,
            /* harmony export */ __importStar: () => /* binding */ __importStar,
            /* harmony export */ __importDefault: () =>
              /* binding */ __importDefault,
            /* harmony export */ __classPrivateFieldGet: () =>
              /* binding */ __classPrivateFieldGet,
            /* harmony export */ __classPrivateFieldSet: () =>
              /* binding */ __classPrivateFieldSet,
            /* harmony export */
          })
          /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
          /* global Reflect, Promise */

          var extendStatics = function (d, b) {
            extendStatics =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (d, b) {
                  d.__proto__ = b
                }) ||
              function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
              }
            return extendStatics(d, b)
          }

          function __extends(d, b) {
            extendStatics(d, b)
            function __() {
              this.constructor = d
            }
            d.prototype =
              b === null
                ? Object.create(b)
                : ((__.prototype = b.prototype), new __())
          }

          var __assign = function () {
            __assign =
              Object.assign ||
              function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i]
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
              }
            return __assign.apply(this, arguments)
          }

          function __rest(s, e) {
            var t = {}
            for (var p in s)
              if (
                Object.prototype.hasOwnProperty.call(s, p) &&
                e.indexOf(p) < 0
              )
                t[p] = s[p]
            if (s != null && typeof Object.getOwnPropertySymbols === 'function')
              for (
                var i = 0, p = Object.getOwnPropertySymbols(s);
                i < p.length;
                i++
              ) {
                if (
                  e.indexOf(p[i]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(s, p[i])
                )
                  t[p[i]] = s[p[i]]
              }
            return t
          }

          function __decorate(decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d
            if (
              typeof Reflect === 'object' &&
              typeof Reflect.decorate === 'function'
            )
              r = Reflect.decorate(decorators, target, key, desc)
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r
            return c > 3 && r && Object.defineProperty(target, key, r), r
          }

          function __param(paramIndex, decorator) {
            return function (target, key) {
              decorator(target, key, paramIndex)
            }
          }

          function __metadata(metadataKey, metadataValue) {
            if (
              typeof Reflect === 'object' &&
              typeof Reflect.metadata === 'function'
            )
              return Reflect.metadata(metadataKey, metadataValue)
          }

          function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P
                ? value
                : new P(function (resolve) {
                    resolve(value)
                  })
            }
            return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value))
                } catch (e) {
                  reject(e)
                }
              }
              function rejected(value) {
                try {
                  step(generator['throw'](value))
                } catch (e) {
                  reject(e)
                }
              }
              function step(result) {
                result.done
                  ? resolve(result.value)
                  : adopt(result.value).then(fulfilled, rejected)
              }
              step(
                (generator = generator.apply(thisArg, _arguments || [])).next()
              )
            })
          }

          function __generator(thisArg, body) {
            var _ = {
                label: 0,
                sent: function () {
                  if (t[0] & 1) throw t[1]
                  return t[1]
                },
                trys: [],
                ops: [],
              },
              f,
              y,
              t,
              g
            return (
              (g = { next: verb(0), throw: verb(1), return: verb(2) }),
              typeof Symbol === 'function' &&
                (g[Symbol.iterator] = function () {
                  return this
                }),
              g
            )
            function verb(n) {
              return function (v) {
                return step([n, v])
              }
            }
            function step(op) {
              if (f) throw new TypeError('Generator is already executing.')
              while (_)
                try {
                  if (
                    ((f = 1),
                    y &&
                      (t =
                        op[0] & 2
                          ? y['return']
                          : op[0]
                          ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                          : y.next) &&
                      !(t = t.call(y, op[1])).done)
                  )
                    return t
                  if (((y = 0), t)) op = [op[0] & 2, t.value]
                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op
                      break
                    case 4:
                      _.label++
                      return { value: op[1], done: false }
                    case 5:
                      _.label++
                      y = op[1]
                      op = [0]
                      continue
                    case 7:
                      op = _.ops.pop()
                      _.trys.pop()
                      continue
                    default:
                      if (
                        !((t = _.trys),
                        (t = t.length > 0 && t[t.length - 1])) &&
                        (op[0] === 6 || op[0] === 2)
                      ) {
                        _ = 0
                        continue
                      }
                      if (
                        op[0] === 3 &&
                        (!t || (op[1] > t[0] && op[1] < t[3]))
                      ) {
                        _.label = op[1]
                        break
                      }
                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1]
                        t = op
                        break
                      }
                      if (t && _.label < t[2]) {
                        _.label = t[2]
                        _.ops.push(op)
                        break
                      }
                      if (t[2]) _.ops.pop()
                      _.trys.pop()
                      continue
                  }
                  op = body.call(thisArg, _)
                } catch (e) {
                  op = [6, e]
                  y = 0
                } finally {
                  f = t = 0
                }
              if (op[0] & 5) throw op[1]
              return { value: op[0] ? op[1] : void 0, done: true }
            }
          }

          function __createBinding(o, m, k, k2) {
            if (k2 === undefined) k2 = k
            o[k2] = m[k]
          }

          function __exportStar(m, exports) {
            for (var p in m)
              if (p !== 'default' && !exports.hasOwnProperty(p))
                exports[p] = m[p]
          }

          function __values(o) {
            var s = typeof Symbol === 'function' && Symbol.iterator,
              m = s && o[s],
              i = 0
            if (m) return m.call(o)
            if (o && typeof o.length === 'number')
              return {
                next: function () {
                  if (o && i >= o.length) o = void 0
                  return { value: o && o[i++], done: !o }
                },
              }
            throw new TypeError(
              s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.'
            )
          }

          function __read(o, n) {
            var m = typeof Symbol === 'function' && o[Symbol.iterator]
            if (!m) return o
            var i = m.call(o),
              r,
              ar = [],
              e
            try {
              while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value)
            } catch (error) {
              e = { error: error }
            } finally {
              try {
                if (r && !r.done && (m = i['return'])) m.call(i)
              } finally {
                if (e) throw e.error
              }
            }
            return ar
          }

          function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++)
              ar = ar.concat(__read(arguments[i]))
            return ar
          }

          function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++)
              s += arguments[i].length
            for (var r = Array(s), k = 0, i = 0; i < il; i++)
              for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j]
            return r
          }

          function __await(v) {
            return this instanceof __await
              ? ((this.v = v), this)
              : new __await(v)
          }

          function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator)
              throw new TypeError('Symbol.asyncIterator is not defined.')
            var g = generator.apply(thisArg, _arguments || []),
              i,
              q = []
            return (
              (i = {}),
              verb('next'),
              verb('throw'),
              verb('return'),
              (i[Symbol.asyncIterator] = function () {
                return this
              }),
              i
            )
            function verb(n) {
              if (g[n])
                i[n] = function (v) {
                  return new Promise(function (a, b) {
                    q.push([n, v, a, b]) > 1 || resume(n, v)
                  })
                }
            }
            function resume(n, v) {
              try {
                step(g[n](v))
              } catch (e) {
                settle(q[0][3], e)
              }
            }
            function step(r) {
              r.value instanceof __await
                ? Promise.resolve(r.value.v).then(fulfill, reject)
                : settle(q[0][2], r)
            }
            function fulfill(value) {
              resume('next', value)
            }
            function reject(value) {
              resume('throw', value)
            }
            function settle(f, v) {
              if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1])
            }
          }

          function __asyncDelegator(o) {
            var i, p
            return (
              (i = {}),
              verb('next'),
              verb('throw', function (e) {
                throw e
              }),
              verb('return'),
              (i[Symbol.iterator] = function () {
                return this
              }),
              i
            )
            function verb(n, f) {
              i[n] = o[n]
                ? function (v) {
                    return (p = !p)
                      ? { value: __await(o[n](v)), done: n === 'return' }
                      : f
                      ? f(v)
                      : v
                  }
                : f
            }
          }

          function __asyncValues(o) {
            if (!Symbol.asyncIterator)
              throw new TypeError('Symbol.asyncIterator is not defined.')
            var m = o[Symbol.asyncIterator],
              i
            return m
              ? m.call(o)
              : ((o =
                  typeof __values === 'function'
                    ? __values(o)
                    : o[Symbol.iterator]()),
                (i = {}),
                verb('next'),
                verb('throw'),
                verb('return'),
                (i[Symbol.asyncIterator] = function () {
                  return this
                }),
                i)
            function verb(n) {
              i[n] =
                o[n] &&
                function (v) {
                  return new Promise(function (resolve, reject) {
                    ;(v = o[n](v)), settle(resolve, reject, v.done, v.value)
                  })
                }
            }
            function settle(resolve, reject, d, v) {
              Promise.resolve(v).then(function (v) {
                resolve({ value: v, done: d })
              }, reject)
            }
          }

          function __makeTemplateObject(cooked, raw) {
            if (Object.defineProperty) {
              Object.defineProperty(cooked, 'raw', { value: raw })
            } else {
              cooked.raw = raw
            }
            return cooked
          }

          function __importStar(mod) {
            if (mod && mod.__esModule) return mod
            var result = {}
            if (mod != null)
              for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k]
            result.default = mod
            return result
          }

          function __importDefault(mod) {
            return mod && mod.__esModule ? mod : { default: mod }
          }

          function __classPrivateFieldGet(receiver, privateMap) {
            if (!privateMap.has(receiver)) {
              throw new TypeError(
                'attempted to get private field on non-instance'
              )
            }
            return privateMap.get(receiver)
          }

          function __classPrivateFieldSet(receiver, privateMap, value) {
            if (!privateMap.has(receiver)) {
              throw new TypeError(
                'attempted to set private field on non-instance'
              )
            }
            privateMap.set(receiver, value)
            return value
          }

          /***/
        },

      /***/ './node_modules/url/node_modules/punycode/punycode.js':
        /*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
        /***/ function (module, exports, __nested_webpack_require_319528__) {
          /* module decorator */ module = __nested_webpack_require_319528__.nmd(module)
          var __WEBPACK_AMD_DEFINE_RESULT__ /*! https://mths.be/punycode v1.3.2 by @mathias */
          ;(function (root) {
            /** Detect free variables */
            var freeExports =  true && exports && !exports.nodeType && exports
            var freeModule =  true && module && !module.nodeType && module
            var freeGlobal =
              typeof __nested_webpack_require_319528__.g == 'object' && __nested_webpack_require_319528__.g
            if (
              freeGlobal.global === freeGlobal ||
              freeGlobal.window === freeGlobal ||
              freeGlobal.self === freeGlobal
            ) {
              root = freeGlobal
            }

            /**
             * The `punycode` object.
             * @name punycode
             * @type Object
             */
            var punycode,
              /** Highest positive signed 32-bit float value */
              maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
              /** Bootstring parameters */
              base = 36,
              tMin = 1,
              tMax = 26,
              skew = 38,
              damp = 700,
              initialBias = 72,
              initialN = 128, // 0x80
              delimiter = '-', // '\x2D'
              /** Regular expressions */
              regexPunycode = /^xn--/,
              regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
              regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
              /** Error messages */
              errors = {
                overflow: 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input',
              },
              /** Convenience shortcuts */
              baseMinusTMin = base - tMin,
              floor = Math.floor,
              stringFromCharCode = String.fromCharCode,
              /** Temporary variable */
              key

            /*--------------------------------------------------------------------------*/

            /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */
            function error(type) {
              throw RangeError(errors[type])
            }

            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */
            function map(array, fn) {
              var length = array.length
              var result = []
              while (length--) {
                result[length] = fn(array[length])
              }
              return result
            }

            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */
            function mapDomain(string, fn) {
              var parts = string.split('@')
              var result = ''
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@'
                string = parts[1]
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '\x2E')
              var labels = string.split('.')
              var encoded = map(labels, fn).join('.')
              return result + encoded
            }

            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */
            function ucs2decode(string) {
              var output = [],
                counter = 0,
                length = string.length,
                value,
                extra
              while (counter < length) {
                value = string.charCodeAt(counter++)
                if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++)
                  if ((extra & 0xfc00) == 0xdc00) {
                    // low surrogate
                    output.push(
                      ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                    )
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value)
                    counter--
                  }
                } else {
                  output.push(value)
                }
              }
              return output
            }

            /**
             * Creates a string based on an array of numeric code points.
             * @see `punycode.ucs2.decode`
             * @memberOf punycode.ucs2
             * @name encode
             * @param {Array} codePoints The array of numeric code points.
             * @returns {String} The new Unicode string (UCS-2).
             */
            function ucs2encode(array) {
              return map(array, function (value) {
                var output = ''
                if (value > 0xffff) {
                  value -= 0x10000
                  output += stringFromCharCode(
                    ((value >>> 10) & 0x3ff) | 0xd800
                  )
                  value = 0xdc00 | (value & 0x3ff)
                }
                output += stringFromCharCode(value)
                return output
              }).join('')
            }

            /**
             * Converts a basic code point into a digit/integer.
             * @see `digitToBasic()`
             * @private
             * @param {Number} codePoint The basic numeric code point value.
             * @returns {Number} The numeric value of a basic code point (for use in
             * representing integers) in the range `0` to `base - 1`, or `base` if
             * the code point does not represent a value.
             */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97
              }
              return base
            }

            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
            }

            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * http://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */
            function adapt(delta, numPoints, firstTime) {
              var k = 0
              delta = firstTime ? floor(delta / damp) : delta >> 1
              delta += floor(delta / numPoints)
              for (
                ;
                /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
                k += base
              ) {
                delta = floor(delta / baseMinusTMin)
              }
              return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew))
            }

            /**
             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
             * symbols.
             * @memberOf punycode
             * @param {String} input The Punycode string of ASCII-only symbols.
             * @returns {String} The resulting string of Unicode symbols.
             */
            function decode(input) {
              // Don't use UCS-2
              var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,
                /** Cached calculation results */
                baseMinusT

              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.

              basic = input.lastIndexOf(delimiter)
              if (basic < 0) {
                basic = 0
              }

              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                  error('not-basic')
                }
                output.push(input.charCodeAt(j))
              }

              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.

              for (
                index = basic > 0 ? basic + 1 : 0;
                index < inputLength /* no final expression */;

              ) {
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (
                  oldi = i, w = 1, k = base /* no condition */;
                  ;
                  k += base
                ) {
                  if (index >= inputLength) {
                    error('invalid-input')
                  }

                  digit = basicToDigit(input.charCodeAt(index++))

                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow')
                  }

                  i += digit * w
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias

                  if (digit < t) {
                    break
                  }

                  baseMinusT = base - t
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow')
                  }

                  w *= baseMinusT
                }

                out = output.length + 1
                bias = adapt(i - oldi, out, oldi == 0)

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error('overflow')
                }

                n += floor(i / out)
                i %= out

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n)
              }

              return ucs2encode(output)
            }

            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */
            function encode(input) {
              var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne,
                baseMinusT,
                qMinusT

              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input)

              // Cache the length
              inputLength = input.length

              // Initialize the state
              n = initialN
              delta = 0
              bias = initialBias

              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j]
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue))
                }
              }

              handledCPCount = basicLength = output.length

              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.

              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter)
              }

              // Main encoding loop:
              while (handledCPCount < inputLength) {
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j]
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow')
                }

                delta += (m - n) * handledCPCountPlusOne
                n = m

                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j]

                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow')
                  }

                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base /* no condition */; ; k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
                      if (q < t) {
                        break
                      }
                      qMinusT = q - t
                      baseMinusT = base - t
                      output.push(
                        stringFromCharCode(
                          digitToBasic(t + (qMinusT % baseMinusT), 0)
                        )
                      )
                      q = floor(qMinusT / baseMinusT)
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)))
                    bias = adapt(
                      delta,
                      handledCPCountPlusOne,
                      handledCPCount == basicLength
                    )
                    delta = 0
                    ++handledCPCount
                  }
                }

                ++delta
                ++n
              }
              return output.join('')
            }

            /**
             * Converts a Punycode string representing a domain name or an email address
             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
             * it doesn't matter if you call it on a string that has already been
             * converted to Unicode.
             * @memberOf punycode
             * @param {String} input The Punycoded domain name or email address to
             * convert to Unicode.
             * @returns {String} The Unicode representation of the given Punycode
             * string.
             */
            function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string)
                  ? decode(string.slice(4).toLowerCase())
                  : string
              })
            }

            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */
            function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string)
                  ? 'xn--' + encode(string)
                  : string
              })
            }

            /*--------------------------------------------------------------------------*/

            /** Define the public API */
            punycode = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              version: '1.3.2',
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              ucs2: {
                decode: ucs2decode,
                encode: ucs2encode,
              },
              decode: decode,
              encode: encode,
              toASCII: toASCII,
              toUnicode: toUnicode,
            }

            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (true) {
              !((__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                return punycode
              }.call(exports, __nested_webpack_require_319528__, exports, module)),
              __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
            } else {}
          })(this)

          /***/
        },

      /***/ './node_modules/url/url.js':
        /*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_340092__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var punycode = __nested_webpack_require_340092__(
            /*! punycode */ './node_modules/url/node_modules/punycode/punycode.js'
          )
          var util = __nested_webpack_require_340092__(
            /*! ./util */ './node_modules/url/util.js'
          )

          exports.parse = urlParse
          exports.resolve = urlResolve
          exports.resolveObject = urlResolveObject
          exports.format = urlFormat

          exports.Url = Url

          function Url() {
            this.protocol = null
            this.slashes = null
            this.auth = null
            this.host = null
            this.port = null
            this.hostname = null
            this.hash = null
            this.search = null
            this.query = null
            this.pathname = null
            this.path = null
            this.href = null
          }

          // Reference: RFC 3986, RFC 1808, RFC 2396

          // define these here so at least they only have to be
          // compiled once on the first module load.
          var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,
            // Special case for a simple path URL
            simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
            // RFC 2396: characters reserved for delimiting URLs.
            // We actually just auto-escape these.
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
            // RFC 2396: characters not allowed for various reasons.
            unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
            autoEscape = ["'"].concat(unwise),
            // Characters that are never ever allowed in a hostname.
            // Note that any invalid chars are also handled, but these
            // are the ones that are *expected* to be seen, so we fast-path
            // them.
            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
            hostEndingChars = ['/', '?', '#'],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
            // protocols that can allow "unsafe" and "unwise" chars.
            unsafeProtocol = {
              javascript: true,
              'javascript:': true,
            },
            // protocols that never have a hostname.
            hostlessProtocol = {
              javascript: true,
              'javascript:': true,
            },
            // protocols that always contain a // bit.
            slashedProtocol = {
              http: true,
              https: true,
              ftp: true,
              gopher: true,
              file: true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true,
            },
            querystring = __nested_webpack_require_340092__(
              /*! querystring */ './node_modules/querystring/index.js'
            )

          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url) return url

            var u = new Url()
            u.parse(url, parseQueryString, slashesDenoteHost)
            return u
          }

          Url.prototype.parse = function (
            url,
            parseQueryString,
            slashesDenoteHost
          ) {
            if (!util.isString(url)) {
              throw new TypeError(
                "Parameter 'url' must be a string, not " + typeof url
              )
            }

            // Copy chrome, IE, opera backslash-handling behavior.
            // Back slashes before the query string get converted to forward slashes
            // See: https://code.google.com/p/chromium/issues/detail?id=25916
            var queryIndex = url.indexOf('?'),
              splitter =
                queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
              uSplit = url.split(splitter),
              slashRegex = /\\/g
            uSplit[0] = uSplit[0].replace(slashRegex, '/')
            url = uSplit.join(splitter)

            var rest = url

            // trim before proceeding.
            // This is to support parse stuff like "  http://foo.com  \n"
            rest = rest.trim()

            if (!slashesDenoteHost && url.split('#').length === 1) {
              // Try fast path regexp
              var simplePath = simplePathPattern.exec(rest)
              if (simplePath) {
                this.path = rest
                this.href = rest
                this.pathname = simplePath[1]
                if (simplePath[2]) {
                  this.search = simplePath[2]
                  if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1))
                  } else {
                    this.query = this.search.substr(1)
                  }
                } else if (parseQueryString) {
                  this.search = ''
                  this.query = {}
                }
                return this
              }
            }

            var proto = protocolPattern.exec(rest)
            if (proto) {
              proto = proto[0]
              var lowerProto = proto.toLowerCase()
              this.protocol = lowerProto
              rest = rest.substr(proto.length)
            }

            // figure out if it's got a host
            // user@server is *always* interpreted as a hostname, and url
            // resolution will treat //foo/bar as host=foo,path=bar because that's
            // how the browser resolves relative URLs.
            if (
              slashesDenoteHost ||
              proto ||
              rest.match(/^\/\/[^@\/]+@[^@\/]+/)
            ) {
              var slashes = rest.substr(0, 2) === '//'
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2)
                this.slashes = true
              }
            }

            if (
              !hostlessProtocol[proto] &&
              (slashes || (proto && !slashedProtocol[proto]))
            ) {
              // there's a hostname.
              // the first instance of /, ?, ;, or # ends the host.
              //
              // If there is an @ in the hostname, then non-host chars *are* allowed
              // to the left of the last @ sign, unless some host-ending character
              // comes *before* the @-sign.
              // URLs are obnoxious.
              //
              // ex:
              // http://a@b@c/ => user:a@b host:c
              // http://a@b?@c => user:a host:c path:/?@c

              // v0.12 TODO(isaacs): This is not quite how Chrome does things.
              // Review our test case against browsers more comprehensively.

              // find the first instance of any hostEndingChars
              var hostEnd = -1
              for (var i = 0; i < hostEndingChars.length; i++) {
                var hec = rest.indexOf(hostEndingChars[i])
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec
              }

              // at this point, either we have an explicit point where the
              // auth portion cannot go past, or the last @ char is the decider.
              var auth, atSign
              if (hostEnd === -1) {
                // atSign can be anywhere.
                atSign = rest.lastIndexOf('@')
              } else {
                // atSign must be in auth portion.
                // http://a@b/c@d => host:b auth:a path:/c@d
                atSign = rest.lastIndexOf('@', hostEnd)
              }

              // Now we have a portion which is definitely the auth.
              // Pull that off.
              if (atSign !== -1) {
                auth = rest.slice(0, atSign)
                rest = rest.slice(atSign + 1)
                this.auth = decodeURIComponent(auth)
              }

              // the host is the remaining to the left of the first non-host char
              hostEnd = -1
              for (var i = 0; i < nonHostChars.length; i++) {
                var hec = rest.indexOf(nonHostChars[i])
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec
              }
              // if we still have not hit it, then the entire thing is a host.
              if (hostEnd === -1) hostEnd = rest.length

              this.host = rest.slice(0, hostEnd)
              rest = rest.slice(hostEnd)

              // pull out port.
              this.parseHost()

              // we've indicated that there is a hostname,
              // so even if it's empty, it has to be present.
              this.hostname = this.hostname || ''

              // if hostname begins with [ and ends with ]
              // assume that it's an IPv6 address.
              var ipv6Hostname =
                this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']'

              // validate a little.
              if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./)
                for (var i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i]
                  if (!part) continue
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = ''
                    for (var j = 0, k = part.length; j < k; j++) {
                      if (part.charCodeAt(j) > 127) {
                        // we replace non-ASCII char with a temporary placeholder
                        // we need this to make sure size of hostname is not
                        // broken by replacing non-ASCII by nothing
                        newpart += 'x'
                      } else {
                        newpart += part[j]
                      }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i)
                      var notHost = hostparts.slice(i + 1)
                      var bit = part.match(hostnamePartStart)
                      if (bit) {
                        validParts.push(bit[1])
                        notHost.unshift(bit[2])
                      }
                      if (notHost.length) {
                        rest = '/' + notHost.join('.') + rest
                      }
                      this.hostname = validParts.join('.')
                      break
                    }
                  }
                }
              }

              if (this.hostname.length > hostnameMaxLen) {
                this.hostname = ''
              } else {
                // hostnames are always lower case.
                this.hostname = this.hostname.toLowerCase()
              }

              if (!ipv6Hostname) {
                // IDNA Support: Returns a punycoded representation of "domain".
                // It only converts parts of the domain name that
                // have non-ASCII characters, i.e. it doesn't matter if
                // you call it with a domain that already is ASCII-only.
                this.hostname = punycode.toASCII(this.hostname)
              }

              var p = this.port ? ':' + this.port : ''
              var h = this.hostname || ''
              this.host = h + p
              this.href += this.host

              // strip [ and ] from the hostname
              // the host field still retains them, though
              if (ipv6Hostname) {
                this.hostname = this.hostname.substr(
                  1,
                  this.hostname.length - 2
                )
                if (rest[0] !== '/') {
                  rest = '/' + rest
                }
              }
            }

            // now rest is set to the post-host stuff.
            // chop off any delim chars.
            if (!unsafeProtocol[lowerProto]) {
              // First, make 100% sure that any "autoEscape" chars get
              // escaped, even if encodeURIComponent doesn't think they
              // need to be.
              for (var i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i]
                if (rest.indexOf(ae) === -1) continue
                var esc = encodeURIComponent(ae)
                if (esc === ae) {
                  esc = escape(ae)
                }
                rest = rest.split(ae).join(esc)
              }
            }

            // chop off from the tail first.
            var hash = rest.indexOf('#')
            if (hash !== -1) {
              // got a fragment string.
              this.hash = rest.substr(hash)
              rest = rest.slice(0, hash)
            }
            var qm = rest.indexOf('?')
            if (qm !== -1) {
              this.search = rest.substr(qm)
              this.query = rest.substr(qm + 1)
              if (parseQueryString) {
                this.query = querystring.parse(this.query)
              }
              rest = rest.slice(0, qm)
            } else if (parseQueryString) {
              // no query string, but parseQueryString still requested
              this.search = ''
              this.query = {}
            }
            if (rest) this.pathname = rest
            if (
              slashedProtocol[lowerProto] &&
              this.hostname &&
              !this.pathname
            ) {
              this.pathname = '/'
            }

            //to support http.request
            if (this.pathname || this.search) {
              var p = this.pathname || ''
              var s = this.search || ''
              this.path = p + s
            }

            // finally, reconstruct the href based on what has been validated.
            this.href = this.format()
            return this
          }

          // format a parsed object into a url string
          function urlFormat(obj) {
            // ensure it's an object, and not a string url.
            // If it's an obj, this is a no-op.
            // this way, you can call url_format() on strings
            // to clean up potentially wonky urls.
            if (util.isString(obj)) obj = urlParse(obj)
            if (!(obj instanceof Url)) return Url.prototype.format.call(obj)
            return obj.format()
          }

          Url.prototype.format = function () {
            var auth = this.auth || ''
            if (auth) {
              auth = encodeURIComponent(auth)
              auth = auth.replace(/%3A/i, ':')
              auth += '@'
            }

            var protocol = this.protocol || '',
              pathname = this.pathname || '',
              hash = this.hash || '',
              host = false,
              query = ''

            if (this.host) {
              host = auth + this.host
            } else if (this.hostname) {
              host =
                auth +
                (this.hostname.indexOf(':') === -1
                  ? this.hostname
                  : '[' + this.hostname + ']')
              if (this.port) {
                host += ':' + this.port
              }
            }

            if (
              this.query &&
              util.isObject(this.query) &&
              Object.keys(this.query).length
            ) {
              query = querystring.stringify(this.query)
            }

            var search = this.search || (query && '?' + query) || ''

            if (protocol && protocol.substr(-1) !== ':') protocol += ':'

            // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
            // unless they had them to begin with.
            if (
              this.slashes ||
              ((!protocol || slashedProtocol[protocol]) && host !== false)
            ) {
              host = '//' + (host || '')
              if (pathname && pathname.charAt(0) !== '/')
                pathname = '/' + pathname
            } else if (!host) {
              host = ''
            }

            if (hash && hash.charAt(0) !== '#') hash = '#' + hash
            if (search && search.charAt(0) !== '?') search = '?' + search

            pathname = pathname.replace(/[?#]/g, function (match) {
              return encodeURIComponent(match)
            })
            search = search.replace('#', '%23')

            return protocol + host + pathname + search + hash
          }

          function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative)
          }

          Url.prototype.resolve = function (relative) {
            return this.resolveObject(urlParse(relative, false, true)).format()
          }

          function urlResolveObject(source, relative) {
            if (!source) return relative
            return urlParse(source, false, true).resolveObject(relative)
          }

          Url.prototype.resolveObject = function (relative) {
            if (util.isString(relative)) {
              var rel = new Url()
              rel.parse(relative, false, true)
              relative = rel
            }

            var result = new Url()
            var tkeys = Object.keys(this)
            for (var tk = 0; tk < tkeys.length; tk++) {
              var tkey = tkeys[tk]
              result[tkey] = this[tkey]
            }

            // hash is always overridden, no matter what.
            // even href="" will remove it.
            result.hash = relative.hash

            // if the relative url is empty, then there's nothing left to do here.
            if (relative.href === '') {
              result.href = result.format()
              return result
            }

            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative.protocol) {
              // take everything except the protocol from relative
              var rkeys = Object.keys(relative)
              for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk]
                if (rkey !== 'protocol') result[rkey] = relative[rkey]
              }

              //urlParse appends trailing / to urls like http://www.example.com
              if (
                slashedProtocol[result.protocol] &&
                result.hostname &&
                !result.pathname
              ) {
                result.path = result.pathname = '/'
              }

              result.href = result.format()
              return result
            }

            if (relative.protocol && relative.protocol !== result.protocol) {
              // if it's a known url protocol, then changing
              // the protocol does weird things
              // first, if it's not file:, then we MUST have a host,
              // and if there was a path
              // to begin with, then we MUST have a path.
              // if it is file:, then the host is dropped,
              // because that's known to be hostless.
              // anything else is assumed to be absolute.
              if (!slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative)
                for (var v = 0; v < keys.length; v++) {
                  var k = keys[v]
                  result[k] = relative[k]
                }
                result.href = result.format()
                return result
              }

              result.protocol = relative.protocol
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/')
                while (relPath.length && !(relative.host = relPath.shift()));
                if (!relative.host) relative.host = ''
                if (!relative.hostname) relative.hostname = ''
                if (relPath[0] !== '') relPath.unshift('')
                if (relPath.length < 2) relPath.unshift('')
                result.pathname = relPath.join('/')
              } else {
                result.pathname = relative.pathname
              }
              result.search = relative.search
              result.query = relative.query
              result.host = relative.host || ''
              result.auth = relative.auth
              result.hostname = relative.hostname || relative.host
              result.port = relative.port
              // to support http.request
              if (result.pathname || result.search) {
                var p = result.pathname || ''
                var s = result.search || ''
                result.path = p + s
              }
              result.slashes = result.slashes || relative.slashes
              result.href = result.format()
              return result
            }

            var isSourceAbs =
                result.pathname && result.pathname.charAt(0) === '/',
              isRelAbs =
                relative.host ||
                (relative.pathname && relative.pathname.charAt(0) === '/'),
              mustEndAbs =
                isRelAbs || isSourceAbs || (result.host && relative.pathname),
              removeAllDots = mustEndAbs,
              srcPath = (result.pathname && result.pathname.split('/')) || [],
              relPath =
                (relative.pathname && relative.pathname.split('/')) || [],
              psychotic = result.protocol && !slashedProtocol[result.protocol]

            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // result.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {
              result.hostname = ''
              result.port = null
              if (result.host) {
                if (srcPath[0] === '') srcPath[0] = result.host
                else srcPath.unshift(result.host)
              }
              result.host = ''
              if (relative.protocol) {
                relative.hostname = null
                relative.port = null
                if (relative.host) {
                  if (relPath[0] === '') relPath[0] = relative.host
                  else relPath.unshift(relative.host)
                }
                relative.host = null
              }
              mustEndAbs =
                mustEndAbs && (relPath[0] === '' || srcPath[0] === '')
            }

            if (isRelAbs) {
              // it's absolute.
              result.host =
                relative.host || relative.host === ''
                  ? relative.host
                  : result.host
              result.hostname =
                relative.hostname || relative.hostname === ''
                  ? relative.hostname
                  : result.hostname
              result.search = relative.search
              result.query = relative.query
              srcPath = relPath
              // fall through to the dot-handling below.
            } else if (relPath.length) {
              // it's relative
              // throw away the existing file, and take the new path instead.
              if (!srcPath) srcPath = []
              srcPath.pop()
              srcPath = srcPath.concat(relPath)
              result.search = relative.search
              result.query = relative.query
            } else if (!util.isNullOrUndefined(relative.search)) {
              // just pull out the search.
              // like href='?foo'.
              // Put this after the other two cases because it simplifies the booleans
              if (psychotic) {
                result.hostname = result.host = srcPath.shift()
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost =
                  result.host && result.host.indexOf('@') > 0
                    ? result.host.split('@')
                    : false
                if (authInHost) {
                  result.auth = authInHost.shift()
                  result.host = result.hostname = authInHost.shift()
                }
              }
              result.search = relative.search
              result.query = relative.query
              //to support http.request
              if (
                !util.isNull(result.pathname) ||
                !util.isNull(result.search)
              ) {
                result.path =
                  (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '')
              }
              result.href = result.format()
              return result
            }

            if (!srcPath.length) {
              // no path at all.  easy.
              // we've already handled the other stuff above.
              result.pathname = null
              //to support http.request
              if (result.search) {
                result.path = '/' + result.search
              } else {
                result.path = null
              }
              result.href = result.format()
              return result
            }

            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0]
            var hasTrailingSlash =
              ((result.host || relative.host || srcPath.length > 1) &&
                (last === '.' || last === '..')) ||
              last === ''

            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0
            for (var i = srcPath.length; i >= 0; i--) {
              last = srcPath[i]
              if (last === '.') {
                srcPath.splice(i, 1)
              } else if (last === '..') {
                srcPath.splice(i, 1)
                up++
              } else if (up) {
                srcPath.splice(i, 1)
                up--
              }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift('..')
              }
            }

            if (
              mustEndAbs &&
              srcPath[0] !== '' &&
              (!srcPath[0] || srcPath[0].charAt(0) !== '/')
            ) {
              srcPath.unshift('')
            }

            if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
              srcPath.push('')
            }

            var isAbsolute =
              srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/')

            // put the host back
            if (psychotic) {
              result.hostname = result.host = isAbsolute
                ? ''
                : srcPath.length
                ? srcPath.shift()
                : ''
              //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost =
                result.host && result.host.indexOf('@') > 0
                  ? result.host.split('@')
                  : false
              if (authInHost) {
                result.auth = authInHost.shift()
                result.host = result.hostname = authInHost.shift()
              }
            }

            mustEndAbs = mustEndAbs || (result.host && srcPath.length)

            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift('')
            }

            if (!srcPath.length) {
              result.pathname = null
              result.path = null
            } else {
              result.pathname = srcPath.join('/')
            }

            //to support request.http
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path =
                (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '')
            }
            result.auth = relative.auth || result.auth
            result.slashes = result.slashes || relative.slashes
            result.href = result.format()
            return result
          }

          Url.prototype.parseHost = function () {
            var host = this.host
            var port = portPattern.exec(host)
            if (port) {
              port = port[0]
              if (port !== ':') {
                this.port = port.substr(1)
              }
              host = host.substr(0, host.length - port.length)
            }
            if (host) this.hostname = host
          }

          /***/
        },

      /***/ './node_modules/url/util.js':
        /*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
        /***/ (module) => {
          'use strict'

          module.exports = {
            isString: function (arg) {
              return typeof arg === 'string'
            },
            isObject: function (arg) {
              return typeof arg === 'object' && arg !== null
            },
            isNull: function (arg) {
              return arg === null
            },
            isNullOrUndefined: function (arg) {
              return arg == null
            },
          }

          /***/
        },

      /***/ './node_modules/util/support/isBufferBrowser.js':
        /*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
        /***/ (module) => {
          module.exports = function isBuffer(arg) {
            return (
              arg &&
              typeof arg === 'object' &&
              typeof arg.copy === 'function' &&
              typeof arg.fill === 'function' &&
              typeof arg.readUInt8 === 'function'
            )
          }

          /***/
        },

      /***/ './node_modules/util/support/types.js':
        /*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_371976__) => {
          'use strict'
          // Currently in sync with Node.js lib/internal/util/types.js
          // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

          var isArgumentsObject = __nested_webpack_require_371976__(
            /*! is-arguments */ './node_modules/is-arguments/index.js'
          )
          var isGeneratorFunction = __nested_webpack_require_371976__(
            /*! is-generator-function */ './node_modules/is-generator-function/index.js'
          )
          var whichTypedArray = __nested_webpack_require_371976__(
            /*! which-typed-array */ './node_modules/which-typed-array/index.js'
          )
          var isTypedArray = __nested_webpack_require_371976__(
            /*! is-typed-array */ './node_modules/is-typed-array/index.js'
          )

          function uncurryThis(f) {
            return f.call.bind(f)
          }

          var BigIntSupported = typeof BigInt !== 'undefined'
          var SymbolSupported = typeof Symbol !== 'undefined'

          var ObjectToString = uncurryThis(Object.prototype.toString)

          var numberValue = uncurryThis(Number.prototype.valueOf)
          var stringValue = uncurryThis(String.prototype.valueOf)
          var booleanValue = uncurryThis(Boolean.prototype.valueOf)

          if (BigIntSupported) {
            var bigIntValue = uncurryThis(BigInt.prototype.valueOf)
          }

          if (SymbolSupported) {
            var symbolValue = uncurryThis(Symbol.prototype.valueOf)
          }

          function checkBoxedPrimitive(value, prototypeValueOf) {
            if (typeof value !== 'object') {
              return false
            }
            try {
              prototypeValueOf(value)
              return true
            } catch (e) {
              return false
            }
          }

          exports.isArgumentsObject = isArgumentsObject
          exports.isGeneratorFunction = isGeneratorFunction
          exports.isTypedArray = isTypedArray

          // Taken from here and modified for better browser support
          // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
          function isPromise(input) {
            return (
              (typeof Promise !== 'undefined' && input instanceof Promise) ||
              (input !== null &&
                typeof input === 'object' &&
                typeof input.then === 'function' &&
                typeof input.catch === 'function')
            )
          }
          exports.isPromise = isPromise

          function isArrayBufferView(value) {
            if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
              return ArrayBuffer.isView(value)
            }

            return isTypedArray(value) || isDataView(value)
          }
          exports.isArrayBufferView = isArrayBufferView

          function isUint8Array(value) {
            return whichTypedArray(value) === 'Uint8Array'
          }
          exports.isUint8Array = isUint8Array

          function isUint8ClampedArray(value) {
            return whichTypedArray(value) === 'Uint8ClampedArray'
          }
          exports.isUint8ClampedArray = isUint8ClampedArray

          function isUint16Array(value) {
            return whichTypedArray(value) === 'Uint16Array'
          }
          exports.isUint16Array = isUint16Array

          function isUint32Array(value) {
            return whichTypedArray(value) === 'Uint32Array'
          }
          exports.isUint32Array = isUint32Array

          function isInt8Array(value) {
            return whichTypedArray(value) === 'Int8Array'
          }
          exports.isInt8Array = isInt8Array

          function isInt16Array(value) {
            return whichTypedArray(value) === 'Int16Array'
          }
          exports.isInt16Array = isInt16Array

          function isInt32Array(value) {
            return whichTypedArray(value) === 'Int32Array'
          }
          exports.isInt32Array = isInt32Array

          function isFloat32Array(value) {
            return whichTypedArray(value) === 'Float32Array'
          }
          exports.isFloat32Array = isFloat32Array

          function isFloat64Array(value) {
            return whichTypedArray(value) === 'Float64Array'
          }
          exports.isFloat64Array = isFloat64Array

          function isBigInt64Array(value) {
            return whichTypedArray(value) === 'BigInt64Array'
          }
          exports.isBigInt64Array = isBigInt64Array

          function isBigUint64Array(value) {
            return whichTypedArray(value) === 'BigUint64Array'
          }
          exports.isBigUint64Array = isBigUint64Array

          function isMapToString(value) {
            return ObjectToString(value) === '[object Map]'
          }
          isMapToString.working =
            typeof Map !== 'undefined' && isMapToString(new Map())

          function isMap(value) {
            if (typeof Map === 'undefined') {
              return false
            }

            return isMapToString.working
              ? isMapToString(value)
              : value instanceof Map
          }
          exports.isMap = isMap

          function isSetToString(value) {
            return ObjectToString(value) === '[object Set]'
          }
          isSetToString.working =
            typeof Set !== 'undefined' && isSetToString(new Set())
          function isSet(value) {
            if (typeof Set === 'undefined') {
              return false
            }

            return isSetToString.working
              ? isSetToString(value)
              : value instanceof Set
          }
          exports.isSet = isSet

          function isWeakMapToString(value) {
            return ObjectToString(value) === '[object WeakMap]'
          }
          isWeakMapToString.working =
            typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap())
          function isWeakMap(value) {
            if (typeof WeakMap === 'undefined') {
              return false
            }

            return isWeakMapToString.working
              ? isWeakMapToString(value)
              : value instanceof WeakMap
          }
          exports.isWeakMap = isWeakMap

          function isWeakSetToString(value) {
            return ObjectToString(value) === '[object WeakSet]'
          }
          isWeakSetToString.working =
            typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet())
          function isWeakSet(value) {
            return isWeakSetToString(value)
          }
          exports.isWeakSet = isWeakSet

          function isArrayBufferToString(value) {
            return ObjectToString(value) === '[object ArrayBuffer]'
          }
          isArrayBufferToString.working =
            typeof ArrayBuffer !== 'undefined' &&
            isArrayBufferToString(new ArrayBuffer())
          function isArrayBuffer(value) {
            if (typeof ArrayBuffer === 'undefined') {
              return false
            }

            return isArrayBufferToString.working
              ? isArrayBufferToString(value)
              : value instanceof ArrayBuffer
          }
          exports.isArrayBuffer = isArrayBuffer

          function isDataViewToString(value) {
            return ObjectToString(value) === '[object DataView]'
          }
          isDataViewToString.working =
            typeof ArrayBuffer !== 'undefined' &&
            typeof DataView !== 'undefined' &&
            isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
          function isDataView(value) {
            if (typeof DataView === 'undefined') {
              return false
            }

            return isDataViewToString.working
              ? isDataViewToString(value)
              : value instanceof DataView
          }
          exports.isDataView = isDataView

          function isSharedArrayBufferToString(value) {
            return ObjectToString(value) === '[object SharedArrayBuffer]'
          }
          isSharedArrayBufferToString.working =
            typeof SharedArrayBuffer !== 'undefined' &&
            isSharedArrayBufferToString(new SharedArrayBuffer())
          function isSharedArrayBuffer(value) {
            if (typeof SharedArrayBuffer === 'undefined') {
              return false
            }

            return isSharedArrayBufferToString.working
              ? isSharedArrayBufferToString(value)
              : value instanceof SharedArrayBuffer
          }
          exports.isSharedArrayBuffer = isSharedArrayBuffer

          function isAsyncFunction(value) {
            return ObjectToString(value) === '[object AsyncFunction]'
          }
          exports.isAsyncFunction = isAsyncFunction

          function isMapIterator(value) {
            return ObjectToString(value) === '[object Map Iterator]'
          }
          exports.isMapIterator = isMapIterator

          function isSetIterator(value) {
            return ObjectToString(value) === '[object Set Iterator]'
          }
          exports.isSetIterator = isSetIterator

          function isGeneratorObject(value) {
            return ObjectToString(value) === '[object Generator]'
          }
          exports.isGeneratorObject = isGeneratorObject

          function isWebAssemblyCompiledModule(value) {
            return ObjectToString(value) === '[object WebAssembly.Module]'
          }
          exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule

          function isNumberObject(value) {
            return checkBoxedPrimitive(value, numberValue)
          }
          exports.isNumberObject = isNumberObject

          function isStringObject(value) {
            return checkBoxedPrimitive(value, stringValue)
          }
          exports.isStringObject = isStringObject

          function isBooleanObject(value) {
            return checkBoxedPrimitive(value, booleanValue)
          }
          exports.isBooleanObject = isBooleanObject

          function isBigIntObject(value) {
            return BigIntSupported && checkBoxedPrimitive(value, bigIntValue)
          }
          exports.isBigIntObject = isBigIntObject

          function isSymbolObject(value) {
            return SymbolSupported && checkBoxedPrimitive(value, symbolValue)
          }
          exports.isSymbolObject = isSymbolObject

          function isBoxedPrimitive(value) {
            return (
              isNumberObject(value) ||
              isStringObject(value) ||
              isBooleanObject(value) ||
              isBigIntObject(value) ||
              isSymbolObject(value)
            )
          }
          exports.isBoxedPrimitive = isBoxedPrimitive

          function isAnyArrayBuffer(value) {
            return (
              typeof Uint8Array !== 'undefined' &&
              (isArrayBuffer(value) || isSharedArrayBuffer(value))
            )
          }
          exports.isAnyArrayBuffer = isAnyArrayBuffer

          ;['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(
            function (method) {
              Object.defineProperty(exports, method, {
                enumerable: false,
                value: function () {
                  throw new Error(method + ' is not supported in userland')
                },
              })
            }
          )

          /***/
        },

      /***/ './node_modules/util/util.js':
        /*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_383546__) => {
          /* provided dependency */ var process = __nested_webpack_require_383546__(
            /*! process/browser */ './node_modules/process/browser.js'
          )
          /* provided dependency */ var console = __nested_webpack_require_383546__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var getOwnPropertyDescriptors =
            Object.getOwnPropertyDescriptors ||
            function getOwnPropertyDescriptors(obj) {
              var keys = Object.keys(obj)
              var descriptors = {}
              for (var i = 0; i < keys.length; i++) {
                descriptors[keys[i]] = Object.getOwnPropertyDescriptor(
                  obj,
                  keys[i]
                )
              }
              return descriptors
            }

          var formatRegExp = /%[sdj%]/g
          exports.format = function (f) {
            if (!isString(f)) {
              var objects = []
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]))
              }
              return objects.join(' ')
            }

            var i = 1
            var args = arguments
            var len = args.length
            var str = String(f).replace(formatRegExp, function (x) {
              if (x === '%%') return '%'
              if (i >= len) return x
              switch (x) {
                case '%s':
                  return String(args[i++])
                case '%d':
                  return Number(args[i++])
                case '%j':
                  try {
                    return JSON.stringify(args[i++])
                  } catch (_) {
                    return '[Circular]'
                  }
                default:
                  return x
              }
            })
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x
              } else {
                str += ' ' + inspect(x)
              }
            }
            return str
          }

          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function (fn, msg) {
            if (
              typeof process !== 'undefined' &&
              process.noDeprecation === true
            ) {
              return fn
            }

            // Allow for deprecating things in the process of starting up.
            if (typeof process === 'undefined') {
              return function () {
                return exports.deprecate(fn, msg).apply(this, arguments)
              }
            }

            var warned = false
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg)
                } else if (process.traceDeprecation) {
                  console.trace(msg)
                } else {
                  console.error(msg)
                }
                warned = true
              }
              return fn.apply(this, arguments)
            }

            return deprecated
          }

          var debugs = {}
          var debugEnvRegex = /^$/

          if (process.env.NODE_DEBUG) {
            var debugEnv = process.env.NODE_DEBUG
            debugEnv = debugEnv
              .replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
              .replace(/\*/g, '.*')
              .replace(/,/g, '$|^')
              .toUpperCase()
            debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i')
          }
          exports.debuglog = function (set) {
            set = set.toUpperCase()
            if (!debugs[set]) {
              if (debugEnvRegex.test(set)) {
                var pid = process.pid
                debugs[set] = function () {
                  var msg = exports.format.apply(exports, arguments)
                  console.error('%s %d: %s', set, pid, msg)
                }
              } else {
                debugs[set] = function () {}
              }
            }
            return debugs[set]
          }

          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Object} opts Optional options object that alters the output.
           */
          /* legacy: obj, showHidden, depth, colors*/
          function inspect(obj, opts) {
            // default options
            var ctx = {
              seen: [],
              stylize: stylizeNoColor,
            }
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2]
            if (arguments.length >= 4) ctx.colors = arguments[3]
            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts
            } else if (opts) {
              // got an "options" object
              exports._extend(ctx, opts)
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false
            if (isUndefined(ctx.depth)) ctx.depth = 2
            if (isUndefined(ctx.colors)) ctx.colors = false
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true
            if (ctx.colors) ctx.stylize = stylizeWithColor
            return formatValue(ctx, obj, ctx.depth)
          }
          exports.inspect = inspect

          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39],
          }

          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            special: 'cyan',
            number: 'yellow',
            boolean: 'yellow',
            undefined: 'grey',
            null: 'bold',
            string: 'green',
            date: 'magenta',
            // "name": intentionally not styling
            regexp: 'red',
          }

          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType]

            if (style) {
              return (
                '\u001b[' +
                inspect.colors[style][0] +
                'm' +
                str +
                '\u001b[' +
                inspect.colors[style][1] +
                'm'
              )
            } else {
              return str
            }
          }

          function stylizeNoColor(str, styleType) {
            return str
          }

          function arrayToHash(array) {
            var hash = {}

            array.forEach(function (val, idx) {
              hash[val] = true
            })

            return hash
          }

          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (
              ctx.customInspect &&
              value &&
              isFunction(value.inspect) &&
              // Filter out the util module, it's inspect function is special
              value.inspect !== exports.inspect &&
              // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)
            ) {
              var ret = value.inspect(recurseTimes, ctx)
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes)
              }
              return ret
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value)
            if (primitive) {
              return primitive
            }

            // Look up the keys of the object.
            var keys = Object.keys(value)
            var visibleKeys = arrayToHash(keys)

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value)
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (
              isError(value) &&
              (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)
            ) {
              return formatError(value)
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : ''
                return ctx.stylize('[Function' + name + ']', 'special')
              }
              if (isRegExp(value)) {
                return ctx.stylize(
                  RegExp.prototype.toString.call(value),
                  'regexp'
                )
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date')
              }
              if (isError(value)) {
                return formatError(value)
              }
            }

            var base = '',
              array = false,
              braces = ['{', '}']

            // Make Array say that they are Array
            if (isArray(value)) {
              array = true
              braces = ['[', ']']
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : ''
              base = ' [Function' + n + ']'
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value)
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value)
            }

            // Make error with message first say the error
            if (isError(value)) {
              base = ' ' + formatError(value)
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1]
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(
                  RegExp.prototype.toString.call(value),
                  'regexp'
                )
              } else {
                return ctx.stylize('[Object]', 'special')
              }
            }

            ctx.seen.push(value)

            var output
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys)
            } else {
              output = keys.map(function (key) {
                return formatProperty(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  key,
                  array
                )
              })
            }

            ctx.seen.pop()

            return reduceToSingleString(output, base, braces)
          }

          function formatPrimitive(ctx, value) {
            if (isUndefined(value)) return ctx.stylize('undefined', 'undefined')
            if (isString(value)) {
              var simple =
                "'" +
                JSON.stringify(value)
                  .replace(/^"|"$/g, '')
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"') +
                "'"
              return ctx.stylize(simple, 'string')
            }
            if (isNumber(value)) return ctx.stylize('' + value, 'number')
            if (isBoolean(value)) return ctx.stylize('' + value, 'boolean')
            // For some reason typeof null is "object", so special case here.
            if (isNull(value)) return ctx.stylize('null', 'null')
          }

          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']'
          }

          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = []
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(
                  formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    String(i),
                    true
                  )
                )
              } else {
                output.push('')
              }
            }
            keys.forEach(function (key) {
              if (!key.match(/^\d+$/)) {
                output.push(
                  formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    true
                  )
                )
              }
            })
            return output
          }

          function formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            array
          ) {
            var name, str, desc
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key],
            }
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special')
              } else {
                str = ctx.stylize('[Getter]', 'special')
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special')
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']'
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null)
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1)
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str
                      .split('\n')
                      .map(function (line) {
                        return '  ' + line
                      })
                      .join('\n')
                      .substr(2)
                  } else {
                    str =
                      '\n' +
                      str
                        .split('\n')
                        .map(function (line) {
                          return '   ' + line
                        })
                        .join('\n')
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special')
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str
              }
              name = JSON.stringify('' + key)
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2)
                name = ctx.stylize(name, 'name')
              } else {
                name = name
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"')
                  .replace(/(^"|"$)/g, "'")
                name = ctx.stylize(name, 'string')
              }
            }

            return name + ': ' + str
          }

          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0
            var length = output.reduce(function (prev, cur) {
              numLinesEst++
              if (cur.indexOf('\n') >= 0) numLinesEst++
              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1
            }, 0)

            if (length > 60) {
              return (
                braces[0] +
                (base === '' ? '' : base + '\n ') +
                ' ' +
                output.join(',\n  ') +
                ' ' +
                braces[1]
              )
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]
          }

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          exports.types = __nested_webpack_require_383546__(
            /*! ./support/types */ './node_modules/util/support/types.js'
          )

          function isArray(ar) {
            return Array.isArray(ar)
          }
          exports.isArray = isArray

          function isBoolean(arg) {
            return typeof arg === 'boolean'
          }
          exports.isBoolean = isBoolean

          function isNull(arg) {
            return arg === null
          }
          exports.isNull = isNull

          function isNullOrUndefined(arg) {
            return arg == null
          }
          exports.isNullOrUndefined = isNullOrUndefined

          function isNumber(arg) {
            return typeof arg === 'number'
          }
          exports.isNumber = isNumber

          function isString(arg) {
            return typeof arg === 'string'
          }
          exports.isString = isString

          function isSymbol(arg) {
            return typeof arg === 'symbol'
          }
          exports.isSymbol = isSymbol

          function isUndefined(arg) {
            return arg === void 0
          }
          exports.isUndefined = isUndefined

          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]'
          }
          exports.isRegExp = isRegExp
          exports.types.isRegExp = isRegExp

          function isObject(arg) {
            return typeof arg === 'object' && arg !== null
          }
          exports.isObject = isObject

          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]'
          }
          exports.isDate = isDate
          exports.types.isDate = isDate

          function isError(e) {
            return (
              isObject(e) &&
              (objectToString(e) === '[object Error]' || e instanceof Error)
            )
          }
          exports.isError = isError
          exports.types.isNativeError = isError

          function isFunction(arg) {
            return typeof arg === 'function'
          }
          exports.isFunction = isFunction

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === 'boolean' ||
              typeof arg === 'number' ||
              typeof arg === 'string' ||
              typeof arg === 'symbol' || // ES6 symbol
              typeof arg === 'undefined'
            )
          }
          exports.isPrimitive = isPrimitive

          exports.isBuffer = __nested_webpack_require_383546__(
            /*! ./support/isBuffer */ './node_modules/util/support/isBufferBrowser.js'
          )

          function objectToString(o) {
            return Object.prototype.toString.call(o)
          }

          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10)
          }

          var months = [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec',
          ]

          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date()
            var time = [
              pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds()),
            ].join(':')
            return [d.getDate(), months[d.getMonth()], time].join(' ')
          }

          // log is just a thin wrapper to console.log that prepends a timestamp
          exports.log = function () {
            console.log(
              '%s - %s',
              timestamp(),
              exports.format.apply(exports, arguments)
            )
          }

          /**
           * Inherit the prototype methods from one constructor into another.
           *
           * The Function.prototype.inherits from lang.js rewritten as a standalone
           * function (not on Function.prototype). NOTE: If this file is to be loaded
           * during bootstrapping this function needs to be rewritten using some native
           * functions as prototype setup using normal JavaScript does not work as
           * expected during bootstrapping (see mirror.js in r114903).
           *
           * @param {function} ctor Constructor function which needs to inherit the
           *     prototype.
           * @param {function} superCtor Constructor function to inherit prototype from.
           */
          exports.inherits = __nested_webpack_require_383546__(
            /*! inherits */ './node_modules/inherits/inherits_browser.js'
          )

          exports._extend = function (origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin

            var keys = Object.keys(add)
            var i = keys.length
            while (i--) {
              origin[keys[i]] = add[keys[i]]
            }
            return origin
          }

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop)
          }

          var kCustomPromisifiedSymbol =
            typeof Symbol !== 'undefined'
              ? Symbol('util.promisify.custom')
              : undefined

          exports.promisify = function promisify(original) {
            if (typeof original !== 'function')
              throw new TypeError(
                'The "original" argument must be of type Function'
              )

            if (
              kCustomPromisifiedSymbol &&
              original[kCustomPromisifiedSymbol]
            ) {
              var fn = original[kCustomPromisifiedSymbol]
              if (typeof fn !== 'function') {
                throw new TypeError(
                  'The "util.promisify.custom" argument must be of type Function'
                )
              }
              Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn,
                enumerable: false,
                writable: false,
                configurable: true,
              })
              return fn
            }

            function fn() {
              var promiseResolve, promiseReject
              var promise = new Promise(function (resolve, reject) {
                promiseResolve = resolve
                promiseReject = reject
              })

              var args = []
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i])
              }
              args.push(function (err, value) {
                if (err) {
                  promiseReject(err)
                } else {
                  promiseResolve(value)
                }
              })

              try {
                original.apply(this, args)
              } catch (err) {
                promiseReject(err)
              }

              return promise
            }

            Object.setPrototypeOf(fn, Object.getPrototypeOf(original))

            if (kCustomPromisifiedSymbol)
              Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn,
                enumerable: false,
                writable: false,
                configurable: true,
              })
            return Object.defineProperties(
              fn,
              getOwnPropertyDescriptors(original)
            )
          }

          exports.promisify.custom = kCustomPromisifiedSymbol

          function callbackifyOnRejected(reason, cb) {
            // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
            // Because `null` is a special error value in callbacks which means "no error
            // occurred", we error-wrap so the callback consumer can distinguish between
            // "the promise rejected with null" or "the promise fulfilled with undefined".
            if (!reason) {
              var newReason = new Error(
                'Promise was rejected with a falsy value'
              )
              newReason.reason = reason
              reason = newReason
            }
            return cb(reason)
          }

          function callbackify(original) {
            if (typeof original !== 'function') {
              throw new TypeError(
                'The "original" argument must be of type Function'
              )
            }

            // We DO NOT return the promise as it gives the user a false sense that
            // the promise is actually somehow related to the callback's execution
            // and that the callback throwing will reject the promise.
            function callbackified() {
              var args = []
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i])
              }

              var maybeCb = args.pop()
              if (typeof maybeCb !== 'function') {
                throw new TypeError(
                  'The last argument must be of type Function'
                )
              }
              var self = this
              var cb = function () {
                return maybeCb.apply(self, arguments)
              }
              // In true node style we process the callback on `nextTick` with all the
              // implications (stack, `uncaughtException`, `async_hooks`)
              original.apply(this, args).then(
                function (ret) {
                  process.nextTick(cb.bind(null, null, ret))
                },
                function (rej) {
                  process.nextTick(callbackifyOnRejected.bind(null, rej, cb))
                }
              )
            }

            Object.setPrototypeOf(
              callbackified,
              Object.getPrototypeOf(original)
            )
            Object.defineProperties(
              callbackified,
              getOwnPropertyDescriptors(original)
            )
            return callbackified
          }
          exports.callbackify = callbackify

          /***/
        },

      /***/ './node_modules/which-typed-array/index.js':
        /*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_411901__) => {
          'use strict'

          var forEach = __nested_webpack_require_411901__(
            /*! foreach */ './node_modules/foreach/index.js'
          )
          var availableTypedArrays = __nested_webpack_require_411901__(
            /*! available-typed-arrays */ './node_modules/available-typed-arrays/index.js'
          )
          var callBound = __nested_webpack_require_411901__(
            /*! call-bind/callBound */ './node_modules/call-bind/callBound.js'
          )

          var $toString = callBound('Object.prototype.toString')
          var hasSymbols = __nested_webpack_require_411901__(
            /*! has-symbols */ './node_modules/has-symbols/index.js'
          )()
          var hasToStringTag =
            hasSymbols && typeof Symbol.toStringTag === 'symbol'

          var typedArrays = availableTypedArrays()

          var $slice = callBound('String.prototype.slice')
          var toStrTags = {}
          var gOPD = __nested_webpack_require_411901__(
            /*! es-abstract/helpers/getOwnPropertyDescriptor */ './node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js'
          )
          var getPrototypeOf = Object.getPrototypeOf // require('getprototypeof');
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function (typedArray) {
              if (typeof __nested_webpack_require_411901__.g[typedArray] === 'function') {
                var arr = new __nested_webpack_require_411901__.g[typedArray]()
                if (!(Symbol.toStringTag in arr)) {
                  throw new EvalError(
                    'this engine has support for Symbol.toStringTag, but ' +
                      typedArray +
                      ' does not have the property! Please report this.'
                  )
                }
                var proto = getPrototypeOf(arr)
                var descriptor = gOPD(proto, Symbol.toStringTag)
                if (!descriptor) {
                  var superProto = getPrototypeOf(proto)
                  descriptor = gOPD(superProto, Symbol.toStringTag)
                }
                toStrTags[typedArray] = descriptor.get
              }
            })
          }

          var tryTypedArrays = function tryAllTypedArrays(value) {
            var foundName = false
            forEach(toStrTags, function (getter, typedArray) {
              if (!foundName) {
                try {
                  var name = getter.call(value)
                  if (name === typedArray) {
                    foundName = name
                  }
                } catch (e) {}
              }
            })
            return foundName
          }

          var isTypedArray = __nested_webpack_require_411901__(
            /*! is-typed-array */ './node_modules/is-typed-array/index.js'
          )

          module.exports = function whichTypedArray(value) {
            if (!isTypedArray(value)) {
              return false
            }
            if (!hasToStringTag) {
              return $slice($toString(value), 8, -1)
            }
            return tryTypedArrays(value)
          }

          /***/
        },

      /******/
    } // The module cache
    /************************************************************************/
    /******/ /******/ var __webpack_module_cache__ = {} // The require function
    /******/
    /******/ /******/ function __nested_webpack_require_415201__(moduleId) {
      /******/ // Check if module is in cache
      /******/ var cachedModule = __webpack_module_cache__[moduleId]
      /******/ if (cachedModule !== undefined) {
        /******/ return cachedModule.exports
        /******/
      } // Create a new module (and put it into the cache)
      /******/ /******/ var module = (__webpack_module_cache__[moduleId] = {
        /******/ id: moduleId,
        /******/ loaded: false,
        /******/ exports: {},
        /******/
      }) // Execute the module function
      /******/
      /******/ /******/ __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nested_webpack_require_415201__
      ) // Flag the module as loaded
      /******/
      /******/ /******/ module.loaded = true // Return the exports of the module
      /******/
      /******/ /******/ return module.exports
      /******/
    } /* webpack/runtime/define property getters */
    /******/
    /************************************************************************/
    /******/ /******/ ;(() => {
      /******/ // define getter functions for harmony exports
      /******/ __nested_webpack_require_415201__.d = (exports, definition) => {
        /******/ for (var key in definition) {
          /******/ if (
            __nested_webpack_require_415201__.o(definition, key) &&
            !__nested_webpack_require_415201__.o(exports, key)
          ) {
            /******/ Object.defineProperty(exports, key, {
              enumerable: true,
              get: definition[key],
            })
            /******/
          }
          /******/
        }
        /******/
      }
      /******/
    })() /* webpack/runtime/global */
    /******/
    /******/ /******/ ;(() => {
      /******/ __nested_webpack_require_415201__.g = (function () {
        /******/ if (typeof globalThis === 'object') return globalThis
        /******/ try {
          /******/ return this || new Function('return this')()
          /******/
        } catch (e) {
          /******/ if (typeof window === 'object') return window
          /******/
        }
        /******/
      })()
      /******/
    })() /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    /******/ /******/ ;(() => {
      /******/ __nested_webpack_require_415201__.o = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop)
      /******/
    })() /* webpack/runtime/make namespace object */
    /******/
    /******/ /******/ ;(() => {
      /******/ // define __esModule on exports
      /******/ __nested_webpack_require_415201__.r = (exports) => {
        /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/ Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module',
          })
          /******/
        }
        /******/ Object.defineProperty(exports, '__esModule', { value: true })
        /******/
      }
      /******/
    })() /* webpack/runtime/node module decorator */
    /******/
    /******/ /******/ ;(() => {
      /******/ __nested_webpack_require_415201__.nmd = (module) => {
        /******/ module.paths = []
        /******/ if (!module.children) module.children = []
        /******/ return module
        /******/
      }
      /******/
    })()
    /******/
    /************************************************************************/
    var __webpack_exports__ = {}
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    ;(() => {
      'use strict'
      var exports = __webpack_exports__
      /*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.ImgurClient = void 0
      var client_1 = __nested_webpack_require_415201__(/*! ./client */ './src/client.ts')
      Object.defineProperty(exports, 'ImgurClient', {
        enumerable: true,
        get: function () {
          return client_1.ImgurClient
        },
      })
    })()

    /******/ return __webpack_exports__
    /******/
  })()
})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWd1ci1hcGkvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9hcnJheS1maWx0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9lczYtb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaXMtbmFuL3BvbHlmaWxsLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvYWxidW0vZ2V0QWxidW0udHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2FsYnVtL2luZGV4LnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2NvbW1vbi90eXBlcy50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvY29tbW9uL3V0aWxzLnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9nYWxsZXJ5L2dldEdhbGxlcnkudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2dhbGxlcnkvZ2V0U3VicmVkZGl0R2FsbGVyeS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvZ2FsbGVyeS9pbmRleC50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvZ2FsbGVyeS9zZWFyY2hHYWxsZXJ5LnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9nZXRBdXRob3JpemF0aW9uSGVhZGVyLnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9pbWFnZS9kZWxldGVJbWFnZS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvaW1hZ2UvZmF2b3JpdGVJbWFnZS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvaW1hZ2UvZ2V0SW1hZ2UudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2ltYWdlL2luZGV4LnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9pbWFnZS91cGRhdGVJbWFnZS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvaW1hZ2UvdXBsb2FkLnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ltZ3VyLWFwaS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLHVCQUF1QiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRTdWLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGVBQWUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHlHQUFtQzs7QUFFaEUsZ0JBQWdCLG1CQUFPLENBQUMsMENBQU87QUFDL0I7O0FBRUEscUJBQXFCLHFFQUFzQjtBQUMzQztBQUNBOztBQUVBLG1EQUFtRCxnR0FBbUM7QUFDdEYsdUNBQXVDLG1CQUFPLENBQUMsb0RBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkZBQTZCOztBQUV4RDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQixPQUFPLGVBQWUsT0FBTyxlQUFlLE9BQU8sV0FBVyxPQUFPO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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ZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEk7Ozs7O1dDUEQsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFOzs7Ozs7Ozs7Ozs7Ozs7QUNKQSxzRUFBdUM7QUFBOUIsaUhBQVciLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0Ly9Db21tb25KUzIgQ29tbWVudFxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdC8vQU1EIENvbW1lbnRcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0Ly9Db21tb25KUyBDb21tZW50XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbWd1clwiXSA9IGZhY3RvcnkoKTtcblx0Ly9Sb290IENvbW1lbnRcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbWd1clwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCJcbi8qKlxuICogQXJyYXkjZmlsdGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2VsZlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAdGhyb3cgVHlwZUVycm9yXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBmbiwgc2VsZikge1xuICBpZiAoYXJyLmZpbHRlcikgcmV0dXJuIGFyci5maWx0ZXIoZm4sIHNlbGYpO1xuICBpZiAodm9pZCAwID09PSBhcnIgfHwgbnVsbCA9PT0gYXJyKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKGFyciwgaSkpIGNvbnRpbnVlO1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGZuLmNhbGwoc2VsZiwgdmFsLCBpLCBhcnIpKSByZXQucHVzaCh2YWwpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lcnJvcnMnKSxcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUztcblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yJyk7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsLycpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogcmVxdWlyZSgnZXM2LW9iamVjdC1hc3NpZ24nKS5hc3NpZ247XG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSByZXF1aXJlKCcuL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMnKTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdO1xuXG52YXIgZXNjYXBlRm4gPSBmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xufTtcblxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuXG4gIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XG4gIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGlmICh3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nID8gcHJvY2Vzcy5lbWl0V2FybmluZyA6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgd2FybignYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwOTQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuXG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcblxuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblxuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufSAvLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuXG5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5vayA9IG9rOyAvLyBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGggPT0uXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuXG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cblxuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxuXG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBleHBlY3RlZFtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gIHJldHVybiBpc1Byb21pc2Uob2JqKSB8fCBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7IC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHBlY3RzRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgIHZhciBkZXRhaWxzID0gJyc7XG5cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlcnJvciAmJiAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWVycm9yIHx8IGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0JyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBhY3R1YWw7XG59XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcblxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxuICAgIH0pOyAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXG4gICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdG1wMi5zaGlmdCgpOyAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pO1xuXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3RXJyO1xuICB9XG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG5cbmZ1bmN0aW9uIHN0cmljdCgpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4ndXNlIHN0cmljdCc7IC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcblxuICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgIGluc3BlY3RlZCA9IFwiXCIuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCBcIi4uLlwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGlucHV0LCBcIiB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCJcIikgKyBcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlLCBcIi5cIik7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYW5kIFwiKS5jb25jYXQoYXJnc1sxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xuXG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZSgnaXMtbmFuJyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gICAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1NykgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cblxuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoaXNOb25JbmRleCkuY29uY2F0KG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkuZmlsdGVyKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSkpKTtcbn0gLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIE9OTFlfRU5VTUVSQUJMRSA9IHVuZGVmaW5lZDtcbnZhciBrU3RyaWN0ID0gdHJ1ZTtcbnZhciBrTG9vc2UgPSBmYWxzZTtcbnZhciBrTm9JdGVyYXRvciA9IDA7XG52YXIga0lzQXJyYXkgPSAxO1xudmFyIGtJc1NldCA9IDI7XG52YXIga0lzTWFwID0gMzsgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcbi8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbi8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG4vLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4vLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXG4vL1xuLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXG4vLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4vLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxuLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbi8vXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcbi8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cblxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcblxuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXG4gICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XG4gIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgLy8gd2FuJ3QgdG8gZWFybHkgcmV0dXJuIG91dCBvZiB0aGUgcmVzdCBvZiB0aGUgY2hlY2tzLiBIb3dldmVyIHdlIGNhbiBjaGVja1xuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEYXRlKHZhbDEpKSB7XG4gICAgaWYgKCFpc0RhdGUodmFsMikgfHwgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDEpICE9PSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgIC8vIGlzIG90aGVyd2lzZSBpZGVudGljYWwuXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XG4gICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cblxuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoX2tleXMubGVuZ3RoICE9PSBfa2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcCk7XG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgIGlmICghYXJlRXF1YWxBcnJheUJ1ZmZlcnModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWwxKSAmJiAhaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcbiAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcblxuICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBVc2UgbWVtb3MgdG8gaGFuZGxlIGN5Y2xlcy5cblxuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG5cbiAgICBpZiAodmFsMk1lbW9BICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcblxuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG5cbiAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pO1xuICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbik7XG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcbiAgbWVtb3MudmFsMS5kZWxldGUodmFsMSk7XG4gIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpO1xuICByZXR1cm4gYXJlRXE7XG59XG5cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG5cbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XG4gIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwcmltID0gK3ByaW07XG4gICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG5cbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYWx0VmFsdWU7XG4gIH1cblxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcblxuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXG4gICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuXG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAhYS5oYXMoX3ZhbCkgJiYgIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRvIGJlIGFibGUgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAga2V5ID0gX2FFbnRyaWVzJGlbMF0sXG4gICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG5cbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlIHdlIHByZXZlbnQgYW5vdGhlciBiLmhhcyhrZXkpIGNoZWNrIGluXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KTtcblxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KGtleSksIGl0ZW0sIGZhbHNlLCBtZW1vKSkgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG5cbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzQVtpXTtcblxuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gIGlzRGVlcFN0cmljdEVxdWFsOiBpc0RlZXBTdHJpY3RFcXVhbFxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmaWx0ZXIgPSByZXF1aXJlKCdhcnJheS1maWx0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0cmV0dXJuIGZpbHRlcihbXG5cdFx0J0JpZ0ludDY0QXJyYXknLFxuXHRcdCdCaWdVaW50NjRBcnJheScsXG5cdFx0J0Zsb2F0MzJBcnJheScsXG5cdFx0J0Zsb2F0NjRBcnJheScsXG5cdFx0J0ludDE2QXJyYXknLFxuXHRcdCdJbnQzMkFycmF5Jyxcblx0XHQnSW50OEFycmF5Jyxcblx0XHQnVWludDE2QXJyYXknLFxuXHRcdCdVaW50MzJBcnJheScsXG5cdFx0J1VpbnQ4QXJyYXknLFxuXHRcdCdVaW50OENsYW1wZWRBcnJheSdcblx0XSwgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGdsb2JhbFt0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJztcblx0fSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IodGltZW91dEVycm9yTWVzc2FnZSwgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvYmogPSB7fTtcblx0dHJ5IHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSk7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRcdGZvciAodmFyIF8gaW4gb2JqKSB7IC8vIGpzY3M6aWdub3JlIGRpc2FsbG93VW51c2VkVmFyaWFibGVzXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBvYmoueCA9PT0gb2JqO1xuXHR9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgSUUgOC4gKi9cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkKCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7XG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJyk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZmlyc3RTb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XG4gICAgICB2YXIgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhc3NpZ25cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ24sXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnID8gc2VsZi5Gb3JtRGF0YSA6IHdpbmRvdy5Gb3JtRGF0YTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbikge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG52YXIgR2VuZXJhdG9yRnVuY3Rpb24gPSBnZXRQcm90byAmJiBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byAmJiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdsb2JhbFt0eXBlZEFycmF5XSgpO1xuXHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXZhbEVycm9yKCd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArIHR5cGVkQXJyYXkgKyAnIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuJyk7XG5cdFx0fVxuXHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdH1cblx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBhbnlUcnVlID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFhbnlUcnVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhbnlUcnVlID0gZ2V0dGVyLmNhbGwodmFsdWUpID09PSB0eXBlZEFycmF5O1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gYW55VHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiaW1wb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuLi9jbGllbnQnO1xuaW1wb3J0IHsgQUxCVU1fRU5EUE9JTlQgfSBmcm9tICcuLi9jb21tb24vZW5kcG9pbnRzJztcbmltcG9ydCB7IEltZ3VyQXBpUmVzcG9uc2UsIEFsYnVtRGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsYnVtKFxuICBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBhbGJ1bUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPEFsYnVtRGF0YT4+IHtcbiAgY29uc3QgdXJsID0gYCR7QUxCVU1fRU5EUE9JTlR9LyR7YWxidW1IYXNofWA7XG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHt1cmx9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTxBbGJ1bURhdGE+O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9nZXRBbGJ1bSc7XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgZ2V0QXV0aG9yaXphdGlvbkhlYWRlciB9IGZyb20gJy4vZ2V0QXV0aG9yaXphdGlvbkhlYWRlcic7XG5pbXBvcnQge1xuICBkZWxldGVJbWFnZSxcbiAgZmF2b3JpdGVJbWFnZSxcbiAgZ2V0SW1hZ2UsXG4gIHVwbG9hZCxcbiAgdXBkYXRlSW1hZ2UsXG4gIFVwZGF0ZUltYWdlUGF5bG9hZCxcbn0gZnJvbSAnLi9pbWFnZSc7XG5pbXBvcnQge1xuICBHYWxsZXJ5T3B0aW9ucyxcbiAgZ2V0R2FsbGVyeSxcbiAgZ2V0U3VicmVkZGl0R2FsbGVyeSxcbiAgU3VicmVkZGl0R2FsbGVyeU9wdGlvbnMsXG4gIHNlYXJjaEdhbGxlcnksXG4gIFNlYXJjaEdhbGxlcnlPcHRpb25zLFxufSBmcm9tICcuL2dhbGxlcnknO1xuaW1wb3J0IHsgZ2V0QWxidW0gfSBmcm9tICcuL2FsYnVtJztcbmltcG9ydCB7IElNR1VSX0FQSV9QUkVGSVggfSBmcm9tICcuL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHtcbiAgQWxidW1EYXRhLFxuICBDcmVkZW50aWFscyxcbiAgR2FsbGVyeURhdGEsXG4gIEltYWdlRGF0YSxcbiAgSW1ndXJBcGlSZXNwb25zZSxcbiAgUGF5bG9hZCxcbn0gZnJvbSAnLi9jb21tb24vdHlwZXMnO1xuXG5jb25zdCBVU0VSQUdFTlQgPSAnaW1ndXIvbmV4dCAoaHR0cHM6Ly9naXRodWIuY29tL2thaW1hbGxlYS9ub2RlLWltZ3VyKSc7XG5cbmltcG9ydCBheGlvcywgeyBBeGlvc0luc3RhbmNlLCBBeGlvc1Jlc3BvbnNlLCBBeGlvc1JlcXVlc3RDb25maWcgfSBmcm9tICdheGlvcyc7XG5cbmV4cG9ydCBjbGFzcyBJbWd1ckNsaWVudCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgcGxhaW5GZXRjaGVyOiBBeGlvc0luc3RhbmNlO1xuICBwcml2YXRlIGZldGNoZXI6IEF4aW9zSW5zdGFuY2U7XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgY3JlZGVudGlhbHM6IENyZWRlbnRpYWxzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucGxhaW5GZXRjaGVyID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IElNR1VSX0FQSV9QUkVGSVgsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICd1c2VyLWFnZW50JzogVVNFUkFHRU5ULFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pO1xuICAgIHRoaXMuZmV0Y2hlciA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICBiYXNlVVJMOiBJTUdVUl9BUElfUFJFRklYLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAndXNlci1hZ2VudCc6IFVTRVJBR0VOVCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KTtcbiAgICB0aGlzLmZldGNoZXIuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKFxuICAgICAgYXN5bmMgKGNvbmZpZzogQXhpb3NSZXF1ZXN0Q29uZmlnKSA9PiB7XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgPyBjb25maWcuaGVhZGVycyA6IHt9O1xuICAgICAgICBjb25maWcuaGVhZGVycy5hdXRob3JpemF0aW9uID0gYXdhaXQgZ2V0QXV0aG9yaXphdGlvbkhlYWRlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH0sXG4gICAgICAoZTogRXJyb3IpID0+IFByb21pc2UucmVqZWN0KGUpXG4gICAgKTtcbiAgfVxuXG4gIHBsYWluUmVxdWVzdChvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcpOiBQcm9taXNlPEF4aW9zUmVzcG9uc2U8dW5rbm93bj4+IHtcbiAgICByZXR1cm4gdGhpcy5wbGFpbkZldGNoZXIob3B0aW9ucyk7XG4gIH1cblxuICByZXF1ZXN0KG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9KTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPHVua25vd24+PiB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hlcihvcHRpb25zKTtcbiAgfVxuXG4gIGRlbGV0ZUltYWdlKGltYWdlSGFzaDogc3RyaW5nKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+PiB7XG4gICAgcmV0dXJuIGRlbGV0ZUltYWdlKHRoaXMsIGltYWdlSGFzaCk7XG4gIH1cblxuICBmYXZvcml0ZUltYWdlKGltYWdlSGFzaDogc3RyaW5nKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPHN0cmluZz4+IHtcbiAgICByZXR1cm4gZmF2b3JpdGVJbWFnZSh0aGlzLCBpbWFnZUhhc2gpO1xuICB9XG5cbiAgZ2V0QWxidW0oYWxidW1IYXNoOiBzdHJpbmcpOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8QWxidW1EYXRhPj4ge1xuICAgIHJldHVybiBnZXRBbGJ1bSh0aGlzLCBhbGJ1bUhhc2gpO1xuICB9XG5cbiAgZ2V0R2FsbGVyeShvcHRpb25zOiBHYWxsZXJ5T3B0aW9ucyk6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT4+IHtcbiAgICByZXR1cm4gZ2V0R2FsbGVyeSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGdldFN1YnJlZGRpdEdhbGxlcnkoXG4gICAgb3B0aW9uczogU3VicmVkZGl0R2FsbGVyeU9wdGlvbnNcbiAgKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPEdhbGxlcnlEYXRhPj4ge1xuICAgIHJldHVybiBnZXRTdWJyZWRkaXRHYWxsZXJ5KHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc2VhcmNoR2FsbGVyeShcbiAgICBvcHRpb25zOiBTZWFyY2hHYWxsZXJ5T3B0aW9uc1xuICApOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8R2FsbGVyeURhdGE+PiB7XG4gICAgcmV0dXJuIHNlYXJjaEdhbGxlcnkodGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBnZXRJbWFnZShpbWFnZUhhc2g6IHN0cmluZyk6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+PiB7XG4gICAgcmV0dXJuIGdldEltYWdlKHRoaXMsIGltYWdlSGFzaCk7XG4gIH1cblxuICB1cGRhdGVJbWFnZShcbiAgICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuICApOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgICByZXR1cm4gdXBkYXRlSW1hZ2UodGhpcywgcGF5bG9hZCk7XG4gIH1cblxuICB1cGxvYWQoXG4gICAgcGF5bG9hZDogc3RyaW5nIHwgc3RyaW5nW10gfCBQYXlsb2FkIHwgUGF5bG9hZFtdXG4gICk6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+IHwgSW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+W10+IHtcbiAgICByZXR1cm4gdXBsb2FkKHRoaXMsIHBheWxvYWQpO1xuICB9XG59XG4iLCJleHBvcnQgY29uc3QgSU1HVVJfQVBJX1BSRUZJWCA9ICdodHRwczovL2FwaS5pbWd1ci5jb20nO1xuXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT04gPSAnMyc7XG5cbmV4cG9ydCBjb25zdCBBVVRIT1JJWkVfRU5EUE9JTlQgPSAnb2F1dGgyL2F1dGhvcml6ZSc7XG5cbmV4cG9ydCBjb25zdCBBTEJVTV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9hbGJ1bWA7XG5cbmV4cG9ydCBjb25zdCBJTUFHRV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9pbWFnZWA7XG5cbmV4cG9ydCBjb25zdCBVUExPQURfRU5EUE9JTlQgPSBgJHtBUElfVkVSU0lPTn0vdXBsb2FkYDtcblxuZXhwb3J0IGNvbnN0IEdBTExFUllfRU5EUE9JTlQgPSBgJHtBUElfVkVSU0lPTn0vZ2FsbGVyeWA7XG5cbmV4cG9ydCBjb25zdCBTVUJSRURESVRfR0FMTEVSWV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9nYWxsZXJ5L3JgO1xuXG5leHBvcnQgY29uc3QgU0VBUkNIX0dBTExFUllfRU5EUE9JTlQgPSBgJHtBUElfVkVSU0lPTn0vZ2FsbGVyeS9zZWFyY2hgO1xuIiwiaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tIFwic3RyZWFtXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzVG9rZW4ge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudElkIHtcbiAgY2xpZW50SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpbiBleHRlbmRzIENsaWVudElkIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgQ3JlZGVudGlhbHMgPSBBY2Nlc3NUb2tlbiB8IENsaWVudElkIHwgTG9naW47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FjY2Vzc1Rva2VuKGFyZzogdW5rbm93bik6IGFyZyBpcyBBY2Nlc3NUb2tlbiB7XG4gIHJldHVybiAoYXJnIGFzIEFjY2Vzc1Rva2VuKS5hY2Nlc3NUb2tlbiAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGllbnRJZChhcmc6IHVua25vd24pOiBhcmcgaXMgQ2xpZW50SWQge1xuICByZXR1cm4gKGFyZyBhcyBDbGllbnRJZCkuY2xpZW50SWQgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG9naW4oYXJnOiB1bmtub3duKTogYXJnIGlzIExvZ2luIHtcbiAgcmV0dXJuIChcbiAgICAoYXJnIGFzIExvZ2luKS5jbGllbnRJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGFyZyBhcyBMb2dpbikudXNlcm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgIChhcmcgYXMgTG9naW4pLnBhc3N3b3JkICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuaW50ZXJmYWNlIENvbW1vbkRhdGEge1xuICBpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nIHwgbnVsbDtcbiAgZGVzY3JpcHRpb246IHN0cmluZyB8IG51bGw7XG4gIGRhdGV0aW1lOiBudW1iZXI7XG4gIGxpbms6IHN0cmluZztcblxuICBhZF9jb25maWc/OiB7XG4gICAgc2FmZUZsYWdzOiBzdHJpbmdbXTtcbiAgICBoaWdoUmlza0ZsYWdzOiBzdHJpbmdbXTtcbiAgICB1bnNhZmVGbGFnczogc3RyaW5nW107XG4gICAgd2FsbFVuc2FmZUZsYWdzOiBzdHJpbmdbXTtcbiAgICBzaG93c0FkczogYm9vbGVhbjtcbiAgfTtcbiAgYWRfdHlwZTogbnVtYmVyO1xuICBhZF91cmw6IHN0cmluZztcblxuICBhY2NvdW50X3VybDogc3RyaW5nIHwgbnVsbDtcbiAgYWNjb3VudF9pZDogc3RyaW5nIHwgbnVsbDtcbiAgZmF2b3JpdGU6IGJvb2xlYW47XG4gIGlzX2FkOiBib29sZWFuO1xuICBpc19hbGJ1bTogYm9vbGVhbjtcbiAgaW5fZ2FsbGVyeTogYm9vbGVhbjtcbiAgaW5fbW9zdF92aXJhbDogYm9vbGVhbjtcbiAgbnNmdzogYm9vbGVhbiB8IG51bGw7XG4gIHNlY3Rpb246IHN0cmluZyB8IG51bGw7XG4gIHRhZ3M6IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gICAgZm9sbG93ZXJzOiBudW1iZXI7XG4gICAgdG90YWxfaXRlbXM6IG51bWJlcjtcbiAgICBmb2xsb3dpbmc6IGJvb2xlYW47XG4gICAgaXNfd2hpdGVsaXN0ZWQ6IGJvb2xlYW47XG4gICAgYmFja2dyb3VuZF9oYXNoOiBzdHJpbmc7XG4gICAgdGh1bWJuYWlsX2hhc2g6IHN0cmluZyB8IG51bGw7XG4gICAgYWNjZW50OiBzdHJpbmc7XG4gICAgYmFja2dyb3VuZF9pc19hbmltYXRlZDogYm9vbGVhbjtcbiAgICB0aHVtYm5haWxfaXNfYW5pbWF0ZWQ6IGJvb2xlYW47XG4gICAgaXNfcHJvbW90ZWQ6IGJvb2xlYW47XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBsb2dvX2hhc2g6IHN0cmluZyB8IG51bGw7XG4gICAgbG9nb19kZXN0aW5hdGlvbl91cmw6IHN0cmluZyB8IG51bGw7XG4gICAgZGVzY3JpcHRpb25fYW5ub3RhdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB9PjtcbiAgdG9waWM6IHN0cmluZyB8IG51bGw7XG4gIHRvcGljX2lkOiBzdHJpbmcgfCBudWxsO1xuICB2b3RlOiBudWxsO1xuXG4gIGNvbW1lbnRfY291bnQ6IG51bWJlciB8IG51bGw7XG4gIGZhdm9yaXRlX2NvdW50OiBudW1iZXIgfCBudWxsO1xuICB1cHM6IG51bWJlciB8IG51bGw7XG4gIGRvd25zOiBudW1iZXIgfCBudWxsO1xuICBzY29yZTogbnVtYmVyIHwgbnVsbDtcbiAgcG9pbnRzOiBudW1iZXIgfCBudWxsO1xuICB2aWV3czogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBJbWFnZURhdGEgZXh0ZW5kcyBDb21tb25EYXRhIHtcbiAgdHlwZTogc3RyaW5nO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICBkZWxldGVoYXNoPzogc3RyaW5nO1xuICBiYW5kd2lkdGg6IG51bWJlcjtcbiAgYW5pbWF0ZWQ6IGJvb2xlYW47XG4gIGhhc19zb3VuZDogYm9vbGVhbjtcbiAgZWRpdGVkOiBzdHJpbmc7XG4gIG1wNF9zaXplPzogbnVtYmVyO1xuICBtcDQ/OiBzdHJpbmc7XG4gIGdpZnY/OiBzdHJpbmc7XG4gIGhscz86IHN0cmluZztcbiAgbG9vcGluZz86IGJvb2xlYW47XG4gIHByb2Nlc3Npbmc/OiB7XG4gICAgc3RhdHVzOiAncGVuZGluZycgfCAnY29tcGxldGVkJztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbGJ1bURhdGEgZXh0ZW5kcyBDb21tb25EYXRhIHtcbiAgY292ZXI6IHN0cmluZyB8IG51bGw7XG4gIGNvdmVyX3dpZHRoOiBudW1iZXIgfCBudWxsO1xuICBjb3Zlcl9oZWlnaHQ6IG51bWJlciB8IG51bGw7XG4gIGxheW91dDogc3RyaW5nO1xuICBwcml2YWN5OiBzdHJpbmc7XG4gIGluY2x1ZGVfYWxidW1fYWRzOiBib29sZWFuO1xuICBpbWFnZXM6IEltYWdlRGF0YVtdO1xuICBpbWFnZXNfY291bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgR2FsbGVyeURhdGEgPSBBcnJheTxJbWFnZURhdGEgfCBBbGJ1bURhdGE+O1xuZXhwb3J0IGludGVyZmFjZSBQYXlsb2FkIHtcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGJhc2U2ND86IHN0cmluZztcbiAgdHlwZT86ICdzdHJlYW0nIHwgJ3VybCcgfCAnYmFzZTY0JztcbiAgbmFtZT86IHN0cmluZztcbiAgdGl0bGU/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBhbGJ1bT86IHN0cmluZztcbiAgc3RyZWFtPzogUmVhZGFibGU7XG4gIGRpc2FibGVfYXVkaW8/OiAnMScgfCAnMCc7XG59XG5leHBvcnQgaW50ZXJmYWNlIEltZ3VyQXBpUmVzcG9uc2U8XG4gIFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+W10gfCBzdHJpbmcgfCBib29sZWFuIHwgSW1hZ2VEYXRhIHwgR2FsbGVyeURhdGEgfCBBbGJ1bURhdGFcbj4ge1xuICBkYXRhOiBUO1xuICBzdGF0dXM6IG51bWJlcjtcbiAgc3VjY2VzczogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBBeGlvc1Jlc3BvbnNlIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJ2Zvcm0tZGF0YSc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlLCBQYXlsb2FkIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2U2NChwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHBheWxvYWQuYmFzZTY0ICE9PSAndW5kZWZpbmVkJyAmJiBwYXlsb2FkLnR5cGUgPT09ICdiYXNlNjQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbWFnZVVybChwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgcGF5bG9hZC5pbWFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGF5bG9hZC50eXBlID09PSAndXJsJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyZWFtKHBheWxvYWQ6IHN0cmluZyB8IFBheWxvYWQpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgcGF5bG9hZC5zdHJlYW0gIT09ICd1bmRlZmluZWQnO1xufVxuXG4vLyBUT0RPOiBSZWZhY3RvciB0aGlzIHRvIGJlIGEgdW5pcXVlIG5hbWUgb2Ygc29tZSBraW5kIChhIGhhc2g/KVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvdXJjZShwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogc3RyaW5nIHwgUmVhZGFibGUge1xuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH1cblxuICBpZiAoaXNCYXNlNjQocGF5bG9hZCkpIHtcbiAgICByZXR1cm4gXCJwYXlsb2FkLmJhc2U2NFwiIGFzIHN0cmluZztcbiAgfSBlbHNlIGlmIChpc1N0cmVhbShwYXlsb2FkKSkge1xuICAgIHJldHVybiBcInBheWxvYWQuc3RyZWFtXCIgYXMgc3RyaW5nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXlsb2FkLmltYWdlIGFzIHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9ybShwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogRm9ybURhdGEge1xuICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgIGZvcm0uYXBwZW5kKCdpbWFnZScsIHBheWxvYWQpO1xuICAgIHJldHVybiBmb3JtO1xuICB9XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGF5bG9hZCkpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcyA9IFsnYmFzZTY0JywgJ3N0cmVhbSddXG4gICAgaWYgKHN1cHBvcnRlZFVwbG9hZE9iamVjdFR5cGVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIGlmIChzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcy5pbmRleE9mKHBheWxvYWQudHlwZSBhcyBzdHJpbmcpICE9PSAtMSkge1xuICAgICAgICBmb3JtLmFwcGVuZChrZXksIHBheWxvYWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICByZXNwb25zZTogQXhpb3NSZXNwb25zZVxuKTogSW1ndXJBcGlSZXNwb25zZSB7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2UuZGF0YT8uc3RhdHVzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcmVzcG9uc2UuZGF0YT8uc3VjY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiByZXNwb25zZS5kYXRhLFxuICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgIC8vIFRPRE86IGRldGVybWluZSB0aGUgc3VjY2VzcyBvZiB0aGUgY2FsbD9cbiAgICBzdWNjZXNzOiB0cnVlLFxuICB9XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBHQUxMRVJZX0VORFBPSU5ULCBJTUdVUl9BUElfUFJFRklYIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlLCBHYWxsZXJ5RGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscyc7XG5cbmV4cG9ydCB0eXBlIENvbW1vblNlY3Rpb25Qcm9wcyA9IHtcbiAgc29ydD86ICd2aXJhbCcgfCAndG9wJyB8ICd0aW1lJztcbiAgcGFnZT86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEhvdFNlY3Rpb24gPSBDb21tb25TZWN0aW9uUHJvcHMgJiB7XG4gIHNlY3Rpb246ICdob3QnO1xufTtcblxuZXhwb3J0IHR5cGUgVG9wU2VjdGlvbiA9IENvbW1vblNlY3Rpb25Qcm9wcyAmIHtcbiAgc2VjdGlvbjogJ3RvcCc7XG4gIHdpbmRvdz86ICdkYXknIHwgJ3dlZWsnIHwgJ21vbnRoJyB8ICd5ZWFyJyB8ICdhbGwnO1xufTtcblxuZXhwb3J0IHR5cGUgVXNlclNlY3Rpb24gPSBPbWl0PENvbW1vblNlY3Rpb25Qcm9wcywgJ3NvcnQnPiAmIHtcbiAgc2VjdGlvbjogJ3VzZXInO1xuICBzb3J0PzogJ3ZpcmFsJyB8ICd0b3AnIHwgJ3RpbWUnIHwgJ3Jpc2luZyc7XG59O1xuXG5leHBvcnQgdHlwZSBTZWN0aW9uT3B0aW9ucyA9IEhvdFNlY3Rpb24gfCBUb3BTZWN0aW9uIHwgVXNlclNlY3Rpb247XG5cbmV4cG9ydCB0eXBlIFByZXNlbnRhdGlvbk9wdGlvbnMgPSB7XG4gIHNob3dWaXJhbD86IGJvb2xlYW47XG4gIG1hdHVyZT86IGJvb2xlYW47XG4gIGFsYnVtX3ByZXZpZXdzPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIEdhbGxlcnlPcHRpb25zID0gU2VjdGlvbk9wdGlvbnMgJiBQcmVzZW50YXRpb25PcHRpb25zO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogR2FsbGVyeU9wdGlvbnMgPSB7XG4gIHNlY3Rpb246ICdob3QnLFxuICBzb3J0OiAndmlyYWwnLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEdhbGxlcnlVcmwob3B0aW9uczogR2FsbGVyeU9wdGlvbnMpOiBVUkwge1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGxldCB1cmkgPSBgJHttZXJnZWRPcHRpb25zLnNlY3Rpb259YDtcblxuICBpZiAobWVyZ2VkT3B0aW9ucy5zb3J0KSB7XG4gICAgdXJpICs9IGAvJHttZXJnZWRPcHRpb25zLnNvcnR9YDtcbiAgfVxuXG4gIGlmIChtZXJnZWRPcHRpb25zLnNlY3Rpb24gPT09ICd0b3AnICYmIG1lcmdlZE9wdGlvbnMud2luZG93KSB7XG4gICAgdXJpICs9IGAvJHttZXJnZWRPcHRpb25zLndpbmRvd31gO1xuICB9XG5cbiAgaWYgKG1lcmdlZE9wdGlvbnMucGFnZSkge1xuICAgIHVyaSArPSBgLyR7bWVyZ2VkT3B0aW9ucy5wYWdlfWA7XG4gIH1cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke0lNR1VSX0FQSV9QUkVGSVh9LyR7R0FMTEVSWV9FTkRQT0lOVH0vJHt1cml9YCk7XG5cbiAgaWYgKG1lcmdlZE9wdGlvbnMuc2hvd1ZpcmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc2hvd1ZpcmFsJywgbWVyZ2VkT3B0aW9ucy5zaG93VmlyYWwudG9TdHJpbmcoKSk7XG4gIH1cblxuICBpZiAobWVyZ2VkT3B0aW9ucy5tYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdtYXR1cmUnLCBtZXJnZWRPcHRpb25zLm1hdHVyZS50b1N0cmluZygpKTtcbiAgfVxuXG4gIGlmIChtZXJnZWRPcHRpb25zLmFsYnVtX3ByZXZpZXdzICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcbiAgICAgICdhbGJ1bV9wcmV2aWV3cycsXG4gICAgICBtZXJnZWRPcHRpb25zLmFsYnVtX3ByZXZpZXdzLnRvU3RyaW5nKClcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdhbGxlcnkoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIG9wdGlvbnM6IEdhbGxlcnlPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNcbik6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT4+IHtcbiAgY29uc3QgeyBwYXRobmFtZSB9ID0gY29uc3RydWN0R2FsbGVyeVVybChvcHRpb25zKTtcbiAgLy8gc2luY2Ugd2UncmUgdXNpbmcgcHJlZml4VXJsIHdpdGggZ290LCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgc3RhcnRpbmcgc2xhc2ggb3IgaXQnbGwgdGhyb3dcbiAgY29uc3QgZmluYWxQYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDEpO1xuXG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsOiBmaW5hbFBhdGhuYW1lIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPEdhbGxlcnlEYXRhPjtcbn1cbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7XG4gIFNVQlJFRERJVF9HQUxMRVJZX0VORFBPSU5ULFxuICBJTUdVUl9BUElfUFJFRklYLFxufSBmcm9tICcuLi9jb21tb24vZW5kcG9pbnRzJztcbmltcG9ydCB7IEltZ3VyQXBpUmVzcG9uc2UsIEdhbGxlcnlEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuZXhwb3J0IHR5cGUgVGltZU9wdGlvbnMgPSB7XG4gIHN1YnJlZGRpdDogc3RyaW5nO1xuICBzb3J0PzogJ3RpbWUnO1xuICBwYWdlPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgVG9wT3B0aW9ucyA9IE9taXQ8VGltZU9wdGlvbnMsICdzb3J0Jz4gJiB7XG4gIHNvcnQ/OiAndG9wJztcbiAgd2luZG93PzogJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3llYXInIHwgJ2FsbCc7XG59O1xuXG5leHBvcnQgdHlwZSBTdWJyZWRkaXRHYWxsZXJ5T3B0aW9ucyA9IFRpbWVPcHRpb25zIHwgVG9wT3B0aW9ucztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFN1YnJlZGRpdEdhbGxlcnlVcmwoXG4gIG9wdGlvbnM6IFN1YnJlZGRpdEdhbGxlcnlPcHRpb25zXG4pOiBVUkwge1xuICBsZXQgdXJpID0gYCR7b3B0aW9ucy5zdWJyZWRkaXR9YDtcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLnNvcnR9YDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNvcnQgPT09ICd0b3AnICYmIG9wdGlvbnMud2luZG93KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLndpbmRvd31gO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucGFnZSkge1xuICAgIHVyaSArPSBgLyR7b3B0aW9ucy5wYWdlfWA7XG4gIH1cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgIGAke0lNR1VSX0FQSV9QUkVGSVh9LyR7U1VCUkVERElUX0dBTExFUllfRU5EUE9JTlR9LyR7dXJpfWBcbiAgKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3VicmVkZGl0R2FsbGVyeShcbiAgY2xpZW50OiBJbWd1ckNsaWVudCxcbiAgb3B0aW9uczogU3VicmVkZGl0R2FsbGVyeU9wdGlvbnNcbik6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT4+IHtcbiAgY29uc3QgeyBwYXRobmFtZSB9ID0gY29uc3RydWN0U3VicmVkZGl0R2FsbGVyeVVybChvcHRpb25zKTtcbiAgLy8gc2luY2Ugd2UncmUgdXNpbmcgcHJlZml4VXJsIHdpdGggZ290LCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgc3RhcnRpbmcgc2xhc2ggb3IgaXQnbGwgdGhyb3dcbiAgY29uc3QgZmluYWxQYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDEpO1xuXG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsOiBmaW5hbFBhdGhuYW1lIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPEdhbGxlcnlEYXRhPjtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vZ2V0R2FsbGVyeSc7XG5leHBvcnQgKiBmcm9tICcuL2dldFN1YnJlZGRpdEdhbGxlcnknO1xuZXhwb3J0ICogZnJvbSAnLi9zZWFyY2hHYWxsZXJ5JztcbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IFNFQVJDSF9HQUxMRVJZX0VORFBPSU5ULCBJTUdVUl9BUElfUFJFRklYIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlLCBHYWxsZXJ5RGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5cbmV4cG9ydCB0eXBlIFNlYXJjaE9wdGlvbnMgPSB7XG4gIHE/OiBzdHJpbmc7XG4gIHF1ZXJ5Pzogc3RyaW5nO1xuICBzb3J0PzogJ3RpbWUnIHwgJ3ZpcmFsJztcbiAgcGFnZT86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFRvcFNlYXJjaE9wdGlvbnMgPSBPbWl0PFNlYXJjaE9wdGlvbnMsICdzb3J0Jz4gJiB7XG4gIHNvcnQ/OiAndG9wJztcbiAgd2luZG93PzogJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3llYXInIHwgJ2FsbCc7XG59O1xuXG5leHBvcnQgdHlwZSBBZHZhbmNlZFNlYXJjaFF1ZXJ5UGFyYW1ldGVycyA9IHtcbiAgcV9hbGw/OiBzdHJpbmc7XG4gIHFfYW55Pzogc3RyaW5nO1xuICBxX2V4YWN0bHk/OiBzdHJpbmc7XG4gIHFfbm90Pzogc3RyaW5nO1xuICBxX3R5cGU/OiAnanBnJyB8ICdwbmcnIHwgJ2dpZicgfCAnYW5pZ2lmJyB8ICdhbGJ1bSc7XG4gIHFfc2l6ZV9weD86ICdzbWFsbCcgfCAnbWVkJyB8ICdiaWcnIHwgJ2xyZycgfCAnaHVnZSc7XG59O1xuXG5jb25zdCBhZHZhbmNlZFBhcmFtZXRlcnM6IEFycmF5PGtleW9mIEFkdmFuY2VkU2VhcmNoUXVlcnlQYXJhbWV0ZXJzPiA9IFtcbiAgJ3FfYWxsJyxcbiAgJ3FfYW55JyxcbiAgJ3FfZXhhY3RseScsXG4gICdxX25vdCcsXG4gICdxX3R5cGUnLFxuICAncV9zaXplX3B4Jyxcbl07XG5cbmV4cG9ydCB0eXBlIFNlYXJjaEdhbGxlcnlPcHRpb25zID0gKFNlYXJjaE9wdGlvbnMgfCBUb3BTZWFyY2hPcHRpb25zKSAmXG4gIEFkdmFuY2VkU2VhcmNoUXVlcnlQYXJhbWV0ZXJzO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0U2VhcmNoR2FsbGVyeVVybChvcHRpb25zOiBTZWFyY2hHYWxsZXJ5T3B0aW9ucyk6IFVSTCB7XG4gIGxldCB1cmkgPSAnJztcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLnNvcnR9YDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNvcnQgPT09ICd0b3AnICYmIG9wdGlvbnMud2luZG93KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLndpbmRvd31gO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucGFnZSkge1xuICAgIHVyaSArPSBgLyR7b3B0aW9ucy5wYWdlfWA7XG4gIH1cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke0lNR1VSX0FQSV9QUkVGSVh9LyR7U0VBUkNIX0dBTExFUllfRU5EUE9JTlR9JHt1cml9YCk7XG5cbiAgYWR2YW5jZWRQYXJhbWV0ZXJzLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgaWYgKG9wdGlvbnNbcGFyYW1dPy5sZW5ndGgpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKHBhcmFtLCBvcHRpb25zW3BhcmFtXSBhcyBzdHJpbmcpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCF1cmwuc2VhcmNoKSB7XG4gICAgY29uc3QgcXVlcnkgPSBvcHRpb25zLnEgfHwgb3B0aW9ucy5xdWVyeTtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHF1ZXJ5IHdhcyBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdxJywgcXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaEdhbGxlcnkoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIG9wdGlvbnM6IFNlYXJjaEdhbGxlcnlPcHRpb25zXG4pOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8R2FsbGVyeURhdGE+PiB7XG4gIGNvbnN0IHsgcGF0aG5hbWUgfSA9IGNvbnN0cnVjdFNlYXJjaEdhbGxlcnlVcmwob3B0aW9ucyk7XG4gIC8vIHNpbmNlIHdlJ3JlIHVzaW5nIHByZWZpeFVybCB3aXRoIGdvdCwgd2UgaGF2ZSB0byByZW1vdmUgdGhlIHN0YXJ0aW5nIHNsYXNoIG9yIGl0J2xsIHRocm93XG4gIGNvbnN0IGZpbmFsUGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgxKTtcblxuICByZXR1cm4gZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybDogZmluYWxQYXRobmFtZSB9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT47XG59XG4iLCJpbXBvcnQge1xuICBBY2Nlc3NUb2tlbixcbiAgaXNBY2Nlc3NUb2tlbixcbiAgaXNDbGllbnRJZCxcbiAgaXNMb2dpbixcbn0gZnJvbSAnLi9jb21tb24vdHlwZXMnO1xuaW1wb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuL2NsaWVudCc7XG5pbXBvcnQgeyBJTUdVUl9BUElfUFJFRklYLCBBVVRIT1JJWkVfRU5EUE9JTlQgfSBmcm9tICcuL2NvbW1vbi9lbmRwb2ludHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aG9yaXphdGlvbkhlYWRlcihcbiAgY2xpZW50OiBJbWd1ckNsaWVudFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgaWYgKGlzQWNjZXNzVG9rZW4oY2xpZW50LmNyZWRlbnRpYWxzKSkge1xuICAgIHJldHVybiBgQmVhcmVyICR7Y2xpZW50LmNyZWRlbnRpYWxzLmFjY2Vzc1Rva2VufWA7XG4gIH1cblxuICBpZiAoaXNDbGllbnRJZChjbGllbnQuY3JlZGVudGlhbHMpICYmICFpc0xvZ2luKGNsaWVudC5jcmVkZW50aWFscykpIHtcbiAgICByZXR1cm4gYENsaWVudC1JRCAke2NsaWVudC5jcmVkZW50aWFscy5jbGllbnRJZH1gO1xuICB9XG5cbiAgY29uc3QgeyBjbGllbnRJZCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjbGllbnQuY3JlZGVudGlhbHM7XG5cbiAgY29uc3Qgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7XG4gICAgdXJsOiBBVVRIT1JJWkVfRU5EUE9JTlQsXG4gICAgYmFzZVVSTDogSU1HVVJfQVBJX1BSRUZJWCxcbiAgICBwYXJhbXM6IHtcbiAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICByZXNwb25zZV90eXBlOiAndG9rZW4nLFxuICAgIH0sXG4gIH07XG5cbiAgbGV0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBsYWluUmVxdWVzdChvcHRpb25zKTtcblxuICBjb25zdCBjb29raWVzID0gQXJyYXkuaXNBcnJheShyZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10pXG4gICAgPyByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ11bMF1cbiAgICA6IHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXTtcblxuICBpZiAoIWNvb2tpZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb2tpZXMgd2VyZSBzZXQgZHVyaW5nIGF1dGhvcml6YXRpb24nKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSBjb29raWVzLm1hdGNoKCcoXnw7KVtzXSphdXRob3JpemVfdG9rZW49KFteO10qKScpO1xuXG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGF1dGhvcml6ZV90b2tlbiBjb29raWUnKTtcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml6ZVRva2VuID0gbWF0Y2hlc1syXTtcblxuICBvcHRpb25zLm1ldGhvZCA9ICdQT1NUJztcbiAgb3B0aW9ucy5kYXRhID0ge1xuICAgIHVzZXJuYW1lLFxuICAgIHBhc3N3b3JkLFxuICAgIGFsbG93OiBhdXRob3JpemVUb2tlbixcbiAgfTtcblxuICBvcHRpb25zLmZvbGxvd1JlZGlyZWN0ID0gZmFsc2U7XG4gIG9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICBjb29raWU6IGBhdXRob3JpemVfdG9rZW49JHthdXRob3JpemVUb2tlbn1gLFxuICB9O1xuXG4gIHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBsYWluUmVxdWVzdChvcHRpb25zKTtcbiAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgbG9jYXRpb24nKTtcbiAgfVxuXG4gIGNvbnN0IHRva2VuID0gSlNPTi5wYXJzZShcbiAgICAne1wiJyArXG4gICAgICBkZWNvZGVVUkkobG9jYXRpb24uc2xpY2UobG9jYXRpb24uaW5kZXhPZignIycpICsgMSkpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgJ1wiLFwiJylcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJ1wiOlwiJykgK1xuICAgICAgJ1wifSdcbiAgKTtcblxuICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRva2VuLmFjY2Vzc190b2tlbjtcbiAgKChjbGllbnQuY3JlZGVudGlhbHMgYXMgdW5rbm93bikgYXMgQWNjZXNzVG9rZW4pLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gIFxuICByZXR1cm4gYEJlYXJlciAke2FjY2Vzc1Rva2VufWA7XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHsgSW1ndXJBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUltYWdlKFxuICBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+PiB7XG4gIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke2ltYWdlSGFzaH1gO1xuICByZXR1cm4gZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnREVMRVRFJyB9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTxib29sZWFuPjtcbn1cbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7IGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmF2b3JpdGVJbWFnZShcbiAgY2xpZW50OiBJbWd1ckNsaWVudCxcbiAgaW1hZ2VIYXNoOiBzdHJpbmdcbik6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTwnZmF2b3JpdGVkJz4+IHtcbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofS9mYXZvcml0ZWA7XG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsLCBtZXRob2Q6ICdQT1NUJyB9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTwnZmF2b3JpdGVkJz47XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHsgSW1ndXJBcGlSZXNwb25zZSwgSW1hZ2VEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7IGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2UoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIGltYWdlSGFzaDogc3RyaW5nXG4pOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8SW1hZ2VEYXRhPj4ge1xuICBjb25zdCB1cmwgPSBgJHtJTUFHRV9FTkRQT0lOVH0vJHtpbWFnZUhhc2h9YDtcbiAgcmV0dXJuIGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwgfSkpIGFzIEltZ3VyQXBpUmVzcG9uc2U8SW1hZ2VEYXRhPlxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9kZWxldGVJbWFnZSc7XG5leHBvcnQgKiBmcm9tICcuL2Zhdm9yaXRlSW1hZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi9nZXRJbWFnZSc7XG5leHBvcnQgKiBmcm9tICcuL3VwZGF0ZUltYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vdXBsb2FkJztcbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBjcmVhdGVGb3JtLCBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7IFBheWxvYWQsIEltZ3VyQXBpUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUltYWdlUGF5bG9hZFxuICBleHRlbmRzIFBpY2s8UGF5bG9hZCwgJ3RpdGxlJyB8ICdkZXNjcmlwdGlvbic+IHtcbiAgaW1hZ2VIYXNoOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRVcGRhdGVQYXlsb2FkKHA6IFVwZGF0ZUltYWdlUGF5bG9hZCkge1xuICByZXR1cm4gdHlwZW9mIHAudGl0bGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwLmRlc2NyaXB0aW9uID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUltYWdlKFxuICBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+IHwgSW1ndXJBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBwYXlsb2FkLm1hcCgocDogVXBkYXRlSW1hZ2VQYXlsb2FkKSA9PiB7XG4gICAgICBpZiAoIWlzVmFsaWRVcGRhdGVQYXlsb2FkKHApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIHJlcXVpcmVzIGEgdGl0bGUgYW5kL29yIGRlc2NyaXB0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke3AuaW1hZ2VIYXNofWA7XG4gICAgICBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgICAgIC8qIGVzbGludCBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yOiAwICovXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICAgICAgLy8gcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAgICAgICAgIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+KVxuICAgICAgICB9KSBhcyBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8Ym9vbGVhbj4+O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZFVwZGF0ZVBheWxvYWQocGF5bG9hZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpO1xuICB9XG5cbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7cGF5bG9hZC5pbWFnZUhhc2h9YDtcbiAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocGF5bG9hZCk7XG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICB1cmwsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgZGF0YTogZm9ybSxcbiAgICAvLyByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQge1xuICBjcmVhdGVGb3JtLFxuICBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlLFxuICAvLyBnZXRTb3VyY2UsXG59IGZyb20gJy4uL2NvbW1vbi91dGlscyc7XG5pbXBvcnQgeyBQYXlsb2FkLCBJbWd1ckFwaVJlc3BvbnNlLCBJbWFnZURhdGEgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuaW1wb3J0IHsgVVBMT0FEX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWQoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIHBheWxvYWQ6IHN0cmluZyB8IHN0cmluZ1tdIHwgUGF5bG9hZCB8IFBheWxvYWRbXVxuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPEltYWdlRGF0YT4gfCBJbWd1ckFwaVJlc3BvbnNlPEltYWdlRGF0YT5bXT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHA6IHN0cmluZyB8IFBheWxvYWQpID0+IHtcbiAgICAgIGNvbnN0IGZvcm0gPSBjcmVhdGVGb3JtKHApO1xuXG4gICAgICAvKiBlc2xpbnQgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvcjogMCAqL1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmUoZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgdXJsOiBVUExPQURfRU5EUE9JTlQsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAocHJvZ3Jlc3NFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsgcHJvZ3Jlc3NFdmVudCB9KTtcbiAgICAgICAgICAgICAgICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzRXZlbnQgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkgYXMgSW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+KTtcbiAgICAgIH0pIGFzIFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+PjtcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocGF5bG9hZCk7XG4gIC8vIGNvbnN0IGlkID0gRGF0ZS5ub3cudG9TdHJpbmcoKTtcbiAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICB1cmw6IFVQTE9BRF9FTkRQT0lOVCxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBkYXRhOiBmb3JtLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyh7IHByb2dyZXNzRXZlbnQgfSk7XG4gICAgICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzRXZlbnQgfSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKHJlcXVlc3QpIGFzIEltZ3VyQXBpUmVzcG9uc2U8SW1hZ2VEYXRhPlxuICApO1xufVxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vc3VwcG9ydC90eXBlcycpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gaGFzU3ltYm9scyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdsb2JhbFt0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIGFyciA9IG5ldyBnbG9iYWxbdHlwZWRBcnJheV0oKTtcblx0XHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFdmFsRXJyb3IoJ3RoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCAnICsgdHlwZWRBcnJheSArICcgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy4nKTtcblx0XHRcdH1cblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmROYW1lID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0dGVyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kTmFtZSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kTmFtZTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiZXhwb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuL2NsaWVudCc7XG4iXSwic291cmNlUm9vdCI6IiJ9


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BikeTagClient": () => (/* reexport safe */ _client__WEBPACK_IMPORTED_MODULE_0__.BikeTagClient)
/* harmony export */ });
/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client */ "./src/client.ts");


})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtldGFnLWFwaS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHJleHhhcnMvZXZlbnRzb3VyY2UtcG9seWZpbGwvc3JjL2V2ZW50c291cmNlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9hc3NldHMvYXNzZXRzQ2xpZW50LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9hdXRoL2F1dGhDbGllbnQuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvZGF0YS9kYXRhTWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvZGF0YS9lbmNvZGVRdWVyeVN0cmluZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvZGF0YS9saXN0ZW4uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2RhdGEvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2RhdGEvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2RhdGFzZXRzL2RhdGFzZXRzQ2xpZW50LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9odHRwL2Jyb3dzZXJNaWRkbGV3YXJlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9odHRwL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvaHR0cC9xdWVyeVN0cmluZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvaHR0cC9yZXF1ZXN0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9odHRwL3JlcXVlc3RPcHRpb25zLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9wcm9qZWN0cy9wcm9qZWN0c0NsaWVudC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvc2FuaXR5Q2xpZW50LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi91c2Vycy91c2Vyc0NsaWVudC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvdXRpbC9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvdXRpbC9nZXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL3V0aWwvb25jZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvdXRpbC9waWNrLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi92YWxpZGF0b3JzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi93YXJuaW5ncy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9nZW5lcmF0ZS1oZWxwLXVybC9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L29ic2VydmFibGUvbGliL1Nhbml0eU9ic2VydmFibGVNaW5pbWFsLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9taW5pbWFsLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvZmlsdGVyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvbWFwLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvcmVkdWNlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2FycmF5LWZpbHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvYXNzZXJ0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9kZWVwLWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9lczYtb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2xpYi9taWRkbGV3YXJlL2RlZmF1bHRPcHRpb25zUHJvY2Vzc29yLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvbWlkZGxld2FyZS9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL21pZGRsZXdhcmUvanNvblJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2xpYi9taWRkbGV3YXJlL2pzb25SZXNwb25zZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL21pZGRsZXdhcmUvb2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL21pZGRsZXdhcmUvcHJvZ3Jlc3MvYnJvd3Nlci1wcm9ncmVzcy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL21pZGRsZXdhcmUvcHJvZ3Jlc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2xpYi9yZXF1ZXN0L2Jyb3dzZXItcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL3JlcXVlc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2xpYi91dGlsL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL3V0aWwvbWlkZGxld2FyZVJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaXMtbmFuL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaXMtbmFuL3NoaW0uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaXMtb2JqL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pc29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9tYWtlLWVycm9yL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL25hbm8tcHVic3ViL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yZXF1aXJlcy1wb3J0L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL09ic2VydmVyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL1N1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL29ic2VydmFibGUvZW1wdHkuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVmYXVsdElmRW1wdHkuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvb3BlcmF0b3JzL21hcC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2Nhbi5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL29wZXJhdG9ycy90YWtlTGFzdC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvc3ltYm9sL3J4U3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC91dGlsL2NhblJlcG9ydEVycm9yLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvdXRpbC9ob3N0UmVwb3J0RXJyb3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvdXRpbC9pc0FycmF5LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvdXRpbC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL3V0aWwvcGlwZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL3V0aWwvdG9TdWJzY3JpYmVyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3NhbWUtb3JpZ2luL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3NhbWUtb3JpZ2luL3VybC1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvYmlrZXRhZy9kZWxldGVUYWcudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvYmlrZXRhZy9mYXZvcml0ZUltYWdlLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2Jpa2V0YWcvZ2V0VGFnLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2Jpa2V0YWcvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvYmlrZXRhZy9xdWV1ZVRhZ0ltYWdlLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2Jpa2V0YWcvdXBkYXRlVGFnLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2Jpa2V0YWcvdXBkYXRlVGFnSW1hZ2UudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvY2xpZW50LnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2NvbW1vbi9kYXRhLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvY29tbW9uL21ldGhvZHMudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvaW1ndXIvZGVsZXRlVGFnLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2ltZ3VyL2dldFRhZy50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9pbWd1ci9pbmRleC50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9pbWd1ci91cGRhdGVUYWcudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvaW1ndXIvdXBsb2FkVGFnSW1hZ2UudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvc2FuaXR5L2RlbGV0ZVRhZy50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9zYW5pdHkvZ2V0VGFnLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL3Nhbml0eS9pbmRleC50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9zYW5pdHkvdXBkYXRlVGFnLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL3Nhbml0eS91cGxvYWRUYWdJbWFnZS50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9pbWd1ckNsaWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2Jpa2V0YWctYXBpL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ3ZCLEdBQUcsTUFBTSxzQkFXTjtBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPLDJCQUEyQixPQUFPO0FBQzFEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9lQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUEsOEVBQThFLHFDQUFxQyxFQUFFOztBQUVySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkRhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLHdFQUFrQjs7QUFFL0M7Ozs7Ozs7Ozs7OztBQ0phOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0NBQStDO0FBQ2hGLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsRUFBRTtBQUNGLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsd0RBQWE7O0FBRXRDLHNEQUFzRCxvQkFBb0IsR0FBRzs7QUFFN0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxFQUFFO0FBQ0YsZ0RBQWdEO0FBQ2hELEVBQUU7QUFDRixzREFBc0Q7QUFDdEQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyw0REFBZTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsNENBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pVQSw0RkFBc0M7Ozs7Ozs7Ozs7OztBQ0F6Qjs7QUFFYixhQUFhLG1CQUFPLENBQUMsd0RBQWE7QUFDbEMsd0JBQXdCLG1CQUFPLENBQUMscUZBQTBCO0FBQzFELHFCQUFxQixtQkFBTyxDQUFDLDZHQUFzQztBQUNuRSxzQkFBc0IsbUJBQU8sQ0FBQyw2R0FBc0M7QUFDcEUsa0JBQWtCLG1CQUFPLENBQUMsNkRBQVcsRUFBRTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7OztBQ3JJYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw0REFBZTtBQUMxQyxlQUFlLG1CQUFPLENBQUMsb0RBQVc7O0FBRWxDOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLHlEQUF5RCxZQUFZLG1DQUFtQzs7QUFFeEc7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUQ7Ozs7Ozs7Ozs7O0FDbEZhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRDs7Ozs7Ozs7Ozs7QUNUYTs7QUFFYixvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVEsbUJBQW1CLG1CQUFPLENBQUMsNERBQWU7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsZ0VBQWlCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVDOzs7Ozs7Ozs7OztBQ3BDYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw0REFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsYUFBYSxnQ0FBZ0M7QUFDekUsS0FBSzs7QUFFTDtBQUNBLDRCQUE0QjtBQUM1QiwrQkFBK0IsNkJBQTZCO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7Ozs7O0FDaENhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsNERBQWU7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEUsU0FBUztBQUNUO0FBQ0Esc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7Ozs7O0FDbkNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7Ozs7Ozs7Ozs7QUNuQ2E7O0FBRWIsZ0lBQTJDO0FBQzNDLGlDOzs7Ozs7Ozs7OztBQ0hhOztBQUViO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsd0RBQWE7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQWU7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxxRUFBcUU7O0FBRTdHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDOzs7Ozs7Ozs7OztBQ3ZOYTs7QUFFYixrSEFBMEM7QUFDMUMsaUM7Ozs7Ozs7Ozs7O0FDSGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUIscUJBQU07QUFDeEIsbUJBQW1CLHFCQUFNO0FBQ3pCLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0M7Ozs7Ozs7Ozs7O0FDWmE7O0FBRWI7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7Ozs7O0FDekJhOztBQUViO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsb0RBQVM7O0FBRXJDO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsb0NBQW9DLGNBQWM7QUFDbEQsNkNBQTZDLGNBQWM7QUFDM0QseUNBQXlDLGNBQWM7O0FBRXZEO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1phOztBQUViO0FBQ0E7QUFDQSwwRkFBMEYsY0FBYztBQUN4RywyQ0FBMkMsYUFBYTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7O0FBRTdDLGlFQUFpRSxjQUFjO0FBQy9FLG9FQUFvRSxjQUFjOztBQUVsRjtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0Esc0NBQXNDLGNBQWM7O0FBRXBELDBEQUEwRCxjQUFjO0FBQ3hFLDhEQUE4RCxjQUFjOztBQUU1RTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWMsRUFBRTtBQUNuQywwRUFBMEUsY0FBYzs7QUFFeEYsd0dBQXdHLGNBQWM7O0FBRXRIO0FBQ0EsNENBQTRDLGNBQWM7O0FBRTFELDZEQUE2RCxjQUFjOztBQUUzRTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDekNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyw0REFBZTs7QUFFbEM7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUJhOztBQUViO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQXFCOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwREFBMEQ7O0FBRTFEOzs7Ozs7Ozs7Ozs7QUNoQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9CYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ05hOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQyxhQUFhLG1CQUFPLENBQUMsb0VBQW1COztBQUV4QyxxQkFBcUIsbUJBQU8sQ0FBQyxpRUFBa0I7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMscURBQVk7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLDZDQUFROztBQUUzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7OztBQ25CYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxpRUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDVGE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLG9FQUFtQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxxREFBWTs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2ZhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsa0RBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsMkJBQTJCLG1CQUFPLENBQUMsOEVBQXdCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFxQjs7QUFFN0M7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxvSEFBOEM7QUFDakUsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBOzs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDWEE7O0FBRWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7Ozs7Ozs7Ozs7QUN0SmpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pGYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxvRUFBbUI7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLG9EQUFXOztBQUVsQyxxQkFBcUIsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsd0RBQVk7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLGdEQUFROztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7OztBQ2pCYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxvRUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDTmE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsd0RBQVk7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFtQjs7QUFFeEM7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7Ozs7Ozs7QUNiYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdFQUFlLEVBQUU7QUFDdkM7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNELHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekhhOztBQUViO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGdFQUFlOztBQUVwQztBQUNBLDRDQUE0QyxvQkFBb0IsRUFBRSxHQUFHLG1CQUFPLENBQUMsc0VBQWtCOztBQUUvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUMvQmE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQy9CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7QUN2THpCOztBQUViO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7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O0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQW1CO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QixzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxhQUFhO0FBQ2IsNERBQTREO0FBQzVELGFBQWE7QUFDYixrRUFBa0U7QUFDbEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUNBQW1CO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBbUI7QUFDcEU7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxpQ0FBbUI7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxpQ0FBbUI7QUFDdkQ7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBbUI7QUFDbkQ7QUFDQTtBQUNBLDZCQUE2QixpQ0FBbUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBbUI7QUFDcEUsa0RBQWtELGlDQUFtQjtBQUNyRTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFtQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixLQUFLOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQW1CO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsaUNBQW1CO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBLDZCQUE2QixpQ0FBbUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QjtBQUN2QixlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBLHFCQUFxQixpQ0FBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsMkNBQTJDLGNBQWM7Ozs7Ozs7VUMzL1d6RDtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0EsQ0FBQyxJOzs7OztXQ1BELHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRCxrQkFBa0I7V0FDeEU7V0FDQSwrQ0FBK0MsY0FBYztXQUM3RCxFOzs7Ozs7Ozs7Ozs7Ozs7O0FDTnlDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdC8vQ29tbW9uSlMyIENvbW1lbnRcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHQvL0FNRCBDb21tZW50XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdC8vQ29tbW9uSlMgQ29tbWVudFxuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYmlrZXRhZ1wiXSA9IGZhY3RvcnkoKTtcblx0Ly9Sb290IENvbW1lbnRcblx0ZWxzZVxuXHRcdHJvb3RbXCJiaWtldGFnXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIi8qXG4gKiBFdmVudFNvdXJjZSBwb2x5ZmlsbFxuICogT3JpZ2luYWxseSBwdWJsaXNoZWQgYnkgc2MgQW12VGVrIHNybCAoaHR0cHM6Ly9naXRodWIuY29tL2FtdnRlay9FdmVudFNvdXJjZSkgLSBkZXZlbEBhbXZ0ZWsuY29tXG4gKiBGb3JrZWQgYnkgRXNwZW4gSG92bGFuZHNkYWwgdG8gZml4IGEgZmV3IGlzc3VlcyArIHB1Ymxpc2ggbGF0ZXN0IHZlcnNpb25cbiAqL1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIC8qIGdsb2JhbCBkZWZpbmUgKi9cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZShbXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgIGlmIChnbG9iYWwuRXZlbnRTb3VyY2UgJiYgIWdsb2JhbC5fZXZlbnRTb3VyY2VJbXBvcnRQcmVmaXgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBldnNJbXBvcnROYW1lID0gKHJvb3QuX2V2ZW50U291cmNlSW1wb3J0UHJlZml4IHx8ICcnKSArICdFdmVudFNvdXJjZSdcbiAgICByb290W2V2c0ltcG9ydE5hbWVdID0gZmFjdG9yeSgpXG4gIH1cbn0pKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyA/IHRoaXMgOiBzZWxmLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBFdmVudFNvdXJjZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJylcbiAgICB9XG5cbiAgICB0aGlzLlVSTCA9IHVybFxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKVxuICAgIHZhciBldnMgPSB0aGlzXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBldnMucG9sbCgpXG4gICAgfSwgMClcbiAgfVxuXG4gIEV2ZW50U291cmNlLnByb3RvdHlwZSA9IHtcbiAgICBDT05ORUNUSU5HOiAwLFxuXG4gICAgT1BFTjogMSxcblxuICAgIENMT1NFRDogMixcblxuICAgIGRlZmF1bHRPcHRpb25zOiB7XG4gICAgICBsb2dnaW5nRW5hYmxlZDogZmFsc2UsXG5cbiAgICAgIGxvZ2dpbmdQcmVmaXg6ICdldmVudHNvdXJjZScsXG5cbiAgICAgIGludGVydmFsOiA1MDAsIC8vIG1pbGxpc2Vjb25kc1xuXG4gICAgICBidWZmZXJTaXplTGltaXQ6IDI1NiAqIDEwMjQsIC8vIGJ5dGVzXG5cbiAgICAgIHNpbGVudFRpbWVvdXQ6IDMwMDAwMCwgLy8gbWlsbGlzZWNvbmRzXG5cbiAgICAgIGdldEFyZ3M6IHtcbiAgICAgICAgZXZzX2J1ZmZlcl9zaXplX2xpbWl0OiAyNTYgKiAxMDI0LFxuICAgICAgfSxcblxuICAgICAgeGhySGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICd0ZXh0L2V2ZW50LXN0cmVhbScsXG4gICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuZGVmYXVsdE9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25cblxuICAgICAgLy8gc2V0IGFsbCBkZWZhdWx0IG9wdGlvbnMuLi5cbiAgICAgIGZvciAob3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgdGhpc1tvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHdpdGggd2hhdCBpcyBpbiBvcHRpb25zXG4gICAgICBmb3IgKG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb24gaW4gZGVmYXVsdHMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgdGhpc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgZ2V0QXJncyBvcHRpb24gaXMgZW5hYmxlZFxuICAgICAgLy8gZW5zdXJlIGV2c19idWZmZXJfc2l6ZV9saW1pdCBjb3JyZXNwb25kcyB0byBidWZmZXJTaXplTGltaXRcbiAgICAgIGlmICh0aGlzLmdldEFyZ3MgJiYgdGhpcy5idWZmZXJTaXplTGltaXQpIHtcbiAgICAgICAgdGhpcy5nZXRBcmdzLmV2c19idWZmZXJfc2l6ZV9saW1pdCA9IHRoaXMuYnVmZmVyU2l6ZUxpbWl0XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGNvbnNvbGUgaXMgbm90IGF2YWlsYWJsZSwgZm9yY2UgbG9nZ2luZ0VuYWJsZWQgdG8gZmFsc2VcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sb2dnaW5nRW5hYmxlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGxvZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLmxvZ2dpbmdFbmFibGVkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKCdbJyArIHRoaXMubG9nZ2luZ1ByZWZpeCArICddOicgKyBtZXNzYWdlKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09IHRoaXMuQ0xPU0VEKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFudXAoKVxuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLkNPTk5FQ1RJTkdcbiAgICAgICAgdGhpcy5jdXJzb3IgPSAwXG4gICAgICAgIHRoaXMuY2FjaGUgPSAnJ1xuICAgICAgICB0aGlzLl94aHIgPSBuZXcgdGhpcy5YSFIodGhpcylcbiAgICAgICAgdGhpcy5yZXNldE5vQWN0aXZpdHlUaW1lcigpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaW4gYW4gYXR0ZW1wdCB0byBzaWxlbmNlIHRoZSBlcnJvcnNcbiAgICAgICAgdGhpcy5sb2coJ1RoZXJlIHdlcmUgZXJyb3JzIGluc2lkZSB0aGUgcG9vbCB0cnktY2F0Y2gnKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Vycm9yJywge3R5cGU6ICdlcnJvcicsIGRhdGE6IGVyci5tZXNzYWdlfSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9sbEFnYWluOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgIC8vIHNjaGVkdWxlIHBvbGwgdG8gYmUgY2FsbGVkIGFmdGVyIGludGVydmFsIG1pbGxpc2Vjb25kc1xuICAgICAgdmFyIGV2cyA9IHRoaXNcbiAgICAgIGV2cy5yZWFkeVN0YXRlID0gZXZzLkNPTk5FQ1RJTkdcbiAgICAgIGV2cy5kaXNwYXRjaEV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgZGF0YTogJ1JlY29ubmVjdGluZyAnLFxuICAgICAgfSlcbiAgICAgIHRoaXMuX3BvbGxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBldnMucG9sbCgpXG4gICAgICB9LCBpbnRlcnZhbCB8fCAwKVxuICAgIH0sXG5cbiAgICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxvZygnZXZzIGNsZWFuaW5nIHVwJylcblxuICAgICAgaWYgKHRoaXMuX3BvbGxUaW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxUaW1lcilcbiAgICAgICAgdGhpcy5fcG9sbFRpbWVyID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbm9BY3Rpdml0eVRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbm9BY3Rpdml0eVRpbWVyKVxuICAgICAgICB0aGlzLl9ub0FjdGl2aXR5VGltZXIgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl94aHIpIHtcbiAgICAgICAgdGhpcy5feGhyLmFib3J0KClcbiAgICAgICAgdGhpcy5feGhyID0gbnVsbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldE5vQWN0aXZpdHlUaW1lcjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuc2lsZW50VGltZW91dCkge1xuICAgICAgICBpZiAodGhpcy5fbm9BY3Rpdml0eVRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9ub0FjdGl2aXR5VGltZXIpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2cyA9IHRoaXNcbiAgICAgICAgdGhpcy5fbm9BY3Rpdml0eVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZXZzLmxvZygnVGltZW91dCEgc2lsZW50VEltZW91dDonICsgZXZzLnNpbGVudFRpbWVvdXQpXG4gICAgICAgICAgZXZzLnBvbGxBZ2FpbigpXG4gICAgICAgIH0sIHRoaXMuc2lsZW50VGltZW91dClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuQ0xPU0VEXG4gICAgICB0aGlzLmxvZygnQ2xvc2luZyBjb25uZWN0aW9uLiByZWFkeVN0YXRlOiAnICsgdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgdGhpcy5jbGVhbnVwKClcbiAgICB9LFxuXG4gICAgX29ueGhyZGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLl94aHJcblxuICAgICAgaWYgKHJlcXVlc3QuaXNSZWFkeSgpICYmICFyZXF1ZXN0Lmhhc0Vycm9yKCkpIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHRpbWVyLCBhcyB3ZSBoYXZlIGFjdGl2aXR5XG4gICAgICAgIHRoaXMucmVzZXROb0FjdGl2aXR5VGltZXIoKVxuXG4gICAgICAgIC8vIG1vdmUgdGhpcyBFdmVudFNvdXJjZSB0byBPUEVOIHN0YXRlLi4uXG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gdGhpcy5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5PUEVOXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdvcGVuJywge3R5cGU6ICdvcGVuJ30pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVmZmVyID0gcmVxdWVzdC5nZXRCdWZmZXIoKVxuXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gdGhpcy5idWZmZXJTaXplTGltaXQpIHtcbiAgICAgICAgICB0aGlzLmxvZygnYnVmZmVyLmxlbmd0aCA+IHRoaXMuYnVmZmVyU2l6ZUxpbWl0JylcbiAgICAgICAgICB0aGlzLnBvbGxBZ2FpbigpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJzb3IgPT0gMCAmJiBidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHNraXAgYnl0ZSBvcmRlciBtYXJrIFxcdUZFRkYgY2hhcmFjdGVyIGlmIGl0IHN0YXJ0cyB0aGUgc3RyZWFtXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJzdHJpbmcoMCwgMSkgPT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdE1lc3NhZ2VJbmRleCA9IHRoaXMubGFzdE1lc3NhZ2VJbmRleChidWZmZXIpXG4gICAgICAgIGlmIChsYXN0TWVzc2FnZUluZGV4WzBdID49IHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgdmFyIG5ld2N1cnNvciA9IGxhc3RNZXNzYWdlSW5kZXhbMV1cbiAgICAgICAgICB2YXIgdG9wYXJzZSA9IGJ1ZmZlci5zdWJzdHJpbmcodGhpcy5jdXJzb3IsIG5ld2N1cnNvcilcbiAgICAgICAgICB0aGlzLnBhcnNlU3RyZWFtKHRvcGFyc2UpXG4gICAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXdjdXJzb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHJlcXVlc3QgaXMgZmluaXNoZWQsIHJlb3BlbiB0aGUgY29ubmVjdGlvblxuICAgICAgICBpZiAocmVxdWVzdC5pc0RvbmUoKSkge1xuICAgICAgICAgIHRoaXMubG9nKCdyZXF1ZXN0LmlzRG9uZSgpLiByZW9wZW5pbmcgdGhlIGNvbm5lY3Rpb24nKVxuICAgICAgICAgIHRoaXMucG9sbEFnYWluKHRoaXMuaW50ZXJ2YWwpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLkNMT1NFRCkge1xuICAgICAgICB0aGlzLmxvZygndGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLkNMT1NFRCcpXG4gICAgICAgIHRoaXMucG9sbEFnYWluKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICAgICAgLy9NVjogVW5zdXJlIHdoeSBhbiBlcnJvciB3YXMgcHJldmlvdXNseSBkaXNwYXRjaGVkXG4gICAgICB9XG4gICAgfSxcblxuICAgIHBhcnNlU3RyZWFtOiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIC8vIG5vcm1hbGl6ZSBsaW5lIHNlcGFyYXRvcnMgKFxcclxcbixcXHIsXFxuKSB0byBcXG5cbiAgICAgIC8vIHJlbW92ZSB3aGl0ZSBzcGFjZXMgdGhhdCBtYXkgcHJlY2VkZSBcXG5cbiAgICAgIGNodW5rID0gdGhpcy5jYWNoZSArIHRoaXMubm9ybWFsaXplVG9MRihjaHVuaylcblxuICAgICAgdmFyIGV2ZW50cyA9IGNodW5rLnNwbGl0KCdcXG5cXG4nKVxuXG4gICAgICB2YXIgaSwgaiwgZXZlbnRUeXBlLCBkYXRhcywgbGluZSwgcmV0cnlcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgZXZlbnRUeXBlID0gJ21lc3NhZ2UnXG4gICAgICAgIGRhdGFzID0gW11cbiAgICAgICAgdmFyIHBhcnRzID0gZXZlbnRzW2ldLnNwbGl0KCdcXG4nKVxuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxpbmUgPSB0aGlzLnRyaW1XaGl0ZVNwYWNlKHBhcnRzW2pdKVxuXG4gICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignZXZlbnQnKSA9PSAwKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBsaW5lLnJlcGxhY2UoL2V2ZW50Oj9cXHMqLywgJycpXG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluZGV4T2YoJ3JldHJ5JykgPT0gMCkge1xuICAgICAgICAgICAgcmV0cnkgPSBwYXJzZUludChsaW5lLnJlcGxhY2UoL3JldHJ5Oj9cXHMqLywgJycpLCAxMClcbiAgICAgICAgICAgIGlmICghaXNOYU4ocmV0cnkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSByZXRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5pbmRleE9mKCdkYXRhJykgPT0gMCkge1xuICAgICAgICAgICAgZGF0YXMucHVzaChsaW5lLnJlcGxhY2UoL2RhdGE6P1xccyovLCAnJykpXG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluZGV4T2YoJ2lkOicpID09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50SWQgPSBsaW5lLnJlcGxhY2UoL2lkOj9cXHMqLywgJycpXG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluZGV4T2YoJ2lkJykgPT0gMCkge1xuICAgICAgICAgICAgLy8gdGhpcyByZXNldHMgdGhlIGlkXG5cbiAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50SWQgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFzLmxlbmd0aCAmJiB0aGlzLnJlYWR5U3RhdGUgIT0gdGhpcy5DTE9TRUQpIHtcbiAgICAgICAgICAvLyBkaXNwYXRjaCBhIG5ldyBldmVudFxuICAgICAgICAgIHZhciBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoXG4gICAgICAgICAgICBldmVudFR5cGUsXG4gICAgICAgICAgICBkYXRhcy5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubG9jYXRpb24gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgID8gd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB0aGlzLmxhc3RFdmVudElkXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudFR5cGUsIGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FjaGUgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBldmVudCkge1xuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpc1snXycgKyB0eXBlICsgJ0hhbmRsZXJzJ11cblxuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzWydvbicgKyB0eXBlXSkge1xuICAgICAgICB0aGlzWydvbicgKyB0eXBlXS5jYWxsKHRoaXMsIGV2ZW50KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCF0aGlzWydfJyArIHR5cGUgKyAnSGFuZGxlcnMnXSkge1xuICAgICAgICB0aGlzWydfJyArIHR5cGUgKyAnSGFuZGxlcnMnXSA9IFtdXG4gICAgICB9XG5cbiAgICAgIHRoaXNbJ18nICsgdHlwZSArICdIYW5kbGVycyddLnB1c2goaGFuZGxlcilcbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXNbJ18nICsgdHlwZSArICdIYW5kbGVycyddXG4gICAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShpLCAxKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BvbGxUaW1lcjogbnVsbCxcblxuICAgIF9ub2FjdGl2aXR5VGltZXI6IG51bGwsXG5cbiAgICBfeGhyOiBudWxsLFxuXG4gICAgbGFzdEV2ZW50SWQ6IG51bGwsXG5cbiAgICBjYWNoZTogJycsXG5cbiAgICBjdXJzb3I6IDAsXG5cbiAgICBvbmVycm9yOiBudWxsLFxuXG4gICAgb25tZXNzYWdlOiBudWxsLFxuXG4gICAgb25vcGVuOiBudWxsLFxuXG4gICAgcmVhZHlTdGF0ZTogMCxcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBoZWxwZXJzIGZ1bmN0aW9uc1xuICAgIC8vIHRob3NlIGFyZSBhdHRhY2hlZCB0byBwcm90b3R5cGUgdG8gZWFzZSByZXVzZSBhbmQgdGVzdGluZy4uLlxuXG4gICAgdXJsV2l0aFBhcmFtczogZnVuY3Rpb24gKGJhc2VVUkwsIHBhcmFtcykge1xuICAgICAgdmFyIGVuY29kZWRBcmdzID0gW11cblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICB2YXIga2V5LCB1cmxhcmdcbiAgICAgICAgdmFyIHVybGl6ZSA9IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgICAgIGZvciAoa2V5IGluIHBhcmFtcykge1xuICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdXJsYXJnID0gdXJsaXplKGtleSkgKyAnPScgKyB1cmxpemUocGFyYW1zW2tleV0pXG4gICAgICAgICAgICBlbmNvZGVkQXJncy5wdXNoKHVybGFyZylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuY29kZWRBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGJhc2VVUkwuaW5kZXhPZignPycpID09IC0xKSByZXR1cm4gYmFzZVVSTCArICc/JyArIGVuY29kZWRBcmdzLmpvaW4oJyYnKVxuICAgICAgICByZXR1cm4gYmFzZVVSTCArICcmJyArIGVuY29kZWRBcmdzLmpvaW4oJyYnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVUkxcbiAgICB9LFxuXG4gICAgbGFzdE1lc3NhZ2VJbmRleDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHZhciBsbjIgPSB0ZXh0Lmxhc3RJbmRleE9mKCdcXG5cXG4nKVxuICAgICAgdmFyIGxyMiA9IHRleHQubGFzdEluZGV4T2YoJ1xcclxccicpXG4gICAgICB2YXIgbHJsbjIgPSB0ZXh0Lmxhc3RJbmRleE9mKCdcXHJcXG5cXHJcXG4nKVxuXG4gICAgICBpZiAobHJsbjIgPiBNYXRoLm1heChsbjIsIGxyMikpIHtcbiAgICAgICAgcmV0dXJuIFtscmxuMiwgbHJsbjIgKyA0XVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtNYXRoLm1heChsbjIsIGxyMiksIE1hdGgubWF4KGxuMiwgbHIyKSArIDJdXG4gICAgfSxcblxuICAgIHRyaW1XaGl0ZVNwYWNlOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAvLyB0byByZW1vdmUgd2hpdGVzcGFjZXMgbGVmdCBhbmQgcmlnaHQgb2Ygc3RyaW5nXG5cbiAgICAgIHZhciByZVRyaW0gPSAvXihcXHN8XFx1MDBBMCkrfChcXHN8XFx1MDBBMCkrJC9nXG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVUcmltLCAnJylcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplVG9MRjogZnVuY3Rpb24gKHN0cikge1xuICAgICAgLy8gcmVwbGFjZSBcXHIgYW5kIFxcclxcbiB3aXRoIFxcblxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIH0sXG4gIH1cblxuICBpZiAoaXNPbGRJRSgpKSB7XG4gICAgRXZlbnRTb3VyY2UuaXNQb2x5ZmlsbCA9ICdJRV84LTknXG5cbiAgICAvLyBwYXRjaCBFdmVudFNvdXJjZSBkZWZhdWx0T3B0aW9uc1xuICAgIHZhciBkZWZhdWx0cyA9IEV2ZW50U291cmNlLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9uc1xuICAgIGRlZmF1bHRzLnhockhlYWRlcnMgPSBudWxsIC8vIG5vIGhlYWRlcnMgd2lsbCBiZSBzZW50XG4gICAgZGVmYXVsdHMuZ2V0QXJncy5ldnNfcHJlYW1ibGUgPSAyMDQ4ICsgOFxuXG4gICAgLy8gRXZlbnRTb3VyY2Ugd2lsbCBzZW5kIHJlcXVlc3QgdXNpbmcgSW50ZXJuZXQgRXhwbG9yZXIgWERvbWFpblJlcXVlc3RcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuWEhSID0gZnVuY3Rpb24gKGV2cykge1xuICAgICAgLyogZ2xvYmFsIFhEb21haW5SZXF1ZXN0ICovXG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYRG9tYWluUmVxdWVzdCgpXG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdFxuXG4gICAgICAvLyBzZXQgaGFuZGxlcnNcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxdWVzdC5fcmVhZHkgPSB0cnVlXG4gICAgICAgIGV2cy5fb254aHJkYXRhKClcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWVcbiAgICAgICAgZXZzLl9vbnhocmRhdGEoKVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZhaWxlZCA9IHRydWVcbiAgICAgICAgZXZzLnJlYWR5U3RhdGUgPSBldnMuQ0xPU0VEXG4gICAgICAgIGV2cy5kaXNwYXRjaEV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIGRhdGE6ICdYRG9tYWluUmVxdWVzdCBlcnJvcicsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mYWlsZWQgPSB0cnVlXG4gICAgICAgIGV2cy5yZWFkeVN0YXRlID0gZXZzLkNMT1NFRFxuICAgICAgICBldnMuZGlzcGF0Y2hFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICBkYXRhOiAnWERvbWFpblJlcXVlc3QgdGltZWQgb3V0JyxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gWERvbWFpblJlcXVlc3QgZG9lcyBub3QgYWxsb3cgc2V0dGluZyBjdXN0b20gaGVhZGVyc1xuICAgICAgLy8gSWYgRXZlbnRTb3VyY2UgaGFzIGVuYWJsZWQgdGhlIHVzZSBvZiBHRVQgYXJndW1lbnRzXG4gICAgICAvLyB3ZSBhZGQgcGFyYW1ldGVycyB0byBVUkwgc28gdGhhdCBzZXJ2ZXIgY2FuIGFkYXB0IHRoZSBzdHJlYW0uLi5cbiAgICAgIHZhciByZXFHZXRBcmdzID0ge31cbiAgICAgIGlmIChldnMuZ2V0QXJncykge1xuICAgICAgICAvLyBjb3B5IGV2cy5nZXRBcmdzIGluIHJlcUdldEFyZ3NcbiAgICAgICAgdmFyIGRlZmF1bHRBcmdzID0gZXZzLmdldEFyZ3NcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRBcmdzKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRBcmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJlcUdldEFyZ3Nba2V5XSA9IGRlZmF1bHRBcmdzW2tleV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2cy5sYXN0RXZlbnRJZCkge1xuICAgICAgICAgIHJlcUdldEFyZ3MuZXZzX2xhc3RfZXZlbnRfaWQgPSBldnMubGFzdEV2ZW50SWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc2VuZCB0aGUgcmVxdWVzdFxuXG4gICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIGV2cy51cmxXaXRoUGFyYW1zKGV2cy5VUkwsIHJlcUdldEFyZ3MpKVxuICAgICAgcmVxdWVzdC5zZW5kKClcbiAgICB9XG5cbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuWEhSLnByb3RvdHlwZSA9IHtcbiAgICAgIHVzZVhEb21haW5SZXF1ZXN0OiB0cnVlLFxuXG4gICAgICBfcmVxdWVzdDogbnVsbCxcblxuICAgICAgX3JlYWR5OiBmYWxzZSwgLy8gdHJ1ZSB3aGVuIHByb2dyZXNzIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZFxuXG4gICAgICBfbG9hZGVkOiBmYWxzZSwgLy8gdHJ1ZSB3aGVuIHJlcXVlc3QgaGFzIGJlZW4gbG9hZGVkXG5cbiAgICAgIF9mYWlsZWQ6IGZhbHNlLCAvLyB0cnVlIGlmIHdoZW4gcmVxdWVzdCBpcyBpbiBlcnJvclxuXG4gICAgICBpc1JlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0Ll9yZWFkeVxuICAgICAgfSxcblxuICAgICAgaXNEb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0Ll9sb2FkZWRcbiAgICAgIH0sXG5cbiAgICAgIGhhc0Vycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0Ll9mYWlsZWRcbiAgICAgIH0sXG5cbiAgICAgIGdldEJ1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnYgPSAnJ1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ2ID0gdGhpcy5fcmVxdWVzdC5yZXNwb25zZVRleHQgfHwgJydcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWwgbm9vcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydlxuICAgICAgfSxcblxuICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFib3J0KClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgRXZlbnRTb3VyY2UuaXNQb2x5ZmlsbCA9ICdYSFInXG5cbiAgICAvLyBFdmVudFNvdXJjZSB3aWxsIHNlbmQgcmVxdWVzdCB1c2luZyBYTUxIdHRwUmVxdWVzdFxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5YSFIgPSBmdW5jdGlvbiAoZXZzKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdFxuICAgICAgZXZzLl94aHIgPSB0aGlzXG5cbiAgICAgIC8vIHNldCBoYW5kbGVyc1xuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPiAxICYmIGV2cy5yZWFkeVN0YXRlICE9IGV2cy5DTE9TRUQpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT0gMjAwIHx8IChyZXF1ZXN0LnN0YXR1cyA+PSAzMDAgJiYgcmVxdWVzdC5zdGF0dXMgPCA0MDApKSB7XG4gICAgICAgICAgICBldnMuX29ueGhyZGF0YSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QuX2ZhaWxlZCA9IHRydWVcbiAgICAgICAgICAgIGV2cy5yZWFkeVN0YXRlID0gZXZzLkNMT1NFRFxuICAgICAgICAgICAgZXZzLmRpc3BhdGNoRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICBkYXRhOiAnVGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCAnICsgcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgZXZzLmNsb3NlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbCBub29wXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgZXZzLnVybFdpdGhQYXJhbXMoZXZzLlVSTCwgZXZzLmdldEFyZ3MpLCB0cnVlKVxuXG4gICAgICB2YXIgaGVhZGVycyA9IGV2cy54aHJIZWFkZXJzIC8vIG1heWJlIG51bGxcbiAgICAgIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChldnMubGFzdEV2ZW50SWQpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdMYXN0LUV2ZW50LUlkJywgZXZzLmxhc3RFdmVudElkKVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LnNlbmQoKVxuICAgIH1cblxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5YSFIucHJvdG90eXBlID0ge1xuICAgICAgdXNlWERvbWFpblJlcXVlc3Q6IGZhbHNlLFxuXG4gICAgICBfcmVxdWVzdDogbnVsbCxcblxuICAgICAgX2ZhaWxlZDogZmFsc2UsIC8vIHRydWUgaWYgd2UgaGF2ZSBoYWQgZXJyb3JzLi4uXG5cbiAgICAgIGlzUmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucmVhZHlTdGF0ZSA+PSAyXG4gICAgICB9LFxuXG4gICAgICBpc0RvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucmVhZHlTdGF0ZSA9PSA0XG4gICAgICB9LFxuXG4gICAgICBoYXNFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbGVkIHx8IHRoaXMuX3JlcXVlc3Quc3RhdHVzID49IDQwMFxuICAgICAgfSxcblxuICAgICAgZ2V0QnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydiA9ICcnXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnYgPSB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dCB8fCAnJ1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbCBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2XG4gICAgICB9LFxuXG4gICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIE1lc3NhZ2VFdmVudCh0eXBlLCBkYXRhLCBvcmlnaW4sIGxhc3RFdmVudElkKSB7XG4gICAgdGhpcy5idWJibGVzID0gZmFsc2VcbiAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IGZhbHNlXG4gICAgdGhpcy5jYW5jZWxhYmxlID0gZmFsc2VcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG51bGxcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbiB8fCAnJ1xuICAgIHRoaXMubGFzdEV2ZW50SWQgPSBsYXN0RXZlbnRJZCB8fCAnJ1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgJ21lc3NhZ2UnXG4gIH1cblxuICBmdW5jdGlvbiBpc09sZElFKCkge1xuICAgIC8vcmV0dXJuIHRydWUgaWYgd2UgYXJlIGluIElFOCBvciBJRTlcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJlxuICAgICAgICB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiZcbiAgICAgICAgbmV3IFhNTEh0dHBSZXF1ZXN0KCkucmVzcG9uc2VUeXBlID09PSB1bmRlZmluZWRcbiAgICApXG4gIH1cblxuICByZXR1cm4gRXZlbnRTb3VyY2Vcbn0pXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnQHNhbml0eS9vYnNlcnZhYmxlL29wZXJhdG9ycy9tYXAnKSxcbiAgICBtYXAgPSBfcmVxdWlyZS5tYXA7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCdAc2FuaXR5L29ic2VydmFibGUvb3BlcmF0b3JzL2ZpbHRlcicpLFxuICAgIGZpbHRlciA9IF9yZXF1aXJlMi5maWx0ZXI7XG5cbnZhciBxdWVyeVN0cmluZyA9IHJlcXVpcmUoJy4uL2h0dHAvcXVlcnlTdHJpbmcnKTtcblxudmFyIHZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XG5cbmZ1bmN0aW9uIEFzc2V0c0NsaWVudChjbGllbnQpIHtcbiAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbmZ1bmN0aW9uIHRvRG9jdW1lbnQoYm9keSkge1xuICAvLyB0b2RvOiByZXdyaXRlIHRvIGp1c3QgcmV0dXJuIGJvZHkuZG9jdW1lbnQgaW4gYSB3aGlsZVxuICB2YXIgZG9jdW1lbnQgPSBib2R5LmRvY3VtZW50O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsICdkb2N1bWVudCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBwcm9taXNlIHJldHVybmVkIGZyb20gY2xpZW50LmFzc2V0LnVwbG9hZCguLi4pIG5vdyByZXNvbHZlcyB3aXRoIHRoZSBhc3NldCBkb2N1bWVudCcpO1xuICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gb3B0aW9uc0Zyb21GaWxlKG9wdHMsIGZpbGUpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEoZmlsZSBpbnN0YW5jZW9mIHdpbmRvdy5GaWxlKSkge1xuICAgIHJldHVybiBvcHRzO1xuICB9XG5cbiAgcmV0dXJuIGFzc2lnbih7XG4gICAgZmlsZW5hbWU6IG9wdHMucHJlc2VydmVGaWxlbmFtZSA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiBmaWxlLm5hbWUsXG4gICAgY29udGVudFR5cGU6IGZpbGUudHlwZVxuICB9LCBvcHRzKTtcbn1cblxuYXNzaWduKEFzc2V0c0NsaWVudC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFVwbG9hZCBhbiBhc3NldFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFzc2V0VHlwZSBgaW1hZ2VgIG9yIGBmaWxlYFxuICAgKiBAcGFyYW0gIHtGaWxlfEJsb2J8QnVmZmVyfFJlYWRhYmxlU3RyZWFtfSBib2R5IEZpbGUgdG8gdXBsb2FkXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdHMgT3B0aW9ucyBmb3IgdGhlIHVwbG9hZFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRzLnByZXNlcnZlRmlsZW5hbWUgV2hldGhlciBvciBub3QgdG8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIGZpbGVuYW1lIChkZWZhdWx0OiB0cnVlKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRzLmZpbGVuYW1lIEZpbGVuYW1lIGZvciB0aGlzIGZpbGUgKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBvcHRzLnRpbWVvdXQgIE1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSB0aW1pbmcgdGhlIHJlcXVlc3Qgb3V0IChkZWZhdWx0OiAwKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRzLmNvbnRlbnRUeXBlIE1pbWUgdHlwZSBvZiB0aGUgZmlsZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gICBvcHRzLmV4dHJhY3QgQXJyYXkgb2YgbWV0YWRhdGEgcGFydHMgdG8gZXh0cmFjdCBmcm9tIGltYWdlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIHZhbHVlczogYGxvY2F0aW9uYCwgYGV4aWZgLCBgaW1hZ2VgLCBgcGFsZXR0ZWBcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgb3B0cy5sYWJlbCBMYWJlbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRzLnRpdGxlIFRpdGxlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIG9wdHMuZGVzY3JpcHRpb24gRGVzY3JpcHRpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgb3B0cy5jcmVkaXRMaW5lIFRoZSBjcmVkaXQgdG8gcGVyc29uKHMpIGFuZC9vciBvcmdhbml6YXRpb24ocykgcmVxdWlyZWQgYnkgdGhlIHN1cHBsaWVyIG9mIHRoZSBpbWFnZSB0byBiZSB1c2VkIHdoZW4gcHVibGlzaGVkXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdHMuc291cmNlIFNvdXJjZSBkYXRhICh3aGVuIHRoZSBhc3NldCBpcyBmcm9tIGFuIGV4dGVybmFsIHNlcnZpY2UpXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIG9wdHMuc291cmNlLmlkIFRoZSAodSlpZCBvZiB0aGUgYXNzZXQgd2l0aGluIHRoZSBzb3VyY2UsIGkuZS4gJ2ktZjMyM3IxRSdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVxdWlyZWQgaWYgc291cmNlIGlzIGRlZmluZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgb3B0cy5zb3VyY2UubmFtZSBUaGUgbmFtZSBvZiB0aGUgc291cmNlLCBpLmUuICd1bnNwbGFzaCdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVxdWlyZWQgaWYgc291cmNlIGlzIGRlZmluZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgb3B0cy5zb3VyY2UudXJsIEEgdXJsIHRvIHdoZXJlIHRvIGZpbmQgdGhlIGFzc2V0LCBvciBnZXQgbW9yZSBpbmZvIGFib3V0IGl0IGluIHRoZSBzb3VyY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWxcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgd2l0aCB0aGUgY3JlYXRlZCBhc3NldCBkb2N1bWVudFxuICAgKi9cbiAgdXBsb2FkOiBmdW5jdGlvbiB1cGxvYWQoYXNzZXRUeXBlLCBib2R5KSB7XG4gICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhbGlkYXRvcnMudmFsaWRhdGVBc3NldFR5cGUoYXNzZXRUeXBlKTsgLy8gSWYgYW4gZW1wdHkgYXJyYXkgaXMgZ2l2ZW4sIGV4cGxpY2l0bHkgc2V0IGBub25lYCB0byBvdmVycmlkZSBBUEkgZGVmYXVsdHNcblxuICAgIHZhciBtZXRhID0gb3B0cy5leHRyYWN0IHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChtZXRhICYmICFtZXRhLmxlbmd0aCkge1xuICAgICAgbWV0YSA9IFsnbm9uZSddO1xuICAgIH1cblxuICAgIHZhciBkYXRhc2V0ID0gdmFsaWRhdG9ycy5oYXNEYXRhc2V0KHRoaXMuY2xpZW50LmNsaWVudENvbmZpZyk7XG4gICAgdmFyIGFzc2V0RW5kcG9pbnQgPSBhc3NldFR5cGUgPT09ICdpbWFnZScgPyAnaW1hZ2VzJyA6ICdmaWxlcyc7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zRnJvbUZpbGUob3B0cywgYm9keSk7XG4gICAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbCxcbiAgICAgICAgdGl0bGUgPSBvcHRpb25zLnRpdGxlLFxuICAgICAgICBkZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgIGNyZWRpdExpbmUgPSBvcHRpb25zLmNyZWRpdExpbmUsXG4gICAgICAgIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZSxcbiAgICAgICAgc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgdmFyIHF1ZXJ5ID0ge1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgbWV0YTogbWV0YSxcbiAgICAgIGNyZWRpdExpbmU6IGNyZWRpdExpbmVcbiAgICB9O1xuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgcXVlcnkuc291cmNlSWQgPSBzb3VyY2UuaWQ7XG4gICAgICBxdWVyeS5zb3VyY2VOYW1lID0gc291cmNlLm5hbWU7XG4gICAgICBxdWVyeS5zb3VyY2VVcmwgPSBzb3VyY2UudXJsO1xuICAgIH1cblxuICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy5jbGllbnQuX3JlcXVlc3RPYnNlcnZhYmxlKHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAsXG4gICAgICB1cmk6IFwiL2Fzc2V0cy9cIi5jb25jYXQoYXNzZXRFbmRwb2ludCwgXCIvXCIpLmNvbmNhdChkYXRhc2V0KSxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuY29udGVudFR5cGUgPyB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiBvcHRpb25zLmNvbnRlbnRUeXBlXG4gICAgICB9IDoge30sXG4gICAgICBxdWVyeTogcXVlcnksXG4gICAgICBib2R5OiBib2R5XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5jbGllbnQuaXNQcm9taXNlQVBJKCkgPyBvYnNlcnZhYmxlLnBpcGUoZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdyZXNwb25zZSc7XG4gICAgfSksIG1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiB0b0RvY3VtZW50KGV2ZW50LmJvZHkpO1xuICAgIH0pKS50b1Byb21pc2UoKSA6IG9ic2VydmFibGU7XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZSh0eXBlLCBpZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdjbGllbnQuYXNzZXRzLmRlbGV0ZSgpIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgY2xpZW50LmRlbGV0ZSg8ZG9jdW1lbnQtaWQ+KScpO1xuICAgIHZhciBkb2NJZCA9IGlkIHx8ICcnO1xuXG4gICAgaWYgKCEvXihpbWFnZXxmaWxlKS0vLnRlc3QoZG9jSWQpKSB7XG4gICAgICBkb2NJZCA9IFwiXCIuY29uY2F0KHR5cGUsIFwiLVwiKS5jb25jYXQoZG9jSWQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5faWQpIHtcbiAgICAgIC8vIFdlIGNvdWxkIGJlIHBhc3NpbmcgYW4gZW50aXJlIGFzc2V0IGRvY3VtZW50IGluc3RlYWQgb2YgYW4gSURcbiAgICAgIGRvY0lkID0gdHlwZS5faWQ7XG4gICAgfVxuXG4gICAgdmFsaWRhdG9ycy5oYXNEYXRhc2V0KHRoaXMuY2xpZW50LmNsaWVudENvbmZpZyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmRlbGV0ZShkb2NJZCk7XG4gIH0sXG4gIGdldEltYWdlVXJsOiBmdW5jdGlvbiBnZXRJbWFnZVVybChyZWYsIHF1ZXJ5KSB7XG4gICAgdmFyIGlkID0gcmVmLl9yZWYgfHwgcmVmO1xuXG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0SW1hZ2VVcmwoKSBuZWVkcyBlaXRoZXIgYW4gb2JqZWN0IHdpdGggYSBfcmVmLCBvciBhIHN0cmluZyB3aXRoIGFuIGFzc2V0IGRvY3VtZW50IElEJyk7XG4gICAgfVxuXG4gICAgaWYgKCEvXmltYWdlLVtBLVphLXowLTlfXSstXFxkK3hcXGQrLVthLXpdezEsNX0kLy50ZXN0KGlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYXNzZXQgSUQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiLiBVUkwgZ2VuZXJhdGlvbiBvbmx5IHdvcmtzIGZvciBhdXRvLWdlbmVyYXRlZCBJRHMuXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgX2lkJHNwbGl0ID0gaWQuc3BsaXQoJy0nKSxcbiAgICAgICAgX2lkJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9pZCRzcGxpdCwgNCksXG4gICAgICAgIGFzc2V0SWQgPSBfaWQkc3BsaXQyWzFdLFxuICAgICAgICBzaXplID0gX2lkJHNwbGl0MlsyXSxcbiAgICAgICAgZm9ybWF0ID0gX2lkJHNwbGl0MlszXTtcblxuICAgIHZhbGlkYXRvcnMuaGFzRGF0YXNldCh0aGlzLmNsaWVudC5jbGllbnRDb25maWcpO1xuICAgIHZhciBfdGhpcyRjbGllbnQkY2xpZW50Q28gPSB0aGlzLmNsaWVudC5jbGllbnRDb25maWcsXG4gICAgICAgIHByb2plY3RJZCA9IF90aGlzJGNsaWVudCRjbGllbnRDby5wcm9qZWN0SWQsXG4gICAgICAgIGRhdGFzZXQgPSBfdGhpcyRjbGllbnQkY2xpZW50Q28uZGF0YXNldDtcbiAgICB2YXIgcXMgPSBxdWVyeSA/IHF1ZXJ5U3RyaW5nKHF1ZXJ5KSA6ICcnO1xuICAgIHJldHVybiBcImh0dHBzOi8vY2RuLnNhbml0eS5pby9pbWFnZXMvXCIuY29uY2F0KHByb2plY3RJZCwgXCIvXCIpLmNvbmNhdChkYXRhc2V0LCBcIi9cIikuY29uY2F0KGFzc2V0SWQsIFwiLVwiKS5jb25jYXQoc2l6ZSwgXCIuXCIpLmNvbmNhdChmb3JtYXQpLmNvbmNhdChxcyk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBBc3NldHNDbGllbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmZ1bmN0aW9uIEF1dGhDbGllbnQoY2xpZW50KSB7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG5hc3NpZ24oQXV0aENsaWVudC5wcm90b3R5cGUsIHtcbiAgZ2V0TG9naW5Qcm92aWRlcnM6IGZ1bmN0aW9uIGdldExvZ2luUHJvdmlkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIHVyaTogJy9hdXRoL3Byb3ZpZGVycydcbiAgICB9KTtcbiAgfSxcbiAgbG9nb3V0OiBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgdXJpOiAnL2F1dGgvbG9nb3V0JyxcbiAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgfSk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBBdXRoQ2xpZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2VuZXJhdGVIZWxwVXJsID0gcmVxdWlyZSgnQHNhbml0eS9nZW5lcmF0ZS1oZWxwLXVybCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcnMnKTtcblxudmFyIHdhcm5pbmdzID0gcmVxdWlyZSgnLi93YXJuaW5ncycpO1xuXG52YXIgZGVmYXVsdENkbkhvc3QgPSAnYXBpY2RuLnNhbml0eS5pbyc7XG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgYXBpSG9zdDogJ2h0dHBzOi8vYXBpLnNhbml0eS5pbycsXG4gIGFwaVZlcnNpb246ICcxJyxcbiAgdXNlUHJvamVjdEhvc3RuYW1lOiB0cnVlLFxuICBncmFkaWVudE1vZGU6IGZhbHNlLFxuICBpc1Byb21pc2VBUEk6IHRydWVcbn07XG52YXIgTE9DQUxIT1NUUyA9IFsnbG9jYWxob3N0JywgJzEyNy4wLjAuMScsICcwLjAuMC4wJ107XG5cbnZhciBpc0xvY2FsID0gZnVuY3Rpb24gaXNMb2NhbChob3N0KSB7XG4gIHJldHVybiBMT0NBTEhPU1RTLmluZGV4T2YoaG9zdCkgIT09IC0xO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZXhwb3J0cy5pbml0Q29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZywgcHJldkNvbmZpZykge1xuICB2YXIgc3BlY2lmaWVkQ29uZmlnID0gYXNzaWduKHt9LCBwcmV2Q29uZmlnLCBjb25maWcpO1xuXG4gIGlmICghc3BlY2lmaWVkQ29uZmlnLmFwaVZlcnNpb24pIHtcbiAgICB3YXJuaW5ncy5wcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmcoKTtcbiAgfVxuXG4gIHZhciBuZXdDb25maWcgPSBhc3NpZ24oe30sIGRlZmF1bHRDb25maWcsIHNwZWNpZmllZENvbmZpZyk7XG4gIHZhciBncmFkaWVudE1vZGUgPSBuZXdDb25maWcuZ3JhZGllbnRNb2RlO1xuICB2YXIgcHJvamVjdEJhc2VkID0gIWdyYWRpZW50TW9kZSAmJiBuZXdDb25maWcudXNlUHJvamVjdEhvc3RuYW1lO1xuXG4gIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgaGVscFVybCA9IGdlbmVyYXRlSGVscFVybCgnanMtY2xpZW50LXByb21pc2UtcG9seWZpbGwnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBuYXRpdmUgUHJvbWlzZS1pbXBsZW1lbnRhdGlvbiBmb3VuZCwgcG9seWZpbGwgbmVlZGVkIC0gc2VlIFwiLmNvbmNhdChoZWxwVXJsKSk7XG4gIH1cblxuICBpZiAoZ3JhZGllbnRNb2RlICYmICFuZXdDb25maWcubmFtZXNwYWNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWd1cmF0aW9uIG11c3QgY29udGFpbiBgbmFtZXNwYWNlYCB3aGVuIHJ1bm5pbmcgaW4gZ3JhZGllbnQgbW9kZScpO1xuICB9XG5cbiAgaWYgKHByb2plY3RCYXNlZCAmJiAhbmV3Q29uZmlnLnByb2plY3RJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBtdXN0IGNvbnRhaW4gYHByb2plY3RJZGAnKTtcbiAgfVxuXG4gIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICB2YXIgaXNMb2NhbGhvc3QgPSBpc0Jyb3dzZXIgJiYgaXNMb2NhbCh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpO1xuXG4gIGlmIChpc0Jyb3dzZXIgJiYgaXNMb2NhbGhvc3QgJiYgbmV3Q29uZmlnLnRva2VuICYmIG5ld0NvbmZpZy5pZ25vcmVCcm93c2VyVG9rZW5XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgd2FybmluZ3MucHJpbnRCcm93c2VyVG9rZW5XYXJuaW5nKCk7XG4gIH0gZWxzZSBpZiAoKCFpc0Jyb3dzZXIgfHwgaXNMb2NhbGhvc3QpICYmIG5ld0NvbmZpZy51c2VDZG4gJiYgbmV3Q29uZmlnLnRva2VuKSB7XG4gICAgd2FybmluZ3MucHJpbnRDZG5Ub2tlbldhcm5pbmcoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q29uZmlnLnVzZUNkbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3YXJuaW5ncy5wcmludENkbldhcm5pbmcoKTtcbiAgfVxuXG4gIGlmIChwcm9qZWN0QmFzZWQpIHtcbiAgICB2YWxpZGF0ZS5wcm9qZWN0SWQobmV3Q29uZmlnLnByb2plY3RJZCk7XG4gIH1cblxuICBpZiAoIWdyYWRpZW50TW9kZSAmJiBuZXdDb25maWcuZGF0YXNldCkge1xuICAgIHZhbGlkYXRlLmRhdGFzZXQobmV3Q29uZmlnLmRhdGFzZXQsIG5ld0NvbmZpZy5ncmFkaWVudE1vZGUpO1xuICB9XG5cbiAgbmV3Q29uZmlnLmFwaVZlcnNpb24gPSBcIlwiLmNvbmNhdChuZXdDb25maWcuYXBpVmVyc2lvbikucmVwbGFjZSgvXnYvLCAnJyk7XG4gIG5ld0NvbmZpZy5pc0RlZmF1bHRBcGkgPSBuZXdDb25maWcuYXBpSG9zdCA9PT0gZGVmYXVsdENvbmZpZy5hcGlIb3N0O1xuICBuZXdDb25maWcudXNlQ2RuID0gQm9vbGVhbihuZXdDb25maWcudXNlQ2RuKSAmJiAhbmV3Q29uZmlnLnRva2VuICYmICFuZXdDb25maWcud2l0aENyZWRlbnRpYWxzO1xuICBleHBvcnRzLnZhbGlkYXRlQXBpVmVyc2lvbihuZXdDb25maWcuYXBpVmVyc2lvbik7XG5cbiAgaWYgKG5ld0NvbmZpZy5ncmFkaWVudE1vZGUpIHtcbiAgICBuZXdDb25maWcudXJsID0gbmV3Q29uZmlnLmFwaUhvc3Q7XG4gICAgbmV3Q29uZmlnLmNkblVybCA9IG5ld0NvbmZpZy5hcGlIb3N0O1xuICB9IGVsc2Uge1xuICAgIHZhciBob3N0UGFydHMgPSBuZXdDb25maWcuYXBpSG9zdC5zcGxpdCgnOi8vJywgMik7XG4gICAgdmFyIHByb3RvY29sID0gaG9zdFBhcnRzWzBdO1xuICAgIHZhciBob3N0ID0gaG9zdFBhcnRzWzFdO1xuICAgIHZhciBjZG5Ib3N0ID0gbmV3Q29uZmlnLmlzRGVmYXVsdEFwaSA/IGRlZmF1bHRDZG5Ib3N0IDogaG9zdDtcblxuICAgIGlmIChuZXdDb25maWcudXNlUHJvamVjdEhvc3RuYW1lKSB7XG4gICAgICBuZXdDb25maWcudXJsID0gXCJcIi5jb25jYXQocHJvdG9jb2wsIFwiOi8vXCIpLmNvbmNhdChuZXdDb25maWcucHJvamVjdElkLCBcIi5cIikuY29uY2F0KGhvc3QsIFwiL3ZcIikuY29uY2F0KG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcbiAgICAgIG5ld0NvbmZpZy5jZG5VcmwgPSBcIlwiLmNvbmNhdChwcm90b2NvbCwgXCI6Ly9cIikuY29uY2F0KG5ld0NvbmZpZy5wcm9qZWN0SWQsIFwiLlwiKS5jb25jYXQoY2RuSG9zdCwgXCIvdlwiKS5jb25jYXQobmV3Q29uZmlnLmFwaVZlcnNpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDb25maWcudXJsID0gXCJcIi5jb25jYXQobmV3Q29uZmlnLmFwaUhvc3QsIFwiL3ZcIikuY29uY2F0KG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcbiAgICAgIG5ld0NvbmZpZy5jZG5VcmwgPSBuZXdDb25maWcudXJsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdDb25maWc7XG59O1xuXG5leHBvcnRzLnZhbGlkYXRlQXBpVmVyc2lvbiA9IGZ1bmN0aW9uIHZhbGlkYXRlQXBpVmVyc2lvbihhcGlWZXJzaW9uKSB7XG4gIGlmIChhcGlWZXJzaW9uID09PSAnMScgfHwgYXBpVmVyc2lvbiA9PT0gJ1gnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFwaURhdGUgPSBuZXcgRGF0ZShhcGlWZXJzaW9uKTtcbiAgdmFyIGFwaVZlcnNpb25WYWxpZCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KGFwaVZlcnNpb24pICYmIGFwaURhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGFwaURhdGUuZ2V0VGltZSgpID4gMDtcblxuICBpZiAoIWFwaVZlcnNpb25WYWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBBUEkgdmVyc2lvbiBzdHJpbmcsIGV4cGVjdGVkIGAxYCBvciBkYXRlIGluIGZvcm1hdCBgWVlZWS1NTS1ERGAnKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnQHNhbml0eS9vYnNlcnZhYmxlL29wZXJhdG9ycy9maWx0ZXInKSxcbiAgICBmaWx0ZXIgPSBfcmVxdWlyZS5maWx0ZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCdAc2FuaXR5L29ic2VydmFibGUvb3BlcmF0b3JzL21hcCcpLFxuICAgIG1hcCA9IF9yZXF1aXJlMi5tYXA7XG5cbnZhciB2YWxpZGF0b3JzID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xuXG52YXIgZ2V0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRTZWxlY3Rpb24nKTtcblxudmFyIGVuY29kZVF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgnLi9lbmNvZGVRdWVyeVN0cmluZycpO1xuXG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG5cbnZhciBQYXRjaCA9IHJlcXVpcmUoJy4vcGF0Y2gnKTtcblxudmFyIGxpc3RlbiA9IHJlcXVpcmUoJy4vbGlzdGVuJyk7XG5cbnZhciBleGNsdWRlRmFsc2V5ID0gZnVuY3Rpb24gZXhjbHVkZUZhbHNleShwYXJhbSwgZGVmVmFsdWUpIHtcbiAgdmFyIHZhbHVlID0gdHlwZW9mIHBhcmFtID09PSAndW5kZWZpbmVkJyA/IGRlZlZhbHVlIDogcGFyYW07XG4gIHJldHVybiBwYXJhbSA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn07XG5cbnZhciBnZXRNdXRhdGlvblF1ZXJ5ID0gZnVuY3Rpb24gZ2V0TXV0YXRpb25RdWVyeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4ge1xuICAgIHJldHVybklkczogdHJ1ZSxcbiAgICByZXR1cm5Eb2N1bWVudHM6IGV4Y2x1ZGVGYWxzZXkob3B0aW9ucy5yZXR1cm5Eb2N1bWVudHMsIHRydWUpLFxuICAgIHZpc2liaWxpdHk6IG9wdGlvbnMudmlzaWJpbGl0eSB8fCAnc3luYydcbiAgfTtcbn07XG5cbnZhciBpc1Jlc3BvbnNlID0gZnVuY3Rpb24gaXNSZXNwb25zZShldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ3Jlc3BvbnNlJztcbn07XG5cbnZhciBnZXRCb2R5ID0gZnVuY3Rpb24gZ2V0Qm9keShldmVudCkge1xuICByZXR1cm4gZXZlbnQuYm9keTtcbn07XG5cbnZhciBpbmRleEJ5ID0gZnVuY3Rpb24gaW5kZXhCeShkb2NzLCBhdHRyKSB7XG4gIHJldHVybiBkb2NzLnJlZHVjZShmdW5jdGlvbiAoaW5kZXhlZCwgZG9jKSB7XG4gICAgaW5kZXhlZFthdHRyKGRvYyldID0gZG9jO1xuICAgIHJldHVybiBpbmRleGVkO1xuICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn07XG5cbnZhciB0b1Byb21pc2UgPSBmdW5jdGlvbiB0b1Byb21pc2Uob2JzZXJ2YWJsZSkge1xuICByZXR1cm4gb2JzZXJ2YWJsZS50b1Byb21pc2UoKTtcbn07XG5cbnZhciBnZXRRdWVyeVNpemVMaW1pdCA9IDExMjY0O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxpc3RlbjogbGlzdGVuLFxuICBnZXREYXRhVXJsOiBmdW5jdGlvbiBnZXREYXRhVXJsKG9wZXJhdGlvbiwgcGF0aCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNsaWVudENvbmZpZztcbiAgICB2YXIgY2F0YWxvZyA9IGNvbmZpZy5ncmFkaWVudE1vZGUgPyBjb25maWcubmFtZXNwYWNlIDogdmFsaWRhdG9ycy5oYXNEYXRhc2V0KGNvbmZpZyk7XG4gICAgdmFyIGJhc2VVcmkgPSBcIi9cIi5jb25jYXQob3BlcmF0aW9uLCBcIi9cIikuY29uY2F0KGNhdGFsb2cpO1xuICAgIHZhciB1cmkgPSBwYXRoID8gXCJcIi5jb25jYXQoYmFzZVVyaSwgXCIvXCIpLmNvbmNhdChwYXRoKSA6IGJhc2VVcmk7XG4gICAgcmV0dXJuICh0aGlzLmNsaWVudENvbmZpZy5ncmFkaWVudE1vZGUgPyB1cmkgOiBcIi9kYXRhXCIuY29uY2F0KHVyaSkpLnJlcGxhY2UoL1xcLygkfFxcPykvLCAnJDEnKTtcbiAgfSxcbiAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKHF1ZXJ5LCBwYXJhbXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIG1hcFJlc3BvbnNlID0gb3B0aW9ucy5maWx0ZXJSZXNwb25zZSA9PT0gZmFsc2UgPyBmdW5jdGlvbiAocmVzKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gOiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLl9kYXRhUmVxdWVzdCgncXVlcnknLCB7XG4gICAgICBxdWVyeTogcXVlcnksXG4gICAgICBwYXJhbXM6IHBhcmFtc1xuICAgIH0sIG9wdGlvbnMpLnBpcGUobWFwKG1hcFJlc3BvbnNlKSk7XG5cbiAgICByZXR1cm4gdGhpcy5pc1Byb21pc2VBUEkoKSA/IHRvUHJvbWlzZShvYnNlcnZhYmxlKSA6IG9ic2VydmFibGU7XG4gIH0sXG4gIGdldERvY3VtZW50OiBmdW5jdGlvbiBnZXREb2N1bWVudChpZCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJpOiB0aGlzLmdldERhdGFVcmwoJ2RvYycsIGlkKSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuXG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLl9yZXF1ZXN0T2JzZXJ2YWJsZShvcHRpb25zKS5waXBlKGZpbHRlcihpc1Jlc3BvbnNlKSwgbWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LmJvZHkuZG9jdW1lbnRzICYmIGV2ZW50LmJvZHkuZG9jdW1lbnRzWzBdO1xuICAgIH0pKTtcblxuICAgIHJldHVybiB0aGlzLmlzUHJvbWlzZUFQSSgpID8gdG9Qcm9taXNlKG9ic2VydmFibGUpIDogb2JzZXJ2YWJsZTtcbiAgfSxcbiAgZ2V0RG9jdW1lbnRzOiBmdW5jdGlvbiBnZXREb2N1bWVudHMoaWRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuZ2V0RGF0YVVybCgnZG9jJywgaWRzLmpvaW4oJywnKSksXG4gICAgICBqc29uOiB0cnVlXG4gICAgfTtcblxuICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy5fcmVxdWVzdE9ic2VydmFibGUob3B0aW9ucykucGlwZShmaWx0ZXIoaXNSZXNwb25zZSksIG1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBpbmRleGVkID0gaW5kZXhCeShldmVudC5ib2R5LmRvY3VtZW50cyB8fCBbXSwgZnVuY3Rpb24gKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jLl9pZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBpbmRleGVkW2lkXSB8fCBudWxsO1xuICAgICAgfSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNQcm9taXNlQVBJKCkgPyB0b1Byb21pc2Uob2JzZXJ2YWJsZSkgOiBvYnNlcnZhYmxlO1xuICB9LFxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShkb2MsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlKGRvYywgJ2NyZWF0ZScsIG9wdGlvbnMpO1xuICB9LFxuICBjcmVhdGVJZk5vdEV4aXN0czogZnVuY3Rpb24gY3JlYXRlSWZOb3RFeGlzdHMoZG9jLCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdG9ycy5yZXF1aXJlRG9jdW1lbnRJZCgnY3JlYXRlSWZOb3RFeGlzdHMnLCBkb2MpO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGUoZG9jLCAnY3JlYXRlSWZOb3RFeGlzdHMnLCBvcHRpb25zKTtcbiAgfSxcbiAgY3JlYXRlT3JSZXBsYWNlOiBmdW5jdGlvbiBjcmVhdGVPclJlcGxhY2UoZG9jLCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdG9ycy5yZXF1aXJlRG9jdW1lbnRJZCgnY3JlYXRlT3JSZXBsYWNlJywgZG9jKTtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlKGRvYywgJ2NyZWF0ZU9yUmVwbGFjZScsIG9wdGlvbnMpO1xuICB9LFxuICBwYXRjaDogZnVuY3Rpb24gcGF0Y2goc2VsZWN0b3IsIG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhdGNoKHNlbGVjdG9yLCBvcGVyYXRpb25zLCB0aGlzKTtcbiAgfSxcbiAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmRhdGFSZXF1ZXN0KCdtdXRhdGUnLCB7XG4gICAgICBtdXRhdGlvbnM6IFt7XG4gICAgICAgIGRlbGV0ZTogZ2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0sXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKG11dGF0aW9ucywgb3B0aW9ucykge1xuICAgIHZhciBtdXQgPSBtdXRhdGlvbnMgaW5zdGFuY2VvZiBQYXRjaCB8fCBtdXRhdGlvbnMgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiA/IG11dGF0aW9ucy5zZXJpYWxpemUoKSA6IG11dGF0aW9ucztcbiAgICB2YXIgbXV0cyA9IEFycmF5LmlzQXJyYXkobXV0KSA/IG11dCA6IFttdXRdO1xuICAgIHZhciB0cmFuc2FjdGlvbklkID0gb3B0aW9ucyAmJiBvcHRpb25zLnRyYW5zYWN0aW9uSWQ7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVJlcXVlc3QoJ211dGF0ZScsIHtcbiAgICAgIG11dGF0aW9uczogbXV0cyxcbiAgICAgIHRyYW5zYWN0aW9uSWQ6IHRyYW5zYWN0aW9uSWRcbiAgICB9LCBvcHRpb25zKTtcbiAgfSxcbiAgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIHRyYW5zYWN0aW9uKG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9LFxuICBkYXRhUmVxdWVzdDogZnVuY3Rpb24gZGF0YVJlcXVlc3QoZW5kcG9pbnQsIGJvZHkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMuX2RhdGFSZXF1ZXN0KGVuZHBvaW50LCBib2R5LCBvcHRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLmlzUHJvbWlzZUFQSSgpID8gdG9Qcm9taXNlKHJlcXVlc3QpIDogcmVxdWVzdDtcbiAgfSxcbiAgX2RhdGFSZXF1ZXN0OiBmdW5jdGlvbiBfZGF0YVJlcXVlc3QoZW5kcG9pbnQsIGJvZHkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGlzTXV0YXRpb24gPSBlbmRwb2ludCA9PT0gJ211dGF0ZSc7IC8vIENoZWNrIGlmIHRoZSBxdWVyeSBzdHJpbmcgaXMgd2l0aGluIGEgY29uZmlndXJlZCB0aHJlc2hvbGQsXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBjYW4gdXNlIEdFVC4gT3RoZXJ3aXNlLCB1c2UgUE9TVC5cblxuICAgIHZhciBzdHJRdWVyeSA9ICFpc011dGF0aW9uICYmIGVuY29kZVF1ZXJ5U3RyaW5nKGJvZHkpO1xuICAgIHZhciB1c2VHZXQgPSAhaXNNdXRhdGlvbiAmJiBzdHJRdWVyeS5sZW5ndGggPCBnZXRRdWVyeVNpemVMaW1pdDtcbiAgICB2YXIgc3RyaW5nUXVlcnkgPSB1c2VHZXQgPyBzdHJRdWVyeSA6ICcnO1xuICAgIHZhciByZXR1cm5GaXJzdCA9IG9wdGlvbnMucmV0dXJuRmlyc3Q7XG4gICAgdmFyIHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQsXG4gICAgICAgIHRva2VuID0gb3B0aW9ucy50b2tlbjtcbiAgICB2YXIgdXJpID0gdGhpcy5nZXREYXRhVXJsKGVuZHBvaW50LCBzdHJpbmdRdWVyeSk7XG4gICAgdmFyIHJlcU9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6IHVzZUdldCA/ICdHRVQnIDogJ1BPU1QnLFxuICAgICAgdXJpOiB1cmksXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgYm9keTogdXNlR2V0ID8gdW5kZWZpbmVkIDogYm9keSxcbiAgICAgIHF1ZXJ5OiBpc011dGF0aW9uICYmIGdldE11dGF0aW9uUXVlcnkob3B0aW9ucyksXG4gICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgdG9rZW46IHRva2VuXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE9ic2VydmFibGUocmVxT3B0aW9ucykucGlwZShmaWx0ZXIoaXNSZXNwb25zZSksIG1hcChnZXRCb2R5KSwgbWFwKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmICghaXNNdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSAvLyBTaG91bGQgd2UgcmV0dXJuIGRvY3VtZW50cz9cblxuXG4gICAgICB2YXIgcmVzdWx0cyA9IHJlcy5yZXN1bHRzIHx8IFtdO1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5Eb2N1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0ID8gcmVzdWx0c1swXSAmJiByZXN1bHRzWzBdLmRvY3VtZW50IDogcmVzdWx0cy5tYXAoZnVuY3Rpb24gKG11dCkge1xuICAgICAgICAgIHJldHVybiBtdXQuZG9jdW1lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBSZXR1cm4gYSByZWR1Y2VkIHN1YnNldFxuXG5cbiAgICAgIHZhciBrZXkgPSByZXR1cm5GaXJzdCA/ICdkb2N1bWVudElkJyA6ICdkb2N1bWVudElkcyc7XG4gICAgICB2YXIgaWRzID0gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uaWQgOiByZXN1bHRzLm1hcChmdW5jdGlvbiAobXV0KSB7XG4gICAgICAgIHJldHVybiBtdXQuaWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICB0cmFuc2FjdGlvbklkOiByZXMudHJhbnNhY3Rpb25JZCxcbiAgICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgICAgfSwga2V5LCBpZHMpO1xuICAgIH0pKTtcbiAgfSxcbiAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZShkb2MsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdmFyIG11dGF0aW9uID0gX2RlZmluZVByb3BlcnR5KHt9LCBvcCwgZG9jKTtcblxuICAgIHZhciBvcHRzID0gYXNzaWduKHtcbiAgICAgIHJldHVybkZpcnN0OiB0cnVlLFxuICAgICAgcmV0dXJuRG9jdW1lbnRzOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVJlcXVlc3QoJ211dGF0ZScsIHtcbiAgICAgIG11dGF0aW9uczogW211dGF0aW9uXVxuICAgIH0sIG9wdHMpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBxdWVyeSA9IF9yZWYucXVlcnksXG4gICAgICBfcmVmJHBhcmFtcyA9IF9yZWYucGFyYW1zLFxuICAgICAgcGFyYW1zID0gX3JlZiRwYXJhbXMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRwYXJhbXMsXG4gICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucztcbiAgdmFyIGJhc2UgPSBcIj9xdWVyeT1cIi5jb25jYXQoZW5jKHF1ZXJ5KSk7XG4gIHZhciBxU3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoZnVuY3Rpb24gKHFzLCBwYXJhbSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChxcywgXCImXCIpLmNvbmNhdChlbmMoXCIkXCIuY29uY2F0KHBhcmFtKSksIFwiPVwiKS5jb25jYXQoZW5jKEpTT04uc3RyaW5naWZ5KHBhcmFtc1twYXJhbV0pKSk7XG4gIH0sIGJhc2UpO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKGZ1bmN0aW9uIChxcywgb3B0aW9uKSB7XG4gICAgLy8gT25seSBpbmNsdWRlIHRoZSBvcHRpb24gaWYgaXQgaXMgdHJ1dGh5XG4gICAgcmV0dXJuIG9wdGlvbnNbb3B0aW9uXSA/IFwiXCIuY29uY2F0KHFzLCBcIiZcIikuY29uY2F0KGVuYyhvcHRpb24pLCBcIj1cIikuY29uY2F0KGVuYyhvcHRpb25zW29wdGlvbl0pKSA6IHFzO1xuICB9LCBxU3RyaW5nKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBPYnNlcnZhYmxlID0gcmVxdWlyZSgnQHNhbml0eS9vYnNlcnZhYmxlL21pbmltYWwnKTtcblxudmFyIHBvbHlmaWxsZWRFdmVudFNvdXJjZSA9IHJlcXVpcmUoJ0BzYW5pdHkvZXZlbnRzb3VyY2UnKTtcblxudmFyIHBpY2sgPSByZXF1aXJlKCcuLi91dGlsL3BpY2snKTtcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vdXRpbC9kZWZhdWx0cycpO1xuXG52YXIgZW5jb2RlUXVlcnlTdHJpbmcgPSByZXF1aXJlKCcuL2VuY29kZVF1ZXJ5U3RyaW5nJyk7XG5cbnZhciBnZW5lcmF0ZUhlbHBVcmwgPSByZXF1aXJlKCdAc2FuaXR5L2dlbmVyYXRlLWhlbHAtdXJsJyk7XG5cbnZhciBvbmNlID0gcmVxdWlyZSgnLi4vdXRpbC9vbmNlJyk7XG5cbnZhciB0b2tlbldhcm5pbmcgPSBbJ1VzaW5nIHRva2VuIHdpdGggbGlzdGVuZXJzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlcnMuICcsIFwiRm9yIG1vcmUgaW5mbywgc2VlIFwiLmNvbmNhdChnZW5lcmF0ZUhlbHBVcmwoJ2pzLWNsaWVudC1saXN0ZW5lci10b2tlbnMtYnJvd3NlcicpLCBcIi5cIildOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG52YXIgcHJpbnRUb2tlbldhcm5pbmcgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNvbnNvbGUud2Fybih0b2tlbldhcm5pbmcuam9pbignICcpKTtcbn0pO1xudmFyIGlzV2luZG93RXZlbnRTb3VyY2UgPSBCb29sZWFuKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5FdmVudFNvdXJjZSk7XG52YXIgRXZlbnRTb3VyY2UgPSBpc1dpbmRvd0V2ZW50U291cmNlID8gd2luZG93LkV2ZW50U291cmNlIC8vIE5hdGl2ZSBicm93c2VyIEV2ZW50U291cmNlXG46IHBvbHlmaWxsZWRFdmVudFNvdXJjZTsgLy8gTm9kZS5qcywgSUUgZXRjXG5cbnZhciBwb3NzaWJsZU9wdGlvbnMgPSBbJ2luY2x1ZGVQcmV2aW91c1JldmlzaW9uJywgJ2luY2x1ZGVSZXN1bHQnLCAndmlzaWJpbGl0eScsICdlZmZlY3RGb3JtYXQnXTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaW5jbHVkZVJlc3VsdDogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0ZW4ocXVlcnksIHBhcmFtcykge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBvcHRpb25zID0gZGVmYXVsdHMob3B0cywgZGVmYXVsdE9wdGlvbnMpO1xuICB2YXIgbGlzdGVuT3B0cyA9IHBpY2sob3B0aW9ucywgcG9zc2libGVPcHRpb25zKTtcbiAgdmFyIHFzID0gZW5jb2RlUXVlcnlTdHJpbmcoe1xuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICBvcHRpb25zOiBsaXN0ZW5PcHRzXG4gIH0pO1xuICB2YXIgX3RoaXMkY2xpZW50Q29uZmlnID0gdGhpcy5jbGllbnRDb25maWcsXG4gICAgICB1cmwgPSBfdGhpcyRjbGllbnRDb25maWcudXJsLFxuICAgICAgdG9rZW4gPSBfdGhpcyRjbGllbnRDb25maWcudG9rZW4sXG4gICAgICB3aXRoQ3JlZGVudGlhbHMgPSBfdGhpcyRjbGllbnRDb25maWcud2l0aENyZWRlbnRpYWxzO1xuICB2YXIgdXJpID0gXCJcIi5jb25jYXQodXJsKS5jb25jYXQodGhpcy5nZXREYXRhVXJsKCdsaXN0ZW4nLCBxcykpO1xuICB2YXIgbGlzdGVuRm9yID0gb3B0aW9ucy5ldmVudHMgPyBvcHRpb25zLmV2ZW50cyA6IFsnbXV0YXRpb24nXTtcbiAgdmFyIHNob3VsZEVtaXRSZWNvbm5lY3QgPSBsaXN0ZW5Gb3IuaW5kZXhPZigncmVjb25uZWN0JykgIT09IC0xO1xuXG4gIGlmICh0b2tlbiAmJiBpc1dpbmRvd0V2ZW50U291cmNlKSB7XG4gICAgcHJpbnRUb2tlbldhcm5pbmcoKTtcbiAgfVxuXG4gIHZhciBlc09wdGlvbnMgPSB7fTtcblxuICBpZiAodG9rZW4gfHwgd2l0aENyZWRlbnRpYWxzKSB7XG4gICAgZXNPcHRpb25zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICBlc09wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgIEF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiLmNvbmNhdCh0b2tlbilcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIHZhciBlcyA9IGdldEV2ZW50U291cmNlKCk7XG4gICAgdmFyIHJlY29ubmVjdFRpbWVyO1xuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbWl0UmVjb25uZWN0KCk7IC8vIEFsbG93IGV2ZW50IGhhbmRsZXJzIG9mIGBlbWl0UmVjb25uZWN0YCB0byBjYW5jZWwvY2xvc2UgdGhlIHJlY29ubmVjdCBhdHRlbXB0XG5cbiAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVW5sZXNzIHdlJ3ZlIGV4cGxpY2l0bHkgc3RvcHBlZCB0aGUgRVMgKGluIHdoaWNoIGNhc2UgYHN0b3BwZWRgIHNob3VsZCBiZSB0cnVlKSxcbiAgICAgIC8vIHdlIHNob3VsZCBuZXZlciBiZSBpbiBhIGRpc2Nvbm5lY3RlZCBzdGF0ZS4gQnkgZGVmYXVsdCwgRXZlbnRTb3VyY2Ugd2lsbCByZWNvbm5lY3RcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHksIGluIHdoaWNoIGNhc2UgaXQgc2V0cyByZWFkeVN0YXRlIHRvIGBDT05ORUNUSU5HYCwgYnV0IGluIHNvbWUgY2FzZXNcbiAgICAgIC8vIChsaWtlIHdoZW4gYSBsYXB0b3AgbGlkIGlzIGNsb3NlZCksIGl0IGNsb3NlcyB0aGUgY29ubmVjdGlvbi4gSW4gdGhlc2UgY2FzZXMgd2UgbmVlZFxuICAgICAgLy8gdG8gZXhwbGljaXRseSByZWNvbm5lY3QuXG5cblxuICAgICAgaWYgKGVzLnJlYWR5U3RhdGUgPT09IEV2ZW50U291cmNlLkNMT1NFRCkge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZXIpO1xuICAgICAgICByZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQob3BlbiwgMTAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5uZWxFcnJvcihlcnIpIHtcbiAgICAgIG9ic2VydmVyLmVycm9yKGNvb2VyY2VFcnJvcihlcnIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZ0KSB7XG4gICAgICB2YXIgZXZlbnQgPSBwYXJzZUV2ZW50KGV2dCk7XG4gICAgICByZXR1cm4gZXZlbnQgaW5zdGFuY2VvZiBFcnJvciA/IG9ic2VydmVyLmVycm9yKGV2ZW50KSA6IG9ic2VydmVyLm5leHQoZXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRGlzY29ubmVjdChldnQpIHtcbiAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBlcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IsIGZhbHNlKTtcbiAgICAgIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5uZWxFcnJvcicsIG9uQ2hhbm5lbEVycm9yLCBmYWxzZSk7XG4gICAgICBlcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNjb25uZWN0Jywgb25EaXNjb25uZWN0LCBmYWxzZSk7XG4gICAgICBsaXN0ZW5Gb3IuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgZXMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0UmVjb25uZWN0KCkge1xuICAgICAgaWYgKHNob3VsZEVtaXRSZWNvbm5lY3QpIHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgdHlwZTogJ3JlY29ubmVjdCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2UoKSB7XG4gICAgICB2YXIgZXZzID0gbmV3IEV2ZW50U291cmNlKHVyaSwgZXNPcHRpb25zKTtcbiAgICAgIGV2cy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IsIGZhbHNlKTtcbiAgICAgIGV2cy5hZGRFdmVudExpc3RlbmVyKCdjaGFubmVsRXJyb3InLCBvbkNoYW5uZWxFcnJvciwgZmFsc2UpO1xuICAgICAgZXZzLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc2Nvbm5lY3QnLCBvbkRpc2Nvbm5lY3QsIGZhbHNlKTtcbiAgICAgIGxpc3RlbkZvci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBldnMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV2cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgZXMgPSBnZXRFdmVudFNvdXJjZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3A7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gcGFyc2VFdmVudChldmVudCkge1xuICB0cnkge1xuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YSAmJiBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIHx8IHt9O1xuICAgIHJldHVybiBhc3NpZ24oe1xuICAgICAgdHlwZTogZXZlbnQudHlwZVxuICAgIH0sIGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvb2VyY2VFcnJvcihlcnIpIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuXG4gIHZhciBldnQgPSBwYXJzZUV2ZW50KGVycik7XG4gIHJldHVybiBldnQgaW5zdGFuY2VvZiBFcnJvciA/IGV2dCA6IG5ldyBFcnJvcihleHRyYWN0RXJyb3JNZXNzYWdlKGV2dCkpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3JNZXNzYWdlKGVycikge1xuICBpZiAoIWVyci5lcnJvcikge1xuICAgIHJldHVybiBlcnIubWVzc2FnZSB8fCAnVW5rbm93biBsaXN0ZW5lciBlcnJvcic7XG4gIH1cblxuICBpZiAoZXJyLmVycm9yLmRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGVyci5lcnJvci5kZXNjcmlwdGlvbjtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgZXJyLmVycm9yID09PSAnc3RyaW5nJyA/IGVyci5lcnJvciA6IEpTT04uc3RyaW5naWZ5KGVyci5lcnJvciwgbnVsbCwgMik7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBkZWVwQXNzaWduID0gcmVxdWlyZSgnZGVlcC1hc3NpZ24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGdldFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0U2VsZWN0aW9uJyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKTtcblxudmFyIHZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGUudmFsaWRhdGVPYmplY3Q7XG52YXIgdmFsaWRhdGVJbnNlcnQgPSB2YWxpZGF0ZS52YWxpZGF0ZUluc2VydDtcblxuZnVuY3Rpb24gUGF0Y2goc2VsZWN0aW9uKSB7XG4gIHZhciBvcGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGNsaWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIHRoaXMub3BlcmF0aW9ucyA9IGFzc2lnbih7fSwgb3BlcmF0aW9ucyk7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG5hc3NpZ24oUGF0Y2gucHJvdG90eXBlLCB7XG4gIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBhdGNoKHRoaXMuc2VsZWN0aW9uLCBhc3NpZ24oe30sIHRoaXMub3BlcmF0aW9ucyksIHRoaXMuY2xpZW50KTtcbiAgfSxcbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHByb3BzKSB7XG4gICAgdmFsaWRhdGVPYmplY3QoJ21lcmdlJywgcHJvcHMpO1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICB9KS5zbGljZSgyKTtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgXFxcIm1lcmdlXFxcIiBwYXRjaCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZVxcblwiLmNvbmNhdChzdGFjay5qb2luKCdcXG4nKSkpO1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oJ21lcmdlJywgZGVlcEFzc2lnbih0aGlzLm9wZXJhdGlvbnMubWVyZ2UgfHwge30sIHByb3BzKSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbignc2V0JywgcHJvcHMpO1xuICB9LFxuICBkaWZmTWF0Y2hQYXRjaDogZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2gocHJvcHMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdCgnZGlmZk1hdGNoUGF0Y2gnLCBwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbignZGlmZk1hdGNoUGF0Y2gnLCBwcm9wcyk7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiB1bnNldChhdHRycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zZXQoYXR0cnMpIHRha2VzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gdW5zZXQsIG5vbi1hcnJheSBnaXZlbicpO1xuICAgIH1cblxuICAgIHRoaXMub3BlcmF0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5vcGVyYXRpb25zLCB7XG4gICAgICB1bnNldDogYXR0cnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0SWZNaXNzaW5nOiBmdW5jdGlvbiBzZXRJZk1pc3NpbmcocHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKCdzZXRJZk1pc3NpbmcnLCBwcm9wcyk7XG4gIH0sXG4gIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UocHJvcHMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdCgncmVwbGFjZScsIHByb3BzKTtcbiAgICByZXR1cm4gdGhpcy5fc2V0KCdzZXQnLCB7XG4gICAgICAkOiBwcm9wc1xuICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGlkLWxlbmd0aFxuICB9LFxuICBpbmM6IGZ1bmN0aW9uIGluYyhwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oJ2luYycsIHByb3BzKTtcbiAgfSxcbiAgZGVjOiBmdW5jdGlvbiBkZWMocHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKCdkZWMnLCBwcm9wcyk7XG4gIH0sXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpIHtcbiAgICB2YXIgX3RoaXMkX2Fzc2lnbjtcblxuICAgIHZhbGlkYXRlSW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpO1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oJ2luc2VydCcsIChfdGhpcyRfYXNzaWduID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRfYXNzaWduLCBhdCwgc2VsZWN0b3IpLCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkX2Fzc2lnbiwgXCJpdGVtc1wiLCBpdGVtcyksIF90aGlzJF9hc3NpZ24pKTtcbiAgfSxcbiAgYXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQoc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KCdhZnRlcicsIFwiXCIuY29uY2F0KHNlbGVjdG9yLCBcIlstMV1cIiksIGl0ZW1zKTtcbiAgfSxcbiAgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZChzZWxlY3RvciwgaXRlbXMpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoJ2JlZm9yZScsIFwiXCIuY29uY2F0KHNlbGVjdG9yLCBcIlswXVwiKSwgaXRlbXMpO1xuICB9LFxuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzZWxlY3Rvciwgc3RhcnQsIGRlbGV0ZUNvdW50LCBpdGVtcykge1xuICAgIC8vIE5lZ2F0aXZlIGluZGV4ZXMgZG9lc24ndCBtZWFuIHRoZSBzYW1lIGluIFNhbml0eSBhcyB0aGV5IGRvIGluIEpTO1xuICAgIC8vIC0xIG1lYW5zIFwiYWN0dWFsbHkgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXlcIiwgd2hpY2ggYWxsb3dzIGluc2VydGluZ1xuICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IHdpdGhvdXQga25vd2luZyBpdHMgbGVuZ3RoLiBXZSB0aGVyZWZvcmUgaGF2ZVxuICAgIC8vIHRvIHN1YnN0cmFjdCBuZWdhdGl2ZSBpbmRleGVzIGJ5IG9uZSB0byBtYXRjaCBKUy4gSWYgeW91IHdhbnQgU2FuaXR5LVxuICAgIC8vIGJlaGF2aW91ciwganVzdCB1c2UgYGluc2VydCgncmVwbGFjZScsIHNlbGVjdG9yLCBpdGVtcylgIGRpcmVjdGx5XG4gICAgdmFyIGRlbEFsbCA9IHR5cGVvZiBkZWxldGVDb3VudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZGVsZXRlQ291bnQgPT09IC0xO1xuICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnQgPCAwID8gc3RhcnQgLSAxIDogc3RhcnQ7XG4gICAgdmFyIGRlbENvdW50ID0gZGVsQWxsID8gLTEgOiBNYXRoLm1heCgwLCBzdGFydCArIGRlbGV0ZUNvdW50KTtcbiAgICB2YXIgZGVsUmFuZ2UgPSBzdGFydEluZGV4IDwgMCAmJiBkZWxDb3VudCA+PSAwID8gJycgOiBkZWxDb3VudDtcbiAgICB2YXIgcmFuZ2VTZWxlY3RvciA9IFwiXCIuY29uY2F0KHNlbGVjdG9yLCBcIltcIikuY29uY2F0KHN0YXJ0SW5kZXgsIFwiOlwiKS5jb25jYXQoZGVsUmFuZ2UsIFwiXVwiKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoJ3JlcGxhY2UnLCByYW5nZVNlbGVjdG9yLCBpdGVtcyB8fCBbXSk7XG4gIH0sXG4gIGlmUmV2aXNpb25JZDogZnVuY3Rpb24gaWZSZXZpc2lvbklkKHJldikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5pZlJldmlzaW9uSUQgPSByZXY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBhc3NpZ24oZ2V0U2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uKSwgdGhpcy5vcGVyYXRpb25zKTtcbiAgfSxcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gIH0sXG4gIGNvbW1pdDogZnVuY3Rpb24gY29tbWl0KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGlmICghdGhpcy5jbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYGNsaWVudGAgcGFzc2VkIHRvIHBhdGNoLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgJyArICdwYXRjaCB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2QnKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuRmlyc3QgPSB0eXBlb2YgdGhpcy5zZWxlY3Rpb24gPT09ICdzdHJpbmcnO1xuICAgIHZhciBvcHRzID0gYXNzaWduKHtcbiAgICAgIHJldHVybkZpcnN0OiByZXR1cm5GaXJzdCxcbiAgICAgIHJldHVybkRvY3VtZW50czogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5tdXRhdGUoe1xuICAgICAgcGF0Y2g6IHRoaXMuc2VyaWFsaXplKClcbiAgICB9LCBvcHRzKTtcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMub3BlcmF0aW9ucyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfc2V0OiBmdW5jdGlvbiBfc2V0KG9wLCBwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24ob3AsIHByb3BzLCBmYWxzZSk7XG4gIH0sXG4gIF9hc3NpZ246IGZ1bmN0aW9uIF9hc3NpZ24ob3AsIHByb3BzKSB7XG4gICAgdmFyIG1lcmdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wLCBwcm9wcyk7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gYXNzaWduKHt9LCB0aGlzLm9wZXJhdGlvbnMsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgb3AsIGFzc2lnbih7fSwgbWVyZ2UgJiYgdGhpcy5vcGVyYXRpb25zW29wXSB8fCB7fSwgcHJvcHMpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBQYXRjaDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIHZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XG5cbnZhciBQYXRjaCA9IHJlcXVpcmUoJy4vcGF0Y2gnKTtcblxudmFyIGRlZmF1bHRNdXRhdGVPcHRpb25zID0ge1xuICByZXR1cm5Eb2N1bWVudHM6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBUcmFuc2FjdGlvbigpIHtcbiAgdmFyIG9wZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICB2YXIgY2xpZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciB0cmFuc2FjdGlvbklkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHRoaXMudHJ4SWQgPSB0cmFuc2FjdGlvbklkO1xuICB0aGlzLm9wZXJhdGlvbnMgPSBvcGVyYXRpb25zO1xuICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuYXNzaWduKFRyYW5zYWN0aW9uLnByb3RvdHlwZSwge1xuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzLm9wZXJhdGlvbnMuc2xpY2UoMCksIHRoaXMuY2xpZW50LCB0aGlzLnRyeElkKTtcbiAgfSxcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZG9jKSB7XG4gICAgdmFsaWRhdG9ycy52YWxpZGF0ZU9iamVjdCgnY3JlYXRlJywgZG9jKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgIGNyZWF0ZTogZG9jXG4gICAgfSk7XG4gIH0sXG4gIGNyZWF0ZUlmTm90RXhpc3RzOiBmdW5jdGlvbiBjcmVhdGVJZk5vdEV4aXN0cyhkb2MpIHtcbiAgICB2YXIgb3AgPSAnY3JlYXRlSWZOb3RFeGlzdHMnO1xuICAgIHZhbGlkYXRvcnMudmFsaWRhdGVPYmplY3Qob3AsIGRvYyk7XG4gICAgdmFsaWRhdG9ycy5yZXF1aXJlRG9jdW1lbnRJZChvcCwgZG9jKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkKF9kZWZpbmVQcm9wZXJ0eSh7fSwgb3AsIGRvYykpO1xuICB9LFxuICBjcmVhdGVPclJlcGxhY2U6IGZ1bmN0aW9uIGNyZWF0ZU9yUmVwbGFjZShkb2MpIHtcbiAgICB2YXIgb3AgPSAnY3JlYXRlT3JSZXBsYWNlJztcbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlT2JqZWN0KG9wLCBkb2MpO1xuICAgIHZhbGlkYXRvcnMucmVxdWlyZURvY3VtZW50SWQob3AsIGRvYyk7XG4gICAgcmV0dXJuIHRoaXMuX2FkZChfZGVmaW5lUHJvcGVydHkoe30sIG9wLCBkb2MpKTtcbiAgfSxcbiAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKGRvY3VtZW50SWQpIHtcbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlRG9jdW1lbnRJZCgnZGVsZXRlJywgZG9jdW1lbnRJZCk7XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh7XG4gICAgICBkZWxldGU6IHtcbiAgICAgICAgaWQ6IGRvY3VtZW50SWRcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgcGF0Y2g6IGZ1bmN0aW9uIHBhdGNoKGRvY3VtZW50SWQsIHBhdGNoT3BzKSB7XG4gICAgdmFyIGlzQnVpbGRlciA9IHR5cGVvZiBwYXRjaE9wcyA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgaXNQYXRjaCA9IGRvY3VtZW50SWQgaW5zdGFuY2VvZiBQYXRjaDsgLy8gdHJhbnNhY3Rpb24ucGF0Y2goY2xpZW50LnBhdGNoKCdkb2N1bWVudElkJykuaW5jKHt2aXNpdHM6IDF9KSlcblxuICAgIGlmIChpc1BhdGNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgICAgcGF0Y2g6IGRvY3VtZW50SWQuc2VyaWFsaXplKClcbiAgICAgIH0pO1xuICAgIH0gLy8gcGF0Y2ggPT4gcGF0Y2guaW5jKHt2aXNpdHM6IDF9KS5zZXQoe2ZvbzogJ2Jhcid9KVxuXG5cbiAgICBpZiAoaXNCdWlsZGVyKSB7XG4gICAgICB2YXIgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgUGF0Y2goZG9jdW1lbnRJZCwge30sIHRoaXMuY2xpZW50KSk7XG5cbiAgICAgIGlmICghKHBhdGNoIGluc3RhbmNlb2YgUGF0Y2gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gcGFzc2VkIHRvIGBwYXRjaCgpYCBtdXN0IHJldHVybiB0aGUgcGF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2FkZCh7XG4gICAgICAgIHBhdGNoOiBwYXRjaC5zZXJpYWxpemUoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZCh7XG4gICAgICBwYXRjaDogYXNzaWduKHtcbiAgICAgICAgaWQ6IGRvY3VtZW50SWRcbiAgICAgIH0sIHBhdGNoT3BzKVxuICAgIH0pO1xuICB9LFxuICB0cmFuc2FjdGlvbklkOiBmdW5jdGlvbiB0cmFuc2FjdGlvbklkKGlkKSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJ4SWQ7XG4gICAgfVxuXG4gICAgdGhpcy50cnhJZCA9IGlkO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zLnNsaWNlKCk7XG4gIH0sXG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICB9LFxuICBjb21taXQ6IGZ1bmN0aW9uIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBgY2xpZW50YCBwYXNzZWQgdG8gdHJhbnNhY3Rpb24sIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSAnICsgJ3RyYW5zYWN0aW9uIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNsaWVudC5tdXRhdGUodGhpcy5zZXJpYWxpemUoKSwgYXNzaWduKHtcbiAgICAgIHRyYW5zYWN0aW9uSWQ6IHRoaXMudHJ4SWRcbiAgICB9LCBkZWZhdWx0TXV0YXRlT3B0aW9ucywgb3B0aW9ucyB8fCB7fSkpO1xuICB9LFxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9hZGQ6IGZ1bmN0aW9uIF9hZGQobXV0KSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnB1c2gobXV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XG5cbmZ1bmN0aW9uIERhdGFzZXRzQ2xpZW50KGNsaWVudCkge1xuICB0aGlzLnJlcXVlc3QgPSBjbGllbnQucmVxdWVzdC5iaW5kKGNsaWVudCk7XG59XG5cbmFzc2lnbihEYXRhc2V0c0NsaWVudC5wcm90b3R5cGUsIHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9tb2RpZnkoJ1BVVCcsIG5hbWUsIG9wdGlvbnMpO1xuICB9LFxuICBlZGl0OiBmdW5jdGlvbiBlZGl0KG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kaWZ5KCdQQVRDSCcsIG5hbWUsIG9wdGlvbnMpO1xuICB9LFxuICBkZWxldGU6IGZ1bmN0aW9uIF9kZWxldGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9tb2RpZnkoJ0RFTEVURScsIG5hbWUpO1xuICB9LFxuICBsaXN0OiBmdW5jdGlvbiBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgdXJpOiAnL2RhdGFzZXRzJ1xuICAgIH0pO1xuICB9LFxuICBfbW9kaWZ5OiBmdW5jdGlvbiBfbW9kaWZ5KG1ldGhvZCwgbmFtZSwgYm9keSkge1xuICAgIHZhbGlkYXRlLmRhdGFzZXQobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVyaTogXCIvZGF0YXNldHMvXCIuY29uY2F0KG5hbWUpLFxuICAgICAgYm9keTogYm9keVxuICAgIH0pO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YXNldHNDbGllbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gW107IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtYWtlRXJyb3IgPSByZXF1aXJlKCdtYWtlLWVycm9yJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmZ1bmN0aW9uIENsaWVudEVycm9yKHJlcykge1xuICB2YXIgcHJvcHMgPSBleHRyYWN0RXJyb3JQcm9wcyhyZXMpO1xuICBDbGllbnRFcnJvci5zdXBlci5jYWxsKHRoaXMsIHByb3BzLm1lc3NhZ2UpO1xuICBhc3NpZ24odGhpcywgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBTZXJ2ZXJFcnJvcihyZXMpIHtcbiAgdmFyIHByb3BzID0gZXh0cmFjdEVycm9yUHJvcHMocmVzKTtcbiAgU2VydmVyRXJyb3Iuc3VwZXIuY2FsbCh0aGlzLCBwcm9wcy5tZXNzYWdlKTtcbiAgYXNzaWduKHRoaXMsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yUHJvcHMocmVzKSB7XG4gIHZhciBib2R5ID0gcmVzLmJvZHk7XG4gIHZhciBwcm9wcyA9IHtcbiAgICByZXNwb25zZTogcmVzLFxuICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLFxuICAgIHJlc3BvbnNlQm9keTogc3RyaW5naWZ5Qm9keShib2R5LCByZXMpXG4gIH07IC8vIEFQSS9Cb29tIHN0eWxlIGVycm9ycyAoe3N0YXR1c0NvZGUsIGVycm9yLCBtZXNzYWdlfSlcblxuICBpZiAoYm9keS5lcnJvciAmJiBib2R5Lm1lc3NhZ2UpIHtcbiAgICBwcm9wcy5tZXNzYWdlID0gXCJcIi5jb25jYXQoYm9keS5lcnJvciwgXCIgLSBcIikuY29uY2F0KGJvZHkubWVzc2FnZSk7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9IC8vIFF1ZXJ5L2RhdGFiYXNlIGVycm9ycyAoe2Vycm9yOiB7ZGVzY3JpcHRpb24sIG90aGVyLCBhcmIsIHByb3BzfX0pXG5cblxuICBpZiAoYm9keS5lcnJvciAmJiBib2R5LmVycm9yLmRlc2NyaXB0aW9uKSB7XG4gICAgcHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IuZGVzY3JpcHRpb247XG4gICAgcHJvcHMuZGV0YWlscyA9IGJvZHkuZXJyb3I7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9IC8vIE90aGVyLCBtb3JlIGFyYml0cmFyeSBlcnJvcnNcblxuXG4gIHByb3BzLm1lc3NhZ2UgPSBib2R5LmVycm9yIHx8IGJvZHkubWVzc2FnZSB8fCBodHRwRXJyb3JNZXNzYWdlKHJlcyk7XG4gIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gaHR0cEVycm9yTWVzc2FnZShyZXMpIHtcbiAgdmFyIHN0YXR1c01lc3NhZ2UgPSByZXMuc3RhdHVzTWVzc2FnZSA/IFwiIFwiLmNvbmNhdChyZXMuc3RhdHVzTWVzc2FnZSkgOiAnJztcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHJlcy5tZXRob2QsIFwiLXJlcXVlc3QgdG8gXCIpLmNvbmNhdChyZXMudXJsLCBcIiByZXN1bHRlZCBpbiBIVFRQIFwiKS5jb25jYXQocmVzLnN0YXR1c0NvZGUpLmNvbmNhdChzdGF0dXNNZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Qm9keShib2R5LCByZXMpIHtcbiAgdmFyIGNvbnRlbnRUeXBlID0gKHJlcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGlzSnNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSAhPT0gLTE7XG4gIHJldHVybiBpc0pzb24gPyBKU09OLnN0cmluZ2lmeShib2R5LCBudWxsLCAyKSA6IGJvZHk7XG59XG5cbm1ha2VFcnJvcihDbGllbnRFcnJvcik7XG5tYWtlRXJyb3IoU2VydmVyRXJyb3IpO1xuZXhwb3J0cy5DbGllbnRFcnJvciA9IENsaWVudEVycm9yO1xuZXhwb3J0cy5TZXJ2ZXJFcnJvciA9IFNlcnZlckVycm9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgdmFyIHFzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcXMucHVzaChcIlwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoa2V5KSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHFzLmxlbmd0aCA+IDAgPyBcIj9cIi5jb25jYXQocXMuam9pbignJicpKSA6ICcnO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHktZnVuY3Rpb24sIG5vLXByb2Nlc3MtZW52ICovXG52YXIgZ2V0SXQgPSByZXF1aXJlKCdnZXQtaXQnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIG9ic2VydmFibGUgPSByZXF1aXJlKCdnZXQtaXQvbGliL21pZGRsZXdhcmUvb2JzZXJ2YWJsZScpO1xuXG52YXIganNvblJlcXVlc3QgPSByZXF1aXJlKCdnZXQtaXQvbGliL21pZGRsZXdhcmUvanNvblJlcXVlc3QnKTtcblxudmFyIGpzb25SZXNwb25zZSA9IHJlcXVpcmUoJ2dldC1pdC9saWIvbWlkZGxld2FyZS9qc29uUmVzcG9uc2UnKTtcblxudmFyIHByb2dyZXNzID0gcmVxdWlyZSgnZ2V0LWl0L2xpYi9taWRkbGV3YXJlL3Byb2dyZXNzJyk7XG5cbnZhciBPYnNlcnZhYmxlID0gcmVxdWlyZSgnQHNhbml0eS9vYnNlcnZhYmxlL21pbmltYWwnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9lcnJvcnMnKSxcbiAgICBDbGllbnRFcnJvciA9IF9yZXF1aXJlLkNsaWVudEVycm9yLFxuICAgIFNlcnZlckVycm9yID0gX3JlcXVpcmUuU2VydmVyRXJyb3I7XG5cbnZhciBodHRwRXJyb3IgPSB7XG4gIG9uUmVzcG9uc2U6IGZ1bmN0aW9uIG9uUmVzcG9uc2UocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKHJlcyk7XG4gICAgfSBlbHNlIGlmIChyZXMuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIHRocm93IG5ldyBDbGllbnRFcnJvcihyZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cbn07XG52YXIgcHJpbnRXYXJuaW5ncyA9IHtcbiAgb25SZXNwb25zZTogZnVuY3Rpb24gb25SZXNwb25zZShyZXMpIHtcbiAgICB2YXIgd2FybiA9IHJlcy5oZWFkZXJzWyd4LXNhbml0eS13YXJuaW5nJ107XG4gICAgdmFyIHdhcm5pbmdzID0gQXJyYXkuaXNBcnJheSh3YXJuKSA/IHdhcm4gOiBbd2Fybl07XG4gICAgd2FybmluZ3MuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKG1zZykge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgIHJldHVybiByZXM7XG4gIH1cbn07IC8vIEVudmlyb25tZW50LXNwZWNpZmljIG1pZGRsZXdhcmUuXG5cbnZhciBlbnZTcGVjaWZpYyA9IHJlcXVpcmUoJy4vbm9kZU1pZGRsZXdhcmUnKTtcblxudmFyIG1pZGRsZXdhcmUgPSBlbnZTcGVjaWZpYy5jb25jYXQoW3ByaW50V2FybmluZ3MsIGpzb25SZXF1ZXN0KCksIGpzb25SZXNwb25zZSgpLCBwcm9ncmVzcygpLCBodHRwRXJyb3IsIG9ic2VydmFibGUoe1xuICBpbXBsZW1lbnRhdGlvbjogT2JzZXJ2YWJsZVxufSldKTtcbnZhciByZXF1ZXN0ID0gZ2V0SXQobWlkZGxld2FyZSk7XG5cbmZ1bmN0aW9uIGh0dHBSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgdmFyIHJlcXVlc3RlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcmVxdWVzdDtcbiAgcmV0dXJuIHJlcXVlc3Rlcihhc3NpZ24oe1xuICAgIG1heFJlZGlyZWN0czogMFxuICB9LCBvcHRpb25zKSk7XG59XG5cbmh0dHBSZXF1ZXN0LmRlZmF1bHRSZXF1ZXN0ZXIgPSByZXF1ZXN0O1xuaHR0cFJlcXVlc3QuQ2xpZW50RXJyb3IgPSBDbGllbnRFcnJvcjtcbmh0dHBSZXF1ZXN0LlNlcnZlckVycm9yID0gU2VydmVyRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGh0dHBSZXF1ZXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgcHJvamVjdEhlYWRlciA9ICdYLVNhbml0eS1Qcm9qZWN0LUlEJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBvdmVycmlkZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgaGVhZGVycyA9IHt9O1xuICB2YXIgdG9rZW4gPSBvdmVycmlkZXMudG9rZW4gfHwgY29uZmlnLnRva2VuO1xuXG4gIGlmICh0b2tlbikge1xuICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFwiQmVhcmVyIFwiLmNvbmNhdCh0b2tlbik7XG4gIH1cblxuICBpZiAoIW92ZXJyaWRlcy51c2VHbG9iYWxBcGkgJiYgIWNvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWUgJiYgY29uZmlnLnByb2plY3RJZCkge1xuICAgIGhlYWRlcnNbcHJvamVjdEhlYWRlcl0gPSBjb25maWcucHJvamVjdElkO1xuICB9XG5cbiAgdmFyIHdpdGhDcmVkZW50aWFscyA9IEJvb2xlYW4odHlwZW9mIG92ZXJyaWRlcy53aXRoQ3JlZGVudGlhbHMgPT09ICd1bmRlZmluZWQnID8gY29uZmlnLnRva2VuIHx8IGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgOiBvdmVycmlkZXMud2l0aENyZWRlbnRpYWxzKTtcbiAgdmFyIHRpbWVvdXQgPSB0eXBlb2Ygb3ZlcnJpZGVzLnRpbWVvdXQgPT09ICd1bmRlZmluZWQnID8gY29uZmlnLnRpbWVvdXQgOiBvdmVycmlkZXMudGltZW91dDtcbiAgcmV0dXJuIGFzc2lnbih7fSwgb3ZlcnJpZGVzLCB7XG4gICAgaGVhZGVyczogYXNzaWduKHt9LCBoZWFkZXJzLCBvdmVycmlkZXMuaGVhZGVycyB8fCB7fSksXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICd1bmRlZmluZWQnID8gNSAqIDYwICogMTAwMCA6IHRpbWVvdXQsXG4gICAganNvbjogdHJ1ZSxcbiAgICB3aXRoQ3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFsc1xuICB9KTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmZ1bmN0aW9uIFByb2plY3RzQ2xpZW50KGNsaWVudCkge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuYXNzaWduKFByb2plY3RzQ2xpZW50LnByb3RvdHlwZSwge1xuICBsaXN0OiBmdW5jdGlvbiBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIHVyaTogJy9wcm9qZWN0cydcbiAgICB9KTtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIHVyaTogXCIvcHJvamVjdHMvXCIuY29uY2F0KGlkKVxuICAgIH0pO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdHNDbGllbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvZmlsdGVyJyksXG4gICAgZmlsdGVyID0gX3JlcXVpcmUuZmlsdGVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnQHNhbml0eS9vYnNlcnZhYmxlL29wZXJhdG9ycy9tYXAnKSxcbiAgICBtYXAgPSBfcmVxdWlyZTIubWFwO1xuXG52YXIgUGF0Y2ggPSByZXF1aXJlKCcuL2RhdGEvcGF0Y2gnKTtcblxudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9kYXRhL3RyYW5zYWN0aW9uJyk7XG5cbnZhciBkYXRhTWV0aG9kcyA9IHJlcXVpcmUoJy4vZGF0YS9kYXRhTWV0aG9kcycpO1xuXG52YXIgRGF0YXNldHNDbGllbnQgPSByZXF1aXJlKCcuL2RhdGFzZXRzL2RhdGFzZXRzQ2xpZW50Jyk7XG5cbnZhciBQcm9qZWN0c0NsaWVudCA9IHJlcXVpcmUoJy4vcHJvamVjdHMvcHJvamVjdHNDbGllbnQnKTtcblxudmFyIEFzc2V0c0NsaWVudCA9IHJlcXVpcmUoJy4vYXNzZXRzL2Fzc2V0c0NsaWVudCcpO1xuXG52YXIgVXNlcnNDbGllbnQgPSByZXF1aXJlKCcuL3VzZXJzL3VzZXJzQ2xpZW50Jyk7XG5cbnZhciBBdXRoQ2xpZW50ID0gcmVxdWlyZSgnLi9hdXRoL2F1dGhDbGllbnQnKTtcblxudmFyIGh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9odHRwL3JlcXVlc3QnKTtcblxudmFyIGdldFJlcXVlc3RPcHRpb25zID0gcmVxdWlyZSgnLi9odHRwL3JlcXVlc3RPcHRpb25zJyk7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKCcuL2NvbmZpZycpLFxuICAgIGRlZmF1bHRDb25maWcgPSBfcmVxdWlyZTMuZGVmYXVsdENvbmZpZyxcbiAgICBpbml0Q29uZmlnID0gX3JlcXVpcmUzLmluaXRDb25maWc7XG5cbnZhciB0b1Byb21pc2UgPSBmdW5jdGlvbiB0b1Byb21pc2Uob2JzZXJ2YWJsZSkge1xuICByZXR1cm4gb2JzZXJ2YWJsZS50b1Byb21pc2UoKTtcbn07XG5cbmZ1bmN0aW9uIFNhbml0eUNsaWVudCgpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZGVmYXVsdENvbmZpZztcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2FuaXR5Q2xpZW50KSkge1xuICAgIHJldHVybiBuZXcgU2FuaXR5Q2xpZW50KGNvbmZpZyk7XG4gIH1cblxuICB0aGlzLmNvbmZpZyhjb25maWcpO1xuICB0aGlzLmFzc2V0cyA9IG5ldyBBc3NldHNDbGllbnQodGhpcyk7XG4gIHRoaXMuZGF0YXNldHMgPSBuZXcgRGF0YXNldHNDbGllbnQodGhpcyk7XG4gIHRoaXMucHJvamVjdHMgPSBuZXcgUHJvamVjdHNDbGllbnQodGhpcyk7XG4gIHRoaXMudXNlcnMgPSBuZXcgVXNlcnNDbGllbnQodGhpcyk7XG4gIHRoaXMuYXV0aCA9IG5ldyBBdXRoQ2xpZW50KHRoaXMpO1xuXG4gIGlmICh0aGlzLmNsaWVudENvbmZpZy5pc1Byb21pc2VBUEkpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZUNvbmZpZyA9IGFzc2lnbih7fSwgdGhpcy5jbGllbnRDb25maWcsIHtcbiAgICAgIGlzUHJvbWlzZUFQSTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLm9ic2VydmFibGUgPSBuZXcgU2FuaXR5Q2xpZW50KG9ic2VydmFibGVDb25maWcpO1xuICB9XG59XG5cbmFzc2lnbihTYW5pdHlDbGllbnQucHJvdG90eXBlLCBkYXRhTWV0aG9kcyk7XG5hc3NpZ24oU2FuaXR5Q2xpZW50LnByb3RvdHlwZSwge1xuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBTYW5pdHlDbGllbnQodGhpcy5jb25maWcoKSk7XG4gIH0sXG4gIGNvbmZpZzogZnVuY3Rpb24gY29uZmlnKG5ld0NvbmZpZykge1xuICAgIGlmICh0eXBlb2YgbmV3Q29uZmlnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy5jbGllbnRDb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9ic2VydmFibGUpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlQ29uZmlnID0gYXNzaWduKHt9LCBuZXdDb25maWcsIHtcbiAgICAgICAgaXNQcm9taXNlQVBJOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9ic2VydmFibGUuY29uZmlnKG9ic2VydmFibGVDb25maWcpO1xuICAgIH1cblxuICAgIHRoaXMuY2xpZW50Q29uZmlnID0gaW5pdENvbmZpZyhuZXdDb25maWcsIHRoaXMuY2xpZW50Q29uZmlnIHx8IHt9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgd2l0aENvbmZpZzogZnVuY3Rpb24gd2l0aENvbmZpZyhuZXdDb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmNvbmZpZyhuZXdDb25maWcpO1xuICB9LFxuICBnZXRVcmw6IGZ1bmN0aW9uIGdldFVybCh1cmkpIHtcbiAgICB2YXIgY2FuVXNlQ2RuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgYmFzZSA9IGNhblVzZUNkbiA/IHRoaXMuY2xpZW50Q29uZmlnLmNkblVybCA6IHRoaXMuY2xpZW50Q29uZmlnLnVybDtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoYmFzZSwgXCIvXCIpLmNvbmNhdCh1cmkucmVwbGFjZSgvXlxcLy8sICcnKSk7XG4gIH0sXG4gIGlzUHJvbWlzZUFQSTogZnVuY3Rpb24gaXNQcm9taXNlQVBJKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudENvbmZpZy5pc1Byb21pc2VBUEk7XG4gIH0sXG4gIF9yZXF1ZXN0T2JzZXJ2YWJsZTogZnVuY3Rpb24gX3JlcXVlc3RPYnNlcnZhYmxlKG9wdGlvbnMpIHtcbiAgICB2YXIgdXJpID0gb3B0aW9ucy51cmwgfHwgb3B0aW9ucy51cmk7XG4gICAgdmFyIGNhblVzZUNkbiA9IHRoaXMuY2xpZW50Q29uZmlnLnVzZUNkbiAmJiBbJ0dFVCcsICdIRUFEJ10uaW5kZXhPZihvcHRpb25zLm1ldGhvZCB8fCAnR0VUJykgPj0gMCAmJiB1cmkuaW5kZXhPZignL2RhdGEvJykgPT09IDA7XG4gICAgdmFyIHJlcU9wdGlvbnMgPSBnZXRSZXF1ZXN0T3B0aW9ucyh0aGlzLmNsaWVudENvbmZpZywgYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB1cmw6IHRoaXMuZ2V0VXJsKHVyaSwgY2FuVXNlQ2RuKVxuICAgIH0pKTtcbiAgICByZXR1cm4gaHR0cFJlcXVlc3QocmVxT3B0aW9ucywgdGhpcy5jbGllbnRDb25maWcucmVxdWVzdGVyKTtcbiAgfSxcbiAgcmVxdWVzdDogZnVuY3Rpb24gcmVxdWVzdChvcHRpb25zKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLl9yZXF1ZXN0T2JzZXJ2YWJsZShvcHRpb25zKS5waXBlKGZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC50eXBlID09PSAncmVzcG9uc2UnO1xuICAgIH0pLCBtYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQuYm9keTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gdGhpcy5pc1Byb21pc2VBUEkoKSA/IHRvUHJvbWlzZShvYnNlcnZhYmxlKSA6IG9ic2VydmFibGU7XG4gIH1cbn0pO1xuU2FuaXR5Q2xpZW50LlBhdGNoID0gUGF0Y2g7XG5TYW5pdHlDbGllbnQuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcblNhbml0eUNsaWVudC5DbGllbnRFcnJvciA9IGh0dHBSZXF1ZXN0LkNsaWVudEVycm9yO1xuU2FuaXR5Q2xpZW50LlNlcnZlckVycm9yID0gaHR0cFJlcXVlc3QuU2VydmVyRXJyb3I7XG5TYW5pdHlDbGllbnQucmVxdWVzdGVyID0gaHR0cFJlcXVlc3QuZGVmYXVsdFJlcXVlc3Rlcjtcbm1vZHVsZS5leHBvcnRzID0gU2FuaXR5Q2xpZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG5mdW5jdGlvbiBVc2Vyc0NsaWVudChjbGllbnQpIHtcbiAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbmFzc2lnbihVc2Vyc0NsaWVudC5wcm90b3R5cGUsIHtcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIHVyaTogXCIvdXNlcnMvXCIuY29uY2F0KGlkKVxuICAgIH0pO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gVXNlcnNDbGllbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5jb25jYXQoT2JqZWN0LmtleXMob2JqKSkucmVkdWNlKGZ1bmN0aW9uICh0YXJnZXQsIHByb3ApIHtcbiAgICB0YXJnZXRbcHJvcF0gPSB0eXBlb2Ygb2JqW3Byb3BdID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzW3Byb3BdIDogb2JqW3Byb3BdO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sIHt9KTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHNlbCkge1xuICBpZiAodHlwZW9mIHNlbCA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShzZWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzZWxcbiAgICB9O1xuICB9XG5cbiAgaWYgKHNlbCAmJiBzZWwucXVlcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcXVlcnk6IHNlbC5xdWVyeVxuICAgIH07XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uT3B0cyA9IFsnKiBEb2N1bWVudCBJRCAoPGRvY0lkPiknLCAnKiBBcnJheSBvZiBkb2N1bWVudCBJRHMnLCAnKiBPYmplY3QgY29udGFpbmluZyBgcXVlcnlgJ10uam9pbignXFxuJyk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc2VsZWN0aW9uIC0gbXVzdCBiZSBvbmUgb2Y6XFxuXFxuXCIuY29uY2F0KHNlbGVjdGlvbk9wdHMpKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBkaWRDYWxsID0gZmFsc2U7XG4gIHZhciByZXR1cm5WYWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGlkQ2FsbCkge1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIHJldHVyblZhbHVlID0gZm4uYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgIGRpZENhbGwgPSB0cnVlO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgcHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLnJlZHVjZShmdW5jdGlvbiAoc2VsZWN0aW9uLCBwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbltwcm9wXSA9IG9ialtwcm9wXTtcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9LCB7fSk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBWQUxJRF9BU1NFVF9UWVBFUyA9IFsnaW1hZ2UnLCAnZmlsZSddO1xudmFyIFZBTElEX0lOU0VSVF9MT0NBVElPTlMgPSBbJ2JlZm9yZScsICdhZnRlcicsICdyZXBsYWNlJ107XG5cbmV4cG9ydHMuZGF0YXNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghL14oflthLXowLTldezF9Wy1cXHddezAsMjV9fFthLXowLTldezF9Wy1cXHddezAsMTl9KSQvLnRlc3QobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFzZXRzIGNhbiBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGNoYXJhY3RlcnMsIG51bWJlcnMsIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMsIGFuZCBzdGFydCB3aXRoIHRpbGRlLCBhbmQgYmUgbWF4aW11bSAyMCBjaGFyYWN0ZXJzJyk7XG4gIH1cbn07XG5cbmV4cG9ydHMucHJvamVjdElkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmICghL15bLWEtejAtOV0rJC9pLnRlc3QoaWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvamVjdElkYCBjYW4gb25seSBjb250YWluIG9ubHkgYS16LCAwLTkgYW5kIGRhc2hlcycpO1xuICB9XG59O1xuXG5leHBvcnRzLnZhbGlkYXRlQXNzZXRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKFZBTElEX0FTU0VUX1RZUEVTLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhc3NldCB0eXBlOiBcIi5jb25jYXQodHlwZSwgXCIuIE11c3QgYmUgb25lIG9mIFwiKS5jb25jYXQoVkFMSURfQVNTRVRfVFlQRVMuam9pbignLCAnKSkpO1xuICB9XG59O1xuXG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gKG9wLCB2YWwpIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbCkgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChvcCwgXCIoKSB0YWtlcyBhbiBvYmplY3Qgb2YgcHJvcGVydGllc1wiKSk7XG4gIH1cbn07XG5cbmV4cG9ydHMucmVxdWlyZURvY3VtZW50SWQgPSBmdW5jdGlvbiAob3AsIGRvYykge1xuICBpZiAoIWRvYy5faWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQob3AsIFwiKCkgcmVxdWlyZXMgdGhhdCB0aGUgZG9jdW1lbnQgY29udGFpbnMgYW4gSUQgKFxcXCJfaWRcXFwiIHByb3BlcnR5KVwiKSk7XG4gIH1cblxuICBleHBvcnRzLnZhbGlkYXRlRG9jdW1lbnRJZChvcCwgZG9jLl9pZCk7XG59O1xuXG5leHBvcnRzLnZhbGlkYXRlRG9jdW1lbnRJZCA9IGZ1bmN0aW9uIChvcCwgaWQpIHtcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgfHwgIS9eW2EtejAtOV8uLV0rJC9pLnRlc3QoaWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KG9wLCBcIigpOiBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIGRvY3VtZW50IElEXCIpKTtcbiAgfVxufTtcblxuZXhwb3J0cy52YWxpZGF0ZUluc2VydCA9IGZ1bmN0aW9uIChhdCwgc2VsZWN0b3IsIGl0ZW1zKSB7XG4gIHZhciBzaWduYXR1cmUgPSAnaW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpJztcblxuICBpZiAoVkFMSURfSU5TRVJUX0xPQ0FUSU9OUy5pbmRleE9mKGF0KSA9PT0gLTEpIHtcbiAgICB2YXIgdmFsaWQgPSBWQUxJRF9JTlNFUlRfTE9DQVRJT05TLm1hcChmdW5jdGlvbiAobG9jKSB7XG4gICAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KGxvYywgXCJcXFwiXCIpO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHNpZ25hdHVyZSwgXCIgdGFrZXMgYW4gXFxcImF0XFxcIi1hcmd1bWVudCB3aGljaCBpcyBvbmUgb2Y6IFwiKS5jb25jYXQodmFsaWQpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHNpZ25hdHVyZSwgXCIgdGFrZXMgYSBcXFwic2VsZWN0b3JcXFwiLWFyZ3VtZW50IHdoaWNoIG11c3QgYmUgYSBzdHJpbmdcIikpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChzaWduYXR1cmUsIFwiIHRha2VzIGFuIFxcXCJpdGVtc1xcXCItYXJndW1lbnQgd2hpY2ggbXVzdCBiZSBhbiBhcnJheVwiKSk7XG4gIH1cbn07XG5cbmV4cG9ydHMuaGFzRGF0YXNldCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgaWYgKCFjb25maWcuZ3JhZGllbnRNb2RlICYmICFjb25maWcuZGF0YXNldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYGRhdGFzZXRgIG11c3QgYmUgcHJvdmlkZWQgdG8gcGVyZm9ybSBxdWVyaWVzJyk7XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmRhdGFzZXQgfHwgJyc7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2VuZXJhdGVIZWxwVXJsID0gcmVxdWlyZSgnQHNhbml0eS9nZW5lcmF0ZS1oZWxwLXVybCcpO1xuXG52YXIgb25jZSA9IHJlcXVpcmUoJy4vdXRpbC9vbmNlJyk7XG5cbnZhciBjcmVhdGVXYXJuaW5nUHJpbnRlciA9IGZ1bmN0aW9uIGNyZWF0ZVdhcm5pbmdQcmludGVyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuICgvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb25zb2xlO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfY29uc29sZSA9IGNvbnNvbGUpLndhcm4uYXBwbHkoX2NvbnNvbGUsIFttZXNzYWdlLmpvaW4oJyAnKV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9KVxuICApO1xufTtcblxuZXhwb3J0cy5wcmludENkbldhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbJ1lvdSBhcmUgbm90IHVzaW5nIHRoZSBTYW5pdHkgQ0ROLiBUaGF0IG1lYW5zIHlvdXIgZGF0YSBpcyBhbHdheXMgZnJlc2gsIGJ1dCB0aGUgQ0ROIGlzIGZhc3RlciBhbmQnLCBcImNoZWFwZXIuIFRoaW5rIGFib3V0IGl0ISBGb3IgbW9yZSBpbmZvLCBzZWUgXCIuY29uY2F0KGdlbmVyYXRlSGVscFVybCgnanMtY2xpZW50LWNkbi1jb25maWd1cmF0aW9uJyksIFwiLlwiKSwgJ1RvIGhpZGUgdGhpcyB3YXJuaW5nLCBwbGVhc2Ugc2V0IHRoZSBgdXNlQ2RuYCBvcHRpb24gdG8gZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIHdoZW4gY3JlYXRpbmcnLCAndGhlIGNsaWVudC4nXSk7XG5leHBvcnRzLnByaW50QnJvd3NlclRva2VuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFsnWW91IGhhdmUgY29uZmlndXJlZCBTYW5pdHkgY2xpZW50IHRvIHVzZSBhIHRva2VuIGluIHRoZSBicm93c2VyLiBUaGlzIG1heSBjYXVzZSB1bmludGVudGlvbmFsIHNlY3VyaXR5IGlzc3Vlcy4nLCBcIlNlZSBcIi5jb25jYXQoZ2VuZXJhdGVIZWxwVXJsKCdqcy1jbGllbnQtYnJvd3Nlci10b2tlbicpLCBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgaG93IHRvIGhpZGUgdGhpcyB3YXJuaW5nLlwiKV0pO1xuZXhwb3J0cy5wcmludENkblRva2VuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFsnWW91IGhhdmUgc2V0IGB1c2VDZG5gIHRvIGB0cnVlYCB3aGlsZSBhbHNvIHNwZWNpZnlpbmcgYSB0b2tlbi4gVGhpcyBpcyB1c3VhbGx5IG5vdCB3aGF0IHlvdScsICd3YW50LiBUaGUgQ0ROIGNhbm5vdCBiZSB1c2VkIHdpdGggYW4gYXV0aG9yaXphdGlvbiB0b2tlbiwgc2luY2UgcHJpdmF0ZSBkYXRhIGNhbm5vdCBiZSBjYWNoZWQuJywgXCJTZWUgXCIuY29uY2F0KGdlbmVyYXRlSGVscFVybCgnanMtY2xpZW50LXVzZWNkbi10b2tlbicpLCBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIildKTtcbmV4cG9ydHMucHJpbnROb0FwaVZlcnNpb25TcGVjaWZpZWRXYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoWydVc2luZyB0aGUgU2FuaXR5IGNsaWVudCB3aXRob3V0IHNwZWNpZnlpbmcgYW4gQVBJIHZlcnNpb24gaXMgZGVwcmVjYXRlZC4nLCBcIlNlZSBcIi5jb25jYXQoZ2VuZXJhdGVIZWxwVXJsKCdqcy1jbGllbnQtYXBpLXZlcnNpb24nKSldKTsiLCIvKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cbnZhciBldnMgPSByZXF1aXJlKCdAcmV4eGFycy9ldmVudHNvdXJjZS1wb2x5ZmlsbCcpXG5cbm1vZHVsZS5leHBvcnRzID0gd2luZG93LkV2ZW50U291cmNlIHx8IGV2cy5FdmVudFNvdXJjZVxuIiwidmFyIGJhc2VVcmwgPSAnaHR0cHM6Ly9kb2NzLnNhbml0eS5pby9oZWxwLydcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZUhlbHBVcmwoc2x1Zykge1xuICByZXR1cm4gYmFzZVVybCArIHNsdWdcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdyeGpzL2ludGVybmFsL09ic2VydmFibGUnKSxcbiAgICBPYnNlcnZhYmxlID0gX3JlcXVpcmUuT2JzZXJ2YWJsZTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycy9tYXAnKSxcbiAgICBtYXAgPSBfcmVxdWlyZTIubWFwO1xuXG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzL2ZpbHRlcicpLFxuICAgIGZpbHRlciA9IF9yZXF1aXJlMy5maWx0ZXI7XG5cbnZhciBfcmVxdWlyZTQgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMvcmVkdWNlJyksXG4gICAgcmVkdWNlID0gX3JlcXVpcmU0LnJlZHVjZTtcbi8qXG4gQSBtaW5pbWFsIHJ4anMgYmFzZWQgb2JzZXJ2YWJsZSB0aGF0IGFsaWduIGFzIGNsb3NlbHkgYXMgcG9zc2libGUgd2l0aCB0aGUgY3VycmVudCBlcy1vYnNlcnZhYmxlIHNwZWMsXG4gd2l0aG91dCB0aGUgc3RhdGljIGZhY3RvcnkgbWV0aG9kc1xuICovXG5cblxuZnVuY3Rpb24gU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWwoKSB7XG4gIE9ic2VydmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbn1cblxuU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgT2JzZXJ2YWJsZS5wcm90b3R5cGUpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTYW5pdHlPYnNlcnZhYmxlTWluaW1hbC5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHtcbiAgdmFsdWU6IFNhbml0eU9ic2VydmFibGVNaW5pbWFsLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cblNhbml0eU9ic2VydmFibGVNaW5pbWFsLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gbGlmdChvcGVyYXRvcikge1xuICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBTYW5pdHlPYnNlcnZhYmxlTWluaW1hbCgpO1xuICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgcmV0dXJuIG9ic2VydmFibGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVEZXByZWNhdGVkTWVtYmVyT3AobmFtZSwgb3ApIHtcbiAgdmFyIGhhc1dhcm5lZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gZGVwcmVjYXRlZE9wZXJhdG9yKCkge1xuICAgIGlmICghaGFzV2FybmVkKSB7XG4gICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcihcIkNhbGxpbmcgb2JzZXJ2YWJsZS5cIi5jb25jYXQobmFtZSwgXCIoLi4uKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG9ic2VydmFibGUucGlwZShcIikuY29uY2F0KG5hbWUsIFwiKC4uLikpIGluc3RlYWRcIikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5waXBlKG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5TYW5pdHlPYnNlcnZhYmxlTWluaW1hbC5wcm90b3R5cGUubWFwID0gY3JlYXRlRGVwcmVjYXRlZE1lbWJlck9wKCdtYXAnLCBtYXApO1xuU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWwucHJvdG90eXBlLmZpbHRlciA9IGNyZWF0ZURlcHJlY2F0ZWRNZW1iZXJPcCgnZmlsdGVyJywgZmlsdGVyKTtcblNhbml0eU9ic2VydmFibGVNaW5pbWFsLnByb3RvdHlwZS5yZWR1Y2UgPSBjcmVhdGVEZXByZWNhdGVkTWVtYmVyT3AoJ2ZpbHRlcicsIHJlZHVjZSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNhbml0eU9ic2VydmFibGVNaW5pbWFsOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWwnKVxuIiwiZXhwb3J0cy5maWx0ZXIgPSByZXF1aXJlKCdyeGpzL2ludGVybmFsL29wZXJhdG9ycy9maWx0ZXInKS5maWx0ZXJcbiIsImV4cG9ydHMubWFwID0gcmVxdWlyZSgncnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwJykubWFwXG4iLCJleHBvcnRzLnJlZHVjZSA9IHJlcXVpcmUoJ3J4anMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZHVjZScpLnJlZHVjZVxuIiwiXG4vKipcbiAqIEFycmF5I2ZpbHRlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdD19IHNlbGZcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHRocm93IFR5cGVFcnJvclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyciwgZm4sIHNlbGYpIHtcbiAgaWYgKGFyci5maWx0ZXIpIHJldHVybiBhcnIuZmlsdGVyKGZuLCBzZWxmKTtcbiAgaWYgKHZvaWQgMCA9PT0gYXJyIHx8IG51bGwgPT09IGFycikgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICB2YXIgcmV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChhcnIsIGkpKSBjb250aW51ZTtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgIGlmIChmbi5jYWxsKHNlbGYsIHZhbCwgaSwgYXJyKSkgcmV0LnB1c2godmFsKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2Fzc2VydC5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8yYTUxYWU0MjRhNTEzZWM5YTZhYTM0NjZiYWEwY2MxZDU1ZGQ0ZjNiXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZXJyb3JzJyksXG4gICAgX3JlcXVpcmUkY29kZXMgPSBfcmVxdWlyZS5jb2RlcyxcbiAgICBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX0FNQklHVU9VU19BUkdVTUVOVCxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9JTlZBTElEX0FSR19WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19WQUxVRSxcbiAgICBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1M7XG5cbnZhciBBc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvcicpO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gICAgaXNQcm9taXNlID0gX3JlcXVpcmUkdHlwZXMuaXNQcm9taXNlLFxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHA7XG5cbnZhciBvYmplY3RBc3NpZ24gPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbiA6IHJlcXVpcmUoJ2VzNi1vYmplY3QtYXNzaWduJykuYXNzaWduO1xudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogcmVxdWlyZSgnb2JqZWN0LWlzJyk7XG52YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKTtcbnZhciBpc0RlZXBFcXVhbDtcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcbnZhciBwYXJzZUV4cHJlc3Npb25BdDtcbnZhciBmaW5kTm9kZUFyb3VuZDtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zJyk7XG5cbiAgaXNEZWVwRXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcEVxdWFsO1xuICBpc0RlZXBTdHJpY3RFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwU3RyaWN0RXF1YWw7XG59IC8vIEVzY2FwZSBjb250cm9sIGNoYXJhY3RlcnMgYnV0IG5vdCBcXG4gYW5kIFxcdCB0byBrZWVwIHRoZSBsaW5lIGJyZWFrcyBhbmRcbi8vIGluZGVudGF0aW9uIGludGFjdC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cblxudmFyIGVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZdL2c7XG52YXIgbWV0YSA9IFtcIlxcXFx1MDAwMFwiLCBcIlxcXFx1MDAwMVwiLCBcIlxcXFx1MDAwMlwiLCBcIlxcXFx1MDAwM1wiLCBcIlxcXFx1MDAwNFwiLCBcIlxcXFx1MDAwNVwiLCBcIlxcXFx1MDAwNlwiLCBcIlxcXFx1MDAwN1wiLCAnXFxcXGInLCAnJywgJycsIFwiXFxcXHUwMDBiXCIsICdcXFxcZicsICcnLCBcIlxcXFx1MDAwZVwiLCBcIlxcXFx1MDAwZlwiLCBcIlxcXFx1MDAxMFwiLCBcIlxcXFx1MDAxMVwiLCBcIlxcXFx1MDAxMlwiLCBcIlxcXFx1MDAxM1wiLCBcIlxcXFx1MDAxNFwiLCBcIlxcXFx1MDAxNVwiLCBcIlxcXFx1MDAxNlwiLCBcIlxcXFx1MDAxN1wiLCBcIlxcXFx1MDAxOFwiLCBcIlxcXFx1MDAxOVwiLCBcIlxcXFx1MDAxYVwiLCBcIlxcXFx1MDAxYlwiLCBcIlxcXFx1MDAxY1wiLCBcIlxcXFx1MDAxZFwiLCBcIlxcXFx1MDAxZVwiLCBcIlxcXFx1MDAxZlwiXTtcblxudmFyIGVzY2FwZUZuID0gZnVuY3Rpb24gZXNjYXBlRm4oc3RyKSB7XG4gIHJldHVybiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTtcbn07XG5cbnZhciB3YXJuZWQgPSBmYWxzZTsgLy8gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xudmFyIE5PX0VYQ0VQVElPTl9TRU5USU5FTCA9IHt9OyAvLyBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGlubmVyRmFpbChvYmopIHtcbiAgaWYgKG9iai5tZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG9iai5tZXNzYWdlO1xuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZuKSB7XG4gIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGludGVybmFsTWVzc2FnZTtcblxuICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgIGludGVybmFsTWVzc2FnZSA9ICdGYWlsZWQnO1xuICB9IGVsc2UgaWYgKGFyZ3NMZW4gPT09IDEpIHtcbiAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAod2FybmVkID09PSBmYWxzZSkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHZhciB3YXJuID0gcHJvY2Vzcy5lbWl0V2FybmluZyA/IHByb2Nlc3MuZW1pdFdhcm5pbmcgOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgIHdhcm4oJ2Fzc2VydC5mYWlsKCkgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSBhc3NlcnQuc3RyaWN0RXF1YWwoKSBpbnN0ZWFkIG9yIG9ubHkgcGFzcyBhIG1lc3NhZ2UuJywgJ0RlcHJlY2F0aW9uV2FybmluZycsICdERVAwMDk0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3NMZW4gPT09IDIpIG9wZXJhdG9yID0gJyE9JztcbiAgfVxuXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG1lc3NhZ2U7XG4gIHZhciBlcnJBcmdzID0ge1xuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdmYWlsJyA6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuIHx8IGZhaWxcbiAgfTtcblxuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyQXJncy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyQXJncyk7XG5cbiAgaWYgKGludGVybmFsTWVzc2FnZSkge1xuICAgIGVyci5tZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuXG4gIHRocm93IGVycjtcbn1cblxuYXNzZXJ0LmZhaWwgPSBmYWlsOyAvLyBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBpbnRlcm5hbC9lcnJvci5cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbmZ1bmN0aW9uIGlubmVyT2soZm4sIGFyZ0xlbiwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHZhciBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG5cbiAgICBpZiAoYXJnTGVuID09PSAwKSB7XG4gICAgICBnZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgIG1lc3NhZ2UgPSAnTm8gdmFsdWUgYXJndW1lbnQgcGFzc2VkIHRvIGBhc3NlcnQub2soKWAnO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cblxuICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiB2YWx1ZSxcbiAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn0gLy8gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISF2YWx1ZS5cblxuXG5mdW5jdGlvbiBvaygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbb2ssIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQub2sgPSBvazsgLy8gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoID09LlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdFxuLy8gZXF1YWwgd2l0aCAhPS5cblxuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnIT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cblxuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG5cblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcblxuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKCFvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ3N0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAob2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBDb21wYXJpc29uID0gZnVuY3Rpb24gQ29tcGFyaXNvbihvYmosIGtleXMsIGFjdHVhbCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wYXJpc29uKTtcblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoYWN0dWFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChvYmpba2V5XSkgJiYgb2JqW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IGFjdHVhbFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbWVzc2FnZSwga2V5cywgZm4pIHtcbiAgaWYgKCEoa2V5IGluIGFjdHVhbCkgfHwgIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbFtrZXldLCBleHBlY3RlZFtrZXldKSkge1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIG9iamVjdHMgdG8gY3JlYXRlIGEgbmljZSBvdXRwdXQuXG4gICAgICB2YXIgYSA9IG5ldyBDb21wYXJpc29uKGFjdHVhbCwga2V5cyk7XG4gICAgICB2YXIgYiA9IG5ldyBDb21wYXJpc29uKGV4cGVjdGVkLCBrZXlzLCBhY3R1YWwpO1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIuYWN0dWFsID0gYWN0dWFsO1xuICAgICAgZXJyLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogZm4ubmFtZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBtc2csIGZuKSB7XG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoaXNSZWdFeHAoZXhwZWN0ZWQpKSByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBhc3NlcnQuZG9lc05vdFRocm93IGRvZXMgbm90IGFjY2VwdCBvYmplY3RzLlxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXhwZWN0ZWQnLCBbJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBleHBlY3RlZCk7XG4gICAgfSAvLyBIYW5kbGUgcHJpbWl0aXZlcyBwcm9wZXJseS5cblxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gU3BlY2lhbCBoYW5kbGUgZXJyb3JzIHRvIG1ha2Ugc3VyZSB0aGUgbmFtZSBhbmQgdGhlIG1lc3NhZ2UgYXJlIGNvbXBhcmVkXG4gICAgLy8gYXMgd2VsbC5cblxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBrZXlzLnB1c2goJ25hbWUnLCAnbWVzc2FnZScpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoJ2Vycm9yJywgZXhwZWN0ZWQsICdtYXkgbm90IGJlIGFuIGVtcHR5IG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAoZXhwZWN0ZWRba2V5XSkgJiYgZXhwZWN0ZWRba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtc2csIGtleXMsIGZuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBHdWFyZCBpbnN0YW5jZW9mIGFnYWluc3QgYXJyb3cgZnVuY3Rpb25zIGFzIHRoZXkgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZS5cblxuXG4gIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEFjdHVhbChmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsICdGdW5jdGlvbicsIGZuKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbn1cblxuZnVuY3Rpb24gY2hlY2tJc1Byb21pc2Uob2JqKSB7XG4gIC8vIEFjY2VwdCBuYXRpdmUgRVM2IHByb21pc2VzIGFuZCBwcm9taXNlcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBpbiBhIHNpbWlsYXJcbiAgLy8gd2F5LiBEbyBub3QgYWNjZXB0IHRoZW5hYmxlcyB0aGF0IHVzZSBhIGZ1bmN0aW9uIGFzIGBvYmpgIGFuZCB0aGF0IGhhdmUgbm9cbiAgLy8gYGNhdGNoYCBoYW5kbGVyLlxuICAvLyBUT0RPOiB0aGVuYWJsZXMgYXJlIGNoZWNrZWQgdXAgdW50aWwgdGhleSBoYXZlIHRoZSBjb3JyZWN0IG1ldGhvZHMsXG4gIC8vIGJ1dCBhY2NvcmRpbmcgdG8gZG9jdW1lbnRhdGlvbiwgdGhlIGB0aGVuYCBtZXRob2Qgc2hvdWxkIHJlY2VpdmVcbiAgLy8gdGhlIGBmdWxmaWxsYCBhbmQgYHJlamVjdGAgYXJndW1lbnRzIGFzIHdlbGwgb3IgaXQgbWF5IGJlIG5ldmVyIHJlc29sdmVkLlxuICByZXR1cm4gaXNQcm9taXNlKG9iaikgfHwgb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY2F0Y2ggPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0UHJvbWlzZTtcblxuICAgIGlmICh0eXBlb2YgcHJvbWlzZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBSZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGlmIGBwcm9taXNlRm5gIHRocm93cyBzeW5jaHJvbm91c2x5LlxuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbigpOyAvLyBGYWlsIGluIGNhc2Ugbm8gcHJvbWlzZSBpcyByZXR1cm5lZC5cblxuICAgICAgaWYgKCFjaGVja0lzUHJvbWlzZShyZXN1bHRQcm9taXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdpbnN0YW5jZSBvZiBQcm9taXNlJywgJ3Byb21pc2VGbicsIHJlc3VsdFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hlY2tJc1Byb21pc2UocHJvbWlzZUZuKSkge1xuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdwcm9taXNlRm4nLCBbJ0Z1bmN0aW9uJywgJ1Byb21pc2UnXSwgcHJvbWlzZUZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXhwZWN0c0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChhY3R1YWwubWVzc2FnZSA9PT0gZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBtZXNzYWdlIFxcXCJcIi5jb25jYXQoYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFjdHVhbCA9PT0gZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgXFxcIlwiLmNvbmNhdChhY3R1YWwsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZXJyb3IgIT0gbnVsbCAmJiBfdHlwZW9mKGVycm9yKSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gIH1cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHtcbiAgICB2YXIgZGV0YWlscyA9ICcnO1xuXG4gICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUpIHtcbiAgICAgIGRldGFpbHMgKz0gXCIgKFwiLmNvbmNhdChlcnJvci5uYW1lLCBcIilcIik7XG4gICAgfVxuXG4gICAgZGV0YWlscyArPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdyZWplY3RzJyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIGV4cGVjdGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZXJyb3IgJiYgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UsIHN0YWNrU3RhcnRGbikpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0c05vRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFlcnJvciB8fCBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yKSkge1xuICAgIHZhciBkZXRhaWxzID0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAnZG9lc05vdFJlamVjdCcgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiR290IHVud2FudGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzLCBcIlxcblwiKSArIFwiQWN0dWFsIG1lc3NhZ2U6IFxcXCJcIi5jb25jYXQoYWN0dWFsICYmIGFjdHVhbC5tZXNzYWdlLCBcIlxcXCJcIiksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgYWN0dWFsO1xufVxuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gdGhyb3dzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbdGhyb3dzLCBnZXRBY3R1YWwocHJvbWlzZUZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5yZWplY3RzID0gZnVuY3Rpb24gcmVqZWN0cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3JlamVjdHMsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgfVxuXG4gIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RUaHJvdywgZ2V0QWN0dWFsKGZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5kb2VzTm90UmVqZWN0ID0gZnVuY3Rpb24gZG9lc05vdFJlamVjdChmbikge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChmbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RSZWplY3QsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uIGlmRXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdpZkVycm9yIGdvdCB1bndhbnRlZCBleGNlcHRpb246ICc7XG5cbiAgICBpZiAoX3R5cGVvZihlcnIpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UubGVuZ3RoID09PSAwICYmIGVyci5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSBpbnNwZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIG5ld0VyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IGVycixcbiAgICAgIGV4cGVjdGVkOiBudWxsLFxuICAgICAgb3BlcmF0b3I6ICdpZkVycm9yJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBzdGFja1N0YXJ0Rm46IGlmRXJyb3JcbiAgICB9KTsgLy8gTWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzdGFjayB0cmFjZSFcblxuICAgIHZhciBvcmlnU3RhY2sgPSBlcnIuc3RhY2s7XG5cbiAgICBpZiAodHlwZW9mIG9yaWdTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZW1vdmUgYW55IGR1cGxpY2F0ZWQgZnJhbWVzIGZyb20gdGhlIGVycm9yIGZyYW1lcyB0YWtlblxuICAgICAgLy8gZnJvbSB3aXRoaW4gYGlmRXJyb3JgIGFuZCBhZGQgdGhlIG9yaWdpbmFsIGVycm9yIGZyYW1lcyB0byB0aGUgbmV3bHlcbiAgICAgIC8vIGNyZWF0ZWQgb25lcy5cbiAgICAgIHZhciB0bXAyID0gb3JpZ1N0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHRtcDIuc2hpZnQoKTsgLy8gRmlsdGVyIGFsbCBmcmFtZXMgZXhpc3RpbmcgaW4gZXJyLnN0YWNrLlxuXG4gICAgICB2YXIgdG1wMSA9IG5ld0Vyci5zdGFjay5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBmcmFtZS5cbiAgICAgICAgdmFyIHBvcyA9IHRtcDEuaW5kZXhPZih0bXAyW2ldKTtcblxuICAgICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAgIC8vIE9ubHkga2VlcCBuZXcgZnJhbWVzLlxuICAgICAgICAgIHRtcDEgPSB0bXAxLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3RXJyLnN0YWNrID0gXCJcIi5jb25jYXQodG1wMS5qb2luKCdcXG4nKSwgXCJcXG5cIikuY29uY2F0KHRtcDIuam9pbignXFxuJykpO1xuICAgIH1cblxuICAgIHRocm93IG5ld0VycjtcbiAgfVxufTsgLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcblxuXG5mdW5jdGlvbiBzdHJpY3QoKSB7XG4gIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbc3RyaWN0LCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzA4MTc4NDBmNzc1MDMyMTY5ZGRkNzBjODVhYzA1OWYxOGZmY2M4MWNcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ3V0aWwvJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCcuLi9lcnJvcnMnKSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlMi5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xuICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGNvdW50ID09IDApIHJldHVybiAnJztcbiAgdmFyIG1heENvdW50ID0gc3RyLmxlbmd0aCAqIGNvdW50O1xuICBjb3VudCA9IE1hdGguZmxvb3IoTWF0aC5sb2coY291bnQpIC8gTWF0aC5sb2coMikpO1xuXG4gIHdoaWxlIChjb3VudCkge1xuICAgIHN0ciArPSBzdHI7XG4gICAgY291bnQtLTtcbiAgfVxuXG4gIHN0ciArPSBzdHIuc3Vic3RyaW5nKDAsIG1heENvdW50IC0gc3RyLmxlbmd0aCk7XG4gIHJldHVybiBzdHI7XG59XG5cbnZhciBibHVlID0gJyc7XG52YXIgZ3JlZW4gPSAnJztcbnZhciByZWQgPSAnJztcbnZhciB3aGl0ZSA9ICcnO1xudmFyIGtSZWFkYWJsZU9wZXJhdG9yID0ge1xuICBkZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbDonLFxuICBzdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLFxuICBzdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBkZWVwRXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsOicsXG4gIGVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZXF1YWw6JyxcbiAgbm90RGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgc3RyaWN0bHkgdW5lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86JyxcbiAgbm90SWRlbnRpY2FsOiAnVmFsdWVzIGlkZW50aWNhbCBidXQgbm90IHJlZmVyZW5jZS1lcXVhbDonXG59OyAvLyBDb21wYXJpbmcgc2hvcnQgcHJpbWl0aXZlcyBzaG91bGQganVzdCBzaG93ID09PSAvICE9PSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuLy8gZGlmZi5cblxudmFyIGtNYXhTaG9ydExlbmd0aCA9IDEwO1xuXG5mdW5jdGlvbiBjb3B5RXJyb3Ioc291cmNlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnbWVzc2FnZScsIHtcbiAgICB2YWx1ZTogc291cmNlLm1lc3NhZ2VcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RWYWx1ZSh2YWwpIHtcbiAgLy8gVGhlIHV0aWwuaW5zcGVjdCBkZWZhdWx0IHZhbHVlcyBjb3VsZCBiZSBjaGFuZ2VkLiBUaGlzIG1ha2VzIHN1cmUgdGhlXG4gIC8vIGVycm9yIG1lc3NhZ2VzIGNvbnRhaW4gdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBuZXZlcnRoZWxlc3MuXG4gIHJldHVybiBpbnNwZWN0KHZhbCwge1xuICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgIGRlcHRoOiAxMDAwLFxuICAgIG1heEFycmF5TGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgY29tcGFyZXMgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgKHdpdGggYSBmZXcgZXhjZXB0aW9ucykuXG4gICAgc2hvd0hpZGRlbjogZmFsc2UsXG4gICAgLy8gSGF2aW5nIGEgbG9uZyBsaW5lIGFzIGVycm9yIGlzIGJldHRlciB0aGFuIHdyYXBwaW5nIHRoZSBsaW5lIGZvclxuICAgIC8vIGNvbXBhcmlzb24gZm9yIG5vdy5cbiAgICAvLyBUT0RPKEJyaWRnZUFSKTogYGJyZWFrTGVuZ3RoYCBzaG91bGQgYmUgbGltaXRlZCBhcyBzb29uIGFzIHNvb24gYXMgd2VcbiAgICAvLyBoYXZlIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3BlY3RlZCBwcm9wZXJ0aWVzIChpLmUuLCBrbm93IHdoZXJlXG4gICAgLy8gaW4gd2hhdCBsaW5lIHRoZSBwcm9wZXJ0eSBzdGFydHMgYW5kIGVuZHMpLlxuICAgIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgZG9lcyBub3QgZGV0ZWN0IHByb3hpZXMgY3VycmVudGx5LlxuICAgIHNob3dQcm94eTogZmFsc2UsXG4gICAgc29ydGVkOiB0cnVlLFxuICAgIC8vIEluc3BlY3QgZ2V0dGVycyBhcyB3ZSBhbHNvIGNoZWNrIHRoZW0gd2hlbiBjb21wYXJpbmcgZW50cmllcy5cbiAgICBnZXR0ZXJzOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSB7XG4gIHZhciBvdGhlciA9ICcnO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIGVuZCA9ICcnO1xuICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICB2YXIgYWN0dWFsSW5zcGVjdGVkID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG4gIHZhciBhY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7XG4gIHZhciBleHBlY3RlZExpbmVzID0gaW5zcGVjdFZhbHVlKGV4cGVjdGVkKS5zcGxpdCgnXFxuJyk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGluZGljYXRvciA9ICcnOyAvLyBJbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzIGV4cGxpY2l0bHkgbWFyayB0aGVtIGFzIG5vdCByZWZlcmVuY2UgZXF1YWxcbiAgLy8gZm9yIHRoZSBgc3RyaWN0RXF1YWxgIG9wZXJhdG9yLlxuXG4gIGlmIChvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICBvcGVyYXRvciA9ICdzdHJpY3RFcXVhbE9iamVjdCc7XG4gIH0gLy8gSWYgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIGZpdCBvbiBhIHNpbmdsZSBsaW5lIGFuZCB0aGV5IGFyZSBub3Qgc3RyaWN0bHlcbiAgLy8gZXF1YWwsIGNoZWNrIGZ1cnRoZXIgc3BlY2lhbCBoYW5kbGluZy5cblxuXG4gIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDEgJiYgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDEgJiYgYWN0dWFsTGluZXNbMF0gIT09IGV4cGVjdGVkTGluZXNbMF0pIHtcbiAgICB2YXIgaW5wdXRMZW5ndGggPSBhY3R1YWxMaW5lc1swXS5sZW5ndGggKyBleHBlY3RlZExpbmVzWzBdLmxlbmd0aDsgLy8gSWYgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIHRvZ2V0aGVyIGlzIGxlc3MgdGhhblxuICAgIC8vIGtNYXhTaG9ydExlbmd0aCBhbmQgaWYgbmVpdGhlciBpcyBhbiBvYmplY3QgYW5kIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzXG4gICAgLy8gbm90IGB6ZXJvYCwgdXNlIHRoZSBzdHJpY3QgZXF1YWwgY29tcGFyaXNvbiB0byB2aXN1YWxpemUgdGhlIG91dHB1dC5cblxuICAgIGlmIChpbnB1dExlbmd0aCA8PSBrTWF4U2hvcnRMZW5ndGgpIHtcbiAgICAgIGlmICgoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpICYmIChfdHlwZW9mKGV4cGVjdGVkKSAhPT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQgPT09IG51bGwpICYmIChhY3R1YWwgIT09IDAgfHwgZXhwZWN0ZWQgIT09IDApKSB7XG4gICAgICAgIC8vIC0wID09PSArMFxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKSArIFwiXCIuY29uY2F0KGFjdHVhbExpbmVzWzBdLCBcIiAhPT0gXCIpLmNvbmNhdChleHBlY3RlZExpbmVzWzBdLCBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnc3RyaWN0RXF1YWxPYmplY3QnKSB7XG4gICAgICAvLyBJZiB0aGUgc3RkZXJyIGlzIGEgdHR5IGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgIC8vIGNvbHVtbnMgcGVyIGxpbmUsIGFkZCBhIG1pc21hdGNoIGluZGljYXRvciBiZWxvdyB0aGUgb3V0cHV0LiBJZiBpdCBpc1xuICAgICAgLy8gbm90IGEgdHR5LCB1c2UgYSBkZWZhdWx0IHZhbHVlIG9mIDgwIGNoYXJhY3RlcnMuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zIDogODA7XG5cbiAgICAgIGlmIChpbnB1dExlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB3aGlsZSAoYWN0dWFsTGluZXNbMF1baV0gPT09IGV4cGVjdGVkTGluZXNbMF1baV0pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gLy8gSWdub3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXJzLlxuXG5cbiAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgLy8gQWRkIHBvc2l0aW9uIGluZGljYXRvciBmb3IgdGhlIGZpcnN0IG1pc21hdGNoIGluIGNhc2UgaXQgaXMgYVxuICAgICAgICAgIC8vIHNpbmdsZSBsaW5lIGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgY29sdW1uIGxlbmd0aC5cbiAgICAgICAgICBpbmRpY2F0b3IgPSBcIlxcbiAgXCIuY29uY2F0KHJlcGVhdCgnICcsIGkpLCBcIl5cIik7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVtb3ZlIGFsbCBlbmRpbmcgbGluZXMgdGhhdCBtYXRjaCAodGhpcyBvcHRpbWl6ZXMgdGhlIG91dHB1dCBmb3JcbiAgLy8gcmVhZGFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiB0b3RhbCBjaGFuZ2VkIGxpbmVzKS5cblxuXG4gIHZhciBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gIHZhciBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuXG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgaWYgKGkrKyA8IDIpIHtcbiAgICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQoYSkuY29uY2F0KGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gYTtcbiAgICB9XG5cbiAgICBhY3R1YWxMaW5lcy5wb3AoKTtcbiAgICBleHBlY3RlZExpbmVzLnBvcCgpO1xuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDAgfHwgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgICBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgdmFyIG1heExpbmVzID0gTWF0aC5tYXgoYWN0dWFsTGluZXMubGVuZ3RoLCBleHBlY3RlZExpbmVzLmxlbmd0aCk7IC8vIFN0cmljdCBlcXVhbCB3aXRoIGlkZW50aWNhbCBvYmplY3RzIHRoYXQgYXJlIG5vdCBpZGVudGljYWwgYnkgcmVmZXJlbmNlLlxuICAvLyBFLmcuLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHsgYTogU3ltYm9sKCkgfSwgeyBhOiBTeW1ib2woKSB9KVxuXG4gIGlmIChtYXhMaW5lcyA9PT0gMCkge1xuICAgIC8vIFdlIGhhdmUgdG8gZ2V0IHRoZSByZXN1bHQgYWdhaW4uIFRoZSBsaW5lcyB3ZXJlIGFsbCByZW1vdmVkIGJlZm9yZS5cbiAgICB2YXIgX2FjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTsgLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICBpZiAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICBfYWN0dWFsTGluZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcblxuICAgICAgd2hpbGUgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAyNykge1xuICAgICAgICBfYWN0dWFsTGluZXMucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yLm5vdElkZW50aWNhbCwgXCJcXG5cXG5cIikuY29uY2F0KF9hY3R1YWxMaW5lcy5qb2luKCdcXG4nKSwgXCJcXG5cIik7XG4gIH1cblxuICBpZiAoaSA+IDMpIHtcbiAgICBlbmQgPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChlbmQpO1xuICAgIHNraXBwZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG90aGVyICE9PSAnJykge1xuICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpO1xuICAgIG90aGVyID0gJyc7XG4gIH1cblxuICB2YXIgcHJpbnRlZExpbmVzID0gMDtcbiAgdmFyIG1zZyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSArIFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIisgYWN0dWFsXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChyZWQsIFwiLSBleHBlY3RlZFwiKS5jb25jYXQod2hpdGUpO1xuICB2YXIgc2tpcHBlZE1zZyA9IFwiIFwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUsIFwiIExpbmVzIHNraXBwZWRcIik7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heExpbmVzOyBpKyspIHtcbiAgICAvLyBPbmx5IGV4dHJhIGV4cGVjdGVkIGxpbmVzIGV4aXN0XG4gICAgdmFyIGN1ciA9IGkgLSBsYXN0UG9zO1xuXG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGV4cGVjdGVkIGxpbmUgdG8gdGhlIGNhY2hlLlxuXG4gICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gT25seSBleHRyYSBhY3R1YWwgbGluZXMgZXhpc3RcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7IC8vIExpbmVzIGRpdmVyZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4cGVjdGVkTGluZSA9IGV4cGVjdGVkTGluZXNbaV07XG4gICAgICB2YXIgYWN0dWFsTGluZSA9IGFjdHVhbExpbmVzW2ldOyAvLyBJZiB0aGUgbGluZXMgZGl2ZXJnZSwgc3BlY2lmaWNhbGx5IGNoZWNrIGZvciBsaW5lcyB0aGF0IG9ubHkgZGl2ZXJnZSBieVxuICAgICAgLy8gYSB0cmFpbGluZyBjb21tYS4gSW4gdGhhdCBjYXNlIGl0IGlzIGFjdHVhbGx5IGlkZW50aWNhbCBhbmQgd2Ugc2hvdWxkXG4gICAgICAvLyBtYXJrIGl0IGFzIHN1Y2guXG5cbiAgICAgIHZhciBkaXZlcmdpbmdMaW5lcyA9IGFjdHVhbExpbmUgIT09IGV4cGVjdGVkTGluZSAmJiAoIWVuZHNXaXRoKGFjdHVhbExpbmUsICcsJykgfHwgYWN0dWFsTGluZS5zbGljZSgwLCAtMSkgIT09IGV4cGVjdGVkTGluZSk7IC8vIElmIHRoZSBleHBlY3RlZCBsaW5lIGhhcyBhIHRyYWlsaW5nIGNvbW1hIGJ1dCBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLFxuICAgICAgLy8gYWRkIGEgY29tbWEgYXQgdGhlIGVuZCBvZiB0aGUgYWN0dWFsIGxpbmUuIE90aGVyd2lzZSB0aGUgb3V0cHV0IGNvdWxkXG4gICAgICAvLyBsb29rIHdlaXJkIGFzIGluOlxuICAgICAgLy9cbiAgICAgIC8vICAgW1xuICAgICAgLy8gICAgIDEgICAgICAgICAvLyBObyBjb21tYSBhdCB0aGUgZW5kIVxuICAgICAgLy8gKyAgIDJcbiAgICAgIC8vICAgXVxuICAgICAgLy9cblxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzICYmIGVuZHNXaXRoKGV4cGVjdGVkTGluZSwgJywnKSAmJiBleHBlY3RlZExpbmUuc2xpY2UoMCwgLTEpID09PSBhY3R1YWxMaW5lKSB7XG4gICAgICAgIGRpdmVyZ2luZ0xpbmVzID0gZmFsc2U7XG4gICAgICAgIGFjdHVhbExpbmUgKz0gJywnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0IGFuZCBjYWNoZSB0aGUgZXhwZWN0ZWQgZGl2ZXJnaW5nXG4gICAgICAgIC8vIGxpbmUgc28gY29uc2VjdXRpdmUgZGl2ZXJnaW5nIGxpbmVzIHNob3cgdXAgYXMgKysrLS0tIGFuZCBub3QgKy0rLSstLlxuXG4gICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZSk7XG4gICAgICAgIHByaW50ZWRMaW5lcyArPSAyOyAvLyBMaW5lcyBhcmUgaWRlbnRpY2FsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgYWxsIGNhY2hlZCBpbmZvcm1hdGlvbiB0byB0aGUgcmVzdWx0IGJlZm9yZSBhZGRpbmcgb3RoZXIgdGhpbmdzXG4gICAgICAgIC8vIGFuZCByZXNldCB0aGUgY2FjaGUuXG4gICAgICAgIHJlcyArPSBvdGhlcjtcbiAgICAgICAgb3RoZXIgPSAnJzsgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgZXhhY3RseSBvbmUgbGluZSBhYm92ZSBvciBpZiBpdCBpcyB0aGVcbiAgICAgICAgLy8gdmVyeSBmaXJzdCBsaW5lLCBhZGQgdGhlIGxpbmUgdG8gdGhlIHJlc3VsdC5cblxuICAgICAgICBpZiAoY3VyID09PSAxIHx8IGkgPT09IDApIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSW5zcGVjdGVkIG9iamVjdCB0byBiaWcgKFNob3cgfjIwIHJvd3MgbWF4KVxuXG5cbiAgICBpZiAocHJpbnRlZExpbmVzID4gMjAgJiYgaSA8IG1heExpbmVzIC0gMikge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWRNc2csIFwiXFxuXCIpLmNvbmNhdChyZXMsIFwiXFxuXCIpLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChvdGhlciwgXCJcXG5cIikgKyBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkID8gc2tpcHBlZE1zZyA6ICcnLCBcIlxcblwiKS5jb25jYXQocmVzKS5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpLmNvbmNhdChpbmRpY2F0b3IpO1xufVxuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoQXNzZXJ0aW9uRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb25FcnJvcik7XG5cbiAgICBpZiAoX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICBvcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3IsXG4gICAgICAgIHN0YWNrU3RhcnRGbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZuO1xuICAgIHZhciBhY3R1YWwgPSBvcHRpb25zLmFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuXG4gICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgU3RyaW5nKG1lc3NhZ2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICAvLyBSZXNldCBvbiBlYWNoIGNhbGwgdG8gbWFrZSBzdXJlIHdlIGhhbmRsZSBkeW5hbWljYWxseSBzZXQgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gdmFyaWFibGVzIGNvcnJlY3QuXG4gICAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGgoKSAhPT0gMSkge1xuICAgICAgICAgIGJsdWUgPSBcIlxceDFCWzM0bVwiO1xuICAgICAgICAgIGdyZWVuID0gXCJcXHgxQlszMm1cIjtcbiAgICAgICAgICB3aGl0ZSA9IFwiXFx4MUJbMzltXCI7XG4gICAgICAgICAgcmVkID0gXCJcXHgxQlszMW1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibHVlID0gJyc7XG4gICAgICAgICAgZ3JlZW4gPSAnJztcbiAgICAgICAgICB3aGl0ZSA9ICcnO1xuICAgICAgICAgIHJlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IC8vIFByZXZlbnQgdGhlIGVycm9yIHN0YWNrIGZyb20gYmVpbmcgdmlzaWJsZSBieSBkdXBsaWNhdGluZyB0aGUgZXJyb3JcbiAgICAgIC8vIGluIGEgdmVyeSBjbG9zZSB3YXkgdG8gdGhlIG9yaWdpbmFsIGluIGNhc2UgYm90aCBzaWRlcyBhcmUgYWN0dWFsbHlcbiAgICAgIC8vIGluc3RhbmNlcyBvZiBFcnJvci5cblxuXG4gICAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkICE9PSBudWxsICYmICdzdGFjaycgaW4gYWN0dWFsICYmIGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yICYmICdzdGFjaycgaW4gZXhwZWN0ZWQgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBhY3R1YWwgPSBjb3B5RXJyb3IoYWN0dWFsKTtcbiAgICAgICAgZXhwZWN0ZWQgPSBjb3B5RXJyb3IoZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpKSk7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJykge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBidXQgdGhlIG9wZXJhdG9yIHJlcXVpcmVzIHVuZXF1YWwsIHNob3dcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9iamVjdCBhbmQgc2F5IEEgZXF1YWxzIEJcbiAgICAgICAgdmFyIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG4gICAgICAgIHZhciByZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKS5zcGxpdCgnXFxuJyk7IC8vIEluIGNhc2UgXCJhY3R1YWxcIiBpcyBhbiBvYmplY3QsIGl0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlIGVxdWFsLlxuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvci5ub3RTdHJpY3RFcXVhbE9iamVjdDtcbiAgICAgICAgfSAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgICAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAzMCkge1xuICAgICAgICAgIHJlc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICAgICAgd2hpbGUgKHJlcy5sZW5ndGggPiAyNykge1xuICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPbmx5IHByaW50IGEgc2luZ2xlIGlucHV0LlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIiBcIikuY29uY2F0KHJlc1swXSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIlxcblxcblwiKS5jb25jYXQocmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpO1xuXG4gICAgICAgIHZhciBvdGhlciA9ICcnO1xuICAgICAgICB2YXIga25vd25PcGVyYXRvcnMgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdEVxdWFsJykge1xuICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChfcmVzLnNsaWNlKDAsIDEwMjEpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChvdGhlci5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnZXF1YWwnKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa25vd25PcGVyYXRvcnMsIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzLCBcIlxcblxcbnNob3VsZCBlcXVhbFxcblxcblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXIgPSBcIiBcIi5jb25jYXQob3BlcmF0b3IsIFwiIFwiKS5jb25jYXQob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KF9yZXMpLmNvbmNhdChvdGhlcikpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICBfdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnQXNzZXJ0aW9uRXJyb3IgW0VSUl9BU1NFUlRJT05dJyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIF90aGlzLmFjdHVhbCA9IGFjdHVhbDtcbiAgICBfdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIF90aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHN0YWNrU3RhcnRGbik7XG4gICAgfSAvLyBDcmVhdGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGUgaW4gdGhlIG5hbWUuXG5cblxuICAgIF90aGlzLnN0YWNrOyAvLyBSZXNldCB0aGUgbmFtZS5cblxuICAgIF90aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXNzZXJ0aW9uRXJyb3IsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIgW1wiKS5jb25jYXQodGhpcy5jb2RlLCBcIl06IFwiKS5jb25jYXQodGhpcy5tZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IGluc3BlY3QuY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZWN1cnNlVGltZXMsIGN0eCkge1xuICAgICAgLy8gVGhpcyBsaW1pdHMgdGhlIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIHByb3BlcnR5IGRlZmF1bHQgaW5zcGVjdGlvbiB0b1xuICAgICAgLy8gdGhlIG1pbmltdW0gZGVwdGguIE90aGVyd2lzZSB0aG9zZSB2YWx1ZXMgd291bGQgYmUgdG9vIHZlcmJvc2UgY29tcGFyZWRcbiAgICAgIC8vIHRvIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZSB3aGljaCBjb250YWlucyBhIGNvbWJpbmVkIHZpZXcgb2YgdGhlc2UgdHdvXG4gICAgICAvLyBpbnB1dCB2YWx1ZXMuXG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBjdHgsIHtcbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAgIGRlcHRoOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuJ3VzZSBzdHJpY3QnOyAvLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cbi8vIGxvbmdlciBiZSBmb3JjZWQgdG8gdHJlYXQgZXZlcnkgZXJyb3IgbWVzc2FnZSBjaGFuZ2UgYXMgYSBzZW12ZXItbWFqb3Jcbi8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxuLy8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuLy8gbWVzc2FnZSBtYXkgY2hhbmdlLCB0aGUgY29kZSBzaG91bGQgbm90LlxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBjb2RlcyA9IHt9OyAvLyBMYXp5IGxvYWRlZFxuXG52YXIgYXNzZXJ0O1xudmFyIHV0aWw7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHMoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUVycm9yKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTm9kZUVycm9yKS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpKTtcbiAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9BTUJJR1VPVVNfQVJHVU1FTlQnLCAnVGhlIFwiJXNcIiBhcmd1bWVudCBpcyBhbWJpZ3VvdXMuICVzJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IHJlcXVpcmUoJy4uL2Fzc2VydCcpO1xuICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBcIiduYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIpOyAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXG5cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KF90eXBlb2YoYWN0dWFsKSk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2lzIGludmFsaWQnO1xuICBpZiAodXRpbCA9PT0gdW5kZWZpbmVkKSB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbiAgdmFyIGluc3BlY3RlZCA9IHV0aWwuaW5zcGVjdCh2YWx1ZSk7XG5cbiAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAxMjgpIHtcbiAgICBpbnNwZWN0ZWQgPSBcIlwiLmNvbmNhdChpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSwgXCIuLi5cIik7XG4gIH1cblxuICByZXR1cm4gXCJUaGUgYXJndW1lbnQgJ1wiLmNvbmNhdChuYW1lLCBcIicgXCIpLmNvbmNhdChyZWFzb24sIFwiLiBSZWNlaXZlZCBcIikuY29uY2F0KGluc3BlY3RlZCk7XG59LCBUeXBlRXJyb3IsIFJhbmdlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnLCBmdW5jdGlvbiAoaW5wdXQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0eXBlO1xuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgdHlwZSA9IFwiaW5zdGFuY2Ugb2YgXCIuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBcInR5cGUgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiLmNvbmNhdChpbnB1dCwgXCIgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXFxcIlwiKS5jb25jYXQobmFtZSwgXCJcXFwiXCIpICsgXCIgZnVuY3Rpb24gYnV0IGdvdCBcIi5jb25jYXQodHlwZSwgXCIuXCIpO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01JU1NJTkdfQVJHUycsIGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB2YXIgbXNnID0gJ1RoZSAnO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoYSwgXCJcXFwiXCIpO1xuICB9KTtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICBtc2cgKz0gXCIsIGFuZCBcIi5jb25jYXQoYXJnc1tsZW4gLSAxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzOyIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcblxudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdO1xufTtcbnZhciBudW1iZXJJc05hTiA9IE51bWJlci5pc05hTiA/IE51bWJlci5pc05hTiA6IHJlcXVpcmUoJ2lzLW5hbicpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBvYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgX3JlcXVpcmUkdHlwZXMgPSByZXF1aXJlKCd1dGlsLycpLnR5cGVzLFxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgaXNEYXRlID0gX3JlcXVpcmUkdHlwZXMuaXNEYXRlLFxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICBpc1NldCA9IF9yZXF1aXJlJHR5cGVzLmlzU2V0LFxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgIGlzTnVtYmVyT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNOdW1iZXJPYmplY3QsXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgaXNCaWdJbnRPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0JpZ0ludE9iamVjdCxcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgaXNGbG9hdDY0QXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cblxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7IC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgcmV0dXJuIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPyBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncyA6IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gIHJldHVybiBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cblxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xuICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdHJpY3QgPyBvYmplY3RJcyh2YWwxLCB2YWwyKSA6IHRydWU7XG4gIH0gLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuXG5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwxKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSk7XG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XG5cbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG5cblxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG5cblxuICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpOyAvLyBUaGUgcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcblxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG5cbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYUtleXMubGVuZ3RoID09PSAwICYmIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fCBpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCB8fCB2YWwxLnNpemUgPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cblxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG5cbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuXG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuXG5mdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gR28gbG9va2luZy5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VxdWFsaXR5X2NvbXBhcmlzb25zX2FuZF9zYW1lbmVzcyNMb29zZV9lcXVhbGl0eV91c2luZ1xuLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuLy8gY2FuIG1hdGNoIGxvdHMgb2YgZGlmZmVyZW50IHN0cmluZyB2YWx1ZXMgKGUuZy4sIDFuID09ICcrMDAwMDEnKS5cblxuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWU7XG4gIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuXG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XG5cbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5cbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gIC8vIHBhaXJ3aXNlLlxuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07IC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuXG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldOyAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtMSwgaXRlbTIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBmYWxzZSwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gIC8vIFNldHMgYW5kIG1hcHMgZG9uJ3QgaGF2ZSB0aGVpciBlbnRyaWVzIGFjY2Vzc2libGUgdmlhIG5vcm1hbCBvYmplY3RcbiAgLy8gcHJvcGVydGllcy5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG5cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2tleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmlsdGVyID0gcmVxdWlyZSgnYXJyYXktZmlsdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHJldHVybiBmaWx0ZXIoW1xuXHRcdCdCaWdJbnQ2NEFycmF5Jyxcblx0XHQnQmlnVWludDY0QXJyYXknLFxuXHRcdCdGbG9hdDMyQXJyYXknLFxuXHRcdCdGbG9hdDY0QXJyYXknLFxuXHRcdCdJbnQxNkFycmF5Jyxcblx0XHQnSW50MzJBcnJheScsXG5cdFx0J0ludDhBcnJheScsXG5cdFx0J1VpbnQxNkFycmF5Jyxcblx0XHQnVWludDMyQXJyYXknLFxuXHRcdCdVaW50OEFycmF5Jyxcblx0XHQnVWludDhDbGFtcGVkQXJyYXknXG5cdF0sIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBnbG9iYWxbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbic7XG5cdH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKHRpbWVvdXRFcnJvck1lc3NhZ2UsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi8nKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHR2YXIgZnVuYyA9ICRyZWZsZWN0QXBwbHkoYmluZCwgJGNhbGwsIGFyZ3VtZW50cyk7XG5cdGlmICgkZ09QRCAmJiAkZGVmaW5lUHJvcGVydHkpIHtcblx0XHR2YXIgZGVzYyA9ICRnT1BEKGZ1bmMsICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdC8vIG9yaWdpbmFsIGxlbmd0aCwgcGx1cyB0aGUgcmVjZWl2ZXIsIG1pbnVzIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIHJlY2VpdmVyKVxuXHRcdFx0JGRlZmluZVByb3BlcnR5KFxuXHRcdFx0XHRmdW5jLFxuXHRcdFx0XHQnbGVuZ3RoJyxcblx0XHRcdFx0eyB2YWx1ZTogMSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSB9XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZnVuYztcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cbiIsIi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIilcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpXG5mdW5jdGlvbiBub3coKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSB9XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxudmFyIGNvbnNvbGVcbnZhciB0aW1lcyA9IHt9XG5cbmlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbC5jb25zb2xlXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGVcbn0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9XG59XG5cbnZhciBmdW5jdGlvbnMgPSBbXG4gICAgW2xvZywgXCJsb2dcIl0sXG4gICAgW2luZm8sIFwiaW5mb1wiXSxcbiAgICBbd2FybiwgXCJ3YXJuXCJdLFxuICAgIFtlcnJvciwgXCJlcnJvclwiXSxcbiAgICBbdGltZSwgXCJ0aW1lXCJdLFxuICAgIFt0aW1lRW5kLCBcInRpbWVFbmRcIl0sXG4gICAgW3RyYWNlLCBcInRyYWNlXCJdLFxuICAgIFtkaXIsIFwiZGlyXCJdLFxuICAgIFtjb25zb2xlQXNzZXJ0LCBcImFzc2VydFwiXVxuXVxuXG5mb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0dXBsZSA9IGZ1bmN0aW9uc1tpXVxuICAgIHZhciBmID0gdHVwbGVbMF1cbiAgICB2YXIgbmFtZSA9IHR1cGxlWzFdXG5cbiAgICBpZiAoIWNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgY29uc29sZVtuYW1lXSA9IGZcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc29sZVxuXG5mdW5jdGlvbiBsb2coKSB7fVxuXG5mdW5jdGlvbiBpbmZvKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gd2FybigpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICB0aW1lc1tsYWJlbF0gPSBub3coKVxufVxuXG5mdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgdmFyIHRpbWUgPSB0aW1lc1tsYWJlbF1cbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbDogXCIgKyBsYWJlbClcbiAgICB9XG5cbiAgICBkZWxldGUgdGltZXNbbGFiZWxdXG4gICAgdmFyIGR1cmF0aW9uID0gbm93KCkgLSB0aW1lXG4gICAgY29uc29sZS5sb2cobGFiZWwgKyBcIjogXCIgKyBkdXJhdGlvbiArIFwibXNcIilcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpXG4gICAgZXJyLm5hbWUgPSBcIlRyYWNlXCJcbiAgICBlcnIubWVzc2FnZSA9IHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjaylcbn1cblxuZnVuY3Rpb24gZGlyKG9iamVjdCkge1xuICAgIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChvYmplY3QpICsgXCJcXG5cIilcbn1cblxuZnVuY3Rpb24gY29uc29sZUFzc2VydChleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBhcnIgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICAgYXNzZXJ0Lm9rKGZhbHNlLCB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcnIpKVxuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iaiA9IHJlcXVpcmUoJ2lzLW9iaicpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdTb3VyY2VzIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25LZXkodG8sIGZyb20sIGtleSkge1xuXHR2YXIgdmFsID0gZnJvbVtrZXldO1xuXG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSkge1xuXHRcdGlmICh0b1trZXldID09PSB1bmRlZmluZWQgfHwgdG9ba2V5XSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0ICgnICsga2V5ICsgJyknKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkgfHwgIWlzT2JqKHZhbCkpIHtcblx0XHR0b1trZXldID0gdmFsO1xuXHR9IGVsc2Uge1xuXHRcdHRvW2tleV0gPSBhc3NpZ24oT2JqZWN0KHRvW2tleV0pLCBmcm9tW2tleV0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbih0bywgZnJvbSkge1xuXHRpZiAodG8gPT09IGZyb20pIHtcblx0XHRyZXR1cm4gdG87XG5cdH1cblxuXHRmcm9tID0gT2JqZWN0KGZyb20pO1xuXG5cdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0YXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdGFzc2lnbktleSh0bywgZnJvbSwgc3ltYm9sc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0KSB7XG5cdHRhcmdldCA9IHRvT2JqZWN0KHRhcmdldCk7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRhc3NpZ24odGFyZ2V0LCBhcmd1bWVudHNbc10pO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCdmb28nKSA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBvcmlnRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG9iaiA9IHt9O1xuXHR0cnkge1xuXHRcdG9yaWdEZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdFx0Zm9yICh2YXIgXyBpbiBvYmopIHsgLy8ganNjczppZ25vcmUgZGlzYWxsb3dVbnVzZWRWYXJpYWJsZXNcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iai54ID09PSBvYmo7XG5cdH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBJRSA4LiAqL1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gb3JpZ0RlZmluZVByb3BlcnR5ICYmIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQoKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QgJiYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdG9yaWdEZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnKTtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIvKipcbiAqIENvZGUgcmVmYWN0b3JlZCBmcm9tIE1vemlsbGEgRGV2ZWxvcGVyIE5ldHdvcms6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGFzc2lnblxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnbixcbiAgcG9seWZpbGw6IHBvbHlmaWxsXG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLW5vZGUnKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVic3ViID0gcmVxdWlyZSgnbmFuby1wdWJzdWInKTtcbnZhciBtaWRkbGV3YXJlUmVkdWNlciA9IHJlcXVpcmUoJy4vdXRpbC9taWRkbGV3YXJlUmVkdWNlcicpO1xudmFyIHByb2Nlc3NPcHRpb25zID0gcmVxdWlyZSgnLi9taWRkbGV3YXJlL2RlZmF1bHRPcHRpb25zUHJvY2Vzc29yJyk7XG52YXIgdmFsaWRhdGVPcHRpb25zID0gcmVxdWlyZSgnLi9taWRkbGV3YXJlL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yJyk7XG52YXIgaHR0cFJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTsgLy8gbm9kZS1yZXF1ZXN0IGluIG5vZGUsIGJyb3dzZXItcmVxdWVzdCBpbiBicm93c2Vyc1xuXG52YXIgY2hhbm5lbE5hbWVzID0gWydyZXF1ZXN0JywgJ3Jlc3BvbnNlJywgJ3Byb2dyZXNzJywgJ2Vycm9yJywgJ2Fib3J0J107XG52YXIgbWlkZGxlaG9va3MgPSBbJ3Byb2Nlc3NPcHRpb25zJywgJ3ZhbGlkYXRlT3B0aW9ucycsICdpbnRlcmNlcHRSZXF1ZXN0JywgJ2ZpbmFsaXplT3B0aW9ucycsICdvblJlcXVlc3QnLCAnb25SZXNwb25zZScsICdvbkVycm9yJywgJ29uUmV0dXJuJywgJ29uSGVhZGVycyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RlcigpIHtcbiAgdmFyIGluaXRNaWRkbGV3YXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICB2YXIgbG9hZGVkTWlkZGxld2FyZSA9IFtdO1xuICB2YXIgbWlkZGxld2FyZSA9IG1pZGRsZWhvb2tzLnJlZHVjZShmdW5jdGlvbiAod2FyZSwgbmFtZSkge1xuICAgIHdhcmVbbmFtZV0gPSB3YXJlW25hbWVdIHx8IFtdO1xuICAgIHJldHVybiB3YXJlO1xuICB9LCB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IFtwcm9jZXNzT3B0aW9uc10sXG4gICAgdmFsaWRhdGVPcHRpb25zOiBbdmFsaWRhdGVPcHRpb25zXVxuICB9KTtcblxuICBmdW5jdGlvbiByZXF1ZXN0KG9wdHMpIHtcbiAgICB2YXIgY2hhbm5lbHMgPSBjaGFubmVsTmFtZXMucmVkdWNlKGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IHB1YnN1YigpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LCB7fSk7XG5cbiAgICAvLyBQcmVwYXJlIGEgbWlkZGxld2FyZSByZWR1Y2VyIHRoYXQgY2FuIGJlIHJldXNlZCB0aHJvdWdob3V0IHRoZSBsaWZlY3ljbGVcbiAgICB2YXIgYXBwbHlNaWRkbGV3YXJlID0gbWlkZGxld2FyZVJlZHVjZXIobWlkZGxld2FyZSk7XG5cbiAgICAvLyBQYXJzZSB0aGUgcGFzc2VkIG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IGFwcGx5TWlkZGxld2FyZSgncHJvY2Vzc09wdGlvbnMnLCBvcHRzKTtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSBvcHRpb25zXG4gICAgYXBwbHlNaWRkbGV3YXJlKCd2YWxpZGF0ZU9wdGlvbnMnLCBvcHRpb25zKTtcblxuICAgIC8vIEJ1aWxkIGEgY29udGV4dCBvYmplY3Qgd2UgY2FuIHBhc3MgdG8gY2hpbGQgaGFuZGxlcnNcbiAgICB2YXIgY29udGV4dCA9IHsgb3B0aW9uczogb3B0aW9ucywgY2hhbm5lbHM6IGNoYW5uZWxzLCBhcHBseU1pZGRsZXdhcmU6IGFwcGx5TWlkZGxld2FyZVxuXG4gICAgICAvLyBXZSBuZWVkIHRvIGhvbGQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQsIG9uZ29pbmcgcmVxdWVzdCxcbiAgICAgIC8vIGluIG9yZGVyIHRvIGFsbG93IGNhbmNlbGxhdGlvbi4gSW4gdGhlIGNhc2Ugb2YgdGhlIHJldHJ5IG1pZGRsZXdhcmUsXG4gICAgICAvLyBhIG5ldyByZXF1ZXN0IG1pZ2h0IGJlIHRyaWdnZXJlZFxuICAgIH07dmFyIG9uZ29pbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBjaGFubmVscy5yZXF1ZXN0LnN1YnNjcmliZShmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAvLyBMZXQgcmVxdWVzdCBhZGFwdGVycyAobm9kZS9icm93c2VyKSBwZXJmb3JtIHRoZSBhY3R1YWwgcmVxdWVzdFxuICAgICAgb25nb2luZ1JlcXVlc3QgPSBodHRwUmVxdWVzdChjdHgsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICByZXR1cm4gb25SZXNwb25zZShlcnIsIHJlcywgY3R4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgd2UgYWJvcnQgdGhlIHJlcXVlc3QsIHByZXZlbnQgZnVydGhlciByZXF1ZXN0cyBmcm9tIGhhcHBlbmluZyxcbiAgICAvLyBhbmQgYmUgc3VyZSB0byBjYW5jZWwgYW55IG9uZ29pbmcgcmVxdWVzdCAob2J2aW91c2x5KVxuICAgIGNoYW5uZWxzLmFib3J0LnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9uZ29pbmdSZXF1ZXN0KSB7XG4gICAgICAgIG9uZ29pbmdSZXF1ZXN0LmFib3J0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZWUgaWYgYW55IG1pZGRsZXdhcmUgd2FudHMgdG8gbW9kaWZ5IHRoZSByZXR1cm4gdmFsdWUgLSBmb3IgaW5zdGFuY2VcbiAgICAvLyB0aGUgcHJvbWlzZSBvciBvYnNlcnZhYmxlIG1pZGRsZXdhcmVzXG4gICAgdmFyIHJldHVyblZhbHVlID0gYXBwbHlNaWRkbGV3YXJlKCdvblJldHVybicsIGNoYW5uZWxzLCBjb250ZXh0KTtcblxuICAgIC8vIElmIHJldHVybiB2YWx1ZSBoYXMgYmVlbiBtb2RpZmllZCBieSBhIG1pZGRsZXdhcmUsIHdlIGV4cGVjdCB0aGUgbWlkZGxld2FyZVxuICAgIC8vIHRvIHB1Ymxpc2ggb24gdGhlICdyZXF1ZXN0JyBjaGFubmVsLiBJZiBpdCBoYXNuJ3QgYmVlbiBtb2RpZmllZCwgd2Ugd2FudCB0b1xuICAgIC8vIHRyaWdnZXIgaXQgcmlnaHQgYXdheVxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gY2hhbm5lbHMpIHtcbiAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG5cbiAgICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlcUVyciwgcmVzLCBjdHgpIHtcbiAgICAgIHZhciBlcnJvciA9IHJlcUVycjtcbiAgICAgIHZhciByZXNwb25zZSA9IHJlcztcblxuICAgICAgLy8gV2UncmUgcHJvY2Vzc2luZyBub24tZXJyb3JzIGZpcnN0LCBpbiBjYXNlIGEgbWlkZGxld2FyZSBjb252ZXJ0cyB0aGVcbiAgICAgIC8vIHJlc3BvbnNlIGludG8gYW4gZXJyb3IgKGZvciBpbnN0YW5jZSwgc3RhdHVzID49IDQwMCA9PSBIdHRwRXJyb3IpXG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhcHBseU1pZGRsZXdhcmUoJ29uUmVzcG9uc2UnLCByZXMsIGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBlcnJvciBtaWRkbGV3YXJlIC0gaWYgbWlkZGxld2FyZSByZXR1cm4gdGhlIHNhbWUgKG9yIGEgZGlmZmVyZW50KSBlcnJvcixcbiAgICAgIC8vIHB1Ymxpc2ggYXMgYW4gZXJyb3IgZXZlbnQuIElmIHdlICpkb24ndCogcmV0dXJuIGFuIGVycm9yLCBhc3N1bWUgaXQgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAgZXJyb3IgPSBlcnJvciAmJiBhcHBseU1pZGRsZXdhcmUoJ29uRXJyb3InLCBlcnJvciwgY3R4KTtcblxuICAgICAgLy8gRmlndXJlIG91dCBpZiB3ZSBzaG91bGQgcHVibGlzaCBvbiBlcnJvci9yZXNwb25zZSBjaGFubmVsc1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZSkge1xuICAgICAgICBjaGFubmVscy5yZXNwb25zZS5wdWJsaXNoKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXF1ZXN0LnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdNaWRkbGV3YXJlKSB7XG4gICAgaWYgKCFuZXdNaWRkbGV3YXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRoYXQgcmVzb2x2ZWQgdG8gZmFsc2V5IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdNaWRkbGV3YXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRoYXQgd2FzIGEgZnVuY3Rpb24uIEl0IHByb2JhYmx5IGV4cGVjdHMgeW91IHRvIHBhc3Mgb3B0aW9ucyB0byBpdC4nKTtcbiAgICB9XG5cbiAgICBpZiAobmV3TWlkZGxld2FyZS5vblJldHVybiAmJiBtaWRkbGV3YXJlLm9uUmV0dXJuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gYWRkIG5ldyBtaWRkbGV3YXJlIHdpdGggYG9uUmV0dXJuYCBoYW5kbGVyLCBidXQgYW5vdGhlciBoYW5kbGVyIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudCcpO1xuICAgIH1cblxuICAgIG1pZGRsZWhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG5ld01pZGRsZXdhcmVba2V5XSkge1xuICAgICAgICBtaWRkbGV3YXJlW2tleV0ucHVzaChuZXdNaWRkbGV3YXJlW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbG9hZGVkTWlkZGxld2FyZS5wdXNoKG5ld01pZGRsZXdhcmUpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9O1xuXG4gIHJlcXVlc3QuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVxdWVzdGVyKGxvYWRlZE1pZGRsZXdhcmUpO1xuICB9O1xuXG4gIGluaXRNaWRkbGV3YXJlLmZvckVhY2gocmVxdWVzdC51c2UpO1xuXG4gIHJldHVybiByZXF1ZXN0O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciB1cmxQYXJzZSA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7IHRpbWVvdXQ6IGlzUmVhY3ROYXRpdmUgPyA2MDAwMCA6IDEyMDAwMCB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnID8gb2JqZWN0QXNzaWduKHsgdXJsOiBvcHRzIH0sIGRlZmF1bHRPcHRpb25zKSA6IG9iamVjdEFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdHMpO1xuXG4gIC8vIFBhcnNlIFVSTCBpbnRvIHBhcnRzXG4gIHZhciB1cmwgPSB1cmxQYXJzZShvcHRpb25zLnVybCwge30sIC8vIERvbid0IHVzZSBjdXJyZW50IGJyb3dzZXIgbG9jYXRpb25cbiAgdHJ1ZSAvLyBQYXJzZSBxdWVyeSBzdHJpbmdzXG4gICk7XG5cbiAgLy8gTm9ybWFsaXplIHRpbWVvdXRzXG4gIG9wdGlvbnMudGltZW91dCA9IG5vcm1hbGl6ZVRpbWVvdXQob3B0aW9ucy50aW1lb3V0KTtcblxuICAvLyBTaGFsbG93LW1lcmdlIChvdmVycmlkZSkgZXhpc3RpbmcgcXVlcnkgcGFyYW1zXG4gIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgdXJsLnF1ZXJ5ID0gb2JqZWN0QXNzaWduKHt9LCB1cmwucXVlcnksIHJlbW92ZVVuZGVmaW5lZChvcHRpb25zLnF1ZXJ5KSk7XG4gIH1cblxuICAvLyBJbXBsaWNpdCBQT1NUIGlmIHdlIGhhdmUgbm90IHNwZWNpZmllZCBhIG1ldGhvZCBidXQgaGF2ZSBhIGJvZHlcbiAgb3B0aW9ucy5tZXRob2QgPSBvcHRpb25zLmJvZHkgJiYgIW9wdGlvbnMubWV0aG9kID8gJ1BPU1QnIDogKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gIC8vIFN0cmluZ2lmeSBVUkxcbiAgb3B0aW9ucy51cmwgPSB1cmwudG9TdHJpbmcoc3RyaW5naWZ5UXVlcnlTdHJpbmcpO1xuXG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnlTdHJpbmcob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcHVzaChrZXksIG9ialtrZXldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcGFpcnMuam9pbignJicpIDogJyc7XG5cbiAgZnVuY3Rpb24gcHVzaChrZXksIHZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBwdXNoKGtleSwgaXRlbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWxdLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJz0nKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVvdXQodGltZSkge1xuICBpZiAodGltZSA9PT0gZmFsc2UgfHwgdGltZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aW1lLmNvbm5lY3QgfHwgdGltZS5zb2NrZXQpIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuXG4gIHZhciBkZWxheSA9IE51bWJlcih0aW1lKTtcbiAgaWYgKGlzTmFOKGRlbGF5KSkge1xuICAgIHJldHVybiBub3JtYWxpemVUaW1lb3V0KGRlZmF1bHRPcHRpb25zLnRpbWVvdXQpO1xuICB9XG5cbiAgcmV0dXJuIHsgY29ubmVjdDogZGVsYXksIHNvY2tldDogZGVsYXkgfTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkKG9iaikge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRPcHRpb25zUHJvY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdmFsaWRVcmwgPSAvXmh0dHBzPzpcXC9cXC8vaTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAoIXZhbGlkVXJsLnRlc3Qob3B0aW9ucy51cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcIlwiICsgb3B0aW9ucy51cmwgKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgVVJMXCIpO1xuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xuXG52YXIgc2VyaWFsaXplVHlwZXMgPSBbJ2Jvb2xlYW4nLCAnc3RyaW5nJywgJ251bWJlciddO1xudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IGZ1bmN0aW9uIHByb2Nlc3NPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNTdHJlYW0gPSB0eXBlb2YgYm9keS5waXBlID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZFNlcmlhbGl6ZSA9ICFpc1N0cmVhbSAmJiAhaXNCdWZmZXIoYm9keSkgJiYgKHNlcmlhbGl6ZVR5cGVzLmluZGV4T2YodHlwZW9mIGJvZHkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGJvZHkpKSAhPT0gLTEgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCBpc1BsYWluT2JqZWN0KGJvZHkpKTtcblxuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3RBc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczogb2JqZWN0QXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvblJlcXVlc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXNwb25zZTogZnVuY3Rpb24gb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlID0gb3B0cyAmJiBvcHRzLmZvcmNlIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSAhPT0gLTE7XG4gICAgICBpZiAoIXJlc3BvbnNlLmJvZHkgfHwgIWNvbnRlbnRUeXBlIHx8ICFzaG91bGREZWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0QXNzaWduKHt9LCByZXNwb25zZSwgeyBib2R5OiB0cnlQYXJzZShyZXNwb25zZS5ib2R5KSB9KTtcbiAgICB9LFxuXG4gICAgcHJvY2Vzc09wdGlvbnM6IGZ1bmN0aW9uIHByb2Nlc3NPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvYmplY3RBc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgaGVhZGVyczogb2JqZWN0QXNzaWduKHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicgfSwgb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gdHJ5UGFyc2UoYm9keSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIubWVzc2FnZSA9ICdGYWlsZWQgdG8gcGFyc2VkIHJlc3BvbnNlIGJvZHkgYXMgSlNPTjogJyArIGVyci5tZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvblJlc3BvbnNlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2xvYmFsJyk7XG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBPYnNlcnZhYmxlID0gb3B0cy5pbXBsZW1lbnRhdGlvbiB8fCBnbG9iYWwuT2JzZXJ2YWJsZTtcbiAgaWYgKCFPYnNlcnZhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgT2JzZXJ2YWJsZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiBmdW5jdGlvbiBvblJldHVybihjaGFubmVscywgY29udGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBjaGFubmVscy5lcnJvci5zdWJzY3JpYmUoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hhbm5lbHMucHJvZ3Jlc3Muc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBvYnNlcnZlci5uZXh0KG9iamVjdEFzc2lnbih7IHR5cGU6ICdwcm9ncmVzcycgfSwgZXZlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZShmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KG9iamVjdEFzc2lnbih7IHR5cGU6ICdyZXNwb25zZScgfSwgcmVzcG9uc2UpKTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYW5uZWxzLmFib3J0LnB1Ymxpc2goKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXF1ZXN0OiBmdW5jdGlvbiBvblJlcXVlc3QoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmFkYXB0ZXIgIT09ICd4aHInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IGV2dC5yZXF1ZXN0O1xuICAgICAgdmFyIGNvbnRleHQgPSBldnQuY29udGV4dDtcblxuICAgICAgaWYgKCd1cGxvYWQnIGluIHhociAmJiAnb25wcm9ncmVzcycgaW4geGhyLnVwbG9hZCkge1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcygndXBsb2FkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgnb25wcm9ncmVzcycgaW4geGhyKSB7XG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MoJ2Rvd25sb2FkJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKHN0YWdlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgcGVyY2VudCA9IGV2ZW50Lmxlbmd0aENvbXB1dGFibGUgPyBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCAqIDEwMCA6IC0xO1xuICAgICAgICAgIGNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaCh7XG4gICAgICAgICAgICBzdGFnZTogc3RhZ2UsXG4gICAgICAgICAgICBwZXJjZW50OiBwZXJjZW50LFxuICAgICAgICAgICAgdG90YWw6IGV2ZW50LnRvdGFsLFxuICAgICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiBldmVudC5sZW5ndGhDb21wdXRhYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXItcHJvZ3Jlc3MuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS1wcm9ncmVzcycpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbWF4LWRlcHRoOiBbXCJlcnJvclwiLCA0XSAqL1xudmFyIHNhbWVPcmlnaW4gPSByZXF1aXJlKCdzYW1lLW9yaWdpbicpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJ3BhcnNlLWhlYWRlcnMnKTtcbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHtcbiAgLyogaW50ZW50aW9uYWwgbm9vcCAqL1xufTtcblxudmFyIHdpbiA9IHdpbmRvdztcbnZhciBYbWxIdHRwUmVxdWVzdCA9IHdpbi5YTUxIdHRwUmVxdWVzdCB8fCBub29wO1xudmFyIGhhc1hocjIgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWG1sSHR0cFJlcXVlc3QoKTtcbnZhciBYRG9tYWluUmVxdWVzdCA9IGhhc1hocjIgPyBYbWxIdHRwUmVxdWVzdCA6IHdpbi5YRG9tYWluUmVxdWVzdDtcbnZhciBhZGFwdGVyID0gJ3hocic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIHZhciBvcHRzID0gY29udGV4dC5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKCdmaW5hbGl6ZU9wdGlvbnMnLCBvcHRzKTtcbiAgdmFyIHRpbWVycyA9IHt9O1xuXG4gIC8vIERlZXAtY2hlY2tpbmcgd2luZG93LmxvY2F0aW9uIGJlY2F1c2Ugb2YgcmVhY3QgbmF0aXZlLCB3aGVyZSBgbG9jYXRpb25gIGRvZXNuJ3QgZXhpc3RcbiAgdmFyIGNvcnMgPSB3aW4gJiYgd2luLmxvY2F0aW9uICYmICFzYW1lT3JpZ2luKHdpbi5sb2NhdGlvbi5ocmVmLCBvcHRpb25zLnVybCk7XG5cbiAgLy8gQWxsb3cgbWlkZGxld2FyZSB0byBpbmplY3QgYSByZXNwb25zZSwgZm9yIGluc3RhbmNlIGluIHRoZSBjYXNlIG9mIGNhY2hpbmcgb3IgbW9ja2luZ1xuICB2YXIgaW5qZWN0ZWRSZXNwb25zZSA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKCdpbnRlcmNlcHRSZXF1ZXN0JywgdW5kZWZpbmVkLCB7XG4gICAgYWRhcHRlcjogYWRhcHRlcixcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIC8vIElmIG1pZGRsZXdhcmUgaW5qZWN0ZWQgYSByZXNwb25zZSwgdHJlYXQgaXQgYXMgd2Ugbm9ybWFsbHkgd291bGQgYW5kIHJldHVybiBpdFxuICAvLyBEbyBub3RlIHRoYXQgdGhlIGluamVjdGVkIHJlc3BvbnNlIGhhcyB0byBiZSByZWR1Y2VkIHRvIGEgY3Jvc3MtZW52aXJvbm1lbnQgZnJpZW5kbHkgcmVzcG9uc2VcbiAgaWYgKGluamVjdGVkUmVzcG9uc2UpIHtcbiAgICB2YXIgY2JUaW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDAsIG51bGwsIGluamVjdGVkUmVzcG9uc2UpO1xuICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGNiVGltZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIHsgYWJvcnQ6IGNhbmNlbCB9O1xuICB9XG5cbiAgLy8gV2UnbGwgd2FudCB0byBudWxsIG91dCB0aGUgcmVxdWVzdCBvbiBzdWNjZXNzL2ZhaWx1cmVcbiAgdmFyIHhociA9IGNvcnMgPyBuZXcgWERvbWFpblJlcXVlc3QoKSA6IG5ldyBYbWxIdHRwUmVxdWVzdCgpO1xuXG4gIHZhciBpc1hkciA9IHdpbi5YRG9tYWluUmVxdWVzdCAmJiB4aHIgaW5zdGFuY2VvZiB3aW4uWERvbWFpblJlcXVlc3Q7XG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuXG4gIC8vIFJlcXVlc3Qgc3RhdGVcbiAgdmFyIGFib3J0ZWQgPSBmYWxzZTtcbiAgdmFyIGxvYWRlZCA9IGZhbHNlO1xuICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcblxuICAvLyBBcHBseSBldmVudCBoYW5kbGVyc1xuICB4aHIub25lcnJvciA9IG9uRXJyb3I7XG4gIHhoci5vbnRpbWVvdXQgPSBvbkVycm9yO1xuICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgfTtcblxuICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uXG4gIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGludGVudGlvbmFsIG5vb3AgKi9cbiAgfTtcblxuICB2YXIgbG9hZEV2ZW50ID0gaXNYZHIgPyAnb25sb2FkJyA6ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICB4aHJbbG9hZEV2ZW50XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBQcmV2ZW50IHJlcXVlc3QgZnJvbSB0aW1pbmcgb3V0XG4gICAgcmVzZXRUaW1lcnMoKTtcblxuICAgIGlmIChhYm9ydGVkIHx8IHhoci5yZWFkeVN0YXRlICE9PSA0ICYmICFpc1hkcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdpbGwgYmUgaGFuZGxlZCBieSBvbkVycm9yXG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvbkxvYWQoKTtcbiAgfTtcblxuICAvLyBAdG9kbyB0d28gbGFzdCBvcHRpb25zIHRvIG9wZW4oKSBpcyB1c2VybmFtZS9wYXNzd29yZFxuICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwsIHRydWUgLy8gQWx3YXlzIGFzeW5jXG4gICk7XG5cbiAgLy8gU29tZSBvcHRpb25zIG5lZWQgdG8gYmUgYXBwbGllZCBhZnRlciBvcGVuXG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xuXG4gIC8vIFNldCBoZWFkZXJzXG4gIGlmIChoZWFkZXJzICYmIHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkZXJzICYmIGlzWGRyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yYXdCb2R5KSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICAvLyBMZXQgbWlkZGxld2FyZSBrbm93IHdlJ3JlIGFib3V0IHRvIGRvIGEgcmVxdWVzdFxuICBjb250ZXh0LmFwcGx5TWlkZGxld2FyZSgnb25SZXF1ZXN0JywgeyBvcHRpb25zOiBvcHRpb25zLCBhZGFwdGVyOiBhZGFwdGVyLCByZXF1ZXN0OiB4aHIsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG5cbiAgeGhyLnNlbmQob3B0aW9ucy5ib2R5IHx8IG51bGwpO1xuXG4gIC8vIEZpZ3VyZSBvdXQgd2hpY2ggdGltZW91dHMgdG8gdXNlIChpZiBhbnkpXG4gIHZhciBkZWxheXMgPSBvcHRpb25zLnRpbWVvdXQ7XG4gIGlmIChkZWxheXMpIHtcbiAgICB0aW1lcnMuY29ubmVjdCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRpbWVvdXRSZXF1ZXN0KCdFVElNRURPVVQnKTtcbiAgICB9LCBkZWxheXMuY29ubmVjdCk7XG4gIH1cblxuICByZXR1cm4geyBhYm9ydDogYWJvcnQgfTtcblxuICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcblxuICAgIGlmICh4aHIpIHtcbiAgICAgIHhoci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVvdXRSZXF1ZXN0KGNvZGUpIHtcbiAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgeGhyLmFib3J0KCk7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGNvZGUgPT09ICdFU09DS0VUVElNRURPVVQnID8gJ1NvY2tldCB0aW1lZCBvdXQgb24gcmVxdWVzdCB0byAnICsgb3B0aW9ucy51cmwgOiAnQ29ubmVjdGlvbiB0aW1lZCBvdXQgb24gcmVxdWVzdCB0byAnICsgb3B0aW9ucy51cmwpO1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgIGNvbnRleHQuY2hhbm5lbHMuZXJyb3IucHVibGlzaChlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWVycygpIHtcbiAgICBpZiAoIWRlbGF5cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0b3BUaW1lcnMoKTtcbiAgICB0aW1lcnMuc29ja2V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGltZW91dFJlcXVlc3QoJ0VTT0NLRVRUSU1FRE9VVCcpO1xuICAgIH0sIGRlbGF5cy5zb2NrZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFRpbWVycygpIHtcbiAgICAvLyBPbmx5IGNsZWFyIHRoZSBjb25uZWN0IHRpbWVvdXQgaWYgd2UndmUgZ290IGEgY29ubmVjdGlvblxuICAgIGlmIChhYm9ydGVkIHx8IHhoci5yZWFkeVN0YXRlID49IDIgJiYgdGltZXJzLmNvbm5lY3QpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcnMuY29ubmVjdCk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVycy5zb2NrZXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcnMuc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgIGlmIChsb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cFxuICAgIHN0b3BUaW1lcnMoKTtcbiAgICBsb2FkZWQgPSB0cnVlO1xuICAgIHhociA9IG51bGw7XG5cbiAgICAvLyBBbm5veWluZ2x5LCBkZXRhaWxzIGFyZSBleHRyZW1lbHkgc2NhcmNlIGFuZCBoaWRkZW4gZnJvbSB1cy5cbiAgICAvLyBXZSBvbmx5IHJlYWxseSBrbm93IHRoYXQgaXQgaXMgYSBuZXR3b3JrIGVycm9yXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignTmV0d29yayBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHJlYWNoICcgKyBvcHRpb25zLnVybCk7XG4gICAgZXJyLmlzTmV0d29ya0Vycm9yID0gdHJ1ZTtcbiAgICBlcnIucmVxdWVzdCA9IG9wdGlvbnM7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZHVjZVJlc3BvbnNlKCkge1xuICAgIHZhciBzdGF0dXNDb2RlID0geGhyLnN0YXR1cztcbiAgICB2YXIgc3RhdHVzTWVzc2FnZSA9IHhoci5zdGF0dXNUZXh0O1xuXG4gICAgaWYgKGlzWGRyICYmIHN0YXR1c0NvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSUU4IENPUlMgR0VUIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lc24ndCBoYXZlIGEgc3RhdHVzIGZpZWxkLCBidXQgYm9keSBpcyBmaW5lXG4gICAgICBzdGF0dXNDb2RlID0gMjAwO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA+IDEyMDAwICYmIHN0YXR1c0NvZGUgPCAxMjE1Nikge1xuICAgICAgLy8gWWV0IGFub3RoZXIgSUUgcXVpcmsgd2hlcmUgaXQgZW1pdHMgd2VpcmQgc3RhdHVzIGNvZGVzIG9uIG5ldHdvcmsgZXJyb3JzXG4gICAgICAvLyBodHRwczovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9lbi11cy9rYi8xOTM2MjVcbiAgICAgIHJldHVybiBvbkVycm9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFub3RoZXIgSUUgYnVnIHdoZXJlIEhUVFAgMjA0IHNvbWVob3cgZW5kcyB1cCBhcyAxMjIzXG4gICAgICBzdGF0dXNDb2RlID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXM7XG4gICAgICBzdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHN0YXR1c01lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHk6IHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0LFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBpc1hkciA/IHt9IDogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSksXG4gICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzTWVzc2FnZTogc3RhdHVzTWVzc2FnZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgaWYgKGFib3J0ZWQgfHwgbG9hZGVkIHx8IHRpbWVkT3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgIG9uRXJyb3IobmV3IEVycm9yKCdVbmtub3duIFhIUiBlcnJvcicpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgIHN0b3BUaW1lcnMoKTtcbiAgICBsb2FkZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKG51bGwsIHJlZHVjZVJlc3BvbnNlKCkpO1xuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci1yZXF1ZXN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUtcmVxdWVzdCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZWdhdGVkLWNvbmRpdGlvbiAqL1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gIHZhciBhcHBseU1pZGRsZXdhcmUgPSBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoaG9vaywgZGVmYXVsdFZhbHVlKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYmFpbEVhcmx5ID0gaG9vayA9PT0gJ29uRXJyb3InO1xuXG4gICAgdmFyIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlkZGxld2FyZVtob29rXS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhhbmRsZXIgPSBtaWRkbGV3YXJlW2hvb2tdW2ldO1xuICAgICAgdmFsdWUgPSBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgW3ZhbHVlXS5jb25jYXQoYXJncykpO1xuXG4gICAgICBpZiAoYmFpbEVhcmx5ICYmICF2YWx1ZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGFwcGx5TWlkZGxld2FyZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWRkbGV3YXJlUmVkdWNlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uID0gZ2V0UHJvdG8gJiYgZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdGlmIChOdW1iZXIuaXNOYU4gJiYgTnVtYmVyLmlzTmFOKE5hTikgJiYgIU51bWJlci5pc05hTignYScpKSB7XG5cdFx0cmV0dXJuIE51bWJlci5pc05hTjtcblx0fVxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1OdW1iZXJJc05hTigpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE51bWJlciwgeyBpc05hTjogcG9seWZpbGwgfSwge1xuXHRcdGlzTmFOOiBmdW5jdGlvbiB0ZXN0SXNOYU4oKSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xuXHR2YXIgdHlwZSA9IHR5cGVvZiB4O1xuXHRyZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuIiwiLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG5mdW5jdGlvbiBpc09iamVjdE9iamVjdChvKSB7XG4gIHJldHVybiBpc09iamVjdChvKSA9PT0gdHJ1ZVxuICAgICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHZhciBjdG9yLHByb3Q7XG5cbiAgaWYgKGlzT2JqZWN0T2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKHR5cGVvZiBjdG9yICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdE9iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdsb2JhbFt0eXBlZEFycmF5XSgpO1xuXHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXZhbEVycm9yKCd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArIHR5cGVkQXJyYXkgKyAnIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuJyk7XG5cdFx0fVxuXHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdH1cblx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBhbnlUcnVlID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFhbnlUcnVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhbnlUcnVlID0gZ2V0dGVyLmNhbGwodmFsdWUpID09PSB0eXBlZEFycmF5O1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gYW55VHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvKiFcbiAqIGlzb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pc29iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpID09PSBmYWxzZTtcbn07XG4iLCIvLyBJU0MgQCBKdWxpZW4gRm9udGFuZXRcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudmFyIGNvbnN0cnVjdCA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiID8gUmVmbGVjdC5jb25zdHJ1Y3QgOiB1bmRlZmluZWQ7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNhcHR1cmVTdGFja1RyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U7XG5pZiAoY2FwdHVyZVN0YWNrVHJhY2UgPT09IHVuZGVmaW5lZCkge1xuICBjYXB0dXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKGVycm9yKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IG5ldyBFcnJvcigpO1xuXG4gICAgZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwic3RhY2tcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXRTdGFjaygpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gY29udGFpbmVyLnN0YWNrO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgcHJvcGVydHkgd2l0aCB2YWx1ZSBmb3IgZmFzdGVyIGZ1dHVyZSBhY2Nlc3Nlcy5cbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBzdGFjayxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0U3RhY2soc3RhY2spIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwic3RhY2tcIiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogc3RhY2ssXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBCYXNlRXJyb3IobWVzc2FnZSkge1xuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICB2YXIgY25hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChjbmFtZSAhPT0gdW5kZWZpbmVkICYmIGNuYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGNuYW1lLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbn1cblxuQmFzZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL0pzQ29tbXVuaXR5L21ha2UtZXJyb3IvaXNzdWVzLzRcbiAgY29uc3RydWN0b3I6IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IEJhc2VFcnJvcixcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgfSxcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFNldHMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBpZiBwb3NzaWJsZSAoZGVwZW5kcyBvZiB0aGUgSlMgZW5naW5lKS5cbnZhciBzZXRGdW5jdGlvbk5hbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNldEZ1bmN0aW9uTmFtZShmbiwgbmFtZSkge1xuICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmbiwgXCJuYW1lXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGYgPSBmdW5jdGlvbigpIHt9O1xuICAgIHNldEZ1bmN0aW9uTmFtZShmLCBcImZvb1wiKTtcbiAgICBpZiAoZi5uYW1lID09PSBcImZvb1wiKSB7XG4gICAgICByZXR1cm4gc2V0RnVuY3Rpb25OYW1lO1xuICAgIH1cbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gbWFrZUVycm9yKGNvbnN0cnVjdG9yLCBzdXBlcl8pIHtcbiAgaWYgKHN1cGVyXyA9PSBudWxsIHx8IHN1cGVyXyA9PT0gRXJyb3IpIHtcbiAgICBzdXBlcl8gPSBCYXNlRXJyb3I7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN1cGVyXyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInN1cGVyXyBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHZhciBuYW1lO1xuICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgbmFtZSA9IGNvbnN0cnVjdG9yO1xuICAgIGNvbnN0cnVjdG9yID1cbiAgICAgIGNvbnN0cnVjdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0KHN1cGVyXywgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuXG4gICAgLy8gSWYgdGhlIG5hbWUgY2FuIGJlIHNldCwgZG8gaXQgb25jZSBhbmQgZm9yIGFsbC5cbiAgICBpZiAoc2V0RnVuY3Rpb25OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldEZ1bmN0aW9uTmFtZShjb25zdHJ1Y3RvciwgbmFtZSk7XG4gICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb25zdHJ1Y3RvciBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyBBbHNvIHJlZ2lzdGVyIHRoZSBzdXBlciBjb25zdHJ1Y3RvciBhbHNvIGFzIGBjb25zdHJ1Y3Rvci5zdXBlcl9gIGp1c3RcbiAgLy8gbGlrZSBOb2RlJ3MgYHV0aWwuaW5oZXJpdHMoKWAuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkb3Qtbm90YXRpb25cbiAgY29uc3RydWN0b3Iuc3VwZXJfID0gY29uc3RydWN0b3JbXCJzdXBlclwiXSA9IHN1cGVyXztcblxuICB2YXIgcHJvcGVydGllcyA9IHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGNvbnN0cnVjdG9yLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSxcbiAgfTtcblxuICAvLyBJZiB0aGUgbmFtZSBjb3VsZCBub3QgYmUgc2V0IG9uIHRoZSBjb25zdHJ1Y3Rvciwgc2V0IGl0IG9uIHRoZVxuICAvLyBwcm90b3R5cGUuXG4gIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBwcm9wZXJ0aWVzLm5hbWUgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbmFtZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlcl8ucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uc3RydWN0b3I7XG59XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBtYWtlRXJyb3I7XG5leHBvcnRzLkJhc2VFcnJvciA9IEJhc2VFcnJvcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUHVic3ViKCkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBbXVxuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIHB1Ymxpc2g6IHB1Ymxpc2hcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXJzLnB1c2goc3Vic2NyaWJlcilcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICB2YXIgaWR4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihzdWJzY3JpYmVyKVxuICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpZHgsIDEpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHB1Ymxpc2goKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgc3Vic2NyaWJlcnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufSIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCJ2YXIgdHJpbSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICB2YXIgaGVhZGVyc0FyciA9IHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJzQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IGhlYWRlcnNBcnJbaV1cbiAgICB2YXIgaW5kZXggPSByb3cuaW5kZXhPZignOicpXG4gICAgLCBrZXkgPSB0cmltKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKClcbiAgICAsIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaW5kZXggKyAxKSlcblxuICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gWyByZXN1bHRba2V5XSwgdmFsdWUgXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgdW5kZWY7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGVuY29kZSBhIGdpdmVuIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGVuY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/IyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGUoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlKHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjYW5SZXBvcnRFcnJvcl8xID0gcmVxdWlyZShcIi4vdXRpbC9jYW5SZXBvcnRFcnJvclwiKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWwvdG9TdWJzY3JpYmVyXCIpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoXCIuL3N5bWJvbC9vYnNlcnZhYmxlXCIpO1xudmFyIHBpcGVfMSA9IHJlcXVpcmUoXCIuL3V0aWwvcGlwZVwiKTtcbnZhciBjb25maWdfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbnZhciBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XG4gICAgICAgIHZhciBzaW5rID0gdG9TdWJzY3JpYmVyXzEudG9TdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKG9wZXJhdG9yLmNhbGwoc2luaywgdGhpcy5zb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuc291cmNlIHx8IChjb25maWdfMS5jb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyAmJiAhc2luay5zeW5jRXJyb3JUaHJvd2FibGUpID9cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoc2luaykgOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2luay5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5SZXBvcnRFcnJvcl8xLmNhblJlcG9ydEVycm9yKHNpbmspKSB7XG4gICAgICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgcHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcHJvbWlzZUN0b3IgPSBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcik7XG4gICAgICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QsIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIHJldHVybiBzb3VyY2UgJiYgc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlW29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3BlcmF0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVfMS5waXBlRnJvbUFycmF5KG9wZXJhdGlvbnMpKHRoaXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xuICAgICAgICByZXR1cm4gbmV3IHByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gdmFsdWUgPSB4OyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG5mdW5jdGlvbiBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcikge1xuICAgIGlmICghcHJvbWlzZUN0b3IpIHtcbiAgICAgICAgcHJvbWlzZUN0b3IgPSBjb25maWdfMS5jb25maWcuUHJvbWlzZSB8fCBQcm9taXNlO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2VDdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlQ3Rvcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uZmlnXzEgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG52YXIgaG9zdFJlcG9ydEVycm9yXzEgPSByZXF1aXJlKFwiLi91dGlsL2hvc3RSZXBvcnRFcnJvclwiKTtcbmV4cG9ydHMuZW1wdHkgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChjb25maWdfMS5jb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdFJlcG9ydEVycm9yXzEuaG9zdFJlcG9ydEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbC9pc0Z1bmN0aW9uXCIpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZlclwiKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N1YnNjcmlwdGlvblwiKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9zeW1ib2wvcnhTdWJzY3JpYmVyXCIpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIGhvc3RSZXBvcnRFcnJvcl8xID0gcmVxdWlyZShcIi4vdXRpbC9ob3N0UmVwb3J0RXJyb3JcIik7XG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25Pck5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gZGVzdGluYXRpb25Pck5leHQuc3luY0Vycm9yVGhyb3dhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uT3JOZXh0LmFkZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIoX3RoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIoX3RoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXIobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgc3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZUFuZFJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcGFyZW50T3JQYXJlbnRzID0gdGhpcy5fcGFyZW50T3JQYXJlbnRzO1xuICAgICAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IF9wYXJlbnRPclBhcmVudHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZXI7XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJzY3JpYmVyID0gU3Vic2NyaWJlcjtcbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnRTdWJzY3JpYmVyLCBvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgY29udGV4dCA9IF90aGlzO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JzZXJ2ZXJPck5leHQpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dC5uZXh0O1xuICAgICAgICAgICAgZXJyb3IgPSBvYnNlcnZlck9yTmV4dC5lcnJvcjtcbiAgICAgICAgICAgIGNvbXBsZXRlID0gb2JzZXJ2ZXJPck5leHQuY29tcGxldGU7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJPck5leHQgIT09IE9ic2VydmVyXzEuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZChjb250ZXh0LnVuc3Vic2NyaWJlLmJpbmQoY29udGV4dCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LnVuc3Vic2NyaWJlID0gX3RoaXMudW5zdWJzY3JpYmUuYmluZChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBfdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgIF90aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICBfdGhpcy5fY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nIHx8ICFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fbmV4dCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICB2YXIgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyA9IGNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nIHx8ICFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0UmVwb3J0RXJyb3JfMS5ob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFJlcG9ydEVycm9yXzEuaG9zdFJlcG9ydEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdyYXBwZWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jb21wbGV0ZS5jYWxsKF90aGlzLl9jb250ZXh0KTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nIHx8ICFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIod3JhcHBlZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHdyYXBwZWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBpZiAoY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBob3N0UmVwb3J0RXJyb3JfMS5ob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JTZXRFcnJvciA9IGZ1bmN0aW9uIChwYXJlbnQsIGZuLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjYWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChjb25maWdfMS5jb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcl8xLmhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgX3BhcmVudFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5TYWZlU3Vic2NyaWJlciA9IFNhZmVTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKFwiLi91dGlsL2lzQXJyYXlcIik7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoXCIuL3V0aWwvaXNPYmplY3RcIik7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbC9pc0Z1bmN0aW9uXCIpO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JfMSA9IHJlcXVpcmUoXCIuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvclwiKTtcbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdG9yVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50T3JQYXJlbnRzID0gX2EuX3BhcmVudE9yUGFyZW50cywgX2N0b3JVbnN1YnNjcmliZSA9IF9hLl9jdG9yVW5zdWJzY3JpYmUsIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSwgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKF9wYXJlbnRPclBhcmVudHMgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIF9wYXJlbnRPclBhcmVudHMucmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRPclBhcmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBfcGFyZW50T3JQYXJlbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IF9wYXJlbnRPclBhcmVudHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHBhcmVudF8xLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgaWYgKF9jdG9yVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3Vuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvciA/IGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlLmVycm9ycykgOiBbZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KF9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZS5lcnJvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG4gICAgICAgIGlmICghdGVhcmRvd24pIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdGVhcmRvd24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdGhpcyB8fCBzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEoc3Vic2NyaXB0aW9uIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCB0ZWFyZG93biAnICsgdGVhcmRvd24gKyAnIGFkZGVkIHRvIFN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgX3BhcmVudE9yUGFyZW50cyA9IHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzO1xuICAgICAgICBpZiAoX3BhcmVudE9yUGFyZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLl9wYXJlbnRPclBhcmVudHMgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRPclBhcmVudHMgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChfcGFyZW50T3JQYXJlbnRzID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzID0gW19wYXJlbnRPclBhcmVudHMsIHRoaXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRPclBhcmVudHMuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIF9wYXJlbnRPclBhcmVudHMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtzdWJzY3JpcHRpb25dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7IHJldHVybiBlcnJzLmNvbmNhdCgoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpID8gZXJyLmVycm9ycyA6IGVycik7IH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3MgPSBmYWxzZTtcbmV4cG9ydHMuY29uZmlnID0ge1xuICAgIFByb21pc2U6IHVuZGVmaW5lZCxcbiAgICBzZXQgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdERVBSRUNBVEVEISBSeEpTIHdhcyBzZXQgdG8gdXNlIGRlcHJlY2F0ZWQgc3luY2hyb25vdXMgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IgYnkgY29kZSBhdDogXFxuJyArIGVycm9yLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSeEpTOiBCYWNrIHRvIGEgYmV0dGVyIGVycm9yIGJlaGF2aW9yLiBUaGFuayB5b3UuIDwzJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9lbmFibGVfc3VwZXJfZ3Jvc3NfbW9kZV90aGF0X3dpbGxfY2F1c2VfYmFkX3RoaW5ncztcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKFwiLi4vT2JzZXJ2YWJsZVwiKTtcbmV4cG9ydHMuRU1QVFkgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSk7XG5mdW5jdGlvbiBlbXB0eShzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVyID8gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSA6IGV4cG9ydHMuRU1QVFk7XG59XG5leHBvcnRzLmVtcHR5ID0gZW1wdHk7XG5mdW5jdGlvbiBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7IHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KTsgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4uL1N1YnNjcmliZXJcIik7XG5mdW5jdGlvbiBkZWZhdWx0SWZFbXB0eShkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHsgZGVmYXVsdFZhbHVlID0gbnVsbDsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgRGVmYXVsdElmRW1wdHlPcGVyYXRvcihkZWZhdWx0VmFsdWUpKTsgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdElmRW1wdHkgPSBkZWZhdWx0SWZFbXB0eTtcbnZhciBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgRGVmYXVsdElmRW1wdHlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRJZkVtcHR5T3BlcmF0b3I7XG59KCkpO1xudmFyIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBfdGhpcy5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRJZkVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi4vU3Vic2NyaWJlclwiKTtcbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmlsdGVyT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG52YXIgRmlsdGVyT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgRmlsdGVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaWx0ZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJPcGVyYXRvcjtcbn0oKSk7XG52YXIgRmlsdGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbHRlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIF90aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmlsdGVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoXCIuLi9TdWJzY3JpYmVyXCIpO1xuZnVuY3Rpb24gbWFwKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwT3BlcmF0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2plY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uLiBBcmUgeW91IGxvb2tpbmcgZm9yIGBtYXBUbygpYD8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5tYXAgPSBtYXA7XG52YXIgTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NYXBPcGVyYXRvciA9IE1hcE9wZXJhdG9yO1xudmFyIE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIF90aGlzLnRoaXNBcmcgPSB0aGlzQXJnIHx8IF90aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNjYW5fMSA9IHJlcXVpcmUoXCIuL3NjYW5cIik7XG52YXIgdGFrZUxhc3RfMSA9IHJlcXVpcmUoXCIuL3Rha2VMYXN0XCIpO1xudmFyIGRlZmF1bHRJZkVtcHR5XzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0SWZFbXB0eVwiKTtcbnZhciBwaXBlXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9waXBlXCIpO1xuZnVuY3Rpb24gcmVkdWNlKGFjY3VtdWxhdG9yLCBzZWVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVkdWNlT3BlcmF0b3JGdW5jdGlvbldpdGhTZWVkKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBpcGVfMS5waXBlKHNjYW5fMS5zY2FuKGFjY3VtdWxhdG9yLCBzZWVkKSwgdGFrZUxhc3RfMS50YWtlTGFzdCgxKSwgZGVmYXVsdElmRW1wdHlfMS5kZWZhdWx0SWZFbXB0eShzZWVkKSkoc291cmNlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlZHVjZU9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBwaXBlXzEucGlwZShzY2FuXzEuc2NhbihmdW5jdGlvbiAoYWNjLCB2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuIGFjY3VtdWxhdG9yKGFjYywgdmFsdWUsIGluZGV4ICsgMSk7IH0pLCB0YWtlTGFzdF8xLnRha2VMYXN0KDEpKShzb3VyY2UpO1xuICAgIH07XG59XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4uL1N1YnNjcmliZXJcIik7XG5mdW5jdGlvbiBzY2FuKGFjY3VtdWxhdG9yLCBzZWVkKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gc2Nhbk9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuc2NhbiA9IHNjYW47XG52YXIgU2Nhbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2FuT3BlcmF0b3IoYWNjdW11bGF0b3IsIHNlZWQsIGhhc1NlZWQpIHtcbiAgICAgICAgaWYgKGhhc1NlZWQgPT09IHZvaWQgMCkgeyBoYXNTZWVkID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgICAgICB0aGlzLmhhc1NlZWQgPSBoYXNTZWVkO1xuICAgIH1cbiAgICBTY2FuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTY2FuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFjY3VtdWxhdG9yLCB0aGlzLnNlZWQsIHRoaXMuaGFzU2VlZCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5PcGVyYXRvcjtcbn0oKSk7XG52YXIgU2NhblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FuU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYWNjdW11bGF0b3IsIF9zZWVkLCBoYXNTZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgICBfdGhpcy5fc2VlZCA9IF9zZWVkO1xuICAgICAgICBfdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgICAgX3RoaXMuaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUsIFwic2VlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1NlZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2VlZCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1NlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VlZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NhblN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYWNjdW11bGF0b3IodGhpcy5zZWVkLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZWQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nhbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4uL1N1YnNjcmliZXJcIik7XG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXCIpO1xudmFyIGVtcHR5XzEgPSByZXF1aXJlKFwiLi4vb2JzZXJ2YWJsZS9lbXB0eVwiKTtcbmZ1bmN0aW9uIHRha2VMYXN0KGNvdW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRha2VMYXN0T3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlfMS5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUYWtlTGFzdE9wZXJhdG9yKGNvdW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy50YWtlTGFzdCA9IHRha2VMYXN0O1xudmFyIFRha2VMYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0T3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRha2VMYXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlTGFzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VMYXN0T3BlcmF0b3I7XG59KCkpO1xudmFyIFRha2VMYXN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VMYXN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHRvdGFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBfdGhpcy5yaW5nID0gbmV3IEFycmF5KCk7XG4gICAgICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWtlTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByaW5nID0gdGhpcy5yaW5nO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50Kys7XG4gICAgICAgIGlmIChyaW5nLmxlbmd0aCA8IHRvdGFsKSB7XG4gICAgICAgICAgICByaW5nLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gY291bnQgJSB0b3RhbDtcbiAgICAgICAgICAgIHJpbmdbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRha2VMYXN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmNvdW50ID49IHRoaXMudG90YWwgPyB0aGlzLnRvdGFsIDogdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHZhciByaW5nID0gdGhpcy5yaW5nO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IChjb3VudCsrKSAlIHRvdGFsO1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmluZ1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VMYXN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VMYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZSc7IH0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yeFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gU3ltYm9sKCdyeFN1YnNjcmliZXInKVxuICAgICAgICA6ICdAQHJ4U3Vic2NyaWJlcl8nICsgTWF0aC5yYW5kb20oKTtcbn0pKCk7XG5leHBvcnRzLiQkcnhTdWJzY3JpYmVyID0gZXhwb3J0cy5yeFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yeFN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGwoKSB7XG4gICAgICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdhcmd1bWVudCBvdXQgb2YgcmFuZ2UnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICByZXR1cm4gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsO1xufSkoKTtcbmV4cG9ydHMuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvckltcGwoZXJyb3JzKSB7XG4gICAgICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVycm9ycyA/XG4gICAgICAgICAgICBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG5cIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gaSArIDEgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKTsgfSkuam9pbignXFxuICAnKSA6ICcnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgVW5zdWJzY3JpcHRpb25FcnJvckltcGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbDtcbn0pKCk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4uL1N1YnNjcmliZXJcIik7XG5mdW5jdGlvbiBjYW5SZXBvcnRFcnJvcihvYnNlcnZlcikge1xuICAgIHdoaWxlIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgX2EgPSBvYnNlcnZlciwgY2xvc2VkXzEgPSBfYS5jbG9zZWQsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb24sIGlzU3RvcHBlZCA9IF9hLmlzU3RvcHBlZDtcbiAgICAgICAgaWYgKGNsb3NlZF8xIHx8IGlzU3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0gZGVzdGluYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNhblJlcG9ydEVycm9yID0gY2FuUmVwb3J0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5SZXBvcnRFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGhvc3RSZXBvcnRFcnJvcihlcnIpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9LCAwKTtcbn1cbmV4cG9ydHMuaG9zdFJlcG9ydEVycm9yID0gaG9zdFJlcG9ydEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9zdFJlcG9ydEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xufVxuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRlbnRpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJzsgfSk7IH0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0FycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRnVuY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaWRlbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2lkZW50aXR5XCIpO1xuZnVuY3Rpb24gcGlwZSgpIHtcbiAgICB2YXIgZm5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZm5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBwaXBlRnJvbUFycmF5KGZucyk7XG59XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuZnVuY3Rpb24gcGlwZUZyb21BcnJheShmbnMpIHtcbiAgICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHlfMS5pZGVudGl0eTtcbiAgICB9XG4gICAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZuc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBmbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBmbikgeyByZXR1cm4gZm4ocHJldik7IH0sIGlucHV0KTtcbiAgICB9O1xufVxuZXhwb3J0cy5waXBlRnJvbUFycmF5ID0gcGlwZUZyb21BcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4uL1N1YnNjcmliZXJcIik7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi4vc3ltYm9sL3J4U3Vic2NyaWJlclwiKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZShcIi4uL09ic2VydmVyXCIpO1xuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihPYnNlcnZlcl8xLmVtcHR5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVyaTEsIHVyaTIsIGllTW9kZSkge1xuICAgIGlmICh1cmkxID09PSB1cmkyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciB1cmwxID0gdXJsLnBhcnNlKHVyaTEsIGZhbHNlLCB0cnVlKTtcbiAgICB2YXIgdXJsMiA9IHVybC5wYXJzZSh1cmkyLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICB2YXIgdXJsMVBvcnQgPSB1cmwxLnBvcnR8MCB8fCAodXJsMS5wcm90b2NvbCA9PT0gJ2h0dHBzJyA/IDQ0MyA6IDgwKTtcbiAgICB2YXIgdXJsMlBvcnQgPSB1cmwyLnBvcnR8MCB8fCAodXJsMi5wcm90b2NvbCA9PT0gJ2h0dHBzJyA/IDQ0MyA6IDgwKTtcblxuICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgcHJvdG86IHVybDEucHJvdG9jb2wgPT09IHVybDIucHJvdG9jb2wsXG4gICAgICAgIGhvc3RuYW1lOiB1cmwxLmhvc3RuYW1lID09PSB1cmwyLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmwxUG9ydCA9PT0gdXJsMlBvcnRcbiAgICB9O1xuXG4gICAgcmV0dXJuICgobWF0Y2gucHJvdG8gJiYgbWF0Y2guaG9zdG5hbWUpICYmIChtYXRjaC5wb3J0IHx8IGllTW9kZSkpO1xufTsiLCIvKipcbiAqIFRoaXMgZmlsZSBpcyBvbmx5IHVzZWQgZm9yIHRoZSBicm93c2VyIHZlcnNpb24gb2YgYHNhbWUtb3JpZ2luYC5cbiAqIFVzZWQgdG8gYnJpbmcgZG93biB0aGUgc2l6ZSBvZiB0aGUgYnJvd3NlciBidW5kbGUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4ID0gL14oPzooPzooPzooW146XFwvI1xcP10rOik/KD86KD86XFwvXFwvKSgoPzooKD86W146QFxcLyNcXD9dKykoPzpcXDooPzpbXjpAXFwvI1xcP10rKSk/KUApPygoW146XFwvI1xcP1xcXVxcW10rfFxcW1teXFwvXFxdQCM/XStcXF0pKD86XFw6KFswLTldKykpPykpPyk/KT8oKD86XFwvPyg/OlteXFwvXFw/I10rXFwvKykqKSg/OlteXFw/I10qKSkpPyhcXD9bXiNdKyk/KSgjLiopPy87XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlZ2V4OiByZWdleCxcbiAgICBwYXJzZTogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4LmV4ZWModXJsKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3RvY29sOiAobWF0Y2hbMV0gfHwgJycpLnRvTG93ZXJDYXNlKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgaG9zdG5hbWU6IChtYXRjaFs1XSB8fCAnJykudG9Mb3dlckNhc2UoKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3J0OiBtYXRjaFs2XSB8fCB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG59OyIsImltcG9ydCB7IEJpa2VUYWdDbGllbnQgfSBmcm9tICcuLi9jbGllbnQnO1xuaW1wb3J0IHsgSU1BR0VfRU5EUE9JTlQgfSBmcm9tICcuLi9jb21tb24vZW5kcG9pbnRzJztcbmltcG9ydCB7IEJpa2VUYWdBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVUYWcoXG4gIGNsaWVudDogQmlrZVRhZ0NsaWVudCxcbiAgaW1hZ2VIYXNoOiBzdHJpbmdcbik6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+PiB7XG4gIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke2ltYWdlSGFzaH1gO1xuICByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnREVMRVRFJyB9KSkuZGF0YSBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj47XG59XG4iLCJpbXBvcnQgeyBCaWtlVGFnQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBCaWtlVGFnQXBpUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmF2b3JpdGVJbWFnZShcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8J2Zhdm9yaXRlZCc+PiB7XG4gIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke2ltYWdlSGFzaH0vZmF2b3JpdGVgO1xuICByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnUE9TVCcgfSkpLmRhdGEgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPCdmYXZvcml0ZWQnPlxufVxuIiwiaW1wb3J0IHsgQmlrZVRhZ0NsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHsgQmlrZVRhZ0FwaVJlc3BvbnNlLCBUYWdEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhZyhcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT4+IHtcbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofWBcbiAgcmV0dXJuICgoYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwgfSkpLmRhdGEgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+XG59XG4iLCJleHBvcnQge2RlbGV0ZVRhZ30gZnJvbSAnLi9kZWxldGVUYWcnXG5leHBvcnQge2dldFRhZ30gZnJvbSAnLi9nZXRUYWcnO1xuZXhwb3J0IHt1cGRhdGVUYWd9IGZyb20gJy4vdXBkYXRlVGFnJztcbmV4cG9ydCB7dXBkYXRlVGFnSW1hZ2V9IGZyb20gJy4vdXBkYXRlVGFnSW1hZ2UnO1xuZXhwb3J0IHtxdWV1ZVRhZ0ltYWdlfSBmcm9tICcuL3F1ZXVlVGFnSW1hZ2UnO1xuZXhwb3J0IHtmYXZvcml0ZUltYWdlfSBmcm9tICcuL2Zhdm9yaXRlSW1hZ2UnOyIsImltcG9ydCB7IEJpa2VUYWdDbGllbnQgfSBmcm9tICcuLi9jbGllbnQnO1xuaW1wb3J0IHsgUGF5bG9hZCwgQmlrZVRhZ0FwaVJlc3BvbnNlLCBUYWdEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbi8vIGltcG9ydCB7IFVQTE9BRF9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcXVldWVUYWdJbWFnZShcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBwYXlsb2FkOiBzdHJpbmcgfCBzdHJpbmdbXSB8IFBheWxvYWQgfCBQYXlsb2FkW11cbik6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+W10+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHBheWxvYWQubWFwKChwOiBzdHJpbmcgfCBQYXlsb2FkKSA9PiB7XG4gICAgICAvLyBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgICAgIC8vIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KFVQTE9BRF9FTkRQT0lOVCwge1xuICAgICAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIC8vICAgYm9keTogZm9ybSxcbiAgICAgIC8vICAgcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAgICAgLy8gfSk7XG5cbiAgICAgIC8vIGNvbnN0IGlkID0gO1xuICAgICAgLy8gcmVxLm9uKCd1cGxvYWRQcm9ncmVzcycsIChwcm9ncmVzczogUHJvZ3Jlc3MpID0+IHtcbiAgICAgIC8vICAgY2xpZW50LmVtaXQoJ3VwbG9hZFByb2dyZXNzJywgeyAuLi5wcm9ncmVzcywgaWQgfSk7XG4gICAgICAvLyB9KTtcblxuICAgICAgcmV0dXJuIChwIGFzIHVua25vd24pIGFzIFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+PjtcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgLy8gY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocGF5bG9hZCk7XG4gIC8vIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KFVQTE9BRF9FTkRQT0lOVCwge1xuICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAvLyAgIGJvZHk6IGZvcm0sXG4gIC8vICAgcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAvLyB9KTtcblxuICAvLyByZXEub24oJ3VwbG9hZFByb2dyZXNzJywgKHByb2dyZXNzOiBQcm9ncmVzcykgPT4ge1xuICAvLyAgIGNsaWVudC5lbWl0KCd1cGxvYWRQcm9ncmVzcycsIHsgLi4ucHJvZ3Jlc3MsIGlkIH0pO1xuICAvLyB9KTtcblxuICByZXR1cm4gKGNsaWVudCBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT47XG59XG4iLCJpbXBvcnQgeyBCaWtlVGFnQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG4vLyBpbXBvcnQgeyBjcmVhdGVGb3JtIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7IFBheWxvYWQsIEJpa2VUYWdBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlVGFnUGF5bG9hZFxuICBleHRlbmRzIFBpY2s8UGF5bG9hZCwgJ3RpdGxlJyB8ICdkZXNjcmlwdGlvbic+IHtcbiAgc2x1Zzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRVcGRhdGVQYXlsb2FkKHA6IFVwZGF0ZVRhZ1BheWxvYWQpIHtcbiAgcmV0dXJuIHR5cGVvZiBwLnRpdGxlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcC5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVUYWcoXG4gIGNsaWVudDogQmlrZVRhZ0NsaWVudCxcbiAgcGF5bG9hZDogVXBkYXRlVGFnUGF5bG9hZFxuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAvLyAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHA6IFVwZGF0ZVRhZ1BheWxvYWQpID0+IHtcbiAgLy8gICAgIGlmICghaXNWYWxpZFVwZGF0ZVBheWxvYWQocCkpIHtcbiAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGUgcmVxdWlyZXMgYSB0aXRsZSBhbmQvb3IgZGVzY3JpcHRpb24nKTtcbiAgLy8gICAgIH1cblxuICAvLyAgICAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7cC5pbWFnZUhhc2h9YDtcbiAgLy8gICAgIGNvbnN0IGZvcm0gPSBjcmVhdGVGb3JtKHApO1xuICAvLyAgICAgcmV0dXJuIChjbGllbnQucmVxdWVzdCh1cmwsIHtcbiAgLy8gICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gIC8vICAgICAgIGJvZHk6IGZvcm0sXG4gIC8vICAgICAgIHJlc29sdmVCb2R5T25seTogdHJ1ZSxcbiAgLy8gICAgIH0pIGFzIHVua25vd24pIGFzIFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+PjtcbiAgLy8gICB9KTtcblxuICAvLyAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIC8vIH1cblxuICBpZiAoIWlzVmFsaWRVcGRhdGVQYXlsb2FkKHBheWxvYWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGUgcmVxdWlyZXMgYSB0aXRsZSBhbmQvb3IgZGVzY3JpcHRpb24nKTtcbiAgfVxuXG4gIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke3BheWxvYWQuc2x1Z31gO1xuICByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnREVMRVRFJyB9KSkuZGF0YSBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj47XG59XG4iLCJpbXBvcnQgeyBCaWtlVGFnQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG4vLyBpbXBvcnQgeyBjcmVhdGVGb3JtIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7IFBheWxvYWQsIEJpa2VUYWdBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlVGFnSW1hZ2VQYXlsb2FkXG4gIGV4dGVuZHMgUGljazxQYXlsb2FkLCAndGl0bGUnIHwgJ2Rlc2NyaXB0aW9uJz4ge1xuICBzbHVnOiBzdHJpbmc7XG59XG5cbi8vIGZ1bmN0aW9uIGlzVmFsaWRVcGRhdGVQYXlsb2FkKHA6IFVwZGF0ZVRhZ0ltYWdlUGF5bG9hZCkge1xuLy8gICByZXR1cm4gdHlwZW9mIHAudGl0bGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwLmRlc2NyaXB0aW9uID09PSAnc3RyaW5nJztcbi8vIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRhZ0ltYWdlKFxuICBjbGllbnQ6IEJpa2VUYWdDbGllbnQsXG4gIHBheWxvYWQ6IFVwZGF0ZVRhZ0ltYWdlUGF5bG9hZFxuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAvLyAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHA6IFVwZGF0ZVRhZ0ltYWdlUGF5bG9hZCkgPT4ge1xuICAvLyAgICAgaWYgKCFpc1ZhbGlkVXBkYXRlUGF5bG9hZChwKSkge1xuICAvLyAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpO1xuICAvLyAgICAgfVxuXG4gIC8vICAgICBjb25zdCB1cmwgPSBgJHtJTUFHRV9FTkRQT0lOVH0vJHtwLmltYWdlSGFzaH1gO1xuICAvLyAgICAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocCk7XG4gIC8vICAgICByZXR1cm4gKGNsaWVudC5yZXF1ZXN0KHVybCwge1xuICAvLyAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgLy8gICAgICAgYm9keTogZm9ybSxcbiAgLy8gICAgICAgcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAvLyAgICAgfSkgYXMgdW5rbm93bikgYXMgUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4+O1xuICAvLyAgIH0pO1xuXG4gIC8vICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgLy8gfVxuXG4gIC8vIGlmICghaXNWYWxpZFVwZGF0ZVBheWxvYWQocGF5bG9hZCkpIHtcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpO1xuICAvLyB9XG5cbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7cGF5bG9hZC5zbHVnfWA7XG4gIHJldHVybiAoKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsLCBtZXRob2Q6ICdERUxFVEUnIH0pKS5kYXRhIGFzIHVua25vd24pIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPjtcblxuXG4gIC8vIC8vIGNvbnN0IGZvcm0gPSBjcmVhdGVGb3JtKHBheWxvYWQpO1xuICAvLyByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh1cmwsIHtcbiAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgLy8gICBib2R5OiBmb3JtLFxuICAvLyAgIHJlc29sdmVCb2R5T25seTogdHJ1ZSxcbiAgLy8gfSkpIGFzIHVua25vd24pIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPjtcbn1cbiIsImltcG9ydCBheGlvcywgeyBBeGlvc0luc3RhbmNlLCBBeGlvc1Jlc3BvbnNlLCBBeGlvc1JlcXVlc3RDb25maWcgfSBmcm9tICdheGlvcydcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cydcbi8vIGltcG9ydCB7IGdldEF1dGhvcml6YXRpb25IZWFkZXIgfSBmcm9tICcuL2dldEF1dGhvcml6YXRpb25IZWFkZXInXG5pbXBvcnQgeyBCSUtFVEFHX0FQSV9QUkVGSVggfSBmcm9tICcuL2NvbW1vbi9lbmRwb2ludHMnXG5pbXBvcnQge1xuICBDcmVkZW50aWFscyxcbiAgVGFnRGF0YSxcbiAgQmlrZVRhZ0FwaVJlc3BvbnNlLFxuICBTYW5pdHlDcmVkZW50aWFscyxcbiAgSW1ndXJDcmVkZW50aWFscyxcbiAgQmlrZVRhZ0NyZWRlbnRpYWxzLFxufSBmcm9tICcuL2NvbW1vbi90eXBlcydcbmltcG9ydCB7IHRhZ0RhdGFGaWVsZHMgfSBmcm9tICcuL2NvbW1vbi9kYXRhJ1xuaW1wb3J0IHsgY29uc3RydWN0VGFnTnVtYmVyU2x1ZywgaXNJbWd1ckNyZWRlbnRpYWxzLCBpc1Nhbml0eUNyZWRlbnRpYWxzLCBpc0Jpa2VUYWdDcmVkZW50aWFscyB9IGZyb20gJy4vY29tbW9uL21ldGhvZHMnXG5cbmltcG9ydCAqIGFzIHNhbml0eUFwaSBmcm9tICcuL3Nhbml0eSdcbmltcG9ydCAqIGFzIGltZ3VyQXBpIGZyb20gJy4vaW1ndXInXG5pbXBvcnQgKiBhcyBiaWtldGFnQXBpIGZyb20gJy4vYmlrZXRhZydcblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgSW1ndXJDbGllbnQsIEltZ3VyQ29uZmlnIH0gZnJvbSAnLi9pbWd1ckNsaWVudCdcbmltcG9ydCBzYW5pdHlDbGllbnQsIHsgU2FuaXR5Q2xpZW50LCBDbGllbnRDb25maWcgYXMgU2FuaXR5Q29uZmlnIH0gZnJvbSAnQHNhbml0eS9jbGllbnQnXG5cbmNvbnN0IFVTRVJBR0VOVCA9ICdiaWtldGFnLWFwaSAoaHR0cHM6Ly9naXRodWIuY29tL2tlbmV1Y2tlci9iaWtldGFnLWFwaSknXG5cbmV4cG9ydCBjbGFzcyBCaWtlVGFnQ2xpZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBmZXRjaGVyOiBBeGlvc0luc3RhbmNlXG4gIHByaXZhdGUgbW9zdEF2YWlsYWJsZUFwaTogc3RyaW5nXG4gIHByaXZhdGUgaW1ndXJDbGllbnQ/OiBJbWd1ckNsaWVudFxuICBwcml2YXRlIHNhbml0eUNsaWVudD86IFNhbml0eUNsaWVudFxuICBwcml2YXRlIHNhbml0eUNvbmZpZz86IFNhbml0eUNvbmZpZyB8IHZvaWRcbiAgcHJpdmF0ZSBpbWd1ckNvbmZpZz86IEltZ3VyQ29uZmlnIHwgdm9pZFxuICBwcml2YXRlIGJpa2V0YWdDb25maWc/OiBCaWtlVGFnQ3JlZGVudGlhbHMgfCB2b2lkXG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgY3JlZGVudGlhbHM6IENyZWRlbnRpYWxzKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5tb3N0QXZhaWxhYmxlQXBpID0gXCJcIlxuICAgIHRoaXMuYmlrZXRhZ0NvbmZpZyA9IGlzQmlrZVRhZ0NyZWRlbnRpYWxzKGNyZWRlbnRpYWxzIGFzIEJpa2VUYWdDcmVkZW50aWFscykgPyBjcmVkZW50aWFscyA6IHVuZGVmaW5lZFxuICAgIHRoaXMuaW1ndXJDb25maWcgPSBpc0ltZ3VyQ3JlZGVudGlhbHMoY3JlZGVudGlhbHMpID8gKGNyZWRlbnRpYWxzIGFzIEltZ3VyQ3JlZGVudGlhbHMpIDogdW5kZWZpbmVkXG4gICAgdGhpcy5zYW5pdHlDb25maWcgPSBpc1Nhbml0eUNyZWRlbnRpYWxzKGNyZWRlbnRpYWxzIGFzIFNhbml0eUNyZWRlbnRpYWxzKSA/IChjcmVkZW50aWFscyBhcyBTYW5pdHlDcmVkZW50aWFscykgOiB1bmRlZmluZWRcblxuICAgIGlmICh0aGlzLmltZ3VyQ29uZmlnKSB7XG4gICAgICB0aGlzLmltZ3VyQ2xpZW50ID0gbmV3IEltZ3VyQ2xpZW50KHRoaXMuaW1ndXJDb25maWcpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2FuaXR5Q29uZmlnKSB7XG4gICAgICB0aGlzLnNhbml0eUNsaWVudCA9IHNhbml0eUNsaWVudCh0aGlzLnNhbml0eUNvbmZpZylcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoZXIgPSBheGlvcy5jcmVhdGUoe1xuICAgICAgYmFzZVVSTDogQklLRVRBR19BUElfUFJFRklYLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAndXNlci1hZ2VudCc6IFVTRVJBR0VOVCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIC8vIGhvb2tzOiB7XG4gICAgICAvLyAgIGJlZm9yZVJlcXVlc3Q6IFtcbiAgICAgIC8vICAgICBhc3luYyAob3B0aW9uczogYW55KSA9PiB7XG4gICAgICAvLyAgICAgICBvcHRpb25zLmhlYWRlcnNbJ2F1dGhvcml6YXRpb24nXSA9IGF3YWl0IGdldEF1dGhvcml6YXRpb25IZWFkZXIoXG4gICAgICAvLyAgICAgICAgIHRoaXNcbiAgICAgIC8vICAgICAgIClcbiAgICAgIC8vICAgICB9LFxuICAgICAgLy8gICBdLFxuICAgICAgLy8gfSxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBnZXREZWZhdWx0QVBJKG9wdGlvbnM6IGFueSk6IGFueSB7XG4gICAgY29uc3QgYXZhaWxhYmxlQVBJID0gb3B0aW9ucy5mb3JjZUFQSSA/IG9wdGlvbnMuZm9yY2VBUEkgOiB0aGlzLmdldE1vc3RBdmFpbGFibGVBUEkoKVxuICAgIGxldCBjbGllbnQ6IGFueSA9IG51bGxcbiAgICBsZXQgYXBpOiBhbnkgPSBudWxsXG5cbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnID8geyBzbHVnOiBvcHRpb25zIH0gOiBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyA/IHsgc2x1ZzogY29uc3RydWN0VGFnTnVtYmVyU2x1ZyhvcHRpb25zKSB9IDogb3B0aW9uc1xuICAgIG9wdGlvbnMuc2x1ZyA9IG9wdGlvbnMuc2x1ZyA/IG9wdGlvbnMuc2x1ZyA6IGNvbnN0cnVjdFRhZ051bWJlclNsdWcob3B0aW9ucy50YWdudW1iZXIsIG9wdGlvbnMuZ2FtZSlcbiAgICBvcHRpb25zLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzID8gb3B0aW9ucy5maWVsZHMgOiB0YWdEYXRhRmllbGRzXG5cbiAgICBzd2l0Y2ggKGF2YWlsYWJsZUFQSSkge1xuICAgICAgY2FzZSBcInNhbml0eVwiOlxuICAgICAgICBjbGllbnQgPSB0aGlzLnNhbml0eUNsaWVudFxuICAgICAgICBhcGkgPSBzYW5pdHlBcGlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJpbWd1clwiOlxuICAgICAgICBjbGllbnQgPSB0aGlzLmltZ3VyQ2xpZW50XG4gICAgICAgIGFwaSA9IGltZ3VyQXBpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBcImJpa2V0YWdcIjpcbiAgICAgICAgY2xpZW50ID0gYXBpID0gYmlrZXRhZ0FwaVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbGllbnQsIGFwaSwgb3B0aW9uc1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBnZXRNb3N0QXZhaWxhYmxlQVBJKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMubW9zdEF2YWlsYWJsZUFwaS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vc3RBdmFpbGFibGVBcGlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaWtldGFnQ29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3N0QXZhaWxhYmxlQXBpID0gXCJiaWtldGFnXCJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW1ndXJDb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vc3RBdmFpbGFibGVBcGkgPSBcImltZ3VyXCJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2FuaXR5Q29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3N0QXZhaWxhYmxlQXBpID0gXCJzYW5pdHlcIlxuICAgIH1cblxuICAgIHJldHVybiBcIlwiXG4gIH1cblxuICBnZXRDb25maWd1cmF0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzYW5pdHk6IHRoaXMuc2FuaXR5Q29uZmlnLFxuICAgICAgaW1ndXI6IHRoaXMuaW1ndXJDb25maWcsXG4gICAgICBiaWtldGFnOiB0aGlzLmJpa2V0YWdDb25maWcsXG4gICAgfVxuICB9XG5cbiAgcGxhaW5SZXF1ZXN0KFxuICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICk6IFByb21pc2U8QXhpb3NSZXNwb25zZTxhbnk+PiB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hlcihvcHRpb25zKS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmRhdGEpXG4gIH1cblxuICByZXF1ZXN0KFxuICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICk6IFByb21pc2U8QXhpb3NSZXNwb25zZTxzdHJpbmc+PiB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hlcihvcHRpb25zKVxuICB9XG5cbiAgLy8gZGVsZXRlSW1hZ2UoaW1hZ2VIYXNoOiBzdHJpbmcpOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPj4ge1xuICAvLyAgIHN3aXRjaCAodGhpcy5nZXRNb3N0QXZhaWxhYmxlQVBJKCkpIHtcbiAgLy8gICAgIGNhc2UgXCJpbWd1clwiOlxuICAvLyAgICAgICByZXR1cm4gaW1ndXIuZGVsZXRlSW1hZ2UodGhpcywgaW1hZ2VIYXNoKVxuICAvLyAgICAgYnJlYWtcbiAgLy8gICB9XG4gIC8vIH1cblxuICAvLyAvLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgZm9yIGdldHRpbmcgYW4gYWxidW1cbiAgLy8gZ2V0QXJjaGl2ZShvcHRpb25zOiBBcmNoaXZlT3B0aW9ucyk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPEFyY2hpdmVEYXRhPj4ge1xuICAvLyAgIHJldHVybiBnZXRBcmNoaXZlKHRoaXMsIG9wdGlvbnMpXG4gIC8vIH1cblxuICBnZXRUYWcob3B0czogbnVtYmVyIHwgc3RyaW5nIHwgYW55KTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT4+IHtcbiAgICBjb25zdCB7IGNsaWVudCwgb3B0aW9ucywgYXBpIH0gPSB0aGlzLmdldERlZmF1bHRBUEkob3B0cylcblxuICAgIHJldHVybiBhcGkuZ2V0VGFnKGNsaWVudCwgb3B0aW9ucylcbiAgfVxuXG4gIC8vIHVwZGF0ZUltYWdlKFxuICAvLyAgIHBheWxvYWQ6IFVwZGF0ZUltYWdlUGF5bG9hZCB8IFVwZGF0ZUltYWdlUGF5bG9hZFtdXG4gIC8vICk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgLy8gICByZXR1cm4gdXBkYXRlSW1hZ2UodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIHVwbG9hZChcbiAgLy8gICBwYXlsb2FkOiBzdHJpbmcgfCBzdHJpbmdbXSB8IFBheWxvYWQgfCBQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT5bXT4ge1xuICAvLyAgIHJldHVybiB1cGxvYWQodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIGdldEJpa2VUYWcoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHN3aXRjaCAodGhpcy5nZXRNb3N0QXZhaWxhYmxlQVBJKCkpIHtcbiAgLy8gICAgIGNhc2UgXCJpbWd1clwiOlxuICAvLyAgICAgICByZXR1cm4gZ2V0QmlrZVRhZyh0aGlzLCBwYXlsb2FkKVxuICAvLyAgICAgICBicmVha1xuICAvLyAgICAgY2FzZSBcInNhbml0eVwiOlxuICAvLyAgICAgICByZXR1cm4gXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLy8gZ2V0QmlrZVRhZ015c3RlcnlJbWFnZShcbiAgLy8gICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuICAvLyApOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vICAgcmV0dXJuIGdldEJpa2VUYWdNeXN0ZXJ5SW1hZ2UodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIGdldEJpa2VUYWdGb3VuZEltYWdlKFxuICAvLyAgIHBheWxvYWQ6IFVwZGF0ZUltYWdlUGF5bG9hZCB8IFVwZGF0ZUltYWdlUGF5bG9hZFtdXG4gIC8vICk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgLy8gICByZXR1cm4gZ2V0QmlrZVRhZ0ZvdW5kSW1hZ2UodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIHF1ZXVlQmlrZVRhZ0ZvdW5kSW1hZ2UoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBxdWV1ZUJpa2VUYWdGb3VuZEltYWdlKHRoaXMsIHBheWxvYWQpXG4gIC8vIH1cblxuICAvLyBxdWV1ZUJpa2VUYWdNeXN0ZXJ5SW1hZ2UoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBxdWV1ZUJpa2VUYWdNeXN0ZXJ5SW1hZ2UodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIGdldFF1ZXVlZEltYWdlcyhcbiAgLy8gICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuICAvLyApOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vICAgcmV0dXJuIGdldFF1ZXVlZEltYWdlcyh0aGlzLCBwYXlsb2FkKVxuICAvLyB9XG5cbiAgLy8gZ2V0UXVldWUoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBnZXRRdWV1ZSh0aGlzLCBwYXlsb2FkKVxuICAvLyB9XG5cbiAgLy8gY29tcGxldGVCaWtlVGFnUm91bmQoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBjb21wbGV0ZUJpa2VUYWdSb3VuZCh0aGlzLCBwYXlsb2FkKVxuICAvLyB9XG5cbiAgLy8gZ2V0QmlrZVRhZ1JvdW5kKFxuICAvLyAgIHBheWxvYWQ6IFVwZGF0ZUltYWdlUGF5bG9hZCB8IFVwZGF0ZUltYWdlUGF5bG9hZFtdXG4gIC8vICk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgLy8gICByZXR1cm4gZ2V0QmlrZVRhZ1JvdW5kKHRoaXMsIHBheWxvYWQpXG4gIC8vIH1cblxuICBjb250ZW50KG9wdGlvbnM6IGFueSA9IHt9KTogU2FuaXR5Q2xpZW50IHtcbiAgICBpZiAoaXNTYW5pdHlDcmVkZW50aWFscyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHNhbml0eUNsaWVudChvcHRpb25zKVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBhcmUgaW52YWxpZCBmb3IgY3JlYXRpbmcgYSBzYW5pdHkgY2xpZW50JylcbiAgfVxuXG4gIGltYWdlcyhvcHRpb25zOiBhbnkgPSB7fSk6IEltZ3VyQ2xpZW50IHtcbiAgICBpZiAoaXNJbWd1ckNyZWRlbnRpYWxzKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IEltZ3VyQ2xpZW50KG9wdGlvbnMpXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIGFyZSBpbnZhbGlkIGZvciBjcmVhdGluZyBhbiBpbWd1ciBjbGllbnQnKVxuICB9XG5cbiAgZGF0YSgpOiBCaWtlVGFnQ2xpZW50IHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG59IiwiXG5cbmV4cG9ydCBjb25zdCB0YWdEYXRhRmllbGRzID0gW1xuICAgIFwic2x1Z1wiLFxuICAgIFwidGFnbnVtYmVyXCIsXG4gICAgXCJteXN0ZXJ5SW1hZ2VcIixcbiAgICBcIm15c3RlcnlJbWFnZVVybFwiLFxuICAgIFwiZ2FtZVwiLFxuICAgIFwicGxheWVyXCIsXG4gICAgXCJoaW50XCIsXG4gICAgXCJkaXNjdXNzaW9uVXJsXCIsXG4gICAgXCJmb3VuZExvY2F0aW9uXCIsXG4gICAgXCJncHNcIixcbiAgICBcImZvdW5kSW1hZ2VcIixcbiAgICBcImZvdW5kSW1hZ2VVcmxcIixcbiAgXVxuICBcbiAgZXhwb3J0IGNvbnN0IHRhZ0RhdGFSZWZlcmVuY2VGaWVsZHMgPSBbXG4gICAgXCJnYW1lXCIsXG4gICAgXCJwbGF5ZXJcIlxuICBdIiwiZXhwb3J0IGNvbnN0IEJJS0VUQUdfQVBJX1BSRUZJWCA9ICdodHRwczovL2FwaS5iaWtldGFnLm9yZyc7XG5cbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTiA9ICcyJztcblxuZXhwb3J0IGNvbnN0IEFVVEhPUklaRV9FTkRQT0lOVCA9ICdvYXV0aDIvYXV0aG9yaXplJztcblxuZXhwb3J0IGNvbnN0IElNQUdFX0VORFBPSU5UID0gYCR7QVBJX1ZFUlNJT059L2ltYWdlYDtcblxuZXhwb3J0IGNvbnN0IFRBR19FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS90YWdgO1xuXG5leHBvcnQgY29uc3QgVVBMT0FEX0VORFBPSU5UID0gYCR7QVBJX1ZFUlNJT059L3VwbG9hZGA7XG5cbmV4cG9ydCBjb25zdCBBTEJVTV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9hcmNoaXZlYDtcblxuZXhwb3J0IGNvbnN0IENPTkZJR19FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9jb25maWdgO1xuIiwiaW1wb3J0IHtcbiAgQWNjZXNzVG9rZW4sXG4gIENsaWVudEtleSxcbiAgU2FuaXR5QWNjZXNzVG9rZW4sXG4gIEltZ3VyQWNjZXNzVG9rZW4sXG4gIEltZ3VyQ2xpZW50SWQsXG4gIEltZ3VyQ3JlZGVudGlhbHMsXG4gIFNhbml0eUNyZWRlbnRpYWxzLFxuICBTYW5pdHlDbGllbnRJZCxcbiAgQmlrZVRhZ0NyZWRlbnRpYWxzLFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgdGFnRGF0YVJlZmVyZW5jZUZpZWxkcyB9IGZyb20gJy4vZGF0YSdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmlrZVRhZ0FjY2Vzc1Rva2VuKGFyZzogdW5rbm93bik6IGFyZyBpcyBBY2Nlc3NUb2tlbiB7XG4gIHJldHVybiAoYXJnIGFzIEFjY2Vzc1Rva2VuKS5jbGllbnRUb2tlbiAhPT0gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jpa2VUYWdDbGllbnRLZXkoYXJnOiB1bmtub3duKTogYXJnIGlzIENsaWVudEtleSB7XG4gIHJldHVybiAoYXJnIGFzIENsaWVudEtleSkuY2xpZW50S2V5ICE9PSB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FuaXR5QWNjZXNzVG9rZW4oYXJnOiB1bmtub3duKTogYXJnIGlzIFNhbml0eUFjY2Vzc1Rva2VuIHtcbiAgcmV0dXJuIChhcmcgYXMgU2FuaXR5QWNjZXNzVG9rZW4pLmFjY2Vzc1Rva2VuICE9PSB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FuaXR5Q2xpZW50SWQoYXJnOiB1bmtub3duKTogYXJnIGlzIFNhbml0eUNsaWVudElkIHtcbiAgcmV0dXJuIChhcmcgYXMgU2FuaXR5Q2xpZW50SWQpLnByb2plY3RJZCAhPT0gdW5kZWZpbmVkXG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBpc1Nhbml0eUxvZ2luKGFyZzogdW5rbm93bik6IGFyZyBpcyBTYW5pdHlMb2dpbiB7XG4vLyAgIHJldHVybiAoXG4vLyAgICAgKGFyZyBhcyBTYW5pdHlMb2dpbikucHJvamVjdElkICE9PSB1bmRlZmluZWQgJiZcbi8vICAgICAoYXJnIGFzIFNhbml0eUxvZ2luKS51c2VybmFtZSAhPT0gdW5kZWZpbmVkICYmXG4vLyAgICAgKGFyZyBhcyBTYW5pdHlMb2dpbikucGFzc3dvcmQgIT09IHVuZGVmaW5lZFxuLy8gICApXG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ltZ3VyQWNjZXNzVG9rZW4oYXJnOiB1bmtub3duKTogYXJnIGlzIEltZ3VyQWNjZXNzVG9rZW4ge1xuICByZXR1cm4gKGFyZyBhcyBJbWd1ckFjY2Vzc1Rva2VuKS5hY2Nlc3NUb2tlbiAhPT0gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ltZ3VyQ2xpZW50SWQoYXJnOiB1bmtub3duKTogYXJnIGlzIEltZ3VyQ2xpZW50SWQge1xuICByZXR1cm4gKGFyZyBhcyBJbWd1ckNsaWVudElkKS5jbGllbnRJZCAhPT0gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RUYWdEYXRhT2JqZWN0KGRhdGE6IGFueSwgZmllbGRzID0gW10pOiBhbnkge1xuICBjb25zdCB0YWdEYXRhID0gZmllbGRzLmxlbmd0aFxuICAgID8gZmllbGRzLnJlZHVjZSgobzogYW55LCBmOiBhbnkpID0+IHtcbiAgICAgICAgb1tmXSA9IGRhdGFbZl1cbiAgICAgICAgcmV0dXJuIG9cbiAgICAgIH0sIHt9KVxuICAgIDogZGF0YVxuXG4gIHRhZ0RhdGFSZWZlcmVuY2VGaWVsZHMuZm9yRWFjaCgoZikgPT4ge1xuICAgIGlmICh0eXBlb2YgdGFnRGF0YVtmXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRhZ0RhdGFbZl0gPSB0YWdEYXRhW2ZdLm5hbWVcbiAgICB9XG4gIH0pXG5cbiAgLy8gdGFnRGF0YS5zbHVnID0gdGFnRGF0YS5zbHVnPy5jdXJyZW50ID8gdGFnRGF0YS5zbHVnLmN1cnJlbnQgOiB1bmRlZmluZWQgLy8gVW5kZWZpbmVkIHdvdWxkIGJlIGEgcHJvYmxlbVxuICB0YWdEYXRhLnNsdWcgPSB0YWdEYXRhLnNsdWcuY3VycmVudFxuXG4gIHJldHVybiB0YWdEYXRhXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RUYWdOdW1iZXJTbHVnKG51bWJlcjogbnVtYmVyLCBnYW1lID0gJ3BvcnRsYW5kJyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtnYW1lfS10YWctJHtudW1iZXJ9YCBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW1ndXJDcmVkZW50aWFscyhjcmVkZW50aWFsczogSW1ndXJDcmVkZW50aWFscyk6IGJvb2xlYW4ge1xuICByZXR1cm4gISEoY3JlZGVudGlhbHMuY2xpZW50SWQgICE9PSB1bmRlZmluZWQgfHwgY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0ICE9PSB1bmRlZmluZWQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Nhbml0eUNyZWRlbnRpYWxzKGNyZWRlbnRpYWxzOiBTYW5pdHlDcmVkZW50aWFscyk6IGJvb2xlYW4ge1xuICByZXR1cm4gISEoY3JlZGVudGlhbHMucHJvamVjdElkICE9PSB1bmRlZmluZWQgJiYgY3JlZGVudGlhbHMuYWNjZXNzVG9rZW4gIT09IHVuZGVmaW5lZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmlrZVRhZ0NyZWRlbnRpYWxzKGNyZWRlbnRpYWxzOiBCaWtlVGFnQ3JlZGVudGlhbHMpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKGNyZWRlbnRpYWxzLmNsaWVudFRva2VuICE9PSB1bmRlZmluZWQgJiYgKGNyZWRlbnRpYWxzIGFzIENsaWVudEtleSkuY2xpZW50S2V5ICE9PSB1bmRlZmluZWQpXG59IiwiaW1wb3J0IHsgQmlrZVRhZ0NsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHsgQmlrZVRhZ0FwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRhZyhcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4+IHtcbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofWA7XG4gIHJldHVybiAoKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsLCBtZXRob2Q6ICdERUxFVEUnIH0pKS5kYXRhIGFzIHVua25vd24pIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPjtcblxuICAvLyByZXR1cm4gKGF3YWl0IGNsaWVudFxuICAvLyAgIC5yZXF1ZXN0KHVybCwgeyBtZXRob2Q6ICdERUxFVEUnIH0pXG4gIC8vICAgLmpzb24oKSkgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+O1xufVxuIiwiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuL2ltZ3VyQ2xpZW50JztcbmltcG9ydCB7IEJpa2VUYWdBcGlSZXNwb25zZSwgVGFnRGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUYWcoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIG9wdGlvbnM6IGFueSxcbik6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+PiB7XG4gIC8vLyBUT0RPOiBHZXQgdGhlIHRhZyBpbWFnZSBoYXNoIGZvciBSZWRkaXQgZnJvbSB0aGUgdGFnbnVtYmVyIHByb3ZpZGVkXG4gIC8vLyBUT0RPOiBHZXQgdGhlIGltYWdlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHRhZ251bWJlclxuICAvLy8gVE9ETzogSW1wbGVtZW50IGRhdGEgdHJhbnNsYXRpb24gZm9yIEltZ3VyIGltYWdlIHRvIFRhZ0RhdGFcbiAgLy8vIFRPRE86IFdyYXAgdGhlIHJlc3BvbnNlIGluIGEgQmlrZVRhZ0FwaVJlc3BvbnNlXG4gIFxuICByZXR1cm4gYXdhaXQgKGNsaWVudC5nZXRJbWFnZShvcHRpb25zLnNsdWcpIGFzIGFueSkgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+XG59XG4iLCJleHBvcnQge2RlbGV0ZVRhZ30gZnJvbSAnLi9kZWxldGVUYWcnXG5leHBvcnQge2dldFRhZ30gZnJvbSAnLi9nZXRUYWcnO1xuZXhwb3J0IHt1cGRhdGVUYWd9IGZyb20gJy4vdXBkYXRlVGFnJztcbmV4cG9ydCB7dXBsb2FkVGFnSW1hZ2V9IGZyb20gJy4vdXBsb2FkVGFnSW1hZ2UnOyIsIlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuL2ltZ3VyQ2xpZW50Jztcbi8vIGltcG9ydCB7IGNyZWF0ZUZvcm0gfSBmcm9tICcuLi9jb21tb24vdXRpbHMnO1xuaW1wb3J0IHsgUGF5bG9hZCwgQmlrZVRhZ0FwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVUYWdQYXlsb2FkXG4gIGV4dGVuZHMgUGljazxQYXlsb2FkLCAndGl0bGUnIHwgJ2Rlc2NyaXB0aW9uJz4ge1xuICBpbWFnZUhhc2g6IHN0cmluZztcbn1cblxuLy8gZnVuY3Rpb24gaXNWYWxpZFVwZGF0ZVBheWxvYWQocDogVXBkYXRlVGFnUGF5bG9hZCkge1xuLy8gICByZXR1cm4gdHlwZW9mIHAudGl0bGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwLmRlc2NyaXB0aW9uID09PSAnc3RyaW5nJztcbi8vIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRhZyhcbiAgY2xpZW50OiBJbWd1ckNsaWVudCxcbiAgcGF5bG9hZDogVXBkYXRlVGFnUGF5bG9hZCB8IFVwZGF0ZVRhZ1BheWxvYWRbXVxuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAvLyAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHA6IFVwZGF0ZVRhZ1BheWxvYWQpID0+IHtcbiAgLy8gICAgIGlmICghaXNWYWxpZFVwZGF0ZVBheWxvYWQocCkpIHtcbiAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGUgcmVxdWlyZXMgYSB0aXRsZSBhbmQvb3IgZGVzY3JpcHRpb24nKTtcbiAgLy8gICAgIH1cblxuICAvLyAgICAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocCk7XG4gIC8vICAgICByZXR1cm4gKGNsaWVudC5yZXF1ZXN0KCd1cmwnLCB7XG4gIC8vICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAvLyAgICAgICBib2R5OiBmb3JtLFxuICAvLyAgICAgICByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gIC8vICAgICB9KSBhcyB1bmtub3duKSBhcyBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPj47XG4gIC8vICAgfSk7XG5cbiAgLy8gICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAvLyB9XG5cbiAgLy8gaWYgKCFpc1ZhbGlkVXBkYXRlUGF5bG9hZChwYXlsb2FkKSkge1xuICAvLyAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIHJlcXVpcmVzIGEgdGl0bGUgYW5kL29yIGRlc2NyaXB0aW9uJyk7XG4gIC8vIH1cblxuICAvLyBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwYXlsb2FkKTtcbiAgLy8gcmV0dXJuICgoYXdhaXQgY2xpZW50LnJlcXVlc3QoJ3VybCcsIHtcbiAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgLy8gICBib2R5OiBmb3JtLFxuICAvLyAgIHJlc29sdmVCb2R5T25seTogdHJ1ZSxcbiAgLy8gfSkpIGFzIHVua25vd24pIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPjtcbiAgcmV0dXJuICgoYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmw6IHBheWxvYWQsIG1ldGhvZDogJ1BPU1QnIH0pKS5kYXRhIGFzIHVua25vd24pIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPjtcblxufVxuIiwiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuL2ltZ3VyQ2xpZW50JztcbmltcG9ydCB7IFBheWxvYWQsIEJpa2VUYWdBcGlSZXNwb25zZSwgVGFnRGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG4vLyBpbXBvcnQgeyBQcm9ncmVzcyB9IGZyb20gJ2F4aW9zJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFRhZ0ltYWdlKFxuICAvLyBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBwYXlsb2FkOiBzdHJpbmcgfCBzdHJpbmdbXSB8IFBheWxvYWQgfCBQYXlsb2FkW11cbik6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+W10+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHBheWxvYWQubWFwKChwOiBzdHJpbmcgfCBQYXlsb2FkKSA9PiB7XG4gICAgICAvLyBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgICAgIC8vIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KCdVUExPQURfRU5EUE9JTlQnLCB7XG4gICAgICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgLy8gICBib2R5OiBmb3JtLFxuICAgICAgLy8gICByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gICAgICAvLyB9KTtcblxuICAgICAgY29uc3QgaWQgPSBcImFcIiArIHBcbiAgICAgIC8vIHJlcS5vbigndXBsb2FkUHJvZ3Jlc3MnLCAocHJvZ3Jlc3M6IFByb2dyZXNzKSA9PiB7XG4gICAgICAvLyAgIGNsaWVudC5lbWl0KCd1cGxvYWRQcm9ncmVzcycsIHsgLi4ucHJvZ3Jlc3MsIGlkIH0pO1xuICAgICAgLy8gfSk7XG5cbiAgICAgIHJldHVybiAoaWQgYXMgdW5rbm93bikgYXMgUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT4+O1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICAvLyBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwYXlsb2FkKTtcbiAgLy8gY29uc3QgcmVxID0gY2xpZW50LnJlcXVlc3QoJ1VQTE9BRF9FTkRQT0lOVCcsIHtcbiAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgLy8gICBib2R5OiBmb3JtLFxuICAvLyAgIHJlc29sdmVCb2R5T25seTogdHJ1ZSxcbiAgLy8gfSk7XG5cbiAgY29uc3QgaWQgPSBcIkFkc1wiXG4gIC8vIHJlcS5vbigndXBsb2FkUHJvZ3Jlc3MnLCAocHJvZ3Jlc3M6IFByb2dyZXNzKSA9PiB7XG4gIC8vICAgY2xpZW50LmVtaXQoJ3VwbG9hZFByb2dyZXNzJywgeyAuLi5wcm9ncmVzcywgaWQgfSk7XG4gIC8vIH0pO1xuXG4gIHJldHVybiAoaWQgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+O1xufVxuIiwiaW1wb3J0IHsgU2FuaXR5Q2xpZW50IH0gZnJvbSAnQHNhbml0eS9jbGllbnQnO1xuaW1wb3J0IHsgQmlrZVRhZ0FwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRhZyhcbiAgY2xpZW50OiBTYW5pdHlDbGllbnQsXG4gIC8vIHNsdWc/OiBzdHJpbmcsXG4gIC8vIHRhZ251bWJlcj86IG51bWJlcixcbik6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+PiB7XG4gIHJldHVybiAoe2NsaWVudH0gYXMgYW55KSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj47XG59XG4iLCJpbXBvcnQgeyBTYW5pdHlDbGllbnQgfSBmcm9tICdAc2FuaXR5L2NsaWVudCdcbmltcG9ydCB7IEJpa2VUYWdBcGlSZXNwb25zZSwgVGFnRGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcydcbmltcG9ydCB7IGNvbnN0cnVjdFRhZ0RhdGFPYmplY3QgfSBmcm9tICcuLi9jb21tb24vbWV0aG9kcydcbmltcG9ydCB7IHRhZ0RhdGFSZWZlcmVuY2VGaWVsZHMgfSBmcm9tICcuLi9jb21tb24vZGF0YSdcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhZyhcbiAgY2xpZW50OiBTYW5pdHlDbGllbnQsXG4gIG9wdGlvbnM6IGFueVxuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT4+IHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBvcHRpb25zJylcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5zbHVnLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gc2x1ZycpXG4gIH1cblxuICBjb25zdCBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcy5yZWR1Y2UoKG86IGFueSwgZjogYW55KSA9PiB7XG4gICAgbyArPSBgJHtmfSR7dGFnRGF0YVJlZmVyZW5jZUZpZWxkcy5pbmRleE9mKGYpICE9IC0xID8gJy0+e25hbWV9JyA6ICcnfSxgXG4gICAgcmV0dXJuIG9cbiAgfSwgJycpLnNsaWNlKDAsIC0xKVxuXG4gIGNvbnN0IHF1ZXJ5ID0gYCpbX3R5cGUgPT0gXCJ0YWdcIiAmJiBzbHVnLmN1cnJlbnQgPT0gXCIke29wdGlvbnMuc2x1Z31cIl1bMF17JHtmaWVsZHN9fWBcblxuICBjb25zdCBwYXJhbXMgPSB7fVxuXG4gIHJldHVybiBjbGllbnQuZmV0Y2gocXVlcnksIHBhcmFtcykudGhlbigodGFnKSA9PiB7XG4gICAgLy8gY29uc3RydWN0IHRhZ0RhdGEgb2JqZWN0IGZyb20gdGFnXG4gICAgY29uc3QgdGFnRGF0YSA9IGNvbnN0cnVjdFRhZ0RhdGFPYmplY3QodGFnLCBvcHRpb25zLmZpZWxkcylcblxuICAgIC8vIHdyYXAgdGFnIGluIEJpa2VUYWdBcGlSZXNwb25zZVxuICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgZGF0YTogdGFnRGF0YSxcbiAgICAgIHN0YXR1czogMSxcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBzb3VyY2U6ICdzYW5pdHknLFxuICAgIH1cblxuICAgIC8vIHJldHVybiBCaWtlVGFnQXBpUmVzcG9uc2VcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+XG4gIH0pXG59XG4iLCJleHBvcnQge2RlbGV0ZVRhZ30gZnJvbSAnLi9kZWxldGVUYWcnXG5leHBvcnQge2dldFRhZ30gZnJvbSAnLi9nZXRUYWcnO1xuZXhwb3J0IHt1cGRhdGVUYWd9IGZyb20gJy4vdXBkYXRlVGFnJztcbmV4cG9ydCB7dXBsb2FkVGFnSW1hZ2V9IGZyb20gJy4vdXBsb2FkVGFnSW1hZ2UnOyIsImltcG9ydCB7IFNhbml0eUNsaWVudCB9IGZyb20gJ0BzYW5pdHkvY2xpZW50JztcbmltcG9ydCB7IFBheWxvYWQsIEJpa2VUYWdBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlVGFnUGF5bG9hZFxuICBleHRlbmRzIFBpY2s8UGF5bG9hZCwgJ3RpdGxlJyB8ICdkZXNjcmlwdGlvbic+IHtcbiAgc2x1Zzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVGFnKFxuICBjbGllbnQ6IFNhbml0eUNsaWVudCxcbiAgLy8gcGF5bG9hZDogVXBkYXRlVGFnUGF5bG9hZCB8IFVwZGF0ZVRhZ1BheWxvYWRbXVxuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICByZXR1cm4gKHtjbGllbnR9IGFzIGFueSkgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+O1xufVxuIiwiaW1wb3J0IHsgU2FuaXR5Q2xpZW50IH0gZnJvbSAnQHNhbml0eS9jbGllbnQnO1xuaW1wb3J0IHsgUGF5bG9hZCwgQmlrZVRhZ0FwaVJlc3BvbnNlLCBUYWdEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFRhZ0ltYWdlKFxuICBjbGllbnQ6IFNhbml0eUNsaWVudCxcbiAgcGF5bG9hZDogc3RyaW5nIHwgc3RyaW5nW10gfCBQYXlsb2FkIHwgUGF5bG9hZFtdXG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxUYWdEYXRhPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxUYWdEYXRhPltdPiB7XG4gIGNvbnN0IHJlcSA9IG51bGxcblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHA6IHN0cmluZyB8IFBheWxvYWQpID0+IHtcblxuICAgICAgcmV0dXJuIChwIGFzIHVua25vd24pIGFzIFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+PjtcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgcmV0dXJuICgoYXdhaXQge2NsaWVudCwgcmVxfSBhcyBhbnkpIGFzIHVua25vd24pIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxUYWdEYXRhPjtcbn1cbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NyZWF0ZUJpbmRpbmcobywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6W1xcXFwvXSsvXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFtcXFxcL117MSx9KT8oW1xcU1xcc10qKS9pXG4gICwgd2hpdGVzcGFjZSA9ICdbXFxcXHgwOVxcXFx4MEFcXFxceDBCXFxcXHgwQ1xcXFx4MERcXFxceDIwXFxcXHhBMFxcXFx1MTY4MFxcXFx1MTgwRVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwQVxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMFxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1RkVGRl0nXG4gICwgbGVmdCA9IG5ldyBSZWdFeHAoJ14nKyB3aGl0ZXNwYWNlICsnKycpO1xuXG4vKipcbiAqIFRyaW0gYSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gdHJpbS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiAoc3RyID8gc3RyIDogJycpLnRvU3RyaW5nKCkucmVwbGFjZShsZWZ0LCAnJyk7XG59XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcblxuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcylcbiAgICAsIHByb3RvY29sID0gbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJydcbiAgICAsIHNsYXNoZXMgPSAhIShtYXRjaFsyXSAmJiBtYXRjaFsyXS5sZW5ndGggPj0gMilcbiAgICAsIHJlc3QgPSAgbWF0Y2hbMl0gJiYgbWF0Y2hbMl0ubGVuZ3RoID09PSAxID8gJy8nICsgbWF0Y2hbM10gOiBtYXRjaFszXTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBzbGFzaGVzOiBzbGFzaGVzLFxuICAgIHJlc3Q6IHJlc3RcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBEZWZhdWx0IHRvIGEgLyBmb3IgcGF0aG5hbWUgaWYgbm9uZSBleGlzdHMuIFRoaXMgbm9ybWFsaXplcyB0aGUgVVJMXG4gIC8vIHRvIGFsd2F5cyBoYXZlIGEgL1xuICAvL1xuICBpZiAodXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nICYmIHVybC5ob3N0bmFtZSkge1xuICAgIHVybC5wYXRobmFtZSA9ICcvJyArIHVybC5wYXRobmFtZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdGlmICh0eXBlb2YgZ2xvYmFsW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR2YXIgYXJyID0gbmV3IGdsb2JhbFt0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEV2YWxFcnJvcigndGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0ICcgKyB0eXBlZEFycmF5ICsgJyBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLicpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIjsoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuICAvL0NvbW1vbkpTMiBDb21tZW50XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcbiAgLy9BTUQgQ29tbWVudFxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgZmFjdG9yeSlcbiAgLy9Db21tb25KUyBDb21tZW50XG4gIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JykgZXhwb3J0c1snaW1ndXInXSA9IGZhY3RvcnkoKVxuICAvL1Jvb3QgQ29tbWVudFxuICBlbHNlIHJvb3RbJ2ltZ3VyJ10gPSBmYWN0b3J5KClcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAvKioqKioqLyAoKCkgPT4ge1xuICAgIC8vIHdlYnBhY2tCb290c3RyYXBcbiAgICAvKioqKioqLyB2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9IHtcbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9hcnJheS1maWx0ZXIvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9hcnJheS1maWx0ZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQXJyYXkjZmlsdGVyLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdD19IHNlbGZcbiAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICAgKiBAdGhyb3cgVHlwZUVycm9yXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIsIGZuLCBzZWxmKSB7XG4gICAgICAgICAgICBpZiAoYXJyLmZpbHRlcikgcmV0dXJuIGFyci5maWx0ZXIoZm4sIHNlbGYpXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBhcnIgfHwgbnVsbCA9PT0gYXJyKSB0aHJvdyBuZXcgVHlwZUVycm9yKClcbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IFR5cGVFcnJvcigpXG4gICAgICAgICAgICB2YXIgcmV0ID0gW11cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwoYXJyLCBpKSkgY29udGludWVcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IGFycltpXVxuICAgICAgICAgICAgICBpZiAoZm4uY2FsbChzZWxmLCB2YWwsIGksIGFycikpIHJldC5wdXNoKHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2Fzc2VydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBwcm9jZXNzL2Jyb3dzZXIgKi8gJy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgY29uc29sZS1icm93c2VyaWZ5ICovICcuL25vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIC8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8yYTUxYWU0MjRhNTEzZWM5YTZhYTM0NjZiYWEwY2MxZDU1ZGQ0ZjNiXG4gICAgICAgICAgLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuICAgICAgICAgIC8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICAgICAgICAvLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbiAgICAgICAgICAvLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICAgICAgICAgIC8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuICAgICAgICAgIC8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICAgICAgLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gICAgICAgICAgLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAgICAgIC8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgICAgICAgIC8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICAgICAgIC8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gICAgICAgICAgLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuICAgICAgICAgIC8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAgICAgICAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXG4gICAgICAgICAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgID8gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIG9ialxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3R5cGVvZihvYmopXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9lcnJvcnMgKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3JlcXVpcmUkY29kZXMgPSBfcmVxdWlyZS5jb2RlcyxcbiAgICAgICAgICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgICAgICAgICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICAgICAgICAgIEVSUl9JTlZBTElEX0FSR19WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19WQUxVRSxcbiAgICAgICAgICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICAgICAgICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTXG5cbiAgICAgICAgICB2YXIgQXNzZXJ0aW9uRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvciAqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISB1dGlsLyAqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdFxuXG4gICAgICAgICAgdmFyIF9yZXF1aXJlJHR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIHV0aWwvICovICcuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMnXG4gICAgICAgICAgICApLnR5cGVzLFxuICAgICAgICAgICAgaXNQcm9taXNlID0gX3JlcXVpcmUkdHlwZXMuaXNQcm9taXNlLFxuICAgICAgICAgICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cFxuXG4gICAgICAgICAgdmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ25cbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnblxuICAgICAgICAgICAgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgIC8qISBlczYtb2JqZWN0LWFzc2lnbiAqLyAnLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanMnXG4gICAgICAgICAgICAgICkuYXNzaWduXG4gICAgICAgICAgdmFyIG9iamVjdElzID0gT2JqZWN0LmlzXG4gICAgICAgICAgICA/IE9iamVjdC5pc1xuICAgICAgICAgICAgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgIC8qISBvYmplY3QtaXMgKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcydcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgIHZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpXG4gICAgICAgICAgdmFyIGlzRGVlcEVxdWFsXG4gICAgICAgICAgdmFyIGlzRGVlcFN0cmljdEVxdWFsXG4gICAgICAgICAgdmFyIHBhcnNlRXhwcmVzc2lvbkF0XG4gICAgICAgICAgdmFyIGZpbmROb2RlQXJvdW5kXG4gICAgICAgICAgdmFyIGRlY29kZXJcblxuICAgICAgICAgIGZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgICAgICAgICAgIHZhciBjb21wYXJpc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucyAqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMnXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlzRGVlcEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBFcXVhbFxuICAgICAgICAgICAgaXNEZWVwU3RyaWN0RXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcFN0cmljdEVxdWFsXG4gICAgICAgICAgfSAvLyBFc2NhcGUgY29udHJvbCBjaGFyYWN0ZXJzIGJ1dCBub3QgXFxuIGFuZCBcXHQgdG8ga2VlcCB0aGUgbGluZSBicmVha3MgYW5kXG4gICAgICAgICAgLy8gaW5kZW50YXRpb24gaW50YWN0LlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cbiAgICAgICAgICB2YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZ1xuICAgICAgICAgIHZhciBtZXRhID0gW1xuICAgICAgICAgICAgJ1xcXFx1MDAwMCcsXG4gICAgICAgICAgICAnXFxcXHUwMDAxJyxcbiAgICAgICAgICAgICdcXFxcdTAwMDInLFxuICAgICAgICAgICAgJ1xcXFx1MDAwMycsXG4gICAgICAgICAgICAnXFxcXHUwMDA0JyxcbiAgICAgICAgICAgICdcXFxcdTAwMDUnLFxuICAgICAgICAgICAgJ1xcXFx1MDAwNicsXG4gICAgICAgICAgICAnXFxcXHUwMDA3JyxcbiAgICAgICAgICAgICdcXFxcYicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ1xcXFx1MDAwYicsXG4gICAgICAgICAgICAnXFxcXGYnLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnXFxcXHUwMDBlJyxcbiAgICAgICAgICAgICdcXFxcdTAwMGYnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxMCcsXG4gICAgICAgICAgICAnXFxcXHUwMDExJyxcbiAgICAgICAgICAgICdcXFxcdTAwMTInLFxuICAgICAgICAgICAgJ1xcXFx1MDAxMycsXG4gICAgICAgICAgICAnXFxcXHUwMDE0JyxcbiAgICAgICAgICAgICdcXFxcdTAwMTUnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxNicsXG4gICAgICAgICAgICAnXFxcXHUwMDE3JyxcbiAgICAgICAgICAgICdcXFxcdTAwMTgnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxOScsXG4gICAgICAgICAgICAnXFxcXHUwMDFhJyxcbiAgICAgICAgICAgICdcXFxcdTAwMWInLFxuICAgICAgICAgICAgJ1xcXFx1MDAxYycsXG4gICAgICAgICAgICAnXFxcXHUwMDFkJyxcbiAgICAgICAgICAgICdcXFxcdTAwMWUnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxZicsXG4gICAgICAgICAgXVxuXG4gICAgICAgICAgdmFyIGVzY2FwZUZuID0gZnVuY3Rpb24gZXNjYXBlRm4oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2FybmVkID0gZmFsc2UgLy8gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbiAgICAgICAgICAvLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbiAgICAgICAgICAvLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxuICAgICAgICAgIHZhciBhc3NlcnQgPSAobW9kdWxlLmV4cG9ydHMgPSBvaylcbiAgICAgICAgICB2YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge30gLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcbiAgICAgICAgICAvLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuICAgICAgICAgIC8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuICAgICAgICAgIC8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4gICAgICAgICAgLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuICAgICAgICAgIGZ1bmN0aW9uIGlubmVyRmFpbChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iailcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgdmFyIGludGVybmFsTWVzc2FnZVxuXG4gICAgICAgICAgICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgICAgICAgICAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJ1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBhY3R1YWxcbiAgICAgICAgICAgICAgYWN0dWFsID0gdW5kZWZpbmVkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAod2FybmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHdhcm5lZCA9IHRydWVcbiAgICAgICAgICAgICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmdcbiAgICAgICAgICAgICAgICAgID8gcHJvY2Vzcy5lbWl0V2FybmluZ1xuICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAnYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLFxuICAgICAgICAgICAgICAgICAgJ0RlcHJlY2F0aW9uV2FybmluZycsXG4gICAgICAgICAgICAgICAgICAnREVQMDA5NCdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG1lc3NhZ2VcbiAgICAgICAgICAgIHZhciBlcnJBcmdzID0ge1xuICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdmYWlsJyA6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKVxuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlXG4gICAgICAgICAgICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQuZmFpbCA9IGZhaWwgLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5cbiAgICAgICAgICBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvclxuXG4gICAgICAgICAgZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCdcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtZXNzYWdlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBmbixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlXG4gICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuICAgICAgICAgIC8vIGJ5ICEhdmFsdWUuXG5cbiAgICAgICAgICBmdW5jdGlvbiBvaygpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlubmVyT2suYXBwbHkodm9pZCAwLCBbb2ssIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXNzZXJ0Lm9rID0gb2sgLy8gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoID09LlxuXG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbiAgICAgICAgICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuICAgICAgICAgICAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICBpbm5lckZhaWwoe1xuICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogZXF1YWwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4gICAgICAgICAgLy8gZXF1YWwgd2l0aCAhPS5cblxuICAgICAgICAgIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJylcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG4gICAgICAgICAgICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBub3RFcXVhbCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKVxuXG4gICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG5cbiAgICAgICAgICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKFxuICAgICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKVxuXG4gICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwRXF1YWwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgICAgICAgIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoXG4gICAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpXG5cbiAgICAgICAgICAgIGlmICghaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBkZWVwU3RyaWN0RXF1YWwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbFxuXG4gICAgICAgICAgZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpXG5cbiAgICAgICAgICAgIGlmIChpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICBpbm5lckZhaWwoe1xuICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBTdHJpY3RFcXVhbCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ3N0cmljdEVxdWFsJyxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKFxuICAgICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICBpbm5lckZhaWwoe1xuICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG5cbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wYXJpc29uKVxuXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIGFjdHVhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICBpc1JlZ0V4cChvYmpba2V5XSkgJiZcbiAgICAgICAgICAgICAgICAgIG9ialtrZXldLnRlc3QoYWN0dWFsW2tleV0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3RoaXNba2V5XSA9IG9ialtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoXG4gICAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgZm5cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIShrZXkgaW4gYWN0dWFsKSB8fFxuICAgICAgICAgICAgICAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIG9iamVjdHMgdG8gY3JlYXRlIGEgbmljZSBvdXRwdXQuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgQ29tcGFyaXNvbihhY3R1YWwsIGtleXMpXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKVxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IGZuLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgZXJyLmFjdHVhbCA9IGFjdHVhbFxuICAgICAgICAgICAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZVxuICAgICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogZm4ubmFtZSxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IGZuLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKSAvLyBhc3NlcnQuZG9lc05vdFRocm93IGRvZXMgbm90IGFjY2VwdCBvYmplY3RzLlxuXG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgICAgICAgICAgICAgICAgJ2V4cGVjdGVkJyxcbiAgICAgICAgICAgICAgICAgIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sXG4gICAgICAgICAgICAgICAgICBleHBlY3RlZFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSAvLyBIYW5kbGUgcHJpbWl0aXZlcyBwcm9wZXJseS5cblxuICAgICAgICAgICAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBmbixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWVcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpIC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZFxuICAgICAgICAgICAgICAvLyBhcyB3ZWxsLlxuXG4gICAgICAgICAgICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShcbiAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICAgICdtYXkgbm90IGJlIGFuIGVtcHR5IG9iamVjdCdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKClcbiAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJlxuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRba2V5XS50ZXN0KGFjdHVhbFtrZXldKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbChmbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZuKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xuICAgICAgICAgICAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAgICAgICAgICAgLy8gd2F5LiBEbyBub3QgYWNjZXB0IHRoZW5hYmxlcyB0aGF0IHVzZSBhIGZ1bmN0aW9uIGFzIGBvYmpgIGFuZCB0aGF0IGhhdmUgbm9cbiAgICAgICAgICAgIC8vIGBjYXRjaGAgaGFuZGxlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgICAgICAgICAgIC8vIGJ1dCBhY2NvcmRpbmcgdG8gZG9jdW1lbnRhdGlvbiwgdGhlIGB0aGVuYCBtZXRob2Qgc2hvdWxkIHJlY2VpdmVcbiAgICAgICAgICAgIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGlzUHJvbWlzZShvYmopIHx8XG4gICAgICAgICAgICAgIChvYmogIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0UHJvbWlzZVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvbWlzZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCkgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG5cbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKFxuICAgICAgICAgICAgICAgICAgICAnaW5zdGFuY2Ugb2YgUHJvbWlzZScsXG4gICAgICAgICAgICAgICAgICAgICdwcm9taXNlRm4nLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgICAgICAgICAgICAgICAgJ3Byb21pc2VGbicsXG4gICAgICAgICAgICAgICAgICBbJ0Z1bmN0aW9uJywgJ1Byb21pc2UnXSxcbiAgICAgICAgICAgICAgICAgIHByb21pc2VGblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRQcm9taXNlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZXhwZWN0c0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3R1YWwubWVzc2FnZSA9PT0gZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3IvbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICdUaGUgZXJyb3IgbWVzc2FnZSBcIicuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICdcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbCA9PT0gZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVChcbiAgICAgICAgICAgICAgICAgICdlcnJvci9tZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICdUaGUgZXJyb3IgXCInLmNvbmNhdChhY3R1YWwsICdcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuJylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3JcbiAgICAgICAgICAgICAgZXJyb3IgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIGVycm9yICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgX3R5cGVvZihlcnJvcikgIT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgICAgICAgICAgIHZhciBkZXRhaWxzID0gJydcblxuICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMgKz0gJyAoJy5jb25jYXQoZXJyb3IubmFtZSwgJyknKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGV0YWlscyArPSBtZXNzYWdlID8gJzogJy5jb25jYXQobWVzc2FnZSkgOiAnLidcbiAgICAgICAgICAgICAgdmFyIGZuVHlwZSA9XG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuLm5hbWUgPT09ICdyZWplY3RzJyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbidcbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdNaXNzaW5nIGV4cGVjdGVkICcuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGVycm9yICYmXG4gICAgICAgICAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhyb3cgYWN0dWFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZXhwZWN0c05vRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVyblxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3JcbiAgICAgICAgICAgICAgZXJyb3IgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlcnJvciB8fCBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yKSkge1xuICAgICAgICAgICAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyAnOiAnLmNvbmNhdChtZXNzYWdlKSA6ICcuJ1xuICAgICAgICAgICAgICB2YXIgZm5UeXBlID1cbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnXG4gICAgICAgICAgICAgICAgICA/ICdyZWplY3Rpb24nXG4gICAgICAgICAgICAgICAgICA6ICdleGNlcHRpb24nXG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgJ0dvdCB1bndhbnRlZCAnLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzLCAnXFxuJykgK1xuICAgICAgICAgICAgICAgICAgJ0FjdHVhbCBtZXNzYWdlOiBcIicuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgJ1wiJyksXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGFjdHVhbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksXG4gICAgICAgICAgICAgICAgX2tleTIgPSAxO1xuICAgICAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgICAgICBfa2V5MisrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBlY3RzRXJyb3IuYXBwbHkoXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5yZWplY3RzID0gZnVuY3Rpb24gcmVqZWN0cyhwcm9taXNlRm4pIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSxcbiAgICAgICAgICAgICAgICBfa2V5MyA9IDE7XG4gICAgICAgICAgICAgIF9rZXkzIDwgX2xlbjM7XG4gICAgICAgICAgICAgIF9rZXkzKytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSxcbiAgICAgICAgICAgICAgICBfa2V5NCA9IDE7XG4gICAgICAgICAgICAgIF9rZXk0IDwgX2xlbjQ7XG4gICAgICAgICAgICAgIF9rZXk0KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGVjdHNOb0Vycm9yLmFwcGx5KFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5kb2VzTm90UmVqZWN0ID0gZnVuY3Rpb24gZG9lc05vdFJlamVjdChmbikge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLFxuICAgICAgICAgICAgICAgIF9rZXk1ID0gMTtcbiAgICAgICAgICAgICAgX2tleTUgPCBfbGVuNTtcbiAgICAgICAgICAgICAgX2tleTUrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkoXG4gICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnXG5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIF90eXBlb2YoZXJyKSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGVyci5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBpbnNwZWN0KGVycilcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBudWxsLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IGlmRXJyb3IsXG4gICAgICAgICAgICAgIH0pIC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG5cbiAgICAgICAgICAgICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFja1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCByZW1vdmUgYW55IGR1cGxpY2F0ZWQgZnJhbWVzIGZyb20gdGhlIGVycm9yIGZyYW1lcyB0YWtlblxuICAgICAgICAgICAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgICAgICAgICAgIHZhciB0bXAyID0gb3JpZ1N0YWNrLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAgIHRtcDIuc2hpZnQoKSAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgICAgICAgICAgICB2YXIgdG1wMSA9IG5ld0Vyci5zdGFjay5zcGxpdCgnXFxuJylcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pXG5cbiAgICAgICAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkga2VlcCBuZXcgZnJhbWVzLlxuICAgICAgICAgICAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3RXJyLnN0YWNrID0gJydcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQodG1wMS5qb2luKCdcXG4nKSwgJ1xcbicpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KHRtcDIuam9pbignXFxuJykpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXdFcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHJpY3QoKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwO1xuICAgICAgICAgICAgICBfa2V5NiA8IF9sZW42O1xuICAgICAgICAgICAgICBfa2V5NisrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlubmVyT2suYXBwbHkodm9pZCAwLCBbc3RyaWN0LCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgICAgICAgICAgIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gICAgICAgICAgICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gICAgICAgICAgICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICAgICAgICAgICAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBwcm9jZXNzL2Jyb3dzZXIgKi8gJy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXG5cbiAgICAgICAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge31cbiAgICAgICAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgc3ltXG4gICAgICAgICAgICAgICAgICAgICkuZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXVxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2VcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlXG4gICAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpXG4gICAgICAgICAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcylcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY2FsbCAmJlxuICAgICAgICAgICAgICAoX3R5cGVvZihjYWxsKSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgICAgICAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbidcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcbiAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgICAgICAgICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKVxuICAgICAgICAgICAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChcbiAgICAgICAgICAgICAgICAgIENsYXNzLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnIHx8ICFSZWZsZWN0LmNvbnN0cnVjdClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgICAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgICAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbbnVsbF1cbiAgICAgICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncylcbiAgICAgICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSlcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKVxuICAgICAgICAgICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPT0gLTFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICAgICAgX3NldFByb3RvdHlwZU9mID1cbiAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgICAgICAgICAgby5fX3Byb3RvX18gPSBwXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2YobylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICAgICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgPyAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdHlwZW9mKG9iailcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgdXRpbC8gKi8gJy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcydcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdFxuXG4gICAgICAgICAgdmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuLi9lcnJvcnMgKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZTIuY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cbiAgICAgICAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaFxuICAgICAgICAgIH0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgICAgICAgICAgIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudClcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnXG4gICAgICAgICAgICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnRcbiAgICAgICAgICAgIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSlcblxuICAgICAgICAgICAgd2hpbGUgKGNvdW50KSB7XG4gICAgICAgICAgICAgIHN0ciArPSBzdHJcbiAgICAgICAgICAgICAgY291bnQtLVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHIgKz0gc3RyLnN1YnN0cmluZygwLCBtYXhDb3VudCAtIHN0ci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJsdWUgPSAnJ1xuICAgICAgICAgIHZhciBncmVlbiA9ICcnXG4gICAgICAgICAgdmFyIHJlZCA9ICcnXG4gICAgICAgICAgdmFyIHdoaXRlID0gJydcbiAgICAgICAgICB2YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gICAgICAgICAgICBkZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbDonLFxuICAgICAgICAgICAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgICAgICAgICAgIHN0cmljdEVxdWFsT2JqZWN0OlxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gICAgICAgICAgICBkZWVwRXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsOicsXG4gICAgICAgICAgICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gICAgICAgICAgICBub3REZWVwU3RyaWN0RXF1YWw6XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gICAgICAgICAgICBub3RTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgc3RyaWN0bHkgdW5lcXVhbCB0bzonLFxuICAgICAgICAgICAgbm90U3RyaWN0RXF1YWxPYmplY3Q6XG4gICAgICAgICAgICAgICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gICAgICAgICAgICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgICAgICAgICAgIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86JyxcbiAgICAgICAgICAgIG5vdElkZW50aWNhbDogJ1ZhbHVlcyBpZGVudGljYWwgYnV0IG5vdCByZWZlcmVuY2UtZXF1YWw6JyxcbiAgICAgICAgICB9IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4gICAgICAgICAgLy8gZGlmZi5cblxuICAgICAgICAgIHZhciBrTWF4U2hvcnRMZW5ndGggPSAxMFxuXG4gICAgICAgICAgZnVuY3Rpb24gY29weUVycm9yKHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSlcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5tZXNzYWdlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpbnNwZWN0VmFsdWUodmFsKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgICAgICAgICAgIC8vIGVycm9yIG1lc3NhZ2VzIGNvbnRhaW4gdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBuZXZlcnRoZWxlc3MuXG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdCh2YWwsIHtcbiAgICAgICAgICAgICAgY29tcGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICBkZXB0aDogMTAwMCxcbiAgICAgICAgICAgICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgICAgICAgICAgICAvLyBBc3NlcnQgY29tcGFyZXMgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgKHdpdGggYSBmZXcgZXhjZXB0aW9ucykuXG4gICAgICAgICAgICAgIHNob3dIaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgICAgICAgICAgIC8vIGNvbXBhcmlzb24gZm9yIG5vdy5cbiAgICAgICAgICAgICAgLy8gVE9ETyhCcmlkZ2VBUik6IGBicmVha0xlbmd0aGAgc2hvdWxkIGJlIGxpbWl0ZWQgYXMgc29vbiBhcyBzb29uIGFzIHdlXG4gICAgICAgICAgICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAgICAgICAgICAgLy8gaW4gd2hhdCBsaW5lIHRoZSBwcm9wZXJ0eSBzdGFydHMgYW5kIGVuZHMpLlxuICAgICAgICAgICAgICBicmVha0xlbmd0aDogSW5maW5pdHksXG4gICAgICAgICAgICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgICAgICAgICAgIHNob3dQcm94eTogZmFsc2UsXG4gICAgICAgICAgICAgIHNvcnRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgICAgICAgICAgICBnZXR0ZXJzOiB0cnVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSAnJ1xuICAgICAgICAgICAgdmFyIHJlcyA9ICcnXG4gICAgICAgICAgICB2YXIgbGFzdFBvcyA9IDBcbiAgICAgICAgICAgIHZhciBlbmQgPSAnJ1xuICAgICAgICAgICAgdmFyIHNraXBwZWQgPSBmYWxzZVxuICAgICAgICAgICAgdmFyIGFjdHVhbEluc3BlY3RlZCA9IGluc3BlY3RWYWx1ZShhY3R1YWwpXG4gICAgICAgICAgICB2YXIgYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRMaW5lcyA9IGluc3BlY3RWYWx1ZShleHBlY3RlZCkuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICB2YXIgaSA9IDBcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3IgPSAnJyAvLyBJbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzIGV4cGxpY2l0bHkgbWFyayB0aGVtIGFzIG5vdCByZWZlcmVuY2UgZXF1YWxcbiAgICAgICAgICAgIC8vIGZvciB0aGUgYHN0cmljdEVxdWFsYCBvcGVyYXRvci5cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJyAmJlxuICAgICAgICAgICAgICBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICBhY3R1YWwgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgZXhwZWN0ZWQgIT09IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcGVyYXRvciA9ICdzdHJpY3RFcXVhbE9iamVjdCdcbiAgICAgICAgICAgIH0gLy8gSWYgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIGZpdCBvbiBhIHNpbmdsZSBsaW5lIGFuZCB0aGV5IGFyZSBub3Qgc3RyaWN0bHlcbiAgICAgICAgICAgIC8vIGVxdWFsLCBjaGVjayBmdXJ0aGVyIHNwZWNpYWwgaGFuZGxpbmcuXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgYWN0dWFsTGluZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgIGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgIGFjdHVhbExpbmVzWzBdICE9PSBleHBlY3RlZExpbmVzWzBdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0TGVuZ3RoID0gYWN0dWFsTGluZXNbMF0ubGVuZ3RoICsgZXhwZWN0ZWRMaW5lc1swXS5sZW5ndGggLy8gSWYgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIHRvZ2V0aGVyIGlzIGxlc3MgdGhhblxuICAgICAgICAgICAgICAvLyBrTWF4U2hvcnRMZW5ndGggYW5kIGlmIG5laXRoZXIgaXMgYW4gb2JqZWN0IGFuZCBhdCBsZWFzdCBvbmUgb2YgdGhlbSBpc1xuICAgICAgICAgICAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgICAgICAgICAgIGlmIChpbnB1dExlbmd0aCA8PSBrTWF4U2hvcnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpICYmXG4gICAgICAgICAgICAgICAgICAoX3R5cGVvZihleHBlY3RlZCkgIT09ICdvYmplY3QnIHx8IGV4cGVjdGVkID09PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgICAgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIC0wID09PSArMFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgJycuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgJ1xcblxcbicpICtcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFjdHVhbExpbmVzWzBdLCAnICE9PSAnKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZXhwZWN0ZWRMaW5lc1swXSwgJ1xcbicpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnc3RyaWN0RXF1YWxPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0ZGVyciBpcyBhIHR0eSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgdHR5LCB1c2UgYSBkZWZhdWx0IHZhbHVlIG9mIDgwIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWVxuICAgICAgICAgICAgICAgICAgICA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnNcbiAgICAgICAgICAgICAgICAgICAgOiA4MFxuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoYWN0dWFsTGluZXNbMF1baV0gPT09IGV4cGVjdGVkTGluZXNbMF1baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICAgICB9IC8vIElnbm9yZSB0aGUgZmlyc3QgY2hhcmFjdGVycy5cblxuICAgICAgICAgICAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBwb3NpdGlvbiBpbmRpY2F0b3IgZm9yIHRoZSBmaXJzdCBtaXNtYXRjaCBpbiBjYXNlIGl0IGlzIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3IgPSAnXFxuICAnLmNvbmNhdChyZXBlYXQoJyAnLCBpKSwgJ14nKVxuICAgICAgICAgICAgICAgICAgICBpID0gMFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAgICAgICAgICAgLy8gcmVhZGFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiB0b3RhbCBjaGFuZ2VkIGxpbmVzKS5cblxuICAgICAgICAgICAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV1cblxuICAgICAgICAgICAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgaWYgKGkrKyA8IDIpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAnXFxuICAnLmNvbmNhdChhKS5jb25jYXQoZW5kKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyID0gYVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWN0dWFsTGluZXMucG9wKClcbiAgICAgICAgICAgICAgZXhwZWN0ZWRMaW5lcy5wb3AoKVxuICAgICAgICAgICAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAwIHx8IGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAwKSBicmVha1xuICAgICAgICAgICAgICBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKSAvLyBTdHJpY3QgZXF1YWwgd2l0aCBpZGVudGljYWwgb2JqZWN0cyB0aGF0IGFyZSBub3QgaWRlbnRpY2FsIGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgICAgIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgICAgICAgICAgIGlmIChtYXhMaW5lcyA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcmVzdWx0IGFnYWluLiBUaGUgbGluZXMgd2VyZSBhbGwgcmVtb3ZlZCBiZWZvcmUuXG4gICAgICAgICAgICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpIC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cbiAgICAgICAgICAgICAgaWYgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSAnJy5jb25jYXQoYmx1ZSwgJy4uLicpLmNvbmNhdCh3aGl0ZSlcblxuICAgICAgICAgICAgICAgIHdoaWxlIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgICAgICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICAgICAgICAgIC5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCAnXFxuXFxuJylcbiAgICAgICAgICAgICAgICAuY29uY2F0KF9hY3R1YWxMaW5lcy5qb2luKCdcXG4nKSwgJ1xcbicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID4gMykge1xuICAgICAgICAgICAgICBlbmQgPSAnXFxuJy5jb25jYXQoYmx1ZSwgJy4uLicpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZClcbiAgICAgICAgICAgICAgc2tpcHBlZCA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG90aGVyICE9PSAnJykge1xuICAgICAgICAgICAgICBlbmQgPSAnXFxuICAnLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZClcbiAgICAgICAgICAgICAgb3RoZXIgPSAnJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJpbnRlZExpbmVzID0gMFxuICAgICAgICAgICAgdmFyIG1zZyA9XG4gICAgICAgICAgICAgIGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSArXG4gICAgICAgICAgICAgICdcXG4nXG4gICAgICAgICAgICAgICAgLmNvbmNhdChncmVlbiwgJysgYWN0dWFsJylcbiAgICAgICAgICAgICAgICAuY29uY2F0KHdoaXRlLCAnICcpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZWQsICctIGV4cGVjdGVkJylcbiAgICAgICAgICAgICAgICAuY29uY2F0KHdoaXRlKVxuICAgICAgICAgICAgdmFyIHNraXBwZWRNc2cgPSAnICdcbiAgICAgICAgICAgICAgLmNvbmNhdChibHVlLCAnLi4uJylcbiAgICAgICAgICAgICAgLmNvbmNhdCh3aGl0ZSwgJyBMaW5lcyBza2lwcGVkJylcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1heExpbmVzOyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gT25seSBleHRyYSBleHBlY3RlZCBsaW5lcyBleGlzdFxuICAgICAgICAgICAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3NcblxuICAgICAgICAgICAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgICAgICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbicuY29uY2F0KGJsdWUsICcuLi4nKS5jb25jYXQod2hpdGUpXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9ICdcXG4gICcuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDJdKVxuICAgICAgICAgICAgICAgICAgICBwcmludGVkTGluZXMrK1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbiAgJy5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pXG4gICAgICAgICAgICAgICAgICBwcmludGVkTGluZXMrK1xuICAgICAgICAgICAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cbiAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSAvLyBBZGQgdGhlIGV4cGVjdGVkIGxpbmUgdG8gdGhlIGNhY2hlLlxuXG4gICAgICAgICAgICAgICAgb3RoZXIgKz0gJ1xcbidcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQocmVkLCAnLScpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KHdoaXRlLCAnICcpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KGV4cGVjdGVkTGluZXNbaV0pXG4gICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzKysgLy8gT25seSBleHRyYSBhY3R1YWwgbGluZXMgZXhpc3RcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgICAgICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9ICdcXG4nLmNvbmNhdChibHVlLCAnLi4uJykuY29uY2F0KHdoaXRlKVxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSAnXFxuICAnLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pXG4gICAgICAgICAgICAgICAgICAgIHByaW50ZWRMaW5lcysrXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlcyArPSAnXFxuICAnLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pXG4gICAgICAgICAgICAgICAgICBwcmludGVkTGluZXMrK1xuICAgICAgICAgICAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cbiAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbidcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoZ3JlZW4sICcrJylcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQod2hpdGUsICcgJylcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoYWN0dWFsTGluZXNbaV0pXG4gICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzKysgLy8gTGluZXMgZGl2ZXJnZVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZExpbmUgPSBleHBlY3RlZExpbmVzW2ldXG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbExpbmUgPSBhY3R1YWxMaW5lc1tpXSAvLyBJZiB0aGUgbGluZXMgZGl2ZXJnZSwgc3BlY2lmaWNhbGx5IGNoZWNrIGZvciBsaW5lcyB0aGF0IG9ubHkgZGl2ZXJnZSBieVxuICAgICAgICAgICAgICAgIC8vIGEgdHJhaWxpbmcgY29tbWEuIEluIHRoYXQgY2FzZSBpdCBpcyBhY3R1YWxseSBpZGVudGljYWwgYW5kIHdlIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgICAgICAgICAgIHZhciBkaXZlcmdpbmdMaW5lcyA9XG4gICAgICAgICAgICAgICAgICBhY3R1YWxMaW5lICE9PSBleHBlY3RlZExpbmUgJiZcbiAgICAgICAgICAgICAgICAgICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKSAvLyBJZiB0aGUgZXhwZWN0ZWQgbGluZSBoYXMgYSB0cmFpbGluZyBjb21tYSBidXQgaXMgb3RoZXJ3aXNlIGlkZW50aWNhbCxcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgICAgICAgICAgICAvLyBsb29rIHdlaXJkIGFzIGluOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICBbXG4gICAgICAgICAgICAgICAgLy8gICAgIDEgICAgICAgICAvLyBObyBjb21tYSBhdCB0aGUgZW5kIVxuICAgICAgICAgICAgICAgIC8vICsgICAyXG4gICAgICAgICAgICAgICAgLy8gICBdXG4gICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIGRpdmVyZ2luZ0xpbmVzICYmXG4gICAgICAgICAgICAgICAgICBlbmRzV2l0aChleHBlY3RlZExpbmUsICcsJykgJiZcbiAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGRpdmVyZ2luZ0xpbmVzID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgIGFjdHVhbExpbmUgKz0gJywnXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAgICAgICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgICAgICAgICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzICs9ICdcXG4nLmNvbmNhdChibHVlLCAnLi4uJykuY29uY2F0KHdoaXRlKVxuICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSAnXFxuICAnLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pXG4gICAgICAgICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzKytcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSAnXFxuICAnLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pXG4gICAgICAgICAgICAgICAgICAgIHByaW50ZWRMaW5lcysrXG4gICAgICAgICAgICAgICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG4gICAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgICAgICAgICAgIC8vIGxpbmUgc28gY29uc2VjdXRpdmUgZGl2ZXJnaW5nIGxpbmVzIHNob3cgdXAgYXMgKysrLS0tIGFuZCBub3QgKy0rLSstLlxuXG4gICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbidcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChncmVlbiwgJysnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHdoaXRlLCAnICcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoYWN0dWFsTGluZSlcbiAgICAgICAgICAgICAgICAgIG90aGVyICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQocmVkLCAnLScpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQod2hpdGUsICcgJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChleHBlY3RlZExpbmUpXG4gICAgICAgICAgICAgICAgICBwcmludGVkTGluZXMgKz0gMiAvLyBMaW5lcyBhcmUgaWRlbnRpY2FsXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXNldCB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICByZXMgKz0gb3RoZXJcbiAgICAgICAgICAgICAgICAgIG90aGVyID0gJycgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgZXhhY3RseSBvbmUgbGluZSBhYm92ZSBvciBpZiBpdCBpcyB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIHZlcnkgZmlyc3QgbGluZSwgYWRkIHRoZSBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbiAgJy5jb25jYXQoYWN0dWFsTGluZSlcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzKytcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gSW5zcGVjdGVkIG9iamVjdCB0byBiaWcgKFNob3cgfjIwIHJvd3MgbWF4KVxuXG4gICAgICAgICAgICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQobXNnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNraXBwZWRNc2csICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcywgJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoYmx1ZSwgJy4uLicpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQod2hpdGUpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQob3RoZXIsICdcXG4nKSArICcnLmNvbmNhdChibHVlLCAnLi4uJykuY29uY2F0KHdoaXRlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgICAgLmNvbmNhdChtc2cpXG4gICAgICAgICAgICAgIC5jb25jYXQoc2tpcHBlZCA/IHNraXBwZWRNc2cgOiAnJywgJ1xcbicpXG4gICAgICAgICAgICAgIC5jb25jYXQocmVzKVxuICAgICAgICAgICAgICAuY29uY2F0KG90aGVyKVxuICAgICAgICAgICAgICAuY29uY2F0KGVuZClcbiAgICAgICAgICAgICAgLmNvbmNhdChpbmRpY2F0b3IpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIEFzc2VydGlvbkVycm9yID1cbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAgIChmdW5jdGlvbiAoX0Vycm9yKSB7XG4gICAgICAgICAgICAgIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNcblxuICAgICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb25FcnJvcilcblxuICAgICAgICAgICAgICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZuXG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkXG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0XG4gICAgICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMFxuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFN0cmluZyhtZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyICYmXG4gICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGgoKSAhPT0gMVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBibHVlID0gJ1xceDFCWzM0bSdcbiAgICAgICAgICAgICAgICAgICAgICBncmVlbiA9ICdcXHgxQlszMm0nXG4gICAgICAgICAgICAgICAgICAgICAgd2hpdGUgPSAnXFx4MUJbMzltJ1xuICAgICAgICAgICAgICAgICAgICAgIHJlZCA9ICdcXHgxQlszMW0nXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYmx1ZSA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgZ3JlZW4gPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgIHdoaXRlID0gJydcbiAgICAgICAgICAgICAgICAgICAgICByZWQgPSAnJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IC8vIFByZXZlbnQgdGhlIGVycm9yIHN0YWNrIGZyb20gYmVpbmcgdmlzaWJsZSBieSBkdXBsaWNhdGluZyB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgIC8vIGluIGEgdmVyeSBjbG9zZSB3YXkgdG8gdGhlIG9yaWdpbmFsIGluIGNhc2UgYm90aCBzaWRlcyBhcmUgYWN0dWFsbHlcbiAgICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlcyBvZiBFcnJvci5cblxuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3N0YWNrJyBpbiBhY3R1YWwgJiZcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJlxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsID0gY29weUVycm9yKGFjdHVhbClcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBjb3B5RXJyb3IoZXhwZWN0ZWQpXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09ICdkZWVwU3RyaWN0RXF1YWwnIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgYnV0IHRoZSBvcGVyYXRvciByZXF1aXJlcyB1bmVxdWFsLCBzaG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBvYmplY3QgYW5kIHNheSBBIGVxdWFscyBCXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKS5zcGxpdCgnXFxuJykgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmXG4gICAgICAgICAgICAgICAgICAgICAgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Iubm90U3RyaWN0RXF1YWxPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNbMjZdID0gJycuY29uY2F0KGJsdWUsICcuLi4nKS5jb25jYXQod2hpdGUpXG5cbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gT25seSBwcmludCBhIHNpbmdsZSBpbnB1dC5cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnJy5jb25jYXQoYmFzZSwgJyAnKS5jb25jYXQocmVzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJycuY29uY2F0KGJhc2UsICdcXG5cXG4nKS5jb25jYXQocmVzLmpvaW4oJ1xcbicpLCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbClcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSAnJ1xuICAgICAgICAgICAgICAgICAgICB2YXIga25vd25PcGVyYXRvcnMgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09ICdub3RFcXVhbCdcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3JlcyA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgJ1xcblxcbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KF9yZXMpXG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzID0gJycuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksICcuLi4nKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdGhlciA9ICcnLmNvbmNhdChpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpKVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzID0gJycuY29uY2F0KF9yZXMuc2xpY2UoMCwgNTA5KSwgJy4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSAnJy5jb25jYXQob3RoZXIuc2xpY2UoMCwgNTA5KSwgJy4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ2VxdWFsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlcyA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoa25vd25PcGVyYXRvcnMsICdcXG5cXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KF9yZXMsICdcXG5cXG5zaG91bGQgZXF1YWxcXG5cXG4nKVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlciA9ICcgJy5jb25jYXQob3BlcmF0b3IsICcgJykuY29uY2F0KG90aGVyKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJycuY29uY2F0KF9yZXMpLmNvbmNhdChvdGhlcilcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdFxuICAgICAgICAgICAgICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJ25hbWUnLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXScsXG4gICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgX3RoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJ1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdHVhbCA9IGFjdHVhbFxuICAgICAgICAgICAgICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yXG5cbiAgICAgICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoXG4gICAgICAgICAgICAgICAgICAgIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm5cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuICAgICAgICAgICAgICAgIF90aGlzLnN0YWNrIC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgICAgICAgICAgICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcidcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQXNzZXJ0aW9uRXJyb3IsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5uYW1lLCAnIFsnKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5jb2RlLCAnXTogJylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGluc3BlY3QuY3VzdG9tLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbGltaXRzIHRoZSBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYCBwcm9wZXJ0eSBkZWZhdWx0IGluc3BlY3Rpb24gdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1pbmltdW0gZGVwdGguIE90aGVyd2lzZSB0aG9zZSB2YWx1ZXMgd291bGQgYmUgdG9vIHZlcmJvc2UgY29tcGFyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgICAgICAgICAgICAgICAgLy8gaW5wdXQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zcGVjdChcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIEFzc2VydGlvbkVycm9yXG4gICAgICAgICAgICB9KShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSlcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3JcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzNiMDQ0OTYyYzQ4ZmUzMTM5MDU4NzdhOTZiNWQwODk0YTU0MDRmNmZcblxuICAgICAgICAgIC8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4gICAgICAgICAgLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4gICAgICAgICAgLyogZXNsaW50IG5vZGUtY29yZS9wcmVmZXItdXRpbC1mb3JtYXQtZXJyb3JzOiBcImVycm9yXCIgKi9cbiAgICAgICAgICAvLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cbiAgICAgICAgICAvLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4gICAgICAgICAgLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4gICAgICAgICAgLy8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuICAgICAgICAgIC8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cblxuICAgICAgICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9ialxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJlxuICAgICAgICAgICAgICAgICAgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgICAgICAgICA6IHR5cGVvZiBvYmpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjYWxsICYmXG4gICAgICAgICAgICAgIChfdHlwZW9mKGNhbGwpID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgY2FsbCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICAgICAgICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICAgICAgICAgIFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mXG4gICAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbidcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcbiAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgICAgICBfc2V0UHJvdG90eXBlT2YgPVxuICAgICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgICAgICAgICBvLl9fcHJvdG9fXyA9IHBcbiAgICAgICAgICAgICAgICByZXR1cm4gb1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvZGVzID0ge30gLy8gTGF6eSBsb2FkZWRcblxuICAgICAgICAgIHZhciBhc3NlcnRcbiAgICAgICAgICB2YXIgdXRpbFxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgICAgICAgICAgIGlmICghQmFzZSkge1xuICAgICAgICAgICAgICBCYXNlID0gRXJyb3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIE5vZGVFcnJvciA9XG4gICAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAgICAgKGZ1bmN0aW9uIChfQmFzZSkge1xuICAgICAgICAgICAgICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpc1xuXG4gICAgICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUVycm9yKVxuXG4gICAgICAgICAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YoTm9kZUVycm9yKS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBfdGhpcy5jb2RlID0gY29kZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5vZGVFcnJvclxuICAgICAgICAgICAgICB9KShCYXNlKVxuXG4gICAgICAgICAgICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvclxuICAgICAgICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cbiAgICAgICAgICBmdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoXG4gICAgICAgICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhpKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICdvbmUgb2YgJ1xuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRoaW5nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgJywgb3IgJykgK1xuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRbbGVuIC0gMV1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvbmUgb2YgJ1xuICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aGluZywgJyAnKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChleHBlY3RlZFswXSwgJyBvciAnKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChleHBlY3RlZFsxXSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mICcuY29uY2F0KHRoaW5nLCAnICcpLmNvbmNhdChleHBlY3RlZFswXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdvZiAnLmNvbmNhdCh0aGluZywgJyAnKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cbiAgICAgICAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2hcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG4gICAgICAgICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2hcbiAgICAgICAgICB9IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG4gICAgICAgICAgZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBzdGFydCA9IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3JlYXRlRXJyb3JUeXBlKFxuICAgICAgICAgICAgJ0VSUl9BTUJJR1VPVVNfQVJHVU1FTlQnLFxuICAgICAgICAgICAgJ1RoZSBcIiVzXCIgYXJndW1lbnQgaXMgYW1iaWd1b3VzLiAlcycsXG4gICAgICAgICAgICBUeXBlRXJyb3JcbiAgICAgICAgICApXG4gICAgICAgICAgY3JlYXRlRXJyb3JUeXBlKFxuICAgICAgICAgICAgJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgICAgICAgICAgIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgICAgLyohIC4uL2Fzc2VydCAqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2Fzc2VydC5qcydcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIikgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICAgICAgICAgICAgICB2YXIgZGV0ZXJtaW5lclxuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJ1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbXNnXG5cbiAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICAgICAgICAgICAgICBtc2cgPSAnVGhlICdcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQobmFtZSwgJyAnKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChkZXRlcm1pbmVyLCAnICcpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnXG4gICAgICAgICAgICAgICAgbXNnID0gJ1RoZSBcIidcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQobmFtZSwgJ1wiICcpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KHR5cGUsICcgJylcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoZGV0ZXJtaW5lciwgJyAnKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSlcbiAgICAgICAgICAgICAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG4gICAgICAgICAgICAgIG1zZyArPSAnLiBSZWNlaXZlZCB0eXBlICcuY29uY2F0KF90eXBlb2YoYWN0dWFsKSlcbiAgICAgICAgICAgICAgcmV0dXJuIG1zZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFR5cGVFcnJvclxuICAgICAgICAgIClcbiAgICAgICAgICBjcmVhdGVFcnJvclR5cGUoXG4gICAgICAgICAgICAnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgcmVhc29uID1cbiAgICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMl1cbiAgICAgICAgICAgICAgICAgIDogJ2lzIGludmFsaWQnXG4gICAgICAgICAgICAgIGlmICh1dGlsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgICAgICAvKiEgdXRpbC8gKi8gJy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcydcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSB1dGlsLmluc3BlY3QodmFsdWUpXG5cbiAgICAgICAgICAgICAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAxMjgpIHtcbiAgICAgICAgICAgICAgICBpbnNwZWN0ZWQgPSAnJy5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksICcuLi4nKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIlxuICAgICAgICAgICAgICAgIC5jb25jYXQobmFtZSwgXCInIFwiKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVhc29uLCAnLiBSZWNlaXZlZCAnKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoaW5zcGVjdGVkKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFR5cGVFcnJvcixcbiAgICAgICAgICAgIFJhbmdlRXJyb3JcbiAgICAgICAgICApXG4gICAgICAgICAgY3JlYXRlRXJyb3JUeXBlKFxuICAgICAgICAgICAgJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsXG4gICAgICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciB0eXBlXG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2luc3RhbmNlIG9mICcuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICd0eXBlICcuY29uY2F0KF90eXBlb2YodmFsdWUpKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgJ1xuICAgICAgICAgICAgICAgICAgLmNvbmNhdChpbnB1dCwgJyB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcIicpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KG5hbWUsICdcIicpICsgJyBmdW5jdGlvbiBidXQgZ290ICcuY29uY2F0KHR5cGUsICcuJylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFR5cGVFcnJvclxuICAgICAgICAgIClcbiAgICAgICAgICBjcmVhdGVFcnJvclR5cGUoXG4gICAgICAgICAgICAnRVJSX01JU1NJTkdfQVJHUycsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgICBfa2V5KytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgICAgICAvKiEgLi4vYXNzZXJ0ICovICcuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvYXNzZXJ0LmpzJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJylcbiAgICAgICAgICAgICAgdmFyIG1zZyA9ICdUaGUgJ1xuICAgICAgICAgICAgICB2YXIgbGVuID0gYXJncy5sZW5ndGhcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcIicuY29uY2F0KGEsICdcIicpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBtc2cgKz0gJycuY29uY2F0KGFyZ3NbMF0sICcgYXJndW1lbnQnKVxuICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIG1zZyArPSAnJ1xuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFyZ3NbMF0sICcgYW5kICcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoYXJnc1sxXSwgJyBhcmd1bWVudHMnKVxuICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpXG4gICAgICAgICAgICAgICAgICBtc2cgKz0gJywgYW5kICcuY29uY2F0KGFyZ3NbbGVuIC0gMV0sICcgYXJndW1lbnRzJylcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gJycuY29uY2F0KG1zZywgJyBtdXN0IGJlIHNwZWNpZmllZCcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgVHlwZUVycm9yXG4gICAgICAgICAgKVxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXNcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qc1xuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4gICAgICAgICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fFxuICAgICAgICAgICAgICBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fFxuICAgICAgICAgICAgICBfbm9uSXRlcmFibGVSZXN0KClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgICAgICAgICAgdmFyIF9hcnIgPSBbXVxuICAgICAgICAgICAgdmFyIF9uID0gdHJ1ZVxuICAgICAgICAgICAgdmFyIF9kID0gZmFsc2VcbiAgICAgICAgICAgIHZhciBfZSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfcztcbiAgICAgICAgICAgICAgICAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTtcbiAgICAgICAgICAgICAgICBfbiA9IHRydWVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKVxuICAgICAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2QgPSB0cnVlXG4gICAgICAgICAgICAgIF9lID0gZXJyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX24gJiYgX2lbJ3JldHVybiddICE9IG51bGwpIF9pWydyZXR1cm4nXSgpXG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2FyclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICAgICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgPyAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdHlwZW9mKG9iailcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZFxuXG4gICAgICAgICAgdmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdXG4gICAgICAgICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdXG4gICAgICAgICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJyYXkucHVzaChba2V5LCB2YWx1ZV0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9iamVjdElzID0gT2JqZWN0LmlzXG4gICAgICAgICAgICA/IE9iamVjdC5pc1xuICAgICAgICAgICAgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgIC8qISBvYmplY3QtaXMgKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcydcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgIHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG4gICAgICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOXG4gICAgICAgICAgICA/IE51bWJlci5pc05hTlxuICAgICAgICAgICAgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgIC8qISBpcy1uYW4gKi8gJy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbmRleC5qcydcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICAgICAgICAgICAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSlcbiAgICAgICAgICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZylcblxuICAgICAgICAgIHZhciBfcmVxdWlyZSR0eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISB1dGlsLyAqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzJ1xuICAgICAgICAgICAgKS50eXBlcyxcbiAgICAgICAgICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgICAgICAgICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICAgICAgICAgIGlzRGF0ZSA9IF9yZXF1aXJlJHR5cGVzLmlzRGF0ZSxcbiAgICAgICAgICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgICAgICAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgICAgICAgICAgaXNTZXQgPSBfcmVxdWlyZSR0eXBlcy5pc1NldCxcbiAgICAgICAgICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgICAgICAgICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgICAgICAgICBpc051bWJlck9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzTnVtYmVyT2JqZWN0LFxuICAgICAgICAgICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICAgICAgICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICAgICAgICAgIGlzQmlnSW50T2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCaWdJbnRPYmplY3QsXG4gICAgICAgICAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgICAgICAgICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICAgICAgICAgIGlzRmxvYXQ2NEFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDY0QXJyYXlcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzTm9uSW5kZXgoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSlcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cbiAgICAgICAgICAgIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgICAgICAgIC5maWx0ZXIoaXNOb25JbmRleClcbiAgICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICB9IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4gICAgICAgICAgLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4gICAgICAgICAgLyohXG4gICAgICAgICAgICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAgICAgICAgICAgKiBAbGljZW5zZSAgTUlUXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4ID0gYS5sZW5ndGhcbiAgICAgICAgICAgIHZhciB5ID0gYi5sZW5ndGhcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICB4ID0gYVtpXVxuICAgICAgICAgICAgICAgIHkgPSBiW2ldXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeCA8IHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5IDwgeCkge1xuICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWRcbiAgICAgICAgICB2YXIga1N0cmljdCA9IHRydWVcbiAgICAgICAgICB2YXIga0xvb3NlID0gZmFsc2VcbiAgICAgICAgICB2YXIga05vSXRlcmF0b3IgPSAwXG4gICAgICAgICAgdmFyIGtJc0FycmF5ID0gMVxuICAgICAgICAgIHZhciBrSXNTZXQgPSAyXG4gICAgICAgICAgdmFyIGtJc01hcCA9IDMgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuICAgICAgICAgIGZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleEZsYWdzU3VwcG9ydGVkXG4gICAgICAgICAgICAgID8gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3NcbiAgICAgICAgICAgICAgOiBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09XG4gICAgICAgICAgICAgICAgICBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgIGlmIChhW29mZnNldF0gIT09IGJbb2Zmc2V0XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgY29tcGFyZShcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpLFxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgKSA9PT0gMFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmXG4gICAgICAgICAgICAgIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXJPYmplY3QodmFsMSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBpc051bWJlck9iamVjdCh2YWwyKSAmJlxuICAgICAgICAgICAgICAgIG9iamVjdElzKFxuICAgICAgICAgICAgICAgICAgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSksXG4gICAgICAgICAgICAgICAgICBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBpc1N0cmluZ09iamVjdCh2YWwyKSAmJlxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PVxuICAgICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbDEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmXG4gICAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PVxuICAgICAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgaXNCaWdJbnRPYmplY3QodmFsMikgJiZcbiAgICAgICAgICAgICAgICBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT1cbiAgICAgICAgICAgICAgICAgIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgaXNTeW1ib2xPYmplY3QodmFsMikgJiZcbiAgICAgICAgICAgICAgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09XG4gICAgICAgICAgICAgICAgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4gICAgICAgICAgLy8gRnVuY3Rpb25UZW1wbGF0ZTo6U2V0Q2xhc3NOYW1lKCkgaW4gQysrIG9yIFN5bWJvbC50b1N0cmluZ1RhZyBpbiBKU1xuICAgICAgICAgIC8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBhIGxpc3Qgb2YgdGFncyBwcmUtZGVmaW5lZCBpbiB0aGUgc3BlYy5cbiAgICAgICAgICAvLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbiAgICAgICAgICAvLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuICAgICAgICAgIC8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuICAgICAgICAgIC8vIHJlYXNvbmFibGUgdG8gaW50ZXJwcmV0IHRoZWlyIHVuZGVybHlpbmcgbWVtb3J5IGluIHRoZSBzYW1lIHdheSxcbiAgICAgICAgICAvLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4gICAgICAgICAgLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbiAgICAgICAgICAvLyBjb3VsZCBzdGlsbCBiZSBkaWZmZXJlbnQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgaW50ZXJwcmV0ZWQgZGlmZmVyZW50bHkpLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4gICAgICAgICAgLy8gYSkgVGhlIHNhbWUgYnVpbHQtaW4gdHlwZSB0YWdzXG4gICAgICAgICAgLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuICAgICAgICAgIGZ1bmN0aW9uIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MpIHtcbiAgICAgICAgICAgIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgICAgICAgICAgIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgICAgICAgICAgIGlmICh2YWwxICE9PSAwKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICByZXR1cm4gc3RyaWN0ID8gb2JqZWN0SXModmFsMSwgdmFsMikgOiB0cnVlXG4gICAgICAgICAgICB9IC8vIENoZWNrIG1vcmUgY2xvc2VseSBpZiB2YWwxIGFuZCB2YWwyIGFyZSBlcXVhbC5cblxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICBpZiAoX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICBudW1iZXJJc05hTih2YWwxKSAmJlxuICAgICAgICAgICAgICAgICAgbnVtYmVySXNOYU4odmFsMilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICB2YWwxID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdmFsMiA9PT0gbnVsbFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodmFsMSA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsMSA9PSB2YWwyXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSlcbiAgICAgICAgICAgIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMilcblxuICAgICAgICAgICAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgICAgICAgICAgICBpZiAodmFsMS5sZW5ndGggIT09IHZhbDIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKVxuICAgICAgICAgICAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKVxuXG4gICAgICAgICAgICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSlcbiAgICAgICAgICAgIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzZWNvbmQgdmFsdWUgaXMgb25lIG9mIHRoZXNlIHZhbHVlcyBhbmQgdGhlIGZpcnN0IGlzbid0LlxuXG4gICAgICAgICAgICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikpIHx8XG4gICAgICAgICAgICAgICAgKCFpc1NldCh2YWwxKSAmJiBpc1NldCh2YWwyKSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWlzRGF0ZSh2YWwyKSB8fFxuICAgICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT1cbiAgICAgICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwyKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWwxKSkge1xuICAgICAgICAgICAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlRXJyb3IodmFsMSkgfHwgdmFsMSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgICAgICAgICAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgICAgICAgICAgICBpZiAodmFsMS5tZXNzYWdlICE9PSB2YWwyLm1lc3NhZ2UgfHwgdmFsMS5uYW1lICE9PSB2YWwyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAoaXNGbG9hdDMyQXJyYXkodmFsMSkgfHwgaXNGbG9hdDY0QXJyYXkodmFsMSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghYXJlU2ltaWxhclR5cGVkQXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgICAgICAgICAgIC8vIHRoZSBzeW1ib2xzLlxuXG4gICAgICAgICAgICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpXG5cbiAgICAgICAgICAgICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpXG5cbiAgICAgICAgICAgICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiZcbiAgICAgICAgICAgICAgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbCwgaylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgICAgICAgICAgIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAgICAgICAgICAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBoYXZpbmc6XG4gICAgICAgICAgICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gICAgICAgICAgICAvLyBjKSBFcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkvaW5kZXhcbiAgICAgICAgICAgIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSlcbiAgICAgICAgICAgICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMikgLy8gVGhlIHBhaXIgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzLlxuXG4gICAgICAgICAgICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIENoZWFwIGtleSB0ZXN0XG5cbiAgICAgICAgICAgIHZhciBpID0gMFxuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkodmFsMiwgYUtleXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKVxuXG4gICAgICAgICAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwXG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzeW1ib2xLZXlzQVtpXVxuXG4gICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFLZXlzLnB1c2goa2V5KVxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpXG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgZ2V0RW51bWVyYWJsZXModmFsMiwgc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gY291bnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpXG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICBnZXRFbnVtZXJhYmxlcyh2YWwyLCBfc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgYUtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fFxuICAgICAgICAgICAgICAgIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICB2YWwxLnNpemUgPT09IDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cbiAgICAgICAgICAgIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG1lbW9zID0ge1xuICAgICAgICAgICAgICAgIHZhbDE6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgLy8gYW5kIGNoZWNraW5nIGZvciB1bmRlZmluZWQuIFRoZSBtYXAgY2FuIG9ubHkgY29udGFpbiBudW1iZXJzLCBzbyBpdCBpc1xuICAgICAgICAgICAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICAgICAgICAgICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpXG5cbiAgICAgICAgICAgICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbDJNZW1vQiA9IG1lbW9zLnZhbDIuZ2V0KHZhbDIpXG5cbiAgICAgICAgICAgICAgICBpZiAodmFsMk1lbW9CICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1lbW9zLnBvc2l0aW9uKytcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pXG4gICAgICAgICAgICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbilcbiAgICAgICAgICAgIHZhciBhcmVFcSA9IG9iakVxdWl2KFxuICAgICAgICAgICAgICB2YWwxLFxuICAgICAgICAgICAgICB2YWwyLFxuICAgICAgICAgICAgICBzdHJpY3QsXG4gICAgICAgICAgICAgIGFLZXlzLFxuICAgICAgICAgICAgICBtZW1vcyxcbiAgICAgICAgICAgICAgaXRlcmF0aW9uVHlwZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgbWVtb3MudmFsMS5kZWxldGUodmFsMSlcbiAgICAgICAgICAgIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpXG4gICAgICAgICAgICByZXR1cm4gYXJlRXFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgICAgICAgICAgIC8vIEdvIGxvb2tpbmcuXG4gICAgICAgICAgICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldClcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV1cblxuICAgICAgICAgICAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWF0Y2hpbmcgZWxlbWVudCB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGNoZWNrIHRoYXQgYWdhaW4uXG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZSh2YWwyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9FcXVhbGl0eV9jb21wYXJpc29uc19hbmRfc2FtZW5lc3MjTG9vc2VfZXF1YWxpdHlfdXNpbmdcbiAgICAgICAgICAvLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4gICAgICAgICAgLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuICAgICAgICAgIC8vIGNhbiBtYXRjaCBsb3RzIG9mIGRpZmZlcmVudCBzdHJpbmcgdmFsdWVzIChlLmcuLCAxbiA9PSAnKzAwMDAxJykuXG5cbiAgICAgICAgICBmdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICAgICAgICAgICAgc3dpdGNoIChfdHlwZW9mKHByaW0pKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcGFzcyBpbiBudWxsIGFzIG9iamVjdCFcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHByaW0gPSArcHJpbVxuICAgICAgICAgICAgICAvLyBMb29zZSBlcXVhbCBlbnRyaWVzIGV4aXN0IG9ubHkgaWYgdGhlIHN0cmluZyBpcyBwb3NzaWJsZSB0byBjb252ZXJ0IHRvXG4gICAgICAgICAgICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0pIHtcbiAgICAgICAgICAgIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKVxuICAgICAgICAgICAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgICAgICAgICAgIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKVxuXG4gICAgICAgICAgICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWx0VmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSlcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkpIHx8XG4gICAgICAgICAgICAgICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICFhLmhhcyhhbHRWYWx1ZSkgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gICAgICAgICAgICAvLyBwYWlyd2lzZS5cbiAgICAgICAgICAgIHZhciBzZXQgPSBudWxsXG4gICAgICAgICAgICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV0gLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgICAgICAgICAgIC8vIHRvIGNoZWNrIHRoaXMgaW1wcm92ZXMgdGhlIHdvcnN0IGNhc2Ugc2NlbmFyaW8gaW5zdGVhZC5cblxuICAgICAgICAgICAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBzZXQgPSBuZXcgU2V0KClcbiAgICAgICAgICAgICAgICB9IC8vIElmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2Vjb25kIHNldCBpdHMgYW4gbm90IG51bGxcbiAgICAgICAgICAgICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAgICAgICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgICAgICAgICAgIC8vIE8obiBsb2cgbikgY29tcGxleGl0eSB3ZSBoYXZlIHRvIGNvcHkgdGhlc2UgdmFsdWVzIGluIGEgbmV3IHNldCBmaXJzdC5cblxuICAgICAgICAgICAgICAgIHNldC5hZGQodmFsKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlIC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGlmICghc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHNldCA9IG5ldyBTZXQoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldC5hZGQodmFsKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYilcblxuICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldIC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgICAgICAgICAgIGlmIChfdHlwZW9mKF92YWwpID09PSAnb2JqZWN0JyAmJiBfdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAhc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgICAhYS5oYXMoX3ZhbCkgJiZcbiAgICAgICAgICAgICAgICAgICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gc2V0LnNpemUgPT09IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gICAgICAgICAgICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAgICAgICAgICAgLy8gICBNYXAoW1t7fSwgJ2EnXSwgW3t9LCAnYiddXSkgdnMgTWFwKFtbe30sICdiJ10sIFt7fSwgJ2EnXV0pXG4gICAgICAgICAgICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgICAgICAgICAgIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIga2V5MiA9IHNldFZhbHVlc1tpXVxuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpbm5lckRlZXBFcXVhbChrZXkxLCBrZXkyLCBzdHJpY3QsIG1lbW8pICYmXG4gICAgICAgICAgICAgICAgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShrZXkyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0gbnVsbFxuICAgICAgICAgICAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9hRW50cmllcyRpID0gX3NsaWNlZFRvQXJyYXkoYUVudHJpZXNbaV0sIDIpLFxuICAgICAgICAgICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICAgICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV1cblxuICAgICAgICAgICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBzZXQgPSBuZXcgU2V0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXQuYWRkKGtleSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgICAgICAgICAgIC8vIGFsbW9zdCBhbGwgcG9zc2libGUgY2FzZXMuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkpIHx8XG4gICAgICAgICAgICAgICAgICAhaW5uZXJEZWVwRXF1YWwoaXRlbTEsIGl0ZW0yLCBzdHJpY3QsIG1lbW8pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2UgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGxcbiAgICAgICAgICAgICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgICAgICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICAgICAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSBuZXcgU2V0KClcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpXG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgIHZhciBfYkVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShiRW50cmllc1tfaTJdLCAyKSxcbiAgICAgICAgICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV1cblxuICAgICAgICAgICAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgIXN0cmljdCAmJlxuICAgICAgICAgICAgICAgICAgKCFhLmhhcyhrZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmXG4gICAgICAgICAgICAgICAgICAhbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgZmFsc2UsIG1lbW8pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gc2V0LnNpemUgPT09IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gICAgICAgICAgICAvLyBTZXRzIGFuZCBtYXBzIGRvbid0IGhhdmUgdGhlaXIgZW50cmllcyBhY2Nlc3NpYmxlIHZpYSBub3JtYWwgb2JqZWN0XG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIGkgPSAwXG5cbiAgICAgICAgICAgIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgICAgICAgICAgICBpZiAoIW1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eShiLCBpKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaW5uZXJEZWVwRXF1YWwoYVtpXSwgYltpXSwgc3RyaWN0LCBtZW1vcylcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgaXMgc3BhcnNlLlxuICAgICAgICAgICAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSlcblxuICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3BlcnR5KGIsIGtleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gVGhlIHBhaXIgbXVzdCBoYXZlIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS5cbiAgICAgICAgICAgIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBfa2V5ID0ga2V5c1tpXVxuXG4gICAgICAgICAgICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrTG9vc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICAgICAgICAgICAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gICAgICAgICAgICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWwsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBmaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGFycmF5LWZpbHRlciAqLyAnLi9ub2RlX21vZHVsZXMvYXJyYXktZmlsdGVyL2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ0JpZ0ludDY0QXJyYXknLFxuICAgICAgICAgICAgICAgICdCaWdVaW50NjRBcnJheScsXG4gICAgICAgICAgICAgICAgJ0Zsb2F0MzJBcnJheScsXG4gICAgICAgICAgICAgICAgJ0Zsb2F0NjRBcnJheScsXG4gICAgICAgICAgICAgICAgJ0ludDE2QXJyYXknLFxuICAgICAgICAgICAgICAgICdJbnQzMkFycmF5JyxcbiAgICAgICAgICAgICAgICAnSW50OEFycmF5JyxcbiAgICAgICAgICAgICAgICAnVWludDE2QXJyYXknLFxuICAgICAgICAgICAgICAgICdVaW50MzJBcnJheScsXG4gICAgICAgICAgICAgICAgJ1VpbnQ4QXJyYXknLFxuICAgICAgICAgICAgICAgICdVaW50OENsYW1wZWRBcnJheScsXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2xpYi9heGlvcyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vdXRpbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIHNldHRsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi9jb3JlL3NldHRsZSAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgY29va2llcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi9oZWxwZXJzL2Nvb2tpZXMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBidWlsZFVSTCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi9oZWxwZXJzL2J1aWxkVVJMICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGJ1aWxkRnVsbFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvcmUvYnVpbGRGdWxsUGF0aCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIHBhcnNlSGVhZGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgaXNVUkxTYW1lT3JpZ2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBjcmVhdGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29yZS9jcmVhdGVFcnJvciAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGFcbiAgICAgICAgICAgICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnNcblxuICAgICAgICAgICAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgICAgICAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgICAgICAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnXG4gICAgICAgICAgICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSlcbiAgICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID1cbiAgICAgICAgICAgICAgICAgICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybClcbiAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKFxuICAgICAgICAgICAgICAgIGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgICAgICAgICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0XG5cbiAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgICAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVVSTCAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDBcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9XG4gICAgICAgICAgICAgICAgICAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZURhdGEgPVxuICAgICAgICAgICAgICAgICAgIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgICAgICAgICAgID8gcmVxdWVzdC5yZXNwb25zZVRleHRcbiAgICAgICAgICAgICAgICAgICAgOiByZXF1ZXN0LnJlc3BvbnNlXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSlcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbnVsbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgICAgICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVxdWVzdCBhYm9ydGVkJyxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbnVsbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBudWxsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgICAgICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJ1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICdFQ09OTkFCT1JURUQnLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBudWxsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgICAgICAgICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICAgICAgICAgICAgdmFyIHhzcmZWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJlxuICAgICAgICAgICAgICAgICAgY29uZmlnLnhzcmZDb29raWVOYW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICAgICAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB1dGlscy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHNcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAgICAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdC51cGxvYWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICdwcm9ncmVzcycsXG4gICAgICAgICAgICAgICAgICBjb25maWcub25VcGxvYWRQcm9ncmVzc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAgICAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICAgICAgICAgIHJlamVjdChjYW5jZWwpXG4gICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbnVsbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGEgPSBudWxsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2hlbHBlcnMvYmluZCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIEF4aW9zID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NvcmUvQXhpb3MgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgbWVyZ2VDb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vY29yZS9tZXJnZUNvbmZpZyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9kZWZhdWx0cyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAgICAgICAgICAgKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKVxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dClcblxuICAgICAgICAgICAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgICAgICAgICAgIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KVxuXG4gICAgICAgICAgICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgICAgICAgICAgIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dClcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG4gICAgICAgICAgdmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpXG5cbiAgICAgICAgICAvLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbiAgICAgICAgICBheGlvcy5BeGlvcyA9IEF4aW9zXG5cbiAgICAgICAgICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gICAgICAgICAgYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbiAgICAgICAgICBheGlvcy5DYW5jZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vY2FuY2VsL0NhbmNlbCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGF4aW9zLkNhbmNlbFRva2VuID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NhbmNlbC9DYW5jZWxUb2tlbiAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgYXhpb3MuaXNDYW5jZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vY2FuY2VsL2lzQ2FuY2VsICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8vIEV4cG9zZSBhbGwvc3ByZWFkXG4gICAgICAgICAgYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgfVxuICAgICAgICAgIGF4aW9zLnNwcmVhZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9oZWxwZXJzL3NwcmVhZCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbiAgICAgICAgICBheGlvcy5pc0F4aW9zRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaGVscGVycy9pc0F4aW9zRXJyb3IgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGF4aW9zXG5cbiAgICAgICAgICAvLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3NcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IENhbmNlbFxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBDYW5jZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vQ2FuY2VsICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGNsYXNzXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVByb21pc2VcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpc1xuICAgICAgICAgICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAgICAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKVxuICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMucmVhc29uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICAgICAgICAgICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICAgICAgICAgICAgdmFyIGNhbmNlbFxuICAgICAgICAgICAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICAgICAgICAgICAgY2FuY2VsID0gY1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgY2FuY2VsOiBjYW5jZWwsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlblxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgYnVpbGRVUkwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2hlbHBlcnMvYnVpbGRVUkwgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL0ludGVyY2VwdG9yTWFuYWdlciAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2Rpc3BhdGNoUmVxdWVzdCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgbWVyZ2VDb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vbWVyZ2VDb25maWcgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZ1xuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICAgICAgICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICAgICAgICAgICAqL1xuICAgICAgICAgIEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgICAgICAgICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgICAgICAgICAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fVxuICAgICAgICAgICAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKVxuXG4gICAgICAgICAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICAgICAgICAgICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgICAgICAgICAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgICAgICAgICAgIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF1cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZylcblxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgICAgICAgICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZylcbiAgICAgICAgICAgIHJldHVybiBidWlsZFVSTChcbiAgICAgICAgICAgICAgY29uZmlnLnVybCxcbiAgICAgICAgICAgICAgY29uZmlnLnBhcmFtcyxcbiAgICAgICAgICAgICAgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXJcbiAgICAgICAgICAgICkucmVwbGFjZSgvXlxcPy8sICcnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xuICAgICAgICAgIHV0aWxzLmZvckVhY2goXG4gICAgICAgICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAgICAgICAgICAgICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICAgICAgICAgICAgICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgICBtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG5cbiAgICAgICAgICB1dGlscy5mb3JFYWNoKFxuICAgICAgICAgICAgWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLFxuICAgICAgICAgICAgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAgICAgICAgICAgICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICAgICAgICAgICAgICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgICBtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aW9zXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vdXRpbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBmdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBJbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICAgICAgICAgICAgcmVqZWN0ZWQ6IHJlamVjdGVkLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBJbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAgICAgICAgICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gICAgICAgICAgICovXG4gICAgICAgICAgSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICAgICAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm4oaClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlclxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBpc0Fic29sdXRlVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBjb21iaW5lVVJMcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vaGVscGVycy9jb21iaW5lVVJMcyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAgICAgICAgICAgKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gICAgICAgICAgICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICAgICAgICAgICAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZFVSTFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGVuaGFuY2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9lbmhhbmNlRXJyb3IgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAgICAgICAgICAgKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICAgICAgICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi90cmFuc2Zvcm1EYXRhICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgaXNDYW5jZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NhbmNlbC9pc0NhbmNlbCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9kZWZhdWx0cyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKVxuXG4gICAgICAgICAgICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fVxuXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgICAgIGNvbmZpZy5kYXRhLFxuICAgICAgICAgICAgICBjb25maWcuaGVhZGVycyxcbiAgICAgICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgICAgICAgICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgICAgICAgICAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgICAgICAgICAgICBjb25maWcuaGVhZGVyc1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB1dGlscy5mb3JFYWNoKFxuICAgICAgICAgICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXJcblxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpXG5cbiAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpXG5cbiAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICAgICAgICAgICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBlcnJvci5jb25maWcgPSBjb25maWdcbiAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlXG4gICAgICAgICAgICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlXG5cbiAgICAgICAgICAgIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBNb3ppbGxhXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAgICAgICAgICAgLy8gQXhpb3NcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICAgICAgICAgICAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9XG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge31cblxuICAgICAgICAgICAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXVxuICAgICAgICAgICAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ11cbiAgICAgICAgICAgIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAgICAgICAgICAgJ2Jhc2VVUkwnLFxuICAgICAgICAgICAgICAndHJhbnNmb3JtUmVxdWVzdCcsXG4gICAgICAgICAgICAgICd0cmFuc2Zvcm1SZXNwb25zZScsXG4gICAgICAgICAgICAgICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAgICAgICAgICAgJ3RpbWVvdXQnLFxuICAgICAgICAgICAgICAndGltZW91dE1lc3NhZ2UnLFxuICAgICAgICAgICAgICAnd2l0aENyZWRlbnRpYWxzJyxcbiAgICAgICAgICAgICAgJ2FkYXB0ZXInLFxuICAgICAgICAgICAgICAncmVzcG9uc2VUeXBlJyxcbiAgICAgICAgICAgICAgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAgICAgICAgICAgJ3hzcmZIZWFkZXJOYW1lJyxcbiAgICAgICAgICAgICAgJ29uVXBsb2FkUHJvZ3Jlc3MnLFxuICAgICAgICAgICAgICAnb25Eb3dubG9hZFByb2dyZXNzJyxcbiAgICAgICAgICAgICAgJ2RlY29tcHJlc3MnLFxuICAgICAgICAgICAgICAnbWF4Q29udGVudExlbmd0aCcsXG4gICAgICAgICAgICAgICdtYXhCb2R5TGVuZ3RoJyxcbiAgICAgICAgICAgICAgJ21heFJlZGlyZWN0cycsXG4gICAgICAgICAgICAgICd0cmFuc3BvcnQnLFxuICAgICAgICAgICAgICAnaHR0cEFnZW50JyxcbiAgICAgICAgICAgICAgJ2h0dHBzQWdlbnQnLFxuICAgICAgICAgICAgICAnY2FuY2VsVG9rZW4nLFxuICAgICAgICAgICAgICAnc29ja2V0UGF0aCcsXG4gICAgICAgICAgICAgICdyZXNwb25zZUVuY29kaW5nJyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ11cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2goXG4gICAgICAgICAgICAgIHZhbHVlRnJvbUNvbmZpZzJLZXlzLFxuICAgICAgICAgICAgICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpXG5cbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2goXG4gICAgICAgICAgICAgIGRlZmF1bHRUb0NvbmZpZzJLZXlzLFxuICAgICAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAgICAgICAgICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAgICAgICAgICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAgICAgICAgICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpXG5cbiAgICAgICAgICAgIHZhciBvdGhlcktleXMgPSBPYmplY3Qua2V5cyhjb25maWcxKVxuICAgICAgICAgICAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTFcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpXG5cbiAgICAgICAgICAgIHJldHVybiBjb25maWdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgY3JlYXRlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vY3JlYXRlRXJyb3IgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXNcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXJlc3BvbnNlLnN0YXR1cyB8fFxuICAgICAgICAgICAgICAhdmFsaWRhdGVTdGF0dXMgfHxcbiAgICAgICAgICAgICAgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vdXRpbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAgICAgICAgICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgICAgICAgICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgcHJvY2Vzcy9icm93c2VyICovICcuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZSAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJlxuICAgICAgICAgICAgICB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgICAgICAgICB2YXIgYWRhcHRlclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgICAgICAgICAgICBhZGFwdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgICAvKiEgLi9hZGFwdGVycy94aHIgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICAgICAgICAgICAgYWRhcHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgICAgLyohIC4vYWRhcHRlcnMvaHR0cCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcydcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gICAgICAgICAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBbXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJylcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICAgICAgICAgICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICAgICAgICAgICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgICAgICAgICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgICAgICAgICAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgICAgICAgICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04J1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCdcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcblxuICAgICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6IFtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElnbm9yZSAqL1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICAgICAgICAgICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRpbWVvdXQ6IDAsXG5cbiAgICAgICAgICAgIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gICAgICAgICAgICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgICAgICAgICAgIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICAgICAgICAgICAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgICAgICAgICAgIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXRpbHMuZm9yRWFjaChcbiAgICAgICAgICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAgICAgICAgICAgICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcblxuICAgICAgICAgIHV0aWxzLmZvckVhY2goXG4gICAgICAgICAgICBbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHNcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLy4uL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8lM0EvZ2ksICc6JylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLyUyNC9nLCAnJCcpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8lMkMvZ2ksICcsJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8lNUIvZ2ksICdbJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLyU1RC9naSwgJ10nKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICAgICAgICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVybFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZFBhcmFtc1xuICAgICAgICAgICAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gW11cblxuICAgICAgICAgICAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAga2V5ID0ga2V5ICsgJ1tdJ1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YWwgPSBbdmFsXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgICAgICAgICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKVxuICAgICAgICAgICAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgICAgICAgICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArXG4gICAgICAgICAgICAgICAgICAnLycgK1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICAgICAgICAgICAgOiBiYXNlVVJMXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKVxuICAgICAgICAgICAgPyAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAgICAgICAgICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICBzZWN1cmVcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gW11cbiAgICAgICAgICAgICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJylcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJylcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbFxuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgOiAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgICAgICAgICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICAgICAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoKVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgICAgICAgICAgIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgICAgICAgICAgIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAgICAgICAgICAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gICAgICAgICAgICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnICYmIHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLy4uL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpXG4gICAgICAgICAgICA/IC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgICAgICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luVVJMXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IHVybFxuXG4gICAgICAgICAgICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpXG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpXG5cbiAgICAgICAgICAgICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbFxuICAgICAgICAgICAgICAgICAgICAgID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaFxuICAgICAgICAgICAgICAgICAgICAgID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoXG4gICAgICAgICAgICAgICAgICAgICAgPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTpcbiAgICAgICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSB1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKVxuICAgICAgICAgICAgICAgICAgICA/IHJlc29sdmVVUkwocmVxdWVzdFVSTClcbiAgICAgICAgICAgICAgICAgICAgOiByZXF1ZXN0VVJMXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3RcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgIDogLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAgICAgICAgICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWROYW1lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmXG4gICAgICAgICAgICAgICAgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWVcbiAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4gICAgICAgICAgLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xuICAgICAgICAgIHZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgICAgICAgICAgICdhZ2UnLFxuICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nLFxuICAgICAgICAgICAgJ2NvbnRlbnQtbGVuZ3RoJyxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnLFxuICAgICAgICAgICAgJ2V0YWcnLFxuICAgICAgICAgICAgJ2V4cGlyZXMnLFxuICAgICAgICAgICAgJ2Zyb20nLFxuICAgICAgICAgICAgJ2hvc3QnLFxuICAgICAgICAgICAgJ2lmLW1vZGlmaWVkLXNpbmNlJyxcbiAgICAgICAgICAgICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgICAgICAgICAgICdsYXN0LW1vZGlmaWVkJyxcbiAgICAgICAgICAgICdsb2NhdGlvbicsXG4gICAgICAgICAgICAnbWF4LWZvcndhcmRzJyxcbiAgICAgICAgICAgICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgICAgICAgICAgICdyZWZlcmVyJyxcbiAgICAgICAgICAgICdyZXRyeS1hZnRlcicsXG4gICAgICAgICAgICAndXNlci1hZ2VudCcsXG4gICAgICAgICAgXVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAgICAgICAgICAgKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAgICAgICAgICAgKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gICAgICAgICAgICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSB7fVxuICAgICAgICAgICAgdmFyIGtleVxuICAgICAgICAgICAgdmFyIHZhbFxuICAgICAgICAgICAgdmFyIGlcblxuICAgICAgICAgICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICAgICAgICAgICAgaSA9IGxpbmUuaW5kZXhPZignOicpXG4gICAgICAgICAgICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpXG5cbiAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAgICAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgYGBganNcbiAgICAgICAgICAgKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICAgICAgICAgICAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAgICAgICAgICAgKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgKiAgYGBgXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICBgYGBqc1xuICAgICAgICAgICAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gICAgICAgICAgICogIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2hlbHBlcnMvYmluZCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuICAgICAgICAgIC8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbiAgICAgICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB2YWwgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgIWlzVW5kZWZpbmVkKHZhbCkgJiZcbiAgICAgICAgICAgICAgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsICYmIHZhbC5idWZmZXIgJiYgdmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKVxuICAgICAgICAgICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gICAgICAgICAgICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogd2ViIHdvcmtlcnM6XG4gICAgICAgICAgICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gICAgICAgICAgICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIHJlYWN0LW5hdGl2ZTpcbiAgICAgICAgICAgKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICAgICAgICAgICAqIG5hdGl2ZXNjcmlwdFxuICAgICAgICAgICAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICAgICAgICAgICAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAgICAgICAgICAgKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgICAgICAgICAgICBvYmogPSBbb2JqXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iailcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICAgICAgICAgICAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAgICAgICAgICAgKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogYGBganNcbiAgICAgICAgICAgKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gICAgICAgICAgICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fVxuICAgICAgICAgICAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbClcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICAgICAgICAgICAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgICAgICAgICAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYVtrZXldID0gdmFsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweGZlZmYpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgICAgICAgICAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgICAgICAgICAgIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gICAgICAgICAgICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgICAgICBpc051bWJlcjogaXNOdW1iZXIsXG4gICAgICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICAgICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNEYXRlOiBpc0RhdGUsXG4gICAgICAgICAgICBpc0ZpbGU6IGlzRmlsZSxcbiAgICAgICAgICAgIGlzQmxvYjogaXNCbG9iLFxuICAgICAgICAgICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgICAgIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgICAgICAgICAgIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgICAgICAgICAgIGZvckVhY2g6IGZvckVhY2gsXG4gICAgICAgICAgICBtZXJnZTogbWVyZ2UsXG4gICAgICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgICAgIHRyaW06IHRyaW0sXG4gICAgICAgICAgICBzdHJpcEJPTTogc3RyaXBCT00sXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGdldC1pbnRyaW5zaWMgKi8gJy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLyAqLyAnLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcbiAgICAgICAgICAgIHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50cmluc2ljXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGZ1bmN0aW9uLWJpbmQgKi8gJy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGdldC1pbnRyaW5zaWMgKi8gJy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKVxuICAgICAgICAgIHZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpXG4gICAgICAgICAgdmFyICRyZWZsZWN0QXBwbHkgPVxuICAgICAgICAgICAgR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSlcblxuICAgICAgICAgIHZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSlcbiAgICAgICAgICB2YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpXG4gICAgICAgICAgdmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKVxuXG4gICAgICAgICAgaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgJGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcbiAgICAgICAgICAgICAgJGRlZmluZVByb3BlcnR5ID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpXG4gICAgICAgICAgICBpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpXG4gICAgICAgICAgICAgIGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIGxlbmd0aCwgcGx1cyB0aGUgcmVjZWl2ZXIsIG1pbnVzIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIHJlY2VpdmVyKVxuICAgICAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eShmdW5jLCAnbGVuZ3RoJywge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xuICAgICAgICAgIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISB1dGlsICovICcuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGFzc2VydCAqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2Fzc2VydC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgZnVuY3Rpb24gbm93KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAgICAgdmFyIGNvbnNvbGVcbiAgICAgICAgICB2YXIgdGltZXMgPSB7fVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18uZyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZy5jb25zb2xlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGVcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZSA9IHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IFtcbiAgICAgICAgICAgIFtsb2csICdsb2cnXSxcbiAgICAgICAgICAgIFtpbmZvLCAnaW5mbyddLFxuICAgICAgICAgICAgW3dhcm4sICd3YXJuJ10sXG4gICAgICAgICAgICBbZXJyb3IsICdlcnJvciddLFxuICAgICAgICAgICAgW3RpbWUsICd0aW1lJ10sXG4gICAgICAgICAgICBbdGltZUVuZCwgJ3RpbWVFbmQnXSxcbiAgICAgICAgICAgIFt0cmFjZSwgJ3RyYWNlJ10sXG4gICAgICAgICAgICBbZGlyLCAnZGlyJ10sXG4gICAgICAgICAgICBbY29uc29sZUFzc2VydCwgJ2Fzc2VydCddLFxuICAgICAgICAgIF1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICAgICAgICAgIHZhciBmID0gdHVwbGVbMF1cbiAgICAgICAgICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgICAgICAgICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbiAgICAgICAgICBmdW5jdGlvbiBsb2coKSB7fVxuXG4gICAgICAgICAgZnVuY3Rpb24gaW5mbygpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB3YXJuKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgICAgICAgICB0aW1lc1tsYWJlbF0gPSBub3coKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gdGltZXNbbGFiZWxdXG4gICAgICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGxhYmVsOiAnICsgbGFiZWwpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5vdygpIC0gdGltZVxuICAgICAgICAgICAgY29uc29sZS5sb2cobGFiZWwgKyAnOiAnICsgZHVyYXRpb24gKyAnbXMnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRyYWNlKCkge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigpXG4gICAgICAgICAgICBlcnIubmFtZSA9ICdUcmFjZSdcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZGlyKG9iamVjdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyAnXFxuJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICB2YXIgYXJyID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAgICAgICAgIGFzc2VydC5vayhmYWxzZSwgdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJyKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBvYmplY3Qta2V5cyAqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBoYXNTeW1ib2xzID1cbiAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnXG5cbiAgICAgICAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgICAgdmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXRcbiAgICAgICAgICB2YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG5cbiAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge31cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG9yaWdEZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KVxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgIGZvciAodmFyIF8gaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgLy8ganNjczppZ25vcmUgZGlzYWxsb3dVbnVzZWRWYXJpYWJsZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gb2JqLnggPT09IG9ialxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvKiB0aGlzIGlzIElFIDguICovXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9XG4gICAgICAgICAgICBvcmlnRGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpXG5cbiAgICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBvYmplY3QgJiYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgIG9yaWdEZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqZWN0W25hbWVdID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKG1hcClcbiAgICAgICAgICAgIGlmIChoYXNTeW1ib2xzKSB7XG4gICAgICAgICAgICAgIHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgIHByb3BzW2ldLFxuICAgICAgICAgICAgICAgIG1hcFtwcm9wc1tpXV0sXG4gICAgICAgICAgICAgICAgcHJlZGljYXRlc1twcm9wc1tpXV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9yc1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGdldC1pbnRyaW5zaWMgKi8gJy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnKVxuICAgICAgICAgIGlmICgkZ09QRCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgJGdPUEQoW10sICdsZW5ndGgnKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG4gICAgICAgICAgICAgICRnT1BEID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gJGdPUERcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9lczYtb2JqZWN0LWFzc2lnbi9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICAgICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIGZpcnN0U291cmNlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0byA9IE9iamVjdCh0YXJnZXQpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuICAgICAgICAgICAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSlcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPCBsZW47XG4gICAgICAgICAgICAgICAgbmV4dEluZGV4KytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XVxuICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KVxuICAgICAgICAgICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhc3NpZ24sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgICAgICBhc3NpZ246IGFzc2lnbixcbiAgICAgICAgICAgIHBvbHlmaWxsOiBwb2x5ZmlsbCxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNvbnNvbGUtYnJvd3NlcmlmeSAqLyAnLi9ub2RlX21vZHVsZXMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gICAgICAgICAgLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICAgICAgICAgIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAgICAgICAgIC8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAgICAgICAgICAvLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gICAgICAgICAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gICAgICAgICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAgICAgICAgIC8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAgICAgICAgIC8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICAgICAgICAvLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gICAgICAgICAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gICAgICAgICAgLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4gICAgICAgICAgLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICAgICAgICAgIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAgICAgICB2YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG4gICAgICAgICAgdmFyIFJlZmxlY3RBcHBseSA9XG4gICAgICAgICAgICBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgID8gUi5hcHBseVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgUmVmbGVjdE93bktleXNcbiAgICAgICAgICBpZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xuICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KFxuICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIE51bWJlcklzTmFOID1cbiAgICAgICAgICAgIE51bWJlci5pc05hTiB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKVxuICAgICAgICAgIH1cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlclxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlXG5cbiAgICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbiAgICAgICAgICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyXG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWRcbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDBcbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWRcblxuICAgICAgICAgIC8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuICAgICAgICAgIC8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4gICAgICAgICAgdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMFxuXG4gICAgICAgICAgZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICtcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBsaXN0ZW5lclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArXG4gICAgICAgICAgICAgICAgICAgIGFyZyArXG4gICAgICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcbiAgICAgICAgICAvLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgICAgICdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArXG4gICAgICAgICAgICAgICAgICBuICtcbiAgICAgICAgICAgICAgICAgICcuJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICAgICAgICAgICAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnNcbiAgICAgICAgICAgIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICAgICAgICAgIHZhciBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJ1xuXG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzXG4gICAgICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICBlbHNlIGlmICghZG9FcnJvcikgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgICAgICAgICAgIGlmIChkb0Vycm9yKSB7XG4gICAgICAgICAgICAgIHZhciBlclxuICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSBlciA9IGFyZ3NbMF1cbiAgICAgICAgICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgICAgICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIHRocm93IGVyIC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgZXJyLmNvbnRleHQgPSBlclxuICAgICAgICAgICAgICB0aHJvdyBlcnIgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV1cblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aFxuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICAgICAgICAgICAgdmFyIG1cbiAgICAgICAgICAgIHZhciBldmVudHNcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1xuXG4gICAgICAgICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKVxuXG4gICAgICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50c1xuICAgICAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICAgICAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAgICAgICAgICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgICAgICAgICAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZW1pdChcbiAgICAgICAgICAgICAgICAgICduZXdMaXN0ZW5lcicsXG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgICAgICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50c1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgICAgICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyXG4gICAgICAgICAgICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgICAgICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZFxuICAgICAgICAgICAgICAgICAgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXVxuICAgICAgICAgICAgICAgICAgOiBbZXhpc3RpbmcsIGxpc3RlbmVyXVxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcilcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICAgICAgICAgICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KVxuICAgICAgICAgICAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICAgICAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nKHR5cGUpICtcbiAgICAgICAgICAgICAgICAgICAgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZydcbiAgICAgICAgICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXRcbiAgICAgICAgICAgICAgICB3LnR5cGUgPSB0eXBlXG4gICAgICAgICAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aFxuICAgICAgICAgICAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbGlzdGVuZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyXG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBsaXN0ZW5lclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maXJlZCkge1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKVxuICAgICAgICAgICAgICB0aGlzLmZpcmVkID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldClcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgICBmaXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHdyYXBGbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKVxuICAgICAgICAgICAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyXG4gICAgICAgICAgICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbGlzdGVuZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBsaXN0ZW5lclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXJcblxuICAgICAgICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcilcblxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzXG4gICAgICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzXG5cbiAgICAgICAgICAgIGxpc3QgPSBldmVudHNbdHlwZV1cbiAgICAgICAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzXG5cbiAgICAgICAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gLTFcblxuICAgICAgICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lclxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHJldHVybiB0aGlzXG5cbiAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKSBsaXN0LnNoaWZ0KClcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSBldmVudHNbdHlwZV0gPSBsaXN0WzBdXG5cbiAgICAgICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lclxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGlcblxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzXG4gICAgICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzXG5cbiAgICAgICAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDBcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICAgICAgICAgIGVsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpXG4gICAgICAgICAgICAgIHZhciBrZXlcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWVcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJylcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDBcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzXG5cbiAgICAgICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdXG5cbiAgICAgICAgICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdXG4gICAgICAgICAgICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW11cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl1cblxuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFxuICAgICAgICAgICAgICA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKVxuICAgICAgICAgICAgICA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudFxuICAgICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV1cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobilcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBjb3B5W2ldID0gYXJyW2ldXG4gICAgICAgICAgICByZXR1cm4gY29weVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgICAgICAgICAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXVxuICAgICAgICAgICAgbGlzdC5wb3AoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcilcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7XG4gICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKFxuICAgICAgICAgICAgZW1pdHRlcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgICAgICAgICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgICAgICAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGFyZylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgK1xuICAgICAgICAgICAgICAgICAgdHlwZW9mIGVtaXR0ZXJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICAgICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4sIGN0eCkge1xuICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IG9iai5sZW5ndGhcbiAgICAgICAgICAgIGlmIChsID09PSArbCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iailcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL2Jyb3dzZXIuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL2Jyb3dzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgLyogZXNsaW50LWVudiBicm93c2VyICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPVxuICAgICAgICAgICAgdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgPyBzZWxmLkZvcm1EYXRhIDogd2luZG93LkZvcm1EYXRhXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxuICAgICAgICAgIHZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJ1xuICAgICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgICB2YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblxuICAgICAgICAgICAgdmFyIGJvdW5kXG4gICAgICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aClcbiAgICAgICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdW5kID0gRnVuY3Rpb24oXG4gICAgICAgICAgICAgICdiaW5kZXInLFxuICAgICAgICAgICAgICAncmV0dXJuIGZ1bmN0aW9uICgnICtcbiAgICAgICAgICAgICAgICBib3VuZEFyZ3Muam9pbignLCcpICtcbiAgICAgICAgICAgICAgICAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nXG4gICAgICAgICAgICApKGJpbmRlcilcblxuICAgICAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fVxuICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlXG4gICAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpXG4gICAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9pbXBsZW1lbnRhdGlvbiAqLyAnLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHVuZGVmaW5lZFxuXG4gICAgICAgICAgdmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yXG4gICAgICAgICAgdmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uXG4gICAgICAgICAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3JcblxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICAgIHZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuICRGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnXG4gICAgICAgICAgICAgICkoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgICAgaWYgKCRnT1BEKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAkZ09QRCh7fSwgJycpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICRnT1BEID0gbnVsbCAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoKVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuICAgICAgICAgICAgPyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzLmNhbGxlZSAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd1R5cGVFcnJvclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd1R5cGVFcnJvclxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgOiB0aHJvd1R5cGVFcnJvclxuXG4gICAgICAgICAgdmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGhhcy1zeW1ib2xzICovICcuL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcydcbiAgICAgICAgICApKClcblxuICAgICAgICAgIHZhciBnZXRQcm90byA9XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB4Ll9fcHJvdG9fX1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbiAgICAgICAgICB2YXIgbmVlZHNFdmFsID0ge31cblxuICAgICAgICAgIHZhciBUeXBlZEFycmF5ID1cbiAgICAgICAgICAgIHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpXG5cbiAgICAgICAgICB2YXIgSU5UUklOU0lDUyA9IHtcbiAgICAgICAgICAgICclQWdncmVnYXRlRXJyb3IlJzpcbiAgICAgICAgICAgICAgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBBZ2dyZWdhdGVFcnJvcixcbiAgICAgICAgICAgICclQXJyYXklJzogQXJyYXksXG4gICAgICAgICAgICAnJUFycmF5QnVmZmVyJSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzXG4gICAgICAgICAgICAgID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG4gICAgICAgICAgICAnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcbiAgICAgICAgICAgICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG4gICAgICAgICAgICAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuICAgICAgICAgICAgJyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG4gICAgICAgICAgICAnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcbiAgICAgICAgICAgICclQm9vbGVhbiUnOiBCb29sZWFuLFxuICAgICAgICAgICAgJyVEYXRhVmlldyUnOlxuICAgICAgICAgICAgICB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG4gICAgICAgICAgICAnJURhdGUlJzogRGF0ZSxcbiAgICAgICAgICAgICclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcbiAgICAgICAgICAgICclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcbiAgICAgICAgICAgICclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcbiAgICAgICAgICAgICclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcbiAgICAgICAgICAgICclRXJyb3IlJzogRXJyb3IsXG4gICAgICAgICAgICAnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG4gICAgICAgICAgICAnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG4gICAgICAgICAgICAnJUZsb2F0MzJBcnJheSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAgICclRmxvYXQ2NEFycmF5JSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuICAgICAgICAgICAgJyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuICAgICAgICAgICAgJyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG4gICAgICAgICAgICAnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcbiAgICAgICAgICAgICclSW50OEFycmF5JSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuICAgICAgICAgICAgJyVJbnQxNkFycmF5JSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG4gICAgICAgICAgICAnJUludDMyQXJyYXklJzpcbiAgICAgICAgICAgICAgdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcbiAgICAgICAgICAgICclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG4gICAgICAgICAgICAnJWlzTmFOJSc6IGlzTmFOLFxuICAgICAgICAgICAgJyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzXG4gICAgICAgICAgICAgID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuICAgICAgICAgICAgJyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9sc1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcbiAgICAgICAgICAgICclTWF0aCUnOiBNYXRoLFxuICAgICAgICAgICAgJyVOdW1iZXIlJzogTnVtYmVyLFxuICAgICAgICAgICAgJyVPYmplY3QlJzogT2JqZWN0LFxuICAgICAgICAgICAgJyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG4gICAgICAgICAgICAnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuICAgICAgICAgICAgJyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG4gICAgICAgICAgICAnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcbiAgICAgICAgICAgICclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuICAgICAgICAgICAgJyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcbiAgICAgICAgICAgICclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuICAgICAgICAgICAgJyVSZWdFeHAlJzogUmVnRXhwLFxuICAgICAgICAgICAgJyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG4gICAgICAgICAgICAnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuICAgICAgICAgICAgJyVTaGFyZWRBcnJheUJ1ZmZlciUnOlxuICAgICAgICAgICAgICB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IFNoYXJlZEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgJyVTdHJpbmclJzogU3RyaW5nLFxuICAgICAgICAgICAgJyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzXG4gICAgICAgICAgICAgID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcbiAgICAgICAgICAgICclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG4gICAgICAgICAgICAnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcbiAgICAgICAgICAgICclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG4gICAgICAgICAgICAnJVVpbnQ4QXJyYXklJzpcbiAgICAgICAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcbiAgICAgICAgICAgICclVWludDhDbGFtcGVkQXJyYXklJzpcbiAgICAgICAgICAgICAgdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBVaW50OENsYW1wZWRBcnJheSxcbiAgICAgICAgICAgICclVWludDE2QXJyYXklJzpcbiAgICAgICAgICAgICAgdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuICAgICAgICAgICAgJyVVaW50MzJBcnJheSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG4gICAgICAgICAgICAnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuICAgICAgICAgICAgJyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG4gICAgICAgICAgICAnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcbiAgICAgICAgICAgICclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9JylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9JylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG4gICAgICAgICAgICAgIHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJylcbiAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmbi5wcm90b3R5cGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuICAgICAgICAgICAgICB2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJylcbiAgICAgICAgICAgICAgaWYgKGdlbikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBJTlRSSU5TSUNTW25hbWVdID0gdmFsdWVcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIExFR0FDWV9BTElBU0VTID0ge1xuICAgICAgICAgICAgJyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuICAgICAgICAgICAgJyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuICAgICAgICAgICAgJyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuICAgICAgICAgICAgJyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcbiAgICAgICAgICAgICclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogW1xuICAgICAgICAgICAgICAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsXG4gICAgICAgICAgICAgICdwcm90b3R5cGUnLFxuICAgICAgICAgICAgICAncHJvdG90eXBlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbXG4gICAgICAgICAgICAgICdHZW5lcmF0b3JGdW5jdGlvbicsXG4gICAgICAgICAgICAgICdwcm90b3R5cGUnLFxuICAgICAgICAgICAgICAncHJvdG90eXBlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG4gICAgICAgICAgICAnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuICAgICAgICAgICAgJyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcbiAgICAgICAgICAgICclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuICAgICAgICAgICAgJyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG4gICAgICAgICAgICAnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcbiAgICAgICAgICAgICclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuICAgICAgICAgICAgJyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcbiAgICAgICAgICAgICclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgZnVuY3Rpb24tYmluZCAqLyAnLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaGFzICovICcuL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KVxuICAgICAgICAgIHZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpXG4gICAgICAgICAgdmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSlcbiAgICAgICAgICB2YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpXG5cbiAgICAgICAgICAvKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG4gICAgICAgICAgdmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZ1xuICAgICAgICAgIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgICAgICAgICB2YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSlcbiAgICAgICAgICAgIHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpXG4gICAgICAgICAgICBpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3ICRTeW50YXhFcnJvcihcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgJFN5bnRheEVycm9yKFxuICAgICAgICAgICAgICAgICdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW11cbiAgICAgICAgICAgICRyZXBsYWNlKFxuICAgICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICAgIHJlUHJvcE5hbWUsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGVcbiAgICAgICAgICAgICAgICAgID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpXG4gICAgICAgICAgICAgICAgICA6IG51bWJlciB8fCBtYXRjaFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVuZCBhZGFwdGF0aW9uICovXG5cbiAgICAgICAgICB2YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG4gICAgICAgICAgICB2YXIgaW50cmluc2ljTmFtZSA9IG5hbWVcbiAgICAgICAgICAgIHZhciBhbGlhc1xuICAgICAgICAgICAgaWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcbiAgICAgICAgICAgICAgYWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXVxuICAgICAgICAgICAgICBpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnaW50cmluc2ljICcgK1xuICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGlhczogYWxpYXMsXG4gICAgICAgICAgICAgICAgbmFtZTogaW50cmluc2ljTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKVxuICAgICAgICAgICAgdmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJydcblxuICAgICAgICAgICAgdmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoXG4gICAgICAgICAgICAgICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLFxuICAgICAgICAgICAgICBhbGxvd01pc3NpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWVcbiAgICAgICAgICAgIHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZVxuXG4gICAgICAgICAgICB2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXNcbiAgICAgICAgICAgIGlmIChhbGlhcykge1xuICAgICAgICAgICAgICBpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdXG4gICAgICAgICAgICAgICRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV1cbiAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpXG4gICAgICAgICAgICAgIHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGZpcnN0ID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICBmaXJzdCA9PT0gXCInXCIgfHxcbiAgICAgICAgICAgICAgICAgIGZpcnN0ID09PSAnYCcgfHxcbiAgICAgICAgICAgICAgICAgIGxhc3QgPT09ICdcIicgfHxcbiAgICAgICAgICAgICAgICAgIGxhc3QgPT09IFwiJ1wiIHx8XG4gICAgICAgICAgICAgICAgICBsYXN0ID09PSAnYCcpICYmXG4gICAgICAgICAgICAgICAgZmlyc3QgIT09IGxhc3RcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3ICRTeW50YXhFcnJvcihcbiAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcbiAgICAgICAgICAgICAgICBza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0XG4gICAgICAgICAgICAgIGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSdcblxuICAgICAgICAgICAgICBpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dNaXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICdiYXNlIGludHJpbnNpYyBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRnT1BEICYmIGkgKyAxID49IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydClcbiAgICAgICAgICAgICAgICAgIGlzT3duID0gISFkZXNjXG5cbiAgICAgICAgICAgICAgICAgIC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuICAgICAgICAgICAgICAgICAgLy8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgIC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2VcbiAgICAgICAgICAgICAgICAgIC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG4gICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG4gICAgICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGlzT3duICYmXG4gICAgICAgICAgICAgICAgICAgICdnZXQnIGluIGRlc2MgJiZcbiAgICAgICAgICAgICAgICAgICAgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkZXNjLmdldFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXJ0XVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc093biA9IGhhc093bih2YWx1ZSwgcGFydClcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcGFydF1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbFxuICAgICAgICAgIHZhciBoYXNTeW1ib2xTaGFtID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3NoYW1zICovICcuL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhc1N5bWJvbFNoYW0oKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvYmogPSB7fVxuICAgICAgICAgICAgdmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpXG4gICAgICAgICAgICB2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSlcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcbiAgICAgICAgICAgIC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICAvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcbiAgICAgICAgICAgIC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgIC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgICAgIHZhciBzeW1WYWwgPSA0MlxuICAgICAgICAgICAgb2JqW3N5bV0gPSBzeW1WYWxcbiAgICAgICAgICAgIGZvciAoc3ltIGluIG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iailcbiAgICAgICAgICAgIGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSlcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgZnVuY3Rpb24tYmluZCAqLyAnLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChcbiAgICAgICAgICAgIEZ1bmN0aW9uLmNhbGwsXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICAgICAgICAgICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgICAgICAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICAgICAgICAgICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgICAgICAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICAgICAgICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgICAgICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGhhc1RvU3RyaW5nVGFnID1cbiAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnXG4gICAgICAgICAgdmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgY2FsbC1iaW5kL2NhbGxCb3VuZCAqLyAnLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJylcblxuICAgICAgICAgIHZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaGFzVG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgICAgJHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuICAgICAgICAgICAgICAkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cylcbiAgICAgICAgICB9KSgpXG5cbiAgICAgICAgICBpc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHMgLy8gZm9yIHRlc3RzXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHNcbiAgICAgICAgICAgID8gaXNTdGFuZGFyZEFyZ3VtZW50c1xuICAgICAgICAgICAgOiBpc0xlZ2FjeUFyZ3VtZW50c1xuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgICB2YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAgIHZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqL1xuICAgICAgICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9XG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJ1xuICAgICAgICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAgICAgICAgIHZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICAgICAgaWYgKCFoYXNUb1N0cmluZ1RhZykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKClcbiAgICAgICAgICB2YXIgR2VuZXJhdG9yRnVuY3Rpb24gPVxuICAgICAgICAgICAgZ2V0UHJvdG8gJiYgZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2VcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNUb1N0cmluZ1RhZykge1xuICAgICAgICAgICAgICB2YXIgc3RyID0gdG9TdHIuY2FsbChmbilcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFByb3RvICYmIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb25cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvaXMtbmFuL2ltcGxlbWVudGF0aW9uLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaXMtbmFuL2ltcGxlbWVudGF0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pcy1uYW4vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgY2FsbC1iaW5kICovICcuL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGRlZmluZS1wcm9wZXJ0aWVzICovICcuL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaW1wbGVtZW50YXRpb24gKi8gJy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbXBsZW1lbnRhdGlvbi5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3BvbHlmaWxsICovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vcG9seWZpbGwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3NoaW0gKi8gJy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9zaGltLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE51bWJlcilcblxuICAgICAgICAgIC8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxuICAgICAgICAgIGRlZmluZShwb2x5ZmlsbCwge1xuICAgICAgICAgICAgZ2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuICAgICAgICAgICAgc2hpbTogc2hpbSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbFxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2ltcGxlbWVudGF0aW9uICovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4gJiYgTnVtYmVyLmlzTmFOKE5hTikgJiYgIU51bWJlci5pc05hTignYScpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaXMtbmFuL3NoaW0uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgZGVmaW5lLXByb3BlcnRpZXMgKi8gJy4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vcG9seWZpbGwgKi8gJy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1OdW1iZXJJc05hTigpIHtcbiAgICAgICAgICAgIHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKClcbiAgICAgICAgICAgIGRlZmluZShOdW1iZXIsIHsgaXNOYU46IHBvbHlmaWxsIH0sIHtcbiAgICAgICAgICAgICAgaXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOICE9PSBwb2x5ZmlsbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBwb2x5ZmlsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGZvcmVhY2ggKi8gJy4vbm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgYXZhaWxhYmxlLXR5cGVkLWFycmF5cyAqLyAnLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgY2FsbC1iaW5kL2NhbGxCb3VuZCAqLyAnLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJylcbiAgICAgICAgICB2YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaGFzLXN5bWJvbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzJ1xuICAgICAgICAgICkoKVxuICAgICAgICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9XG4gICAgICAgICAgICBoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnXG5cbiAgICAgICAgICB2YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpXG5cbiAgICAgICAgICB2YXIgJGluZGV4T2YgPVxuICAgICAgICAgICAgY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgdmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpXG4gICAgICAgICAgdmFyIHRvU3RyVGFncyA9IHt9XG4gICAgICAgICAgdmFyIGdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGVzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICovICcuL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG4gICAgICAgICAgaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgX193ZWJwYWNrX3JlcXVpcmVfXy5nW3R5cGVkQXJyYXldKClcbiAgICAgICAgICAgICAgaWYgKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZhbEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ3RoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCAnICtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheSArXG4gICAgICAgICAgICAgICAgICAgICcgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy4nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycilcbiAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpXG4gICAgICAgICAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYW55VHJ1ZSA9IGZhbHNlXG4gICAgICAgICAgICBmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICBpZiAoIWFueVRydWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYW55VHJ1ZSA9IGdldHRlci5jYWxsKHZhbHVlKSA9PT0gdHlwZWRBcnJheVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8qKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gYW55VHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG4gICAgICAgICAgICAgIHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpXG4gICAgICAgICAgICAgIHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdPUEQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXMoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gMSAvIGEgPT09IDEgLyBiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBkZWZpbmUtcHJvcGVydGllcyAqLyAnLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgY2FsbC1iaW5kICovICcuL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2ltcGxlbWVudGF0aW9uICovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9wb2x5ZmlsbCAqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3BvbHlmaWxsLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgc2hpbSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9zaGltICovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpXG5cbiAgICAgICAgICBkZWZpbmUocG9seWZpbGwsIHtcbiAgICAgICAgICAgIGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcbiAgICAgICAgICAgIHNoaW06IHNoaW0sXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWZpbGxcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9pbXBsZW1lbnRhdGlvbiAqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vcG9seWZpbGwgKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgZGVmaW5lLXByb3BlcnRpZXMgKi8gJy4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xuICAgICAgICAgICAgdmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKVxuICAgICAgICAgICAgZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuICAgICAgICAgICAgICBpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHBvbHlmaWxsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2ltcGxlbWVudGF0aW9uLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIga2V5c1NoaW1cbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICAvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICAgICAgICAgICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgICAgICAgICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgICAgIHZhciBpc0FyZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pc0FyZ3VtZW50cyAqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMnXG4gICAgICAgICAgICApIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICAgICAgICAgIHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICAgICAgICAgICB2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoXG4gICAgICAgICAgICAgIHsgdG9TdHJpbmc6IG51bGwgfSxcbiAgICAgICAgICAgICAgJ3RvU3RyaW5nJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgdmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJylcbiAgICAgICAgICAgIHZhciBkb250RW51bXMgPSBbXG4gICAgICAgICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICAgICAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgdmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgIHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhjbHVkZWRLZXlzID0ge1xuICAgICAgICAgICAgICAkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgJGNvbnNvbGU6IHRydWUsXG4gICAgICAgICAgICAgICRleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgJGZyYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICAkZnJhbWVzOiB0cnVlLFxuICAgICAgICAgICAgICAkaW5uZXJIZWlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICRpbm5lcldpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuICAgICAgICAgICAgICAkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICRvdXRlckhlaWdodDogdHJ1ZSxcbiAgICAgICAgICAgICAgJG91dGVyV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICRwYWdlWE9mZnNldDogdHJ1ZSxcbiAgICAgICAgICAgICAgJHBhZ2VZT2Zmc2V0OiB0cnVlLFxuICAgICAgICAgICAgICAkcGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICAkc2Nyb2xsTGVmdDogdHJ1ZSxcbiAgICAgICAgICAgICAgJHNjcm9sbFRvcDogdHJ1ZSxcbiAgICAgICAgICAgICAgJHNjcm9sbFg6IHRydWUsXG4gICAgICAgICAgICAgICRzY3JvbGxZOiB0cnVlLFxuICAgICAgICAgICAgICAkc2VsZjogdHJ1ZSxcbiAgICAgICAgICAgICAgJHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcbiAgICAgICAgICAgICAgJHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuICAgICAgICAgICAgICAkd2luZG93OiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8qIGdsb2JhbCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhZXhjbHVkZWRLZXlzWyckJyArIGtdICYmXG4gICAgICAgICAgICAgICAgICAgIGhhcy5jYWxsKHdpbmRvdywgaykgJiZcbiAgICAgICAgICAgICAgICAgICAgd2luZG93W2tdICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICB2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgLyogZ2xvYmFsIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgICAgICAgIHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICAgICAgICAgICB2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KVxuICAgICAgICAgICAgICB2YXIgaXNTdHJpbmcgPVxuICAgICAgICAgICAgICAgIGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSdcbiAgICAgICAgICAgICAgdmFyIHRoZUtleXMgPSBbXVxuXG4gICAgICAgICAgICAgIGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb25cbiAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIHRoZUtleXMucHVzaChTdHJpbmcoaSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgIHRoZUtleXMucHVzaChTdHJpbmcoaikpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJlxuICAgICAgICAgICAgICAgICAgICBoYXMuY2FsbChvYmplY3QsIG5hbWUpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KFxuICAgICAgICAgICAgICAgICAgb2JqZWN0XG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJlxuICAgICAgICAgICAgICAgICAgICBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhlS2V5c1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgIHZhciBpc0FyZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaXNBcmd1bWVudHMgKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzXG4gICAgICAgICAgdmFyIGtleXNTaGltID0gb3JpZ0tleXNcbiAgICAgICAgICAgID8gZnVuY3Rpb24ga2V5cyhvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdLZXlzKG8pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgICAvKiEgLi9pbXBsZW1lbnRhdGlvbiAqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanMnXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgIHZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5c1xuXG4gICAgICAgICAga2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICAgIHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgNS4wIGJ1Z1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICAgIH0pKDEsIDIpXG4gICAgICAgICAgICAgIGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICBpZiAoaXNBcmdzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzID0ga2V5c1NoaW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgdmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSdcbiAgICAgICAgICAgIGlmICghaXNBcmdzKSB7XG4gICAgICAgICAgICAgIGlzQXJncyA9XG4gICAgICAgICAgICAgICAgc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICAgICAgICAgICAgIHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzQXJnc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG4gICAgICAgICAgdmFyIHByb2Nlc3MgPSAobW9kdWxlLmV4cG9ydHMgPSB7fSlcblxuICAgICAgICAgIC8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuICAgICAgICAgIC8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuICAgICAgICAgIC8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbiAgICAgICAgICAvLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG4gICAgICAgICAgdmFyIGNhY2hlZFNldFRpbWVvdXRcbiAgICAgICAgICB2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0XG5cbiAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJylcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJylcbiAgICAgICAgICB9XG4gICAgICAgICAgOyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpXG4gICAgICAgICAgZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICAgICAgICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiZcbiAgICAgICAgICAgICAgc2V0VGltZW91dFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0XG4gICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8XG4gICAgICAgICAgICAgICAgIWNhY2hlZENsZWFyVGltZW91dCkgJiZcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0XG4gICAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcilcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcilcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBxdWV1ZSA9IFtdXG4gICAgICAgICAgdmFyIGRyYWluaW5nID0gZmFsc2VcbiAgICAgICAgICB2YXIgY3VycmVudFF1ZXVlXG4gICAgICAgICAgdmFyIHF1ZXVlSW5kZXggPSAtMVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgICAgICAgICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhaW5pbmcgPSBmYWxzZVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcXVldWVJbmRleCA9IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRyYWluUXVldWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgICAgICAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKVxuICAgICAgICAgICAgZHJhaW5pbmcgPSB0cnVlXG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGhcbiAgICAgICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWVcbiAgICAgICAgICAgICAgcXVldWUgPSBbXVxuICAgICAgICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHF1ZXVlSW5kZXggPSAtMVxuICAgICAgICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IG51bGxcbiAgICAgICAgICAgIGRyYWluaW5nID0gZmFsc2VcbiAgICAgICAgICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSlcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG4gICAgICAgICAgZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmZ1biA9IGZ1blxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5XG4gICAgICAgICAgfVxuICAgICAgICAgIEl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpXG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MudGl0bGUgPSAnYnJvd3NlcidcbiAgICAgICAgICBwcm9jZXNzLmJyb3dzZXIgPSB0cnVlXG4gICAgICAgICAgcHJvY2Vzcy5lbnYgPSB7fVxuICAgICAgICAgIHByb2Nlc3MuYXJndiA9IFtdXG4gICAgICAgICAgcHJvY2Vzcy52ZXJzaW9uID0gJycgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbiAgICAgICAgICBwcm9jZXNzLnZlcnNpb25zID0ge31cblxuICAgICAgICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gICAgICAgICAgcHJvY2Vzcy5vbiA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcFxuICAgICAgICAgIHByb2Nlc3Mub25jZSA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLm9mZiA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcFxuICAgICAgICAgIHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcFxuICAgICAgICAgIHByb2Nlc3MuZW1pdCA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wXG5cbiAgICAgICAgICBwcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8nXG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICAgICAgICAgIC8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAgICAgICAgICAvLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAgICAgICAgICAvLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gICAgICAgICAgLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICAgICAgICAgIC8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuICAgICAgICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAgICAgICAgICAvLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAgICAgICAgICAvLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgICAgICAgLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICAgICAgICAgIC8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuICAgICAgICAgIC8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICAgICAgICAgIC8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAgICAgICAgICAvLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAgICAgICAgLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuICAgICAgICAgIC8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG4gICAgICAgICAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICAgICAgICAgICAgc2VwID0gc2VwIHx8ICcmJ1xuICAgICAgICAgICAgZXEgPSBlcSB8fCAnPSdcbiAgICAgICAgICAgIHZhciBvYmogPSB7fVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVnZXhwID0gL1xcKy9nXG4gICAgICAgICAgICBxcyA9IHFzLnNwbGl0KHNlcClcblxuICAgICAgICAgICAgdmFyIG1heEtleXMgPSAxMDAwXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBxcy5sZW5ndGhcbiAgICAgICAgICAgIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICAgICAgICAgICAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICAgICAgICAgICAgbGVuID0gbWF4S2V5c1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICAgICAgICAgIGtzdHIsXG4gICAgICAgICAgICAgICAgdnN0cixcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIHZcblxuICAgICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KVxuICAgICAgICAgICAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtzdHIgPSB4XG4gICAgICAgICAgICAgICAgdnN0ciA9ICcnXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpXG4gICAgICAgICAgICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cilcblxuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBvYmpba10gPSB2XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tdLnB1c2godilcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpba10gPSBbb2JqW2tdLCB2XVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAgICAgICAgICAvLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gICAgICAgICAgLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gICAgICAgICAgLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICAgICAgICAgIC8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbiAgICAgICAgICAvLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAgICAgICAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gICAgICAgICAgLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gICAgICAgICAgLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgICAgICAgIC8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbiAgICAgICAgICAvLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAgICAgICAgICAvLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAgICAgICAgICAvLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4gICAgICAgICAgLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuICAgICAgICAgIHZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2XG5cbiAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnXG5cbiAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJydcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICAgICAgICAgICAgc2VwID0gc2VwIHx8ICcmJ1xuICAgICAgICAgICAgZXEgPSBlcSB8fCAnPSdcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgb2JqID0gdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXFcbiAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrXVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbihzZXApXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihzZXApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbmFtZSkgcmV0dXJuICcnXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArXG4gICAgICAgICAgICAgIGVxICtcbiAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2RlY29kZSAqLyAnLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2VuY29kZSAqLyAnLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9hbGJ1bS9nZXRBbGJ1bS50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvYWxidW0vZ2V0QWxidW0udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuZ2V0QWxidW0gPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL3V0aWxzICovICcuL3NyYy9jb21tb24vdXRpbHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldEFsYnVtKGNsaWVudCwgYWxidW1IYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtlbmRwb2ludHNfMS5BTEJVTV9FTkRQT0lOVH0vJHthbGJ1bUhhc2h9YFxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShcbiAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5nZXRBbGJ1bSA9IGdldEFsYnVtXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvYWxidW0vaW5kZXgudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2FsYnVtL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBjb25zdCB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISB0c2xpYiAqLyAnLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0QWxidW0gKi8gJy4vc3JjL2FsYnVtL2dldEFsYnVtLnRzJyksXG4gICAgICAgICAgICBleHBvcnRzXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2NsaWVudC50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NsaWVudC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuSW1ndXJDbGllbnQgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISB0c2xpYiAqLyAnLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgZXZlbnRzICovICcuL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBnZXRBdXRob3JpemF0aW9uSGVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vZ2V0QXV0aG9yaXphdGlvbkhlYWRlciAqLyAnLi9zcmMvZ2V0QXV0aG9yaXphdGlvbkhlYWRlci50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgaW1hZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9pbWFnZSAqLyAnLi9zcmMvaW1hZ2UvaW5kZXgudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGdhbGxlcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9nYWxsZXJ5ICovICcuL3NyYy9nYWxsZXJ5L2luZGV4LnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBhbGJ1bV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2FsYnVtICovICcuL3NyYy9hbGJ1bS9pbmRleC50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgZW5kcG9pbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgVVNFUkFHRU5UID1cbiAgICAgICAgICAgICdpbWd1ci9uZXh0IChodHRwczovL2dpdGh1Yi5jb20va2FpbWFsbGVhL25vZGUtaW1ndXIpJ1xuICAgICAgICAgIGNvbnN0IGF4aW9zXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oLyohIGF4aW9zICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcycpXG4gICAgICAgICAgKVxuICAgICAgICAgIGNsYXNzIEltZ3VyQ2xpZW50IGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgIHN1cGVyKClcbiAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgIHRoaXMucGxhaW5GZXRjaGVyID0gYXhpb3NfMS5kZWZhdWx0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYmFzZVVSTDogZW5kcG9pbnRzXzEuSU1HVVJfQVBJX1BSRUZJWCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAndXNlci1hZ2VudCc6IFVTRVJBR0VOVCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB0aGlzLmZldGNoZXIgPSBheGlvc18xLmRlZmF1bHQuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBiYXNlVVJMOiBlbmRwb2ludHNfMS5JTUdVUl9BUElfUFJFRklYLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICd1c2VyLWFnZW50JzogVVNFUkFHRU5ULFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHRoaXMuZmV0Y2hlci5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXG4gICAgICAgICAgICAgICAgYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyA/IGNvbmZpZy5oZWFkZXJzIDoge31cbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSBhd2FpdCBnZXRBdXRob3JpemF0aW9uSGVhZGVyXzEuZ2V0QXV0aG9yaXphdGlvbkhlYWRlcihcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGUpID0+IFByb21pc2UucmVqZWN0KGUpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYWluUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYWluRmV0Y2hlcihvcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hlcihvcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlSW1hZ2UoaW1hZ2VIYXNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbWFnZV8xLmRlbGV0ZUltYWdlKHRoaXMsIGltYWdlSGFzaClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhdm9yaXRlSW1hZ2UoaW1hZ2VIYXNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbWFnZV8xLmZhdm9yaXRlSW1hZ2UodGhpcywgaW1hZ2VIYXNoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0QWxidW0oYWxidW1IYXNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhbGJ1bV8xLmdldEFsYnVtKHRoaXMsIGFsYnVtSGFzaClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEdhbGxlcnkob3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gZ2FsbGVyeV8xLmdldEdhbGxlcnkodGhpcywgb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldFN1YnJlZGRpdEdhbGxlcnkob3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gZ2FsbGVyeV8xLmdldFN1YnJlZGRpdEdhbGxlcnkodGhpcywgb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlYXJjaEdhbGxlcnkob3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gZ2FsbGVyeV8xLnNlYXJjaEdhbGxlcnkodGhpcywgb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEltYWdlKGltYWdlSGFzaCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VfMS5nZXRJbWFnZSh0aGlzLCBpbWFnZUhhc2gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVJbWFnZShwYXlsb2FkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbWFnZV8xLnVwZGF0ZUltYWdlKHRoaXMsIHBheWxvYWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGxvYWQocGF5bG9hZCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VfMS51cGxvYWQodGhpcywgcGF5bG9hZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5JbWd1ckNsaWVudCA9IEltZ3VyQ2xpZW50XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tb24vZW5kcG9pbnRzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuU0VBUkNIX0dBTExFUllfRU5EUE9JTlQgPSBleHBvcnRzLlNVQlJFRERJVF9HQUxMRVJZX0VORFBPSU5UID0gZXhwb3J0cy5HQUxMRVJZX0VORFBPSU5UID0gZXhwb3J0cy5VUExPQURfRU5EUE9JTlQgPSBleHBvcnRzLklNQUdFX0VORFBPSU5UID0gZXhwb3J0cy5BTEJVTV9FTkRQT0lOVCA9IGV4cG9ydHMuQVVUSE9SSVpFX0VORFBPSU5UID0gZXhwb3J0cy5BUElfVkVSU0lPTiA9IGV4cG9ydHMuSU1HVVJfQVBJX1BSRUZJWCA9IHZvaWQgMFxuICAgICAgICAgIGV4cG9ydHMuSU1HVVJfQVBJX1BSRUZJWCA9ICdodHRwczovL2FwaS5pbWd1ci5jb20nXG4gICAgICAgICAgZXhwb3J0cy5BUElfVkVSU0lPTiA9ICczJ1xuICAgICAgICAgIGV4cG9ydHMuQVVUSE9SSVpFX0VORFBPSU5UID0gJ29hdXRoMi9hdXRob3JpemUnXG4gICAgICAgICAgZXhwb3J0cy5BTEJVTV9FTkRQT0lOVCA9IGAke2V4cG9ydHMuQVBJX1ZFUlNJT059L2FsYnVtYFxuICAgICAgICAgIGV4cG9ydHMuSU1BR0VfRU5EUE9JTlQgPSBgJHtleHBvcnRzLkFQSV9WRVJTSU9OfS9pbWFnZWBcbiAgICAgICAgICBleHBvcnRzLlVQTE9BRF9FTkRQT0lOVCA9IGAke2V4cG9ydHMuQVBJX1ZFUlNJT059L3VwbG9hZGBcbiAgICAgICAgICBleHBvcnRzLkdBTExFUllfRU5EUE9JTlQgPSBgJHtleHBvcnRzLkFQSV9WRVJTSU9OfS9nYWxsZXJ5YFxuICAgICAgICAgIGV4cG9ydHMuU1VCUkVERElUX0dBTExFUllfRU5EUE9JTlQgPSBgJHtleHBvcnRzLkFQSV9WRVJTSU9OfS9nYWxsZXJ5L3JgXG4gICAgICAgICAgZXhwb3J0cy5TRUFSQ0hfR0FMTEVSWV9FTkRQT0lOVCA9IGAke2V4cG9ydHMuQVBJX1ZFUlNJT059L2dhbGxlcnkvc2VhcmNoYFxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2NvbW1vbi90eXBlcy50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1vbi90eXBlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuaXNMb2dpbiA9IGV4cG9ydHMuaXNDbGllbnRJZCA9IGV4cG9ydHMuaXNBY2Nlc3NUb2tlbiA9IHZvaWQgMFxuICAgICAgICAgIGZ1bmN0aW9uIGlzQWNjZXNzVG9rZW4oYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnLmFjY2Vzc1Rva2VuICE9PSB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0FjY2Vzc1Rva2VuID0gaXNBY2Nlc3NUb2tlblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQ2xpZW50SWQoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnLmNsaWVudElkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0NsaWVudElkID0gaXNDbGllbnRJZFxuICAgICAgICAgIGZ1bmN0aW9uIGlzTG9naW4oYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBhcmcuY2xpZW50SWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICBhcmcudXNlcm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICBhcmcucGFzc3dvcmQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzTG9naW4gPSBpc0xvZ2luXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvY29tbW9uL3V0aWxzLnRzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbW9uL3V0aWxzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgICAgZXhwb3J0cy5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlID0gZXhwb3J0cy5jcmVhdGVGb3JtID0gZXhwb3J0cy5nZXRTb3VyY2UgPSBleHBvcnRzLmlzU3RyZWFtID0gZXhwb3J0cy5pc0ltYWdlVXJsID0gZXhwb3J0cy5pc0Jhc2U2NCA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHRzbGliICovICcuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGZvcm1fZGF0YV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgZm9ybS1kYXRhICovICcuL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL2Jyb3dzZXIuanMnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIGZ1bmN0aW9uIGlzQmFzZTY0KHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0eXBlb2YgcGF5bG9hZC5iYXNlNjQgIT09ICd1bmRlZmluZWQnICYmIHBheWxvYWQudHlwZSA9PT0gJ2Jhc2U2NCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0Jhc2U2NCA9IGlzQmFzZTY0XG4gICAgICAgICAgZnVuY3Rpb24gaXNJbWFnZVVybChwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0eXBlb2YgcGF5bG9hZC5pbWFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGF5bG9hZC50eXBlID09PSAndXJsJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzSW1hZ2VVcmwgPSBpc0ltYWdlVXJsXG4gICAgICAgICAgZnVuY3Rpb24gaXNTdHJlYW0ocGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcGF5bG9hZC5zdHJlYW0gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNTdHJlYW0gPSBpc1N0cmVhbVxuICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgdG8gYmUgYSB1bmlxdWUgbmFtZSBvZiBzb21lIGtpbmQgKGEgaGFzaD8pXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0U291cmNlKHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Jhc2U2NChwYXlsb2FkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ3BheWxvYWQuYmFzZTY0J1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmVhbShwYXlsb2FkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ3BheWxvYWQuc3RyZWFtJ1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQuaW1hZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5nZXRTb3VyY2UgPSBnZXRTb3VyY2VcbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVGb3JtKHBheWxvYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBuZXcgZm9ybV9kYXRhXzEuZGVmYXVsdCgpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGZvcm0uYXBwZW5kKCdpbWFnZScsIHBheWxvYWQpXG4gICAgICAgICAgICAgIHJldHVybiBmb3JtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXlsb2FkKSkge1xuICAgICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcyA9IFsnYmFzZTY0JywgJ3N0cmVhbSddXG4gICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRlZFVwbG9hZE9iamVjdFR5cGVzLmluZGV4T2YocGF5bG9hZC50eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgcGF5bG9hZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5jcmVhdGVGb3JtID0gY3JlYXRlRm9ybVxuICAgICAgICAgIGZ1bmN0aW9uIGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2JcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mICgoX2EgPSByZXNwb25zZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICA6IF9hLnN0YXR1cykgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiAoKF9iID0gcmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgOiBfYi5zdWNjZXNzKSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgIC8vIFRPRE86IGRldGVybWluZSB0aGUgc3VjY2VzcyBvZiB0aGUgY2FsbD9cbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlID0gZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2dhbGxlcnkvZ2V0R2FsbGVyeS50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2dhbGxlcnkvZ2V0R2FsbGVyeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuZ2V0R2FsbGVyeSA9IGV4cG9ydHMuY29uc3RydWN0R2FsbGVyeVVybCA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vZW5kcG9pbnRzICovICcuL3NyYy9jb21tb24vZW5kcG9pbnRzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCB1cmxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgdXJsICovICcuL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vdXRpbHMgKi8gJy4vc3JjL2NvbW1vbi91dGlscy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZWN0aW9uOiAnaG90JyxcbiAgICAgICAgICAgIHNvcnQ6ICd2aXJhbCcsXG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnN0cnVjdEdhbGxlcnlVcmwob3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgICAgICAgbGV0IHVyaSA9IGAke21lcmdlZE9wdGlvbnMuc2VjdGlvbn1gXG4gICAgICAgICAgICBpZiAobWVyZ2VkT3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgICAgIHVyaSArPSBgLyR7bWVyZ2VkT3B0aW9ucy5zb3J0fWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJnZWRPcHRpb25zLnNlY3Rpb24gPT09ICd0b3AnICYmIG1lcmdlZE9wdGlvbnMud2luZG93KSB7XG4gICAgICAgICAgICAgIHVyaSArPSBgLyR7bWVyZ2VkT3B0aW9ucy53aW5kb3d9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmdlZE9wdGlvbnMucGFnZSkge1xuICAgICAgICAgICAgICB1cmkgKz0gYC8ke21lcmdlZE9wdGlvbnMucGFnZX1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgdXJsXzEuVVJMKFxuICAgICAgICAgICAgICBgJHtlbmRwb2ludHNfMS5JTUdVUl9BUElfUFJFRklYfS8ke2VuZHBvaW50c18xLkdBTExFUllfRU5EUE9JTlR9LyR7dXJpfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChtZXJnZWRPcHRpb25zLnNob3dWaXJhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFxuICAgICAgICAgICAgICAgICdzaG93VmlyYWwnLFxuICAgICAgICAgICAgICAgIG1lcmdlZE9wdGlvbnMuc2hvd1ZpcmFsLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmdlZE9wdGlvbnMubWF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ21hdHVyZScsIG1lcmdlZE9wdGlvbnMubWF0dXJlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyZ2VkT3B0aW9ucy5hbGJ1bV9wcmV2aWV3cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFxuICAgICAgICAgICAgICAgICdhbGJ1bV9wcmV2aWV3cycsXG4gICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5hbGJ1bV9wcmV2aWV3cy50b1N0cmluZygpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5jb25zdHJ1Y3RHYWxsZXJ5VXJsID0gY29uc3RydWN0R2FsbGVyeVVybFxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldEdhbGxlcnkoY2xpZW50LCBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IGNvbnN0cnVjdEdhbGxlcnlVcmwob3B0aW9ucylcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIHVzaW5nIHByZWZpeFVybCB3aXRoIGdvdCwgd2UgaGF2ZSB0byByZW1vdmUgdGhlIHN0YXJ0aW5nIHNsYXNoIG9yIGl0J2xsIHRocm93XG4gICAgICAgICAgICBjb25zdCBmaW5hbFBhdGhuYW1lID0gcGF0aG5hbWUuc2xpY2UoMSlcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsOiBmaW5hbFBhdGhuYW1lIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZ2V0R2FsbGVyeSA9IGdldEdhbGxlcnlcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9nYWxsZXJ5L2dldFN1YnJlZGRpdEdhbGxlcnkudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9nYWxsZXJ5L2dldFN1YnJlZGRpdEdhbGxlcnkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmdldFN1YnJlZGRpdEdhbGxlcnkgPSBleHBvcnRzLmNvbnN0cnVjdFN1YnJlZGRpdEdhbGxlcnlVcmwgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXJsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHVybCAqLyAnLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL3V0aWxzICovICcuL3NyYy9jb21tb24vdXRpbHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGZ1bmN0aW9uIGNvbnN0cnVjdFN1YnJlZGRpdEdhbGxlcnlVcmwob3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHVyaSA9IGAke29wdGlvbnMuc3VicmVkZGl0fWBcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICAgICAgdXJpICs9IGAvJHtvcHRpb25zLnNvcnR9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc29ydCA9PT0gJ3RvcCcgJiYgb3B0aW9ucy53aW5kb3cpIHtcbiAgICAgICAgICAgICAgdXJpICs9IGAvJHtvcHRpb25zLndpbmRvd31gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWdlKSB7XG4gICAgICAgICAgICAgIHVyaSArPSBgLyR7b3B0aW9ucy5wYWdlfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyB1cmxfMS5VUkwoXG4gICAgICAgICAgICAgIGAke2VuZHBvaW50c18xLklNR1VSX0FQSV9QUkVGSVh9LyR7ZW5kcG9pbnRzXzEuU1VCUkVERElUX0dBTExFUllfRU5EUE9JTlR9LyR7dXJpfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5jb25zdHJ1Y3RTdWJyZWRkaXRHYWxsZXJ5VXJsID0gY29uc3RydWN0U3VicmVkZGl0R2FsbGVyeVVybFxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldFN1YnJlZGRpdEdhbGxlcnkoY2xpZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBjb25zdHJ1Y3RTdWJyZWRkaXRHYWxsZXJ5VXJsKG9wdGlvbnMpXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSB1c2luZyBwcmVmaXhVcmwgd2l0aCBnb3QsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBzdGFydGluZyBzbGFzaCBvciBpdCdsbCB0aHJvd1xuICAgICAgICAgICAgY29uc3QgZmluYWxQYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDEpXG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybDogZmluYWxQYXRobmFtZSB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmdldFN1YnJlZGRpdEdhbGxlcnkgPSBnZXRTdWJyZWRkaXRHYWxsZXJ5XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvZ2FsbGVyeS9pbmRleC50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9nYWxsZXJ5L2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGNvbnN0IHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHRzbGliICovICcuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHRzbGliXzEuX19leHBvcnRTdGFyKFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vZ2V0R2FsbGVyeSAqLyAnLi9zcmMvZ2FsbGVyeS9nZXRHYWxsZXJ5LnRzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4cG9ydHNcbiAgICAgICAgICApXG4gICAgICAgICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9nZXRTdWJyZWRkaXRHYWxsZXJ5ICovICcuL3NyYy9nYWxsZXJ5L2dldFN1YnJlZGRpdEdhbGxlcnkudHMnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXhwb3J0c1xuICAgICAgICAgIClcbiAgICAgICAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL3NlYXJjaEdhbGxlcnkgKi8gJy4vc3JjL2dhbGxlcnkvc2VhcmNoR2FsbGVyeS50cydcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBleHBvcnRzXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2dhbGxlcnkvc2VhcmNoR2FsbGVyeS50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2dhbGxlcnkvc2VhcmNoR2FsbGVyeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuc2VhcmNoR2FsbGVyeSA9IGV4cG9ydHMuY29uc3RydWN0U2VhcmNoR2FsbGVyeVVybCA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vZW5kcG9pbnRzICovICcuL3NyYy9jb21tb24vZW5kcG9pbnRzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vdXRpbHMgKi8gJy4vc3JjL2NvbW1vbi91dGlscy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXJsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHVybCAqLyAnLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgYWR2YW5jZWRQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgJ3FfYWxsJyxcbiAgICAgICAgICAgICdxX2FueScsXG4gICAgICAgICAgICAncV9leGFjdGx5JyxcbiAgICAgICAgICAgICdxX25vdCcsXG4gICAgICAgICAgICAncV90eXBlJyxcbiAgICAgICAgICAgICdxX3NpemVfcHgnLFxuICAgICAgICAgIF1cbiAgICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RTZWFyY2hHYWxsZXJ5VXJsKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB1cmkgPSAnJ1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICAgICAgICB1cmkgKz0gYC8ke29wdGlvbnMuc29ydH1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3J0ID09PSAndG9wJyAmJiBvcHRpb25zLndpbmRvdykge1xuICAgICAgICAgICAgICB1cmkgKz0gYC8ke29wdGlvbnMud2luZG93fWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhZ2UpIHtcbiAgICAgICAgICAgICAgdXJpICs9IGAvJHtvcHRpb25zLnBhZ2V9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IHVybF8xLlVSTChcbiAgICAgICAgICAgICAgYCR7ZW5kcG9pbnRzXzEuSU1HVVJfQVBJX1BSRUZJWH0vJHtlbmRwb2ludHNfMS5TRUFSQ0hfR0FMTEVSWV9FTkRQT0lOVH0ke3VyaX1gXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBhZHZhbmNlZFBhcmFtZXRlcnMuZm9yRWFjaCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zW3BhcmFtXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIDogX2EubGVuZ3RoXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKHBhcmFtLCBvcHRpb25zW3BhcmFtXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmICghdXJsLnNlYXJjaCkge1xuICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IG9wdGlvbnMucSB8fCBvcHRpb25zLnF1ZXJ5XG4gICAgICAgICAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHF1ZXJ5IHdhcyBwcm92aWRlZCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3EnLCBxdWVyeSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5jb25zdHJ1Y3RTZWFyY2hHYWxsZXJ5VXJsID0gY29uc3RydWN0U2VhcmNoR2FsbGVyeVVybFxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIHNlYXJjaEdhbGxlcnkoY2xpZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBjb25zdHJ1Y3RTZWFyY2hHYWxsZXJ5VXJsKG9wdGlvbnMpXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSB1c2luZyBwcmVmaXhVcmwgd2l0aCBnb3QsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBzdGFydGluZyBzbGFzaCBvciBpdCdsbCB0aHJvd1xuICAgICAgICAgICAgY29uc3QgZmluYWxQYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDEpXG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybDogZmluYWxQYXRobmFtZSB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLnNlYXJjaEdhbGxlcnkgPSBzZWFyY2hHYWxsZXJ5XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvZ2V0QXV0aG9yaXphdGlvbkhlYWRlci50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9nZXRBdXRob3JpemF0aW9uSGVhZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlciA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IHR5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vY29tbW9uL3R5cGVzICovICcuL3NyYy9jb21tb24vdHlwZXMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NvbW1vbi9lbmRwb2ludHMgKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhvcml6YXRpb25IZWFkZXIoY2xpZW50KSB7XG4gICAgICAgICAgICBpZiAodHlwZXNfMS5pc0FjY2Vzc1Rva2VuKGNsaWVudC5jcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGBCZWFyZXIgJHtjbGllbnQuY3JlZGVudGlhbHMuYWNjZXNzVG9rZW59YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlc18xLmlzQ2xpZW50SWQoY2xpZW50LmNyZWRlbnRpYWxzKSAmJlxuICAgICAgICAgICAgICAhdHlwZXNfMS5pc0xvZ2luKGNsaWVudC5jcmVkZW50aWFscylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gYENsaWVudC1JRCAke2NsaWVudC5jcmVkZW50aWFscy5jbGllbnRJZH1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudElkLCB1c2VybmFtZSwgcGFzc3dvcmQgfSA9IGNsaWVudC5jcmVkZW50aWFsc1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgdXJsOiBlbmRwb2ludHNfMS5BVVRIT1JJWkVfRU5EUE9JTlQsXG4gICAgICAgICAgICAgIGJhc2VVUkw6IGVuZHBvaW50c18xLklNR1VSX0FQSV9QUkVGSVgsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VfdHlwZTogJ3Rva2VuJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wbGFpblJlcXVlc3Qob3B0aW9ucylcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZXMgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXSlcbiAgICAgICAgICAgICAgPyByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ11bMF1cbiAgICAgICAgICAgICAgOiByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ11cbiAgICAgICAgICAgIGlmICghY29va2llcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb2tpZXMgd2VyZSBzZXQgZHVyaW5nIGF1dGhvcml6YXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGNvb2tpZXMubWF0Y2goJyhefDspW3NdKmF1dGhvcml6ZV90b2tlbj0oW147XSopJylcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhdXRob3JpemVfdG9rZW4gY29va2llJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6ZVRva2VuID0gbWF0Y2hlc1syXVxuICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnUE9TVCdcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHtcbiAgICAgICAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICBhbGxvdzogYXV0aG9yaXplVG9rZW4sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLmZvbGxvd1JlZGlyZWN0ID0gZmFsc2VcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgY29va2llOiBgYXV0aG9yaXplX3Rva2VuPSR7YXV0aG9yaXplVG9rZW59YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBsYWluUmVxdWVzdChvcHRpb25zKVxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uXG4gICAgICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIGxvY2F0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgJ3tcIicgK1xuICAgICAgICAgICAgICAgIGRlY29kZVVSSShsb2NhdGlvbi5zbGljZShsb2NhdGlvbi5pbmRleE9mKCcjJykgKyAxKSlcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICdcIixcIicpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPS9nLCAnXCI6XCInKSArXG4gICAgICAgICAgICAgICAgJ1wifSdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdG9rZW4uYWNjZXNzX3Rva2VuXG4gICAgICAgICAgICBjbGllbnQuY3JlZGVudGlhbHMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlblxuICAgICAgICAgICAgcmV0dXJuIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlciA9IGdldEF1dGhvcml6YXRpb25IZWFkZXJcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9pbWFnZS9kZWxldGVJbWFnZS50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW1hZ2UvZGVsZXRlSW1hZ2UudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuZGVsZXRlSW1hZ2UgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL3V0aWxzICovICcuL3NyYy9jb21tb24vdXRpbHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUltYWdlKGNsaWVudCwgaW1hZ2VIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtlbmRwb2ludHNfMS5JTUFHRV9FTkRQT0lOVH0vJHtpbWFnZUhhc2h9YFxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShcbiAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwsIG1ldGhvZDogJ0RFTEVURScgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5kZWxldGVJbWFnZSA9IGRlbGV0ZUltYWdlXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvaW1hZ2UvZmF2b3JpdGVJbWFnZS50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS9mYXZvcml0ZUltYWdlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuZmF2b3JpdGVJbWFnZSA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vZW5kcG9pbnRzICovICcuL3NyYy9jb21tb24vZW5kcG9pbnRzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vdXRpbHMgKi8gJy4vc3JjL2NvbW1vbi91dGlscy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gZmF2b3JpdGVJbWFnZShjbGllbnQsIGltYWdlSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7ZW5kcG9pbnRzXzEuSU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofS9mYXZvcml0ZWBcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsLCBtZXRob2Q6ICdQT1NUJyB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmZhdm9yaXRlSW1hZ2UgPSBmYXZvcml0ZUltYWdlXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvaW1hZ2UvZ2V0SW1hZ2UudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ltYWdlL2dldEltYWdlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmdldEltYWdlID0gdm9pZCAwXG4gICAgICAgICAgY29uc3QgZW5kcG9pbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi9lbmRwb2ludHMgKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi91dGlscyAqLyAnLi9zcmMvY29tbW9uL3V0aWxzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBnZXRJbWFnZShjbGllbnQsIGltYWdlSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7ZW5kcG9pbnRzXzEuSU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofWBcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZ2V0SW1hZ2UgPSBnZXRJbWFnZVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2ltYWdlL2luZGV4LnRzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgICAgY29uc3QgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgdHNsaWIgKi8gJy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9kZWxldGVJbWFnZSAqLyAnLi9zcmMvaW1hZ2UvZGVsZXRlSW1hZ2UudHMnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXhwb3J0c1xuICAgICAgICAgIClcbiAgICAgICAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2Zhdm9yaXRlSW1hZ2UgKi8gJy4vc3JjL2ltYWdlL2Zhdm9yaXRlSW1hZ2UudHMnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXhwb3J0c1xuICAgICAgICAgIClcbiAgICAgICAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0SW1hZ2UgKi8gJy4vc3JjL2ltYWdlL2dldEltYWdlLnRzJyksXG4gICAgICAgICAgICBleHBvcnRzXG4gICAgICAgICAgKVxuICAgICAgICAgIHRzbGliXzEuX19leHBvcnRTdGFyKFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vdXBkYXRlSW1hZ2UgKi8gJy4vc3JjL2ltYWdlL3VwZGF0ZUltYWdlLnRzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4cG9ydHNcbiAgICAgICAgICApXG4gICAgICAgICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VwbG9hZCAqLyAnLi9zcmMvaW1hZ2UvdXBsb2FkLnRzJyksXG4gICAgICAgICAgICBleHBvcnRzXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2ltYWdlL3VwZGF0ZUltYWdlLnRzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS91cGRhdGVJbWFnZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgICAgZXhwb3J0cy51cGRhdGVJbWFnZSA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vZW5kcG9pbnRzICovICcuL3NyYy9jb21tb24vZW5kcG9pbnRzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vdXRpbHMgKi8gJy4vc3JjL2NvbW1vbi91dGlscy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgZnVuY3Rpb24gaXNWYWxpZFVwZGF0ZVBheWxvYWQocCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdHlwZW9mIHAudGl0bGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwLmRlc2NyaXB0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiB1cGRhdGVJbWFnZShjbGllbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRVcGRhdGVQYXlsb2FkKHApKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke2VuZHBvaW50c18xLklNQUdFX0VORFBPSU5UfS8ke3AuaW1hZ2VIYXNofWBcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gdXRpbHNfMS5jcmVhdGVGb3JtKHApXG4gICAgICAgICAgICAgICAgLyogZXNsaW50IG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3I6IDAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRVcGRhdGVQYXlsb2FkKHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIHJlcXVpcmVzIGEgdGl0bGUgYW5kL29yIGRlc2NyaXB0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke2VuZHBvaW50c18xLklNQUdFX0VORFBPSU5UfS8ke3BheWxvYWQuaW1hZ2VIYXNofWBcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSB1dGlsc18xLmNyZWF0ZUZvcm0ocGF5bG9hZClcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgZGF0YTogZm9ybSxcbiAgICAgICAgICAgICAgICAvLyByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMudXBkYXRlSW1hZ2UgPSB1cGRhdGVJbWFnZVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2ltYWdlL3VwbG9hZC50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ltYWdlL3VwbG9hZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNvbnNvbGUtYnJvd3NlcmlmeSAqLyAnLi9ub2RlX21vZHVsZXMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLnVwbG9hZCA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi91dGlscyAqLyAnLi9zcmMvY29tbW9uL3V0aWxzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkKGNsaWVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBwYXlsb2FkLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm0gPSB1dGlsc18xLmNyZWF0ZUZvcm0ocClcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvcjogMCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZW5kcG9pbnRzXzEuVVBMT0FEX0VORFBPSU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogKHByb2dyZXNzRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coeyBwcm9ncmVzc0V2ZW50IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5lbWl0KCd1cGxvYWRQcm9ncmVzcycsIHsgLi4ucHJvZ3Jlc3NFdmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm9ybSA9IHV0aWxzXzEuY3JlYXRlRm9ybShwYXlsb2FkKVxuICAgICAgICAgICAgLy8gY29uc3QgaWQgPSBEYXRlLm5vdy50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgdXJsOiBlbmRwb2ludHNfMS5VUExPQURfRU5EUE9JTlQsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAocHJvZ3Jlc3NFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsgcHJvZ3Jlc3NFdmVudCB9KVxuICAgICAgICAgICAgICAgIGNsaWVudC5lbWl0KCd1cGxvYWRQcm9ncmVzcycsIHsgLi4ucHJvZ3Jlc3NFdmVudCB9KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICAgIHV0aWxzXzEuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShyZXF1ZXN0KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLnVwbG9hZCA9IHVwbG9hZFxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChcbiAgICAgICAgICBfX3VudXNlZF93ZWJwYWNrX21vZHVsZSxcbiAgICAgICAgICBfX3dlYnBhY2tfZXhwb3J0c19fLFxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX19cbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pXG4gICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fZXh0ZW5kczogKCkgPT4gLyogYmluZGluZyAqLyBfX2V4dGVuZHMsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2Fzc2lnbjogKCkgPT4gLyogYmluZGluZyAqLyBfX2Fzc2lnbixcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fcmVzdDogKCkgPT4gLyogYmluZGluZyAqLyBfX3Jlc3QsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2RlY29yYXRlOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fZGVjb3JhdGUsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX3BhcmFtOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fcGFyYW0sXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX21ldGFkYXRhOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fbWV0YWRhdGEsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2F3YWl0ZXI6ICgpID0+IC8qIGJpbmRpbmcgKi8gX19hd2FpdGVyLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19nZW5lcmF0b3I6ICgpID0+IC8qIGJpbmRpbmcgKi8gX19nZW5lcmF0b3IsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2NyZWF0ZUJpbmRpbmc6ICgpID0+XG4gICAgICAgICAgICAgIC8qIGJpbmRpbmcgKi8gX19jcmVhdGVCaW5kaW5nLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19leHBvcnRTdGFyOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fZXhwb3J0U3RhcixcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fdmFsdWVzOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fdmFsdWVzLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19yZWFkOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fcmVhZCxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fc3ByZWFkOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fc3ByZWFkLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19zcHJlYWRBcnJheXM6ICgpID0+XG4gICAgICAgICAgICAgIC8qIGJpbmRpbmcgKi8gX19zcHJlYWRBcnJheXMsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2F3YWl0OiAoKSA9PiAvKiBiaW5kaW5nICovIF9fYXdhaXQsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2FzeW5jR2VuZXJhdG9yOiAoKSA9PlxuICAgICAgICAgICAgICAvKiBiaW5kaW5nICovIF9fYXN5bmNHZW5lcmF0b3IsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2FzeW5jRGVsZWdhdG9yOiAoKSA9PlxuICAgICAgICAgICAgICAvKiBiaW5kaW5nICovIF9fYXN5bmNEZWxlZ2F0b3IsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2FzeW5jVmFsdWVzOiAoKSA9PlxuICAgICAgICAgICAgICAvKiBiaW5kaW5nICovIF9fYXN5bmNWYWx1ZXMsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX21ha2VUZW1wbGF0ZU9iamVjdDogKCkgPT5cbiAgICAgICAgICAgICAgLyogYmluZGluZyAqLyBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9faW1wb3J0U3RhcjogKCkgPT4gLyogYmluZGluZyAqLyBfX2ltcG9ydFN0YXIsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2ltcG9ydERlZmF1bHQ6ICgpID0+XG4gICAgICAgICAgICAgIC8qIGJpbmRpbmcgKi8gX19pbXBvcnREZWZhdWx0LFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19jbGFzc1ByaXZhdGVGaWVsZEdldDogKCkgPT5cbiAgICAgICAgICAgICAgLyogYmluZGluZyAqLyBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19jbGFzc1ByaXZhdGVGaWVsZFNldDogKCkgPT5cbiAgICAgICAgICAgICAgLyogYmluZGluZyAqLyBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi9cbiAgICAgICAgICB9KVxuICAgICAgICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuICAgICAgICAgIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbiAgICAgICAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgICAgICBleHRlbmRTdGF0aWNzID1cbiAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgICAgICAgICAgIGQuX19wcm90b19fID0gYlxuICAgICAgICAgICAgICAgIH0pIHx8XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgICAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKVxuICAgICAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkLnByb3RvdHlwZSA9XG4gICAgICAgICAgICAgIGIgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5jcmVhdGUoYilcbiAgICAgICAgICAgICAgICA6ICgoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUpLCBuZXcgX18oKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfX2Fzc2lnbiA9XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24gfHxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXVxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHt9XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiZcbiAgICAgICAgICAgICAgICBlLmluZGV4T2YocCkgPCAwXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXVxuICAgICAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpO1xuICAgICAgICAgICAgICAgIGkgPCBwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgZS5pbmRleE9mKHBbaV0pIDwgMCAmJlxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgIHIgPVxuICAgICAgICAgICAgICAgIGMgPCAzXG4gICAgICAgICAgICAgICAgICA/IHRhcmdldFxuICAgICAgICAgICAgICAgICAgOiBkZXNjID09PSBudWxsXG4gICAgICAgICAgICAgICAgICA/IChkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpXG4gICAgICAgICAgICAgICAgICA6IGRlc2MsXG4gICAgICAgICAgICAgIGRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICBpZiAoKGQgPSBkZWNvcmF0b3JzW2ldKSlcbiAgICAgICAgICAgICAgICAgIHIgPVxuICAgICAgICAgICAgICAgICAgICAoYyA8IDNcbiAgICAgICAgICAgICAgICAgICAgICA/IGQocilcbiAgICAgICAgICAgICAgICAgICAgICA6IGMgPiAzXG4gICAgICAgICAgICAgICAgICAgICAgPyBkKHRhcmdldCwga2V5LCByKVxuICAgICAgICAgICAgICAgICAgICAgIDogZCh0YXJnZXQsIGtleSkpIHx8IHJcbiAgICAgICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUFxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QoZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbJ3Rocm93J10odmFsdWUpKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb25lXG4gICAgICAgICAgICAgICAgICA/IHJlc29sdmUocmVzdWx0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGVwKFxuICAgICAgICAgICAgICAgIChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgICAgICAgIHZhciBfID0ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAwLFxuICAgICAgICAgICAgICAgIHNlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRbMV1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyeXM6IFtdLFxuICAgICAgICAgICAgICAgIG9wczogW10sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGYsXG4gICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgIGdcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChnID0geyBuZXh0OiB2ZXJiKDApLCB0aHJvdzogdmVyYigxKSwgcmV0dXJuOiB2ZXJiKDIpIH0pLFxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy4nKVxuICAgICAgICAgICAgICB3aGlsZSAoXylcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoKGYgPSAxKSxcbiAgICAgICAgICAgICAgICAgICAgeSAmJlxuICAgICAgICAgICAgICAgICAgICAgICh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wWzBdICYgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlbJ3JldHVybiddXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogb3BbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyB5Wyd0aHJvdyddIHx8ICgodCA9IHlbJ3JldHVybiddKSAmJiB0LmNhbGwoeSksIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogeS5uZXh0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgICAgICAgICAgICBpZiAoKCh5ID0gMCksIHQpKSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdXG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcFxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKytcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrK1xuICAgICAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXVxuICAgICAgICAgICAgICAgICAgICAgIG9wID0gWzBdXG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEoKHQgPSBfLnRyeXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBvcFswXSA9PT0gMyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSlcbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG9wXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXylcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IFs2LCBlXVxuICAgICAgICAgICAgICAgICAgeSA9IDBcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgZiA9IHQgPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXVxuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrXG4gICAgICAgICAgICBvW2syXSA9IG1ba11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBtKVxuICAgICAgICAgICAgICBpZiAocCAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKVxuICAgICAgICAgICAgICAgIGV4cG9ydHNbcF0gPSBtW3BdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICAgICAgICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcixcbiAgICAgICAgICAgICAgbSA9IHMgJiYgb1tzXSxcbiAgICAgICAgICAgICAgaSA9IDBcbiAgICAgICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pXG4gICAgICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIHMgPyAnT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS4nIDogJ1N5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgICAgICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBvW1N5bWJvbC5pdGVyYXRvcl1cbiAgICAgICAgICAgIGlmICghbSkgcmV0dXJuIG9cbiAgICAgICAgICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICBhciA9IFtdLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBlID0geyBlcnJvcjogZXJyb3IgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVsncmV0dXJuJ10pKSBtLmNhbGwoaSlcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBhclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICAgICAgICBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGhcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal1cbiAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXRcbiAgICAgICAgICAgICAgPyAoKHRoaXMudiA9IHYpLCB0aGlzKVxuICAgICAgICAgICAgICA6IG5ldyBfX2F3YWl0KHYpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLicpXG4gICAgICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgcSA9IFtdXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaSA9IHt9KSxcbiAgICAgICAgICAgICAgdmVyYignbmV4dCcpLFxuICAgICAgICAgICAgICB2ZXJiKCd0aHJvdycpLFxuICAgICAgICAgICAgICB2ZXJiKCdyZXR1cm4nKSxcbiAgICAgICAgICAgICAgKGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICAgICAgaWYgKGdbbl0pXG4gICAgICAgICAgICAgICAgaVtuXSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0ZXAoZ1tuXSh2KSlcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHNldHRsZShxWzBdWzNdLCBlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHtcbiAgICAgICAgICAgICAgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXRcbiAgICAgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KVxuICAgICAgICAgICAgICAgIDogc2V0dGxlKHFbMF1bMl0sIHIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc3VtZSgnbmV4dCcsIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc3VtZSgndGhyb3cnLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7XG4gICAgICAgICAgICAgIGlmICgoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICAgICAgICAgICAgdmFyIGksIHBcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpID0ge30pLFxuICAgICAgICAgICAgICB2ZXJiKCduZXh0JyksXG4gICAgICAgICAgICAgIHZlcmIoJ3Rocm93JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB2ZXJiKCdyZXR1cm4nKSxcbiAgICAgICAgICAgICAgKGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7XG4gICAgICAgICAgICAgIGlbbl0gPSBvW25dXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHAgPSAhcClcbiAgICAgICAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09ICdyZXR1cm4nIH1cbiAgICAgICAgICAgICAgICAgICAgICA6IGZcbiAgICAgICAgICAgICAgICAgICAgICA/IGYodilcbiAgICAgICAgICAgICAgICAgICAgICA6IHZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IGZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLicpXG4gICAgICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLFxuICAgICAgICAgICAgICBpXG4gICAgICAgICAgICByZXR1cm4gbVxuICAgICAgICAgICAgICA/IG0uY2FsbChvKVxuICAgICAgICAgICAgICA6ICgobyA9XG4gICAgICAgICAgICAgICAgICB0eXBlb2YgX192YWx1ZXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyBfX3ZhbHVlcyhvKVxuICAgICAgICAgICAgICAgICAgICA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpKSxcbiAgICAgICAgICAgICAgICAoaSA9IHt9KSxcbiAgICAgICAgICAgICAgICB2ZXJiKCduZXh0JyksXG4gICAgICAgICAgICAgICAgdmVyYigndGhyb3cnKSxcbiAgICAgICAgICAgICAgICB2ZXJiKCdyZXR1cm4nKSxcbiAgICAgICAgICAgICAgICAoaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGkpXG4gICAgICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICAgICAgaVtuXSA9XG4gICAgICAgICAgICAgICAgb1tuXSAmJlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICA7KHYgPSBvW25dKHYpKSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7XG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pXG4gICAgICAgICAgICAgIH0sIHJlamVjdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCAncmF3JywgeyB2YWx1ZTogcmF3IH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb29rZWQucmF3ID0gcmF3XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29va2VkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpXG4gICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbW9kKVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba11cbiAgICAgICAgICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gICAgICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIC8qIG1vZHVsZSBkZWNvcmF0b3IgKi8gbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQobW9kdWxlKVxuICAgICAgICAgIHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuICAgICAgICAgIDsoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cbiAgICAgICAgICAgIHZhciBmcmVlRXhwb3J0cyA9IHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzXG4gICAgICAgICAgICB2YXIgZnJlZU1vZHVsZSA9IHRydWUgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlXG4gICAgICAgICAgICB2YXIgZnJlZUdsb2JhbCA9XG4gICAgICAgICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPT0gJ29iamVjdCcgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG4gICAgICAgICAgICAgIGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG4gICAgICAgICAgICAgIGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSBmcmVlR2xvYmFsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuICAgICAgICAgICAgICogQG5hbWUgcHVueWNvZGVcbiAgICAgICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcHVueWNvZGUsXG4gICAgICAgICAgICAgIC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbiAgICAgICAgICAgICAgbWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuICAgICAgICAgICAgICAvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG4gICAgICAgICAgICAgIGJhc2UgPSAzNixcbiAgICAgICAgICAgICAgdE1pbiA9IDEsXG4gICAgICAgICAgICAgIHRNYXggPSAyNixcbiAgICAgICAgICAgICAgc2tldyA9IDM4LFxuICAgICAgICAgICAgICBkYW1wID0gNzAwLFxuICAgICAgICAgICAgICBpbml0aWFsQmlhcyA9IDcyLFxuICAgICAgICAgICAgICBpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcbiAgICAgICAgICAgICAgLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbiAgICAgICAgICAgICAgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG4gICAgICAgICAgICAgIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuICAgICAgICAgICAgICByZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgIC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuICAgICAgICAgICAgICBlcnJvcnMgPSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG4gICAgICAgICAgICAgICAgJ25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0JyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuICAgICAgICAgICAgICBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG4gICAgICAgICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcbiAgICAgICAgICAgICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuICAgICAgICAgICAgICBrZXlcblxuICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICAgICAgICAgICAgICogaXRlbS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXVxuICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICAgICAgICAgICAgICogYWRkcmVzc2VzLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAgICAgICAgICAgICAqIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgKiBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJylcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFydHNbMF0gKyAnQCdcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBwYXJ0c1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cbiAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKVxuICAgICAgICAgICAgICB2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyBlbmNvZGVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICAgICAgICAgICAgICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICAgICAgICAgICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAgICAgICAgICAgICAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICAgICAgICAgICAgICogbWF0Y2hpbmcgVVRGLTE2LlxuICAgICAgICAgICAgICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gICAgICAgICAgICAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gICAgICAgICAgICAgKiBAbmFtZSBkZWNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBjb3VudGVyID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKylcbiAgICAgICAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweGZjMDApID09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICgodmFsdWUgJiAweDNmZikgPDwgMTApICsgKGV4dHJhICYgMHgzZmYpICsgMHgxMDAwMFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXItLVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgICAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAgICAgICAgICAgICAqIEBuYW1lIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICAgICAgICAgICAgICByZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gJydcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlIC09IDB4MTAwMDBcbiAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgICAgICgodmFsdWUgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAweGRjMDAgfCAodmFsdWUgJiAweDNmZilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgICAgICAgIH0pLmpvaW4oJycpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICAgICAgICAgICAgICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gICAgICAgICAgICAgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gICAgICAgICAgICAgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSAyMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDY1XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gOTdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICAgICAgICAgICAgICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICAgICAgICAgICAgICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuICAgICAgICAgICAgICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuICAgICAgICAgICAgICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gICAgICAgICAgICAgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwXG4gICAgICAgICAgICAgIGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDFcbiAgICAgICAgICAgICAgZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8qIG5vIGluaXRpYWxpemF0aW9uICovIGRlbHRhID4gKGJhc2VNaW51c1RNaW4gKiB0TWF4KSA+PiAxO1xuICAgICAgICAgICAgICAgIGsgKz0gYmFzZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoayArICgoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEpIC8gKGRlbHRhICsgc2tldykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAgICAgICAgICAgICAqIHN5bWJvbHMuXG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICAgIC8vIERvbid0IHVzZSBVQ1MtMlxuICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb3V0LFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIG4gPSBpbml0aWFsTixcbiAgICAgICAgICAgICAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG4gICAgICAgICAgICAgICAgYmFzaWMsXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBvbGRpLFxuICAgICAgICAgICAgICAgIHcsXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICBkaWdpdCxcbiAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuICAgICAgICAgICAgICAgIGJhc2VNaW51c1RcblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcbiAgICAgICAgICAgICAgLy8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcbiAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cbiAgICAgICAgICAgICAgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpXG4gICAgICAgICAgICAgIGlmIChiYXNpYyA8IDApIHtcbiAgICAgICAgICAgICAgICBiYXNpYyA9IDBcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ25vdC1iYXNpYycpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG4gICAgICAgICAgICAgIC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7XG4gICAgICAgICAgICAgICAgaW5kZXggPCBpbnB1dExlbmd0aCAvKiBubyBmaW5hbCBleHByZXNzaW9uICovO1xuXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2UgLyogbm8gY29uZGl0aW9uICovO1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgayArPSBiYXNlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ2ludmFsaWQtaW5wdXQnKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGkgKz0gZGlnaXQgKiB3XG4gICAgICAgICAgICAgICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXNcblxuICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0IDwgdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBiYXNlTWludXNUID0gYmFzZSAtIHRcbiAgICAgICAgICAgICAgICAgIGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93JylcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdyAqPSBiYXNlTWludXNUXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDFcbiAgICAgICAgICAgICAgICBiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKVxuXG4gICAgICAgICAgICAgICAgLy8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcbiAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuICAgICAgICAgICAgICAgIGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbiArPSBmbG9vcihpIC8gb3V0KVxuICAgICAgICAgICAgICAgIGkgJT0gb3V0XG5cbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZShpKyssIDAsIG4pXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAgICAgICAgICAgICAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgICAgICAgICAgIHZhciBuLFxuICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgIGhhbmRsZWRDUENvdW50LFxuICAgICAgICAgICAgICAgIGJhc2ljTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGJpYXMsXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHEsXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuICAgICAgICAgICAgICAgIGlucHV0TGVuZ3RoLFxuICAgICAgICAgICAgICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuICAgICAgICAgICAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcbiAgICAgICAgICAgICAgICBiYXNlTWludXNULFxuICAgICAgICAgICAgICAgIHFNaW51c1RcblxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG4gICAgICAgICAgICAgIGlucHV0ID0gdWNzMmRlY29kZShpbnB1dClcblxuICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgbGVuZ3RoXG4gICAgICAgICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoXG5cbiAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgbiA9IGluaXRpYWxOXG4gICAgICAgICAgICAgIGRlbHRhID0gMFxuICAgICAgICAgICAgICBiaWFzID0gaW5pdGlhbEJpYXNcblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGhcblxuICAgICAgICAgICAgICAvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcbiAgICAgICAgICAgICAgLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG4gICAgICAgICAgICAgIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuICAgICAgICAgICAgICBpZiAoYmFzaWNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChkZWxpbWl0ZXIpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBNYWluIGVuY29kaW5nIGxvb3A6XG4gICAgICAgICAgICAgIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgIC8vIGxhcmdlciBvbmU6XG4gICAgICAgICAgICAgICAgZm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdXG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICAgICAgICAgICAgICBtID0gY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG4gICAgICAgICAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxXG4gICAgICAgICAgICAgICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZVxuICAgICAgICAgICAgICAgIG4gPSBtXG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal1cblxuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gZGVsdGEsIGsgPSBiYXNlIC8qIG5vIGNvbmRpdGlvbiAqLzsgOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXNcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocSA8IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHFNaW51c1QgPSBxIC0gdFxuICAgICAgICAgICAgICAgICAgICAgIGJhc2VNaW51c1QgPSBiYXNlIC0gdFxuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nRnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdFRvQmFzaWModCArIChxTWludXNUICUgYmFzZU1pbnVzVCksIDApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKVxuICAgICAgICAgICAgICAgICAgICBiaWFzID0gYWRhcHQoXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAwXG4gICAgICAgICAgICAgICAgICAgICsraGFuZGxlZENQQ291bnRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICArK2RlbHRhXG4gICAgICAgICAgICAgICAgKytuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAgICAgICAgICAgICAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAgICAgICAgICAgICAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICAgICAgICAgICAgICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAgICAgICAgICAgICAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICAgICAgICAgICAgICogc3RyaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICA6IHN0cmluZ1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICAgICAgICAgICAgICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gICAgICAgICAgICAgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAgICAgICAgICAgICAqIEFTQ0lJLlxuICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICAgICAgICAgICAgICogVW5pY29kZSBzdHJpbmcuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gICAgICAgICAgICAgKiBlbWFpbCBhZGRyZXNzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcbiAgICAgICAgICAgICAgICAgID8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcbiAgICAgICAgICAgICAgICAgIDogc3RyaW5nXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgICAgICAvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG4gICAgICAgICAgICBwdW55Y29kZSA9IHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cbiAgICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMy4yJyxcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG4gICAgICAgICAgICAgICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAgICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICB1Y3MyOiB7XG4gICAgICAgICAgICAgICAgZGVjb2RlOiB1Y3MyZGVjb2RlLFxuICAgICAgICAgICAgICAgIGVuY29kZTogdWNzMmVuY29kZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICAgICAgICB0b0FTQ0lJOiB0b0FTQ0lJLFxuICAgICAgICAgICAgICB0b1VuaWNvZGU6IHRvVW5pY29kZSxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG4gICAgICAgICAgICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcbiAgICAgICAgICAgIC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICEoKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdW55Y29kZVxuICAgICAgICAgICAgICB9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSksXG4gICAgICAgICAgICAgIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKHRoaXMpXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAgICAgICAgICAvLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gICAgICAgICAgLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gICAgICAgICAgLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICAgICAgICAgIC8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbiAgICAgICAgICAvLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAgICAgICAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gICAgICAgICAgLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gICAgICAgICAgLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgICAgICAgIC8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbiAgICAgICAgICAvLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAgICAgICAgICAvLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAgICAgICAgICAvLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4gICAgICAgICAgLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuICAgICAgICAgIHZhciBwdW55Y29kZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgcHVueWNvZGUgKi8gJy4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3V0aWwgKi8gJy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIGV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZVxuICAgICAgICAgIGV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmVcbiAgICAgICAgICBleHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0XG4gICAgICAgICAgZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXRcblxuICAgICAgICAgIGV4cG9ydHMuVXJsID0gVXJsXG5cbiAgICAgICAgICBmdW5jdGlvbiBVcmwoKSB7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5hdXRoID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5ob3N0ID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuaGFzaCA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IG51bGxcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBudWxsXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBudWxsXG4gICAgICAgICAgICB0aGlzLmhyZWYgPSBudWxsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbiAgICAgICAgICAvLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuICAgICAgICAgIC8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxuICAgICAgICAgIHZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgICAgICAgICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgICAgICAgICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuICAgICAgICAgICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAgICAgICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgICAgICAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcbiAgICAgICAgICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgICAgICAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG4gICAgICAgICAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgICAgICAgICBhdXRvRXNjYXBlID0gW1wiJ1wiXS5jb25jYXQodW53aXNlKSxcbiAgICAgICAgICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgICAgICAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAgICAgICAgIC8vIHRoZW0uXG4gICAgICAgICAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICAgICAgICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICAgICAgICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgICAgICAgICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICAgICAgICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgICAgICAgICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgICAgICAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICAgICAgICAgamF2YXNjcmlwdDogdHJ1ZSxcbiAgICAgICAgICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgICAgICAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgICAgICAgICBqYXZhc2NyaXB0OiB0cnVlLFxuICAgICAgICAgICAgICAnamF2YXNjcmlwdDonOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgICAgICAgICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgICAgICAgICBodHRwOiB0cnVlLFxuICAgICAgICAgICAgICBodHRwczogdHJ1ZSxcbiAgICAgICAgICAgICAgZnRwOiB0cnVlLFxuICAgICAgICAgICAgICBnb3BoZXI6IHRydWUsXG4gICAgICAgICAgICAgIGZpbGU6IHRydWUsXG4gICAgICAgICAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAgICAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgICAgICAgICAnZnRwOic6IHRydWUsXG4gICAgICAgICAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICAgICAgICAgJ2ZpbGU6JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxdWVyeXN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISBxdWVyeXN0cmluZyAqLyAnLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMnXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICBmdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICAgICAgICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmxcblxuICAgICAgICAgICAgdmFyIHUgPSBuZXcgVXJsKClcbiAgICAgICAgICAgIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdClcbiAgICAgICAgICAgIHJldHVybiB1XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIHBhcnNlUXVlcnlTdHJpbmcsXG4gICAgICAgICAgICBzbGFzaGVzRGVub3RlSG9zdFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gICAgICAgICAgICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gICAgICAgICAgICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICAgICAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAgICAgICBxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSA/ICc/JyA6ICcjJyxcbiAgICAgICAgICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgICAgICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2dcbiAgICAgICAgICAgIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJylcbiAgICAgICAgICAgIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKVxuXG4gICAgICAgICAgICB2YXIgcmVzdCA9IHVybFxuXG4gICAgICAgICAgICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICAgICAgICAgICAgcmVzdCA9IHJlc3QudHJpbSgpXG5cbiAgICAgICAgICAgIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgICAgICAgICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KVxuICAgICAgICAgICAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHJlc3RcbiAgICAgICAgICAgICAgICB0aGlzLmhyZWYgPSByZXN0XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV1cbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSAnJ1xuICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdClcbiAgICAgICAgICAgIGlmIChwcm90bykge1xuICAgICAgICAgICAgICBwcm90byA9IHByb3RvWzBdXG4gICAgICAgICAgICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90b1xuICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAgICAgICAgICAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAgICAgICAgICAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAgICAgICAgICAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNsYXNoZXNEZW5vdGVIb3N0IHx8XG4gICAgICAgICAgICAgIHByb3RvIHx8XG4gICAgICAgICAgICAgIHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJ1xuICAgICAgICAgICAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKVxuICAgICAgICAgICAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgICAgICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgICAgICAgICAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgICAgICAgICAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgICAgICAgICAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIGV4OlxuICAgICAgICAgICAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgICAgICAgICAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAgICAgICAgICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgICAgICAgICAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICAgICAgICAgICAgdmFyIGhvc3RFbmQgPSAtMVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKVxuICAgICAgICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgICAgICAgICAgIGhvc3RFbmQgPSBoZWNcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgICAgICAgICAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICAgICAgICAgICAgdmFyIGF1dGgsIGF0U2lnblxuICAgICAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgICAgICAgICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgICAgICAgICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKVxuICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgICAgICAgICAgIGhvc3RFbmQgPSAtMVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKVxuICAgICAgICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgICAgICAgICAgIGhvc3RFbmQgPSBoZWNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgICAgICAgICAgIGlmIChob3N0RW5kID09PSAtMSkgaG9zdEVuZCA9IHJlc3QubGVuZ3RoXG5cbiAgICAgICAgICAgICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKVxuICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKVxuXG4gICAgICAgICAgICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgICAgICAgICAgIHRoaXMucGFyc2VIb3N0KClcblxuICAgICAgICAgICAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgICAgICAgICAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJ1xuXG4gICAgICAgICAgICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgICAgICAgICAgICB2YXIgaXB2Nkhvc3RuYW1lID1cbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJ1xuXG4gICAgICAgICAgICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgICAgICAgICAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV1cbiAgICAgICAgICAgICAgICAgIGlmICghcGFydCkgY29udGludWVcbiAgICAgICAgICAgICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJylcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gJydcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAgICAgICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgICAgICAgICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnXG4gICAgICAgICAgICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJ1xuICAgICAgICAgICAgICB0aGlzLmhvc3QgPSBoICsgcFxuICAgICAgICAgICAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0XG5cbiAgICAgICAgICAgICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgICAgICAgICAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgICAgICAgICAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICByZXN0ID0gJy8nICsgcmVzdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgICAgICAgICAgIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgICAgICAgICAgIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcbiAgICAgICAgICAgICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgICAgICAgICAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZS5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV1cbiAgICAgICAgICAgICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSlcbiAgICAgICAgICAgICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICAgICAgICAgICAgZXNjID0gZXNjYXBlKGFlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgICAgICAgICAgIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJylcbiAgICAgICAgICAgIGlmIChoYXNoICE9PSAtMSkge1xuICAgICAgICAgICAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgICAgICAgICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpXG4gICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKVxuICAgICAgICAgICAgaWYgKHFtICE9PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKVxuICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKVxuICAgICAgICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gJydcbiAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgICAgICAgIXRoaXMucGF0aG5hbWVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gJy8nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJ1xuICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnXG4gICAgICAgICAgICAgIHRoaXMucGF0aCA9IHAgKyBzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICAgICAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG4gICAgICAgICAgZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgICAgICAgICAgIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAgICAgICAgICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gICAgICAgICAgICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKVxuICAgICAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKVxuICAgICAgICAgICAgcmV0dXJuIG9iai5mb3JtYXQoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIFVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJydcbiAgICAgICAgICAgIGlmIChhdXRoKSB7XG4gICAgICAgICAgICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aClcbiAgICAgICAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6JylcbiAgICAgICAgICAgICAgYXV0aCArPSAnQCdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgICAgICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgICAgICAgICBob3N0ID0gZmFsc2UsXG4gICAgICAgICAgICAgIHF1ZXJ5ID0gJydcblxuICAgICAgICAgICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgICAgICAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgIGhvc3QgPVxuICAgICAgICAgICAgICAgIGF1dGggK1xuICAgICAgICAgICAgICAgICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgID8gdGhpcy5ob3N0bmFtZVxuICAgICAgICAgICAgICAgICAgOiAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKVxuICAgICAgICAgICAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICAgICAgICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMucXVlcnkgJiZcbiAgICAgICAgICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICc/JyArIHF1ZXJ5KSB8fCAnJ1xuXG4gICAgICAgICAgICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOidcblxuICAgICAgICAgICAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gICAgICAgICAgICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0aGlzLnNsYXNoZXMgfHxcbiAgICAgICAgICAgICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJylcbiAgICAgICAgICAgICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKVxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICAgICAgICAgICAgaG9zdCA9ICcnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoXG4gICAgICAgICAgICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgICAgICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gICAgICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBVcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmVcbiAgICAgICAgICAgIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIFVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgICAgICAgICAgIHZhciByZWwgPSBuZXcgVXJsKClcbiAgICAgICAgICAgICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgcmVsYXRpdmUgPSByZWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKVxuICAgICAgICAgICAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcylcbiAgICAgICAgICAgIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICAgICAgICAgICAgdmFyIHRrZXkgPSB0a2V5c1t0a11cbiAgICAgICAgICAgICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgICAgICAgICAgIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoXG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICAgICAgICAgICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpXG4gICAgICAgICAgICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXVxuICAgICAgICAgICAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKSByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5wYXRobmFtZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJ1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgICAgICAgICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgICAgICAgICAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAgICAgICAgICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAgICAgICAgICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAgICAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgICAgICAgICAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW3ZdXG4gICAgICAgICAgICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKVxuICAgICAgICAgICAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJ1xuICAgICAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJydcbiAgICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJylcbiAgICAgICAgICAgICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2hcbiAgICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnXG4gICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aFxuICAgICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0XG4gICAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgICAgICAgICAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJ1xuICAgICAgICAgICAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJ1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gcCArIHNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXNcbiAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNTb3VyY2VBYnMgPVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsXG4gICAgICAgICAgICAgIGlzUmVsQWJzID1cbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgICAgICAgKHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgICAgICAgICAgbXVzdEVuZEFicyA9XG4gICAgICAgICAgICAgICAgaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICAgICAgICAgIHNyY1BhdGggPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpKSB8fCBbXSxcbiAgICAgICAgICAgICAgcmVsUGF0aCA9XG4gICAgICAgICAgICAgICAgKHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykpIHx8IFtdLFxuICAgICAgICAgICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdXG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgICAgICAgICAgIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gICAgICAgICAgICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgICAgICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gJydcbiAgICAgICAgICAgICAgcmVzdWx0LnBvcnQgPSBudWxsXG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgICAgICAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0XG4gICAgICAgICAgICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSAnJ1xuICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbFxuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0XG4gICAgICAgICAgICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG11c3RFbmRBYnMgPVxuICAgICAgICAgICAgICAgIG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNSZWxBYnMpIHtcbiAgICAgICAgICAgICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPVxuICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJydcbiAgICAgICAgICAgICAgICAgID8gcmVsYXRpdmUuaG9zdFxuICAgICAgICAgICAgICAgICAgOiByZXN1bHQuaG9zdFxuICAgICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPVxuICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJ1xuICAgICAgICAgICAgICAgICAgPyByZWxhdGl2ZS5ob3N0bmFtZVxuICAgICAgICAgICAgICAgICAgOiByZXN1bHQuaG9zdG5hbWVcbiAgICAgICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaFxuICAgICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICAgICAgICBzcmNQYXRoID0gcmVsUGF0aFxuICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gaXQncyByZWxhdGl2ZVxuICAgICAgICAgICAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICAgICAgICAgICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW11cbiAgICAgICAgICAgICAgc3JjUGF0aC5wb3AoKVxuICAgICAgICAgICAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aClcbiAgICAgICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaFxuICAgICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgICAgICAgICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAgICAgICAgICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAgICAgICAgICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgICAgICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKVxuICAgICAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgICAgICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KClcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2hcbiAgICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgICAgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPVxuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsXG4gICAgICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2hcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAgICAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gICAgICAgICAgICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAgICAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXVxuICAgICAgICAgICAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPVxuICAgICAgICAgICAgICAoKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgICAgICAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykpIHx8XG4gICAgICAgICAgICAgIGxhc3QgPT09ICcnXG5cbiAgICAgICAgICAgIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gICAgICAgICAgICB2YXIgdXAgPSAwXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGxhc3QgPSBzcmNQYXRoW2ldXG4gICAgICAgICAgICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgICAgIHVwKytcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpXG4gICAgICAgICAgICAgICAgdXAtLVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgICAgICAgICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgICAgICAgICAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG11c3RFbmRBYnMgJiZcbiAgICAgICAgICAgICAgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICAgICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiBzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgc3JjUGF0aC5wdXNoKCcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9XG4gICAgICAgICAgICAgIHNyY1BhdGhbMF0gPT09ICcnIHx8IChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpXG5cbiAgICAgICAgICAgIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gICAgICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZVxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IHNyY1BhdGgubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBzcmNQYXRoLnNoaWZ0KClcbiAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID1cbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwXG4gICAgICAgICAgICAgICAgICA/IHJlc3VsdC5ob3N0LnNwbGl0KCdAJylcbiAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKVxuXG4gICAgICAgICAgICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoJycpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbFxuICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgICAgICAgICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPVxuICAgICAgICAgICAgICAgIChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoXG4gICAgICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXNcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdFxuICAgICAgICAgICAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpXG4gICAgICAgICAgICBpZiAocG9ydCkge1xuICAgICAgICAgICAgICBwb3J0ID0gcG9ydFswXVxuICAgICAgICAgICAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgaXNTdHJpbmc6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNPYmplY3Q6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTnVsbDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnID09PSBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZyA9PSBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBhcmcgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuICAgICAgICAgIHZhciBpc0FyZ3VtZW50c09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaXMtYXJndW1lbnRzICovICcuL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBpcy1nZW5lcmF0b3ItZnVuY3Rpb24gKi8gJy4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIHdoaWNoVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgd2hpY2gtdHlwZWQtYXJyYXkgKi8gJy4vbm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBpcy10eXBlZC1hcnJheSAqLyAnLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICAgICAgICAgICAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgdmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG5cbiAgICAgICAgICB2YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKVxuXG4gICAgICAgICAgdmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKVxuICAgICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZilcbiAgICAgICAgICB2YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZilcblxuICAgICAgICAgIGlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3RcbiAgICAgICAgICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uXG4gICAgICAgICAgZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXlcblxuICAgICAgICAgIC8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbiAgICAgICAgICBmdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB8fFxuICAgICAgICAgICAgICAoaW5wdXQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzRGF0YVZpZXcodmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlld1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXlcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01hcFRvU3RyaW5nLndvcmtpbmcgPVxuICAgICAgICAgICAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgICAgICAgICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcFxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzTWFwID0gaXNNYXBcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU2V0VG9TdHJpbmcud29ya2luZyA9XG4gICAgICAgICAgICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbiAgICAgICAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgICAgICAgICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldFxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzU2V0ID0gaXNTZXRcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9XG4gICAgICAgICAgICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbiAgICAgICAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgICAgICAgICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPVxuICAgICAgICAgICAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4gICAgICAgICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPVxuICAgICAgICAgICAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuICAgICAgICAgIGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICAgICAgICAgICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPVxuICAgICAgICAgICAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuICAgICAgICAgIGZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICAgICAgICAgICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlld1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPVxuICAgICAgICAgICAgdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigpKVxuICAgICAgICAgIGZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICAgICAgICAgICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvblxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvclxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvclxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3RcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3RcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3RcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3RcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmVcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXJcblxuICAgICAgICAgIDtbJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goXG4gICAgICAgICAgICBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgcHJvY2Vzcy9icm93c2VyICovICcuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIC8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNvbnNvbGUtYnJvd3NlcmlmeSAqLyAnLi9ub2RlX21vZHVsZXMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gICAgICAgICAgLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICAgICAgICAgIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAgICAgICAgIC8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAgICAgICAgICAvLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gICAgICAgICAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gICAgICAgICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAgICAgICAgIC8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAgICAgICAgIC8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICAgICAgICAvLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gICAgICAgICAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gICAgICAgICAgLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4gICAgICAgICAgLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICAgICAgICAgIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAgICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICAgIG9iaixcbiAgICAgICAgICAgICAgICAgIGtleXNbaV1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZ1xuICAgICAgICAgIGV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICAgICAgICAgICAgdmFyIG9iamVjdHMgPSBbXVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aFxuICAgICAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSdcbiAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geFxuICAgICAgICAgICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlICclcyc6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSlcbiAgICAgICAgICAgICAgICBjYXNlICclZCc6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSlcbiAgICAgICAgICAgICAgICBjYXNlICclaic6XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKVxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgICAgICAgICAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyB4XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICAgICAgLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAgICAgICAgICAvLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICAgICAgICAgIGV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZuLCBtc2cpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlXG4gICAgICAgICAgICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgICAgICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UobXNnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybmVkID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZXByZWNhdGVkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlYnVncyA9IHt9XG4gICAgICAgICAgdmFyIGRlYnVnRW52UmVnZXggPSAvXiQvXG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICAgICAgICAgICAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVR1xuICAgICAgICAgICAgZGVidWdFbnYgPSBkZWJ1Z0VudlxuICAgICAgICAgICAgICAucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgIGlmICghZGVidWdzW3NldF0pIHtcbiAgICAgICAgICAgICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkXG4gICAgICAgICAgICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVidWdzW3NldF1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gICAgICAgICAgICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuICAgICAgICAgIGZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICAgIHNlZW46IFtdLFxuICAgICAgICAgICAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvcixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxlZ2FjeS4uLlxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdXG4gICAgICAgICAgICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgICAgICAgICAgIC8vIGxlZ2FjeS4uLlxuICAgICAgICAgICAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cykge1xuICAgICAgICAgICAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgICAgICAgICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMlxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZVxuICAgICAgICAgICAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3RcblxuICAgICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgICAgICAgIGluc3BlY3QuY29sb3JzID0ge1xuICAgICAgICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgICAgICAgIGl0YWxpYzogWzMsIDIzXSxcbiAgICAgICAgICAgIHVuZGVybGluZTogWzQsIDI0XSxcbiAgICAgICAgICAgIGludmVyc2U6IFs3LCAyN10sXG4gICAgICAgICAgICB3aGl0ZTogWzM3LCAzOV0sXG4gICAgICAgICAgICBncmV5OiBbOTAsIDM5XSxcbiAgICAgICAgICAgIGJsYWNrOiBbMzAsIDM5XSxcbiAgICAgICAgICAgIGJsdWU6IFszNCwgMzldLFxuICAgICAgICAgICAgY3lhbjogWzM2LCAzOV0sXG4gICAgICAgICAgICBncmVlbjogWzMyLCAzOV0sXG4gICAgICAgICAgICBtYWdlbnRhOiBbMzUsIDM5XSxcbiAgICAgICAgICAgIHJlZDogWzMxLCAzOV0sXG4gICAgICAgICAgICB5ZWxsb3c6IFszMywgMzldLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuICAgICAgICAgIGluc3BlY3Quc3R5bGVzID0ge1xuICAgICAgICAgICAgc3BlY2lhbDogJ2N5YW4nLFxuICAgICAgICAgICAgbnVtYmVyOiAneWVsbG93JyxcbiAgICAgICAgICAgIGJvb2xlYW46ICd5ZWxsb3cnLFxuICAgICAgICAgICAgdW5kZWZpbmVkOiAnZ3JleScsXG4gICAgICAgICAgICBudWxsOiAnYm9sZCcsXG4gICAgICAgICAgICBzdHJpbmc6ICdncmVlbicsXG4gICAgICAgICAgICBkYXRlOiAnbWFnZW50YScsXG4gICAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICAgcmVnZXhwOiAncmVkJyxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdXG5cbiAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICdcXHUwMDFiWycgK1xuICAgICAgICAgICAgICAgIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArXG4gICAgICAgICAgICAgICAgJ20nICtcbiAgICAgICAgICAgICAgICBzdHIgK1xuICAgICAgICAgICAgICAgICdcXHUwMDFiWycgK1xuICAgICAgICAgICAgICAgIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArXG4gICAgICAgICAgICAgICAgJ20nXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHt9XG5cbiAgICAgICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgICAgICAgICAgIGhhc2hbdmFsXSA9IHRydWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBoYXNoXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgICAgICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAgICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpXG4gICAgICAgICAgICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgICAgICAgICAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKVxuICAgICAgICAgICAgaWYgKHByaW1pdGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgICAgICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKVxuXG4gICAgICAgICAgICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICAgICAgICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpc0Vycm9yKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoXG4gICAgICAgICAgICAgICAgICBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgJ3JlZ2V4cCdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJhc2UgPSAnJyxcbiAgICAgICAgICAgICAgYXJyYXkgPSBmYWxzZSxcbiAgICAgICAgICAgICAgYnJhY2VzID0gWyd7JywgJ30nXVxuXG4gICAgICAgICAgICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgYXJyYXkgPSB0cnVlXG4gICAgICAgICAgICAgIGJyYWNlcyA9IFsnWycsICddJ11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJ1xuICAgICAgICAgICAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICAgICAgICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gICAgICAgICAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcbiAgICAgICAgICAgICAgICAgIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAncmVnZXhwJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zZWVuLnB1c2godmFsdWUpXG5cbiAgICAgICAgICAgIHZhciBvdXRwdXRcbiAgICAgICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgcmVjdXJzZVRpbWVzLFxuICAgICAgICAgICAgICAgICAgdmlzaWJsZUtleXMsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICBhcnJheVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnNlZW4ucG9wKClcblxuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICB2YXIgc2ltcGxlID1cbiAgICAgICAgICAgICAgICBcIidcIiArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgK1xuICAgICAgICAgICAgICAgIFwiJ1wiXG4gICAgICAgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKVxuICAgICAgICAgICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpXG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gICAgICAgICAgICBpZiAoaXNOdWxsKHZhbHVlKSkgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgICAgICAgICAgIGZvcm1hdFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICByZWN1cnNlVGltZXMsXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVLZXlzLFxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcoaSksXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2VUaW1lcyxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcmVjdXJzZVRpbWVzLFxuICAgICAgICAgICAgdmlzaWJsZUtleXMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBhcnJheVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG5hbWUsIHN0ciwgZGVzY1xuICAgICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwge1xuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVba2V5XSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyKSB7XG4gICAgICAgICAgICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICAgICAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0clxuICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdWJzdHIoMilcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9XG4gICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgIHN0clxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KVxuICAgICAgICAgICAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKVxuICAgICAgICAgICAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpXG4gICAgICAgICAgICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgJzogJyArIHN0clxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gICAgICAgICAgICB2YXIgbnVtTGluZXNFc3QgPSAwXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICAgICAgICAgIG51bUxpbmVzRXN0KytcbiAgICAgICAgICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrXG4gICAgICAgICAgICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMVxuICAgICAgICAgICAgfSwgMClcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICBicmFjZXNbMV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4gICAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG4gICAgICAgICAgZXhwb3J0cy50eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9zdXBwb3J0L3R5cGVzICovICcuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNBcnJheShhcikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXlcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbidcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW5cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcgPT09IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc051bGwgPSBpc051bGxcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZyA9PSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcidcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmdcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnID09PSB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cFxuICAgICAgICAgIGV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNEYXRlID0gaXNEYXRlXG4gICAgICAgICAgZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGVcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgaXNPYmplY3QoZSkgJiZcbiAgICAgICAgICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvclxuICAgICAgICAgIGV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3JcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmVcblxuICAgICAgICAgIGV4cG9ydHMuaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vc3VwcG9ydC9pc0J1ZmZlciAqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFkKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1vbnRocyA9IFtcbiAgICAgICAgICAgICdKYW4nLFxuICAgICAgICAgICAgJ0ZlYicsXG4gICAgICAgICAgICAnTWFyJyxcbiAgICAgICAgICAgICdBcHInLFxuICAgICAgICAgICAgJ01heScsXG4gICAgICAgICAgICAnSnVuJyxcbiAgICAgICAgICAgICdKdWwnLFxuICAgICAgICAgICAgJ0F1ZycsXG4gICAgICAgICAgICAnU2VwJyxcbiAgICAgICAgICAgICdPY3QnLFxuICAgICAgICAgICAgJ05vdicsXG4gICAgICAgICAgICAnRGVjJyxcbiAgICAgICAgICBdXG5cbiAgICAgICAgICAvLyAyNiBGZWIgMTY6MTk6MzRcbiAgICAgICAgICBmdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKClcbiAgICAgICAgICAgIHZhciB0aW1lID0gW1xuICAgICAgICAgICAgICBwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKSxcbiAgICAgICAgICAgIF0uam9pbignOicpXG4gICAgICAgICAgICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuICAgICAgICAgIGV4cG9ydHMubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICclcyAtICVzJyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wKCksXG4gICAgICAgICAgICAgIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gICAgICAgICAgICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAgICAgICAgICAgKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAgICAgICAgICAgKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAgICAgICAgICAgKiAgICAgcHJvdG90eXBlLlxuICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4cG9ydHMuaW5oZXJpdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGluaGVyaXRzICovICcuL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIGV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uIChvcmlnaW4sIGFkZCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICAgICAgICAgICAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW5cblxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpXG4gICAgICAgICAgICB2YXIgaSA9IGtleXMubGVuZ3RoXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9XG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJylcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICAgIGV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbidcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJlxuICAgICAgICAgICAgICBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZuLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBmblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICAgICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0XG4gICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgICAgICAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3RcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KGVycilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpXG5cbiAgICAgICAgICAgIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZuLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG4gICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgICAgICAgICAgIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAgICAgICAgICAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gICAgICAgICAgICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAgICAgICAgICAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICAgICAgICAgICAgaWYgKCFyZWFzb24pIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb25cbiAgICAgICAgICAgICAgcmVhc29uID0gbmV3UmVhc29uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2IocmVhc29uKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gICAgICAgICAgICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgICAgICAgICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJldCkge1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmVqKSB7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoXG4gICAgICAgICAgICAgIGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgICAgICAgICBjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNraWZpZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBmb3JlYWNoICovICcuL25vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGF2YWlsYWJsZS10eXBlZC1hcnJheXMgKi8gJy4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBjYWxsQm91bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNhbGwtYmluZC9jYWxsQm91bmQgKi8gJy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpXG4gICAgICAgICAgdmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGhhcy1zeW1ib2xzICovICcuL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcydcbiAgICAgICAgICApKClcbiAgICAgICAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPVxuICAgICAgICAgICAgaGFzU3ltYm9scyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJ1xuXG4gICAgICAgICAgdmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKVxuXG4gICAgICAgICAgdmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpXG4gICAgICAgICAgdmFyIHRvU3RyVGFncyA9IHt9XG4gICAgICAgICAgdmFyIGdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGVzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICovICcuL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG4gICAgICAgICAgaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IG5ldyBfX3dlYnBhY2tfcmVxdWlyZV9fLmdbdHlwZWRBcnJheV0oKVxuICAgICAgICAgICAgICAgIGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZhbEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAndGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXkgK1xuICAgICAgICAgICAgICAgICAgICAgICcgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy4nXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycilcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZE5hbWUgPSBmYWxzZVxuICAgICAgICAgICAgZm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTmFtZSA9IG5hbWVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kTmFtZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGlzLXR5cGVkLWFycmF5ICovICcuL25vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNUb1N0cmluZ1RhZykge1xuICAgICAgICAgICAgICByZXR1cm4gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKioqKiovXG4gICAgfSAvLyBUaGUgbW9kdWxlIGNhY2hlXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqKioqLyAvKioqKioqLyB2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge30gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiAgICAvKioqKioqL1xuICAgIC8qKioqKiovIC8qKioqKiovIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbiAgICAgIC8qKioqKiovIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuICAgICAgLyoqKioqKi8gdmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF1cbiAgICAgIC8qKioqKiovIGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKioqKioqLyByZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHNcbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH0gLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiAgICAgIC8qKioqKiovIC8qKioqKiovIHZhciBtb2R1bGUgPSAoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbiAgICAgICAgLyoqKioqKi8gaWQ6IG1vZHVsZUlkLFxuICAgICAgICAvKioqKioqLyBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAvKioqKioqLyBleHBvcnRzOiB7fSxcbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH0pIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuICAgICAgLyoqKioqKi9cbiAgICAgIC8qKioqKiovIC8qKioqKiovIF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwoXG4gICAgICAgIG1vZHVsZS5leHBvcnRzLFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIG1vZHVsZS5leHBvcnRzLFxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fXG4gICAgICApIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiAgICAgIC8qKioqKiovXG4gICAgICAvKioqKioqLyAvKioqKioqLyBtb2R1bGUubG9hZGVkID0gdHJ1ZSAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuICAgICAgLyoqKioqKi9cbiAgICAgIC8qKioqKiovIC8qKioqKiovIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICAgICAgLyoqKioqKi9cbiAgICB9IC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuICAgIC8qKioqKiovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqKioqLyAvKioqKioqLyA7KCgpID0+IHtcbiAgICAgIC8qKioqKiovIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbiAgICAgIC8qKioqKiovIF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4gICAgICAgIC8qKioqKiovIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgLyoqKioqKi8gaWYgKFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiZcbiAgICAgICAgICAgICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLyoqKioqKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBnZXQ6IGRlZmluaXRpb25ba2V5XSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICB9XG4gICAgICAgIC8qKioqKiovXG4gICAgICB9XG4gICAgICAvKioqKioqL1xuICAgIH0pKCkgLyogd2VicGFjay9ydW50aW1lL2dsb2JhbCAqL1xuICAgIC8qKioqKiovXG4gICAgLyoqKioqKi8gLyoqKioqKi8gOygoKSA9PiB7XG4gICAgICAvKioqKioqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKioqKioqLyBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpc1xuICAgICAgICAvKioqKioqLyB0cnkge1xuICAgICAgICAgIC8qKioqKiovIHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpXG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8qKioqKiovIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvd1xuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgIH1cbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH0pKClcbiAgICAgIC8qKioqKiovXG4gICAgfSkoKSAvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqLyAvKioqKioqLyA7KCgpID0+IHtcbiAgICAgIC8qKioqKiovIF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApXG4gICAgICAvKioqKioqL1xuICAgIH0pKCkgLyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuICAgIC8qKioqKiovXG4gICAgLyoqKioqKi8gLyoqKioqKi8gOygoKSA9PiB7XG4gICAgICAvKioqKioqLyAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gICAgICAvKioqKioqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuICAgICAgICAvKioqKioqLyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgICAgICAgLyoqKioqKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdNb2R1bGUnLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgfVxuICAgICAgICAvKioqKioqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgIC8qKioqKiovXG4gICAgICB9XG4gICAgICAvKioqKioqL1xuICAgIH0pKCkgLyogd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciAqL1xuICAgIC8qKioqKiovXG4gICAgLyoqKioqKi8gLyoqKioqKi8gOygoKSA9PiB7XG4gICAgICAvKioqKioqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcbiAgICAgICAgLyoqKioqKi8gbW9kdWxlLnBhdGhzID0gW11cbiAgICAgICAgLyoqKioqKi8gaWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdXG4gICAgICAgIC8qKioqKiovIHJldHVybiBtb2R1bGVcbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH1cbiAgICAgIC8qKioqKiovXG4gICAgfSkoKVxuICAgIC8qKioqKiovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9XG4gICAgLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4gICAgOygoKSA9PiB7XG4gICAgICAndXNlIHN0cmljdCdcbiAgICAgIHZhciBleHBvcnRzID0gX193ZWJwYWNrX2V4cG9ydHNfX1xuICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgZXhwb3J0cy5JbWd1ckNsaWVudCA9IHZvaWQgMFxuICAgICAgdmFyIGNsaWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jbGllbnQgKi8gJy4vc3JjL2NsaWVudC50cycpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ltZ3VyQ2xpZW50Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2xpZW50XzEuSW1ndXJDbGllbnRcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSkoKVxuXG4gICAgLyoqKioqKi8gcmV0dXJuIF9fd2VicGFja19leHBvcnRzX19cbiAgICAvKioqKioqL1xuICB9KSgpXG59KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdmQyVmljR0ZqYXk5MWJtbDJaWEp6WVd4TmIyUjFiR1ZFWldacGJtbDBhVzl1SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5aGNuSmhlUzFtYVd4MFpYSXZhVzVrWlhndWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkZ6YzJWeWRDOWlkV2xzWkM5aGMzTmxjblF1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRnpjMlZ5ZEM5aWRXbHNaQzlwYm5SbGNtNWhiQzloYzNObGNuUXZZWE56WlhKMGFXOXVYMlZ5Y205eUxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTloYzNObGNuUXZZblZwYkdRdmFXNTBaWEp1WVd3dlpYSnliM0p6TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWhjM05sY25RdlluVnBiR1F2YVc1MFpYSnVZV3d2ZFhScGJDOWpiMjF3WVhKcGMyOXVjeTVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdllYWmhhV3hoWW14bExYUjVjR1ZrTFdGeWNtRjVjeTlwYm1SbGVDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZhVzVrWlhndWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTloWkdGd2RHVnljeTk0YUhJdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTloZUdsdmN5NXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZiR2xpTDJOaGJtTmxiQzlEWVc1alpXd3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5allXNWpaV3d2UTJGdVkyVnNWRzlyWlc0dWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTlqWVc1alpXd3ZhWE5EWVc1alpXd3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5amIzSmxMMEY0YVc5ekxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTloZUdsdmN5OXNhV0l2WTI5eVpTOUpiblJsY21ObGNIUnZjazFoYm1GblpYSXVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5amIzSmxMMkoxYVd4a1JuVnNiRkJoZEdndWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTlqYjNKbEwyTnlaV0YwWlVWeWNtOXlMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5aGVHbHZjeTlzYVdJdlkyOXlaUzlrYVhOd1lYUmphRkpsY1hWbGMzUXVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5amIzSmxMMlZ1YUdGdVkyVkZjbkp2Y2k1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZZWGhwYjNNdmJHbGlMMk52Y21VdmJXVnlaMlZEYjI1bWFXY3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5amIzSmxMM05sZEhSc1pTNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZiR2xpTDJOdmNtVXZkSEpoYm5ObWIzSnRSR0YwWVM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZZWGhwYjNNdmJHbGlMMlJsWm1GMWJIUnpMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5aGVHbHZjeTlzYVdJdmFHVnNjR1Z5Y3k5aWFXNWtMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5aGVHbHZjeTlzYVdJdmFHVnNjR1Z5Y3k5aWRXbHNaRlZTVEM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZZWGhwYjNNdmJHbGlMMmhsYkhCbGNuTXZZMjl0WW1sdVpWVlNUSE11YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRjRhVzl6TDJ4cFlpOW9aV3h3WlhKekwyTnZiMnRwWlhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTlvWld4d1pYSnpMMmx6UVdKemIyeDFkR1ZWVWt3dWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTlvWld4d1pYSnpMMmx6UVhocGIzTkZjbkp2Y2k1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZZWGhwYjNNdmJHbGlMMmhsYkhCbGNuTXZhWE5WVWt4VFlXMWxUM0pwWjJsdUxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTloZUdsdmN5OXNhV0l2YUdWc2NHVnljeTl1YjNKdFlXeHBlbVZJWldGa1pYSk9ZVzFsTG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWhlR2x2Y3k5c2FXSXZhR1ZzY0dWeWN5OXdZWEp6WlVobFlXUmxjbk11YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRjRhVzl6TDJ4cFlpOW9aV3h3WlhKekwzTndjbVZoWkM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZZWGhwYjNNdmJHbGlMM1YwYVd4ekxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTlqWVd4c0xXSnBibVF2WTJGc2JFSnZkVzVrTG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWpZV3hzTFdKcGJtUXZhVzVrWlhndWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMk52Ym5OdmJHVXRZbkp2ZDNObGNtbG1lUzlwYm1SbGVDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WkdWbWFXNWxMWEJ5YjNCbGNuUnBaWE12YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJWekxXRmljM1J5WVdOMEwyaGxiSEJsY25NdloyVjBUM2R1VUhKdmNHVnlkSGxFWlhOamNtbHdkRzl5TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWxjell0YjJKcVpXTjBMV0Z6YzJsbmJpOXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZaWFpsYm5SekwyVjJaVzUwY3k1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZabTl5WldGamFDOXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZabTl5YlMxa1lYUmhMMnhwWWk5aWNtOTNjMlZ5TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OW1kVzVqZEdsdmJpMWlhVzVrTDJsdGNHeGxiV1Z1ZEdGMGFXOXVMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5bWRXNWpkR2x2YmkxaWFXNWtMMmx1WkdWNExtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTluWlhRdGFXNTBjbWx1YzJsakwybHVaR1Y0TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OW9ZWE10YzNsdFltOXNjeTlwYm1SbGVDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12YUdGekxYTjViV0p2YkhNdmMyaGhiWE11YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyaGhjeTl6Y21NdmFXNWtaWGd1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwybHVhR1Z5YVhSekwybHVhR1Z5YVhSelgySnliM2R6WlhJdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMmx6TFdGeVozVnRaVzUwY3k5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdmFYTXRaMlZ1WlhKaGRHOXlMV1oxYm1OMGFXOXVMMmx1WkdWNExtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwY3kxdVlXNHZhVzF3YkdWdFpXNTBZWFJwYjI0dWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMmx6TFc1aGJpOXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZhWE10Ym1GdUwzQnZiSGxtYVd4c0xtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTlwY3kxdVlXNHZjMmhwYlM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZhWE10ZEhsd1pXUXRZWEp5WVhrdmFXNWtaWGd1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyOWlhbVZqZEMxcGN5OXBiWEJzWlcxbGJuUmhkR2x2Ymk1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZiMkpxWldOMExXbHpMMmx1WkdWNExtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTl2WW1wbFkzUXRhWE12Y0c5c2VXWnBiR3d1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyOWlhbVZqZEMxcGN5OXphR2x0TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OXZZbXBsWTNRdGEyVjVjeTlwYlhCc1pXMWxiblJoZEdsdmJpNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12YjJKcVpXTjBMV3RsZVhNdmFXNWtaWGd1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyOWlhbVZqZEMxclpYbHpMMmx6UVhKbmRXMWxiblJ6TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OXdjbTlqWlhOekwySnliM2R6WlhJdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMM0YxWlhKNWMzUnlhVzVuTDJSbFkyOWtaUzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdmNYVmxjbmx6ZEhKcGJtY3ZaVzVqYjJSbExtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTl4ZFdWeWVYTjBjbWx1Wnk5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl6Y21NdllXeGlkVzB2WjJWMFFXeGlkVzB1ZEhNaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2YzNKakwyRnNZblZ0TDJsdVpHVjRMblJ6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMM055WXk5amJHbGxiblF1ZEhNaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2YzNKakwyTnZiVzF2Ymk5bGJtUndiMmx1ZEhNdWRITWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmMzSmpMMk52YlcxdmJpOTBlWEJsY3k1MGN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5emNtTXZZMjl0Ylc5dUwzVjBhV3h6TG5Seklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDNOeVl5OW5ZV3hzWlhKNUwyZGxkRWRoYkd4bGNua3VkSE1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZjM0pqTDJkaGJHeGxjbmt2WjJWMFUzVmljbVZrWkdsMFIyRnNiR1Z5ZVM1MGN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5emNtTXZaMkZzYkdWeWVTOXBibVJsZUM1MGN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5emNtTXZaMkZzYkdWeWVTOXpaV0Z5WTJoSFlXeHNaWEo1TG5Seklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDNOeVl5OW5aWFJCZFhSb2IzSnBlbUYwYVc5dVNHVmhaR1Z5TG5Seklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDNOeVl5OXBiV0ZuWlM5a1pXeGxkR1ZKYldGblpTNTBjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXpjbU12YVcxaFoyVXZabUYyYjNKcGRHVkpiV0ZuWlM1MGN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5emNtTXZhVzFoWjJVdloyVjBTVzFoWjJVdWRITWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmMzSmpMMmx0WVdkbEwybHVaR1Y0TG5Seklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDNOeVl5OXBiV0ZuWlM5MWNHUmhkR1ZKYldGblpTNTBjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXpjbU12YVcxaFoyVXZkWEJzYjJGa0xuUnpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTkwYzJ4cFlpOTBjMnhwWWk1bGN6WXVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDNWeWJDOXViMlJsWDIxdlpIVnNaWE12Y0hWdWVXTnZaR1V2Y0hWdWVXTnZaR1V1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwzVnliQzkxY213dWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMM1Z5YkM5MWRHbHNMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5MWRHbHNMM04xY0hCdmNuUXZhWE5DZFdabVpYSkNjbTkzYzJWeUxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTkxZEdsc0wzTjFjSEJ2Y25RdmRIbHdaWE11YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwzVjBhV3d2ZFhScGJDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12ZDJocFkyZ3RkSGx3WldRdFlYSnlZWGt2YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEwzZGxZbkJoWTJzdlltOXZkSE4wY21Gd0lpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzkzWldKd1lXTnJMM0oxYm5ScGJXVXZaR1ZtYVc1bElIQnliM0JsY25SNUlHZGxkSFJsY25NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMM2RsWW5CaFkyc3ZjblZ1ZEdsdFpTOW5iRzlpWVd3aUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMM2RsWW5CaFkyc3ZjblZ1ZEdsdFpTOW9ZWE5QZDI1UWNtOXdaWEowZVNCemFHOXlkR2hoYm1RaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMM2RsWW5CaFkyc3ZjblZ1ZEdsdFpTOXRZV3RsSUc1aGJXVnpjR0ZqWlNCdlltcGxZM1FpTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEwzZGxZbkJoWTJzdmNuVnVkR2x0WlM5dWIyUmxJRzF2WkhWc1pTQmtaV052Y21GMGIzSWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmMzSmpMMmx1WkdWNExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenRCUVVORUxFODdPenM3T3pzN096czdRVU5pUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExFMUJRVTA3UVVGRGFrSXNWMEZCVnl4VFFVRlRPMEZCUTNCQ0xGZEJRVmNzVVVGQlVUdEJRVU51UWl4WlFVRlpPMEZCUTFvN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEdkQ1FVRm5RanRCUVVOcVF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3T3pzN096czdPenM3T3pzN08wRkRlRUpCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTmhPenRCUVVWaUxIVkNRVUYxUWl3eVJVRkJNa1VzYTBOQlFXdERMRzFDUVVGdFFpeEhRVUZITEVWQlFVVXNUMEZCVHl4clEwRkJhME1zT0VoQlFUaElMRWRCUVVjc1JVRkJSU3h4UWtGQmNVSTdPMEZCUlRkV0xHbEVRVUZwUkN3d1EwRkJNRU1zTUVSQlFUQkVMRVZCUVVVN08wRkJSWFpLTEdWQlFXVXNiVUpCUVU4c1EwRkJReXg1UlVGQmJVSTdRVUZETVVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMSEZDUVVGeFFpeHRRa0ZCVHl4RFFVRkRMSGxIUVVGdFF6czdRVUZGYUVVc1owSkJRV2RDTEcxQ1FVRlBMRU5CUVVNc01FTkJRVTg3UVVGREwwSTdPMEZCUlVFc2NVSkJRWEZDTEhGRlFVRnpRanRCUVVNelF6dEJRVU5CT3p0QlFVVkJMRzFFUVVGdFJDeG5SMEZCYlVNN1FVRkRkRVlzZFVOQlFYVkRMRzFDUVVGUExFTkJRVU1zYjBSQlFWYzdRVUZETVVRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc2JVSkJRVzFDTEcxQ1FVRlBMRU5CUVVNc05rWkJRVFpDT3p0QlFVVjRSRHRCUVVOQk8wRkJRMEVzUTBGQlF6dEJRVU5FTzBGQlEwRTdPenRCUVVkQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQkxHMUNRVUZ0UWp0QlFVTnVRanRCUVVOQk96dEJRVVZCTzBGQlEwRXNLMEpCUVN0Q08wRkJReTlDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTEdsQ1FVRnBRaXhQUVVGUExHVkJRV1VzVDBGQlR5eGxRVUZsTEU5QlFVOHNWMEZCVnl4UFFVRlBPMEZCUTNSR08wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRU3h0UWtGQmJVSTdPMEZCUlc1Q096dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEVzUTBGQlF6dEJRVU5FT3pzN1FVRkhRVHRCUVVOQkxIRkZRVUZ4UlN4aFFVRmhPMEZCUTJ4R08wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRU3hsUVVGbE96dEJRVVZtT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3T3p0QlFVZElPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFc1JVRkJSVHRCUVVOR096czdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE96czdRVUZIU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJMRVZCUVVVN096dEJRVWRHTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRXNSVUZCUlRzN08wRkJSMFk3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CT3pzN1FVRkhRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNlVVJCUVhsRU96dEJRVVY2UkR0QlFVTkJPMEZCUTBFc1MwRkJTenM3TzBGQlIwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPenRCUVVWQkxIRkRRVUZ4UXp0QlFVTnlRenM3UVVGRlFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTEVkQlFVYzdPenRCUVVkSU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzZVVKQlFYbENPMEZCUTNwQ096dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEd0RFFVRnJRenM3UVVGRmJFTTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJMRXRCUVVzN1FVRkRUQ3hIUVVGSE8wRkJRMGc3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN3MFJrRkJORVlzWlVGQlpUdEJRVU16Unp0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN3MFJrRkJORVlzWlVGQlpUdEJRVU16Unp0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdPMEZCUlVFN1FVRkRRU3cwUmtGQk5FWXNaVUZCWlR0QlFVTXpSenRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3cwUmtGQk5FWXNaVUZCWlR0QlFVTXpSenRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTeXhGUVVGRk96dEJRVVZRT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHRRa0ZCYlVJN08wRkJSVzVDT3p0QlFVVkJMSEZDUVVGeFFpeHBRa0ZCYVVJN1FVRkRkRU03UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUlVGQlJUczdPMEZCUjBZN1FVRkRRU3gzUlVGQmQwVXNaVUZCWlR0QlFVTjJSanRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVOQlFVTTdRVUZEUkN4eFF6czdPenM3T3pzN096czdPMEZEZEc1Q1FUdEJRVU5CTzBGQlEyRTdPMEZCUldJc1owTkJRV2RETEdkQ1FVRm5RaXh6UWtGQmMwSXNUMEZCVHl4MVJFRkJkVVFzYlVOQlFXMURMREJFUVVFd1JDeHpSa0ZCYzBZc1owVkJRV2RGTEVWQlFVVXNSMEZCUnl4RlFVRkZMR2xEUVVGcFF5d3lRMEZCTWtNc1JVRkJSU3hGUVVGRkxFVkJRVVVzWlVGQlpUczdRVUZGTDJRc01rTkJRVEpETEd0Q1FVRnJRaXhyUTBGQmEwTXNjVVZCUVhGRkxFVkJRVVVzUlVGQlJTeFBRVUZQTEd0Q1FVRnJRaXhGUVVGRkxGbEJRVms3TzBGQlJTOU5MR2xFUVVGcFJDd3dRMEZCTUVNc01FUkJRVEJFTEVWQlFVVTdPMEZCUlhaS0xESkRRVUV5UXl4blFrRkJaMElzYTBKQlFXdENMRTlCUVU4c01rSkJRVEpDTEhkRVFVRjNSQ3huUTBGQlowTXNkVVJCUVhWRUxESkVRVUV5UkN4RlFVRkZPenRCUVVVelZDdzJSRUZCTmtRc2MwVkJRWE5GTERoRVFVRTRSQ3h2UWtGQmIwSTdPMEZCUlhKT0xHbEVRVUZwUkN3d1JVRkJNRVVzWVVGQllTeEZRVUZGTEhGRFFVRnhRenM3UVVGRkwwc3NkVU5CUVhWRExIVkNRVUYxUWl4MVJrRkJkVVlzUlVGQlJTeGhRVUZoT3p0QlFVVndTeXd3UTBGQk1FTXNLMFJCUVN0RUxESkZRVUV5UlN4RlFVRkZMSGxGUVVGNVJTeGxRVUZsTEhORVFVRnpSQ3hGUVVGRkxFVkJRVVVzZFVSQlFYVkVPenRCUVVVdldDeHJRMEZCYTBNc1owVkJRV2RGTEhORVFVRnpSQ3dyUkVGQkswUXNiVU5CUVcxRExESkZRVUV5UlN4RlFVRkZMSEZEUVVGeFF5eHBSRUZCYVVRc05FSkJRVFJDTEVWQlFVVXNjVUpCUVhGQ0xIZEZRVUYzUlN4RlFVRkZMSEZFUVVGeFJDeGxRVUZsTEhkRlFVRjNSU3hGUVVGRkxFVkJRVVVzZDBOQlFYZERMRWRCUVVjc1owTkJRV2RET3p0QlFVVnlka0lzY1VOQlFYRkRMSGRGUVVGM1JTd3dRMEZCTUVNc09FTkJRVGhETEUxQlFVMHNkMFZCUVhkRkxFZEJRVWNzWVVGQllTeEZRVUZGTEZsQlFWa3NZMEZCWXl4RlFVRkZPenRCUVVWcVZTd3dRMEZCTUVNc2EwTkJRV3RETEdkRFFVRm5ReXhGUVVGRkxFOUJRVThzZDBSQlFYZEVMR2RDUVVGblFpeDFRa0ZCZFVJc2EwUkJRV3RFTEd0RFFVRnJReXgxUkVGQmRVUXNhVUpCUVdsQ0xFZEJRVWNzUlVGQlJTd3dRMEZCTUVNN08wRkJSUzlhTEdkRFFVRm5ReXh0UlVGQmJVVTdPMEZCUlc1SExHZERRVUZuUXl3MFJVRkJORVVzYVVKQlFXbENMRlZCUVZVc1IwRkJSeXc0UWtGQk9FSTdPMEZCUlhoTExEWkNRVUUyUWl4blIwRkJaMGNzWjBSQlFXZEVMRWRCUVVjc01rSkJRVEpDT3p0QlFVVXpUU3gxUWtGQmRVSXNNa1ZCUVRKRkxHdERRVUZyUXl4dFFrRkJiVUlzUjBGQlJ5eEZRVUZGTEU5QlFVOHNhME5CUVd0RExEaElRVUU0U0N4SFFVRkhMRVZCUVVVc2NVSkJRWEZDT3p0QlFVVTNWaXhsUVVGbExHMUNRVUZQTEVOQlFVTXNNRU5CUVU4N1FVRkRPVUk3TzBGQlJVRXNaMEpCUVdkQ0xHMUNRVUZQTEVOQlFVTXNhVVZCUVZjN1FVRkRia01zWjBWQlFXZEZPenM3UVVGSGFFVTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTeERRVUZET3pzN1FVRkhSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRVZCUVVVN1FVRkRSanM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHhRa0ZCY1VJN1FVRkRja0k3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHM3TzBGQlIwRTdRVUZEUVN4elJVRkJjMFU3UVVGRGRFVTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQkxITkNRVUZ6UWl4UFFVRlBMRmRCUVZjc1QwRkJUeXhuUWtGQlowSXNUMEZCVHpzN1FVRkZkRVU3UVVGRFFUdEJRVU5CTzBGQlEwRXNVMEZCVXpzN08wRkJSMVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEczdPMEZCUjBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzYjBWQlFXOUZPMEZCUTNCRkxHMURRVUZ0UXl4alFVRmpMRWRCUVVjc1kwRkJZenM3UVVGRmJFVTdRVUZEUVR0QlFVTkJMRzFFUVVGdFJEdEJRVU51UkRzN08wRkJSMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVN4aFFVRmhMR05CUVdNN1FVRkRNMEk3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNUMEZCVHpzN08wRkJSMUFzYTBKQlFXdENPenRCUVVWc1FqdEJRVU5CTEhGQ1FVRnhRanRCUVVOeVFpeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFBRVUZQT3pzN1FVRkhVQ3hyUWtGQmEwSTdPMEZCUld4Q08wRkJRMEVzY1VKQlFYRkNPMEZCUTNKQ0xFdEJRVXM3UVVGRFREdEJRVU5CTEhORFFVRnpRenRCUVVOMFF6dEJRVU5CT3p0QlFVVkJMRzFKUVVGdFNUdEJRVU51U1R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTzBGQlExZzdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFRRVUZUT3pzN1FVRkhWQ3h2UWtGQmIwSTdRVUZEY0VJN08wRkJSVUU3UVVGRFFUdEJRVU5CTERCQ1FVRXdRanRCUVVNeFFpeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTzBGQlEyNUNPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPenM3UVVGSFREdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3c1ZVRkJWU3hQUVVGUExGZEJRVmNzVDBGQlR6dEJRVU51UXp0QlFVTkJPMEZCUTBFc1dVRkJXU3hQUVVGUExGZEJRVmNzVDBGQlR5eDVRa0ZCZVVJc1QwRkJUenRCUVVOeVJUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRk5CUVZNN1FVRkRWRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNUMEZCVHp0QlFVTlFPMEZCUTBFN096dEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVUkJRVzFFT3p0QlFVVnVSRHRCUVVOQk8wRkJRMEVzVTBGQlV6dEJRVU5VT3pzN1FVRkhRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRk5CUVZNN096dEJRVWRVTzBGQlEwRTdRVUZEUVN4VFFVRlRPMEZCUTFRN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1UwRkJVenRCUVVOVU96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRmRCUVZjN1FVRkRXRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3T3p0QlFVZE1MR2RDUVVGblFqczdRVUZGYUVJN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc01rTkJRVEpETzBGQlF6TkRPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUE3UVVGRFFTeEhRVUZIT3p0QlFVVklPMEZCUTBFc1EwRkJRenM3UVVGRlJDeG5RenM3T3pzN096czdPenM3UVVOd1prRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUczdRVUZGUVR0QlFVTmhPMEZCUTJJN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRXNkVUpCUVhWQ0xESkZRVUV5UlN4clEwRkJhME1zYlVKQlFXMUNMRWRCUVVjc1JVRkJSU3hQUVVGUExHdERRVUZyUXl3NFNFRkJPRWdzUjBGQlJ5eEZRVUZGTEhGQ1FVRnhRanM3UVVGRk4xWXNhVVJCUVdsRUxEQkRRVUV3UXl3d1JFRkJNRVFzUlVGQlJUczdRVUZGZGtvc2FVUkJRV2xFTERCRlFVRXdSU3hoUVVGaExFVkJRVVVzY1VOQlFYRkRPenRCUVVVdlN5eDFRMEZCZFVNc2RVSkJRWFZDTEhWR1FVRjFSaXhGUVVGRkxHRkJRV0U3TzBGQlJYQkxMRFpDUVVFMlFpeG5SMEZCWjBjc1owUkJRV2RFTEVkQlFVY3NNa0pCUVRKQ096dEJRVVV6VFN3d1EwRkJNRU1zSzBSQlFTdEVMREpGUVVFeVJTeEZRVUZGTEhsRlFVRjVSU3hsUVVGbExITkVRVUZ6UkN4RlFVRkZMRVZCUVVVc2RVUkJRWFZFT3p0QlFVVXZXQ3huUTBGQlowTXNORVZCUVRSRkxHbENRVUZwUWl4VlFVRlZMRWRCUVVjc09FSkJRVGhDT3p0QlFVVjRTeXhsUVVGbE96dEJRVVZtTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CTEVOQlFVTTdPenRCUVVkRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPenRCUVVWTU8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRXNRMEZCUXpzN08wRkJSMFE3UVVGRFFUdEJRVU5CTEVOQlFVTTdPenRCUVVkRU8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc1EwRkJRenM3TzBGQlIwUTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEhGRFFVRnhReXh0UWtGQlR5eERRVUZETEhkRVFVRlhPMEZCUTNoRUxEaEVRVUU0UkRzN1FVRkZPVVE3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVN4SFFVRkhPenM3UVVGSFNEdEJRVU5CTzBGQlEwRXNRMEZCUXp0QlFVTkVPMEZCUTBFN1FVRkRRU3hwUTBGQmFVTXNiVUpCUVU4c1EwRkJReXd3UTBGQlR6dEJRVU5vUkRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4RFFVRkRPMEZCUTBRN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN08wRkJSVUU3UVVGRFFTeERRVUZETzBGQlEwUTdRVUZEUVN4eFJVRkJjVVVzWVVGQllUdEJRVU5zUmp0QlFVTkJPenRCUVVWQkxIRkRRVUZ4UXl4dFFrRkJUeXhEUVVGRExIZEVRVUZYTzBGQlEzaEVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZIT3p0QlFVVklPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc1EwRkJRenRCUVVORUxHOUNRVUZ2UWl4VE96czdPenM3T3pzN096dEJRMnhOY0VJN1FVRkRRVHRCUVVOaE96dEJRVVZpTEdsRFFVRnBReXh2UmtGQmIwWTdPMEZCUlhKSUxEWkNRVUUyUWl3MlJVRkJOa1U3TzBGQlJURkhMSGREUVVGM1F5eGxRVUZsTEdWQlFXVXNaMEpCUVdkQ0xHOUNRVUZ2UWl4TlFVRk5MREJEUVVFd1F5d3JRa0ZCSzBJc1lVRkJZU3h4UWtGQmNVSXNiVU5CUVcxRExFVkJRVVVzUlVGQlJTeGpRVUZqTEZkQlFWY3NWVUZCVlN4RlFVRkZMRlZCUVZVc1RVRkJUU3hwUkVGQmFVUXNSVUZCUlN4VlFVRlZMR3RDUVVGclFpeEZRVUZGTEVWQlFVVXNZVUZCWVRzN1FVRkZkbG9zSzBKQlFTdENMRzlEUVVGdlF6czdRVUZGYmtVc2RVSkJRWFZDTERKRlFVRXlSU3hyUTBGQmEwTXNiVUpCUVcxQ0xFZEJRVWNzUlVGQlJTeFBRVUZQTEd0RFFVRnJReXc0U0VGQk9FZ3NSMEZCUnl4RlFVRkZMSEZDUVVGeFFqczdRVUZGTjFZN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96dEJRVVZCTEhWRFFVRjFReXh0UWtGQlR5eERRVUZETEc5RVFVRlhPMEZCUXpGRU8wRkJRMEU3UVVGRFFUdEJRVU5CTEdkRVFVRm5SQ3h0UWtGQlR5eERRVUZETERoRFFVRlJPenRCUVVWb1JUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEhGQ1FVRnhRaXh4UlVGQmMwSTdRVUZETTBNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUVzYVVKQlFXbENMR2RDUVVGblFqdEJRVU5xUXp0QlFVTkJPMEZCUTBFc1IwRkJSenM3TzBGQlIwZzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUTBGQlF6dEJRVU5FT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRU3gxUTBGQmRVTXNVMEZCVXp0QlFVTm9SRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHVkJRV1U3TzBGQlJXWTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMSE5DUVVGelFpeDFRa0ZCZFVJN1FVRkROME03UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTEVOQlFVTTdRVUZEUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN1FVRkhRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnpzN08wRkJSMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96czdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVRzN08wRkJSMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hyUTBGQmEwTTdPMEZCUld4RE8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdPenRCUVVkSU96dEJRVVZCTEZGQlFWRXNhMEpCUVd0Q08wRkJRekZDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRU3hwUWtGQmFVSXNkMEpCUVhkQ08wRkJRM3BET3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4VFFVRlRPMEZCUTFRN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4SFFVRkhPenM3UVVGSFNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRU3hwUWtGQmFVSXNjMEpCUVhOQ08wRkJRM1pET3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRU5CUVVNN1FVRkRSRHRCUVVOQk8wRkJRMEU3T3p0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRXNhVUpCUVdsQ0xHOUNRVUZ2UWp0QlFVTnlReXg1UWtGQmVVSTdRVUZEZWtJN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJMRXRCUVVzN1FVRkRUQ3dyUWtGQkswSTdPMEZCUlM5Q08wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUVzYjBKQlFXOUNMSEZDUVVGeFFqdEJRVU42UXl3MlFrRkJOa0k3UVVGRE4wSTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hsUVVGbExGZEJRVmNzYjBKQlFXOUNMRmRCUVZjN1FVRkRla1E3UVVGRFFUczdRVUZGUVN4cFFrRkJhVUlzYzBKQlFYTkNPMEZCUTNaRE96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzYVVKQlFXbENMSEZDUVVGeFFqdEJRVU4wUXp0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc2FVTkJRV2xETzBGQlEycERPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQkxIRkNRVUZ4UWl4MVFrRkJkVUk3UVVGRE5VTTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnc1ZVRkJWU3hqUVVGak8wRkJRM2hDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1QwRkJUenRCUVVOUU8wRkJRMEVzVDBGQlR6dEJRVU5RTzBGQlEwRTdPMEZCUlVFc1kwRkJZeXhyUWtGQmEwSTdRVUZEYUVNN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHM3TzBGQlIwRXNZVUZCWVN4cFFrRkJhVUk3UVVGRE9VSTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVVN096czdPenM3T3pzN08wRkRMM0ZDWVRzN1FVRkZZaXhoUVVGaExHMUNRVUZQTEVOQlFVTXNNRVJCUVdNN08wRkJSVzVETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3huUWtGQlowSXNjVUpCUVUwN1FVRkRkRUlzUlVGQlJUdEJRVU5HT3pzN096czdPenM3T3p0QlEzQkNRU3cwUmtGQmRVTXNRenM3T3pzN096czdPenM3UVVOQk1VSTdPMEZCUldJc1dVRkJXU3h0UWtGQlR5eERRVUZETEhGRVFVRlpPMEZCUTJoRExHRkJRV0VzYlVKQlFVOHNRMEZCUXl4cFJVRkJhMEk3UVVGRGRrTXNZMEZCWXl4dFFrRkJUeXhEUVVGRExIbEZRVUZ6UWp0QlFVTTFReXhsUVVGbExHMUNRVUZQTEVOQlFVTXNNa1ZCUVhWQ08wRkJRemxETEc5Q1FVRnZRaXh0UWtGQlR5eERRVUZETERaRlFVRjFRanRCUVVOdVJDeHRRa0ZCYlVJc2JVSkJRVThzUTBGQlF5eHRSa0ZCTWtJN1FVRkRkRVFzYzBKQlFYTkNMRzFDUVVGUExFTkJRVU1zZVVaQlFUaENPMEZCUXpWRUxHdENRVUZyUWl4dFFrRkJUeXhEUVVGRExIbEZRVUZ4UWpzN1FVRkZMME03UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3cwUTBGQk5FTTdRVUZETlVNN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPMEZCUTBFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3T3pzN096czdPenM3T3p0QlEyeE1ZVHM3UVVGRllpeFpRVUZaTEcxQ1FVRlBMRU5CUVVNc2EwUkJRVk03UVVGRE4wSXNWMEZCVnl4dFFrRkJUeXhEUVVGRExHZEZRVUZuUWp0QlFVTnVReXhaUVVGWkxHMUNRVUZQTEVOQlFVTXNORVJCUVdNN1FVRkRiRU1zYTBKQlFXdENMRzFDUVVGUExFTkJRVU1zZDBWQlFXOUNPMEZCUXpsRExHVkJRV1VzYlVKQlFVOHNRMEZCUXl4M1JFRkJXVHM3UVVGRmJrTTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEZsQlFWa3NUVUZCVFR0QlFVTnNRanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4bFFVRmxMRzFDUVVGUExFTkJRVU1zYTBWQlFXbENPMEZCUTNoRExHOUNRVUZ2UWl4dFFrRkJUeXhEUVVGRExEUkZRVUZ6UWp0QlFVTnNSQ3hwUWtGQmFVSXNiVUpCUVU4c1EwRkJReXh6UlVGQmJVSTdPMEZCUlRWRE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNaVUZCWlN4dFFrRkJUeXhEUVVGRExHOUZRVUZyUWpzN1FVRkZla003UVVGRFFTeHhRa0ZCY1VJc2JVSkJRVThzUTBGQlF5eG5Sa0ZCZDBJN08wRkJSWEpFT3p0QlFVVkJPMEZCUTBFc2MwSkJRWE5DT3pzN096czdPenM3T3pzN1FVTjJSRlE3TzBGQlJXSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExGRkJRVkU3UVVGRGJrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk96czdPenM3T3pzN096czdRVU5zUW1FN08wRkJSV0lzWVVGQllTeHRRa0ZCVHl4RFFVRkRMREpFUVVGVk96dEJRVVV2UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVTBGQlV6dEJRVU53UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN08wRkJSVWc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN096czdPenM3T3pzN096dEJRM2hFWVRzN1FVRkZZanRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3T3p0QlEwcGhPenRCUVVWaUxGbEJRVmtzYlVKQlFVOHNRMEZCUXl4eFJFRkJXVHRCUVVOb1F5eGxRVUZsTEcxQ1FVRlBMRU5CUVVNc2VVVkJRWEZDTzBGQlF6VkRMSGxDUVVGNVFpeHRRa0ZCVHl4RFFVRkRMR2xHUVVGelFqdEJRVU4yUkN4elFrRkJjMElzYlVKQlFVOHNRMEZCUXl3eVJVRkJiVUk3UVVGRGFrUXNhMEpCUVd0Q0xHMUNRVUZQTEVOQlFVTXNiVVZCUVdVN08wRkJSWHBETzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6czdRVUZGU0R0QlFVTkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdkRVFVRm5SRHRCUVVOb1JEdEJRVU5CTzBGQlEwRXNlVUpCUVhsQ08wRkJRM3BDTEV0QlFVczdRVUZEVER0QlFVTkJMRU5CUVVNN08wRkJSVVE3UVVGRFFUdEJRVU5CTzBGQlEwRXNaMFJCUVdkRU8wRkJRMmhFTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQkxFTkJRVU03TzBGQlJVUTdPenM3T3pzN096czdPenRCUXpsR1lUczdRVUZGWWl4WlFVRlpMRzFDUVVGUExFTkJRVU1zY1VSQlFWazdPMEZCUldoRE8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExGTkJRVk03UVVGRGNFSXNWMEZCVnl4VFFVRlRPMEZCUTNCQ08wRkJRMEVzV1VGQldTeFBRVUZQTzBGQlEyNUNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEU5QlFVODdRVUZEYkVJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NVMEZCVXp0QlFVTndRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN08wRkJSVUU3T3pzN096czdPenM3T3p0QlEyNUVZVHM3UVVGRllpeHZRa0ZCYjBJc2JVSkJRVThzUTBGQlF5eHRSa0ZCTUVJN1FVRkRkRVFzYTBKQlFXdENMRzFDUVVGUExFTkJRVU1zSzBWQlFYZENPenRCUVVWc1JEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhoUVVGaExFOUJRVTg3UVVGRGNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3T3p0QlEyNUNZVHM3UVVGRllpeHRRa0ZCYlVJc2JVSkJRVThzUTBGQlF5eHhSVUZCWjBJN08wRkJSVE5ETzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeFhRVUZYTEU5QlFVODdRVUZEYkVJc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhYUVVGWExFOUJRVTg3UVVGRGJFSXNZVUZCWVN4TlFVRk5PMEZCUTI1Q08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenM3T3pzN096czdPenRCUTJwQ1lUczdRVUZGWWl4WlFVRlpMRzFDUVVGUExFTkJRVU1zY1VSQlFWazdRVUZEYUVNc2IwSkJRVzlDTEcxQ1FVRlBMRU5CUVVNc2RVVkJRV2xDTzBGQlF6ZERMR1ZCUVdVc2JVSkJRVThzUTBGQlF5eDFSVUZCYjBJN1FVRkRNME1zWlVGQlpTeHRRa0ZCVHl4RFFVRkRMSGxFUVVGaE96dEJRVVZ3UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVDBGQlR6dEJRVU5zUWl4aFFVRmhMRkZCUVZFN1FVRkRja0k3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTd3JRa0ZCSzBJN1FVRkRMMElzZFVOQlFYVkRPMEZCUTNaRE8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzUjBGQlJ6dEJRVU5JT3pzN096czdPenM3T3pzN1FVTTVSV0U3TzBGQlJXSTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhOUVVGTk8wRkJRMnBDTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhYUVVGWExFOUJRVTg3UVVGRGJFSXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGZEJRVmNzVDBGQlR6dEJRVU5zUWl4aFFVRmhMRTFCUVUwN1FVRkRia0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVONlEyRTdPMEZCUldJc1dVRkJXU3h0UWtGQlR5eERRVUZETEcxRVFVRlZPenRCUVVVNVFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeFhRVUZYTEU5QlFVODdRVUZEYkVJc1lVRkJZU3hQUVVGUE8wRkJRM0JDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTUxESkNRVUV5UWp0QlFVTXpRaXhMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdPMEZCUlVnN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRU3hIUVVGSE96dEJRVVZJTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEVzUjBGQlJ6czdRVUZGU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenM3UVVGRlREczdRVUZGUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVOMFJtRTdPMEZCUldJc2EwSkJRV3RDTEcxQ1FVRlBMRU5CUVVNc2JVVkJRV1U3TzBGQlJYcERPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVTBGQlV6dEJRVU53UWl4WFFVRlhMRk5CUVZNN1FVRkRjRUlzVjBGQlZ5eFBRVUZQTzBGQlEyeENPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTjRRbUU3TzBGQlJXSXNXVUZCV1N4dFFrRkJUeXhEUVVGRExIRkVRVUZaT3p0QlFVVm9RenRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEdOQlFXTTdRVUZEZWtJc1YwRkJWeXhOUVVGTk8wRkJRMnBDTEZkQlFWY3NaVUZCWlR0QlFVTXhRaXhoUVVGaExFVkJRVVU3UVVGRFpqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CT3pzN096czdPenM3T3pzN08wRkRia0poT3p0QlFVVmlMRmxCUVZrc2JVSkJRVThzUTBGQlF5eHJSRUZCVXp0QlFVTTNRaXd3UWtGQk1FSXNiVUpCUVU4c1EwRkJReXc0UmtGQkswSTdPMEZCUldwRk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1kwRkJZeXh0UWtGQlR5eERRVUZETEdkRlFVRm5RanRCUVVOMFF5eEhRVUZITEdsQ1FVRnBRaXhQUVVGUExHMUVRVUZ0UkN4UFFVRlBPMEZCUTNKR08wRkJRMEVzWTBGQll5eHRRa0ZCVHl4RFFVRkRMR2xGUVVGcFFqdEJRVU4yUXp0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhkRlFVRjNSVHRCUVVONFJUdEJRVU5CTzBGQlEwRTdRVUZEUVN4MVJFRkJkVVE3UVVGRGRrUTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1QwRkJUeXhaUVVGWk8wRkJRMjVDTzBGQlEwRTdRVUZEUVN4SFFVRkhPenRCUVVWSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEVOQlFVTTdPMEZCUlVRN1FVRkRRVHRCUVVOQkxFTkJRVU03TzBGQlJVUTdPenM3T3pzN096czdPenRCUTJwSFlUczdRVUZGWWp0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNhVUpCUVdsQ08wRkJRM0JETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN096dEJRMVpoT3p0QlFVVmlMRmxCUVZrc2JVSkJRVThzUTBGQlF5eHhSRUZCV1RzN1FVRkZhRU03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeFhRVUZYTEU5QlFVODdRVUZEYkVJc1lVRkJZU3hQUVVGUE8wRkJRM0JDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRU3hIUVVGSE8wRkJRMGc3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEU5QlFVODdRVUZEVUR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUFzUzBGQlN6czdRVUZGVER0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTnlSV0U3TzBGQlJXSTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhoUVVGaExFOUJRVTg3UVVGRGNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU5pWVRzN1FVRkZZaXhaUVVGWkxHMUNRVUZQTEVOQlFVTXNjVVJCUVZrN08wRkJSV2hETzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRU3d3UTBGQk1FTTdRVUZETVVNc1UwRkJVenM3UVVGRlZEdEJRVU5CTERSRVFVRTBSQ3gzUWtGQmQwSTdRVUZEY0VZN1FVRkRRU3hUUVVGVE96dEJRVVZVTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenM3UVVGRlREdEJRVU5CTzBGQlEwRTdRVUZEUVN4clEwRkJhME03UVVGRGJFTXNLMEpCUVN0Q0xHRkJRV0VzUlVGQlJUdEJRVU01UXp0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU96czdPenM3T3pzN096czdRVU53UkdFN08wRkJSV0k3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xHRkJRV0VzVVVGQlVUdEJRVU55UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdPenM3T3pzN096czdPMEZEWW1FN08wRkJSV0k3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4RlFVRkZPMEZCUTJJc1lVRkJZU3hSUVVGUk8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVOV1lUczdRVUZGWWl4WlFVRlpMRzFDUVVGUExFTkJRVU1zY1VSQlFWazdPMEZCUldoRE8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMR05CUVdNc1QwRkJUenRCUVVOeVFpeG5Ra0ZCWjBJN1FVRkRhRUk3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGpRVUZqTEU5QlFVODdRVUZEY2tJc1owSkJRV2RDTEZGQlFWRTdRVUZEZUVJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3pzN1FVRkZURHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PenM3T3pzN096czdPenM3UVVOdVJXRTdPMEZCUldJc1dVRkJXU3h0UWtGQlR5eERRVUZETEcxRVFVRlZPenRCUVVVNVFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3T3pzN096czdPenM3T3p0QlExaGhPenRCUVVWaUxGbEJRVmtzYlVKQlFVOHNRMEZCUXl4eFJFRkJXVHM3UVVGRmFFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeGhRVUZoTEU5QlFVODdRVUZEY0VJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMR2xDUVVGcFFpeGxRVUZsT3p0QlFVVm9RenRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CT3pzN096czdPenM3T3pzN1FVTndSR0U3TzBGQlJXSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxDdENRVUVyUWp0QlFVTXZRanRCUVVOQk8wRkJRMEVzVjBGQlZ5eFRRVUZUTzBGQlEzQkNMR0ZCUVdFN1FVRkRZanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenM3T3pzN096czdPenRCUXpGQ1lUczdRVUZGWWl4WFFVRlhMRzFDUVVGUExFTkJRVU1zWjBWQlFXZENPenRCUVVWdVF6czdRVUZGUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WFFVRlhMRTlCUVU4N1FVRkRiRUlzWVVGQllTeFJRVUZSTzBGQlEzSkNPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeGhRVUZoTEZGQlFWRTdRVUZEY2tJN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEdGQlFXRXNVVUZCVVR0QlFVTnlRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVDBGQlR6dEJRVU5zUWl4aFFVRmhMRkZCUVZFN1FVRkRja0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ5eFBRVUZQTzBGQlEyeENMR0ZCUVdFc1VVRkJVVHRCUVVOeVFqdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEU5QlFVODdRVUZEYkVJc1lVRkJZU3hSUVVGUk8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ5eFBRVUZQTzBGQlEyeENMR0ZCUVdFc1VVRkJVVHRCUVVOeVFqdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEU5QlFVODdRVUZEYkVJc1lVRkJZU3hSUVVGUk8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhoUVVGaExGRkJRVkU3UVVGRGNrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGbEJRVmtzVVVGQlVUdEJRVU53UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEU5QlFVODdRVUZEYkVJc1lVRkJZU3hSUVVGUk8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhoUVVGaExGRkJRVkU3UVVGRGNrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xHRkJRV0VzVVVGQlVUdEJRVU55UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WFFVRlhMRTlCUVU4N1FVRkRiRUlzWVVGQllTeFJRVUZSTzBGQlEzSkNPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeGhRVUZoTEZGQlFWRTdRVUZEY2tJN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEdGQlFXRXNVVUZCVVR0QlFVTnlRanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExFOUJRVTg3UVVGRGJFSXNZVUZCWVN4UFFVRlBPMEZCUTNCQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhoUVVGaE8wRkJRM2hDTEZkQlFWY3NVMEZCVXp0QlFVTndRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc2JVTkJRVzFETEU5QlFVODdRVUZETVVNN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNkVUpCUVhWQ0xGTkJRVk1zUjBGQlJ5eFRRVUZUTzBGQlF6VkRMREpDUVVFeVFqdEJRVU16UWp0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEdGQlFXRXNUMEZCVHp0QlFVTndRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3c05FSkJRVFJDTzBGQlF6VkNMRXRCUVVzN1FVRkRURHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdPMEZCUlVFc2RVTkJRWFZETEU5QlFVODdRVUZET1VNN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhYUVVGWExFOUJRVTg3UVVGRGJFSXNXVUZCV1N4UFFVRlBPMEZCUTI1Q08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVDBGQlR6dEJRVU5zUWl4WlFVRlpMRTlCUVU4N1FVRkRia0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVNNVZtRTdPMEZCUldJc2JVSkJRVzFDTEcxQ1FVRlBMRU5CUVVNc05FUkJRV1U3TzBGQlJURkRMR1ZCUVdVc2JVSkJRVThzUTBGQlF5dzJRMEZCU1RzN1FVRkZNMEk3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3T3p0QlEyUmhPenRCUVVWaUxGZEJRVmNzYlVKQlFVOHNRMEZCUXl3MFJFRkJaVHRCUVVOc1F5eHRRa0ZCYlVJc2JVSkJRVThzUTBGQlF5dzBSRUZCWlRzN1FVRkZNVU03UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNiMEpCUVc5Q0xGRkJRVkVzVjBGQlZ6dEJRVU4yUXl4RlFVRkZPMEZCUTBZN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzTWtOQlFUSkRMRzFDUVVGdFFqdEJRVU01UkN4RFFVRkRPMEZCUTBRc1EwRkJReXh2UWtGQmIwSTdRVUZEY2tJN096czdPenM3T3pzN08wRkRPVU5CTzBGQlEwRXNWMEZCVnl4dFFrRkJUeXhEUVVGRExIbERRVUZOTzBGQlEzcENMR0ZCUVdFc2JVSkJRVThzUTBGQlF5eHhSRUZCVVR0QlFVTTNRaXhuUWtGQlowSTdPMEZCUldoQ08wRkJRMEU3UVVGRFFUczdRVUZGUVN4WFFVRlhMSEZDUVVGTkxHOUNRVUZ2UWl4eFFrRkJUVHRCUVVNelF5eGpRVUZqTEhGQ1FVRk5PMEZCUTNCQ0xFTkJRVU03UVVGRFJEdEJRVU5CTEVOQlFVTTdRVUZEUkR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRXNaVUZCWlN4elFrRkJjMEk3UVVGRGNrTTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU4wUm1FN08wRkJSV0lzVjBGQlZ5eHRRa0ZCVHl4RFFVRkRMSGRFUVVGaE8wRkJRMmhET3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWjBOQlFXZERMR2REUVVGblF6dEJRVU5vUlR0QlFVTkJMSE5DUVVGelFqdEJRVU4wUWp0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRkxGbEJRVms3UVVGRFpEdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNDeEZRVUZGTzBGQlEwWTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2RDUVVGblFpeHJRa0ZCYTBJN1FVRkRiRU03UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk96czdPenM3T3pzN096czdRVU42UkdFN08wRkJSV0lzYlVKQlFXMUNMRzFDUVVGUExFTkJRVU1zTkVSQlFXVTdPMEZCUlRGRE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSVUZCUlR0QlFVTkdPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3pzN096czdPenM3T3pzN1FVTmtRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGWVRzN1FVRkZZanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMR2xDUVVGcFFpeHpRa0ZCYzBJN1FVRkRka003UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3h0UkVGQmJVUXNhVUpCUVdsQ08wRkJRM0JGTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN08wRkROME5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUldFN08wRkJSV0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVOQlFVTTdRVUZEUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFTkJRVU03UVVGRFJEdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxFMUJRVTBzVDBGQlR5eEpRVUZKTEU5QlFVOHNUMEZCVHl4UFFVRlBPMEZCUTNSRE96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEcxQ1FVRnRRanM3UVVGRmJrSTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUTBGQlF6czdRVUZGUkRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hwUWtGQmFVSXNjMEpCUVhOQ08wRkJRM1pET3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdWQlFXVTdRVUZEWmp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHTkJRV003UVVGRFpEczdRVUZGUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQkxHMUNRVUZ0UWl4VFFVRlRPMEZCUXpWQ08wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3hsUVVGbE8wRkJRMlk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN08wRkJSVUVzYVVOQlFXbERMRkZCUVZFN1FVRkRla003UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRk5CUVZNN1FVRkRWRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEcxQ1FVRnRRaXhwUWtGQmFVSTdRVUZEY0VNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRU3h6UTBGQmMwTXNVVUZCVVR0QlFVTTVRenRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEU5QlFVODdRVUZEZUVJN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNVVUZCVVN4NVFrRkJlVUk3UVVGRGFrTTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJc1owSkJRV2RDTzBGQlEycERPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzTmtSQlFUWkVMR0ZCUVdFN1FVRkRNVVU3UVVGRFFTdzJSRUZCTmtRc1lVRkJZVHRCUVVNeFJUdEJRVU5CTEVkQlFVYzdRVUZEU0RzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEVzYjBOQlFXOURMR0ZCUVdFN1FVRkRha1E3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRUQ3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTXZaVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeDFRa0ZCZFVJc1QwRkJUenRCUVVNNVFqdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTndRa0U3UVVGRFFUczdPenM3T3pzN096czdPMEZEUkdFN08wRkJSV0k3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzYVVKQlFXbENPMEZCUTNCRE8wRkJRMEU3TzBGQlJVRXNPRVZCUVRoRkxIRkRRVUZ4UXl4RlFVRkZPenRCUVVWeVNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdPenM3T3pzN096czdPMEZEYmtSaE96dEJRVVZpTEhGQ1FVRnhRaXh0UWtGQlR5eERRVUZETEhkRlFVRnJRanM3UVVGRkwwTTdPenM3T3pzN096czdPenRCUTBwaE96dEJRVVZpT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4cFEwRkJhVU1zSzBOQlFTdERPMEZCUTJoR0xFVkJRVVU3UVVGRFJqczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hWUVVGVk8wRkJRMVlzUlVGQlJUdEJRVU5HTEdWQlFXVTdRVUZEWmp0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2IwSkJRVzlDTzBGQlEzQkNPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVazdRVUZEU2p0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRk8wRkJRMFk3TzBGQlJVRXNhVUpCUVdsQ0xHMUNRVUZQTEVOQlFVTXNkMFJCUVdFN08wRkJSWFJETEhORVFVRnpSQ3h2UWtGQmIwSXNSMEZCUnpzN1FVRkZOMFU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMSEZFUVVGeFJEdEJRVU55UkN4RlFVRkZPMEZCUTBZc1owUkJRV2RFTzBGQlEyaEVMRVZCUVVVN1FVRkRSaXh6UkVGQmMwUTdRVUZEZEVRc1JVRkJSVHRCUVVOR08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSVUZCUlR0QlFVTkdPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEZkQlFWY3NiVUpCUVU4c1EwRkJReXcwUkVGQlpUdEJRVU5zUXl4aFFVRmhMRzFDUVVGUExFTkJRVU1zTkVOQlFVczdRVUZETVVJN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRGhDUVVFNFFqdEJRVU01UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlJUdEJRVU5HTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRk8wRkJRMFk3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQkxEaENRVUU0UWl4clFrRkJhMEk3UVVGRGFFUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRU3hKUVVGSk8wRkJRMG83UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTjZWV0U3TzBGQlJXSTdRVUZEUVN4dlFrRkJiMElzYlVKQlFVOHNRMEZCUXl4dlJFRkJVenM3UVVGRmNrTTdRVUZEUVN4M1EwRkJkME1zWTBGQll6dEJRVU4wUkN4dlEwRkJiME1zWTBGQll6dEJRVU5zUkN3MlEwRkJOa01zWTBGQll6dEJRVU16UkN4NVEwRkJlVU1zWTBGQll6czdRVUZGZGtRN1FVRkRRVHM3T3pzN096czdPenM3TzBGRFdtRTdPMEZCUldJN1FVRkRRVHRCUVVOQkxEQkdRVUV3Uml4alFVRmpPMEZCUTNoSExESkRRVUV5UXl4aFFVRmhPenRCUVVWNFJEdEJRVU5CTzBGQlEwRTdRVUZEUVN3clFrRkJLMElzWTBGQll6czdRVUZGTjBNc2FVVkJRV2xGTEdOQlFXTTdRVUZETDBVc2IwVkJRVzlGTEdOQlFXTTdPMEZCUld4R08wRkJRMEVzWjBOQlFXZERMR05CUVdNN1FVRkRPVU03UVVGRFFTeHpRMEZCYzBNc1kwRkJZenM3UVVGRmNFUXNNRVJCUVRCRUxHTkJRV003UVVGRGVFVXNPRVJCUVRoRUxHTkJRV003TzBGQlJUVkZPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNZMEZCWXl4RlFVRkZPMEZCUTI1RExEQkZRVUV3UlN4alFVRmpPenRCUVVWNFJpeDNSMEZCZDBjc1kwRkJZenM3UVVGRmRFZzdRVUZEUVN3MFEwRkJORU1zWTBGQll6czdRVUZGTVVRc05rUkJRVFpFTEdOQlFXTTdPMEZCUlRORk8wRkJRMEU3UVVGRFFTeHpSVUZCYzBVc1kwRkJZenRCUVVOd1JqczdRVUZGUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVONlEyRTdPMEZCUldJc1YwRkJWeXh0UWtGQlR5eERRVUZETERSRVFVRmxPenRCUVVWc1F6czdPenM3T3pzN096czdRVU5LUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CTEVOQlFVTTdRVUZEUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVNeFFtRTdPMEZCUldJN1FVRkRRU3huUWtGQlowSXNiVUpCUVU4c1EwRkJReXhyUlVGQmNVSTdPMEZCUlRkRE96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hEUVVGRE96dEJRVVZFTERCRVFVRXdSRHM3UVVGRk1VUTdPenM3T3pzN096czdPenRCUTJoRFlUczdRVUZGWWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYjBOQlFXOURPMEZCUTNCRE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNkME5CUVhkRE8wRkJRM2hETEVWQlFVVTdRVUZEUmp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN096czdPenM3T3pzN08wRkRMMEpoT3p0QlFVVmlPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdPenM3T3pzN096czdPMEZEVG1FN08wRkJSV0lzWlVGQlpTeHRRa0ZCVHl4RFFVRkRMRzlFUVVGWE8wRkJRMnhETEdGQlFXRXNiVUpCUVU4c1EwRkJReXh2UlVGQmJVSTdPMEZCUlhoRExIRkNRVUZ4UWl4dFFrRkJUeXhEUVVGRExHbEZRVUZyUWp0QlFVTXZReXhyUWtGQmEwSXNiVUpCUVU4c1EwRkJReXh4UkVGQldUdEJRVU4wUXl4WFFVRlhMRzFDUVVGUExFTkJRVU1zTmtOQlFWRTdPMEZCUlROQ096dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUTBGQlF6czdRVUZGUkRzN096czdPenM3T3pzN08wRkRia0poT3p0QlFVVmlMSEZDUVVGeFFpeHRRa0ZCVHl4RFFVRkRMR2xGUVVGclFqczdRVUZGTDBNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTlVZVHM3UVVGRllpeGhRVUZoTEcxQ1FVRlBMRU5CUVVNc2IwVkJRVzFDTzBGQlEzaERMR3RDUVVGclFpeHRRa0ZCVHl4RFFVRkRMSEZFUVVGWk96dEJRVVYwUXpzN1FVRkZRVHRCUVVOQk8wRkJRMEVzYVVKQlFXbENMR3RDUVVGclFqdEJRVU51UXp0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRk8wRkJRMFk3UVVGRFFUczdPenM3T3pzN096czdPMEZEWm1FN08wRkJSV0lzWTBGQll5eHRRa0ZCVHl4RFFVRkRMR2RFUVVGVE8wRkJReTlDTERKQ1FVRXlRaXh0UWtGQlR5eERRVUZETERoRlFVRjNRanRCUVVNelJDeG5Ra0ZCWjBJc2JVSkJRVThzUTBGQlF5eHJSVUZCY1VJN08wRkJSVGRETzBGQlEwRXNhVUpCUVdsQ0xHMUNRVUZQTEVOQlFVTXNkMFJCUVdFN1FVRkRkRU03TzBGQlJVRTdPMEZCUlVFN1FVRkRRU3huUWtGQlowSXNhMEpCUVd0Q08wRkJRMnhETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEcxQ1FVRlBMRU5CUVVNc2IwaEJRVGhETzBGQlEycEZMREpEUVVFeVF6dEJRVU16UXp0QlFVTkJPMEZCUTBFc1owSkJRV2RDTEhGQ1FVRk5PMEZCUTNSQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlJUdEJRVU5HT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVa3NXVUZCV1R0QlFVTm9RanRCUVVOQkxFVkJRVVU3UVVGRFJqdEJRVU5CT3p0QlFVVkJPMEZCUTBFc01rTkJRVEpETEdOQlFXTTdRVUZEZWtRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGhRVUZoTEdOQlFXTTdRVUZETTBJN1FVRkRRVHM3T3pzN096czdPenM3TzBGRE5VUmhPenRCUVVWaU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN096czdRVU5xUW1FN08wRkJSV0lzWVVGQllTeHRRa0ZCVHl4RFFVRkRMRzlGUVVGdFFqdEJRVU40UXl4bFFVRmxMRzFDUVVGUExFTkJRVU1zYjBSQlFWYzdPMEZCUld4RExIRkNRVUZ4UWl4dFFrRkJUeXhEUVVGRExHOUZRVUZyUWp0QlFVTXZReXhyUWtGQmEwSXNiVUpCUVU4c1EwRkJReXgzUkVGQldUdEJRVU4wUXl4WFFVRlhMRzFDUVVGUExFTkJRVU1zWjBSQlFWRTdPMEZCUlROQ096dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenM3UVVGRlJEczdPenM3T3pzN096czdPMEZEYWtKaE96dEJRVVZpTEhGQ1FVRnhRaXh0UWtGQlR5eERRVUZETEc5RlFVRnJRanM3UVVGRkwwTTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVOT1lUczdRVUZGWWl4clFrRkJhMElzYlVKQlFVOHNRMEZCUXl4M1JFRkJXVHRCUVVOMFF5eGhRVUZoTEcxQ1FVRlBMRU5CUVVNc2IwVkJRVzFDT3p0QlFVVjRRenRCUVVOQk8wRkJRMEVzYVVKQlFXbENMR1ZCUVdVN1FVRkRhRU03UVVGRFFUdEJRVU5CTzBGQlEwRXNSVUZCUlR0QlFVTkdPMEZCUTBFN096czdPenM3T3pzN096dEJRMkpoT3p0QlFVVmlPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGpRVUZqTEcxQ1FVRlBMRU5CUVVNc1owVkJRV1VzUlVGQlJUdEJRVU4yUXp0QlFVTkJMREJEUVVFd1F5eHBRa0ZCYVVJN1FVRkRNMFFzZFVSQlFYVkVPMEZCUTNaRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNjME5CUVhORExHTkJRV003UVVGRGNFUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFMUJRVTA3UVVGRFRqdEJRVU5CTzBGQlEwRTdRVUZEUVN4SlFVRkpPMEZCUTBvN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEZRVUZGTzBGQlEwWTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMR3RDUVVGclFpeHRRa0ZCYlVJN1FVRkRja003UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc2EwSkJRV3RDTEcxQ1FVRnRRanRCUVVOeVF6dEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQkxHdENRVUZyUWl4elFrRkJjMEk3UVVGRGVFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTjZTR0U3TzBGQlJXSTdRVUZEUVN4aFFVRmhMRzFDUVVGUExFTkJRVU1zWjBWQlFXVTdPMEZCUlhCRE8wRkJRMEVzTkVOQlFUUkRMRzlDUVVGdlFpeEZRVUZGTEVkQlFVY3NiVUpCUVU4c1EwRkJReXh6UlVGQmEwSTdPMEZCUlM5R096dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTEhkRFFVRjNRenRCUVVONFF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRk8wRkJRMFk3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN096czdPenM3T3pzN096dEJReTlDWVRzN1FVRkZZanM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN096czdPenM3T3pzN1FVTm9Ra0U3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1UwRkJVenRCUVVOVU8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRU3hEUVVGRE8wRkJRMFE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEVzVTBGQlV6dEJRVU5VTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPMEZCU1VFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMSFZDUVVGMVFpeHpRa0ZCYzBJN1FVRkROME03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4eFFrRkJjVUk3UVVGRGNrSTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEhGRFFVRnhRenM3UVVGRmNrTTdRVUZEUVR0QlFVTkJPenRCUVVWQkxESkNRVUV5UWp0QlFVTXpRanRCUVVOQk8wRkJRMEU3UVVGRFFTdzBRa0ZCTkVJc1ZVRkJWVHM3T3pzN096czdPenM3TzBGRGRreDBRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZoT3p0QlFVVmlPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMR2xDUVVGcFFpeFRRVUZUTzBGQlF6RkNPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdPenM3T3pzN096czdPMEZETDBWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJXRTdPMEZCUldJN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4VFFVRlRPMEZCUTFRc1QwRkJUenRCUVVOUU8wRkJRMEU3UVVGRFFTeExRVUZMT3p0QlFVVk1PenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTXZSR0U3TzBGQlJXSXNZMEZCWXl4SFFVRkhMREpHUVVGdFF6dEJRVU53UkN4alFVRmpMRWRCUVVjc0swWkJRWFZET3pzN096czdPenM3T3pzN096czdRVU5HZUVRc1owZEJRWEZFTzBGQlJYSkVMRzlHUVVGclJUdEJRVVV6UkN4TFFVRkxMRlZCUVZVc1VVRkJVU3hEUVVNMVFpeE5RVUZ0UWl4RlFVTnVRaXhUUVVGcFFqdEpRVVZxUWl4TlFVRk5MRWRCUVVjc1IwRkJSeXhIUVVGSExEQkNRVUZqTEVsQlFVa3NVMEZCVXl4RlFVRkZMRU5CUVVNN1NVRkROME1zVDBGQlR5eDFRMEZCSzBJc1EwRkJReXhOUVVGTkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUXl4SFFVRkhMRVZCUVVNc1EwRkJReXhEUVVGblF5eERRVUZETzBGQlEzSkhMRU5CUVVNN1FVRk9SQ3cwUWtGTlF6czdPenM3T3pzN096czdPenM3TzBGRFdFUXNaMGRCUVRKQ096czdPenM3T3pzN096czdPenM3TzBGRFFUTkNMSE5HUVVGelF6dEJRVU4wUXl4M1NFRkJhMFU3UVVGRGJFVXNNa1ZCVDJsQ08wRkJRMnBDTEdsR1FVOXRRanRCUVVOdVFpd3lSVUZCYlVNN1FVRkRia01zSzBaQlFYTkVPMEZCVlhSRUxFMUJRVTBzVTBGQlV5eEhRVUZITEhORVFVRnpSQ3hEUVVGRE8wRkJSWHBGTERKSFFVRm5SanRCUVVWb1JpeE5RVUZoTEZkQlFWa3NVMEZCVVN4eFFrRkJXVHRKUVVrelF5eFpRVUZ4UWl4WFFVRjNRanRSUVVNelF5eExRVUZMTEVWQlFVVXNRMEZCUXp0UlFVUlhMR2RDUVVGWExFZEJRVmdzVjBGQlZ5eERRVUZoTzFGQlJ6TkRMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzWlVGQlN5eERRVUZETEUxQlFVMHNRMEZCUXp0WlFVTXZRaXhQUVVGUExFVkJRVVVzTkVKQlFXZENPMWxCUTNwQ0xFOUJRVThzUlVGQlJUdG5Ra0ZEVUN4WlFVRlpMRVZCUVVVc1UwRkJVenRoUVVONFFqdFpRVU5FTEZsQlFWa3NSVUZCUlN4TlFVRk5PMU5CUTNKQ0xFTkJRVU1zUTBGQlF6dFJRVU5JTEVsQlFVa3NRMEZCUXl4UFFVRlBMRWRCUVVjc1pVRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF6dFpRVU14UWl4UFFVRlBMRVZCUVVVc05FSkJRV2RDTzFsQlEzcENMRTlCUVU4c1JVRkJSVHRuUWtGRFVDeFpRVUZaTEVWQlFVVXNVMEZCVXp0aFFVTjRRanRaUVVORUxGbEJRVmtzUlVGQlJTeE5RVUZOTzFOQlEzSkNMRU5CUVVNc1EwRkJRenRSUVVOSUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRMjVETEV0QlFVc3NSVUZCUlN4TlFVRXdRaXhGUVVGRkxFVkJRVVU3V1VGRGJrTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1IwRkJSeXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTTdXVUZEZEVRc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eGhRVUZoTEVkQlFVY3NUVUZCVFN3clEwRkJjMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTnNSU3hQUVVGUExFMUJRVTBzUTBGQlF6dFJRVU5vUWl4RFFVRkRMRVZCUTBRc1EwRkJReXhEUVVGUkxFVkJRVVVzUlVGQlJTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRMmhETEVOQlFVTTdTVUZEU2l4RFFVRkRPMGxCUlVRc1dVRkJXU3hEUVVGRExFOUJRVEpDTzFGQlEzUkRMRTlCUVU4c1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTndReXhEUVVGRE8wbEJSVVFzVDBGQlR5eERRVUZETEZWQlFUaENMRVZCUVVVN1VVRkRkRU1zVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJReTlDTEVOQlFVTTdTVUZGUkN4WFFVRlhMRU5CUVVNc1UwRkJhVUk3VVVGRE0wSXNUMEZCVHl4dFFrRkJWeXhEUVVGRExFbEJRVWtzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0SlFVTjBReXhEUVVGRE8wbEJSVVFzWVVGQllTeERRVUZETEZOQlFXbENPMUZCUXpkQ0xFOUJRVThzY1VKQlFXRXNRMEZCUXl4SlFVRkpMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU03U1VGRGVFTXNRMEZCUXp0SlFVVkVMRkZCUVZFc1EwRkJReXhUUVVGcFFqdFJRVU40UWl4UFFVRlBMR2RDUVVGUkxFTkJRVU1zU1VGQlNTeEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPMGxCUTI1RExFTkJRVU03U1VGRlJDeFZRVUZWTEVOQlFVTXNUMEZCZFVJN1VVRkRhRU1zVDBGQlR5eHZRa0ZCVlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU51UXl4RFFVRkRPMGxCUlVRc2JVSkJRVzFDTEVOQlEycENMRTlCUVdkRE8xRkJSV2hETEU5QlFVOHNOa0pCUVcxQ0xFTkJRVU1zU1VGQlNTeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUXpWRExFTkJRVU03U1VGRlJDeGhRVUZoTEVOQlExZ3NUMEZCTmtJN1VVRkZOMElzVDBGQlR5eDFRa0ZCWVN4RFFVRkRMRWxCUVVrc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUlVRc1VVRkJVU3hEUVVGRExGTkJRV2xDTzFGQlEzaENMRTlCUVU4c1owSkJRVkVzUTBGQlF5eEpRVUZKTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1NVRkRia01zUTBGQlF6dEpRVVZFTEZkQlFWY3NRMEZEVkN4UFFVRnJSRHRSUVVWc1JDeFBRVUZQTEcxQ1FVRlhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlEzQkRMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRMG9zVDBGQlowUTdVVUZGYUVRc1QwRkJUeXhqUVVGTkxFTkJRVU1zU1VGQlNTeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUXk5Q0xFTkJRVU03UTBGRFJqdEJRV3hHUkN4clEwRnJSa003T3pzN096czdPenM3T3pzN096dEJRMjVJV1N4M1FrRkJaMElzUjBGQlJ5eDFRa0ZCZFVJc1EwRkJRenRCUVVVelF5eHRRa0ZCVnl4SFFVRkhMRWRCUVVjc1EwRkJRenRCUVVWc1Fpd3dRa0ZCYTBJc1IwRkJSeXhyUWtGQmEwSXNRMEZCUXp0QlFVVjRReXh6UWtGQll5eEhRVUZITEVkQlFVY3NiVUpCUVZjc1VVRkJVU3hEUVVGRE8wRkJSWGhETEhOQ1FVRmpMRWRCUVVjc1IwRkJSeXh0UWtGQlZ5eFJRVUZSTEVOQlFVTTdRVUZGZUVNc2RVSkJRV1VzUjBGQlJ5eEhRVUZITEcxQ1FVRlhMRk5CUVZNc1EwRkJRenRCUVVVeFF5eDNRa0ZCWjBJc1IwRkJSeXhIUVVGSExHMUNRVUZYTEZWQlFWVXNRMEZCUXp0QlFVVTFReXhyUTBGQk1FSXNSMEZCUnl4SFFVRkhMRzFDUVVGWExGbEJRVmtzUTBGQlF6dEJRVVY0UkN3clFrRkJkVUlzUjBGQlJ5eEhRVUZITEcxQ1FVRlhMR2xDUVVGcFFpeERRVUZET3pzN096czdPenM3T3pzN096czdRVU5EZGtVc1UwRkJaMElzWVVGQllTeERRVUZETEVkQlFWazdTVUZEZUVNc1QwRkJVU3hIUVVGdFFpeERRVUZETEZkQlFWY3NTMEZCU3l4VFFVRlRMRU5CUVVNN1FVRkRlRVFzUTBGQlF6dEJRVVpFTEhORFFVVkRPMEZCUlVRc1UwRkJaMElzVlVGQlZTeERRVUZETEVkQlFWazdTVUZEY2tNc1QwRkJVU3hIUVVGblFpeERRVUZETEZGQlFWRXNTMEZCU3l4VFFVRlRMRU5CUVVNN1FVRkRiRVFzUTBGQlF6dEJRVVpFTEdkRFFVVkRPMEZCUlVRc1UwRkJaMElzVDBGQlR5eERRVUZETEVkQlFWazdTVUZEYkVNc1QwRkJUeXhEUVVOS0xFZEJRV0VzUTBGQlF5eFJRVUZSTEV0QlFVc3NVMEZCVXp0UlFVTndReXhIUVVGaExFTkJRVU1zVVVGQlVTeExRVUZMTEZOQlFWTTdVVUZEY0VNc1IwRkJZU3hEUVVGRExGRkJRVkVzUzBGQlN5eFRRVUZUTEVOQlEzUkRMRU5CUVVNN1FVRkRTaXhEUVVGRE8wRkJUa1FzTUVKQlRVTTdPenM3T3pzN096czdPenM3T3pzN1FVTTVRa1FzTmtoQlFXbERPMEZCU1dwRExGTkJRV2RDTEZGQlFWRXNRMEZCUXl4UFFVRjVRanRKUVVOb1JDeEpRVUZKTEU5QlFVOHNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkJSVHRSUVVNdlFpeFBRVUZQTEV0QlFVc3NRMEZCUXp0TFFVTmtPMGxCUlVRc1QwRkJUeXhQUVVGUExFOUJRVThzUTBGQlF5eE5RVUZOTEV0QlFVc3NWMEZCVnl4SlFVRkpMRTlCUVU4c1EwRkJReXhKUVVGSkxFdEJRVXNzVVVGQlVTeERRVUZETzBGQlF6VkZMRU5CUVVNN1FVRk9SQ3cwUWtGTlF6dEJRVVZFTEZOQlFXZENMRlZCUVZVc1EwRkJReXhQUVVGNVFqdEpRVU5zUkN4SlFVRkpMRTlCUVU4c1QwRkJUeXhMUVVGTExGRkJRVkVzUlVGQlJUdFJRVU12UWl4UFFVRlBMRWxCUVVrc1EwRkJRenRMUVVOaU8wbEJSVVFzVDBGQlR5eFBRVUZQTEU5QlFVOHNRMEZCUXl4TFFVRkxMRXRCUVVzc1YwRkJWeXhKUVVGSkxFOUJRVThzUTBGQlF5eEpRVUZKTEV0QlFVc3NTMEZCU3l4RFFVRkRPMEZCUTNoRkxFTkJRVU03UVVGT1JDeG5RMEZOUXp0QlFVVkVMRk5CUVdkQ0xGRkJRVkVzUTBGQlF5eFBRVUY1UWp0SlFVTm9SQ3hKUVVGSkxFOUJRVThzVDBGQlR5eExRVUZMTEZGQlFWRXNSVUZCUlR0UlFVTXZRaXhQUVVGUExFdEJRVXNzUTBGQlF6dExRVU5rTzBsQlJVUXNUMEZCVHl4UFFVRlBMRTlCUVU4c1EwRkJReXhOUVVGTkxFdEJRVXNzVjBGQlZ5eERRVUZETzBGQlF5OURMRU5CUVVNN1FVRk9SQ3cwUWtGTlF6dEJRVVZFTEdsRlFVRnBSVHRCUVVOcVJTeFRRVUZuUWl4VFFVRlRMRU5CUVVNc1QwRkJlVUk3U1VGRGFrUXNTVUZCU1N4UFFVRlBMRTlCUVU4c1MwRkJTeXhSUVVGUkxFVkJRVVU3VVVGREwwSXNUMEZCVHl4UFFVRlBMRU5CUVVNN1MwRkRhRUk3U1VGRlJDeEpRVUZKTEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJSVHRSUVVOeVFpeFBRVUZQTEdkQ1FVRXdRaXhEUVVGRE8wdEJRMjVETzFOQlFVMHNTVUZCU1N4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVU3VVVGRE5VSXNUMEZCVHl4blFrRkJNRUlzUTBGQlF6dExRVU51UXp0VFFVRk5PMUZCUTB3c1QwRkJUeXhQUVVGUExFTkJRVU1zUzBGQlpTeERRVUZETzB0QlEyaERPMEZCUTBnc1EwRkJRenRCUVZwRUxEaENRVmxETzBGQlJVUXNVMEZCWjBJc1ZVRkJWU3hEUVVGRExFOUJRWGxDTzBsQlEyeEVMRTFCUVUwc1NVRkJTU3hIUVVGSExFbEJRVWtzYlVKQlFWRXNSVUZCUlN4RFFVRkRPMGxCUlRWQ0xFbEJRVWtzVDBGQlR5eFBRVUZQTEV0QlFVc3NVVUZCVVN4RlFVRkZPMUZCUXk5Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRemxDTEU5QlFVOHNTVUZCU1N4RFFVRkRPMHRCUTJJN1NVRkZSQ3hMUVVGTExFMUJRVTBzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RFFVRkRMRWxCUVVrc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlR0UlFVTnNSQ3hOUVVGTkxEQkNRVUV3UWl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxGRkJRVkVzUTBGQlF6dFJRVU4yUkN4SlFVRkpMREJDUVVFd1FpeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUlVGQlJUdFpRVU5zUkN4SlFVRkpMREJDUVVFd1FpeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJZeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVWQlFVVTdaMEpCUTNKRkxFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8yRkJRek5DTzFOQlEwWTdZVUZCVFR0WlFVTk1MRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMU5CUTNwQ08wdEJRMFk3U1VGRFJDeFBRVUZQTEVsQlFVa3NRMEZCUXp0QlFVTmtMRU5CUVVNN1FVRnVRa1FzWjBOQmJVSkRPMEZCUlVRc1UwRkJaMElzSzBKQlFTdENMRU5CUXpkRExGRkJRWFZDT3p0SlFVVjJRaXhKUVVGSkxFOUJRVThzWlVGQlVTeERRVUZETEVsQlFVa3NNRU5CUVVVc1RVRkJUU3hOUVVGTExGZEJRVmNzU1VGQlNTeFBRVUZQTEdWQlFWRXNRMEZCUXl4SlFVRkpMREJEUVVGRkxFOUJRVThzVFVGQlN5eFhRVUZYTEVWQlFVVTdVVUZEYWtjc1QwRkJUeXhSUVVGUkxFTkJRVU1zU1VGQlNUdExRVU55UWp0SlFVVkVMRTlCUVU4N1VVRkRUQ3hKUVVGSkxFVkJRVVVzVVVGQlVTeERRVUZETEVsQlFVazdVVUZEYmtJc1RVRkJUU3hGUVVGRkxGRkJRVkVzUTBGQlF5eE5RVUZOTzFGQlEzWkNMREpEUVVFeVF6dFJRVU16UXl4UFFVRlBMRVZCUVVVc1NVRkJTVHRMUVVOa08wRkJRMGdzUTBGQlF6dEJRV0pFTERCRlFXRkRPenM3T3pzN096czdPenM3T3pzN1FVTTNSVVFzWjBkQlFYbEZPMEZCUlhwRkxEQkZRVUV3UWp0QlFVTXhRaXh2UmtGQmEwVTdRVUVyUW14RkxFMUJRVTBzWTBGQll5eEhRVUZ0UWp0SlFVTnlReXhQUVVGUExFVkJRVVVzUzBGQlN6dEpRVU5rTEVsQlFVa3NSVUZCUlN4UFFVRlBPME5CUTJRc1EwRkJRenRCUVVWR0xGTkJRV2RDTEcxQ1FVRnRRaXhEUVVGRExFOUJRWFZDTzBsQlEzcEVMRTFCUVUwc1lVRkJZU3hIUVVGSExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNSVUZCUlN4RlFVRkZMR05CUVdNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVVZxUlN4SlFVRkpMRWRCUVVjc1IwRkJSeXhIUVVGSExHRkJRV0VzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0SlFVVnlReXhKUVVGSkxHRkJRV0VzUTBGQlF5eEpRVUZKTEVWQlFVVTdVVUZEZEVJc1IwRkJSeXhKUVVGSkxFbEJRVWtzWVVGQllTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRPMHRCUTJwRE8wbEJSVVFzU1VGQlNTeGhRVUZoTEVOQlFVTXNUMEZCVHl4TFFVRkxMRXRCUVVzc1NVRkJTU3hoUVVGaExFTkJRVU1zVFVGQlRTeEZRVUZGTzFGQlF6TkVMRWRCUVVjc1NVRkJTU3hKUVVGSkxHRkJRV0VzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0TFFVTnVRenRKUVVWRUxFbEJRVWtzWVVGQllTeERRVUZETEVsQlFVa3NSVUZCUlR0UlFVTjBRaXhIUVVGSExFbEJRVWtzU1VGQlNTeGhRVUZoTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1MwRkRha003U1VGRlJDeE5RVUZOTEVkQlFVY3NSMEZCUnl4SlFVRkpMRk5CUVVjc1EwRkJReXhIUVVGSExEUkNRVUZuUWl4SlFVRkpMRFJDUVVGblFpeEpRVUZKTEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkZkRVVzU1VGQlNTeGhRVUZoTEVOQlFVTXNVMEZCVXl4TFFVRkxMRk5CUVZNc1JVRkJSVHRSUVVONlF5eEhRVUZITEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhYUVVGWExFVkJRVVVzWVVGQllTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8wdEJRekZGTzBsQlJVUXNTVUZCU1N4aFFVRmhMRU5CUVVNc1RVRkJUU3hMUVVGTExGTkJRVk1zUlVGQlJUdFJRVU4wUXl4SFFVRkhMRU5CUVVNc1dVRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eFJRVUZSTEVWQlFVVXNZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZETzB0QlEzQkZPMGxCUlVRc1NVRkJTU3hoUVVGaExFTkJRVU1zWTBGQll5eExRVUZMTEZOQlFWTXNSVUZCUlR0UlFVTTVReXhIUVVGSExFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNRMEZEY2tJc1owSkJRV2RDTEVWQlEyaENMR0ZCUVdFc1EwRkJReXhqUVVGakxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlEzaERMRU5CUVVNN1MwRkRTRHRKUVVWRUxFOUJRVThzUjBGQlJ5eERRVUZETzBGQlEySXNRMEZCUXp0QlFXNURSQ3hyUkVGdFEwTTdRVUZGVFN4TFFVRkxMRlZCUVZVc1ZVRkJWU3hEUVVNNVFpeE5RVUZ0UWl4RlFVTnVRaXhWUVVFd1FpeGpRVUZqTzBsQlJYaERMRTFCUVUwc1JVRkJSU3hSUVVGUkxFVkJRVVVzUjBGQlJ5eHRRa0ZCYlVJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU5zUkN3MFJrRkJORVk3U1VGRE5VWXNUVUZCVFN4aFFVRmhMRWRCUVVjc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVVjRReXhQUVVGUExIVkRRVUVyUWl4RFFVRkRMRTFCUVUwc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZGTEVkQlFVY3NSVUZCUlN4aFFVRmhMRVZCUVVVc1EwRkJReXhEUVVGclF5eERRVUZETzBGQlEzaElMRU5CUVVNN1FVRlVSQ3huUTBGVFF6czdPenM3T3pzN096czdPenM3TzBGRGNrWkVMR2RIUVVjMlFqdEJRVVUzUWl3d1JVRkJNRUk3UVVGRE1VSXNiMFpCUVd0Rk8wRkJaV3hGTEZOQlFXZENMRFJDUVVFMFFpeERRVU14UXl4UFFVRm5RenRKUVVWb1F5eEpRVUZKTEVkQlFVY3NSMEZCUnl4SFFVRkhMRTlCUVU4c1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dEpRVVZxUXl4SlFVRkpMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVU3VVVGRGFFSXNSMEZCUnl4SlFVRkpMRWxCUVVrc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzB0QlF6TkNPMGxCUlVRc1NVRkJTU3hQUVVGUExFTkJRVU1zU1VGQlNTeExRVUZMTEV0QlFVc3NTVUZCU1N4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRk8xRkJRelZETEVkQlFVY3NTVUZCU1N4SlFVRkpMRTlCUVU4c1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dExRVU0zUWp0SlFVVkVMRWxCUVVrc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJUdFJRVU5vUWl4SFFVRkhMRWxCUVVrc1NVRkJTU3hQUVVGUExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTTdTMEZETTBJN1NVRkZSQ3hOUVVGTkxFZEJRVWNzUjBGQlJ5eEpRVUZKTEZOQlFVY3NRMEZEYWtJc1IwRkJSeXcwUWtGQlowSXNTVUZCU1N4elEwRkJNRUlzU1VGQlNTeEhRVUZITEVWQlFVVXNRMEZETTBRc1EwRkJRenRKUVVWR0xFOUJRVThzUjBGQlJ5eERRVUZETzBGQlEySXNRMEZCUXp0QlFYUkNSQ3h2UlVGelFrTTdRVUZGVFN4TFFVRkxMRlZCUVZVc2JVSkJRVzFDTEVOQlEzWkRMRTFCUVcxQ0xFVkJRMjVDTEU5QlFXZERPMGxCUldoRExFMUJRVTBzUlVGQlJTeFJRVUZSTEVWQlFVVXNSMEZCUnl3MFFrRkJORUlzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTXpSQ3cwUmtGQk5FWTdTVUZETlVZc1RVRkJUU3hoUVVGaExFZEJRVWNzVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVWNFF5eFBRVUZQTEhWRFFVRXJRaXhEUVVGRExFMUJRVTBzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZMRWRCUVVjc1JVRkJSU3hoUVVGaExFVkJRVVVzUTBGQlF5eERRVUZyUXl4RFFVRkRPMEZCUTNoSUxFTkJRVU03UVVGVVJDeHJSRUZUUXpzN096czdPenM3T3pzN096czdPMEZEZGtSRUxITkhRVUUyUWp0QlFVTTNRaXgzU0VGQmMwTTdRVUZEZEVNc05FZEJRV2RET3pzN096czdPenM3T3pzN096czdRVU5FYUVNc1owZEJRV2RHTzBGQlJXaEdMRzlHUVVGclJUdEJRVU5zUlN3d1JVRkJNRUk3UVVGMVFqRkNMRTFCUVUwc2EwSkJRV3RDTEVkQlFTdERPMGxCUTNKRkxFOUJRVTg3U1VGRFVDeFBRVUZQTzBsQlExQXNWMEZCVnp0SlFVTllMRTlCUVU4N1NVRkRVQ3hSUVVGUk8wbEJRMUlzVjBGQlZ6dERRVU5hTEVOQlFVTTdRVUZMUml4VFFVRm5RaXg1UWtGQmVVSXNRMEZCUXl4UFFVRTJRanRKUVVOeVJTeEpRVUZKTEVkQlFVY3NSMEZCUnl4RlFVRkZMRU5CUVVNN1NVRkZZaXhKUVVGSkxFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlFVVTdVVUZEYUVJc1IwRkJSeXhKUVVGSkxFbEJRVWtzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRPMHRCUXpOQ08wbEJSVVFzU1VGQlNTeFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRXRCUVVzc1NVRkJTU3hQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZGTzFGQlF6VkRMRWRCUVVjc1NVRkJTU3hKUVVGSkxFOUJRVThzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0TFFVTTNRanRKUVVWRUxFbEJRVWtzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlR0UlFVTm9RaXhIUVVGSExFbEJRVWtzU1VGQlNTeFBRVUZQTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1MwRkRNMEk3U1VGRlJDeE5RVUZOTEVkQlFVY3NSMEZCUnl4SlFVRkpMRk5CUVVjc1EwRkJReXhIUVVGSExEUkNRVUZuUWl4SlFVRkpMRzFEUVVGMVFpeEhRVUZITEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkZOVVVzYTBKQlFXdENMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVVTdPMUZCUTI1RExFbEJRVWtzWVVGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl3d1EwRkJSU3hOUVVGTkxFVkJRVVU3V1VGRE1VSXNSMEZCUnl4RFFVRkRMRmxCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVZjc1EwRkJReXhEUVVGRE8xTkJRekZFTzBsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkZTQ3hKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNSVUZCUlR0UlFVTm1MRTFCUVUwc1MwRkJTeXhIUVVGSExFOUJRVThzUTBGQlF5eERRVUZETEVsQlFVa3NUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJRenRSUVVONlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZPMWxCUTFZc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eDFRa0ZCZFVJc1EwRkJReXhEUVVGRE8xTkJRekZETzFGQlJVUXNSMEZCUnl4RFFVRkRMRmxCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMHRCUTNKRE8wbEJSVVFzVDBGQlR5eEhRVUZITEVOQlFVTTdRVUZEWWl4RFFVRkRPMEZCYWtORUxEaEVRV2xEUXp0QlFVVk5MRXRCUVVzc1ZVRkJWU3hoUVVGaExFTkJRMnBETEUxQlFXMUNMRVZCUTI1Q0xFOUJRVFpDTzBsQlJUZENMRTFCUVUwc1JVRkJSU3hSUVVGUkxFVkJRVVVzUjBGQlJ5eDVRa0ZCZVVJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU40UkN3MFJrRkJORVk3U1VGRE5VWXNUVUZCVFN4aFFVRmhMRWRCUVVjc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVVjRReXhQUVVGUExIVkRRVUVyUWl4RFFVRkRMRTFCUVUwc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZGTEVkQlFVY3NSVUZCUlN4aFFVRmhMRVZCUVVVc1EwRkJReXhEUVVGclF5eERRVUZETzBGQlEzaElMRU5CUVVNN1FVRlVSQ3h6UTBGVFF6czdPenM3T3pzN096czdPenM3TzBGRGJrWkVMRzFHUVV0M1FqdEJRVVY0UWl3clJrRkJNRVU3UVVGRmJrVXNTMEZCU3l4VlFVRlZMSE5DUVVGelFpeERRVU14UXl4TlFVRnRRanRKUVVWdVFpeEpRVUZKTEhGQ1FVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eEZRVUZGTzFGQlEzSkRMRTlCUVU4c1ZVRkJWU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEZkQlFWY3NSVUZCUlN4RFFVRkRPMHRCUTI1RU8wbEJSVVFzU1VGQlNTeHJRa0ZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEdWQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExFVkJRVVU3VVVGRGJFVXNUMEZCVHl4aFFVRmhMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdTMEZEYmtRN1NVRkZSQ3hOUVVGTkxFVkJRVVVzVVVGQlVTeEZRVUZGTEZGQlFWRXNSVUZCUlN4UlFVRlJMRVZCUVVVc1IwRkJSeXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETzBsQlJUVkVMRTFCUVUwc1QwRkJUeXhIUVVFMFFqdFJRVU4yUXl4SFFVRkhMRVZCUVVVc09FSkJRV3RDTzFGQlEzWkNMRTlCUVU4c1JVRkJSU3cwUWtGQlowSTdVVUZEZWtJc1RVRkJUU3hGUVVGRk8xbEJRMDRzVTBGQlV5eEZRVUZGTEZGQlFWRTdXVUZEYmtJc1lVRkJZU3hGUVVGRkxFOUJRVTg3VTBGRGRrSTdTMEZEUml4RFFVRkRPMGxCUlVZc1NVRkJTU3hSUVVGUkxFZEJRVWNzVFVGQlRTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJSV3hFTEUxQlFVMHNUMEZCVHl4SFFVRkhMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJRenRSUVVNelJDeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYmtNc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1NVRkZia01zU1VGQlNTeERRVUZETEU5QlFVOHNSVUZCUlR0UlFVTmFMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zTUVOQlFUQkRMRU5CUVVNc1EwRkJRenRMUVVNM1JEdEpRVVZFTEUxQlFVMHNUMEZCVHl4SFFVRkhMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zYTBOQlFXdERMRU5CUVVNc1EwRkJRenRKUVVWc1JTeEpRVUZKTEVOQlFVTXNUMEZCVHl4SlFVRkpMRTlCUVU4c1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFGQlEyeERMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zZFVOQlFYVkRMRU5CUVVNc1EwRkJRenRMUVVNeFJEdEpRVVZFTEUxQlFVMHNZMEZCWXl4SFFVRkhMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVZzUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF6dEpRVU40UWl4UFFVRlBMRU5CUVVNc1NVRkJTU3hIUVVGSE8xRkJRMklzVVVGQlVUdFJRVU5TTEZGQlFWRTdVVUZEVWl4TFFVRkxMRVZCUVVVc1kwRkJZenRMUVVOMFFpeERRVUZETzBsQlJVWXNUMEZCVHl4RFFVRkRMR05CUVdNc1IwRkJSeXhMUVVGTExFTkJRVU03U1VGREwwSXNUMEZCVHl4RFFVRkRMRTlCUVU4c1IwRkJSenRSUVVOb1FpeE5RVUZOTEVWQlFVVXNiVUpCUVcxQ0xHTkJRV01zUlVGQlJUdExRVU0xUXl4RFFVRkRPMGxCUlVZc1VVRkJVU3hIUVVGSExFMUJRVTBzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVNNVF5eE5RVUZOTEZGQlFWRXNSMEZCUnl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF6dEpRVU16UXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRk8xRkJRMklzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl3d1FrRkJNRUlzUTBGQlF5eERRVUZETzB0QlF6ZERPMGxCUlVRc1RVRkJUU3hMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZEZEVJc1NVRkJTVHRSUVVOR0xGTkJRVk1zUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1lVRkRha1FzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNN1lVRkRjRUlzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNN1lVRkRjRUlzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNN1VVRkRka0lzU1VGQlNTeERRVU5RTEVOQlFVTTdTVUZGUml4TlFVRk5MRmRCUVZjc1IwRkJSeXhMUVVGTExFTkJRVU1zV1VGQldTeERRVUZETzBsQlEzSkRMRTFCUVUwc1EwRkJReXhYUVVGMVF5eERRVUZETEZkQlFWY3NSMEZCUnl4WFFVRlhMRU5CUVVNN1NVRkZNMFVzVDBGQlR5eFZRVUZWTEZkQlFWY3NSVUZCUlN4RFFVRkRPMEZCUTJwRExFTkJRVU03UVVGMlJVUXNkMFJCZFVWRE96czdPenM3T3pzN096czdPenM3UVVNdlJVUXNaMGRCUVhGRU8wRkJSWEpFTEc5R1FVRnJSVHRCUVVVelJDeExRVUZMTEZWQlFWVXNWMEZCVnl4RFFVTXZRaXhOUVVGdFFpeEZRVU51UWl4VFFVRnBRanRKUVVWcVFpeE5RVUZOTEVkQlFVY3NSMEZCUnl4SFFVRkhMREJDUVVGakxFbEJRVWtzVTBGQlV5eEZRVUZGTEVOQlFVTTdTVUZETjBNc1QwRkJUeXgxUTBGQkswSXNRMEZCUXl4TlFVRk5MRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlJTeEhRVUZITEVWQlFVVXNUVUZCVFN4RlFVRkZMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVGhDTEVOQlFVTTdRVUZEZGtnc1EwRkJRenRCUVU1RUxHdERRVTFET3pzN096czdPenM3T3pzN096czdRVU5XUkN4blIwRkJjVVE3UVVGRmNrUXNiMFpCUVd0Rk8wRkJSVE5FTEV0QlFVc3NWVUZCVlN4aFFVRmhMRU5CUTJwRExFMUJRVzFDTEVWQlEyNUNMRk5CUVdsQ08wbEJSV3BDTEUxQlFVMHNSMEZCUnl4SFFVRkhMRWRCUVVjc01FSkJRV01zU1VGQlNTeFRRVUZUTEZkQlFWY3NRMEZCUXp0SlFVTjBSQ3hQUVVGUExIVkRRVUVyUWl4RFFVRkRMRTFCUVUwc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZGTEVkQlFVY3NSVUZCUlN4TlFVRk5MRVZCUVVVc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQmEwTXNRMEZCUXp0QlFVTjZTQ3hEUVVGRE8wRkJUa1FzYzBOQlRVTTdPenM3T3pzN096czdPenM3T3p0QlExWkVMR2RIUVVGeFJEdEJRVVZ5UkN4dlJrRkJhMFU3UVVGRk0wUXNTMEZCU3l4VlFVRlZMRkZCUVZFc1EwRkROVUlzVFVGQmJVSXNSVUZEYmtJc1UwRkJhVUk3U1VGRmFrSXNUVUZCVFN4SFFVRkhMRWRCUVVjc1IwRkJSeXd3UWtGQll5eEpRVUZKTEZOQlFWTXNSVUZCUlN4RFFVRkRPMGxCUXpkRExFOUJRVThzZFVOQlFTdENMRU5CUVVNc1RVRkJUU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNc1EwRkJaME03UVVGRGRFY3NRMEZCUXp0QlFVNUVMRFJDUVUxRE96czdPenM3T3pzN096czdPenM3UVVOWVJDeHpSMEZCT0VJN1FVRkRPVUlzTUVkQlFXZERPMEZCUTJoRExHZEhRVUV5UWp0QlFVTXpRaXh6UjBGQk9FSTdRVUZET1VJc05FWkJRWGxDT3pzN096czdPenM3T3pzN096czdRVU5JZWtJc1owZEJRWEZFTzBGQlEzSkVMRzlHUVVFNFJUdEJRVkU1UlN4VFFVRlRMRzlDUVVGdlFpeERRVUZETEVOQlFYRkNPMGxCUTJwRUxFOUJRVThzVDBGQlR5eERRVUZETEVOQlFVTXNTMEZCU3l4TFFVRkxMRkZCUVZFc1NVRkJTU3hQUVVGUExFTkJRVU1zUTBGQlF5eFhRVUZYTEV0QlFVc3NVVUZCVVN4RFFVRkRPMEZCUXpGRkxFTkJRVU03UVVGRlRTeExRVUZMTEZWQlFWVXNWMEZCVnl4RFFVTXZRaXhOUVVGdFFpeEZRVU51UWl4UFFVRnJSRHRKUVVWc1JDeEpRVUZKTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVU3VVVGRE1VSXNUVUZCVFN4UlFVRlJMRWRCUVVjc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFYRkNMRVZCUVVVc1JVRkJSVHRaUVVOeVJDeEpRVUZKTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVTdaMEpCUXpWQ0xFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNORU5CUVRSRExFTkJRVU1zUTBGQlF6dGhRVU12UkR0WlFVVkVMRTFCUVUwc1IwRkJSeXhIUVVGSExFZEJRVWNzTUVKQlFXTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1UwRkJVeXhGUVVGRkxFTkJRVU03V1VGREwwTXNUVUZCVFN4SlFVRkpMRWRCUVVjc2EwSkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXpRaXg1UTBGQmVVTTdXVUZEZWtNc1QwRkJUeXhKUVVGSkxFOUJRVThzUTBGQlF5eExRVUZMTEZkQlFWVXNUMEZCVHp0blFrRkRja01zVDBGQlR5eFBRVUZQTEVOQlFVTXNkVU5CUVN0Q0xFTkJRVU1zVFVGQlRTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMjlDUVVOc1JTeEhRVUZITzI5Q1FVTklMRTFCUVUwc1JVRkJSU3hOUVVGTk8yOUNRVU5rTEVsQlFVa3NSVUZCUlN4SlFVRkpPMjlDUVVOV0xIbENRVUY1UWp0cFFrRkRNVUlzUTBGQlF5eERRVUU0UWl4RFFVRkRPMWxCUTI1RExFTkJRVU1zUTBGQmRVTXNRMEZCUXp0UlFVTTNReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVVZJTEU5QlFVOHNUVUZCVFN4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzB0QlEzQkRPMGxCUlVRc1NVRkJTU3hEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRk8xRkJRMnhETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc05FTkJRVFJETEVOQlFVTXNRMEZCUXp0TFFVTXZSRHRKUVVWRUxFMUJRVTBzUjBGQlJ5eEhRVUZITEVkQlFVY3NNRUpCUVdNc1NVRkJTU3hQUVVGUExFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTTdTVUZEY2tRc1RVRkJUU3hKUVVGSkxFZEJRVWNzYTBKQlFWVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOcVF5eFBRVUZQTEhWRFFVRXJRaXhEUVVGRExFMUJRVTBzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXp0UlFVTXhSQ3hIUVVGSE8xRkJRMGdzVFVGQlRTeEZRVUZGTEUxQlFVMDdVVUZEWkN4SlFVRkpMRVZCUVVVc1NVRkJTVHRSUVVOV0xIbENRVUY1UWp0TFFVTXhRaXhEUVVGRExFTkJRVGhDTzBGQlEyeERMRU5CUVVNN1FVRjBRMFFzYTBOQmMwTkRPenM3T3pzN096czdPenM3T3pzN08wRkRia1JFTEc5R1FVbDVRanRCUVVWNlFpeG5SMEZCYzBRN1FVRkZMME1zUzBGQlN5eFZRVUZWTEUxQlFVMHNRMEZETVVJc1RVRkJiVUlzUlVGRGJrSXNUMEZCWjBRN1NVRkZhRVFzU1VGQlNTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRk8xRkJRekZDTEUxQlFVMHNVVUZCVVN4SFFVRkhMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZ0UWl4RlFVRkZMRVZCUVVVN1dVRkRia1FzVFVGQlRTeEpRVUZKTEVkQlFVY3NhMEpCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVVV6UWl4NVEwRkJlVU03V1VGRGVrTXNUMEZCVHl4SlFVRkpMRTlCUVU4c1EwRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEVWQlFVVTdaMEpCUTI1RExFOUJRVThzUTBGQlF5eDFRMEZCSzBJc1EwRkRia01zVFVGQlRTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMjlDUVVOdVFpeEhRVUZITEVWQlFVVXNNa0pCUVdVN2IwSkJRM0JDTEUxQlFVMHNSVUZCUlN4TlFVRk5PMjlDUVVOa0xFbEJRVWtzUlVGQlJTeEpRVUZKTzI5Q1FVTldMR2RDUVVGblFpeEZRVUZGTEVOQlFVTXNZVUZCWVN4RlFVRkZMRVZCUVVVN2QwSkJRMnhETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hoUVVGaExFVkJRVVVzUTBGQlF5eERRVUZETzNkQ1FVTXZRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFVkJRVVVzUjBGQlJ5eGhRVUZoTEVWQlFVVXNRMEZCUXl4RFFVRkRPMjlDUVVOMFJDeERRVUZETzJsQ1FVTkdMRU5CUVVNc1EwRkRORUlzUTBGQlF5eERRVUZETzFsQlEzUkRMRU5CUVVNc1EwRkJlVU1zUTBGQlF6dFJRVU0zUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOSUxFOUJRVThzVFVGQlRTeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8wdEJRM0JETzBsQlJVUXNUVUZCVFN4SlFVRkpMRWRCUVVjc2EwSkJRVlVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTnFReXhyUTBGQmEwTTdTVUZEYkVNc1RVRkJUU3hQUVVGUExFZEJRVWNzVFVGQlRTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMUZCUTI1RExFZEJRVWNzUlVGQlJTd3lRa0ZCWlR0UlFVTndRaXhOUVVGTkxFVkJRVVVzVFVGQlRUdFJRVU5rTEVsQlFVa3NSVUZCUlN4SlFVRkpPMUZCUTFZc1owSkJRV2RDTEVWQlFVVXNRMEZCUXl4aFFVRmhMRVZCUVVVc1JVRkJSVHRaUVVOc1F5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1lVRkJZU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU12UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExHZENRVUZuUWl4RlFVRkZMRVZCUVVVc1IwRkJSeXhoUVVGaExFVkJRVVVzUTBGQlF5eERRVUZETzFGQlEzUkVMRU5CUVVNN1MwRkRSaXhEUVVGRExFTkJRVU03U1VGRlNDeFBRVUZQTEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUTNCQ0xIVkRRVUVyUWl4RFFVRkRMRTlCUVU4c1EwRkJaME1zUTBGRGVFVXNRMEZCUXp0QlFVTktMRU5CUVVNN1FVRjZRMFFzZDBKQmVVTkRPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUTJ4RVJEdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4VlFVRlZMR2RDUVVGblFpeHpRMEZCYzBNc2FVSkJRV2xDTEVWQlFVVTdRVUZEYmtZc2VVSkJRWGxDTEhWRVFVRjFSRHRCUVVOb1JqdEJRVU5CT3p0QlFVVlBPMEZCUTFBN1FVRkRRU3h0UWtGQmJVSXNjMEpCUVhOQ08wRkJRM3BETzBGQlEwRTdPMEZCUlU4N1FVRkRVRHRCUVVOQkxHZEVRVUZuUkN4UFFVRlBPMEZCUTNaRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN3MFJFRkJORVFzWTBGQll6dEJRVU14UlR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZQTzBGQlExQTdRVUZEUVR0QlFVTkJMRFJEUVVFMFF5eFJRVUZSTzBGQlEzQkVPMEZCUTBFN08wRkJSVTg3UVVGRFVDeHRRMEZCYlVNc2IwTkJRVzlETzBGQlEzWkZPenRCUVVWUE8wRkJRMUE3UVVGRFFUczdRVUZGVHp0QlFVTlFMREpDUVVFeVFpd3JSRUZCSzBRc1owSkJRV2RDTEVWQlFVVXNSVUZCUlR0QlFVTTVSenRCUVVOQkxHMURRVUZ0UXl4TlFVRk5MRFpDUVVFMlFpeEZRVUZGTEZsQlFWa3NWMEZCVnl4RlFVRkZPMEZCUTJwSExHdERRVUZyUXl4TlFVRk5MR2xEUVVGcFF5eEZRVUZGTEZsQlFWa3NWMEZCVnl4RlFVRkZPMEZCUTNCSExDdENRVUVyUWl4eFJrRkJjVVk3UVVGRGNFZzdRVUZEUVN4TFFVRkxPMEZCUTB3N08wRkJSVTg3UVVGRFVDeGhRVUZoTERaQ1FVRTJRaXd3UWtGQk1FSXNZVUZCWVN4RlFVRkZMSEZDUVVGeFFqdEJRVU40Unl4blFrRkJaMElzY1VSQlFYRkVMRzlGUVVGdlJTeGhRVUZoTEVWQlFVVTdRVUZEZUVvc2MwSkJRWE5DTEhOQ1FVRnpRaXh4UWtGQmNVSXNSMEZCUnp0QlFVTndSVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4MVEwRkJkVU03UVVGRGRrTXNhME5CUVd0RExGTkJRVk03UVVGRE0wTXNhME5CUVd0RExGZEJRVmNzVlVGQlZUdEJRVU4yUkN4NVEwRkJlVU1zWTBGQll6dEJRVU4yUkR0QlFVTkJMRFpIUVVFMlJ5eFBRVUZQTEZWQlFWVTdRVUZET1Vnc1owWkJRV2RHTEdsQ1FVRnBRaXhQUVVGUE8wRkJRM2hITEhkRVFVRjNSQ3huUWtGQlowSXNVVUZCVVN4UFFVRlBPMEZCUTNaR0xEaERRVUU0UXl4blFrRkJaMElzWjBKQlFXZENMRTlCUVU4N1FVRkRja1k3UVVGRFFTeHBRMEZCYVVNN1FVRkRha003UVVGRFFUdEJRVU5CTEZOQlFWTXNXVUZCV1N4aFFVRmhMRTlCUVU4c1JVRkJSU3hWUVVGVkxGZEJRVmM3UVVGRGFFVXNiVU5CUVcxRExGTkJRVk03UVVGRE5VTTdRVUZEUVRzN1FVRkZUenRCUVVOUU8wRkJRMEU3UVVGRFFUczdRVUZGVHp0QlFVTlFPMEZCUTBFN08wRkJSVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2IwSkJRVzlDTzBGQlEzQkNPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVKQlFXMUNMRTFCUVUwc1owSkJRV2RDTzBGQlEzcERPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYVVKQlFXbENMSE5DUVVGelFqdEJRVU4yUXp0QlFVTkJPMEZCUTBFN08wRkJSVTg3UVVGRFVDdzBRa0ZCTkVJc2MwSkJRWE5DTzBGQlEyeEVPMEZCUTBFN1FVRkRRVHM3UVVGRlR6dEJRVU5RTEdsRVFVRnBSQ3hSUVVGUk8wRkJRM3BFTEhkRFFVRjNReXhSUVVGUk8wRkJRMmhFTEhkRVFVRjNSQ3hSUVVGUk8wRkJRMmhGTzBGQlEwRTdRVUZEUVRzN1FVRkZUenRCUVVOUU8wRkJRMEU3TzBGQlJVODdRVUZEVUR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEhOR1FVRnpSaXhoUVVGaExFVkJRVVU3UVVGRGRFZ3NjMEpCUVhOQ0xHZERRVUZuUXl4eFEwRkJjVU1zTUVOQlFUQkRMRVZCUVVVc1JVRkJSU3hIUVVGSE8wRkJRelZKTERKQ1FVRXlRaXhOUVVGTkxHVkJRV1VzUlVGQlJTeFpRVUZaTEc5Q1FVRnZRaXhGUVVGRk8wRkJRM0JHTEhOQ1FVRnpRaXh2UjBGQmIwYzdRVUZETVVnc05rSkJRVFpDTEhWQ1FVRjFRanRCUVVOd1JDdzBRa0ZCTkVJc2QwSkJRWGRDTzBGQlEzQkVMREpDUVVFeVFpeDVSRUZCZVVRN1FVRkRjRVk3TzBGQlJVODdRVUZEVUR0QlFVTkJMR2xDUVVGcFFpdzBRMEZCTkVNc1UwRkJVeXhGUVVGRkxIRkVRVUZ4UkN4aFFVRmhMRVZCUVVVN1FVRkROVWtzZVVKQlFYbENMRFpDUVVFMlFpeHZRa0ZCYjBJc1owUkJRV2RFTEdkQ1FVRm5RaXhGUVVGRkxFdEJRVXM3UVVGRGFrbzdPMEZCUlU4N1FVRkRVRHRCUVVOQk8wRkJRMEVzTWtkQlFUSkhMSE5HUVVGelJpeGhRVUZoTEVWQlFVVTdRVUZEYUU0c2MwSkJRWE5DTERoQ1FVRTRRaXhuUkVGQlowUXNkVVJCUVhWRUxFVkJRVVVzUlVGQlJTeEhRVUZITzBGQlEyeExMRFJEUVVFMFF5eHpRMEZCYzBNc1ZVRkJWU3h2UWtGQmIwSXNSVUZCUlN4RlFVRkZMRlZCUVZVN1FVRkRPVWc3TzBGQlJVODdRVUZEVUN4blEwRkJaME1zZFVOQlFYVkRMR0ZCUVdFc1JVRkJSU3hGUVVGRkxFOUJRVThzYTBKQlFXdENPMEZCUTJwSU8wRkJRMEU3TzBGQlJVODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVODdRVUZEVUN3MFEwRkJORU03UVVGRE5VTTdPMEZCUlU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTjZUa0U3UVVGRFFTeERRVUZET3p0QlFVVkVPMEZCUTBFc2JVSkJRVzFDTEV0QlFUQkNPMEZCUXpkRE8wRkJRMEVzYTBKQlFXdENMRXRCUVhsQ08wRkJRek5ETzBGQlEwRXNlVUpCUVhsQ0xIRkNRVUZOTEdkQ1FVRm5RaXh4UWtGQlRUdEJRVU55UkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVWQlFVVTdPMEZCUlVZN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WlFVRlpMRTlCUVU4N1FVRkRia0lzWTBGQll5eE5RVUZOTzBGQlEzQkNPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmxCUVZrc1RVRkJUVHRCUVVOc1FpeFpRVUZaTEZOQlFWTTdRVUZEY2tJN1FVRkRRU3hqUVVGakxFMUJRVTA3UVVGRGNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzV1VGQldTeFBRVUZQTzBGQlEyNUNMRmxCUVZrc1UwRkJVenRCUVVOeVFqdEJRVU5CTEdOQlFXTXNUVUZCVFR0QlFVTndRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzV1VGQldTeFBRVUZQTzBGQlEyNUNMR05CUVdNc1RVRkJUVHRCUVVOd1FqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4eFEwRkJjVU03UVVGRGNrTTdRVUZEUVN4TFFVRkxPMEZCUTB3c05FSkJRVFJDTzBGQlF6VkNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzU1VGQlNUdEJRVU5LTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmxCUVZrc1RVRkJUVHRCUVVOc1FpeGpRVUZqTEU5QlFVODdRVUZEY2tJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGbEJRVmtzVDBGQlR6dEJRVU51UWl4alFVRmpMRTlCUVU4N1FVRkRja0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNXVUZCV1N4UFFVRlBPMEZCUTI1Q0xHTkJRV01zVDBGQlR6dEJRVU55UWp0QlFVTkJPMEZCUTBFc1UwRkJVenRCUVVOVU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxDdENRVUVyUWl4dFEwRkJiVU03UVVGRGJFVTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WlFVRlpMRTlCUVU4N1FVRkRia0lzWTBGQll5eFBRVUZQTzBGQlEzSkNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeGhRVUZoTEZkQlFWYzdRVUZEZUVJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc2QwSkJRWGRDT3p0QlFVVjRRaXg1UTBGQmVVTXNjVUpCUVhGQ096dEJRVVU1UkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYTBOQlFXdERMRzlDUVVGdlFqczdRVUZGZEVRN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3haUVVGWkxFOUJRVTg3UVVGRGJrSXNZMEZCWXl4UFFVRlBPMEZCUTNKQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzWVVGQllTeHBRa0ZCYVVJN1FVRkRPVUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxEQkNRVUV3UWl4cFFrRkJhVUk3UVVGRE0wTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVN4alFVRmpMR2xDUVVGcFFqdEJRVU12UWpzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRGhDUVVFNFFpeHZRa0ZCYjBJN1FVRkRiRVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzV1VGQldTeFBRVUZQTzBGQlEyNUNPMEZCUTBFc1kwRkJZeXhQUVVGUE8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZsQlFWa3NUMEZCVHp0QlFVTnVRanRCUVVOQkxHTkJRV01zVDBGQlR6dEJRVU55UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0RzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRVZCUVVVc1NVRkZWVHRCUVVOYU8wRkJRMEVzUlVGQlJTeHRRMEZCYlVJN1FVRkRja0k3UVVGRFFTeEhRVUZITzBGQlFVRXNhMGRCUVVNN1FVRkRTaXhGUVVGRkxFMUJRVTBzUlVGVlRqczdRVUZGUml4RFFVRkRPenM3T3pzN096czdPenM3UVVOcWFFSkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSV0U3TzBGQlJXSXNaVUZCWlN4dFFrRkJUeXhEUVVGRExITkZRVUZWTzBGQlEycERMRmRCUVZjc2JVSkJRVThzUTBGQlF5d3dRMEZCVVRzN1FVRkZNMElzWVVGQllUdEJRVU5pTEdWQlFXVTdRVUZEWml4eFFrRkJjVUk3UVVGRGNrSXNZMEZCWXpzN1FVRkZaQ3hYUVVGWE96dEJRVVZZTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTeG5Ra0ZCWjBJc1MwRkJTenM3UVVGRmNrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VOQlFYRkRPMEZCUTNKRE8wRkJRMEU3UVVGRFFTd3lRMEZCTWtNc1MwRkJTenRCUVVOb1JDd3dRMEZCTUVNc1MwRkJTenRCUVVNdlF6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHdzYTBKQlFXdENMRzFDUVVGUExFTkJRVU1zZDBSQlFXRTdPMEZCUlhaRE8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc2IwTkJRVzlETzBGQlEzQkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzTkVKQlFUUkNPMEZCUXk5RE8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNiVUpCUVcxQ0xIbENRVUY1UWp0QlFVTTFRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTERKRFFVRXlReXhQUVVGUE8wRkJRMnhFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc01FTkJRVEJETEU5QlFVODdRVUZEYWtRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdGQlFXRTdRVUZEWWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3d3UTBGQk1FTXNUMEZCVHp0QlFVTnFSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3TzBGQlIwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxHdENRVUZyUWl4dFFrRkJiVUk3UVVGRGNrTTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2IwSkJRVzlDTEcxQ1FVRnRRanRCUVVOMlF6dEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNjVUpCUVhGQ0xHbENRVUZwUWp0QlFVTjBRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEaENRVUU0UWl4UlFVRlJPMEZCUTNSRE8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hWUVVGVkxFMUJRVTA3UVVGRGFFSTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3T3pzN096czdPenM3TzBGRE0zUkNZVHM3UVVGRllqdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096dEJRMlpCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hET3pzN096czdPenM3T3p0QlEweEJPMEZCUTBFN08wRkJSV0U3TzBGQlJXSXNkMEpCUVhkQ0xHMUNRVUZQTEVOQlFVTXNNRVJCUVdNN1FVRkRPVU1zTUVKQlFUQkNMRzFDUVVGUExFTkJRVU1zTkVWQlFYVkNPMEZCUTNwRUxITkNRVUZ6UWl4dFFrRkJUeXhEUVVGRExHOUZRVUZ0UWp0QlFVTnFSQ3h0UWtGQmJVSXNiVUpCUVU4c1EwRkJReXc0UkVGQlowSTdPMEZCUlRORE8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUczdRVUZGUVN4NVFrRkJlVUk3UVVGRGVrSXNNa0pCUVRKQ08wRkJRek5DTEc5Q1FVRnZRanM3UVVGRmNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJN08wRkJSV3BDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4NVFrRkJlVUk3T3p0QlFVZDZRanRCUVVOQk8wRkJRMEU3UVVGRFFTeHZRa0ZCYjBJN08wRkJSWEJDTzBGQlEwRTdRVUZEUVR0QlFVTkJMREpDUVVFeVFqczdRVUZGTTBJN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VKQlFYRkNPenRCUVVWeVFqdEJRVU5CTzBGQlEwRTdRVUZEUVN4eFFrRkJjVUk3TzBGQlJYSkNPMEZCUTBFN1FVRkRRVHRCUVVOQkxHMUNRVUZ0UWpzN1FVRkZia0k3UVVGRFFUdEJRVU5CTzBGQlEwRXNiMEpCUVc5Q096dEJRVVZ3UWp0QlFVTkJPMEZCUTBFN1FVRkRRU3h2UWtGQmIwSTdPMEZCUlhCQ08wRkJRMEU3UVVGRFFUdEJRVU5CTEhOQ1FVRnpRanM3UVVGRmRFSTdRVUZEUVR0QlFVTkJPMEZCUTBFc2MwSkJRWE5DT3p0QlFVVjBRanRCUVVOQk8wRkJRMEU3UVVGRFFTeDFRa0ZCZFVJN08wRkJSWFpDTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGRDUVVGM1FqczdRVUZGZUVJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hoUVVGaE96dEJRVVZpTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGhRVUZoT3p0QlFVVmlPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4cFFrRkJhVUk3TzBGQlJXcENPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDT3p0QlFVVnFRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVSkJRWEZDT3p0QlFVVnlRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hyUWtGQmEwSTdPMEZCUld4Q08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3d5UWtGQk1rSTdPMEZCUlROQ08wRkJRMEU3UVVGRFFUdEJRVU5CTEhWQ1FVRjFRanM3UVVGRmRrSTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVSkJRWEZDT3p0QlFVVnlRanRCUVVOQk8wRkJRMEU3UVVGRFFTeHhRa0ZCY1VJN08wRkJSWEpDTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGxDUVVGNVFqczdRVUZGZWtJN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVOQlFXMURPenRCUVVWdVF6dEJRVU5CTzBGQlEwRTdRVUZEUVN4elFrRkJjMEk3TzBGQlJYUkNPMEZCUTBFN1FVRkRRVHRCUVVOQkxITkNRVUZ6UWpzN1FVRkZkRUk3UVVGRFFUdEJRVU5CTzBGQlEwRXNkVUpCUVhWQ096dEJRVVYyUWp0QlFVTkJPMEZCUTBFN1FVRkRRU3h6UWtGQmMwSTdPMEZCUlhSQ08wRkJRMEU3UVVGRFFUdEJRVU5CTEhOQ1FVRnpRanM3UVVGRmRFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNkMEpCUVhkQ096dEJRVVY0UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeDNRa0ZCZDBJN08wRkJSWGhDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNDeERRVUZET3pzN096czdPenM3T3pzN08wRkRNMVZFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHRRa0ZCYlVJc2FVSkJRV2xDTzBGQlEzQkRPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNZMEZCWXp0QlFVTmtPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNjMEpCUVhOQ08wRkJRM3BETzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTEhWQ1FVRjFRaXhUUVVGVE8wRkJRMmhETzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYVVKQlFXbENPMEZCUTJwQ0xHRkJRV0VzVDBGQlR5eHZRa0ZCYjBJc1QwRkJUenRCUVVNdlF6dEJRVU5CT3p0QlFVVkJPMEZCUTBFc1lVRkJZU3hQUVVGUE8wRkJRM0JDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZWQlFWVXNUMEZCVHp0QlFVTnFRanRCUVVOQkxFOUJRVThzVlVGQlZTeFBRVUZQTzBGQlEzaENMRkZCUVZFc1QwRkJUenRCUVVObUxFOUJRVTg3UVVGRFVDeFJRVUZSTEU5QlFVODdRVUZEWmp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPenRCUVVkQk8wRkJRMEU3TzBGQlJVRXNTVUZCU1N4UFFVRlBPMEZCUTFnc2FVSkJRV2xDTEU5QlFVODdRVUZEZUVJc2NVTkJRWEZETzBGQlEzSkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeG5Ra0ZCWjBJN1FVRkRhRUk3UVVGRFFUdEJRVU5CTzBGQlEwRXNaMEpCUVdkQ0xFOUJRVTg3UVVGRGRrSTdRVUZEUVR0QlFVTkJMRkZCUVZFc1QwRkJUenRCUVVObU8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096dEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEZkQlFWY3NUMEZCVHp0QlFVTnNRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hsUVVGbE96czdRVUZIWmp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096dEJRVWRCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVRzN08wRkJSMEU3UVVGRFFUdEJRVU5CT3pzN1FVRkhRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4SFFVRkhPenRCUVVWSU8wRkJRMEU3T3p0QlFVZEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRXNORU5CUVRSRExFdEJRVXM3TzBGQlJXcEVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREczdRVUZGUVRzN1FVRkZRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN1FVRkhRVHRCUVVOQk8wRkJRMEU3T3p0QlFVZEJPMEZCUTBFN1FVRkRRU3h0UTBGQmJVTXNUMEZCVHp0QlFVTXhRenRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPenM3UVVGSFFUdEJRVU5CTzBGQlEwRXNlVVJCUVhsRU8wRkJRM3BFTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnp0QlFVTllMRk5CUVZNN1FVRkRWRHRCUVVOQk8wRkJRMEVzVjBGQlZ6dEJRVU5ZTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdPMEZCUjBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3T3p0QlFVZEJPMEZCUTBFN1FVRkRRU3hyUjBGQk1FTTdPMEZCUlRGRE8wRkJRMEU3UVVGRFFUdEJRVU5CTEdWQlFXVTdPMEZCUldZN1FVRkRRVHRCUVVOQk8wRkJRMEVzYVVKQlFXbENPenRCUVVWcVFqdEJRVU5CTzBGQlEwRTdRVUZEUVN4alFVRmpPenRCUVVWa08wRkJRMEU3UVVGRFFUdEJRVU5CTEhsQ1FVRjVRanM3UVVGRmVrSTdRVUZEUVR0QlFVTkJPMEZCUTBFc1owSkJRV2RDT3p0QlFVVm9RanRCUVVOQk8wRkJRMEU3UVVGRFFTeG5Ra0ZCWjBJN08wRkJSV2hDTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2RDUVVGblFqczdRVUZGYUVJN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVKQlFXMUNPenRCUVVWdVFqdEJRVU5CTzBGQlEwRTdRVUZEUVN4blFrRkJaMEk3UVVGRGFFSXNjMEpCUVhOQ096dEJRVVYwUWp0QlFVTkJPMEZCUTBFN1FVRkRRU3huUWtGQlowSTdPMEZCUldoQ08wRkJRMEU3UVVGRFFUdEJRVU5CTEdOQlFXTTdRVUZEWkN4dlFrRkJiMEk3TzBGQlJYQkNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWlVGQlpUdEJRVU5tTERKQ1FVRXlRanM3UVVGRk0wSTdRVUZEUVR0QlFVTkJPMEZCUTBFc2EwSkJRV3RDT3p0QlFVVnNRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDT3p0QlFVVnVRaXhyU0VGQlowUTdPMEZCUldoRU8wRkJRMEU3UVVGRFFUczdPMEZCUjBFN1FVRkRRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096dEJRVWRCTzBGQlEwRXNWMEZCVnp0QlFVTllMRVZCUVVVc1QwRkJUenRCUVVOVU96czdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WFFVRlhMRk5CUVZNN1FVRkRjRUk3UVVGRFFTeFhRVUZYTEZOQlFWTTdRVUZEY0VJN1FVRkRRU3h4UjBGQmMwTTdPMEZCUlhSRExHVkJRV1U3UVVGRFpqdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVN4cFFrRkJhVUk3UVVGRGFrSTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE96dEJRVVZNTzBGQlEwRXNiVUpCUVcxQ0xITkNRVUZ6UWp0QlFVTjZRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNUMEZCVHp0QlFVTlFPMEZCUTBFN1FVRkRRU3hMUVVGTE96dEJRVVZNTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeDNRa0ZCZDBJN08wRkJSWGhDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVKQlFXMUNMSE5DUVVGelFqdEJRVU42UXp0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTd3lRa0ZCTWtJc1EwRkJReXhQUVVGUExIRkRRVUZ4UXp0QlFVTjRSU3d5UWtGQk1rSXNRMEZCUXl4UFFVRlBMSE5FUVVGelJEdEJRVU42UmpzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiVUpCUVcxQ096czdPenM3T3pzN096czdRVU14YzBKT096dEJRVVZpTEdOQlFXTXNiVUpCUVU4c1EwRkJReXhuUkVGQlV6dEJRVU12UWl3eVFrRkJNa0lzYlVKQlFVOHNRMEZCUXl3NFJVRkJkMEk3UVVGRE0wUXNaMEpCUVdkQ0xHMUNRVUZQTEVOQlFVTXNhMFZCUVhGQ096dEJRVVUzUXp0QlFVTkJMR2xDUVVGcFFpeHRRa0ZCVHl4RFFVRkRMSGRFUVVGaE8wRkJRM1JET3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEcxQ1FVRlBMRU5CUVVNc2IwaEJRVGhETzBGQlEycEZMREpEUVVFeVF6dEJRVU16UXp0QlFVTkJPMEZCUTBFc1lVRkJZU3h4UWtGQlRUdEJRVU51UWl4cFFrRkJhVUlzY1VKQlFVMDdRVUZEZGtJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFVkJRVVU3UVVGRFJqczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SlFVRkpPMEZCUTBvN1FVRkRRU3hGUVVGRk8wRkJRMFk3UVVGRFFUczdRVUZGUVN4dFFrRkJiVUlzYlVKQlFVOHNRMEZCUXl3NFJFRkJaMEk3TzBGQlJUTkRPMEZCUTBFc05FSkJRVFJDTEdOQlFXTTdRVUZETVVNc2RVSkJRWFZDTEhkRFFVRjNRenRCUVVNdlJEdEJRVU5CT3pzN096czdPMVZEZGtSQk8xVkJRMEU3TzFWQlJVRTdWVUZEUVR0VlFVTkJPMVZCUTBFN1ZVRkRRVHRWUVVOQk8xVkJRMEU3VlVGRFFUdFZRVU5CTzFWQlEwRTdWVUZEUVR0VlFVTkJPMVZCUTBFN08xVkJSVUU3VlVGRFFUczdWVUZGUVR0VlFVTkJPenRWUVVWQk8xVkJRMEU3VlVGRFFUczdPenM3VjBONlFrRTdWMEZEUVR0WFFVTkJPMWRCUTBFN1YwRkRRU3gzUTBGQmQwTXNlVU5CUVhsRE8xZEJRMnBHTzFkQlEwRTdWMEZEUVN4Rk96czdPenRYUTFCQk8xZEJRMEU3VjBGRFFUdFhRVU5CTzFkQlEwRXNSVUZCUlR0WFFVTkdPMWRCUTBFN1YwRkRRU3hEUVVGRExFazdPenM3TzFkRFVFUXNkMFk3T3pzN08xZERRVUU3VjBGRFFUdFhRVU5CTzFkQlEwRXNjMFJCUVhORUxHdENRVUZyUWp0WFFVTjRSVHRYUVVOQkxDdERRVUVyUXl4alFVRmpPMWRCUXpkRUxFVTdPenM3TzFkRFRrRTdWMEZEUVR0WFFVTkJPMWRCUTBFN1YwRkRRU3hGT3pzN096czdPenM3T3pzN096czdRVU5LUVN4elJVRkJkVU03UVVGQk9VSXNhVWhCUVZjaUxDSm1hV3hsSWpvaVluVnVaR3hsTG1weklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lLR1oxYm1OMGFXOXVJSGRsWW5CaFkydFZibWwyWlhKellXeE5iMlIxYkdWRVpXWnBibWwwYVc5dUtISnZiM1FzSUdaaFkzUnZjbmtwSUh0Y2JseDBMeTlEYjIxdGIyNUtVeklnUTI5dGJXVnVkRnh1WEhScFppaDBlWEJsYjJZZ1pYaHdiM0owY3lBOVBUMGdKMjlpYW1WamRDY2dKaVlnZEhsd1pXOW1JRzF2WkhWc1pTQTlQVDBnSjI5aWFtVmpkQ2NwWEc1Y2RGeDBiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1ZV04wYjNKNUtDazdYRzVjZEM4dlFVMUVJRU52YlcxbGJuUmNibHgwWld4elpTQnBaaWgwZVhCbGIyWWdaR1ZtYVc1bElEMDlQU0FuWm5WdVkzUnBiMjRuSUNZbUlHUmxabWx1WlM1aGJXUXBYRzVjZEZ4MFpHVm1hVzVsS0Z0ZExDQm1ZV04wYjNKNUtUdGNibHgwTHk5RGIyMXRiMjVLVXlCRGIyMXRaVzUwWEc1Y2RHVnNjMlVnYVdZb2RIbHdaVzltSUdWNGNHOXlkSE1nUFQwOUlDZHZZbXBsWTNRbktWeHVYSFJjZEdWNGNHOXlkSE5iWENKcGJXZDFjbHdpWFNBOUlHWmhZM1J2Y25rb0tUdGNibHgwTHk5U2IyOTBJRU52YlcxbGJuUmNibHgwWld4elpWeHVYSFJjZEhKdmIzUmJYQ0pwYldkMWNsd2lYU0E5SUdaaFkzUnZjbmtvS1R0Y2JuMHBLSFI1Y0dWdlppQnpaV3htSUNFOVBTQW5kVzVrWldacGJtVmtKeUEvSUhObGJHWWdPaUIwYUdsekxDQm1kVzVqZEdsdmJpZ3BJSHRjYm5KbGRIVnliaUFpTENKY2JpOHFLbHh1SUNvZ1FYSnlZWGtqWm1sc2RHVnlMbHh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdRWEp5WVhsOUlHRnljbHh1SUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ1ptNWNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBQWDBnYzJWc1pseHVJQ29nUUhKbGRIVnliaUI3UVhKeVlYbDlYRzRnS2lCQWRHaHliM2NnVkhsd1pVVnljbTl5WEc0Z0tpOWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUFvWVhKeUxDQm1iaXdnYzJWc1ppa2dlMXh1SUNCcFppQW9ZWEp5TG1acGJIUmxjaWtnY21WMGRYSnVJR0Z5Y2k1bWFXeDBaWElvWm00c0lITmxiR1lwTzF4dUlDQnBaaUFvZG05cFpDQXdJRDA5UFNCaGNuSWdmSHdnYm5Wc2JDQTlQVDBnWVhKeUtTQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlPMXh1SUNCcFppQW9KMloxYm1OMGFXOXVKeUFoUFNCMGVYQmxiMllnWm00cElIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSTdYRzRnSUhaaGNpQnlaWFFnUFNCYlhUdGNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCaGNuSXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0JwWmlBb0lXaGhjMDkzYmk1allXeHNLR0Z5Y2l3Z2FTa3BJR052Ym5ScGJuVmxPMXh1SUNBZ0lIWmhjaUIyWVd3Z1BTQmhjbkpiYVYwN1hHNGdJQ0FnYVdZZ0tHWnVMbU5oYkd3b2MyVnNaaXdnZG1Gc0xDQnBMQ0JoY25JcEtTQnlaWFF1Y0hWemFDaDJZV3dwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJ5WlhRN1hHNTlPMXh1WEc1MllYSWdhR0Z6VDNkdUlEMGdUMkpxWldOMExuQnliM1J2ZEhsd1pTNW9ZWE5QZDI1UWNtOXdaWEowZVR0Y2JpSXNJaTh2SUVOMWNuSmxiblJzZVNCcGJpQnplVzVqSUhkcGRHZ2dUbTlrWlM1cWN5QnNhV0l2WVhOelpYSjBMbXB6WEc0dkx5Qm9kSFJ3Y3pvdkwyZHBkR2gxWWk1amIyMHZibTlrWldwekwyNXZaR1V2WTI5dGJXbDBMekpoTlRGaFpUUXlOR0UxTVRObFl6bGhObUZoTXpRMk5tSmhZVEJqWXpGa05UVmtaRFJtTTJKY2JpOHZJRTl5YVdkcGJtRnNiSGtnWm5KdmJTQnVZWEozYUdGc0xtcHpJQ2hvZEhSd09pOHZibUZ5ZDJoaGJHcHpMbTl5WnlsY2JpOHZJRU52Y0hseWFXZG9kQ0FvWXlrZ01qQXdPU0JVYUc5dFlYTWdVbTlpYVc1emIyNGdQREk0TUc1dmNuUm9MbU52YlQ1Y2JpOHZYRzR2THlCUVpYSnRhWE56YVc5dUlHbHpJR2hsY21WaWVTQm5jbUZ1ZEdWa0xDQm1jbVZsSUc5bUlHTm9ZWEpuWlN3Z2RHOGdZVzU1SUhCbGNuTnZiaUJ2WW5SaGFXNXBibWNnWVNCamIzQjVYRzR2THlCdlppQjBhR2x6SUhOdlpuUjNZWEpsSUdGdVpDQmhjM052WTJsaGRHVmtJR1J2WTNWdFpXNTBZWFJwYjI0Z1ptbHNaWE1nS0hSb1pTQW5VMjltZEhkaGNtVW5LU3dnZEc5Y2JpOHZJR1JsWVd3Z2FXNGdkR2hsSUZOdlpuUjNZWEpsSUhkcGRHaHZkWFFnY21WemRISnBZM1JwYjI0c0lHbHVZMngxWkdsdVp5QjNhWFJvYjNWMElHeHBiV2wwWVhScGIyNGdkR2hsWEc0dkx5QnlhV2RvZEhNZ2RHOGdkWE5sTENCamIzQjVMQ0J0YjJScFpua3NJRzFsY21kbExDQndkV0pzYVhOb0xDQmthWE4wY21saWRYUmxMQ0J6ZFdKc2FXTmxibk5sTENCaGJtUXZiM0pjYmk4dklITmxiR3dnWTI5d2FXVnpJRzltSUhSb1pTQlRiMlowZDJGeVpTd2dZVzVrSUhSdklIQmxjbTFwZENCd1pYSnpiMjV6SUhSdklIZG9iMjBnZEdobElGTnZablIzWVhKbElHbHpYRzR2THlCbWRYSnVhWE5vWldRZ2RHOGdaRzhnYzI4c0lITjFZbXBsWTNRZ2RHOGdkR2hsSUdadmJHeHZkMmx1WnlCamIyNWthWFJwYjI1ek9seHVMeTljYmk4dklGUm9aU0JoWW05MlpTQmpiM0I1Y21sbmFIUWdibTkwYVdObElHRnVaQ0IwYUdseklIQmxjbTFwYzNOcGIyNGdibTkwYVdObElITm9ZV3hzSUdKbElHbHVZMngxWkdWa0lHbHVYRzR2THlCaGJHd2dZMjl3YVdWeklHOXlJSE4xWW5OMFlXNTBhV0ZzSUhCdmNuUnBiMjV6SUc5bUlIUm9aU0JUYjJaMGQyRnlaUzVjYmk4dlhHNHZMeUJVU0VVZ1UwOUdWRmRCVWtVZ1NWTWdVRkpQVmtsRVJVUWdKMEZUSUVsVEp5d2dWMGxVU0U5VlZDQlhRVkpTUVU1VVdTQlBSaUJCVGxrZ1MwbE9SQ3dnUlZoUVVrVlRVeUJQVWx4dUx5OGdTVTFRVEVsRlJDd2dTVTVEVEZWRVNVNUhJRUpWVkNCT1QxUWdURWxOU1ZSRlJDQlVUeUJVU0VVZ1YwRlNVa0ZPVkVsRlV5QlBSaUJOUlZKRFNFRk9WRUZDU1V4SlZGa3NYRzR2THlCR1NWUk9SVk5USUVaUFVpQkJJRkJCVWxSSlExVk1RVklnVUZWU1VFOVRSU0JCVGtRZ1RrOU9TVTVHVWtsT1IwVk5SVTVVTGlCSlRpQk9UeUJGVmtWT1ZDQlRTRUZNVENCVVNFVmNiaTh2SUVGVlZFaFBVbE1nUWtVZ1RFbEJRa3hGSUVaUFVpQkJUbGtnUTB4QlNVMHNJRVJCVFVGSFJWTWdUMUlnVDFSSVJWSWdURWxCUWtsTVNWUlpMQ0JYU0VWVVNFVlNJRWxPSUVGT1hHNHZMeUJCUTFSSlQwNGdUMFlnUTA5T1ZGSkJRMVFzSUZSUFVsUWdUMUlnVDFSSVJWSlhTVk5GTENCQlVrbFRTVTVISUVaU1QwMHNJRTlWVkNCUFJpQlBVaUJKVGlCRFQwNU9SVU5VU1U5T1hHNHZMeUJYU1ZSSUlGUklSU0JUVDBaVVYwRlNSU0JQVWlCVVNFVWdWVk5GSUU5U0lFOVVTRVZTSUVSRlFVeEpUa2RUSUVsT0lGUklSU0JUVDBaVVYwRlNSUzVjYmlkMWMyVWdjM1J5YVdOMEp6dGNibHh1Wm5WdVkzUnBiMjRnWDNSNWNHVnZaaWh2WW1vcElIc2dhV1lnS0hSNWNHVnZaaUJUZVcxaWIyd2dQVDA5SUZ3aVpuVnVZM1JwYjI1Y0lpQW1KaUIwZVhCbGIyWWdVM2x0WW05c0xtbDBaWEpoZEc5eUlEMDlQU0JjSW5ONWJXSnZiRndpS1NCN0lGOTBlWEJsYjJZZ1BTQm1kVzVqZEdsdmJpQmZkSGx3Wlc5bUtHOWlhaWtnZXlCeVpYUjFjbTRnZEhsd1pXOW1JRzlpYWpzZ2ZUc2dmU0JsYkhObElIc2dYM1I1Y0dWdlppQTlJR1oxYm1OMGFXOXVJRjkwZVhCbGIyWW9iMkpxS1NCN0lISmxkSFZ5YmlCdlltb2dKaVlnZEhsd1pXOW1JRk41YldKdmJDQTlQVDBnWENKbWRXNWpkR2x2Ymx3aUlDWW1JRzlpYWk1amIyNXpkSEoxWTNSdmNpQTlQVDBnVTNsdFltOXNJQ1ltSUc5aWFpQWhQVDBnVTNsdFltOXNMbkJ5YjNSdmRIbHdaU0EvSUZ3aWMzbHRZbTlzWENJZ09pQjBlWEJsYjJZZ2IySnFPeUI5T3lCOUlISmxkSFZ5YmlCZmRIbHdaVzltS0c5aWFpazdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gyTnNZWE56UTJGc2JFTm9aV05yS0dsdWMzUmhibU5sTENCRGIyNXpkSEoxWTNSdmNpa2dleUJwWmlBb0lTaHBibk4wWVc1alpTQnBibk4wWVc1alpXOW1JRU52Ym5OMGNuVmpkRzl5S1NrZ2V5QjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLRndpUTJGdWJtOTBJR05oYkd3Z1lTQmpiR0Z6Y3lCaGN5QmhJR1oxYm1OMGFXOXVYQ0lwT3lCOUlIMWNibHh1ZG1GeUlGOXlaWEYxYVhKbElEMGdjbVZ4ZFdseVpTZ25MaTlwYm5SbGNtNWhiQzlsY25KdmNuTW5LU3hjYmlBZ0lDQmZjbVZ4ZFdseVpTUmpiMlJsY3lBOUlGOXlaWEYxYVhKbExtTnZaR1Z6TEZ4dUlDQWdJRVZTVWw5QlRVSkpSMVZQVlZOZlFWSkhWVTFGVGxRZ1BTQmZjbVZ4ZFdseVpTUmpiMlJsY3k1RlVsSmZRVTFDU1VkVlQxVlRYMEZTUjFWTlJVNVVMRnh1SUNBZ0lFVlNVbDlKVGxaQlRFbEVYMEZTUjE5VVdWQkZJRDBnWDNKbGNYVnBjbVVrWTI5a1pYTXVSVkpTWDBsT1ZrRk1TVVJmUVZKSFgxUlpVRVVzWEc0Z0lDQWdSVkpTWDBsT1ZrRk1TVVJmUVZKSFgxWkJURlZGSUQwZ1gzSmxjWFZwY21Va1kyOWtaWE11UlZKU1gwbE9Wa0ZNU1VSZlFWSkhYMVpCVEZWRkxGeHVJQ0FnSUVWU1VsOUpUbFpCVEVsRVgxSkZWRlZTVGw5V1FVeFZSU0E5SUY5eVpYRjFhWEpsSkdOdlpHVnpMa1ZTVWw5SlRsWkJURWxFWDFKRlZGVlNUbDlXUVV4VlJTeGNiaUFnSUNCRlVsSmZUVWxUVTBsT1IxOUJVa2RUSUQwZ1gzSmxjWFZwY21Va1kyOWtaWE11UlZKU1gwMUpVMU5KVGtkZlFWSkhVenRjYmx4dWRtRnlJRUZ6YzJWeWRHbHZia1Z5Y205eUlEMGdjbVZ4ZFdseVpTZ25MaTlwYm5SbGNtNWhiQzloYzNObGNuUXZZWE56WlhKMGFXOXVYMlZ5Y205eUp5azdYRzVjYm5aaGNpQmZjbVZ4ZFdseVpUSWdQU0J5WlhGMWFYSmxLQ2QxZEdsc0x5Y3BMRnh1SUNBZ0lHbHVjM0JsWTNRZ1BTQmZjbVZ4ZFdseVpUSXVhVzV6Y0dWamREdGNibHh1ZG1GeUlGOXlaWEYxYVhKbEpIUjVjR1Z6SUQwZ2NtVnhkV2x5WlNnbmRYUnBiQzhuS1M1MGVYQmxjeXhjYmlBZ0lDQnBjMUJ5YjIxcGMyVWdQU0JmY21WeGRXbHlaU1IwZVhCbGN5NXBjMUJ5YjIxcGMyVXNYRzRnSUNBZ2FYTlNaV2RGZUhBZ1BTQmZjbVZ4ZFdseVpTUjBlWEJsY3k1cGMxSmxaMFY0Y0R0Y2JseHVkbUZ5SUc5aWFtVmpkRUZ6YzJsbmJpQTlJRTlpYW1WamRDNWhjM05wWjI0Z1B5QlBZbXBsWTNRdVlYTnphV2R1SURvZ2NtVnhkV2x5WlNnblpYTTJMVzlpYW1WamRDMWhjM05wWjI0bktTNWhjM05wWjI0N1hHNTJZWElnYjJKcVpXTjBTWE1nUFNCUFltcGxZM1F1YVhNZ1B5QlBZbXBsWTNRdWFYTWdPaUJ5WlhGMWFYSmxLQ2R2WW1wbFkzUXRhWE1uS1R0Y2JuWmhjaUJsY25KdmNrTmhZMmhsSUQwZ2JtVjNJRTFoY0NncE8xeHVkbUZ5SUdselJHVmxjRVZ4ZFdGc08xeHVkbUZ5SUdselJHVmxjRk4wY21samRFVnhkV0ZzTzF4dWRtRnlJSEJoY25ObFJYaHdjbVZ6YzJsdmJrRjBPMXh1ZG1GeUlHWnBibVJPYjJSbFFYSnZkVzVrTzF4dWRtRnlJR1JsWTI5a1pYSTdYRzVjYm1aMWJtTjBhVzl1SUd4aGVubE1iMkZrUTI5dGNHRnlhWE52YmlncElIdGNiaUFnZG1GeUlHTnZiWEJoY21semIyNGdQU0J5WlhGMWFYSmxLQ2N1TDJsdWRHVnlibUZzTDNWMGFXd3ZZMjl0Y0dGeWFYTnZibk1uS1R0Y2JseHVJQ0JwYzBSbFpYQkZjWFZoYkNBOUlHTnZiWEJoY21semIyNHVhWE5FWldWd1JYRjFZV3c3WEc0Z0lHbHpSR1ZsY0ZOMGNtbGpkRVZ4ZFdGc0lEMGdZMjl0Y0dGeWFYTnZiaTVwYzBSbFpYQlRkSEpwWTNSRmNYVmhiRHRjYm4wZ0x5OGdSWE5qWVhCbElHTnZiblJ5YjJ3Z1kyaGhjbUZqZEdWeWN5QmlkWFFnYm05MElGeGNiaUJoYm1RZ1hGeDBJSFJ2SUd0bFpYQWdkR2hsSUd4cGJtVWdZbkpsWVd0eklHRnVaRnh1THk4Z2FXNWtaVzUwWVhScGIyNGdhVzUwWVdOMExseHVMeThnWlhOc2FXNTBMV1JwYzJGaWJHVXRibVY0ZEMxc2FXNWxJRzV2TFdOdmJuUnliMnd0Y21WblpYaGNibHh1WEc1MllYSWdaWE5qWVhCbFUyVnhkV1Z1WTJWelVtVm5SWGh3SUQwZ0wxdGNYSGd3TUMxY1hIZ3dPRnhjZURCaVhGeDRNR05jWEhnd1pTMWNYSGd4Wmwwdlp6dGNiblpoY2lCdFpYUmhJRDBnVzF3aVhGeGNYSFV3TURBd1hDSXNJRndpWEZ4Y1hIVXdNREF4WENJc0lGd2lYRnhjWEhVd01EQXlYQ0lzSUZ3aVhGeGNYSFV3TURBelhDSXNJRndpWEZ4Y1hIVXdNREEwWENJc0lGd2lYRnhjWEhVd01EQTFYQ0lzSUZ3aVhGeGNYSFV3TURBMlhDSXNJRndpWEZ4Y1hIVXdNREEzWENJc0lDZGNYRnhjWWljc0lDY25MQ0FuSnl3Z1hDSmNYRnhjZFRBd01HSmNJaXdnSjF4Y1hGeG1KeXdnSnljc0lGd2lYRnhjWEhVd01EQmxYQ0lzSUZ3aVhGeGNYSFV3TURCbVhDSXNJRndpWEZ4Y1hIVXdNREV3WENJc0lGd2lYRnhjWEhVd01ERXhYQ0lzSUZ3aVhGeGNYSFV3TURFeVhDSXNJRndpWEZ4Y1hIVXdNREV6WENJc0lGd2lYRnhjWEhVd01ERTBYQ0lzSUZ3aVhGeGNYSFV3TURFMVhDSXNJRndpWEZ4Y1hIVXdNREUyWENJc0lGd2lYRnhjWEhVd01ERTNYQ0lzSUZ3aVhGeGNYSFV3TURFNFhDSXNJRndpWEZ4Y1hIVXdNREU1WENJc0lGd2lYRnhjWEhVd01ERmhYQ0lzSUZ3aVhGeGNYSFV3TURGaVhDSXNJRndpWEZ4Y1hIVXdNREZqWENJc0lGd2lYRnhjWEhVd01ERmtYQ0lzSUZ3aVhGeGNYSFV3TURGbFhDSXNJRndpWEZ4Y1hIVXdNREZtWENKZE8xeHVYRzUyWVhJZ1pYTmpZWEJsUm00Z1BTQm1kVzVqZEdsdmJpQmxjMk5oY0dWR2JpaHpkSElwSUh0Y2JpQWdjbVYwZFhKdUlHMWxkR0ZiYzNSeUxtTm9ZWEpEYjJSbFFYUW9NQ2xkTzF4dWZUdGNibHh1ZG1GeUlIZGhjbTVsWkNBOUlHWmhiSE5sT3lBdkx5QlVhR1VnWVhOelpYSjBJRzF2WkhWc1pTQndjbTkyYVdSbGN5Qm1kVzVqZEdsdmJuTWdkR2hoZENCMGFISnZkMXh1THk4Z1FYTnpaWEowYVc5dVJYSnliM0luY3lCM2FHVnVJSEJoY25ScFkzVnNZWElnWTI5dVpHbDBhVzl1Y3lCaGNtVWdibTkwSUcxbGRDNGdWR2hsWEc0dkx5QmhjM05sY25RZ2JXOWtkV3hsSUcxMWMzUWdZMjl1Wm05eWJTQjBieUIwYUdVZ1ptOXNiRzkzYVc1bklHbHVkR1Z5Wm1GalpTNWNibHh1ZG1GeUlHRnpjMlZ5ZENBOUlHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2IyczdYRzUyWVhJZ1RrOWZSVmhEUlZCVVNVOU9YMU5GVGxSSlRrVk1JRDBnZTMwN0lDOHZJRUZzYkNCdlppQjBhR1VnWm05c2JHOTNhVzVuSUdaMWJtTjBhVzl1Y3lCdGRYTjBJSFJvY205M0lHRnVJRUZ6YzJWeWRHbHZia1Z5Y205eVhHNHZMeUIzYUdWdUlHRWdZMjl5Y21WemNHOXVaR2x1WnlCamIyNWthWFJwYjI0Z2FYTWdibTkwSUcxbGRDd2dkMmwwYUNCaElHMWxjM05oWjJVZ2RHaGhkRnh1THk4Z2JXRjVJR0psSUhWdVpHVm1hVzVsWkNCcFppQnViM1FnY0hKdmRtbGtaV1F1SUVGc2JDQmhjM05sY25ScGIyNGdiV1YwYUc5a2N5QndjbTkyYVdSbFhHNHZMeUJpYjNSb0lIUm9aU0JoWTNSMVlXd2dZVzVrSUdWNGNHVmpkR1ZrSUhaaGJIVmxjeUIwYnlCMGFHVWdZWE56WlhKMGFXOXVJR1Z5Y205eUlHWnZjbHh1THk4Z1pHbHpjR3hoZVNCd2RYSndiM05sY3k1Y2JseHVablZ1WTNScGIyNGdhVzV1WlhKR1lXbHNLRzlpYWlrZ2UxeHVJQ0JwWmlBb2IySnFMbTFsYzNOaFoyVWdhVzV6ZEdGdVkyVnZaaUJGY25KdmNpa2dkR2h5YjNjZ2IySnFMbTFsYzNOaFoyVTdYRzRnSUhSb2NtOTNJRzVsZHlCQmMzTmxjblJwYjI1RmNuSnZjaWh2WW1vcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCbVlXbHNLR0ZqZEhWaGJDd2daWGh3WldOMFpXUXNJRzFsYzNOaFoyVXNJRzl3WlhKaGRHOXlMQ0J6ZEdGamExTjBZWEowUm00cElIdGNiaUFnZG1GeUlHRnlaM05NWlc0Z1BTQmhjbWQxYldWdWRITXViR1Z1WjNSb08xeHVJQ0IyWVhJZ2FXNTBaWEp1WVd4TlpYTnpZV2RsTzF4dVhHNGdJR2xtSUNoaGNtZHpUR1Z1SUQwOVBTQXdLU0I3WEc0Z0lDQWdhVzUwWlhKdVlXeE5aWE56WVdkbElEMGdKMFpoYVd4bFpDYzdYRzRnSUgwZ1pXeHpaU0JwWmlBb1lYSm5jMHhsYmlBOVBUMGdNU2tnZTF4dUlDQWdJRzFsYzNOaFoyVWdQU0JoWTNSMVlXdzdYRzRnSUNBZ1lXTjBkV0ZzSUQwZ2RXNWtaV1pwYm1Wa08xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHbG1JQ2gzWVhKdVpXUWdQVDA5SUdaaGJITmxLU0I3WEc0Z0lDQWdJQ0IzWVhKdVpXUWdQU0IwY25WbE8xeHVJQ0FnSUNBZ2RtRnlJSGRoY200Z1BTQndjbTlqWlhOekxtVnRhWFJYWVhKdWFXNW5JRDhnY0hKdlkyVnpjeTVsYldsMFYyRnlibWx1WnlBNklHTnZibk52YkdVdWQyRnliaTVpYVc1a0tHTnZibk52YkdVcE8xeHVJQ0FnSUNBZ2QyRnliaWduWVhOelpYSjBMbVpoYVd3b0tTQjNhWFJvSUcxdmNtVWdkR2hoYmlCdmJtVWdZWEpuZFcxbGJuUWdhWE1nWkdWd2NtVmpZWFJsWkM0Z0p5QXJJQ2RRYkdWaGMyVWdkWE5sSUdGemMyVnlkQzV6ZEhKcFkzUkZjWFZoYkNncElHbHVjM1JsWVdRZ2IzSWdiMjVzZVNCd1lYTnpJR0VnYldWemMyRm5aUzRuTENBblJHVndjbVZqWVhScGIyNVhZWEp1YVc1bkp5d2dKMFJGVURBd09UUW5LVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvWVhKbmMweGxiaUE5UFQwZ01pa2diM0JsY21GMGIzSWdQU0FuSVQwbk8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0cxbGMzTmhaMlVnYVc1emRHRnVZMlZ2WmlCRmNuSnZjaWtnZEdoeWIzY2diV1Z6YzJGblpUdGNiaUFnZG1GeUlHVnlja0Z5WjNNZ1BTQjdYRzRnSUNBZ1lXTjBkV0ZzT2lCaFkzUjFZV3dzWEc0Z0lDQWdaWGh3WldOMFpXUTZJR1Y0Y0dWamRHVmtMRnh1SUNBZ0lHOXdaWEpoZEc5eU9pQnZjR1Z5WVhSdmNpQTlQVDBnZFc1a1pXWnBibVZrSUQ4Z0oyWmhhV3duSURvZ2IzQmxjbUYwYjNJc1hHNGdJQ0FnYzNSaFkydFRkR0Z5ZEVadU9pQnpkR0ZqYTFOMFlYSjBSbTRnZkh3Z1ptRnBiRnh1SUNCOU8xeHVYRzRnSUdsbUlDaHRaWE56WVdkbElDRTlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0JsY25KQmNtZHpMbTFsYzNOaFoyVWdQU0J0WlhOellXZGxPMXh1SUNCOVhHNWNiaUFnZG1GeUlHVnljaUE5SUc1bGR5QkJjM05sY25ScGIyNUZjbkp2Y2lobGNuSkJjbWR6S1R0Y2JseHVJQ0JwWmlBb2FXNTBaWEp1WVd4TlpYTnpZV2RsS1NCN1hHNGdJQ0FnWlhKeUxtMWxjM05oWjJVZ1BTQnBiblJsY201aGJFMWxjM05oWjJVN1hHNGdJQ0FnWlhKeUxtZGxibVZ5WVhSbFpFMWxjM05oWjJVZ1BTQjBjblZsTzF4dUlDQjlYRzVjYmlBZ2RHaHliM2NnWlhKeU8xeHVmVnh1WEc1aGMzTmxjblF1Wm1GcGJDQTlJR1poYVd3N0lDOHZJRlJvWlNCQmMzTmxjblJwYjI1RmNuSnZjaUJwY3lCa1pXWnBibVZrSUdsdUlHbHVkR1Z5Ym1Gc0wyVnljbTl5TGx4dVhHNWhjM05sY25RdVFYTnpaWEowYVc5dVJYSnliM0lnUFNCQmMzTmxjblJwYjI1RmNuSnZjanRjYmx4dVpuVnVZM1JwYjI0Z2FXNXVaWEpQYXlobWJpd2dZWEpuVEdWdUxDQjJZV3gxWlN3Z2JXVnpjMkZuWlNrZ2UxeHVJQ0JwWmlBb0lYWmhiSFZsS1NCN1hHNGdJQ0FnZG1GeUlHZGxibVZ5WVhSbFpFMWxjM05oWjJVZ1BTQm1ZV3h6WlR0Y2JseHVJQ0FnSUdsbUlDaGhjbWRNWlc0Z1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUdkbGJtVnlZWFJsWkUxbGMzTmhaMlVnUFNCMGNuVmxPMXh1SUNBZ0lDQWdiV1Z6YzJGblpTQTlJQ2RPYnlCMllXeDFaU0JoY21kMWJXVnVkQ0J3WVhOelpXUWdkRzhnWUdGemMyVnlkQzV2YXlncFlDYzdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHRaWE56WVdkbElHbHVjM1JoYm1ObGIyWWdSWEp5YjNJcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUcxbGMzTmhaMlU3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdkbUZ5SUdWeWNpQTlJRzVsZHlCQmMzTmxjblJwYjI1RmNuSnZjaWg3WEc0Z0lDQWdJQ0JoWTNSMVlXdzZJSFpoYkhWbExGeHVJQ0FnSUNBZ1pYaHdaV04wWldRNklIUnlkV1VzWEc0Z0lDQWdJQ0J0WlhOellXZGxPaUJ0WlhOellXZGxMRnh1SUNBZ0lDQWdiM0JsY21GMGIzSTZJQ2M5UFNjc1hHNGdJQ0FnSUNCemRHRmphMU4wWVhKMFJtNDZJR1p1WEc0Z0lDQWdmU2s3WEc0Z0lDQWdaWEp5TG1kbGJtVnlZWFJsWkUxbGMzTmhaMlVnUFNCblpXNWxjbUYwWldSTlpYTnpZV2RsTzF4dUlDQWdJSFJvY205M0lHVnljanRjYmlBZ2ZWeHVmU0F2THlCUWRYSmxJR0Z6YzJWeWRHbHZiaUIwWlhOMGN5QjNhR1YwYUdWeUlHRWdkbUZzZFdVZ2FYTWdkSEoxZEdoNUxDQmhjeUJrWlhSbGNtMXBibVZrWEc0dkx5QmllU0FoSVhaaGJIVmxMbHh1WEc1Y2JtWjFibU4wYVc5dUlHOXJLQ2tnZTF4dUlDQm1iM0lnS0haaGNpQmZiR1Z1SUQwZ1lYSm5kVzFsYm5SekxteGxibWQwYUN3Z1lYSm5jeUE5SUc1bGR5QkJjbkpoZVNoZmJHVnVLU3dnWDJ0bGVTQTlJREE3SUY5clpYa2dQQ0JmYkdWdU95QmZhMlY1S3lzcElIdGNiaUFnSUNCaGNtZHpXMTlyWlhsZElEMGdZWEpuZFcxbGJuUnpXMTlyWlhsZE8xeHVJQ0I5WEc1Y2JpQWdhVzV1WlhKUGF5NWhjSEJzZVNoMmIybGtJREFzSUZ0dmF5d2dZWEpuY3k1c1pXNW5kR2hkTG1OdmJtTmhkQ2hoY21kektTazdYRzU5WEc1Y2JtRnpjMlZ5ZEM1dmF5QTlJRzlyT3lBdkx5QlVhR1VnWlhGMVlXeHBkSGtnWVhOelpYSjBhVzl1SUhSbGMzUnpJSE5vWVd4c2IzY3NJR052WlhKamFYWmxJR1Z4ZFdGc2FYUjVJSGRwZEdnZ1BUMHVYRzVjYmk4cUlHVnpiR2x1ZEMxa2FYTmhZbXhsSUc1dkxYSmxjM1J5YVdOMFpXUXRjSEp2Y0dWeWRHbGxjeUFxTDF4dVhHNWhjM05sY25RdVpYRjFZV3dnUFNCbWRXNWpkR2x2YmlCbGNYVmhiQ2hoWTNSMVlXd3NJR1Y0Y0dWamRHVmtMQ0J0WlhOellXZGxLU0I3WEc0Z0lHbG1JQ2hoY21kMWJXVnVkSE11YkdWdVozUm9JRHdnTWlrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCRlVsSmZUVWxUVTBsT1IxOUJVa2RUS0NkaFkzUjFZV3duTENBblpYaHdaV04wWldRbktUdGNiaUFnZlNBdkx5QmxjMnhwYm5RdFpHbHpZV0pzWlMxdVpYaDBMV3hwYm1VZ1pYRmxjV1Z4WEc1Y2JseHVJQ0JwWmlBb1lXTjBkV0ZzSUNFOUlHVjRjR1ZqZEdWa0tTQjdYRzRnSUNBZ2FXNXVaWEpHWVdsc0tIdGNiaUFnSUNBZ0lHRmpkSFZoYkRvZ1lXTjBkV0ZzTEZ4dUlDQWdJQ0FnWlhod1pXTjBaV1E2SUdWNGNHVmpkR1ZrTEZ4dUlDQWdJQ0FnYldWemMyRm5aVG9nYldWemMyRm5aU3hjYmlBZ0lDQWdJRzl3WlhKaGRHOXlPaUFuUFQwbkxGeHVJQ0FnSUNBZ2MzUmhZMnRUZEdGeWRFWnVPaUJsY1hWaGJGeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1OU95QXZMeUJVYUdVZ2JtOXVMV1Z4ZFdGc2FYUjVJR0Z6YzJWeWRHbHZiaUIwWlhOMGN5Qm1iM0lnZDJobGRHaGxjaUIwZDI4Z2IySnFaV04wY3lCaGNtVWdibTkwWEc0dkx5QmxjWFZoYkNCM2FYUm9JQ0U5TGx4dVhHNWNibUZ6YzJWeWRDNXViM1JGY1hWaGJDQTlJR1oxYm1OMGFXOXVJRzV2ZEVWeGRXRnNLR0ZqZEhWaGJDd2daWGh3WldOMFpXUXNJRzFsYzNOaFoyVXBJSHRjYmlBZ2FXWWdLR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ2dQQ0F5S1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWU1VsOU5TVk5UU1U1SFgwRlNSMU1vSjJGamRIVmhiQ2NzSUNkbGVIQmxZM1JsWkNjcE8xeHVJQ0I5SUM4dklHVnpiR2x1ZEMxa2FYTmhZbXhsTFc1bGVIUXRiR2x1WlNCbGNXVnhaWEZjYmx4dVhHNGdJR2xtSUNoaFkzUjFZV3dnUFQwZ1pYaHdaV04wWldRcElIdGNiaUFnSUNCcGJtNWxja1poYVd3b2UxeHVJQ0FnSUNBZ1lXTjBkV0ZzT2lCaFkzUjFZV3dzWEc0Z0lDQWdJQ0JsZUhCbFkzUmxaRG9nWlhod1pXTjBaV1FzWEc0Z0lDQWdJQ0J0WlhOellXZGxPaUJ0WlhOellXZGxMRnh1SUNBZ0lDQWdiM0JsY21GMGIzSTZJQ2NoUFNjc1hHNGdJQ0FnSUNCemRHRmphMU4wWVhKMFJtNDZJRzV2ZEVWeGRXRnNYRzRnSUNBZ2ZTazdYRzRnSUgxY2JuMDdJQzh2SUZSb1pTQmxjWFZwZG1Gc1pXNWpaU0JoYzNObGNuUnBiMjRnZEdWemRITWdZU0JrWldWd0lHVnhkV0ZzYVhSNUlISmxiR0YwYVc5dUxseHVYRzVjYm1GemMyVnlkQzVrWldWd1JYRjFZV3dnUFNCbWRXNWpkR2x2YmlCa1pXVndSWEYxWVd3b1lXTjBkV0ZzTENCbGVIQmxZM1JsWkN3Z2JXVnpjMkZuWlNrZ2UxeHVJQ0JwWmlBb1lYSm5kVzFsYm5SekxteGxibWQwYUNBOElESXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSVkpTWDAxSlUxTkpUa2RmUVZKSFV5Z25ZV04wZFdGc0p5d2dKMlY0Y0dWamRHVmtKeWs3WEc0Z0lIMWNibHh1SUNCcFppQW9hWE5FWldWd1JYRjFZV3dnUFQwOUlIVnVaR1ZtYVc1bFpDa2diR0Y2ZVV4dllXUkRiMjF3WVhKcGMyOXVLQ2s3WEc1Y2JpQWdhV1lnS0NGcGMwUmxaWEJGY1hWaGJDaGhZM1IxWVd3c0lHVjRjR1ZqZEdWa0tTa2dlMXh1SUNBZ0lHbHVibVZ5Um1GcGJDaDdYRzRnSUNBZ0lDQmhZM1IxWVd3NklHRmpkSFZoYkN4Y2JpQWdJQ0FnSUdWNGNHVmpkR1ZrT2lCbGVIQmxZM1JsWkN4Y2JpQWdJQ0FnSUcxbGMzTmhaMlU2SUcxbGMzTmhaMlVzWEc0Z0lDQWdJQ0J2Y0dWeVlYUnZjam9nSjJSbFpYQkZjWFZoYkNjc1hHNGdJQ0FnSUNCemRHRmphMU4wWVhKMFJtNDZJR1JsWlhCRmNYVmhiRnh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlPeUF2THlCVWFHVWdibTl1TFdWeGRXbDJZV3hsYm1ObElHRnpjMlZ5ZEdsdmJpQjBaWE4wY3lCbWIzSWdZVzU1SUdSbFpYQWdhVzVsY1hWaGJHbDBlUzVjYmx4dVhHNWhjM05sY25RdWJtOTBSR1ZsY0VWeGRXRnNJRDBnWm5WdVkzUnBiMjRnYm05MFJHVmxjRVZ4ZFdGc0tHRmpkSFZoYkN3Z1pYaHdaV04wWldRc0lHMWxjM05oWjJVcElIdGNiaUFnYVdZZ0tHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnZ1BDQXlLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZTVWw5TlNWTlRTVTVIWDBGU1IxTW9KMkZqZEhWaGJDY3NJQ2RsZUhCbFkzUmxaQ2NwTzF4dUlDQjlYRzVjYmlBZ2FXWWdLR2x6UkdWbGNFVnhkV0ZzSUQwOVBTQjFibVJsWm1sdVpXUXBJR3hoZW5sTWIyRmtRMjl0Y0dGeWFYTnZiaWdwTzF4dVhHNGdJR2xtSUNocGMwUmxaWEJGY1hWaGJDaGhZM1IxWVd3c0lHVjRjR1ZqZEdWa0tTa2dlMXh1SUNBZ0lHbHVibVZ5Um1GcGJDaDdYRzRnSUNBZ0lDQmhZM1IxWVd3NklHRmpkSFZoYkN4Y2JpQWdJQ0FnSUdWNGNHVmpkR1ZrT2lCbGVIQmxZM1JsWkN4Y2JpQWdJQ0FnSUcxbGMzTmhaMlU2SUcxbGMzTmhaMlVzWEc0Z0lDQWdJQ0J2Y0dWeVlYUnZjam9nSjI1dmRFUmxaWEJGY1hWaGJDY3NYRzRnSUNBZ0lDQnpkR0ZqYTFOMFlYSjBSbTQ2SUc1dmRFUmxaWEJGY1hWaGJGeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1OU8xeHVMeW9nWlhOc2FXNTBMV1Z1WVdKc1pTQXFMMXh1WEc1Y2JtRnpjMlZ5ZEM1a1pXVndVM1J5YVdOMFJYRjFZV3dnUFNCbWRXNWpkR2x2YmlCa1pXVndVM1J5YVdOMFJYRjFZV3dvWVdOMGRXRnNMQ0JsZUhCbFkzUmxaQ3dnYldWemMyRm5aU2tnZTF4dUlDQnBaaUFvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0E4SURJcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JWSlNYMDFKVTFOSlRrZGZRVkpIVXlnbllXTjBkV0ZzSnl3Z0oyVjRjR1ZqZEdWa0p5azdYRzRnSUgxY2JseHVJQ0JwWmlBb2FYTkVaV1Z3UlhGMVlXd2dQVDA5SUhWdVpHVm1hVzVsWkNrZ2JHRjZlVXh2WVdSRGIyMXdZWEpwYzI5dUtDazdYRzVjYmlBZ2FXWWdLQ0ZwYzBSbFpYQlRkSEpwWTNSRmNYVmhiQ2hoWTNSMVlXd3NJR1Y0Y0dWamRHVmtLU2tnZTF4dUlDQWdJR2x1Ym1WeVJtRnBiQ2g3WEc0Z0lDQWdJQ0JoWTNSMVlXdzZJR0ZqZEhWaGJDeGNiaUFnSUNBZ0lHVjRjR1ZqZEdWa09pQmxlSEJsWTNSbFpDeGNiaUFnSUNBZ0lHMWxjM05oWjJVNklHMWxjM05oWjJVc1hHNGdJQ0FnSUNCdmNHVnlZWFJ2Y2pvZ0oyUmxaWEJUZEhKcFkzUkZjWFZoYkNjc1hHNGdJQ0FnSUNCemRHRmphMU4wWVhKMFJtNDZJR1JsWlhCVGRISnBZM1JGY1hWaGJGeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1OU8xeHVYRzVoYzNObGNuUXVibTkwUkdWbGNGTjBjbWxqZEVWeGRXRnNJRDBnYm05MFJHVmxjRk4wY21samRFVnhkV0ZzTzF4dVhHNW1kVzVqZEdsdmJpQnViM1JFWldWd1UzUnlhV04wUlhGMVlXd29ZV04wZFdGc0xDQmxlSEJsWTNSbFpDd2diV1Z6YzJGblpTa2dlMXh1SUNCcFppQW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQThJRElwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlZKU1gwMUpVMU5KVGtkZlFWSkhVeWduWVdOMGRXRnNKeXdnSjJWNGNHVmpkR1ZrSnlrN1hHNGdJSDFjYmx4dUlDQnBaaUFvYVhORVpXVndSWEYxWVd3Z1BUMDlJSFZ1WkdWbWFXNWxaQ2tnYkdGNmVVeHZZV1JEYjIxd1lYSnBjMjl1S0NrN1hHNWNiaUFnYVdZZ0tHbHpSR1ZsY0ZOMGNtbGpkRVZ4ZFdGc0tHRmpkSFZoYkN3Z1pYaHdaV04wWldRcEtTQjdYRzRnSUNBZ2FXNXVaWEpHWVdsc0tIdGNiaUFnSUNBZ0lHRmpkSFZoYkRvZ1lXTjBkV0ZzTEZ4dUlDQWdJQ0FnWlhod1pXTjBaV1E2SUdWNGNHVmpkR1ZrTEZ4dUlDQWdJQ0FnYldWemMyRm5aVG9nYldWemMyRm5aU3hjYmlBZ0lDQWdJRzl3WlhKaGRHOXlPaUFuYm05MFJHVmxjRk4wY21samRFVnhkV0ZzSnl4Y2JpQWdJQ0FnSUhOMFlXTnJVM1JoY25SR2Jqb2dibTkwUkdWbGNGTjBjbWxqZEVWeGRXRnNYRzRnSUNBZ2ZTazdYRzRnSUgxY2JuMWNibHh1WVhOelpYSjBMbk4wY21samRFVnhkV0ZzSUQwZ1puVnVZM1JwYjI0Z2MzUnlhV04wUlhGMVlXd29ZV04wZFdGc0xDQmxlSEJsWTNSbFpDd2diV1Z6YzJGblpTa2dlMXh1SUNCcFppQW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQThJRElwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlZKU1gwMUpVMU5KVGtkZlFWSkhVeWduWVdOMGRXRnNKeXdnSjJWNGNHVmpkR1ZrSnlrN1hHNGdJSDFjYmx4dUlDQnBaaUFvSVc5aWFtVmpkRWx6S0dGamRIVmhiQ3dnWlhod1pXTjBaV1FwS1NCN1hHNGdJQ0FnYVc1dVpYSkdZV2xzS0h0Y2JpQWdJQ0FnSUdGamRIVmhiRG9nWVdOMGRXRnNMRnh1SUNBZ0lDQWdaWGh3WldOMFpXUTZJR1Y0Y0dWamRHVmtMRnh1SUNBZ0lDQWdiV1Z6YzJGblpUb2diV1Z6YzJGblpTeGNiaUFnSUNBZ0lHOXdaWEpoZEc5eU9pQW5jM1J5YVdOMFJYRjFZV3duTEZ4dUlDQWdJQ0FnYzNSaFkydFRkR0Z5ZEVadU9pQnpkSEpwWTNSRmNYVmhiRnh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlPMXh1WEc1aGMzTmxjblF1Ym05MFUzUnlhV04wUlhGMVlXd2dQU0JtZFc1amRHbHZiaUJ1YjNSVGRISnBZM1JGY1hWaGJDaGhZM1IxWVd3c0lHVjRjR1ZqZEdWa0xDQnRaWE56WVdkbEtTQjdYRzRnSUdsbUlDaGhjbWQxYldWdWRITXViR1Z1WjNSb0lEd2dNaWtnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJGVWxKZlRVbFRVMGxPUjE5QlVrZFRLQ2RoWTNSMVlXd25MQ0FuWlhod1pXTjBaV1FuS1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2h2WW1wbFkzUkpjeWhoWTNSMVlXd3NJR1Y0Y0dWamRHVmtLU2tnZTF4dUlDQWdJR2x1Ym1WeVJtRnBiQ2g3WEc0Z0lDQWdJQ0JoWTNSMVlXdzZJR0ZqZEhWaGJDeGNiaUFnSUNBZ0lHVjRjR1ZqZEdWa09pQmxlSEJsWTNSbFpDeGNiaUFnSUNBZ0lHMWxjM05oWjJVNklHMWxjM05oWjJVc1hHNGdJQ0FnSUNCdmNHVnlZWFJ2Y2pvZ0oyNXZkRk4wY21samRFVnhkV0ZzSnl4Y2JpQWdJQ0FnSUhOMFlXTnJVM1JoY25SR2Jqb2dibTkwVTNSeWFXTjBSWEYxWVd4Y2JpQWdJQ0I5S1R0Y2JpQWdmVnh1ZlR0Y2JseHVkbUZ5SUVOdmJYQmhjbWx6YjI0Z1BTQm1kVzVqZEdsdmJpQkRiMjF3WVhKcGMyOXVLRzlpYWl3Z2EyVjVjeXdnWVdOMGRXRnNLU0I3WEc0Z0lIWmhjaUJmZEdocGN5QTlJSFJvYVhNN1hHNWNiaUFnWDJOc1lYTnpRMkZzYkVOb1pXTnJLSFJvYVhNc0lFTnZiWEJoY21semIyNHBPMXh1WEc0Z0lHdGxlWE11Wm05eVJXRmphQ2htZFc1amRHbHZiaUFvYTJWNUtTQjdYRzRnSUNBZ2FXWWdLR3RsZVNCcGJpQnZZbW9wSUh0Y2JpQWdJQ0FnSUdsbUlDaGhZM1IxWVd3Z0lUMDlJSFZ1WkdWbWFXNWxaQ0FtSmlCMGVYQmxiMllnWVdOMGRXRnNXMnRsZVYwZ1BUMDlJQ2R6ZEhKcGJtY25JQ1ltSUdselVtVm5SWGh3S0c5aWFsdHJaWGxkS1NBbUppQnZZbXBiYTJWNVhTNTBaWE4wS0dGamRIVmhiRnRyWlhsZEtTa2dlMXh1SUNBZ0lDQWdJQ0JmZEdocGMxdHJaWGxkSUQwZ1lXTjBkV0ZzVzJ0bGVWMDdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQmZkR2hwYzF0clpYbGRJRDBnYjJKcVcydGxlVjA3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOUtUdGNibjA3WEc1Y2JtWjFibU4wYVc5dUlHTnZiWEJoY21WRmVHTmxjSFJwYjI1TFpYa29ZV04wZFdGc0xDQmxlSEJsWTNSbFpDd2dhMlY1TENCdFpYTnpZV2RsTENCclpYbHpMQ0JtYmlrZ2UxeHVJQ0JwWmlBb0lTaHJaWGtnYVc0Z1lXTjBkV0ZzS1NCOGZDQWhhWE5FWldWd1UzUnlhV04wUlhGMVlXd29ZV04wZFdGc1cydGxlVjBzSUdWNGNHVmpkR1ZrVzJ0bGVWMHBLU0I3WEc0Z0lDQWdhV1lnS0NGdFpYTnpZV2RsS1NCN1hHNGdJQ0FnSUNBdkx5QkRjbVZoZEdVZ2NHeGhZMlZvYjJ4a1pYSWdiMkpxWldOMGN5QjBieUJqY21WaGRHVWdZU0J1YVdObElHOTFkSEIxZEM1Y2JpQWdJQ0FnSUhaaGNpQmhJRDBnYm1WM0lFTnZiWEJoY21semIyNG9ZV04wZFdGc0xDQnJaWGx6S1R0Y2JpQWdJQ0FnSUhaaGNpQmlJRDBnYm1WM0lFTnZiWEJoY21semIyNG9aWGh3WldOMFpXUXNJR3RsZVhNc0lHRmpkSFZoYkNrN1hHNGdJQ0FnSUNCMllYSWdaWEp5SUQwZ2JtVjNJRUZ6YzJWeWRHbHZia1Z5Y205eUtIdGNiaUFnSUNBZ0lDQWdZV04wZFdGc09pQmhMRnh1SUNBZ0lDQWdJQ0JsZUhCbFkzUmxaRG9nWWl4Y2JpQWdJQ0FnSUNBZ2IzQmxjbUYwYjNJNklDZGtaV1Z3VTNSeWFXTjBSWEYxWVd3bkxGeHVJQ0FnSUNBZ0lDQnpkR0ZqYTFOMFlYSjBSbTQ2SUdadVhHNGdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lHVnljaTVoWTNSMVlXd2dQU0JoWTNSMVlXdzdYRzRnSUNBZ0lDQmxjbkl1Wlhod1pXTjBaV1FnUFNCbGVIQmxZM1JsWkR0Y2JpQWdJQ0FnSUdWeWNpNXZjR1Z5WVhSdmNpQTlJR1p1TG01aGJXVTdYRzRnSUNBZ0lDQjBhSEp2ZHlCbGNuSTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXNXVaWEpHWVdsc0tIdGNiaUFnSUNBZ0lHRmpkSFZoYkRvZ1lXTjBkV0ZzTEZ4dUlDQWdJQ0FnWlhod1pXTjBaV1E2SUdWNGNHVmpkR1ZrTEZ4dUlDQWdJQ0FnYldWemMyRm5aVG9nYldWemMyRm5aU3hjYmlBZ0lDQWdJRzl3WlhKaGRHOXlPaUJtYmk1dVlXMWxMRnh1SUNBZ0lDQWdjM1JoWTJ0VGRHRnlkRVp1T2lCbWJseHVJQ0FnSUgwcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1Y0Y0dWamRHVmtSWGhqWlhCMGFXOXVLR0ZqZEhWaGJDd2daWGh3WldOMFpXUXNJRzF6Wnl3Z1ptNHBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQmxlSEJsWTNSbFpDQWhQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUdsbUlDaHBjMUpsWjBWNGNDaGxlSEJsWTNSbFpDa3BJSEpsZEhWeWJpQmxlSEJsWTNSbFpDNTBaWE4wS0dGamRIVmhiQ2s3SUM4dklHRnpjMlZ5ZEM1a2IyVnpUbTkwVkdoeWIzY2daRzlsY3lCdWIzUWdZV05qWlhCMElHOWlhbVZqZEhNdVhHNWNiaUFnSUNCcFppQW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQTlQVDBnTWlrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVlNVbDlKVGxaQlRFbEVYMEZTUjE5VVdWQkZLQ2RsZUhCbFkzUmxaQ2NzSUZzblJuVnVZM1JwYjI0bkxDQW5VbVZuUlhod0oxMHNJR1Y0Y0dWamRHVmtLVHRjYmlBZ0lDQjlJQzh2SUVoaGJtUnNaU0J3Y21sdGFYUnBkbVZ6SUhCeWIzQmxjbXg1TGx4dVhHNWNiaUFnSUNCcFppQW9YM1I1Y0dWdlppaGhZM1IxWVd3cElDRTlQU0FuYjJKcVpXTjBKeUI4ZkNCaFkzUjFZV3dnUFQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUhaaGNpQmxjbklnUFNCdVpYY2dRWE56WlhKMGFXOXVSWEp5YjNJb2UxeHVJQ0FnSUNBZ0lDQmhZM1IxWVd3NklHRmpkSFZoYkN4Y2JpQWdJQ0FnSUNBZ1pYaHdaV04wWldRNklHVjRjR1ZqZEdWa0xGeHVJQ0FnSUNBZ0lDQnRaWE56WVdkbE9pQnRjMmNzWEc0Z0lDQWdJQ0FnSUc5d1pYSmhkRzl5T2lBblpHVmxjRk4wY21samRFVnhkV0ZzSnl4Y2JpQWdJQ0FnSUNBZ2MzUmhZMnRUZEdGeWRFWnVPaUJtYmx4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNCbGNuSXViM0JsY21GMGIzSWdQU0JtYmk1dVlXMWxPMXh1SUNBZ0lDQWdkR2h5YjNjZ1pYSnlPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIWmhjaUJyWlhseklEMGdUMkpxWldOMExtdGxlWE1vWlhod1pXTjBaV1FwT3lBdkx5QlRjR1ZqYVdGc0lHaGhibVJzWlNCbGNuSnZjbk1nZEc4Z2JXRnJaU0J6ZFhKbElIUm9aU0J1WVcxbElHRnVaQ0IwYUdVZ2JXVnpjMkZuWlNCaGNtVWdZMjl0Y0dGeVpXUmNiaUFnSUNBdkx5QmhjeUIzWld4c0xseHVYRzRnSUNBZ2FXWWdLR1Y0Y0dWamRHVmtJR2x1YzNSaGJtTmxiMllnUlhKeWIzSXBJSHRjYmlBZ0lDQWdJR3RsZVhNdWNIVnphQ2duYm1GdFpTY3NJQ2R0WlhOellXZGxKeWs3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2hyWlhsekxteGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWU1VsOUpUbFpCVEVsRVgwRlNSMTlXUVV4VlJTZ25aWEp5YjNJbkxDQmxlSEJsWTNSbFpDd2dKMjFoZVNCdWIzUWdZbVVnWVc0Z1pXMXdkSGtnYjJKcVpXTjBKeWs3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdhV1lnS0dselJHVmxjRVZ4ZFdGc0lEMDlQU0IxYm1SbFptbHVaV1FwSUd4aGVubE1iMkZrUTI5dGNHRnlhWE52YmlncE8xeHVJQ0FnSUd0bGVYTXVabTl5UldGamFDaG1kVzVqZEdsdmJpQW9hMlY1S1NCN1hHNGdJQ0FnSUNCcFppQW9kSGx3Wlc5bUlHRmpkSFZoYkZ0clpYbGRJRDA5UFNBbmMzUnlhVzVuSnlBbUppQnBjMUpsWjBWNGNDaGxlSEJsWTNSbFpGdHJaWGxkS1NBbUppQmxlSEJsWTNSbFpGdHJaWGxkTG5SbGMzUW9ZV04wZFdGc1cydGxlVjBwS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ1kyOXRjR0Z5WlVWNFkyVndkR2x2Ymt0bGVTaGhZM1IxWVd3c0lHVjRjR1ZqZEdWa0xDQnJaWGtzSUcxelp5d2dhMlY1Y3l3Z1ptNHBPMXh1SUNBZ0lIMHBPMXh1SUNBZ0lISmxkSFZ5YmlCMGNuVmxPMXh1SUNCOUlDOHZJRWQxWVhKa0lHbHVjM1JoYm1ObGIyWWdZV2RoYVc1emRDQmhjbkp2ZHlCbWRXNWpkR2x2Ym5NZ1lYTWdkR2hsZVNCa2IyNG5kQ0JvWVhabElHRWdjSEp2ZEc5MGVYQmxMbHh1WEc1Y2JpQWdhV1lnS0dWNGNHVmpkR1ZrTG5CeWIzUnZkSGx3WlNBaFBUMGdkVzVrWldacGJtVmtJQ1ltSUdGamRIVmhiQ0JwYm5OMFlXNWpaVzltSUdWNGNHVmpkR1ZrS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJSDFjYmx4dUlDQnBaaUFvUlhKeWIzSXVhWE5RY205MGIzUjVjR1ZQWmlobGVIQmxZM1JsWkNrcElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdaWGh3WldOMFpXUXVZMkZzYkNoN2ZTd2dZV04wZFdGc0tTQTlQVDBnZEhKMVpUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1oyVjBRV04wZFdGc0tHWnVLU0I3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdabTRnSVQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSVkpTWDBsT1ZrRk1TVVJmUVZKSFgxUlpVRVVvSjJadUp5d2dKMFoxYm1OMGFXOXVKeXdnWm00cE8xeHVJQ0I5WEc1Y2JpQWdkSEo1SUh0Y2JpQWdJQ0JtYmlncE8xeHVJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1U3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnVGs5ZlJWaERSVkJVU1U5T1gxTkZUbFJKVGtWTU8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCamFHVmphMGx6VUhKdmJXbHpaU2h2WW1vcElIdGNiaUFnTHk4Z1FXTmpaWEIwSUc1aGRHbDJaU0JGVXpZZ2NISnZiV2x6WlhNZ1lXNWtJSEJ5YjIxcGMyVnpJSFJvWVhRZ1lYSmxJR2x0Y0d4bGJXVnVkR1ZrSUdsdUlHRWdjMmx0YVd4aGNseHVJQ0F2THlCM1lYa3VJRVJ2SUc1dmRDQmhZMk5sY0hRZ2RHaGxibUZpYkdWeklIUm9ZWFFnZFhObElHRWdablZ1WTNScGIyNGdZWE1nWUc5aWFtQWdZVzVrSUhSb1lYUWdhR0YyWlNCdWIxeHVJQ0F2THlCZ1kyRjBZMmhnSUdoaGJtUnNaWEl1WEc0Z0lDOHZJRlJQUkU4NklIUm9aVzVoWW14bGN5QmhjbVVnWTJobFkydGxaQ0IxY0NCMWJuUnBiQ0IwYUdWNUlHaGhkbVVnZEdobElHTnZjbkpsWTNRZ2JXVjBhRzlrY3l4Y2JpQWdMeThnWW5WMElHRmpZMjl5WkdsdVp5QjBieUJrYjJOMWJXVnVkR0YwYVc5dUxDQjBhR1VnWUhSb1pXNWdJRzFsZEdodlpDQnphRzkxYkdRZ2NtVmpaV2wyWlZ4dUlDQXZMeUIwYUdVZ1lHWjFiR1pwYkd4Z0lHRnVaQ0JnY21WcVpXTjBZQ0JoY21kMWJXVnVkSE1nWVhNZ2QyVnNiQ0J2Y2lCcGRDQnRZWGtnWW1VZ2JtVjJaWElnY21WemIyeDJaV1F1WEc0Z0lISmxkSFZ5YmlCcGMxQnliMjFwYzJVb2IySnFLU0I4ZkNCdlltb2dJVDA5SUc1MWJHd2dKaVlnWDNSNWNHVnZaaWh2WW1vcElEMDlQU0FuYjJKcVpXTjBKeUFtSmlCMGVYQmxiMllnYjJKcUxuUm9aVzRnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVlnZEhsd1pXOW1JRzlpYWk1allYUmphQ0E5UFQwZ0oyWjFibU4wYVc5dUp6dGNibjFjYmx4dVpuVnVZM1JwYjI0Z2QyRnBkRVp2Y2tGamRIVmhiQ2h3Y205dGFYTmxSbTRwSUh0Y2JpQWdjbVYwZFhKdUlGQnliMjFwYzJVdWNtVnpiMngyWlNncExuUm9aVzRvWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUhaaGNpQnlaWE4xYkhSUWNtOXRhWE5sTzF4dVhHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCd2NtOXRhWE5sUm00Z1BUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUM4dklGSmxkSFZ5YmlCaElISmxhbVZqZEdWa0lIQnliMjFwYzJVZ2FXWWdZSEJ5YjIxcGMyVkdibUFnZEdoeWIzZHpJSE41Ym1Ob2NtOXViM1Z6YkhrdVhHNGdJQ0FnSUNCeVpYTjFiSFJRY205dGFYTmxJRDBnY0hKdmJXbHpaVVp1S0NrN0lDOHZJRVpoYVd3Z2FXNGdZMkZ6WlNCdWJ5QndjbTl0YVhObElHbHpJSEpsZEhWeWJtVmtMbHh1WEc0Z0lDQWdJQ0JwWmlBb0lXTm9aV05yU1hOUWNtOXRhWE5sS0hKbGMzVnNkRkJ5YjIxcGMyVXBLU0I3WEc0Z0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRlVsSmZTVTVXUVV4SlJGOVNSVlJWVWs1ZlZrRk1WVVVvSjJsdWMzUmhibU5sSUc5bUlGQnliMjFwYzJVbkxDQW5jSEp2YldselpVWnVKeXdnY21WemRXeDBVSEp2YldselpTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaGphR1ZqYTBselVISnZiV2x6WlNod2NtOXRhWE5sUm00cEtTQjdYRzRnSUNBZ0lDQnlaWE4xYkhSUWNtOXRhWE5sSUQwZ2NISnZiV2x6WlVadU8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlZKU1gwbE9Wa0ZNU1VSZlFWSkhYMVJaVUVVb0ozQnliMjFwYzJWR2JpY3NJRnNuUm5WdVkzUnBiMjRuTENBblVISnZiV2x6WlNkZExDQndjbTl0YVhObFJtNHBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkSFZ5YmlCUWNtOXRhWE5sTG5KbGMyOXNkbVVvS1M1MGFHVnVLR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ5WlhOMWJIUlFjbTl0YVhObE8xeHVJQ0FnSUgwcExuUm9aVzRvWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUU1UFgwVllRMFZRVkVsUFRsOVRSVTVVU1U1RlREdGNiaUFnSUNCOUtTNWpZWFJqYUNobWRXNWpkR2x2YmlBb1pTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHVTdYRzRnSUNBZ2ZTazdYRzRnSUgwcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCbGVIQmxZM1J6UlhKeWIzSW9jM1JoWTJ0VGRHRnlkRVp1TENCaFkzUjFZV3dzSUdWeWNtOXlMQ0J0WlhOellXZGxLU0I3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdaWEp5YjNJZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdhV1lnS0dGeVozVnRaVzUwY3k1c1pXNW5kR2dnUFQwOUlEUXBJSHRjYmlBZ0lDQWdJSFJvY205M0lHNWxkeUJGVWxKZlNVNVdRVXhKUkY5QlVrZGZWRmxRUlNnblpYSnliM0luTENCYkowOWlhbVZqZENjc0lDZEZjbkp2Y2ljc0lDZEdkVzVqZEdsdmJpY3NJQ2RTWldkRmVIQW5YU3dnWlhKeWIzSXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2hmZEhsd1pXOW1LR0ZqZEhWaGJDa2dQVDA5SUNkdlltcGxZM1FuSUNZbUlHRmpkSFZoYkNBaFBUMGdiblZzYkNrZ2UxeHVJQ0FnSUNBZ2FXWWdLR0ZqZEhWaGJDNXRaWE56WVdkbElEMDlQU0JsY25KdmNpa2dlMXh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlZKU1gwRk5Ra2xIVlU5VlUxOUJVa2RWVFVWT1ZDZ25aWEp5YjNJdmJXVnpjMkZuWlNjc0lGd2lWR2hsSUdWeWNtOXlJRzFsYzNOaFoyVWdYRnhjSWx3aUxtTnZibU5oZENoaFkzUjFZV3d1YldWemMyRm5aU3dnWENKY1hGd2lJR2x6SUdsa1pXNTBhV05oYkNCMGJ5QjBhR1VnYldWemMyRm5aUzVjSWlrcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1lXTjBkV0ZzSUQwOVBTQmxjbkp2Y2lrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVlNVbDlCVFVKSlIxVlBWVk5mUVZKSFZVMUZUbFFvSjJWeWNtOXlMMjFsYzNOaFoyVW5MQ0JjSWxSb1pTQmxjbkp2Y2lCY1hGd2lYQ0l1WTI5dVkyRjBLR0ZqZEhWaGJDd2dYQ0pjWEZ3aUlHbHpJR2xrWlc1MGFXTmhiQ0IwYnlCMGFHVWdiV1Z6YzJGblpTNWNJaWtwTzF4dUlDQWdJSDFjYmx4dUlDQWdJRzFsYzNOaFoyVWdQU0JsY25KdmNqdGNiaUFnSUNCbGNuSnZjaUE5SUhWdVpHVm1hVzVsWkR0Y2JpQWdmU0JsYkhObElHbG1JQ2hsY25KdmNpQWhQU0J1ZFd4c0lDWW1JRjkwZVhCbGIyWW9aWEp5YjNJcElDRTlQU0FuYjJKcVpXTjBKeUFtSmlCMGVYQmxiMllnWlhKeWIzSWdJVDA5SUNkbWRXNWpkR2x2YmljcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JWSlNYMGxPVmtGTVNVUmZRVkpIWDFSWlVFVW9KMlZ5Y205eUp5d2dXeWRQWW1wbFkzUW5MQ0FuUlhKeWIzSW5MQ0FuUm5WdVkzUnBiMjRuTENBblVtVm5SWGh3SjEwc0lHVnljbTl5S1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2hoWTNSMVlXd2dQVDA5SUU1UFgwVllRMFZRVkVsUFRsOVRSVTVVU1U1RlRDa2dlMXh1SUNBZ0lIWmhjaUJrWlhSaGFXeHpJRDBnSnljN1hHNWNiaUFnSUNCcFppQW9aWEp5YjNJZ0ppWWdaWEp5YjNJdWJtRnRaU2tnZTF4dUlDQWdJQ0FnWkdWMFlXbHNjeUFyUFNCY0lpQW9YQ0l1WTI5dVkyRjBLR1Z5Y205eUxtNWhiV1VzSUZ3aUtWd2lLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQmtaWFJoYVd4eklDczlJRzFsYzNOaFoyVWdQeUJjSWpvZ1hDSXVZMjl1WTJGMEtHMWxjM05oWjJVcElEb2dKeTRuTzF4dUlDQWdJSFpoY2lCbWJsUjVjR1VnUFNCemRHRmphMU4wWVhKMFJtNHVibUZ0WlNBOVBUMGdKM0psYW1WamRITW5JRDhnSjNKbGFtVmpkR2x2YmljZ09pQW5aWGhqWlhCMGFXOXVKenRjYmlBZ0lDQnBibTVsY2taaGFXd29lMXh1SUNBZ0lDQWdZV04wZFdGc09pQjFibVJsWm1sdVpXUXNYRzRnSUNBZ0lDQmxlSEJsWTNSbFpEb2daWEp5YjNJc1hHNGdJQ0FnSUNCdmNHVnlZWFJ2Y2pvZ2MzUmhZMnRUZEdGeWRFWnVMbTVoYldVc1hHNGdJQ0FnSUNCdFpYTnpZV2RsT2lCY0lrMXBjM05wYm1jZ1pYaHdaV04wWldRZ1hDSXVZMjl1WTJGMEtHWnVWSGx3WlNrdVkyOXVZMkYwS0dSbGRHRnBiSE1wTEZ4dUlDQWdJQ0FnYzNSaFkydFRkR0Z5ZEVadU9pQnpkR0ZqYTFOMFlYSjBSbTVjYmlBZ0lDQjlLVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaGxjbkp2Y2lBbUppQWhaWGh3WldOMFpXUkZlR05sY0hScGIyNG9ZV04wZFdGc0xDQmxjbkp2Y2l3Z2JXVnpjMkZuWlN3Z2MzUmhZMnRUZEdGeWRFWnVLU2tnZTF4dUlDQWdJSFJvY205M0lHRmpkSFZoYkR0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmxlSEJsWTNSelRtOUZjbkp2Y2loemRHRmphMU4wWVhKMFJtNHNJR0ZqZEhWaGJDd2daWEp5YjNJc0lHMWxjM05oWjJVcElIdGNiaUFnYVdZZ0tHRmpkSFZoYkNBOVBUMGdUazlmUlZoRFJWQlVTVTlPWDFORlRsUkpUa1ZNS1NCeVpYUjFjbTQ3WEc1Y2JpQWdhV1lnS0hSNWNHVnZaaUJsY25KdmNpQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0J0WlhOellXZGxJRDBnWlhKeWIzSTdYRzRnSUNBZ1pYSnliM0lnUFNCMWJtUmxabWx1WldRN1hHNGdJSDFjYmx4dUlDQnBaaUFvSVdWeWNtOXlJSHg4SUdWNGNHVmpkR1ZrUlhoalpYQjBhVzl1S0dGamRIVmhiQ3dnWlhKeWIzSXBLU0I3WEc0Z0lDQWdkbUZ5SUdSbGRHRnBiSE1nUFNCdFpYTnpZV2RsSUQ4Z1hDSTZJRndpTG1OdmJtTmhkQ2h0WlhOellXZGxLU0E2SUNjdUp6dGNiaUFnSUNCMllYSWdabTVVZVhCbElEMGdjM1JoWTJ0VGRHRnlkRVp1TG01aGJXVWdQVDA5SUNka2IyVnpUbTkwVW1WcVpXTjBKeUEvSUNkeVpXcGxZM1JwYjI0bklEb2dKMlY0WTJWd2RHbHZiaWM3WEc0Z0lDQWdhVzV1WlhKR1lXbHNLSHRjYmlBZ0lDQWdJR0ZqZEhWaGJEb2dZV04wZFdGc0xGeHVJQ0FnSUNBZ1pYaHdaV04wWldRNklHVnljbTl5TEZ4dUlDQWdJQ0FnYjNCbGNtRjBiM0k2SUhOMFlXTnJVM1JoY25SR2JpNXVZVzFsTEZ4dUlDQWdJQ0FnYldWemMyRm5aVG9nWENKSGIzUWdkVzUzWVc1MFpXUWdYQ0l1WTI5dVkyRjBLR1p1Vkhsd1pTa3VZMjl1WTJGMEtHUmxkR0ZwYkhNc0lGd2lYRnh1WENJcElDc2dYQ0pCWTNSMVlXd2diV1Z6YzJGblpUb2dYRnhjSWx3aUxtTnZibU5oZENoaFkzUjFZV3dnSmlZZ1lXTjBkV0ZzTG0xbGMzTmhaMlVzSUZ3aVhGeGNJbHdpS1N4Y2JpQWdJQ0FnSUhOMFlXTnJVM1JoY25SR2Jqb2djM1JoWTJ0VGRHRnlkRVp1WEc0Z0lDQWdmU2s3WEc0Z0lIMWNibHh1SUNCMGFISnZkeUJoWTNSMVlXdzdYRzU5WEc1Y2JtRnpjMlZ5ZEM1MGFISnZkM01nUFNCbWRXNWpkR2x2YmlCMGFISnZkM01vY0hKdmJXbHpaVVp1S1NCN1hHNGdJR1p2Y2lBb2RtRnlJRjlzWlc0eUlEMGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFDd2dZWEpuY3lBOUlHNWxkeUJCY25KaGVTaGZiR1Z1TWlBK0lERWdQeUJmYkdWdU1pQXRJREVnT2lBd0tTd2dYMnRsZVRJZ1BTQXhPeUJmYTJWNU1pQThJRjlzWlc0eU95QmZhMlY1TWlzcktTQjdYRzRnSUNBZ1lYSm5jMXRmYTJWNU1pQXRJREZkSUQwZ1lYSm5kVzFsYm5SelcxOXJaWGt5WFR0Y2JpQWdmVnh1WEc0Z0lHVjRjR1ZqZEhORmNuSnZjaTVoY0hCc2VTaDJiMmxrSURBc0lGdDBhSEp2ZDNNc0lHZGxkRUZqZEhWaGJDaHdjbTl0YVhObFJtNHBYUzVqYjI1allYUW9ZWEpuY3lrcE8xeHVmVHRjYmx4dVlYTnpaWEowTG5KbGFtVmpkSE1nUFNCbWRXNWpkR2x2YmlCeVpXcGxZM1J6S0hCeWIyMXBjMlZHYmlrZ2UxeHVJQ0JtYjNJZ0tIWmhjaUJmYkdWdU15QTlJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ3NJR0Z5WjNNZ1BTQnVaWGNnUVhKeVlYa29YMnhsYmpNZ1BpQXhJRDhnWDJ4bGJqTWdMU0F4SURvZ01Da3NJRjlyWlhreklEMGdNVHNnWDJ0bGVUTWdQQ0JmYkdWdU16c2dYMnRsZVRNckt5a2dlMXh1SUNBZ0lHRnlaM05iWDJ0bGVUTWdMU0F4WFNBOUlHRnlaM1Z0Wlc1MGMxdGZhMlY1TTEwN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2QyRnBkRVp2Y2tGamRIVmhiQ2h3Y205dGFYTmxSbTRwTG5Sb1pXNG9ablZ1WTNScGIyNGdLSEpsYzNWc2RDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbGVIQmxZM1J6UlhKeWIzSXVZWEJ3Ykhrb2RtOXBaQ0F3TENCYmNtVnFaV04wY3l3Z2NtVnpkV3gwWFM1amIyNWpZWFFvWVhKbmN5a3BPMXh1SUNCOUtUdGNibjA3WEc1Y2JtRnpjMlZ5ZEM1a2IyVnpUbTkwVkdoeWIzY2dQU0JtZFc1amRHbHZiaUJrYjJWelRtOTBWR2h5YjNjb1ptNHBJSHRjYmlBZ1ptOXlJQ2gyWVhJZ1gyeGxialFnUFNCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvTENCaGNtZHpJRDBnYm1WM0lFRnljbUY1S0Y5c1pXNDBJRDRnTVNBL0lGOXNaVzQwSUMwZ01TQTZJREFwTENCZmEyVjVOQ0E5SURFN0lGOXJaWGswSUR3Z1gyeGxialE3SUY5clpYazBLeXNwSUh0Y2JpQWdJQ0JoY21kelcxOXJaWGswSUMwZ01WMGdQU0JoY21kMWJXVnVkSE5iWDJ0bGVUUmRPMXh1SUNCOVhHNWNiaUFnWlhod1pXTjBjMDV2UlhKeWIzSXVZWEJ3Ykhrb2RtOXBaQ0F3TENCYlpHOWxjMDV2ZEZSb2NtOTNMQ0JuWlhSQlkzUjFZV3dvWm00cFhTNWpiMjVqWVhRb1lYSm5jeWtwTzF4dWZUdGNibHh1WVhOelpYSjBMbVJ2WlhOT2IzUlNaV3BsWTNRZ1BTQm1kVzVqZEdsdmJpQmtiMlZ6VG05MFVtVnFaV04wS0dadUtTQjdYRzRnSUdadmNpQW9kbUZ5SUY5c1pXNDFJRDBnWVhKbmRXMWxiblJ6TG14bGJtZDBhQ3dnWVhKbmN5QTlJRzVsZHlCQmNuSmhlU2hmYkdWdU5TQStJREVnUHlCZmJHVnVOU0F0SURFZ09pQXdLU3dnWDJ0bGVUVWdQU0F4T3lCZmEyVjVOU0E4SUY5c1pXNDFPeUJmYTJWNU5Tc3JLU0I3WEc0Z0lDQWdZWEpuYzF0ZmEyVjVOU0F0SURGZElEMGdZWEpuZFcxbGJuUnpXMTlyWlhrMVhUdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjNZV2wwUm05eVFXTjBkV0ZzS0dadUtTNTBhR1Z1S0daMWJtTjBhVzl1SUNoeVpYTjFiSFFwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdaWGh3WldOMGMwNXZSWEp5YjNJdVlYQndiSGtvZG05cFpDQXdMQ0JiWkc5bGMwNXZkRkpsYW1WamRDd2djbVZ6ZFd4MFhTNWpiMjVqWVhRb1lYSm5jeWtwTzF4dUlDQjlLVHRjYm4wN1hHNWNibUZ6YzJWeWRDNXBaa1Z5Y205eUlEMGdablZ1WTNScGIyNGdhV1pGY25KdmNpaGxjbklwSUh0Y2JpQWdhV1lnS0dWeWNpQWhQVDBnYm5Wc2JDQW1KaUJsY25JZ0lUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJSFpoY2lCdFpYTnpZV2RsSUQwZ0oybG1SWEp5YjNJZ1oyOTBJSFZ1ZDJGdWRHVmtJR1Y0WTJWd2RHbHZiam9nSnp0Y2JseHVJQ0FnSUdsbUlDaGZkSGx3Wlc5bUtHVnljaWtnUFQwOUlDZHZZbXBsWTNRbklDWW1JSFI1Y0dWdlppQmxjbkl1YldWemMyRm5aU0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNBZ0lHbG1JQ2hsY25JdWJXVnpjMkZuWlM1c1pXNW5kR2dnUFQwOUlEQWdKaVlnWlhKeUxtTnZibk4wY25WamRHOXlLU0I3WEc0Z0lDQWdJQ0FnSUcxbGMzTmhaMlVnS3owZ1pYSnlMbU52Ym5OMGNuVmpkRzl5TG01aGJXVTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQnRaWE56WVdkbElDczlJR1Z5Y2k1dFpYTnpZV2RsTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnRaWE56WVdkbElDczlJR2x1YzNCbFkzUW9aWEp5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0IyWVhJZ2JtVjNSWEp5SUQwZ2JtVjNJRUZ6YzJWeWRHbHZia1Z5Y205eUtIdGNiaUFnSUNBZ0lHRmpkSFZoYkRvZ1pYSnlMRnh1SUNBZ0lDQWdaWGh3WldOMFpXUTZJRzUxYkd3c1hHNGdJQ0FnSUNCdmNHVnlZWFJ2Y2pvZ0oybG1SWEp5YjNJbkxGeHVJQ0FnSUNBZ2JXVnpjMkZuWlRvZ2JXVnpjMkZuWlN4Y2JpQWdJQ0FnSUhOMFlXTnJVM1JoY25SR2Jqb2dhV1pGY25KdmNseHVJQ0FnSUgwcE95QXZMeUJOWVd0bElITjFjbVVnZDJVZ1lXTjBkV0ZzYkhrZ2FHRjJaU0JoSUhOMFlXTnJJSFJ5WVdObElWeHVYRzRnSUNBZ2RtRnlJRzl5YVdkVGRHRmpheUE5SUdWeWNpNXpkR0ZqYXp0Y2JseHVJQ0FnSUdsbUlDaDBlWEJsYjJZZ2IzSnBaMU4wWVdOcklEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJQ0FnTHk4Z1ZHaHBjeUIzYVd4c0lISmxiVzkyWlNCaGJua2daSFZ3YkdsallYUmxaQ0JtY21GdFpYTWdabkp2YlNCMGFHVWdaWEp5YjNJZ1puSmhiV1Z6SUhSaGEyVnVYRzRnSUNBZ0lDQXZMeUJtY205dElIZHBkR2hwYmlCZ2FXWkZjbkp2Y21BZ1lXNWtJR0ZrWkNCMGFHVWdiM0pwWjJsdVlXd2daWEp5YjNJZ1puSmhiV1Z6SUhSdklIUm9aU0J1Wlhkc2VWeHVJQ0FnSUNBZ0x5OGdZM0psWVhSbFpDQnZibVZ6TGx4dUlDQWdJQ0FnZG1GeUlIUnRjRElnUFNCdmNtbG5VM1JoWTJzdWMzQnNhWFFvSjF4Y2JpY3BPMXh1SUNBZ0lDQWdkRzF3TWk1emFHbG1kQ2dwT3lBdkx5QkdhV3gwWlhJZ1lXeHNJR1p5WVcxbGN5QmxlR2x6ZEdsdVp5QnBiaUJsY25JdWMzUmhZMnN1WEc1Y2JpQWdJQ0FnSUhaaGNpQjBiWEF4SUQwZ2JtVjNSWEp5TG5OMFlXTnJMbk53YkdsMEtDZGNYRzRuS1R0Y2JseHVJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQjBiWEF5TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJQzh2SUVacGJtUWdkR2hsSUdacGNuTjBJRzlqWTNWeWNtVnVZMlVnYjJZZ2RHaGxJR1p5WVcxbExseHVJQ0FnSUNBZ0lDQjJZWElnY0c5eklEMGdkRzF3TVM1cGJtUmxlRTltS0hSdGNESmJhVjBwTzF4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2h3YjNNZ0lUMDlJQzB4S1NCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnVDI1c2VTQnJaV1Z3SUc1bGR5Qm1jbUZ0WlhNdVhHNGdJQ0FnSUNBZ0lDQWdkRzF3TVNBOUlIUnRjREV1YzJ4cFkyVW9NQ3dnY0c5ektUdGNiaUFnSUNBZ0lDQWdJQ0JpY21WaGF6dGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J1WlhkRmNuSXVjM1JoWTJzZ1BTQmNJbHdpTG1OdmJtTmhkQ2gwYlhBeExtcHZhVzRvSjF4Y2JpY3BMQ0JjSWx4Y2Jsd2lLUzVqYjI1allYUW9kRzF3TWk1cWIybHVLQ2RjWEc0bktTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2RHaHliM2NnYm1WM1JYSnlPMXh1SUNCOVhHNTlPeUF2THlCRmVIQnZjMlVnWVNCemRISnBZM1FnYjI1c2VTQjJZWEpwWVc1MElHOW1JR0Z6YzJWeWRGeHVYRzVjYm1aMWJtTjBhVzl1SUhOMGNtbGpkQ2dwSUh0Y2JpQWdabTl5SUNoMllYSWdYMnhsYmpZZ1BTQmhjbWQxYldWdWRITXViR1Z1WjNSb0xDQmhjbWR6SUQwZ2JtVjNJRUZ5Y21GNUtGOXNaVzQyS1N3Z1gydGxlVFlnUFNBd095QmZhMlY1TmlBOElGOXNaVzQyT3lCZmEyVjVOaXNyS1NCN1hHNGdJQ0FnWVhKbmMxdGZhMlY1TmwwZ1BTQmhjbWQxYldWdWRITmJYMnRsZVRaZE8xeHVJQ0I5WEc1Y2JpQWdhVzV1WlhKUGF5NWhjSEJzZVNoMmIybGtJREFzSUZ0emRISnBZM1FzSUdGeVozTXViR1Z1WjNSb1hTNWpiMjVqWVhRb1lYSm5jeWtwTzF4dWZWeHVYRzVoYzNObGNuUXVjM1J5YVdOMElEMGdiMkpxWldOMFFYTnphV2R1S0hOMGNtbGpkQ3dnWVhOelpYSjBMQ0I3WEc0Z0lHVnhkV0ZzT2lCaGMzTmxjblF1YzNSeWFXTjBSWEYxWVd3c1hHNGdJR1JsWlhCRmNYVmhiRG9nWVhOelpYSjBMbVJsWlhCVGRISnBZM1JGY1hWaGJDeGNiaUFnYm05MFJYRjFZV3c2SUdGemMyVnlkQzV1YjNSVGRISnBZM1JGY1hWaGJDeGNiaUFnYm05MFJHVmxjRVZ4ZFdGc09pQmhjM05sY25RdWJtOTBSR1ZsY0ZOMGNtbGpkRVZ4ZFdGc1hHNTlLVHRjYm1GemMyVnlkQzV6ZEhKcFkzUXVjM1J5YVdOMElEMGdZWE56WlhKMExuTjBjbWxqZERzaUxDSXZMeUJEZFhKeVpXNTBiSGtnYVc0Z2MzbHVZeUIzYVhSb0lFNXZaR1V1YW5NZ2JHbGlMMmx1ZEdWeWJtRnNMMkZ6YzJWeWRDOWhjM05sY25ScGIyNWZaWEp5YjNJdWFuTmNiaTh2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5dWIyUmxhbk12Ym05a1pTOWpiMjF0YVhRdk1EZ3hOemcwTUdZM056VXdNekl4Tmpsa1pHUTNNR000TldGak1EVTVaakU0Wm1aall6Z3hZMXh1SjNWelpTQnpkSEpwWTNRbk8xeHVYRzVtZFc1amRHbHZiaUJmYjJKcVpXTjBVM0J5WldGa0tIUmhjbWRsZENrZ2V5Qm1iM0lnS0haaGNpQnBJRDBnTVRzZ2FTQThJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZzdJR2tyS3lrZ2V5QjJZWElnYzI5MWNtTmxJRDBnWVhKbmRXMWxiblJ6VzJsZElDRTlJRzUxYkd3Z1B5QmhjbWQxYldWdWRITmJhVjBnT2lCN2ZUc2dkbUZ5SUc5M2JrdGxlWE1nUFNCUFltcGxZM1F1YTJWNWN5aHpiM1Z5WTJVcE95QnBaaUFvZEhsd1pXOW1JRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVZONWJXSnZiSE1nUFQwOUlDZG1kVzVqZEdsdmJpY3BJSHNnYjNkdVMyVjVjeUE5SUc5M2JrdGxlWE11WTI5dVkyRjBLRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVZONWJXSnZiSE1vYzI5MWNtTmxLUzVtYVd4MFpYSW9ablZ1WTNScGIyNGdLSE41YlNrZ2V5QnlaWFIxY200Z1QySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaWh6YjNWeVkyVXNJSE41YlNrdVpXNTFiV1Z5WVdKc1pUc2dmU2twT3lCOUlHOTNia3RsZVhNdVptOXlSV0ZqYUNobWRXNWpkR2x2YmlBb2EyVjVLU0I3SUY5a1pXWnBibVZRY205d1pYSjBlU2gwWVhKblpYUXNJR3RsZVN3Z2MyOTFjbU5sVzJ0bGVWMHBPeUI5S1RzZ2ZTQnlaWFIxY200Z2RHRnlaMlYwT3lCOVhHNWNibVoxYm1OMGFXOXVJRjlrWldacGJtVlFjbTl3WlhKMGVTaHZZbW9zSUd0bGVTd2dkbUZzZFdVcElIc2dhV1lnS0d0bGVTQnBiaUJ2WW1vcElIc2dUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0c5aWFpd2dhMlY1TENCN0lIWmhiSFZsT2lCMllXeDFaU3dnWlc1MWJXVnlZV0pzWlRvZ2RISjFaU3dnWTI5dVptbG5kWEpoWW14bE9pQjBjblZsTENCM2NtbDBZV0pzWlRvZ2RISjFaU0I5S1RzZ2ZTQmxiSE5sSUhzZ2IySnFXMnRsZVYwZ1BTQjJZV3gxWlRzZ2ZTQnlaWFIxY200Z2IySnFPeUI5WEc1Y2JtWjFibU4wYVc5dUlGOWpiR0Z6YzBOaGJHeERhR1ZqYXlocGJuTjBZVzVqWlN3Z1EyOXVjM1J5ZFdOMGIzSXBJSHNnYVdZZ0tDRW9hVzV6ZEdGdVkyVWdhVzV6ZEdGdVkyVnZaaUJEYjI1emRISjFZM1J2Y2lrcElIc2dkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWhjSWtOaGJtNXZkQ0JqWVd4c0lHRWdZMnhoYzNNZ1lYTWdZU0JtZFc1amRHbHZibHdpS1RzZ2ZTQjlYRzVjYm1aMWJtTjBhVzl1SUY5a1pXWnBibVZRY205d1pYSjBhV1Z6S0hSaGNtZGxkQ3dnY0hKdmNITXBJSHNnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCd2NtOXdjeTVzWlc1bmRHZzdJR2tyS3lrZ2V5QjJZWElnWkdWelkzSnBjSFJ2Y2lBOUlIQnliM0J6VzJsZE95QmtaWE5qY21sd2RHOXlMbVZ1ZFcxbGNtRmliR1VnUFNCa1pYTmpjbWx3ZEc5eUxtVnVkVzFsY21GaWJHVWdmSHdnWm1Gc2MyVTdJR1JsYzJOeWFYQjBiM0l1WTI5dVptbG5kWEpoWW14bElEMGdkSEoxWlRzZ2FXWWdLRndpZG1Gc2RXVmNJaUJwYmlCa1pYTmpjbWx3ZEc5eUtTQmtaWE5qY21sd2RHOXlMbmR5YVhSaFlteGxJRDBnZEhKMVpUc2dUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0hSaGNtZGxkQ3dnWkdWelkzSnBjSFJ2Y2k1clpYa3NJR1JsYzJOeWFYQjBiM0lwT3lCOUlIMWNibHh1Wm5WdVkzUnBiMjRnWDJOeVpXRjBaVU5zWVhOektFTnZibk4wY25WamRHOXlMQ0J3Y205MGIxQnliM0J6TENCemRHRjBhV05RY205d2N5a2dleUJwWmlBb2NISnZkRzlRY205d2N5a2dYMlJsWm1sdVpWQnliM0JsY25ScFpYTW9RMjl1YzNSeWRXTjBiM0l1Y0hKdmRHOTBlWEJsTENCd2NtOTBiMUJ5YjNCektUc2dhV1lnS0hOMFlYUnBZMUJ5YjNCektTQmZaR1ZtYVc1bFVISnZjR1Z5ZEdsbGN5aERiMjV6ZEhKMVkzUnZjaXdnYzNSaGRHbGpVSEp2Y0hNcE95QnlaWFIxY200Z1EyOXVjM1J5ZFdOMGIzSTdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gzQnZjM05wWW14bFEyOXVjM1J5ZFdOMGIzSlNaWFIxY200b2MyVnNaaXdnWTJGc2JDa2dleUJwWmlBb1kyRnNiQ0FtSmlBb1gzUjVjR1Z2WmloallXeHNLU0E5UFQwZ1hDSnZZbXBsWTNSY0lpQjhmQ0IwZVhCbGIyWWdZMkZzYkNBOVBUMGdYQ0ptZFc1amRHbHZibHdpS1NrZ2V5QnlaWFIxY200Z1kyRnNiRHNnZlNCeVpYUjFjbTRnWDJGemMyVnlkRlJvYVhOSmJtbDBhV0ZzYVhwbFpDaHpaV3htS1RzZ2ZWeHVYRzVtZFc1amRHbHZiaUJmWVhOelpYSjBWR2hwYzBsdWFYUnBZV3hwZW1Wa0tITmxiR1lwSUhzZ2FXWWdLSE5sYkdZZ1BUMDlJSFp2YVdRZ01Da2dleUIwYUhKdmR5QnVaWGNnVW1WbVpYSmxibU5sUlhKeWIzSW9YQ0owYUdseklHaGhjMjRuZENCaVpXVnVJR2x1YVhScFlXeHBjMlZrSUMwZ2MzVndaWElvS1NCb1lYTnVKM1FnWW1WbGJpQmpZV3hzWldSY0lpazdJSDBnY21WMGRYSnVJSE5sYkdZN0lIMWNibHh1Wm5WdVkzUnBiMjRnWDJsdWFHVnlhWFJ6S0hOMVlrTnNZWE56TENCemRYQmxja05zWVhOektTQjdJR2xtSUNoMGVYQmxiMllnYzNWd1pYSkRiR0Z6Y3lBaFBUMGdYQ0ptZFc1amRHbHZibHdpSUNZbUlITjFjR1Z5UTJ4aGMzTWdJVDA5SUc1MWJHd3BJSHNnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2loY0lsTjFjR1Z5SUdWNGNISmxjM05wYjI0Z2JYVnpkQ0JsYVhSb1pYSWdZbVVnYm5Wc2JDQnZjaUJoSUdaMWJtTjBhVzl1WENJcE95QjlJSE4xWWtOc1lYTnpMbkJ5YjNSdmRIbHdaU0E5SUU5aWFtVmpkQzVqY21WaGRHVW9jM1Z3WlhKRGJHRnpjeUFtSmlCemRYQmxja05zWVhOekxuQnliM1J2ZEhsd1pTd2dleUJqYjI1emRISjFZM1J2Y2pvZ2V5QjJZV3gxWlRvZ2MzVmlRMnhoYzNNc0lIZHlhWFJoWW14bE9pQjBjblZsTENCamIyNW1hV2QxY21GaWJHVTZJSFJ5ZFdVZ2ZTQjlLVHNnYVdZZ0tITjFjR1Z5UTJ4aGMzTXBJRjl6WlhSUWNtOTBiM1I1Y0dWUFppaHpkV0pEYkdGemN5d2djM1Z3WlhKRGJHRnpjeWs3SUgxY2JseHVablZ1WTNScGIyNGdYM2R5WVhCT1lYUnBkbVZUZFhCbGNpaERiR0Z6Y3lrZ2V5QjJZWElnWDJOaFkyaGxJRDBnZEhsd1pXOW1JRTFoY0NBOVBUMGdYQ0ptZFc1amRHbHZibHdpSUQ4Z2JtVjNJRTFoY0NncElEb2dkVzVrWldacGJtVmtPeUJmZDNKaGNFNWhkR2wyWlZOMWNHVnlJRDBnWm5WdVkzUnBiMjRnWDNkeVlYQk9ZWFJwZG1WVGRYQmxjaWhEYkdGemN5a2dleUJwWmlBb1EyeGhjM01nUFQwOUlHNTFiR3dnZkh3Z0lWOXBjMDVoZEdsMlpVWjFibU4wYVc5dUtFTnNZWE56S1NrZ2NtVjBkWEp1SUVOc1lYTnpPeUJwWmlBb2RIbHdaVzltSUVOc1lYTnpJQ0U5UFNCY0ltWjFibU4wYVc5dVhDSXBJSHNnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2loY0lsTjFjR1Z5SUdWNGNISmxjM05wYjI0Z2JYVnpkQ0JsYVhSb1pYSWdZbVVnYm5Wc2JDQnZjaUJoSUdaMWJtTjBhVzl1WENJcE95QjlJR2xtSUNoMGVYQmxiMllnWDJOaFkyaGxJQ0U5UFNCY0luVnVaR1ZtYVc1bFpGd2lLU0I3SUdsbUlDaGZZMkZqYUdVdWFHRnpLRU5zWVhOektTa2djbVYwZFhKdUlGOWpZV05vWlM1blpYUW9RMnhoYzNNcE95QmZZMkZqYUdVdWMyVjBLRU5zWVhOekxDQlhjbUZ3Y0dWeUtUc2dmU0JtZFc1amRHbHZiaUJYY21Gd2NHVnlLQ2tnZXlCeVpYUjFjbTRnWDJOdmJuTjBjblZqZENoRGJHRnpjeXdnWVhKbmRXMWxiblJ6TENCZloyVjBVSEp2ZEc5MGVYQmxUMllvZEdocGN5a3VZMjl1YzNSeWRXTjBiM0lwT3lCOUlGZHlZWEJ3WlhJdWNISnZkRzkwZVhCbElEMGdUMkpxWldOMExtTnlaV0YwWlNoRGJHRnpjeTV3Y205MGIzUjVjR1VzSUhzZ1kyOXVjM1J5ZFdOMGIzSTZJSHNnZG1Gc2RXVTZJRmR5WVhCd1pYSXNJR1Z1ZFcxbGNtRmliR1U2SUdaaGJITmxMQ0IzY21sMFlXSnNaVG9nZEhKMVpTd2dZMjl1Wm1sbmRYSmhZbXhsT2lCMGNuVmxJSDBnZlNrN0lISmxkSFZ5YmlCZmMyVjBVSEp2ZEc5MGVYQmxUMllvVjNKaGNIQmxjaXdnUTJ4aGMzTXBPeUI5T3lCeVpYUjFjbTRnWDNkeVlYQk9ZWFJwZG1WVGRYQmxjaWhEYkdGemN5azdJSDFjYmx4dVpuVnVZM1JwYjI0Z2FYTk9ZWFJwZG1WU1pXWnNaV04wUTI5dWMzUnlkV04wS0NrZ2V5QnBaaUFvZEhsd1pXOW1JRkpsWm14bFkzUWdQVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdmSHdnSVZKbFpteGxZM1F1WTI5dWMzUnlkV04wS1NCeVpYUjFjbTRnWm1Gc2MyVTdJR2xtSUNoU1pXWnNaV04wTG1OdmJuTjBjblZqZEM1emFHRnRLU0J5WlhSMWNtNGdabUZzYzJVN0lHbG1JQ2gwZVhCbGIyWWdVSEp2ZUhrZ1BUMDlJRndpWm5WdVkzUnBiMjVjSWlrZ2NtVjBkWEp1SUhSeWRXVTdJSFJ5ZVNCN0lFUmhkR1V1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29VbVZtYkdWamRDNWpiMjV6ZEhKMVkzUW9SR0YwWlN3Z1cxMHNJR1oxYm1OMGFXOXVJQ2dwSUh0OUtTazdJSEpsZEhWeWJpQjBjblZsT3lCOUlHTmhkR05vSUNobEtTQjdJSEpsZEhWeWJpQm1ZV3h6WlRzZ2ZTQjlYRzVjYm1aMWJtTjBhVzl1SUY5amIyNXpkSEoxWTNRb1VHRnlaVzUwTENCaGNtZHpMQ0JEYkdGemN5a2dleUJwWmlBb2FYTk9ZWFJwZG1WU1pXWnNaV04wUTI5dWMzUnlkV04wS0NrcElIc2dYMk52Ym5OMGNuVmpkQ0E5SUZKbFpteGxZM1F1WTI5dWMzUnlkV04wT3lCOUlHVnNjMlVnZXlCZlkyOXVjM1J5ZFdOMElEMGdablZ1WTNScGIyNGdYMk52Ym5OMGNuVmpkQ2hRWVhKbGJuUXNJR0Z5WjNNc0lFTnNZWE56S1NCN0lIWmhjaUJoSUQwZ1cyNTFiR3hkT3lCaExuQjFjMmd1WVhCd2JIa29ZU3dnWVhKbmN5azdJSFpoY2lCRGIyNXpkSEoxWTNSdmNpQTlJRVoxYm1OMGFXOXVMbUpwYm1RdVlYQndiSGtvVUdGeVpXNTBMQ0JoS1RzZ2RtRnlJR2x1YzNSaGJtTmxJRDBnYm1WM0lFTnZibk4wY25WamRHOXlLQ2s3SUdsbUlDaERiR0Z6Y3lrZ1gzTmxkRkJ5YjNSdmRIbHdaVTltS0dsdWMzUmhibU5sTENCRGJHRnpjeTV3Y205MGIzUjVjR1VwT3lCeVpYUjFjbTRnYVc1emRHRnVZMlU3SUgwN0lIMGdjbVYwZFhKdUlGOWpiMjV6ZEhKMVkzUXVZWEJ3Ykhrb2JuVnNiQ3dnWVhKbmRXMWxiblJ6S1RzZ2ZWeHVYRzVtZFc1amRHbHZiaUJmYVhOT1lYUnBkbVZHZFc1amRHbHZiaWhtYmlrZ2V5QnlaWFIxY200Z1JuVnVZM1JwYjI0dWRHOVRkSEpwYm1jdVkyRnNiQ2htYmlrdWFXNWtaWGhQWmloY0lsdHVZWFJwZG1VZ1kyOWtaVjFjSWlrZ0lUMDlJQzB4T3lCOVhHNWNibVoxYm1OMGFXOXVJRjl6WlhSUWNtOTBiM1I1Y0dWUFppaHZMQ0J3S1NCN0lGOXpaWFJRY205MGIzUjVjR1ZQWmlBOUlFOWlhbVZqZEM1elpYUlFjbTkwYjNSNWNHVlBaaUI4ZkNCbWRXNWpkR2x2YmlCZmMyVjBVSEp2ZEc5MGVYQmxUMllvYnl3Z2NDa2dleUJ2TGw5ZmNISnZkRzlmWHlBOUlIQTdJSEpsZEhWeWJpQnZPeUI5T3lCeVpYUjFjbTRnWDNObGRGQnliM1J2ZEhsd1pVOW1LRzhzSUhBcE95QjlYRzVjYm1aMWJtTjBhVzl1SUY5blpYUlFjbTkwYjNSNWNHVlBaaWh2S1NCN0lGOW5aWFJRY205MGIzUjVjR1ZQWmlBOUlFOWlhbVZqZEM1elpYUlFjbTkwYjNSNWNHVlBaaUEvSUU5aWFtVmpkQzVuWlhSUWNtOTBiM1I1Y0dWUFppQTZJR1oxYm1OMGFXOXVJRjluWlhSUWNtOTBiM1I1Y0dWUFppaHZLU0I3SUhKbGRIVnliaUJ2TGw5ZmNISnZkRzlmWHlCOGZDQlBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvYnlrN0lIMDdJSEpsZEhWeWJpQmZaMlYwVUhKdmRHOTBlWEJsVDJZb2J5azdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gzUjVjR1Z2Wmlodlltb3BJSHNnYVdZZ0tIUjVjR1Z2WmlCVGVXMWliMndnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCMGVYQmxiMllnVTNsdFltOXNMbWwwWlhKaGRHOXlJRDA5UFNCY0luTjViV0p2YkZ3aUtTQjdJRjkwZVhCbGIyWWdQU0JtZFc1amRHbHZiaUJmZEhsd1pXOW1LRzlpYWlrZ2V5QnlaWFIxY200Z2RIbHdaVzltSUc5aWFqc2dmVHNnZlNCbGJITmxJSHNnWDNSNWNHVnZaaUE5SUdaMWJtTjBhVzl1SUY5MGVYQmxiMllvYjJKcUtTQjdJSEpsZEhWeWJpQnZZbW9nSmlZZ2RIbHdaVzltSUZONWJXSnZiQ0E5UFQwZ1hDSm1kVzVqZEdsdmJsd2lJQ1ltSUc5aWFpNWpiMjV6ZEhKMVkzUnZjaUE5UFQwZ1UzbHRZbTlzSUNZbUlHOWlhaUFoUFQwZ1UzbHRZbTlzTG5CeWIzUnZkSGx3WlNBL0lGd2ljM2x0WW05c1hDSWdPaUIwZVhCbGIyWWdiMkpxT3lCOU95QjlJSEpsZEhWeWJpQmZkSGx3Wlc5bUtHOWlhaWs3SUgxY2JseHVkbUZ5SUY5eVpYRjFhWEpsSUQwZ2NtVnhkV2x5WlNnbmRYUnBiQzhuS1N4Y2JpQWdJQ0JwYm5Od1pXTjBJRDBnWDNKbGNYVnBjbVV1YVc1emNHVmpkRHRjYmx4dWRtRnlJRjl5WlhGMWFYSmxNaUE5SUhKbGNYVnBjbVVvSnk0dUwyVnljbTl5Y3ljcExGeHVJQ0FnSUVWU1VsOUpUbFpCVEVsRVgwRlNSMTlVV1ZCRklEMGdYM0psY1hWcGNtVXlMbU52WkdWekxrVlNVbDlKVGxaQlRFbEVYMEZTUjE5VVdWQkZPeUF2THlCb2RIUndjem92TDJSbGRtVnNiM0JsY2k1dGIzcHBiR3hoTG05eVp5OWxiaTFWVXk5a2IyTnpMMWRsWWk5S1lYWmhVMk55YVhCMEwxSmxabVZ5Wlc1alpTOUhiRzlpWVd4ZlQySnFaV04wY3k5VGRISnBibWN2Wlc1a2MxZHBkR2hjYmx4dVhHNW1kVzVqZEdsdmJpQmxibVJ6VjJsMGFDaHpkSElzSUhObFlYSmphQ3dnZEdocGMxOXNaVzRwSUh0Y2JpQWdhV1lnS0hSb2FYTmZiR1Z1SUQwOVBTQjFibVJsWm1sdVpXUWdmSHdnZEdocGMxOXNaVzRnUGlCemRISXViR1Z1WjNSb0tTQjdYRzRnSUNBZ2RHaHBjMTlzWlc0Z1BTQnpkSEl1YkdWdVozUm9PMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJSE4wY2k1emRXSnpkSEpwYm1jb2RHaHBjMTlzWlc0Z0xTQnpaV0Z5WTJndWJHVnVaM1JvTENCMGFHbHpYMnhsYmlrZ1BUMDlJSE5sWVhKamFEdGNibjBnTHk4Z2FIUjBjSE02THk5a1pYWmxiRzl3WlhJdWJXOTZhV3hzWVM1dmNtY3ZaVzR0VlZNdlpHOWpjeTlYWldJdlNtRjJZVk5qY21sd2RDOVNaV1psY21WdVkyVXZSMnh2WW1Gc1gwOWlhbVZqZEhNdlUzUnlhVzVuTDNKbGNHVmhkRnh1WEc1Y2JtWjFibU4wYVc5dUlISmxjR1ZoZENoemRISXNJR052ZFc1MEtTQjdYRzRnSUdOdmRXNTBJRDBnVFdGMGFDNW1iRzl2Y2loamIzVnVkQ2s3WEc0Z0lHbG1JQ2h6ZEhJdWJHVnVaM1JvSUQwOUlEQWdmSHdnWTI5MWJuUWdQVDBnTUNrZ2NtVjBkWEp1SUNjbk8xeHVJQ0IyWVhJZ2JXRjRRMjkxYm5RZ1BTQnpkSEl1YkdWdVozUm9JQ29nWTI5MWJuUTdYRzRnSUdOdmRXNTBJRDBnVFdGMGFDNW1iRzl2Y2loTllYUm9MbXh2WnloamIzVnVkQ2tnTHlCTllYUm9MbXh2WnlneUtTazdYRzVjYmlBZ2QyaHBiR1VnS0dOdmRXNTBLU0I3WEc0Z0lDQWdjM1J5SUNzOUlITjBjanRjYmlBZ0lDQmpiM1Z1ZEMwdE8xeHVJQ0I5WEc1Y2JpQWdjM1J5SUNzOUlITjBjaTV6ZFdKemRISnBibWNvTUN3Z2JXRjRRMjkxYm5RZ0xTQnpkSEl1YkdWdVozUm9LVHRjYmlBZ2NtVjBkWEp1SUhOMGNqdGNibjFjYmx4dWRtRnlJR0pzZFdVZ1BTQW5KenRjYm5aaGNpQm5jbVZsYmlBOUlDY25PMXh1ZG1GeUlISmxaQ0E5SUNjbk8xeHVkbUZ5SUhkb2FYUmxJRDBnSnljN1hHNTJZWElnYTFKbFlXUmhZbXhsVDNCbGNtRjBiM0lnUFNCN1hHNGdJR1JsWlhCVGRISnBZM1JGY1hWaGJEb2dKMFY0Y0dWamRHVmtJSFpoYkhWbGN5QjBieUJpWlNCemRISnBZM1JzZVNCa1pXVndMV1Z4ZFdGc09pY3NYRzRnSUhOMGNtbGpkRVZ4ZFdGc09pQW5SWGh3WldOMFpXUWdkbUZzZFdWeklIUnZJR0psSUhOMGNtbGpkR3g1SUdWeGRXRnNPaWNzWEc0Z0lITjBjbWxqZEVWeGRXRnNUMkpxWldOME9pQW5SWGh3WldOMFpXUWdYQ0poWTNSMVlXeGNJaUIwYnlCaVpTQnlaV1psY21WdVkyVXRaWEYxWVd3Z2RHOGdYQ0psZUhCbFkzUmxaRndpT2ljc1hHNGdJR1JsWlhCRmNYVmhiRG9nSjBWNGNHVmpkR1ZrSUhaaGJIVmxjeUIwYnlCaVpTQnNiMjl6Wld4NUlHUmxaWEF0WlhGMVlXdzZKeXhjYmlBZ1pYRjFZV3c2SUNkRmVIQmxZM1JsWkNCMllXeDFaWE1nZEc4Z1ltVWdiRzl2YzJWc2VTQmxjWFZoYkRvbkxGeHVJQ0J1YjNSRVpXVndVM1J5YVdOMFJYRjFZV3c2SUNkRmVIQmxZM1JsWkNCY0ltRmpkSFZoYkZ3aUlHNXZkQ0IwYnlCaVpTQnpkSEpwWTNSc2VTQmtaV1Z3TFdWeGRXRnNJSFJ2T2ljc1hHNGdJRzV2ZEZOMGNtbGpkRVZ4ZFdGc09pQW5SWGh3WldOMFpXUWdYQ0poWTNSMVlXeGNJaUIwYnlCaVpTQnpkSEpwWTNSc2VTQjFibVZ4ZFdGc0lIUnZPaWNzWEc0Z0lHNXZkRk4wY21samRFVnhkV0ZzVDJKcVpXTjBPaUFuUlhod1pXTjBaV1FnWENKaFkzUjFZV3hjSWlCdWIzUWdkRzhnWW1VZ2NtVm1aWEpsYm1ObExXVnhkV0ZzSUhSdklGd2laWGh3WldOMFpXUmNJam9uTEZ4dUlDQnViM1JFWldWd1JYRjFZV3c2SUNkRmVIQmxZM1JsWkNCY0ltRmpkSFZoYkZ3aUlHNXZkQ0IwYnlCaVpTQnNiMjl6Wld4NUlHUmxaWEF0WlhGMVlXd2dkRzg2Snl4Y2JpQWdibTkwUlhGMVlXdzZJQ2RGZUhCbFkzUmxaQ0JjSW1GamRIVmhiRndpSUhSdklHSmxJR3h2YjNObGJIa2dkVzVsY1hWaGJDQjBiem9uTEZ4dUlDQnViM1JKWkdWdWRHbGpZV3c2SUNkV1lXeDFaWE1nYVdSbGJuUnBZMkZzSUdKMWRDQnViM1FnY21WbVpYSmxibU5sTFdWeGRXRnNPaWRjYm4wN0lDOHZJRU52YlhCaGNtbHVaeUJ6YUc5eWRDQndjbWx0YVhScGRtVnpJSE5vYjNWc1pDQnFkWE4wSUhOb2IzY2dQVDA5SUM4Z0lUMDlJR2x1YzNSbFlXUWdiMllnZFhOcGJtY2dkR2hsWEc0dkx5QmthV1ptTGx4dVhHNTJZWElnYTAxaGVGTm9iM0owVEdWdVozUm9JRDBnTVRBN1hHNWNibVoxYm1OMGFXOXVJR052Y0hsRmNuSnZjaWh6YjNWeVkyVXBJSHRjYmlBZ2RtRnlJR3RsZVhNZ1BTQlBZbXBsWTNRdWEyVjVjeWh6YjNWeVkyVXBPMXh1SUNCMllYSWdkR0Z5WjJWMElEMGdUMkpxWldOMExtTnlaV0YwWlNoUFltcGxZM1F1WjJWMFVISnZkRzkwZVhCbFQyWW9jMjkxY21ObEtTazdYRzRnSUd0bGVYTXVabTl5UldGamFDaG1kVzVqZEdsdmJpQW9hMlY1S1NCN1hHNGdJQ0FnZEdGeVoyVjBXMnRsZVYwZ1BTQnpiM1Z5WTJWYmEyVjVYVHRjYmlBZ2ZTazdYRzRnSUU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGVTaDBZWEpuWlhRc0lDZHRaWE56WVdkbEp5d2dlMXh1SUNBZ0lIWmhiSFZsT2lCemIzVnlZMlV1YldWemMyRm5aVnh1SUNCOUtUdGNiaUFnY21WMGRYSnVJSFJoY21kbGREdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2FXNXpjR1ZqZEZaaGJIVmxLSFpoYkNrZ2UxeHVJQ0F2THlCVWFHVWdkWFJwYkM1cGJuTndaV04wSUdSbFptRjFiSFFnZG1Gc2RXVnpJR052ZFd4a0lHSmxJR05vWVc1blpXUXVJRlJvYVhNZ2JXRnJaWE1nYzNWeVpTQjBhR1ZjYmlBZ0x5OGdaWEp5YjNJZ2JXVnpjMkZuWlhNZ1kyOXVkR0ZwYmlCMGFHVWdibVZqWlhOellYSjVJR2x1Wm05eWJXRjBhVzl1SUc1bGRtVnlkR2hsYkdWemN5NWNiaUFnY21WMGRYSnVJR2x1YzNCbFkzUW9kbUZzTENCN1hHNGdJQ0FnWTI5dGNHRmpkRG9nWm1Gc2MyVXNYRzRnSUNBZ1kzVnpkRzl0U1c1emNHVmpkRG9nWm1Gc2MyVXNYRzRnSUNBZ1pHVndkR2c2SURFd01EQXNYRzRnSUNBZ2JXRjRRWEp5WVhsTVpXNW5kR2c2SUVsdVptbHVhWFI1TEZ4dUlDQWdJQzh2SUVGemMyVnlkQ0JqYjIxd1lYSmxjeUJ2Ym14NUlHVnVkVzFsY21GaWJHVWdjSEp2Y0dWeWRHbGxjeUFvZDJsMGFDQmhJR1psZHlCbGVHTmxjSFJwYjI1ektTNWNiaUFnSUNCemFHOTNTR2xrWkdWdU9pQm1ZV3h6WlN4Y2JpQWdJQ0F2THlCSVlYWnBibWNnWVNCc2IyNW5JR3hwYm1VZ1lYTWdaWEp5YjNJZ2FYTWdZbVYwZEdWeUlIUm9ZVzRnZDNKaGNIQnBibWNnZEdobElHeHBibVVnWm05eVhHNGdJQ0FnTHk4Z1kyOXRjR0Z5YVhOdmJpQm1iM0lnYm05M0xseHVJQ0FnSUM4dklGUlBSRThvUW5KcFpHZGxRVklwT2lCZ1luSmxZV3RNWlc1bmRHaGdJSE5vYjNWc1pDQmlaU0JzYVcxcGRHVmtJR0Z6SUhOdmIyNGdZWE1nYzI5dmJpQmhjeUIzWlZ4dUlDQWdJQzh2SUdoaGRtVWdiV1YwWVNCcGJtWnZjbTFoZEdsdmJpQmhZbTkxZENCMGFHVWdhVzV6Y0dWamRHVmtJSEJ5YjNCbGNuUnBaWE1nS0drdVpTNHNJR3R1YjNjZ2QyaGxjbVZjYmlBZ0lDQXZMeUJwYmlCM2FHRjBJR3hwYm1VZ2RHaGxJSEJ5YjNCbGNuUjVJSE4wWVhKMGN5QmhibVFnWlc1a2N5a3VYRzRnSUNBZ1luSmxZV3RNWlc1bmRHZzZJRWx1Wm1sdWFYUjVMRnh1SUNBZ0lDOHZJRUZ6YzJWeWRDQmtiMlZ6SUc1dmRDQmtaWFJsWTNRZ2NISnZlR2xsY3lCamRYSnlaVzUwYkhrdVhHNGdJQ0FnYzJodmQxQnliM2g1T2lCbVlXeHpaU3hjYmlBZ0lDQnpiM0owWldRNklIUnlkV1VzWEc0Z0lDQWdMeThnU1c1emNHVmpkQ0JuWlhSMFpYSnpJR0Z6SUhkbElHRnNjMjhnWTJobFkyc2dkR2hsYlNCM2FHVnVJR052YlhCaGNtbHVaeUJsYm5SeWFXVnpMbHh1SUNBZ0lHZGxkSFJsY25NNklIUnlkV1ZjYmlBZ2ZTazdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHTnlaV0YwWlVWeWNrUnBabVlvWVdOMGRXRnNMQ0JsZUhCbFkzUmxaQ3dnYjNCbGNtRjBiM0lwSUh0Y2JpQWdkbUZ5SUc5MGFHVnlJRDBnSnljN1hHNGdJSFpoY2lCeVpYTWdQU0FuSnp0Y2JpQWdkbUZ5SUd4aGMzUlFiM01nUFNBd08xeHVJQ0IyWVhJZ1pXNWtJRDBnSnljN1hHNGdJSFpoY2lCemEybHdjR1ZrSUQwZ1ptRnNjMlU3WEc0Z0lIWmhjaUJoWTNSMVlXeEpibk53WldOMFpXUWdQU0JwYm5Od1pXTjBWbUZzZFdVb1lXTjBkV0ZzS1R0Y2JpQWdkbUZ5SUdGamRIVmhiRXhwYm1WeklEMGdZV04wZFdGc1NXNXpjR1ZqZEdWa0xuTndiR2wwS0NkY1hHNG5LVHRjYmlBZ2RtRnlJR1Y0Y0dWamRHVmtUR2x1WlhNZ1BTQnBibk53WldOMFZtRnNkV1VvWlhod1pXTjBaV1FwTG5Od2JHbDBLQ2RjWEc0bktUdGNiaUFnZG1GeUlHa2dQU0F3TzF4dUlDQjJZWElnYVc1a2FXTmhkRzl5SUQwZ0p5YzdJQzh2SUVsdUlHTmhjMlVnWW05MGFDQjJZV3gxWlhNZ1lYSmxJRzlpYW1WamRITWdaWGh3YkdsamFYUnNlU0J0WVhKcklIUm9aVzBnWVhNZ2JtOTBJSEpsWm1WeVpXNWpaU0JsY1hWaGJGeHVJQ0F2THlCbWIzSWdkR2hsSUdCemRISnBZM1JGY1hWaGJHQWdiM0JsY21GMGIzSXVYRzVjYmlBZ2FXWWdLRzl3WlhKaGRHOXlJRDA5UFNBbmMzUnlhV04wUlhGMVlXd25JQ1ltSUY5MGVYQmxiMllvWVdOMGRXRnNLU0E5UFQwZ0oyOWlhbVZqZENjZ0ppWWdYM1I1Y0dWdlppaGxlSEJsWTNSbFpDa2dQVDA5SUNkdlltcGxZM1FuSUNZbUlHRmpkSFZoYkNBaFBUMGdiblZzYkNBbUppQmxlSEJsWTNSbFpDQWhQVDBnYm5Wc2JDa2dlMXh1SUNBZ0lHOXdaWEpoZEc5eUlEMGdKM04wY21samRFVnhkV0ZzVDJKcVpXTjBKenRjYmlBZ2ZTQXZMeUJKWmlCY0ltRmpkSFZoYkZ3aUlHRnVaQ0JjSW1WNGNHVmpkR1ZrWENJZ1ptbDBJRzl1SUdFZ2MybHVaMnhsSUd4cGJtVWdZVzVrSUhSb1pYa2dZWEpsSUc1dmRDQnpkSEpwWTNSc2VWeHVJQ0F2THlCbGNYVmhiQ3dnWTJobFkyc2dablZ5ZEdobGNpQnpjR1ZqYVdGc0lHaGhibVJzYVc1bkxseHVYRzVjYmlBZ2FXWWdLR0ZqZEhWaGJFeHBibVZ6TG14bGJtZDBhQ0E5UFQwZ01TQW1KaUJsZUhCbFkzUmxaRXhwYm1WekxteGxibWQwYUNBOVBUMGdNU0FtSmlCaFkzUjFZV3hNYVc1bGMxc3dYU0FoUFQwZ1pYaHdaV04wWldSTWFXNWxjMXN3WFNrZ2UxeHVJQ0FnSUhaaGNpQnBibkIxZEV4bGJtZDBhQ0E5SUdGamRIVmhiRXhwYm1Weld6QmRMbXhsYm1kMGFDQXJJR1Y0Y0dWamRHVmtUR2x1WlhOYk1GMHViR1Z1WjNSb095QXZMeUJKWmlCMGFHVWdZMmhoY21GamRHVnlJR3hsYm1kMGFDQnZaaUJjSW1GamRIVmhiRndpSUdGdVpDQmNJbVY0Y0dWamRHVmtYQ0lnZEc5blpYUm9aWElnYVhNZ2JHVnpjeUIwYUdGdVhHNGdJQ0FnTHk4Z2EwMWhlRk5vYjNKMFRHVnVaM1JvSUdGdVpDQnBaaUJ1WldsMGFHVnlJR2x6SUdGdUlHOWlhbVZqZENCaGJtUWdZWFFnYkdWaGMzUWdiMjVsSUc5bUlIUm9aVzBnYVhOY2JpQWdJQ0F2THlCdWIzUWdZSHBsY205Z0xDQjFjMlVnZEdobElITjBjbWxqZENCbGNYVmhiQ0JqYjIxd1lYSnBjMjl1SUhSdklIWnBjM1ZoYkdsNlpTQjBhR1VnYjNWMGNIVjBMbHh1WEc0Z0lDQWdhV1lnS0dsdWNIVjBUR1Z1WjNSb0lEdzlJR3ROWVhoVGFHOXlkRXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdhV1lnS0NoZmRIbHdaVzltS0dGamRIVmhiQ2tnSVQwOUlDZHZZbXBsWTNRbklIeDhJR0ZqZEhWaGJDQTlQVDBnYm5Wc2JDa2dKaVlnS0Y5MGVYQmxiMllvWlhod1pXTjBaV1FwSUNFOVBTQW5iMkpxWldOMEp5QjhmQ0JsZUhCbFkzUmxaQ0E5UFQwZ2JuVnNiQ2tnSmlZZ0tHRmpkSFZoYkNBaFBUMGdNQ0I4ZkNCbGVIQmxZM1JsWkNBaFBUMGdNQ2twSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdMVEFnUFQwOUlDc3dYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmNJbHdpTG1OdmJtTmhkQ2hyVW1WaFpHRmliR1ZQY0dWeVlYUnZjbHR2Y0dWeVlYUnZjbDBzSUZ3aVhGeHVYRnh1WENJcElDc2dYQ0pjSWk1amIyNWpZWFFvWVdOMGRXRnNUR2x1WlhOYk1GMHNJRndpSUNFOVBTQmNJaWt1WTI5dVkyRjBLR1Y0Y0dWamRHVmtUR2x1WlhOYk1GMHNJRndpWEZ4dVhDSXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9iM0JsY21GMGIzSWdJVDA5SUNkemRISnBZM1JGY1hWaGJFOWlhbVZqZENjcElIdGNiaUFnSUNBZ0lDOHZJRWxtSUhSb1pTQnpkR1JsY25JZ2FYTWdZU0IwZEhrZ1lXNWtJSFJvWlNCcGJuQjFkQ0JzWlc1bmRHZ2dhWE1nYkc5M1pYSWdkR2hoYmlCMGFHVWdZM1Z5Y21WdWRGeHVJQ0FnSUNBZ0x5OGdZMjlzZFcxdWN5QndaWElnYkdsdVpTd2dZV1JrSUdFZ2JXbHpiV0YwWTJnZ2FXNWthV05oZEc5eUlHSmxiRzkzSUhSb1pTQnZkWFJ3ZFhRdUlFbG1JR2wwSUdselhHNGdJQ0FnSUNBdkx5QnViM1FnWVNCMGRIa3NJSFZ6WlNCaElHUmxabUYxYkhRZ2RtRnNkV1VnYjJZZ09EQWdZMmhoY21GamRHVnljeTVjYmlBZ0lDQWdJSFpoY2lCdFlYaE1aVzVuZEdnZ1BTQndjbTlqWlhOekxuTjBaR1Z5Y2lBbUppQndjbTlqWlhOekxuTjBaR1Z5Y2k1cGMxUlVXU0EvSUhCeWIyTmxjM011YzNSa1pYSnlMbU52YkhWdGJuTWdPaUE0TUR0Y2JseHVJQ0FnSUNBZ2FXWWdLR2x1Y0hWMFRHVnVaM1JvSUR3Z2JXRjRUR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaGhZM1IxWVd4TWFXNWxjMXN3WFZ0cFhTQTlQVDBnWlhod1pXTjBaV1JNYVc1bGMxc3dYVnRwWFNrZ2UxeHVJQ0FnSUNBZ0lDQWdJR2tyS3p0Y2JpQWdJQ0FnSUNBZ2ZTQXZMeUJKWjI1dmNtVWdkR2hsSUdacGNuTjBJR05vWVhKaFkzUmxjbk11WEc1Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvYVNBK0lESXBJSHRjYmlBZ0lDQWdJQ0FnSUNBdkx5QkJaR1FnY0c5emFYUnBiMjRnYVc1a2FXTmhkRzl5SUdadmNpQjBhR1VnWm1seWMzUWdiV2x6YldGMFkyZ2dhVzRnWTJGelpTQnBkQ0JwY3lCaFhHNGdJQ0FnSUNBZ0lDQWdMeThnYzJsdVoyeGxJR3hwYm1VZ1lXNWtJSFJvWlNCcGJuQjFkQ0JzWlc1bmRHZ2dhWE1nYkdWemN5QjBhR0Z1SUhSb1pTQmpiMngxYlc0Z2JHVnVaM1JvTGx4dUlDQWdJQ0FnSUNBZ0lHbHVaR2xqWVhSdmNpQTlJRndpWEZ4dUlDQmNJaTVqYjI1allYUW9jbVZ3WldGMEtDY2dKeXdnYVNrc0lGd2lYbHdpS1R0Y2JpQWdJQ0FnSUNBZ0lDQnBJRDBnTUR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmU0F2THlCU1pXMXZkbVVnWVd4c0lHVnVaR2x1WnlCc2FXNWxjeUIwYUdGMElHMWhkR05vSUNoMGFHbHpJRzl3ZEdsdGFYcGxjeUIwYUdVZ2IzVjBjSFYwSUdadmNseHVJQ0F2THlCeVpXRmtZV0pwYkdsMGVTQmllU0J5WldSMVkybHVaeUIwYUdVZ2JuVnRZbVZ5SUc5bUlIUnZkR0ZzSUdOb1lXNW5aV1FnYkdsdVpYTXBMbHh1WEc1Y2JpQWdkbUZ5SUdFZ1BTQmhZM1IxWVd4TWFXNWxjMXRoWTNSMVlXeE1hVzVsY3k1c1pXNW5kR2dnTFNBeFhUdGNiaUFnZG1GeUlHSWdQU0JsZUhCbFkzUmxaRXhwYm1WelcyVjRjR1ZqZEdWa1RHbHVaWE11YkdWdVozUm9JQzBnTVYwN1hHNWNiaUFnZDJocGJHVWdLR0VnUFQwOUlHSXBJSHRjYmlBZ0lDQnBaaUFvYVNzcklEd2dNaWtnZTF4dUlDQWdJQ0FnWlc1a0lEMGdYQ0pjWEc0Z0lGd2lMbU52Ym1OaGRDaGhLUzVqYjI1allYUW9aVzVrS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdiM1JvWlhJZ1BTQmhPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHRmpkSFZoYkV4cGJtVnpMbkJ2Y0NncE8xeHVJQ0FnSUdWNGNHVmpkR1ZrVEdsdVpYTXVjRzl3S0NrN1hHNGdJQ0FnYVdZZ0tHRmpkSFZoYkV4cGJtVnpMbXhsYm1kMGFDQTlQVDBnTUNCOGZDQmxlSEJsWTNSbFpFeHBibVZ6TG14bGJtZDBhQ0E5UFQwZ01Da2dZbkpsWVdzN1hHNGdJQ0FnWVNBOUlHRmpkSFZoYkV4cGJtVnpXMkZqZEhWaGJFeHBibVZ6TG14bGJtZDBhQ0F0SURGZE8xeHVJQ0FnSUdJZ1BTQmxlSEJsWTNSbFpFeHBibVZ6VzJWNGNHVmpkR1ZrVEdsdVpYTXViR1Z1WjNSb0lDMGdNVjA3WEc0Z0lIMWNibHh1SUNCMllYSWdiV0Y0VEdsdVpYTWdQU0JOWVhSb0xtMWhlQ2hoWTNSMVlXeE1hVzVsY3k1c1pXNW5kR2dzSUdWNGNHVmpkR1ZrVEdsdVpYTXViR1Z1WjNSb0tUc2dMeThnVTNSeWFXTjBJR1Z4ZFdGc0lIZHBkR2dnYVdSbGJuUnBZMkZzSUc5aWFtVmpkSE1nZEdoaGRDQmhjbVVnYm05MElHbGtaVzUwYVdOaGJDQmllU0J5WldabGNtVnVZMlV1WEc0Z0lDOHZJRVV1Wnk0c0lHRnpjMlZ5ZEM1a1pXVndVM1J5YVdOMFJYRjFZV3dvZXlCaE9pQlRlVzFpYjJ3b0tTQjlMQ0I3SUdFNklGTjViV0p2YkNncElIMHBYRzVjYmlBZ2FXWWdLRzFoZUV4cGJtVnpJRDA5UFNBd0tTQjdYRzRnSUNBZ0x5OGdWMlVnYUdGMlpTQjBieUJuWlhRZ2RHaGxJSEpsYzNWc2RDQmhaMkZwYmk0Z1ZHaGxJR3hwYm1WeklIZGxjbVVnWVd4c0lISmxiVzkyWldRZ1ltVm1iM0psTGx4dUlDQWdJSFpoY2lCZllXTjBkV0ZzVEdsdVpYTWdQU0JoWTNSMVlXeEpibk53WldOMFpXUXVjM0JzYVhRb0oxeGNiaWNwT3lBdkx5QlBibXg1SUhKbGJXOTJaU0JzYVc1bGN5QnBiaUJqWVhObElHbDBJRzFoYTJWeklITmxibk5sSUhSdklHTnZiR3hoY0hObElIUm9iM05sTGx4dUlDQWdJQzh2SUZSUFJFODZJRUZqWTJWd2RDQmxibllnZEc4Z1lXeDNZWGx6SUhOb2IzY2dkR2hsSUdaMWJHd2daWEp5YjNJdVhHNWNibHh1SUNBZ0lHbG1JQ2hmWVdOMGRXRnNUR2x1WlhNdWJHVnVaM1JvSUQ0Z016QXBJSHRjYmlBZ0lDQWdJRjloWTNSMVlXeE1hVzVsYzFzeU5sMGdQU0JjSWx3aUxtTnZibU5oZENoaWJIVmxMQ0JjSWk0dUxsd2lLUzVqYjI1allYUW9kMmhwZEdVcE8xeHVYRzRnSUNBZ0lDQjNhR2xzWlNBb1gyRmpkSFZoYkV4cGJtVnpMbXhsYm1kMGFDQStJREkzS1NCN1hHNGdJQ0FnSUNBZ0lGOWhZM1IxWVd4TWFXNWxjeTV3YjNBb0tUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNWNiaUFnSUNCeVpYUjFjbTRnWENKY0lpNWpiMjVqWVhRb2ExSmxZV1JoWW14bFQzQmxjbUYwYjNJdWJtOTBTV1JsYm5ScFkyRnNMQ0JjSWx4Y2JseGNibHdpS1M1amIyNWpZWFFvWDJGamRIVmhiRXhwYm1WekxtcHZhVzRvSjF4Y2JpY3BMQ0JjSWx4Y2Jsd2lLVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHBJRDRnTXlrZ2UxeHVJQ0FnSUdWdVpDQTlJRndpWEZ4dVhDSXVZMjl1WTJGMEtHSnNkV1VzSUZ3aUxpNHVYQ0lwTG1OdmJtTmhkQ2gzYUdsMFpTa3VZMjl1WTJGMEtHVnVaQ2s3WEc0Z0lDQWdjMnRwY0hCbFpDQTlJSFJ5ZFdVN1hHNGdJSDFjYmx4dUlDQnBaaUFvYjNSb1pYSWdJVDA5SUNjbktTQjdYRzRnSUNBZ1pXNWtJRDBnWENKY1hHNGdJRndpTG1OdmJtTmhkQ2h2ZEdobGNpa3VZMjl1WTJGMEtHVnVaQ2s3WEc0Z0lDQWdiM1JvWlhJZ1BTQW5KenRjYmlBZ2ZWeHVYRzRnSUhaaGNpQndjbWx1ZEdWa1RHbHVaWE1nUFNBd08xeHVJQ0IyWVhJZ2JYTm5JRDBnYTFKbFlXUmhZbXhsVDNCbGNtRjBiM0piYjNCbGNtRjBiM0pkSUNzZ1hDSmNYRzVjSWk1amIyNWpZWFFvWjNKbFpXNHNJRndpS3lCaFkzUjFZV3hjSWlrdVkyOXVZMkYwS0hkb2FYUmxMQ0JjSWlCY0lpa3VZMjl1WTJGMEtISmxaQ3dnWENJdElHVjRjR1ZqZEdWa1hDSXBMbU52Ym1OaGRDaDNhR2wwWlNrN1hHNGdJSFpoY2lCemEybHdjR1ZrVFhObklEMGdYQ0lnWENJdVkyOXVZMkYwS0dKc2RXVXNJRndpTGk0dVhDSXBMbU52Ym1OaGRDaDNhR2wwWlN3Z1hDSWdUR2x1WlhNZ2MydHBjSEJsWkZ3aUtUdGNibHh1SUNCbWIzSWdLR2tnUFNBd095QnBJRHdnYldGNFRHbHVaWE03SUdrckt5a2dlMXh1SUNBZ0lDOHZJRTl1YkhrZ1pYaDBjbUVnWlhod1pXTjBaV1FnYkdsdVpYTWdaWGhwYzNSY2JpQWdJQ0IyWVhJZ1kzVnlJRDBnYVNBdElHeGhjM1JRYjNNN1hHNWNiaUFnSUNCcFppQW9ZV04wZFdGc1RHbHVaWE11YkdWdVozUm9JRHdnYVNBcklERXBJSHRjYmlBZ0lDQWdJQzh2SUVsbUlIUm9aU0JzWVhOMElHUnBkbVZ5WjJsdVp5QnNhVzVsSUdseklHMXZjbVVnZEdoaGJpQnZibVVnYkdsdVpTQmhZbTkyWlNCaGJtUWdkR2hsWEc0Z0lDQWdJQ0F2THlCamRYSnlaVzUwSUd4cGJtVWdhWE1nWVhRZ2JHVmhjM1FnYkdsdVpTQjBhSEpsWlN3Z1lXUmtJSE52YldVZ2IyWWdkR2hsSUdadmNtMWxjaUJzYVc1bGN5QmhibVJjYmlBZ0lDQWdJQzh2SUdGc2MyOGdZV1JrSUdSdmRITWdkRzhnYVc1a2FXTmhkR1VnYzJ0cGNIQmxaQ0JsYm5SeWFXVnpMbHh1SUNBZ0lDQWdhV1lnS0dOMWNpQStJREVnSmlZZ2FTQStJRElwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR04xY2lBK0lEUXBJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpYTWdLejBnWENKY1hHNWNJaTVqYjI1allYUW9ZbXgxWlN3Z1hDSXVMaTVjSWlrdVkyOXVZMkYwS0hkb2FYUmxLVHRjYmlBZ0lDQWdJQ0FnSUNCemEybHdjR1ZrSUQwZ2RISjFaVHRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoamRYSWdQaUF6S1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVZ6SUNzOUlGd2lYRnh1SUNCY0lpNWpiMjVqWVhRb1pYaHdaV04wWldSTWFXNWxjMXRwSUMwZ01sMHBPMXh1SUNBZ0lDQWdJQ0FnSUhCeWFXNTBaV1JNYVc1bGN5c3JPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2NtVnpJQ3M5SUZ3aVhGeHVJQ0JjSWk1amIyNWpZWFFvWlhod1pXTjBaV1JNYVc1bGMxdHBJQzBnTVYwcE8xeHVJQ0FnSUNBZ0lDQndjbWx1ZEdWa1RHbHVaWE1yS3p0Y2JpQWdJQ0FnSUgwZ0x5OGdUV0Z5YXlCMGFHVWdZM1Z5Y21WdWRDQnNhVzVsSUdGeklIUm9aU0JzWVhOMElHUnBkbVZ5WjJsdVp5QnZibVV1WEc1Y2JseHVJQ0FnSUNBZ2JHRnpkRkJ2Y3lBOUlHazdJQzh2SUVGa1pDQjBhR1VnWlhod1pXTjBaV1FnYkdsdVpTQjBieUIwYUdVZ1kyRmphR1V1WEc1Y2JpQWdJQ0FnSUc5MGFHVnlJQ3M5SUZ3aVhGeHVYQ0l1WTI5dVkyRjBLSEpsWkN3Z1hDSXRYQ0lwTG1OdmJtTmhkQ2gzYUdsMFpTd2dYQ0lnWENJcExtTnZibU5oZENobGVIQmxZM1JsWkV4cGJtVnpXMmxkS1R0Y2JpQWdJQ0FnSUhCeWFXNTBaV1JNYVc1bGN5c3JPeUF2THlCUGJteDVJR1Y0ZEhKaElHRmpkSFZoYkNCc2FXNWxjeUJsZUdsemRGeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1pYaHdaV04wWldSTWFXNWxjeTVzWlc1bmRHZ2dQQ0JwSUNzZ01Ta2dlMXh1SUNBZ0lDQWdMeThnU1dZZ2RHaGxJR3hoYzNRZ1pHbDJaWEpuYVc1bklHeHBibVVnYVhNZ2JXOXlaU0IwYUdGdUlHOXVaU0JzYVc1bElHRmliM1psSUdGdVpDQjBhR1ZjYmlBZ0lDQWdJQzh2SUdOMWNuSmxiblFnYkdsdVpTQnBjeUJoZENCc1pXRnpkQ0JzYVc1bElIUm9jbVZsTENCaFpHUWdjMjl0WlNCdlppQjBhR1VnWm05eWJXVnlJR3hwYm1WeklHRnVaRnh1SUNBZ0lDQWdMeThnWVd4emJ5QmhaR1FnWkc5MGN5QjBieUJwYm1ScFkyRjBaU0J6YTJsd2NHVmtJR1Z1ZEhKcFpYTXVYRzRnSUNBZ0lDQnBaaUFvWTNWeUlENGdNU0FtSmlCcElENGdNaWtnZTF4dUlDQWdJQ0FnSUNCcFppQW9ZM1Z5SUQ0Z05Da2dlMXh1SUNBZ0lDQWdJQ0FnSUhKbGN5QXJQU0JjSWx4Y2Jsd2lMbU52Ym1OaGRDaGliSFZsTENCY0lpNHVMbHdpS1M1amIyNWpZWFFvZDJocGRHVXBPMXh1SUNBZ0lDQWdJQ0FnSUhOcmFYQndaV1FnUFNCMGNuVmxPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0dOMWNpQStJRE1wSUh0Y2JpQWdJQ0FnSUNBZ0lDQnlaWE1nS3owZ1hDSmNYRzRnSUZ3aUxtTnZibU5oZENoaFkzUjFZV3hNYVc1bGMxdHBJQzBnTWwwcE8xeHVJQ0FnSUNBZ0lDQWdJSEJ5YVc1MFpXUk1hVzVsY3lzck8xeHVJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnY21WeklDczlJRndpWEZ4dUlDQmNJaTVqYjI1allYUW9ZV04wZFdGc1RHbHVaWE5iYVNBdElERmRLVHRjYmlBZ0lDQWdJQ0FnY0hKcGJuUmxaRXhwYm1Wekt5czdYRzRnSUNBZ0lDQjlJQzh2SUUxaGNtc2dkR2hsSUdOMWNuSmxiblFnYkdsdVpTQmhjeUIwYUdVZ2JHRnpkQ0JrYVhabGNtZHBibWNnYjI1bExseHVYRzVjYmlBZ0lDQWdJR3hoYzNSUWIzTWdQU0JwT3lBdkx5QkJaR1FnZEdobElHRmpkSFZoYkNCc2FXNWxJSFJ2SUhSb1pTQnlaWE4xYkhRdVhHNWNiaUFnSUNBZ0lISmxjeUFyUFNCY0lseGNibHdpTG1OdmJtTmhkQ2huY21WbGJpd2dYQ0lyWENJcExtTnZibU5oZENoM2FHbDBaU3dnWENJZ1hDSXBMbU52Ym1OaGRDaGhZM1IxWVd4TWFXNWxjMXRwWFNrN1hHNGdJQ0FnSUNCd2NtbHVkR1ZrVEdsdVpYTXJLenNnTHk4Z1RHbHVaWE1nWkdsMlpYSm5aVnh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCMllYSWdaWGh3WldOMFpXUk1hVzVsSUQwZ1pYaHdaV04wWldSTWFXNWxjMXRwWFR0Y2JpQWdJQ0FnSUhaaGNpQmhZM1IxWVd4TWFXNWxJRDBnWVdOMGRXRnNUR2x1WlhOYmFWMDdJQzh2SUVsbUlIUm9aU0JzYVc1bGN5QmthWFpsY21kbExDQnpjR1ZqYVdacFkyRnNiSGtnWTJobFkyc2dabTl5SUd4cGJtVnpJSFJvWVhRZ2IyNXNlU0JrYVhabGNtZGxJR0o1WEc0Z0lDQWdJQ0F2THlCaElIUnlZV2xzYVc1bklHTnZiVzFoTGlCSmJpQjBhR0YwSUdOaGMyVWdhWFFnYVhNZ1lXTjBkV0ZzYkhrZ2FXUmxiblJwWTJGc0lHRnVaQ0IzWlNCemFHOTFiR1JjYmlBZ0lDQWdJQzh2SUcxaGNtc2dhWFFnWVhNZ2MzVmphQzVjYmx4dUlDQWdJQ0FnZG1GeUlHUnBkbVZ5WjJsdVoweHBibVZ6SUQwZ1lXTjBkV0ZzVEdsdVpTQWhQVDBnWlhod1pXTjBaV1JNYVc1bElDWW1JQ2doWlc1a2MxZHBkR2dvWVdOMGRXRnNUR2x1WlN3Z0p5d25LU0I4ZkNCaFkzUjFZV3hNYVc1bExuTnNhV05sS0RBc0lDMHhLU0FoUFQwZ1pYaHdaV04wWldSTWFXNWxLVHNnTHk4Z1NXWWdkR2hsSUdWNGNHVmpkR1ZrSUd4cGJtVWdhR0Z6SUdFZ2RISmhhV3hwYm1jZ1kyOXRiV0VnWW5WMElHbHpJRzkwYUdWeWQybHpaU0JwWkdWdWRHbGpZV3dzWEc0Z0lDQWdJQ0F2THlCaFpHUWdZU0JqYjIxdFlTQmhkQ0IwYUdVZ1pXNWtJRzltSUhSb1pTQmhZM1IxWVd3Z2JHbHVaUzRnVDNSb1pYSjNhWE5sSUhSb1pTQnZkWFJ3ZFhRZ1kyOTFiR1JjYmlBZ0lDQWdJQzh2SUd4dmIyc2dkMlZwY21RZ1lYTWdhVzQ2WEc0Z0lDQWdJQ0F2TDF4dUlDQWdJQ0FnTHk4Z0lDQmJYRzRnSUNBZ0lDQXZMeUFnSUNBZ01TQWdJQ0FnSUNBZ0lDOHZJRTV2SUdOdmJXMWhJR0YwSUhSb1pTQmxibVFoWEc0Z0lDQWdJQ0F2THlBcklDQWdNbHh1SUNBZ0lDQWdMeThnSUNCZFhHNGdJQ0FnSUNBdkwxeHVYRzRnSUNBZ0lDQnBaaUFvWkdsMlpYSm5hVzVuVEdsdVpYTWdKaVlnWlc1a2MxZHBkR2dvWlhod1pXTjBaV1JNYVc1bExDQW5MQ2NwSUNZbUlHVjRjR1ZqZEdWa1RHbHVaUzV6YkdsalpTZ3dMQ0F0TVNrZ1BUMDlJR0ZqZEhWaGJFeHBibVVwSUh0Y2JpQWdJQ0FnSUNBZ1pHbDJaWEpuYVc1blRHbHVaWE1nUFNCbVlXeHpaVHRjYmlBZ0lDQWdJQ0FnWVdOMGRXRnNUR2x1WlNBclBTQW5MQ2M3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdsbUlDaGthWFpsY21kcGJtZE1hVzVsY3lrZ2UxeHVJQ0FnSUNBZ0lDQXZMeUJKWmlCMGFHVWdiR0Z6ZENCa2FYWmxjbWRwYm1jZ2JHbHVaU0JwY3lCdGIzSmxJSFJvWVc0Z2IyNWxJR3hwYm1VZ1lXSnZkbVVnWVc1a0lIUm9aVnh1SUNBZ0lDQWdJQ0F2THlCamRYSnlaVzUwSUd4cGJtVWdhWE1nWVhRZ2JHVmhjM1FnYkdsdVpTQjBhSEpsWlN3Z1lXUmtJSE52YldVZ2IyWWdkR2hsSUdadmNtMWxjaUJzYVc1bGN5QmhibVJjYmlBZ0lDQWdJQ0FnTHk4Z1lXeHpieUJoWkdRZ1pHOTBjeUIwYnlCcGJtUnBZMkYwWlNCemEybHdjR1ZrSUdWdWRISnBaWE11WEc0Z0lDQWdJQ0FnSUdsbUlDaGpkWElnUGlBeElDWW1JR2tnUGlBeUtTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHTjFjaUErSURRcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGN5QXJQU0JjSWx4Y2Jsd2lMbU52Ym1OaGRDaGliSFZsTENCY0lpNHVMbHdpS1M1amIyNWpZWFFvZDJocGRHVXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2MydHBjSEJsWkNBOUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaGpkWElnUGlBektTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYTWdLejBnWENKY1hHNGdJRndpTG1OdmJtTmhkQ2hoWTNSMVlXeE1hVzVsYzF0cElDMGdNbDBwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjSEpwYm5SbFpFeHBibVZ6S3lzN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUNBZ2NtVnpJQ3M5SUZ3aVhGeHVJQ0JjSWk1amIyNWpZWFFvWVdOMGRXRnNUR2x1WlhOYmFTQXRJREZkS1R0Y2JpQWdJQ0FnSUNBZ0lDQndjbWx1ZEdWa1RHbHVaWE1yS3p0Y2JpQWdJQ0FnSUNBZ2ZTQXZMeUJOWVhKcklIUm9aU0JqZFhKeVpXNTBJR3hwYm1VZ1lYTWdkR2hsSUd4aGMzUWdaR2wyWlhKbmFXNW5JRzl1WlM1Y2JseHVYRzRnSUNBZ0lDQWdJR3hoYzNSUWIzTWdQU0JwT3lBdkx5QkJaR1FnZEdobElHRmpkSFZoYkNCc2FXNWxJSFJ2SUhSb1pTQnlaWE4xYkhRZ1lXNWtJR05oWTJobElIUm9aU0JsZUhCbFkzUmxaQ0JrYVhabGNtZHBibWRjYmlBZ0lDQWdJQ0FnTHk4Z2JHbHVaU0J6YnlCamIyNXpaV04xZEdsMlpTQmthWFpsY21kcGJtY2diR2x1WlhNZ2MyaHZkeUIxY0NCaGN5QXJLeXN0TFMwZ1lXNWtJRzV2ZENBckxTc3RLeTB1WEc1Y2JpQWdJQ0FnSUNBZ2NtVnpJQ3M5SUZ3aVhGeHVYQ0l1WTI5dVkyRjBLR2R5WldWdUxDQmNJaXRjSWlrdVkyOXVZMkYwS0hkb2FYUmxMQ0JjSWlCY0lpa3VZMjl1WTJGMEtHRmpkSFZoYkV4cGJtVXBPMXh1SUNBZ0lDQWdJQ0J2ZEdobGNpQXJQU0JjSWx4Y2Jsd2lMbU52Ym1OaGRDaHlaV1FzSUZ3aUxWd2lLUzVqYjI1allYUW9kMmhwZEdVc0lGd2lJRndpS1M1amIyNWpZWFFvWlhod1pXTjBaV1JNYVc1bEtUdGNiaUFnSUNBZ0lDQWdjSEpwYm5SbFpFeHBibVZ6SUNzOUlESTdJQzh2SUV4cGJtVnpJR0Z5WlNCcFpHVnVkR2xqWVd4Y2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUM4dklFRmtaQ0JoYkd3Z1kyRmphR1ZrSUdsdVptOXliV0YwYVc5dUlIUnZJSFJvWlNCeVpYTjFiSFFnWW1WbWIzSmxJR0ZrWkdsdVp5QnZkR2hsY2lCMGFHbHVaM05jYmlBZ0lDQWdJQ0FnTHk4Z1lXNWtJSEpsYzJWMElIUm9aU0JqWVdOb1pTNWNiaUFnSUNBZ0lDQWdjbVZ6SUNzOUlHOTBhR1Z5TzF4dUlDQWdJQ0FnSUNCdmRHaGxjaUE5SUNjbk95QXZMeUJKWmlCMGFHVWdiR0Z6ZENCa2FYWmxjbWRwYm1jZ2JHbHVaU0JwY3lCbGVHRmpkR3g1SUc5dVpTQnNhVzVsSUdGaWIzWmxJRzl5SUdsbUlHbDBJR2x6SUhSb1pWeHVJQ0FnSUNBZ0lDQXZMeUIyWlhKNUlHWnBjbk4wSUd4cGJtVXNJR0ZrWkNCMGFHVWdiR2x1WlNCMGJ5QjBhR1VnY21WemRXeDBMbHh1WEc0Z0lDQWdJQ0FnSUdsbUlDaGpkWElnUFQwOUlERWdmSHdnYVNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lISmxjeUFyUFNCY0lseGNiaUFnWENJdVkyOXVZMkYwS0dGamRIVmhiRXhwYm1VcE8xeHVJQ0FnSUNBZ0lDQWdJSEJ5YVc1MFpXUk1hVzVsY3lzck8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTQXZMeUJKYm5Od1pXTjBaV1FnYjJKcVpXTjBJSFJ2SUdKcFp5QW9VMmh2ZHlCK01qQWdjbTkzY3lCdFlYZ3BYRzVjYmx4dUlDQWdJR2xtSUNod2NtbHVkR1ZrVEdsdVpYTWdQaUF5TUNBbUppQnBJRHdnYldGNFRHbHVaWE1nTFNBeUtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1hDSmNJaTVqYjI1allYUW9iWE5uS1M1amIyNWpZWFFvYzJ0cGNIQmxaRTF6Wnl3Z1hDSmNYRzVjSWlrdVkyOXVZMkYwS0hKbGN5d2dYQ0pjWEc1Y0lpa3VZMjl1WTJGMEtHSnNkV1VzSUZ3aUxpNHVYQ0lwTG1OdmJtTmhkQ2gzYUdsMFpTa3VZMjl1WTJGMEtHOTBhR1Z5TENCY0lseGNibHdpS1NBcklGd2lYQ0l1WTI5dVkyRjBLR0pzZFdVc0lGd2lMaTR1WENJcExtTnZibU5oZENoM2FHbDBaU2s3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJRndpWENJdVkyOXVZMkYwS0cxelp5a3VZMjl1WTJGMEtITnJhWEJ3WldRZ1B5QnphMmx3Y0dWa1RYTm5JRG9nSnljc0lGd2lYRnh1WENJcExtTnZibU5oZENoeVpYTXBMbU52Ym1OaGRDaHZkR2hsY2lrdVkyOXVZMkYwS0dWdVpDa3VZMjl1WTJGMEtHbHVaR2xqWVhSdmNpazdYRzU5WEc1Y2JuWmhjaUJCYzNObGNuUnBiMjVGY25KdmNpQTlYRzR2S2lOZlgxQlZVa1ZmWHlvdlhHNW1kVzVqZEdsdmJpQW9YMFZ5Y205eUtTQjdYRzRnSUY5cGJtaGxjbWwwY3loQmMzTmxjblJwYjI1RmNuSnZjaXdnWDBWeWNtOXlLVHRjYmx4dUlDQm1kVzVqZEdsdmJpQkJjM05sY25ScGIyNUZjbkp2Y2lodmNIUnBiMjV6S1NCN1hHNGdJQ0FnZG1GeUlGOTBhR2x6TzF4dVhHNGdJQ0FnWDJOc1lYTnpRMkZzYkVOb1pXTnJLSFJvYVhNc0lFRnpjMlZ5ZEdsdmJrVnljbTl5S1R0Y2JseHVJQ0FnSUdsbUlDaGZkSGx3Wlc5bUtHOXdkR2x2Ym5NcElDRTlQU0FuYjJKcVpXTjBKeUI4ZkNCdmNIUnBiMjV6SUQwOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JWSlNYMGxPVmtGTVNVUmZRVkpIWDFSWlVFVW9KMjl3ZEdsdmJuTW5MQ0FuVDJKcVpXTjBKeXdnYjNCMGFXOXVjeWs3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdkbUZ5SUcxbGMzTmhaMlVnUFNCdmNIUnBiMjV6TG0xbGMzTmhaMlVzWEc0Z0lDQWdJQ0FnSUc5d1pYSmhkRzl5SUQwZ2IzQjBhVzl1Y3k1dmNHVnlZWFJ2Y2l4Y2JpQWdJQ0FnSUNBZ2MzUmhZMnRUZEdGeWRFWnVJRDBnYjNCMGFXOXVjeTV6ZEdGamExTjBZWEowUm00N1hHNGdJQ0FnZG1GeUlHRmpkSFZoYkNBOUlHOXdkR2x2Ym5NdVlXTjBkV0ZzTEZ4dUlDQWdJQ0FnSUNCbGVIQmxZM1JsWkNBOUlHOXdkR2x2Ym5NdVpYaHdaV04wWldRN1hHNGdJQ0FnZG1GeUlHeHBiV2wwSUQwZ1JYSnliM0l1YzNSaFkydFVjbUZqWlV4cGJXbDBPMXh1SUNBZ0lFVnljbTl5TG5OMFlXTnJWSEpoWTJWTWFXMXBkQ0E5SURBN1hHNWNiaUFnSUNCcFppQW9iV1Z6YzJGblpTQWhQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQmZkR2hwY3lBOUlGOXdiM056YVdKc1pVTnZibk4wY25WamRHOXlVbVYwZFhKdUtIUm9hWE1zSUY5blpYUlFjbTkwYjNSNWNHVlBaaWhCYzNObGNuUnBiMjVGY25KdmNpa3VZMkZzYkNoMGFHbHpMQ0JUZEhKcGJtY29iV1Z6YzJGblpTa3BLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2FXWWdLSEJ5YjJObGMzTXVjM1JrWlhKeUlDWW1JSEJ5YjJObGMzTXVjM1JrWlhKeUxtbHpWRlJaS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJRkpsYzJWMElHOXVJR1ZoWTJnZ1kyRnNiQ0IwYnlCdFlXdGxJSE4xY21VZ2QyVWdhR0Z1Wkd4bElHUjVibUZ0YVdOaGJHeDVJSE5sZENCbGJuWnBjbTl1YldWdWRGeHVJQ0FnSUNBZ0lDQXZMeUIyWVhKcFlXSnNaWE1nWTI5eWNtVmpkQzVjYmlBZ0lDQWdJQ0FnYVdZZ0tIQnliMk5sYzNNdWMzUmtaWEp5SUNZbUlIQnliMk5sYzNNdWMzUmtaWEp5TG1kbGRFTnZiRzl5UkdWd2RHZ2dKaVlnY0hKdlkyVnpjeTV6ZEdSbGNuSXVaMlYwUTI5c2IzSkVaWEIwYUNncElDRTlQU0F4S1NCN1hHNGdJQ0FnSUNBZ0lDQWdZbXgxWlNBOUlGd2lYRng0TVVKYk16UnRYQ0k3WEc0Z0lDQWdJQ0FnSUNBZ1ozSmxaVzRnUFNCY0lseGNlREZDV3pNeWJWd2lPMXh1SUNBZ0lDQWdJQ0FnSUhkb2FYUmxJRDBnWENKY1hIZ3hRbHN6T1cxY0lqdGNiaUFnSUNBZ0lDQWdJQ0J5WldRZ1BTQmNJbHhjZURGQ1d6TXhiVndpTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHSnNkV1VnUFNBbkp6dGNiaUFnSUNBZ0lDQWdJQ0JuY21WbGJpQTlJQ2NuTzF4dUlDQWdJQ0FnSUNBZ0lIZG9hWFJsSUQwZ0p5YzdYRzRnSUNBZ0lDQWdJQ0FnY21Wa0lEMGdKeWM3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgwZ0x5OGdVSEpsZG1WdWRDQjBhR1VnWlhKeWIzSWdjM1JoWTJzZ1puSnZiU0JpWldsdVp5QjJhWE5wWW14bElHSjVJR1IxY0d4cFkyRjBhVzVuSUhSb1pTQmxjbkp2Y2x4dUlDQWdJQ0FnTHk4Z2FXNGdZU0IyWlhKNUlHTnNiM05sSUhkaGVTQjBieUIwYUdVZ2IzSnBaMmx1WVd3Z2FXNGdZMkZ6WlNCaWIzUm9JSE5wWkdWeklHRnlaU0JoWTNSMVlXeHNlVnh1SUNBZ0lDQWdMeThnYVc1emRHRnVZMlZ6SUc5bUlFVnljbTl5TGx4dVhHNWNiaUFnSUNBZ0lHbG1JQ2hmZEhsd1pXOW1LR0ZqZEhWaGJDa2dQVDA5SUNkdlltcGxZM1FuSUNZbUlHRmpkSFZoYkNBaFBUMGdiblZzYkNBbUppQmZkSGx3Wlc5bUtHVjRjR1ZqZEdWa0tTQTlQVDBnSjI5aWFtVmpkQ2NnSmlZZ1pYaHdaV04wWldRZ0lUMDlJRzUxYkd3Z0ppWWdKM04wWVdOckp5QnBiaUJoWTNSMVlXd2dKaVlnWVdOMGRXRnNJR2x1YzNSaGJtTmxiMllnUlhKeWIzSWdKaVlnSjNOMFlXTnJKeUJwYmlCbGVIQmxZM1JsWkNBbUppQmxlSEJsWTNSbFpDQnBibk4wWVc1alpXOW1JRVZ5Y205eUtTQjdYRzRnSUNBZ0lDQWdJR0ZqZEhWaGJDQTlJR052Y0hsRmNuSnZjaWhoWTNSMVlXd3BPMXh1SUNBZ0lDQWdJQ0JsZUhCbFkzUmxaQ0E5SUdOdmNIbEZjbkp2Y2lobGVIQmxZM1JsWkNrN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lHbG1JQ2h2Y0dWeVlYUnZjaUE5UFQwZ0oyUmxaWEJUZEhKcFkzUkZjWFZoYkNjZ2ZId2diM0JsY21GMGIzSWdQVDA5SUNkemRISnBZM1JGY1hWaGJDY3BJSHRjYmlBZ0lDQWdJQ0FnWDNSb2FYTWdQU0JmY0c5emMybGliR1ZEYjI1emRISjFZM1J2Y2xKbGRIVnliaWgwYUdsekxDQmZaMlYwVUhKdmRHOTBlWEJsVDJZb1FYTnpaWEowYVc5dVJYSnliM0lwTG1OaGJHd29kR2hwY3l3Z1kzSmxZWFJsUlhKeVJHbG1aaWhoWTNSMVlXd3NJR1Y0Y0dWamRHVmtMQ0J2Y0dWeVlYUnZjaWtwS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2IzQmxjbUYwYjNJZ1BUMDlJQ2R1YjNSRVpXVndVM1J5YVdOMFJYRjFZV3duSUh4OElHOXdaWEpoZEc5eUlEMDlQU0FuYm05MFUzUnlhV04wUlhGMVlXd25LU0I3WEc0Z0lDQWdJQ0FnSUM4dklFbHVJR05oYzJVZ2RHaGxJRzlpYW1WamRITWdZWEpsSUdWeGRXRnNJR0oxZENCMGFHVWdiM0JsY21GMGIzSWdjbVZ4ZFdseVpYTWdkVzVsY1hWaGJDd2djMmh2ZDF4dUlDQWdJQ0FnSUNBdkx5QjBhR1VnWm1seWMzUWdiMkpxWldOMElHRnVaQ0J6WVhrZ1FTQmxjWFZoYkhNZ1FseHVJQ0FnSUNBZ0lDQjJZWElnWW1GelpTQTlJR3RTWldGa1lXSnNaVTl3WlhKaGRHOXlXMjl3WlhKaGRHOXlYVHRjYmlBZ0lDQWdJQ0FnZG1GeUlISmxjeUE5SUdsdWMzQmxZM1JXWVd4MVpTaGhZM1IxWVd3cExuTndiR2wwS0NkY1hHNG5LVHNnTHk4Z1NXNGdZMkZ6WlNCY0ltRmpkSFZoYkZ3aUlHbHpJR0Z1SUc5aWFtVmpkQ3dnYVhRZ2MyaHZkV3hrSUc1dmRDQmlaU0J5WldabGNtVnVZMlVnWlhGMVlXd3VYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHOXdaWEpoZEc5eUlEMDlQU0FuYm05MFUzUnlhV04wUlhGMVlXd25JQ1ltSUY5MGVYQmxiMllvWVdOMGRXRnNLU0E5UFQwZ0oyOWlhbVZqZENjZ0ppWWdZV04wZFdGc0lDRTlQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQWdJQ0FnWW1GelpTQTlJR3RTWldGa1lXSnNaVTl3WlhKaGRHOXlMbTV2ZEZOMGNtbGpkRVZ4ZFdGc1QySnFaV04wTzF4dUlDQWdJQ0FnSUNCOUlDOHZJRTl1YkhrZ2NtVnRiM1psSUd4cGJtVnpJR2x1SUdOaGMyVWdhWFFnYldGclpYTWdjMlZ1YzJVZ2RHOGdZMjlzYkdGd2MyVWdkR2h2YzJVdVhHNGdJQ0FnSUNBZ0lDOHZJRlJQUkU4NklFRmpZMlZ3ZENCbGJuWWdkRzhnWVd4M1lYbHpJSE5vYjNjZ2RHaGxJR1oxYkd3Z1pYSnliM0l1WEc1Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvY21WekxteGxibWQwYUNBK0lETXdLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2NtVnpXekkyWFNBOUlGd2lYQ0l1WTI5dVkyRjBLR0pzZFdVc0lGd2lMaTR1WENJcExtTnZibU5oZENoM2FHbDBaU2s3WEc1Y2JpQWdJQ0FnSUNBZ0lDQjNhR2xzWlNBb2NtVnpMbXhsYm1kMGFDQStJREkzS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhNdWNHOXdLQ2s3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlJQzh2SUU5dWJIa2djSEpwYm5RZ1lTQnphVzVuYkdVZ2FXNXdkWFF1WEc1Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvY21WekxteGxibWQwYUNBOVBUMGdNU2tnZTF4dUlDQWdJQ0FnSUNBZ0lGOTBhR2x6SUQwZ1gzQnZjM05wWW14bFEyOXVjM1J5ZFdOMGIzSlNaWFIxY200b2RHaHBjeXdnWDJkbGRGQnliM1J2ZEhsd1pVOW1LRUZ6YzJWeWRHbHZia1Z5Y205eUtTNWpZV3hzS0hSb2FYTXNJRndpWENJdVkyOXVZMkYwS0dKaGMyVXNJRndpSUZ3aUtTNWpiMjVqWVhRb2NtVnpXekJkS1NrcE8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJRjkwYUdseklEMGdYM0J2YzNOcFlteGxRMjl1YzNSeWRXTjBiM0pTWlhSMWNtNG9kR2hwY3l3Z1gyZGxkRkJ5YjNSdmRIbHdaVTltS0VGemMyVnlkR2x2YmtWeWNtOXlLUzVqWVd4c0tIUm9hWE1zSUZ3aVhDSXVZMjl1WTJGMEtHSmhjMlVzSUZ3aVhGeHVYRnh1WENJcExtTnZibU5oZENoeVpYTXVhbTlwYmlnblhGeHVKeWtzSUZ3aVhGeHVYQ0lwS1NrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJmY21WeklEMGdhVzV6Y0dWamRGWmhiSFZsS0dGamRIVmhiQ2s3WEc1Y2JpQWdJQ0FnSUNBZ2RtRnlJRzkwYUdWeUlEMGdKeWM3WEc0Z0lDQWdJQ0FnSUhaaGNpQnJibTkzYms5d1pYSmhkRzl5Y3lBOUlHdFNaV0ZrWVdKc1pVOXdaWEpoZEc5eVcyOXdaWEpoZEc5eVhUdGNibHh1SUNBZ0lDQWdJQ0JwWmlBb2IzQmxjbUYwYjNJZ1BUMDlJQ2R1YjNSRVpXVndSWEYxWVd3bklIeDhJRzl3WlhKaGRHOXlJRDA5UFNBbmJtOTBSWEYxWVd3bktTQjdYRzRnSUNBZ0lDQWdJQ0FnWDNKbGN5QTlJRndpWENJdVkyOXVZMkYwS0d0U1pXRmtZV0pzWlU5d1pYSmhkRzl5VzI5d1pYSmhkRzl5WFN3Z1hDSmNYRzVjWEc1Y0lpa3VZMjl1WTJGMEtGOXlaWE1wTzF4dVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0Y5eVpYTXViR1Z1WjNSb0lENGdNVEF5TkNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWDNKbGN5QTlJRndpWENJdVkyOXVZMkYwS0Y5eVpYTXVjMnhwWTJVb01Dd2dNVEF5TVNrc0lGd2lMaTR1WENJcE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNCdmRHaGxjaUE5SUZ3aVhDSXVZMjl1WTJGMEtHbHVjM0JsWTNSV1lXeDFaU2hsZUhCbFkzUmxaQ2twTzF4dVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0Y5eVpYTXViR1Z1WjNSb0lENGdOVEV5S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JmY21WeklEMGdYQ0pjSWk1amIyNWpZWFFvWDNKbGN5NXpiR2xqWlNnd0xDQTFNRGtwTENCY0lpNHVMbHdpS1R0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9iM1JvWlhJdWJHVnVaM1JvSUQ0Z05URXlLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnZkR2hsY2lBOUlGd2lYQ0l1WTI5dVkyRjBLRzkwYUdWeUxuTnNhV05sS0RBc0lEVXdPU2tzSUZ3aUxpNHVYQ0lwTzF4dUlDQWdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHZjR1Z5WVhSdmNpQTlQVDBnSjJSbFpYQkZjWFZoYkNjZ2ZId2diM0JsY21GMGIzSWdQVDA5SUNkbGNYVmhiQ2NwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRjl5WlhNZ1BTQmNJbHdpTG1OdmJtTmhkQ2hyYm05M2JrOXdaWEpoZEc5eWN5d2dYQ0pjWEc1Y1hHNWNJaWt1WTI5dVkyRjBLRjl5WlhNc0lGd2lYRnh1WEZ4dWMyaHZkV3hrSUdWeGRXRnNYRnh1WEZ4dVhDSXBPMXh1SUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnZkR2hsY2lBOUlGd2lJRndpTG1OdmJtTmhkQ2h2Y0dWeVlYUnZjaXdnWENJZ1hDSXBMbU52Ym1OaGRDaHZkR2hsY2lrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ1gzUm9hWE1nUFNCZmNHOXpjMmxpYkdWRGIyNXpkSEoxWTNSdmNsSmxkSFZ5YmloMGFHbHpMQ0JmWjJWMFVISnZkRzkwZVhCbFQyWW9RWE56WlhKMGFXOXVSWEp5YjNJcExtTmhiR3dvZEdocGN5d2dYQ0pjSWk1amIyNWpZWFFvWDNKbGN5a3VZMjl1WTJGMEtHOTBhR1Z5S1NrcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUVWeWNtOXlMbk4wWVdOclZISmhZMlZNYVcxcGRDQTlJR3hwYldsME8xeHVJQ0FnSUY5MGFHbHpMbWRsYm1WeVlYUmxaRTFsYzNOaFoyVWdQU0FoYldWemMyRm5aVHRjYmlBZ0lDQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvWDJGemMyVnlkRlJvYVhOSmJtbDBhV0ZzYVhwbFpDaGZkR2hwY3lrc0lDZHVZVzFsSnl3Z2UxeHVJQ0FnSUNBZ2RtRnNkV1U2SUNkQmMzTmxjblJwYjI1RmNuSnZjaUJiUlZKU1gwRlRVMFZTVkVsUFRsMG5MRnh1SUNBZ0lDQWdaVzUxYldWeVlXSnNaVG9nWm1Gc2MyVXNYRzRnSUNBZ0lDQjNjbWwwWVdKc1pUb2dkSEoxWlN4Y2JpQWdJQ0FnSUdOdmJtWnBaM1Z5WVdKc1pUb2dkSEoxWlZ4dUlDQWdJSDBwTzF4dUlDQWdJRjkwYUdsekxtTnZaR1VnUFNBblJWSlNYMEZUVTBWU1ZFbFBUaWM3WEc0Z0lDQWdYM1JvYVhNdVlXTjBkV0ZzSUQwZ1lXTjBkV0ZzTzF4dUlDQWdJRjkwYUdsekxtVjRjR1ZqZEdWa0lEMGdaWGh3WldOMFpXUTdYRzRnSUNBZ1gzUm9hWE11YjNCbGNtRjBiM0lnUFNCdmNHVnlZWFJ2Y2p0Y2JseHVJQ0FnSUdsbUlDaEZjbkp2Y2k1allYQjBkWEpsVTNSaFkydFVjbUZqWlNrZ2UxeHVJQ0FnSUNBZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJtVjRkQzFzYVc1bElHNXZMWEpsYzNSeWFXTjBaV1F0YzNsdWRHRjRYRzRnSUNBZ0lDQkZjbkp2Y2k1allYQjBkWEpsVTNSaFkydFVjbUZqWlNoZllYTnpaWEowVkdocGMwbHVhWFJwWVd4cGVtVmtLRjkwYUdsektTd2djM1JoWTJ0VGRHRnlkRVp1S1R0Y2JpQWdJQ0I5SUM4dklFTnlaV0YwWlNCbGNuSnZjaUJ0WlhOellXZGxJR2x1WTJ4MVpHbHVaeUIwYUdVZ1pYSnliM0lnWTI5a1pTQnBiaUIwYUdVZ2JtRnRaUzVjYmx4dVhHNGdJQ0FnWDNSb2FYTXVjM1JoWTJzN0lDOHZJRkpsYzJWMElIUm9aU0J1WVcxbExseHVYRzRnSUNBZ1gzUm9hWE11Ym1GdFpTQTlJQ2RCYzNObGNuUnBiMjVGY25KdmNpYzdYRzRnSUNBZ2NtVjBkWEp1SUY5d2IzTnphV0pzWlVOdmJuTjBjblZqZEc5eVVtVjBkWEp1S0Y5MGFHbHpLVHRjYmlBZ2ZWeHVYRzRnSUY5amNtVmhkR1ZEYkdGemN5aEJjM05sY25ScGIyNUZjbkp2Y2l3Z1czdGNiaUFnSUNCclpYazZJRndpZEc5VGRISnBibWRjSWl4Y2JpQWdJQ0IyWVd4MVpUb2dablZ1WTNScGIyNGdkRzlUZEhKcGJtY29LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdYQ0pjSWk1amIyNWpZWFFvZEdocGN5NXVZVzFsTENCY0lpQmJYQ0lwTG1OdmJtTmhkQ2gwYUdsekxtTnZaR1VzSUZ3aVhUb2dYQ0lwTG1OdmJtTmhkQ2gwYUdsekxtMWxjM05oWjJVcE8xeHVJQ0FnSUgxY2JpQWdmU3dnZTF4dUlDQWdJR3RsZVRvZ2FXNXpjR1ZqZEM1amRYTjBiMjBzWEc0Z0lDQWdkbUZzZFdVNklHWjFibU4wYVc5dUlIWmhiSFZsS0hKbFkzVnljMlZVYVcxbGN5d2dZM1I0S1NCN1hHNGdJQ0FnSUNBdkx5QlVhR2x6SUd4cGJXbDBjeUIwYUdVZ1lHRmpkSFZoYkdBZ1lXNWtJR0JsZUhCbFkzUmxaR0FnY0hKdmNHVnlkSGtnWkdWbVlYVnNkQ0JwYm5Od1pXTjBhVzl1SUhSdlhHNGdJQ0FnSUNBdkx5QjBhR1VnYldsdWFXMTFiU0JrWlhCMGFDNGdUM1JvWlhKM2FYTmxJSFJvYjNObElIWmhiSFZsY3lCM2IzVnNaQ0JpWlNCMGIyOGdkbVZ5WW05elpTQmpiMjF3WVhKbFpGeHVJQ0FnSUNBZ0x5OGdkRzhnZEdobElHRmpkSFZoYkNCbGNuSnZjaUJ0WlhOellXZGxJSGRvYVdOb0lHTnZiblJoYVc1eklHRWdZMjl0WW1sdVpXUWdkbWxsZHlCdlppQjBhR1Z6WlNCMGQyOWNiaUFnSUNBZ0lDOHZJR2x1Y0hWMElIWmhiSFZsY3k1Y2JpQWdJQ0FnSUhKbGRIVnliaUJwYm5Od1pXTjBLSFJvYVhNc0lGOXZZbXBsWTNSVGNISmxZV1FvZTMwc0lHTjBlQ3dnZTF4dUlDQWdJQ0FnSUNCamRYTjBiMjFKYm5Od1pXTjBPaUJtWVd4elpTeGNiaUFnSUNBZ0lDQWdaR1Z3ZEdnNklEQmNiaUFnSUNBZ0lIMHBLVHRjYmlBZ0lDQjlYRzRnSUgxZEtUdGNibHh1SUNCeVpYUjFjbTRnUVhOelpYSjBhVzl1UlhKeWIzSTdYRzU5S0Y5M2NtRndUbUYwYVhabFUzVndaWElvUlhKeWIzSXBLVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCQmMzTmxjblJwYjI1RmNuSnZjanNpTENJdkx5QkRkWEp5Wlc1MGJIa2dhVzRnYzNsdVl5QjNhWFJvSUU1dlpHVXVhbk1nYkdsaUwybHVkR1Z5Ym1Gc0wyVnljbTl5Y3k1cWMxeHVMeThnYUhSMGNITTZMeTluYVhSb2RXSXVZMjl0TDI1dlpHVnFjeTl1YjJSbEwyTnZiVzFwZEM4ellqQTBORGsyTW1NME9HWmxNekV6T1RBMU9EYzNZVGsyWWpWa01EZzVOR0UxTkRBMFpqWm1YRzVjYmk4cUlHVnpiR2x1ZENCdWIyUmxMV052Y21VdlpHOWpkVzFsYm5SbFpDMWxjbkp2Y25NNklGd2laWEp5YjNKY0lpQXFMMXh1WEc0dktpQmxjMnhwYm5RZ2JtOWtaUzFqYjNKbEwyRnNjR2hoWW1WMGFYcGxMV1Z5Y205eWN6b2dYQ0psY25KdmNsd2lJQ292WEc1Y2JpOHFJR1Z6YkdsdWRDQnViMlJsTFdOdmNtVXZjSEpsWm1WeUxYVjBhV3d0Wm05eWJXRjBMV1Z5Y205eWN6b2dYQ0psY25KdmNsd2lJQ292WEc0bmRYTmxJSE4wY21samRDYzdJQzh2SUZSb1pTQjNhRzlzWlNCd2IybHVkQ0JpWldocGJtUWdkR2hwY3lCcGJuUmxjbTVoYkNCdGIyUjFiR1VnYVhNZ2RHOGdZV3hzYjNjZ1RtOWtaUzVxY3lCMGJ5QnViMXh1THk4Z2JHOXVaMlZ5SUdKbElHWnZjbU5sWkNCMGJ5QjBjbVZoZENCbGRtVnllU0JsY25KdmNpQnRaWE56WVdkbElHTm9ZVzVuWlNCaGN5QmhJSE5sYlhabGNpMXRZV3B2Y2x4dUx5OGdZMmhoYm1kbExpQlVhR1VnVG05a1pVVnljbTl5SUdOc1lYTnpaWE1nYUdWeVpTQmhiR3dnWlhod2IzTmxJR0VnWUdOdlpHVmdJSEJ5YjNCbGNuUjVJSGRvYjNObFhHNHZMeUIyWVd4MVpTQnpkR0YwYVdOaGJHeDVJR0Z1WkNCd1pYSnRZVzVsYm5Sc2VTQnBaR1Z1ZEdsbWFXVnpJSFJvWlNCbGNuSnZjaTRnVjJocGJHVWdkR2hsSUdWeWNtOXlYRzR2THlCdFpYTnpZV2RsSUcxaGVTQmphR0Z1WjJVc0lIUm9aU0JqYjJSbElITm9iM1ZzWkNCdWIzUXVYRzVjYm1aMWJtTjBhVzl1SUY5MGVYQmxiMllvYjJKcUtTQjdJR2xtSUNoMGVYQmxiMllnVTNsdFltOXNJRDA5UFNCY0ltWjFibU4wYVc5dVhDSWdKaVlnZEhsd1pXOW1JRk41YldKdmJDNXBkR1Z5WVhSdmNpQTlQVDBnWENKemVXMWliMnhjSWlrZ2V5QmZkSGx3Wlc5bUlEMGdablZ1WTNScGIyNGdYM1I1Y0dWdlppaHZZbW9wSUhzZ2NtVjBkWEp1SUhSNWNHVnZaaUJ2WW1vN0lIMDdJSDBnWld4elpTQjdJRjkwZVhCbGIyWWdQU0JtZFc1amRHbHZiaUJmZEhsd1pXOW1LRzlpYWlrZ2V5QnlaWFIxY200Z2IySnFJQ1ltSUhSNWNHVnZaaUJUZVcxaWIyd2dQVDA5SUZ3aVpuVnVZM1JwYjI1Y0lpQW1KaUJ2WW1vdVkyOXVjM1J5ZFdOMGIzSWdQVDA5SUZONWJXSnZiQ0FtSmlCdlltb2dJVDA5SUZONWJXSnZiQzV3Y205MGIzUjVjR1VnUHlCY0luTjViV0p2YkZ3aUlEb2dkSGx3Wlc5bUlHOWlhanNnZlRzZ2ZTQnlaWFIxY200Z1gzUjVjR1Z2Wmlodlltb3BPeUI5WEc1Y2JtWjFibU4wYVc5dUlGOWpiR0Z6YzBOaGJHeERhR1ZqYXlocGJuTjBZVzVqWlN3Z1EyOXVjM1J5ZFdOMGIzSXBJSHNnYVdZZ0tDRW9hVzV6ZEdGdVkyVWdhVzV6ZEdGdVkyVnZaaUJEYjI1emRISjFZM1J2Y2lrcElIc2dkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWhjSWtOaGJtNXZkQ0JqWVd4c0lHRWdZMnhoYzNNZ1lYTWdZU0JtZFc1amRHbHZibHdpS1RzZ2ZTQjlYRzVjYm1aMWJtTjBhVzl1SUY5d2IzTnphV0pzWlVOdmJuTjBjblZqZEc5eVVtVjBkWEp1S0hObGJHWXNJR05oYkd3cElIc2dhV1lnS0dOaGJHd2dKaVlnS0Y5MGVYQmxiMllvWTJGc2JDa2dQVDA5SUZ3aWIySnFaV04wWENJZ2ZId2dkSGx3Wlc5bUlHTmhiR3dnUFQwOUlGd2lablZ1WTNScGIyNWNJaWtwSUhzZ2NtVjBkWEp1SUdOaGJHdzdJSDBnY21WMGRYSnVJRjloYzNObGNuUlVhR2x6U1c1cGRHbGhiR2w2WldRb2MyVnNaaWs3SUgxY2JseHVablZ1WTNScGIyNGdYMkZ6YzJWeWRGUm9hWE5KYm1sMGFXRnNhWHBsWkNoelpXeG1LU0I3SUdsbUlDaHpaV3htSUQwOVBTQjJiMmxrSURBcElIc2dkR2h5YjNjZ2JtVjNJRkpsWm1WeVpXNWpaVVZ5Y205eUtGd2lkR2hwY3lCb1lYTnVKM1FnWW1WbGJpQnBibWwwYVdGc2FYTmxaQ0F0SUhOMWNHVnlLQ2tnYUdGemJpZDBJR0psWlc0Z1kyRnNiR1ZrWENJcE95QjlJSEpsZEhWeWJpQnpaV3htT3lCOVhHNWNibVoxYm1OMGFXOXVJRjluWlhSUWNtOTBiM1I1Y0dWUFppaHZLU0I3SUY5blpYUlFjbTkwYjNSNWNHVlBaaUE5SUU5aWFtVmpkQzV6WlhSUWNtOTBiM1I1Y0dWUFppQS9JRTlpYW1WamRDNW5aWFJRY205MGIzUjVjR1ZQWmlBNklHWjFibU4wYVc5dUlGOW5aWFJRY205MGIzUjVjR1ZQWmlodktTQjdJSEpsZEhWeWJpQnZMbDlmY0hKdmRHOWZYeUI4ZkNCUFltcGxZM1F1WjJWMFVISnZkRzkwZVhCbFQyWW9ieWs3SUgwN0lISmxkSFZ5YmlCZloyVjBVSEp2ZEc5MGVYQmxUMllvYnlrN0lIMWNibHh1Wm5WdVkzUnBiMjRnWDJsdWFHVnlhWFJ6S0hOMVlrTnNZWE56TENCemRYQmxja05zWVhOektTQjdJR2xtSUNoMGVYQmxiMllnYzNWd1pYSkRiR0Z6Y3lBaFBUMGdYQ0ptZFc1amRHbHZibHdpSUNZbUlITjFjR1Z5UTJ4aGMzTWdJVDA5SUc1MWJHd3BJSHNnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2loY0lsTjFjR1Z5SUdWNGNISmxjM05wYjI0Z2JYVnpkQ0JsYVhSb1pYSWdZbVVnYm5Wc2JDQnZjaUJoSUdaMWJtTjBhVzl1WENJcE95QjlJSE4xWWtOc1lYTnpMbkJ5YjNSdmRIbHdaU0E5SUU5aWFtVmpkQzVqY21WaGRHVW9jM1Z3WlhKRGJHRnpjeUFtSmlCemRYQmxja05zWVhOekxuQnliM1J2ZEhsd1pTd2dleUJqYjI1emRISjFZM1J2Y2pvZ2V5QjJZV3gxWlRvZ2MzVmlRMnhoYzNNc0lIZHlhWFJoWW14bE9pQjBjblZsTENCamIyNW1hV2QxY21GaWJHVTZJSFJ5ZFdVZ2ZTQjlLVHNnYVdZZ0tITjFjR1Z5UTJ4aGMzTXBJRjl6WlhSUWNtOTBiM1I1Y0dWUFppaHpkV0pEYkdGemN5d2djM1Z3WlhKRGJHRnpjeWs3SUgxY2JseHVablZ1WTNScGIyNGdYM05sZEZCeWIzUnZkSGx3WlU5bUtHOHNJSEFwSUhzZ1gzTmxkRkJ5YjNSdmRIbHdaVTltSUQwZ1QySnFaV04wTG5ObGRGQnliM1J2ZEhsd1pVOW1JSHg4SUdaMWJtTjBhVzl1SUY5elpYUlFjbTkwYjNSNWNHVlBaaWh2TENCd0tTQjdJRzh1WDE5d2NtOTBiMTlmSUQwZ2NEc2djbVYwZFhKdUlHODdJSDA3SUhKbGRIVnliaUJmYzJWMFVISnZkRzkwZVhCbFQyWW9ieXdnY0NrN0lIMWNibHh1ZG1GeUlHTnZaR1Z6SUQwZ2UzMDdJQzh2SUV4aGVua2diRzloWkdWa1hHNWNiblpoY2lCaGMzTmxjblE3WEc1MllYSWdkWFJwYkR0Y2JseHVablZ1WTNScGIyNGdZM0psWVhSbFJYSnliM0pVZVhCbEtHTnZaR1VzSUcxbGMzTmhaMlVzSUVKaGMyVXBJSHRjYmlBZ2FXWWdLQ0ZDWVhObEtTQjdYRzRnSUNBZ1FtRnpaU0E5SUVWeWNtOXlPMXh1SUNCOVhHNWNiaUFnWm5WdVkzUnBiMjRnWjJWMFRXVnpjMkZuWlNoaGNtY3hMQ0JoY21jeUxDQmhjbWN6S1NCN1hHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCdFpYTnpZV2RsSUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHMWxjM05oWjJVN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQnRaWE56WVdkbEtHRnlaekVzSUdGeVp6SXNJR0Z5WnpNcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lIWmhjaUJPYjJSbFJYSnliM0lnUFZ4dUlDQXZLaU5mWDFCVlVrVmZYeW92WEc0Z0lHWjFibU4wYVc5dUlDaGZRbUZ6WlNrZ2UxeHVJQ0FnSUY5cGJtaGxjbWwwY3loT2IyUmxSWEp5YjNJc0lGOUNZWE5sS1R0Y2JseHVJQ0FnSUdaMWJtTjBhVzl1SUU1dlpHVkZjbkp2Y2loaGNtY3hMQ0JoY21jeUxDQmhjbWN6S1NCN1hHNGdJQ0FnSUNCMllYSWdYM1JvYVhNN1hHNWNiaUFnSUNBZ0lGOWpiR0Z6YzBOaGJHeERhR1ZqYXloMGFHbHpMQ0JPYjJSbFJYSnliM0lwTzF4dVhHNGdJQ0FnSUNCZmRHaHBjeUE5SUY5d2IzTnphV0pzWlVOdmJuTjBjblZqZEc5eVVtVjBkWEp1S0hSb2FYTXNJRjluWlhSUWNtOTBiM1I1Y0dWUFppaE9iMlJsUlhKeWIzSXBMbU5oYkd3b2RHaHBjeXdnWjJWMFRXVnpjMkZuWlNoaGNtY3hMQ0JoY21jeUxDQmhjbWN6S1NrcE8xeHVJQ0FnSUNBZ1gzUm9hWE11WTI5a1pTQTlJR052WkdVN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWDNSb2FYTTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUU1dlpHVkZjbkp2Y2p0Y2JpQWdmU2hDWVhObEtUdGNibHh1SUNCamIyUmxjMXRqYjJSbFhTQTlJRTV2WkdWRmNuSnZjanRjYm4wZ0x5OGdhSFIwY0hNNkx5OW5hWFJvZFdJdVkyOXRMMjV2WkdWcWN5OXViMlJsTDJKc2IySXZkakV3TGpndU1DOXNhV0l2YVc1MFpYSnVZV3d2WlhKeWIzSnpMbXB6WEc1Y2JseHVablZ1WTNScGIyNGdiMjVsVDJZb1pYaHdaV04wWldRc0lIUm9hVzVuS1NCN1hHNGdJR2xtSUNoQmNuSmhlUzVwYzBGeWNtRjVLR1Y0Y0dWamRHVmtLU2tnZTF4dUlDQWdJSFpoY2lCc1pXNGdQU0JsZUhCbFkzUmxaQzVzWlc1bmRHZzdYRzRnSUNBZ1pYaHdaV04wWldRZ1BTQmxlSEJsWTNSbFpDNXRZWEFvWm5WdVkzUnBiMjRnS0drcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCVGRISnBibWNvYVNrN1hHNGdJQ0FnZlNrN1hHNWNiaUFnSUNCcFppQW9iR1Z1SUQ0Z01pa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlGd2liMjVsSUc5bUlGd2lMbU52Ym1OaGRDaDBhR2x1Wnl3Z1hDSWdYQ0lwTG1OdmJtTmhkQ2hsZUhCbFkzUmxaQzV6YkdsalpTZ3dMQ0JzWlc0Z0xTQXhLUzVxYjJsdUtDY3NJQ2NwTENCY0lpd2diM0lnWENJcElDc2daWGh3WldOMFpXUmJiR1Z1SUMwZ01WMDdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHNaVzRnUFQwOUlESXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmNJbTl1WlNCdlppQmNJaTVqYjI1allYUW9kR2hwYm1jc0lGd2lJRndpS1M1amIyNWpZWFFvWlhod1pXTjBaV1JiTUYwc0lGd2lJRzl5SUZ3aUtTNWpiMjVqWVhRb1pYaHdaV04wWldSYk1WMHBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWENKdlppQmNJaTVqYjI1allYUW9kR2hwYm1jc0lGd2lJRndpS1M1amIyNWpZWFFvWlhod1pXTjBaV1JiTUYwcE8xeHVJQ0FnSUgxY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCeVpYUjFjbTRnWENKdlppQmNJaTVqYjI1allYUW9kR2hwYm1jc0lGd2lJRndpS1M1amIyNWpZWFFvVTNSeWFXNW5LR1Y0Y0dWamRHVmtLU2s3WEc0Z0lIMWNibjBnTHk4Z2FIUjBjSE02THk5a1pYWmxiRzl3WlhJdWJXOTZhV3hzWVM1dmNtY3ZaVzR0VlZNdlpHOWpjeTlYWldJdlNtRjJZVk5qY21sd2RDOVNaV1psY21WdVkyVXZSMnh2WW1Gc1gwOWlhbVZqZEhNdlUzUnlhVzVuTDNOMFlYSjBjMWRwZEdoY2JseHVYRzVtZFc1amRHbHZiaUJ6ZEdGeWRITlhhWFJvS0hOMGNpd2djMlZoY21Ob0xDQndiM01wSUh0Y2JpQWdjbVYwZFhKdUlITjBjaTV6ZFdKemRISW9JWEJ2Y3lCOGZDQndiM01nUENBd0lEOGdNQ0E2SUN0d2IzTXNJSE5sWVhKamFDNXNaVzVuZEdncElEMDlQU0J6WldGeVkyZzdYRzU5SUM4dklHaDBkSEJ6T2k4dlpHVjJaV3h2Y0dWeUxtMXZlbWxzYkdFdWIzSm5MMlZ1TFZWVEwyUnZZM012VjJWaUwwcGhkbUZUWTNKcGNIUXZVbVZtWlhKbGJtTmxMMGRzYjJKaGJGOVBZbXBsWTNSekwxTjBjbWx1Wnk5bGJtUnpWMmwwYUZ4dVhHNWNibVoxYm1OMGFXOXVJR1Z1WkhOWGFYUm9LSE4wY2l3Z2MyVmhjbU5vTENCMGFHbHpYMnhsYmlrZ2UxeHVJQ0JwWmlBb2RHaHBjMTlzWlc0Z1BUMDlJSFZ1WkdWbWFXNWxaQ0I4ZkNCMGFHbHpYMnhsYmlBK0lITjBjaTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQjBhR2x6WDJ4bGJpQTlJSE4wY2k1c1pXNW5kR2c3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnYzNSeUxuTjFZbk4wY21sdVp5aDBhR2x6WDJ4bGJpQXRJSE5sWVhKamFDNXNaVzVuZEdnc0lIUm9hWE5mYkdWdUtTQTlQVDBnYzJWaGNtTm9PMXh1ZlNBdkx5Qm9kSFJ3Y3pvdkwyUmxkbVZzYjNCbGNpNXRiM3BwYkd4aExtOXlaeTlsYmkxVlV5OWtiMk56TDFkbFlpOUtZWFpoVTJOeWFYQjBMMUpsWm1WeVpXNWpaUzlIYkc5aVlXeGZUMkpxWldOMGN5OVRkSEpwYm1jdmFXNWpiSFZrWlhOY2JseHVYRzVtZFc1amRHbHZiaUJwYm1Oc2RXUmxjeWh6ZEhJc0lITmxZWEpqYUN3Z2MzUmhjblFwSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUJ6ZEdGeWRDQWhQVDBnSjI1MWJXSmxjaWNwSUh0Y2JpQWdJQ0J6ZEdGeWRDQTlJREE3WEc0Z0lIMWNibHh1SUNCcFppQW9jM1JoY25RZ0t5QnpaV0Z5WTJndWJHVnVaM1JvSUQ0Z2MzUnlMbXhsYm1kMGFDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J5WlhSMWNtNGdjM1J5TG1sdVpHVjRUMllvYzJWaGNtTm9MQ0J6ZEdGeWRDa2dJVDA5SUMweE8xeHVJQ0I5WEc1OVhHNWNibU55WldGMFpVVnljbTl5Vkhsd1pTZ25SVkpTWDBGTlFrbEhWVTlWVTE5QlVrZFZUVVZPVkNjc0lDZFVhR1VnWENJbGMxd2lJR0Z5WjNWdFpXNTBJR2x6SUdGdFltbG5kVzkxY3k0Z0pYTW5MQ0JVZVhCbFJYSnliM0lwTzF4dVkzSmxZWFJsUlhKeWIzSlVlWEJsS0NkRlVsSmZTVTVXUVV4SlJGOUJVa2RmVkZsUVJTY3NJR1oxYm1OMGFXOXVJQ2h1WVcxbExDQmxlSEJsWTNSbFpDd2dZV04wZFdGc0tTQjdYRzRnSUdsbUlDaGhjM05sY25RZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnWVhOelpYSjBJRDBnY21WeGRXbHlaU2duTGk0dllYTnpaWEowSnlrN1hHNGdJR0Z6YzJWeWRDaDBlWEJsYjJZZ2JtRnRaU0E5UFQwZ0ozTjBjbWx1Wnljc0lGd2lKMjVoYldVbklHMTFjM1FnWW1VZ1lTQnpkSEpwYm1kY0lpazdJQzh2SUdSbGRHVnliV2x1WlhJNklDZHRkWE4wSUdKbEp5QnZjaUFuYlhWemRDQnViM1FnWW1VblhHNWNiaUFnZG1GeUlHUmxkR1Z5YldsdVpYSTdYRzVjYmlBZ2FXWWdLSFI1Y0dWdlppQmxlSEJsWTNSbFpDQTlQVDBnSjNOMGNtbHVaeWNnSmlZZ2MzUmhjblJ6VjJsMGFDaGxlSEJsWTNSbFpDd2dKMjV2ZENBbktTa2dlMXh1SUNBZ0lHUmxkR1Z5YldsdVpYSWdQU0FuYlhWemRDQnViM1FnWW1Vbk8xeHVJQ0FnSUdWNGNHVmpkR1ZrSUQwZ1pYaHdaV04wWldRdWNtVndiR0ZqWlNndlhtNXZkQ0F2TENBbkp5azdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdaR1YwWlhKdGFXNWxjaUE5SUNkdGRYTjBJR0psSnp0Y2JpQWdmVnh1WEc0Z0lIWmhjaUJ0YzJjN1hHNWNiaUFnYVdZZ0tHVnVaSE5YYVhSb0tHNWhiV1VzSUNjZ1lYSm5kVzFsYm5RbktTa2dlMXh1SUNBZ0lDOHZJRVp2Y2lCallYTmxjeUJzYVd0bElDZG1hWEp6ZENCaGNtZDFiV1Z1ZENkY2JpQWdJQ0J0YzJjZ1BTQmNJbFJvWlNCY0lpNWpiMjVqWVhRb2JtRnRaU3dnWENJZ1hDSXBMbU52Ym1OaGRDaGtaWFJsY20xcGJtVnlMQ0JjSWlCY0lpa3VZMjl1WTJGMEtHOXVaVTltS0dWNGNHVmpkR1ZrTENBbmRIbHdaU2NwS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCMllYSWdkSGx3WlNBOUlHbHVZMngxWkdWektHNWhiV1VzSUNjdUp5a2dQeUFuY0hKdmNHVnlkSGtuSURvZ0oyRnlaM1Z0Wlc1MEp6dGNiaUFnSUNCdGMyY2dQU0JjSWxSb1pTQmNYRndpWENJdVkyOXVZMkYwS0c1aGJXVXNJRndpWEZ4Y0lpQmNJaWt1WTI5dVkyRjBLSFI1Y0dVc0lGd2lJRndpS1M1amIyNWpZWFFvWkdWMFpYSnRhVzVsY2l3Z1hDSWdYQ0lwTG1OdmJtTmhkQ2h2Ym1WUFppaGxlSEJsWTNSbFpDd2dKM1I1Y0dVbktTazdYRzRnSUgwZ0x5OGdWRTlFVHloQ2NtbGtaMlZCVWlrNklFbHRjSEp2ZG1VZ2RHaGxJRzkxZEhCMWRDQmllU0J6YUc5M2FXNW5JR0J1ZFd4c1lDQmhibVFnYzJsdGFXeGhjaTVjYmx4dVhHNGdJRzF6WnlBclBTQmNJaTRnVW1WalpXbDJaV1FnZEhsd1pTQmNJaTVqYjI1allYUW9YM1I1Y0dWdlppaGhZM1IxWVd3cEtUdGNiaUFnY21WMGRYSnVJRzF6Wnp0Y2JuMHNJRlI1Y0dWRmNuSnZjaWs3WEc1amNtVmhkR1ZGY25KdmNsUjVjR1VvSjBWU1VsOUpUbFpCVEVsRVgwRlNSMTlXUVV4VlJTY3NJR1oxYm1OMGFXOXVJQ2h1WVcxbExDQjJZV3gxWlNrZ2UxeHVJQ0IyWVhJZ2NtVmhjMjl1SUQwZ1lYSm5kVzFsYm5SekxteGxibWQwYUNBK0lESWdKaVlnWVhKbmRXMWxiblJ6V3pKZElDRTlQU0IxYm1SbFptbHVaV1FnUHlCaGNtZDFiV1Z1ZEhOYk1sMGdPaUFuYVhNZ2FXNTJZV3hwWkNjN1hHNGdJR2xtSUNoMWRHbHNJRDA5UFNCMWJtUmxabWx1WldRcElIVjBhV3dnUFNCeVpYRjFhWEpsS0NkMWRHbHNMeWNwTzF4dUlDQjJZWElnYVc1emNHVmpkR1ZrSUQwZ2RYUnBiQzVwYm5Od1pXTjBLSFpoYkhWbEtUdGNibHh1SUNCcFppQW9hVzV6Y0dWamRHVmtMbXhsYm1kMGFDQStJREV5T0NrZ2UxeHVJQ0FnSUdsdWMzQmxZM1JsWkNBOUlGd2lYQ0l1WTI5dVkyRjBLR2x1YzNCbFkzUmxaQzV6YkdsalpTZ3dMQ0F4TWpncExDQmNJaTR1TGx3aUtUdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQmNJbFJvWlNCaGNtZDFiV1Z1ZENBblhDSXVZMjl1WTJGMEtHNWhiV1VzSUZ3aUp5QmNJaWt1WTI5dVkyRjBLSEpsWVhOdmJpd2dYQ0l1SUZKbFkyVnBkbVZrSUZ3aUtTNWpiMjVqWVhRb2FXNXpjR1ZqZEdWa0tUdGNibjBzSUZSNWNHVkZjbkp2Y2l3Z1VtRnVaMlZGY25KdmNpazdYRzVqY21WaGRHVkZjbkp2Y2xSNWNHVW9KMFZTVWw5SlRsWkJURWxFWDFKRlZGVlNUbDlXUVV4VlJTY3NJR1oxYm1OMGFXOXVJQ2hwYm5CMWRDd2dibUZ0WlN3Z2RtRnNkV1VwSUh0Y2JpQWdkbUZ5SUhSNWNHVTdYRzVjYmlBZ2FXWWdLSFpoYkhWbElDWW1JSFpoYkhWbExtTnZibk4wY25WamRHOXlJQ1ltSUhaaGJIVmxMbU52Ym5OMGNuVmpkRzl5TG01aGJXVXBJSHRjYmlBZ0lDQjBlWEJsSUQwZ1hDSnBibk4wWVc1alpTQnZaaUJjSWk1amIyNWpZWFFvZG1Gc2RXVXVZMjl1YzNSeWRXTjBiM0l1Ym1GdFpTazdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdkSGx3WlNBOUlGd2lkSGx3WlNCY0lpNWpiMjVqWVhRb1gzUjVjR1Z2WmloMllXeDFaU2twTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUZ3aVJYaHdaV04wWldRZ1hDSXVZMjl1WTJGMEtHbHVjSFYwTENCY0lpQjBieUJpWlNCeVpYUjFjbTVsWkNCbWNtOXRJSFJvWlNCY1hGd2lYQ0lwTG1OdmJtTmhkQ2h1WVcxbExDQmNJbHhjWENKY0lpa2dLeUJjSWlCbWRXNWpkR2x2YmlCaWRYUWdaMjkwSUZ3aUxtTnZibU5oZENoMGVYQmxMQ0JjSWk1Y0lpazdYRzU5TENCVWVYQmxSWEp5YjNJcE8xeHVZM0psWVhSbFJYSnliM0pVZVhCbEtDZEZVbEpmVFVsVFUwbE9SMTlCVWtkVEp5d2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQm1iM0lnS0haaGNpQmZiR1Z1SUQwZ1lYSm5kVzFsYm5SekxteGxibWQwYUN3Z1lYSm5jeUE5SUc1bGR5QkJjbkpoZVNoZmJHVnVLU3dnWDJ0bGVTQTlJREE3SUY5clpYa2dQQ0JmYkdWdU95QmZhMlY1S3lzcElIdGNiaUFnSUNCaGNtZHpXMTlyWlhsZElEMGdZWEpuZFcxbGJuUnpXMTlyWlhsZE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0dGemMyVnlkQ0E5UFQwZ2RXNWtaV1pwYm1Wa0tTQmhjM05sY25RZ1BTQnlaWEYxYVhKbEtDY3VMaTloYzNObGNuUW5LVHRjYmlBZ1lYTnpaWEowS0dGeVozTXViR1Z1WjNSb0lENGdNQ3dnSjBGMElHeGxZWE4wSUc5dVpTQmhjbWNnYm1WbFpITWdkRzhnWW1VZ2MzQmxZMmxtYVdWa0p5azdYRzRnSUhaaGNpQnRjMmNnUFNBblZHaGxJQ2M3WEc0Z0lIWmhjaUJzWlc0Z1BTQmhjbWR6TG14bGJtZDBhRHRjYmlBZ1lYSm5jeUE5SUdGeVozTXViV0Z3S0daMWJtTjBhVzl1SUNoaEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUZ3aVhGeGNJbHdpTG1OdmJtTmhkQ2hoTENCY0lseGNYQ0pjSWlrN1hHNGdJSDBwTzF4dVhHNGdJSE4zYVhSamFDQW9iR1Z1S1NCN1hHNGdJQ0FnWTJGelpTQXhPbHh1SUNBZ0lDQWdiWE5uSUNzOUlGd2lYQ0l1WTI5dVkyRjBLR0Z5WjNOYk1GMHNJRndpSUdGeVozVnRaVzUwWENJcE8xeHVJQ0FnSUNBZ1luSmxZV3M3WEc1Y2JpQWdJQ0JqWVhObElESTZYRzRnSUNBZ0lDQnRjMmNnS3owZ1hDSmNJaTVqYjI1allYUW9ZWEpuYzFzd1hTd2dYQ0lnWVc1a0lGd2lLUzVqYjI1allYUW9ZWEpuYzFzeFhTd2dYQ0lnWVhKbmRXMWxiblJ6WENJcE8xeHVJQ0FnSUNBZ1luSmxZV3M3WEc1Y2JpQWdJQ0JrWldaaGRXeDBPbHh1SUNBZ0lDQWdiWE5uSUNzOUlHRnlaM011YzJ4cFkyVW9NQ3dnYkdWdUlDMGdNU2t1YW05cGJpZ25MQ0FuS1R0Y2JpQWdJQ0FnSUcxelp5QXJQU0JjSWl3Z1lXNWtJRndpTG1OdmJtTmhkQ2hoY21kelcyeGxiaUF0SURGZExDQmNJaUJoY21kMWJXVnVkSE5jSWlrN1hHNGdJQ0FnSUNCaWNtVmhhenRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJjSWx3aUxtTnZibU5oZENodGMyY3NJRndpSUcxMWMzUWdZbVVnYzNCbFkybG1hV1ZrWENJcE8xeHVmU3dnVkhsd1pVVnljbTl5S1R0Y2JtMXZaSFZzWlM1bGVIQnZjblJ6TG1OdlpHVnpJRDBnWTI5a1pYTTdJaXdpTHk4Z1EzVnljbVZ1ZEd4NUlHbHVJSE41Ym1NZ2QybDBhQ0JPYjJSbExtcHpJR3hwWWk5cGJuUmxjbTVoYkM5MWRHbHNMMk52YlhCaGNtbHpiMjV6TG1welhHNHZMeUJvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ym05a1pXcHpMMjV2WkdVdlkyOXRiV2wwTHpFeE1tTmpOMk15TnpVMU1USTFOR0ZoTW1JeE56QTVPR1ppTnpjME9EWTNaakExWldRd1pEbGNiaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVablZ1WTNScGIyNGdYM05zYVdObFpGUnZRWEp5WVhrb1lYSnlMQ0JwS1NCN0lISmxkSFZ5YmlCZllYSnlZWGxYYVhSb1NHOXNaWE1vWVhKeUtTQjhmQ0JmYVhSbGNtRmliR1ZVYjBGeWNtRjVUR2x0YVhRb1lYSnlMQ0JwS1NCOGZDQmZibTl1U1hSbGNtRmliR1ZTWlhOMEtDazdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gyNXZia2wwWlhKaFlteGxVbVZ6ZENncElIc2dkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWhjSWtsdWRtRnNhV1FnWVhSMFpXMXdkQ0IwYnlCa1pYTjBjblZqZEhWeVpTQnViMjR0YVhSbGNtRmliR1VnYVc1emRHRnVZMlZjSWlrN0lIMWNibHh1Wm5WdVkzUnBiMjRnWDJsMFpYSmhZbXhsVkc5QmNuSmhlVXhwYldsMEtHRnljaXdnYVNrZ2V5QjJZWElnWDJGeWNpQTlJRnRkT3lCMllYSWdYMjRnUFNCMGNuVmxPeUIyWVhJZ1gyUWdQU0JtWVd4elpUc2dkbUZ5SUY5bElEMGdkVzVrWldacGJtVmtPeUIwY25rZ2V5Qm1iM0lnS0haaGNpQmZhU0E5SUdGeWNsdFRlVzFpYjJ3dWFYUmxjbUYwYjNKZEtDa3NJRjl6T3lBaEtGOXVJRDBnS0Y5eklEMGdYMmt1Ym1WNGRDZ3BLUzVrYjI1bEtUc2dYMjRnUFNCMGNuVmxLU0I3SUY5aGNuSXVjSFZ6YUNoZmN5NTJZV3gxWlNrN0lHbG1JQ2hwSUNZbUlGOWhjbkl1YkdWdVozUm9JRDA5UFNCcEtTQmljbVZoYXpzZ2ZTQjlJR05oZEdOb0lDaGxjbklwSUhzZ1gyUWdQU0IwY25WbE95QmZaU0E5SUdWeWNqc2dmU0JtYVc1aGJHeDVJSHNnZEhKNUlIc2dhV1lnS0NGZmJpQW1KaUJmYVZ0Y0luSmxkSFZ5Ymx3aVhTQWhQU0J1ZFd4c0tTQmZhVnRjSW5KbGRIVnlibHdpWFNncE95QjlJR1pwYm1Gc2JIa2dleUJwWmlBb1gyUXBJSFJvY205M0lGOWxPeUI5SUgwZ2NtVjBkWEp1SUY5aGNuSTdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gyRnljbUY1VjJsMGFFaHZiR1Z6S0dGeWNpa2dleUJwWmlBb1FYSnlZWGt1YVhOQmNuSmhlU2hoY25JcEtTQnlaWFIxY200Z1lYSnlPeUI5WEc1Y2JtWjFibU4wYVc5dUlGOTBlWEJsYjJZb2IySnFLU0I3SUdsbUlDaDBlWEJsYjJZZ1UzbHRZbTlzSUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lnSmlZZ2RIbHdaVzltSUZONWJXSnZiQzVwZEdWeVlYUnZjaUE5UFQwZ1hDSnplVzFpYjJ4Y0lpa2dleUJmZEhsd1pXOW1JRDBnWm5WdVkzUnBiMjRnWDNSNWNHVnZaaWh2WW1vcElIc2djbVYwZFhKdUlIUjVjR1Z2WmlCdlltbzdJSDA3SUgwZ1pXeHpaU0I3SUY5MGVYQmxiMllnUFNCbWRXNWpkR2x2YmlCZmRIbHdaVzltS0c5aWFpa2dleUJ5WlhSMWNtNGdiMkpxSUNZbUlIUjVjR1Z2WmlCVGVXMWliMndnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCdlltb3VZMjl1YzNSeWRXTjBiM0lnUFQwOUlGTjViV0p2YkNBbUppQnZZbW9nSVQwOUlGTjViV0p2YkM1d2NtOTBiM1I1Y0dVZ1B5QmNJbk41YldKdmJGd2lJRG9nZEhsd1pXOW1JRzlpYWpzZ2ZUc2dmU0J5WlhSMWNtNGdYM1I1Y0dWdlppaHZZbW9wT3lCOVhHNWNiblpoY2lCeVpXZGxlRVpzWVdkelUzVndjRzl5ZEdWa0lEMGdMMkV2Wnk1bWJHRm5jeUFoUFQwZ2RXNWtaV1pwYm1Wa08xeHVYRzUyWVhJZ1lYSnlZWGxHY205dFUyVjBJRDBnWm5WdVkzUnBiMjRnWVhKeVlYbEdjbTl0VTJWMEtITmxkQ2tnZTF4dUlDQjJZWElnWVhKeVlYa2dQU0JiWFR0Y2JpQWdjMlYwTG1admNrVmhZMmdvWm5WdVkzUnBiMjRnS0haaGJIVmxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHRnljbUY1TG5CMWMyZ29kbUZzZFdVcE8xeHVJQ0I5S1R0Y2JpQWdjbVYwZFhKdUlHRnljbUY1TzF4dWZUdGNibHh1ZG1GeUlHRnljbUY1Um5KdmJVMWhjQ0E5SUdaMWJtTjBhVzl1SUdGeWNtRjVSbkp2YlUxaGNDaHRZWEFwSUh0Y2JpQWdkbUZ5SUdGeWNtRjVJRDBnVzEwN1hHNGdJRzFoY0M1bWIzSkZZV05vS0daMWJtTjBhVzl1SUNoMllXeDFaU3dnYTJWNUtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdGeWNtRjVMbkIxYzJnb1cydGxlU3dnZG1Gc2RXVmRLVHRjYmlBZ2ZTazdYRzRnSUhKbGRIVnliaUJoY25KaGVUdGNibjA3WEc1Y2JuWmhjaUJ2WW1wbFkzUkpjeUE5SUU5aWFtVmpkQzVwY3lBL0lFOWlhbVZqZEM1cGN5QTZJSEpsY1hWcGNtVW9KMjlpYW1WamRDMXBjeWNwTzF4dWRtRnlJRzlpYW1WamRFZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjeUE5SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNZ1B5QlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxUZVcxaWIyeHpJRG9nWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0J5WlhSMWNtNGdXMTA3WEc1OU8xeHVkbUZ5SUc1MWJXSmxja2x6VG1GT0lEMGdUblZ0WW1WeUxtbHpUbUZPSUQ4Z1RuVnRZbVZ5TG1selRtRk9JRG9nY21WeGRXbHlaU2duYVhNdGJtRnVKeWs3WEc1Y2JtWjFibU4wYVc5dUlIVnVZM1Z5Y25sVWFHbHpLR1lwSUh0Y2JpQWdjbVYwZFhKdUlHWXVZMkZzYkM1aWFXNWtLR1lwTzF4dWZWeHVYRzUyWVhJZ2FHRnpUM2R1VUhKdmNHVnlkSGtnUFNCMWJtTjFjbko1VkdocGN5aFBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1S1R0Y2JuWmhjaUJ3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlNBOUlIVnVZM1Z5Y25sVWFHbHpLRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVjSEp2Y0dWeWRIbEpjMFZ1ZFcxbGNtRmliR1VwTzF4dWRtRnlJRzlpYW1WamRGUnZVM1J5YVc1bklEMGdkVzVqZFhKeWVWUm9hWE1vVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaeWs3WEc1Y2JuWmhjaUJmY21WeGRXbHlaU1IwZVhCbGN5QTlJSEpsY1hWcGNtVW9KM1YwYVd3dkp5a3VkSGx3WlhNc1hHNGdJQ0FnYVhOQmJubEJjbkpoZVVKMVptWmxjaUE5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6UVc1NVFYSnlZWGxDZFdabVpYSXNYRzRnSUNBZ2FYTkJjbkpoZVVKMVptWmxjbFpwWlhjZ1BTQmZjbVZ4ZFdseVpTUjBlWEJsY3k1cGMwRnljbUY1UW5WbVptVnlWbWxsZHl4Y2JpQWdJQ0JwYzBSaGRHVWdQU0JmY21WeGRXbHlaU1IwZVhCbGN5NXBjMFJoZEdVc1hHNGdJQ0FnYVhOTllYQWdQU0JmY21WeGRXbHlaU1IwZVhCbGN5NXBjMDFoY0N4Y2JpQWdJQ0JwYzFKbFowVjRjQ0E5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6VW1WblJYaHdMRnh1SUNBZ0lHbHpVMlYwSUQwZ1gzSmxjWFZwY21Va2RIbHdaWE11YVhOVFpYUXNYRzRnSUNBZ2FYTk9ZWFJwZG1WRmNuSnZjaUE5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6VG1GMGFYWmxSWEp5YjNJc1hHNGdJQ0FnYVhOQ2IzaGxaRkJ5YVcxcGRHbDJaU0E5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6UW05NFpXUlFjbWx0YVhScGRtVXNYRzRnSUNBZ2FYTk9kVzFpWlhKUFltcGxZM1FnUFNCZmNtVnhkV2x5WlNSMGVYQmxjeTVwYzA1MWJXSmxjazlpYW1WamRDeGNiaUFnSUNCcGMxTjBjbWx1WjA5aWFtVmpkQ0E5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6VTNSeWFXNW5UMkpxWldOMExGeHVJQ0FnSUdselFtOXZiR1ZoYms5aWFtVmpkQ0E5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6UW05dmJHVmhiazlpYW1WamRDeGNiaUFnSUNCcGMwSnBaMGx1ZEU5aWFtVmpkQ0E5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6UW1sblNXNTBUMkpxWldOMExGeHVJQ0FnSUdselUzbHRZbTlzVDJKcVpXTjBJRDBnWDNKbGNYVnBjbVVrZEhsd1pYTXVhWE5UZVcxaWIyeFBZbXBsWTNRc1hHNGdJQ0FnYVhOR2JHOWhkRE15UVhKeVlYa2dQU0JmY21WeGRXbHlaU1IwZVhCbGN5NXBjMFpzYjJGME16SkJjbkpoZVN4Y2JpQWdJQ0JwYzBac2IyRjBOalJCY25KaGVTQTlJRjl5WlhGMWFYSmxKSFI1Y0dWekxtbHpSbXh2WVhRMk5FRnljbUY1TzF4dVhHNW1kVzVqZEdsdmJpQnBjMDV2YmtsdVpHVjRLR3RsZVNrZ2UxeHVJQ0JwWmlBb2EyVjVMbXhsYm1kMGFDQTlQVDBnTUNCOGZDQnJaWGt1YkdWdVozUm9JRDRnTVRBcElISmxkSFZ5YmlCMGNuVmxPMXh1WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dhMlY1TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ2RtRnlJR052WkdVZ1BTQnJaWGt1WTJoaGNrTnZaR1ZCZENocEtUdGNiaUFnSUNCcFppQW9ZMjlrWlNBOElEUTRJSHg4SUdOdlpHVWdQaUExTnlrZ2NtVjBkWEp1SUhSeWRXVTdYRzRnSUgwZ0x5OGdWR2hsSUcxaGVHbHRkVzBnYzJsNlpTQm1iM0lnWVc0Z1lYSnlZWGtnYVhNZ01pQXFLaUF6TWlBdE1TNWNibHh1WEc0Z0lISmxkSFZ5YmlCclpYa3ViR1Z1WjNSb0lEMDlQU0F4TUNBbUppQnJaWGtnUGowZ1RXRjBhQzV3YjNjb01pd2dNeklwTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJuWlhSUGQyNU9iMjVKYm1SbGVGQnliM0JsY25ScFpYTW9kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJRTlpYW1WamRDNXJaWGx6S0haaGJIVmxLUzVtYVd4MFpYSW9hWE5PYjI1SmJtUmxlQ2t1WTI5dVkyRjBLRzlpYW1WamRFZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjeWgyWVd4MVpTa3VabWxzZEdWeUtFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWNISnZjR1Z5ZEhsSmMwVnVkVzFsY21GaWJHVXVZbWx1WkNoMllXeDFaU2twS1R0Y2JuMGdMeThnVkdGclpXNGdabkp2YlNCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdlptVnliM056TDJKMVptWmxjaTlpYkc5aUx6WTRNR1U1WlRWbE5EZzRaakl5WVdGak1qYzFPVGxoTlRka1l6ZzBOR0UyTXpFMU9USTRaR1F2YVc1a1pYZ3Vhbk5jYmk4dklHOXlhV2RwYm1Gc0lHNXZkR2xqWlRwY2JseHVMeW9oWEc0Z0tpQlVhR1VnWW5WbVptVnlJRzF2WkhWc1pTQm1jbTl0SUc1dlpHVXVhbk1zSUdadmNpQjBhR1VnWW5KdmQzTmxjaTVjYmlBcVhHNGdLaUJBWVhWMGFHOXlJQ0FnUm1WeWIzTnpJRUZpYjNWcmFHRmthV3BsYUNBOFptVnliM056UUdabGNtOXpjeTV2Y21jK0lEeG9kSFJ3T2k4dlptVnliM056TG05eVp6NWNiaUFxSUVCc2FXTmxibk5sSUNCTlNWUmNiaUFxTDF4dVhHNWNibVoxYm1OMGFXOXVJR052YlhCaGNtVW9ZU3dnWWlrZ2UxeHVJQ0JwWmlBb1lTQTlQVDBnWWlrZ2UxeHVJQ0FnSUhKbGRIVnliaUF3TzF4dUlDQjlYRzVjYmlBZ2RtRnlJSGdnUFNCaExteGxibWQwYUR0Y2JpQWdkbUZ5SUhrZ1BTQmlMbXhsYm1kMGFEdGNibHh1SUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYkdWdUlEMGdUV0YwYUM1dGFXNG9lQ3dnZVNrN0lHa2dQQ0JzWlc0N0lDc3JhU2tnZTF4dUlDQWdJR2xtSUNoaFcybGRJQ0U5UFNCaVcybGRLU0I3WEc0Z0lDQWdJQ0I0SUQwZ1lWdHBYVHRjYmlBZ0lDQWdJSGtnUFNCaVcybGRPMXh1SUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2FXWWdLSGdnUENCNUtTQjdYRzRnSUNBZ2NtVjBkWEp1SUMweE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0hrZ1BDQjRLU0I3WEc0Z0lDQWdjbVYwZFhKdUlERTdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdNRHRjYm4xY2JseHVkbUZ5SUU5T1RGbGZSVTVWVFVWU1FVSk1SU0E5SUhWdVpHVm1hVzVsWkR0Y2JuWmhjaUJyVTNSeWFXTjBJRDBnZEhKMVpUdGNiblpoY2lCclRHOXZjMlVnUFNCbVlXeHpaVHRjYm5aaGNpQnJUbTlKZEdWeVlYUnZjaUE5SURBN1hHNTJZWElnYTBselFYSnlZWGtnUFNBeE8xeHVkbUZ5SUd0SmMxTmxkQ0E5SURJN1hHNTJZWElnYTBselRXRndJRDBnTXpzZ0x5OGdRMmhsWTJzZ2FXWWdkR2hsZVNCb1lYWmxJSFJvWlNCellXMWxJSE52ZFhKalpTQmhibVFnWm14aFozTmNibHh1Wm5WdVkzUnBiMjRnWVhKbFUybHRhV3hoY2xKbFowVjRjSE1vWVN3Z1lpa2dlMXh1SUNCeVpYUjFjbTRnY21WblpYaEdiR0ZuYzFOMWNIQnZjblJsWkNBL0lHRXVjMjkxY21ObElEMDlQU0JpTG5OdmRYSmpaU0FtSmlCaExtWnNZV2R6SUQwOVBTQmlMbVpzWVdkeklEb2dVbVZuUlhod0xuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5NWpZV3hzS0dFcElEMDlQU0JTWldkRmVIQXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5MbU5oYkd3b1lpazdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHRnlaVk5wYldsc1lYSkdiRzloZEVGeWNtRjVjeWhoTENCaUtTQjdYRzRnSUdsbUlDaGhMbUo1ZEdWTVpXNW5kR2dnSVQwOUlHSXVZbmwwWlV4bGJtZDBhQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdmVnh1WEc0Z0lHWnZjaUFvZG1GeUlHOW1abk5sZENBOUlEQTdJRzltWm5ObGRDQThJR0V1WW5sMFpVeGxibWQwYURzZ2IyWm1jMlYwS3lzcElIdGNiaUFnSUNCcFppQW9ZVnR2Wm1aelpYUmRJQ0U5UFNCaVcyOW1abk5sZEYwcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnWVhKbFUybHRhV3hoY2xSNWNHVmtRWEp5WVhsektHRXNJR0lwSUh0Y2JpQWdhV1lnS0dFdVlubDBaVXhsYm1kMGFDQWhQVDBnWWk1aWVYUmxUR1Z1WjNSb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR052YlhCaGNtVW9ibVYzSUZWcGJuUTRRWEp5WVhrb1lTNWlkV1ptWlhJc0lHRXVZbmwwWlU5bVpuTmxkQ3dnWVM1aWVYUmxUR1Z1WjNSb0tTd2dibVYzSUZWcGJuUTRRWEp5WVhrb1lpNWlkV1ptWlhJc0lHSXVZbmwwWlU5bVpuTmxkQ3dnWWk1aWVYUmxUR1Z1WjNSb0tTa2dQVDA5SURBN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdGeVpVVnhkV0ZzUVhKeVlYbENkV1ptWlhKektHSjFaakVzSUdKMVpqSXBJSHRjYmlBZ2NtVjBkWEp1SUdKMVpqRXVZbmwwWlV4bGJtZDBhQ0E5UFQwZ1luVm1NaTVpZVhSbFRHVnVaM1JvSUNZbUlHTnZiWEJoY21Vb2JtVjNJRlZwYm5RNFFYSnlZWGtvWW5WbU1Ta3NJRzVsZHlCVmFXNTBPRUZ5Y21GNUtHSjFaaklwS1NBOVBUMGdNRHRjYm4xY2JseHVablZ1WTNScGIyNGdhWE5GY1hWaGJFSnZlR1ZrVUhKcGJXbDBhWFpsS0haaGJERXNJSFpoYkRJcElIdGNiaUFnYVdZZ0tHbHpUblZ0WW1WeVQySnFaV04wS0haaGJERXBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHbHpUblZ0WW1WeVQySnFaV04wS0haaGJESXBJQ1ltSUc5aWFtVmpkRWx6S0U1MWJXSmxjaTV3Y205MGIzUjVjR1V1ZG1Gc2RXVlBaaTVqWVd4c0tIWmhiREVwTENCT2RXMWlaWEl1Y0hKdmRHOTBlWEJsTG5aaGJIVmxUMll1WTJGc2JDaDJZV3d5S1NrN1hHNGdJSDFjYmx4dUlDQnBaaUFvYVhOVGRISnBibWRQWW1wbFkzUW9kbUZzTVNrcElIdGNiaUFnSUNCeVpYUjFjbTRnYVhOVGRISnBibWRQWW1wbFkzUW9kbUZzTWlrZ0ppWWdVM1J5YVc1bkxuQnliM1J2ZEhsd1pTNTJZV3gxWlU5bUxtTmhiR3dvZG1Gc01Ta2dQVDA5SUZOMGNtbHVaeTV3Y205MGIzUjVjR1V1ZG1Gc2RXVlBaaTVqWVd4c0tIWmhiRElwTzF4dUlDQjlYRzVjYmlBZ2FXWWdLR2x6UW05dmJHVmhiazlpYW1WamRDaDJZV3d4S1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJwYzBKdmIyeGxZVzVQWW1wbFkzUW9kbUZzTWlrZ0ppWWdRbTl2YkdWaGJpNXdjbTkwYjNSNWNHVXVkbUZzZFdWUFppNWpZV3hzS0haaGJERXBJRDA5UFNCQ2IyOXNaV0Z1TG5CeWIzUnZkSGx3WlM1MllXeDFaVTltTG1OaGJHd29kbUZzTWlrN1hHNGdJSDFjYmx4dUlDQnBaaUFvYVhOQ2FXZEpiblJQWW1wbFkzUW9kbUZzTVNrcElIdGNiaUFnSUNCeVpYUjFjbTRnYVhOQ2FXZEpiblJQWW1wbFkzUW9kbUZzTWlrZ0ppWWdRbWxuU1c1MExuQnliM1J2ZEhsd1pTNTJZV3gxWlU5bUxtTmhiR3dvZG1Gc01Ta2dQVDA5SUVKcFowbHVkQzV3Y205MGIzUjVjR1V1ZG1Gc2RXVlBaaTVqWVd4c0tIWmhiRElwTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdselUzbHRZbTlzVDJKcVpXTjBLSFpoYkRJcElDWW1JRk41YldKdmJDNXdjbTkwYjNSNWNHVXVkbUZzZFdWUFppNWpZV3hzS0haaGJERXBJRDA5UFNCVGVXMWliMnd1Y0hKdmRHOTBlWEJsTG5aaGJIVmxUMll1WTJGc2JDaDJZV3d5S1R0Y2JuMGdMeThnVG05MFpYTTZJRlI1Y0dVZ2RHRm5jeUJoY21VZ2FHbHpkRzl5YVdOaGJDQmJXME5zWVhOelhWMGdjSEp2Y0dWeWRHbGxjeUIwYUdGMElHTmhiaUJpWlNCelpYUWdZbmxjYmk4dklFWjFibU4wYVc5dVZHVnRjR3hoZEdVNk9sTmxkRU5zWVhOelRtRnRaU2dwSUdsdUlFTXJLeUJ2Y2lCVGVXMWliMnd1ZEc5VGRISnBibWRVWVdjZ2FXNGdTbE5jYmk4dklHRnVaQ0J5WlhSeWFXVjJaV1FnZFhOcGJtY2dUMkpxWldOMExuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5NWpZV3hzS0c5aWFpa2dhVzRnU2xOY2JpOHZJRk5sWlNCb2RIUndjem92TDNSak16a3VaMmwwYUhWaUxtbHZMMlZqYldFeU5qSXZJM05sWXkxdlltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdmMzUnlhVzVuWEc0dkx5Qm1iM0lnWVNCc2FYTjBJRzltSUhSaFozTWdjSEpsTFdSbFptbHVaV1FnYVc0Z2RHaGxJSE53WldNdVhHNHZMeUJVYUdWeVpTQmhjbVVnYzI5dFpTQjFibk53WldOcFptbGxaQ0IwWVdkeklHbHVJSFJvWlNCM2FXeGtJSFJ2YnlBb1pTNW5MaUIwZVhCbFpDQmhjbkpoZVNCMFlXZHpLUzVjYmk4dklGTnBibU5sSUhSaFozTWdZMkZ1SUdKbElHRnNkR1Z5WldRc0lIUm9aWGtnYjI1c2VTQnpaWEoyWlNCbVlYTjBJR1poYVd4MWNtVnpYRzR2TDF4dUx5OGdWSGx3WldRZ1lYSnlZWGx6SUdGdVpDQmlkV1ptWlhKeklHRnlaU0JqYUdWamEyVmtJR0o1SUdOdmJYQmhjbWx1WnlCMGFHVWdZMjl1ZEdWdWRDQnBiaUIwYUdWcGNseHVMeThnZFc1a1pYSnNlV2x1WnlCQmNuSmhlVUoxWm1abGNpNGdWR2hwY3lCdmNIUnBiV2w2WVhScGIyNGdjbVZ4ZFdseVpYTWdkR2hoZENCcGRDZHpYRzR2THlCeVpXRnpiMjVoWW14bElIUnZJR2x1ZEdWeWNISmxkQ0IwYUdWcGNpQjFibVJsY214NWFXNW5JRzFsYlc5eWVTQnBiaUIwYUdVZ2MyRnRaU0IzWVhrc1hHNHZMeUIzYUdsamFDQnBjeUJqYUdWamEyVmtJR0o1SUdOdmJYQmhjbWx1WnlCMGFHVnBjaUIwZVhCbElIUmhaM011WEc0dkx5QW9aUzVuTGlCaElGVnBiblE0UVhKeVlYa2dZVzVrSUdFZ1ZXbHVkREUyUVhKeVlYa2dkMmwwYUNCMGFHVWdjMkZ0WlNCdFpXMXZjbmtnWTI5dWRHVnVkRnh1THk4Z1kyOTFiR1FnYzNScGJHd2dZbVVnWkdsbVptVnlaVzUwSUdKbFkyRjFjMlVnZEdobGVTQjNhV3hzSUdKbElHbHVkR1Z5Y0hKbGRHVmtJR1JwWm1abGNtVnVkR3g1S1M1Y2JpOHZYRzR2THlCR2IzSWdjM1J5YVdOMElHTnZiWEJoY21semIyNHNJRzlpYW1WamRITWdjMmh2ZFd4a0lHaGhkbVZjYmk4dklHRXBJRlJvWlNCellXMWxJR0oxYVd4MExXbHVJSFI1Y0dVZ2RHRm5jMXh1THk4Z1lpa2dWR2hsSUhOaGJXVWdjSEp2ZEc5MGVYQmxjeTVjYmx4dVhHNW1kVzVqZEdsdmJpQnBibTVsY2tSbFpYQkZjWFZoYkNoMllXd3hMQ0IyWVd3eUxDQnpkSEpwWTNRc0lHMWxiVzl6S1NCN1hHNGdJQzh2SUVGc2JDQnBaR1Z1ZEdsallXd2dkbUZzZFdWeklHRnlaU0JsY1hWcGRtRnNaVzUwTENCaGN5QmtaWFJsY20xcGJtVmtJR0o1SUQwOVBTNWNiaUFnYVdZZ0tIWmhiREVnUFQwOUlIWmhiRElwSUh0Y2JpQWdJQ0JwWmlBb2RtRnNNU0FoUFQwZ01Da2djbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdjbVYwZFhKdUlITjBjbWxqZENBL0lHOWlhbVZqZEVsektIWmhiREVzSUhaaGJESXBJRG9nZEhKMVpUdGNiaUFnZlNBdkx5QkRhR1ZqYXlCdGIzSmxJR05zYjNObGJIa2dhV1lnZG1Gc01TQmhibVFnZG1Gc01pQmhjbVVnWlhGMVlXd3VYRzVjYmx4dUlDQnBaaUFvYzNSeWFXTjBLU0I3WEc0Z0lDQWdhV1lnS0Y5MGVYQmxiMllvZG1Gc01Ta2dJVDA5SUNkdlltcGxZM1FuS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEhsd1pXOW1JSFpoYkRFZ1BUMDlJQ2R1ZFcxaVpYSW5JQ1ltSUc1MWJXSmxja2x6VG1GT0tIWmhiREVwSUNZbUlHNTFiV0psY2tselRtRk9LSFpoYkRJcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDaGZkSGx3Wlc5bUtIWmhiRElwSUNFOVBTQW5iMkpxWldOMEp5QjhmQ0IyWVd3eElEMDlQU0J1ZFd4c0lIeDhJSFpoYkRJZ1BUMDlJRzUxYkd3cElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bUtIWmhiREVwSUNFOVBTQlBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvZG1Gc01pa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnYVdZZ0tIWmhiREVnUFQwOUlHNTFiR3dnZkh3Z1gzUjVjR1Z2WmloMllXd3hLU0FoUFQwZ0oyOWlhbVZqZENjcElIdGNiaUFnSUNBZ0lHbG1JQ2gyWVd3eUlEMDlQU0J1ZFd4c0lIeDhJRjkwZVhCbGIyWW9kbUZzTWlrZ0lUMDlJQ2R2WW1wbFkzUW5LU0I3WEc0Z0lDQWdJQ0FnSUM4dklHVnpiR2x1ZEMxa2FYTmhZbXhsTFc1bGVIUXRiR2x1WlNCbGNXVnhaWEZjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFpoYkRFZ1BUMGdkbUZzTWp0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2gyWVd3eUlEMDlQU0J1ZFd4c0lIeDhJRjkwZVhCbGIyWW9kbUZzTWlrZ0lUMDlJQ2R2WW1wbFkzUW5LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2RtRnlJSFpoYkRGVVlXY2dQU0J2WW1wbFkzUlViMU4wY21sdVp5aDJZV3d4S1R0Y2JpQWdkbUZ5SUhaaGJESlVZV2NnUFNCdlltcGxZM1JVYjFOMGNtbHVaeWgyWVd3eUtUdGNibHh1SUNCcFppQW9kbUZzTVZSaFp5QWhQVDBnZG1Gc01sUmhaeWtnZTF4dUlDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2hCY25KaGVTNXBjMEZ5Y21GNUtIWmhiREVwS1NCN1hHNGdJQ0FnTHk4Z1EyaGxZMnNnWm05eUlITndZWEp6WlNCaGNuSmhlWE1nWVc1a0lHZGxibVZ5WVd3Z1ptRnpkQ0J3WVhSb1hHNGdJQ0FnYVdZZ0tIWmhiREV1YkdWdVozUm9JQ0U5UFNCMllXd3lMbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCclpYbHpNU0E5SUdkbGRFOTNiazV2YmtsdVpHVjRVSEp2Y0dWeWRHbGxjeWgyWVd3eExDQlBUa3haWDBWT1ZVMUZVa0ZDVEVVcE8xeHVJQ0FnSUhaaGNpQnJaWGx6TWlBOUlHZGxkRTkzYms1dmJrbHVaR1Y0VUhKdmNHVnlkR2xsY3loMllXd3lMQ0JQVGt4WlgwVk9WVTFGVWtGQ1RFVXBPMXh1WEc0Z0lDQWdhV1lnS0d0bGVYTXhMbXhsYm1kMGFDQWhQVDBnYTJWNWN6SXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlHdGxlVU5vWldOcktIWmhiREVzSUhaaGJESXNJSE4wY21samRDd2diV1Z0YjNNc0lHdEpjMEZ5Y21GNUxDQnJaWGx6TVNrN1hHNGdJSDBnTHk4Z1cySnliM2R6WlhKcFpubGRJRlJvYVhNZ2RISnBaMmRsY25NZ2IyNGdZMlZ5ZEdGcGJpQjBlWEJsY3lCcGJpQkpSU0FvVFdGd0wxTmxkQ2tnYzI4Z2QyVWdaRzl1SjNSY2JpQWdMeThnZDJGdUozUWdkRzhnWldGeWJIa2djbVYwZFhKdUlHOTFkQ0J2WmlCMGFHVWdjbVZ6ZENCdlppQjBhR1VnWTJobFkydHpMaUJJYjNkbGRtVnlJSGRsSUdOaGJpQmphR1ZqYTF4dUlDQXZMeUJwWmlCMGFHVWdjMlZqYjI1a0lIWmhiSFZsSUdseklHOXVaU0J2WmlCMGFHVnpaU0IyWVd4MVpYTWdZVzVrSUhSb1pTQm1hWEp6ZENCcGMyNG5kQzVjYmx4dVhHNGdJR2xtSUNoMllXd3hWR0ZuSUQwOVBTQW5XMjlpYW1WamRDQlBZbXBsWTNSZEp5a2dlMXh1SUNBZ0lDOHZJSEpsZEhWeWJpQnJaWGxEYUdWamF5aDJZV3d4TENCMllXd3lMQ0J6ZEhKcFkzUXNJRzFsYlc5ekxDQnJUbTlKZEdWeVlYUnZjaWs3WEc0Z0lDQWdhV1lnS0NGcGMwMWhjQ2gyWVd3eEtTQW1KaUJwYzAxaGNDaDJZV3d5S1NCOGZDQWhhWE5UWlhRb2RtRnNNU2tnSmlZZ2FYTlRaWFFvZG1Gc01pa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCcFppQW9hWE5FWVhSbEtIWmhiREVwS1NCN1hHNGdJQ0FnYVdZZ0tDRnBjMFJoZEdVb2RtRnNNaWtnZkh3Z1JHRjBaUzV3Y205MGIzUjVjR1V1WjJWMFZHbHRaUzVqWVd4c0tIWmhiREVwSUNFOVBTQkVZWFJsTG5CeWIzUnZkSGx3WlM1blpYUlVhVzFsTG1OaGJHd29kbUZzTWlrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0JwWmlBb2FYTlNaV2RGZUhBb2RtRnNNU2twSUh0Y2JpQWdJQ0JwWmlBb0lXbHpVbVZuUlhod0tIWmhiRElwSUh4OElDRmhjbVZUYVcxcGJHRnlVbVZuUlhod2N5aDJZV3d4TENCMllXd3lLU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgxY2JpQWdmU0JsYkhObElHbG1JQ2hwYzA1aGRHbDJaVVZ5Y205eUtIWmhiREVwSUh4OElIWmhiREVnYVc1emRHRnVZMlZ2WmlCRmNuSnZjaWtnZTF4dUlDQWdJQzh2SUVSdklHNXZkQ0JqYjIxd1lYSmxJSFJvWlNCemRHRmpheUJoY3lCcGRDQnRhV2RvZENCa2FXWm1aWElnWlhabGJpQjBhRzkxWjJnZ2RHaGxJR1Z5Y205eUlHbDBjMlZzWmx4dUlDQWdJQzh2SUdseklHOTBhR1Z5ZDJselpTQnBaR1Z1ZEdsallXd3VYRzRnSUNBZ2FXWWdLSFpoYkRFdWJXVnpjMkZuWlNBaFBUMGdkbUZzTWk1dFpYTnpZV2RsSUh4OElIWmhiREV1Ym1GdFpTQWhQVDBnZG1Gc01pNXVZVzFsS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdhV1lnS0dselFYSnlZWGxDZFdabVpYSldhV1YzS0haaGJERXBLU0I3WEc0Z0lDQWdhV1lnS0NGemRISnBZM1FnSmlZZ0tHbHpSbXh2WVhRek1rRnljbUY1S0haaGJERXBJSHg4SUdselJteHZZWFEyTkVGeWNtRjVLSFpoYkRFcEtTa2dlMXh1SUNBZ0lDQWdhV1lnS0NGaGNtVlRhVzFwYkdGeVJteHZZWFJCY25KaGVYTW9kbUZzTVN3Z2RtRnNNaWtwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9JV0Z5WlZOcGJXbHNZWEpVZVhCbFpFRnljbUY1Y3loMllXd3hMQ0IyWVd3eUtTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJSDBnTHk4Z1FuVm1abVZ5TG1OdmJYQmhjbVVnY21WMGRYSnVjeUIwY25WbExDQnpieUIyWVd3eExteGxibWQwYUNBOVBUMGdkbUZzTWk1c1pXNW5kR2d1SUVsbUlIUm9aWGtnWW05MGFGeHVJQ0FnSUM4dklHOXViSGtnWTI5dWRHRnBiaUJ1ZFcxbGNtbGpJR3RsZVhNc0lIZGxJR1J2YmlkMElHNWxaV1FnZEc4Z1pYaGhiU0JtZFhKMGFHVnlJSFJvWVc0Z1kyaGxZMnRwYm1kY2JpQWdJQ0F2THlCMGFHVWdjM2x0WW05c2N5NWNibHh1WEc0Z0lDQWdkbUZ5SUY5clpYbHpJRDBnWjJWMFQzZHVUbTl1U1c1a1pYaFFjbTl3WlhKMGFXVnpLSFpoYkRFc0lFOU9URmxmUlU1VlRVVlNRVUpNUlNrN1hHNWNiaUFnSUNCMllYSWdYMnRsZVhNeUlEMGdaMlYwVDNkdVRtOXVTVzVrWlhoUWNtOXdaWEowYVdWektIWmhiRElzSUU5T1RGbGZSVTVWVFVWU1FVSk1SU2s3WEc1Y2JpQWdJQ0JwWmlBb1gydGxlWE11YkdWdVozUm9JQ0U5UFNCZmEyVjVjekl1YkdWdVozUm9LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJR3RsZVVOb1pXTnJLSFpoYkRFc0lIWmhiRElzSUhOMGNtbGpkQ3dnYldWdGIzTXNJR3RPYjBsMFpYSmhkRzl5TENCZmEyVjVjeWs3WEc0Z0lIMGdaV3h6WlNCcFppQW9hWE5UWlhRb2RtRnNNU2twSUh0Y2JpQWdJQ0JwWmlBb0lXbHpVMlYwS0haaGJESXBJSHg4SUhaaGJERXVjMmw2WlNBaFBUMGdkbUZzTWk1emFYcGxLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJR3RsZVVOb1pXTnJLSFpoYkRFc0lIWmhiRElzSUhOMGNtbGpkQ3dnYldWdGIzTXNJR3RKYzFObGRDazdYRzRnSUgwZ1pXeHpaU0JwWmlBb2FYTk5ZWEFvZG1Gc01Ta3BJSHRjYmlBZ0lDQnBaaUFvSVdselRXRndLSFpoYkRJcElIeDhJSFpoYkRFdWMybDZaU0FoUFQwZ2RtRnNNaTV6YVhwbEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlHdGxlVU5vWldOcktIWmhiREVzSUhaaGJESXNJSE4wY21samRDd2diV1Z0YjNNc0lHdEpjMDFoY0NrN1hHNGdJSDBnWld4elpTQnBaaUFvYVhOQmJubEJjbkpoZVVKMVptWmxjaWgyWVd3eEtTa2dlMXh1SUNBZ0lHbG1JQ2doWVhKbFJYRjFZV3hCY25KaGVVSjFabVpsY25Nb2RtRnNNU3dnZG1Gc01pa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCcFppQW9hWE5DYjNobFpGQnlhVzFwZEdsMlpTaDJZV3d4S1NBbUppQWhhWE5GY1hWaGJFSnZlR1ZrVUhKcGJXbDBhWFpsS0haaGJERXNJSFpoYkRJcEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR3RsZVVOb1pXTnJLSFpoYkRFc0lIWmhiRElzSUhOMGNtbGpkQ3dnYldWdGIzTXNJR3RPYjBsMFpYSmhkRzl5S1R0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnWjJWMFJXNTFiV1Z5WVdKc1pYTW9kbUZzTENCclpYbHpLU0I3WEc0Z0lISmxkSFZ5YmlCclpYbHpMbVpwYkhSbGNpaG1kVzVqZEdsdmJpQW9heWtnZTF4dUlDQWdJSEpsZEhWeWJpQndjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaU2gyWVd3c0lHc3BPMXh1SUNCOUtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2EyVjVRMmhsWTJzb2RtRnNNU3dnZG1Gc01pd2djM1J5YVdOMExDQnRaVzF2Y3l3Z2FYUmxjbUYwYVc5dVZIbHdaU3dnWVV0bGVYTXBJSHRjYmlBZ0x5OGdSbTl5SUdGc2JDQnlaVzFoYVc1cGJtY2dUMkpxWldOMElIQmhhWEp6TENCcGJtTnNkV1JwYm1jZ1FYSnlZWGtzSUc5aWFtVmpkSE1nWVc1a0lFMWhjSE1zWEc0Z0lDOHZJR1Z4ZFdsMllXeGxibU5sSUdseklHUmxkR1Z5YldsdVpXUWdZbmtnYUdGMmFXNW5PbHh1SUNBdkx5QmhLU0JVYUdVZ2MyRnRaU0J1ZFcxaVpYSWdiMllnYjNkdVpXUWdaVzUxYldWeVlXSnNaU0J3Y205d1pYSjBhV1Z6WEc0Z0lDOHZJR0lwSUZSb1pTQnpZVzFsSUhObGRDQnZaaUJyWlhsekwybHVaR1Y0WlhNZ0tHRnNkR2h2ZFdkb0lHNXZkQ0J1WldObGMzTmhjbWxzZVNCMGFHVWdjMkZ0WlNCdmNtUmxjaWxjYmlBZ0x5OGdZeWtnUlhGMWFYWmhiR1Z1ZENCMllXeDFaWE1nWm05eUlHVjJaWEo1SUdOdmNuSmxjM0J2Ym1ScGJtY2dhMlY1TDJsdVpHVjRYRzRnSUM4dklHUXBJRVp2Y2lCVFpYUnpJR0Z1WkNCTllYQnpMQ0JsY1hWaGJDQmpiMjUwWlc1MGMxeHVJQ0F2THlCT2IzUmxPaUIwYUdseklHRmpZMjkxYm5SeklHWnZjaUJpYjNSb0lHNWhiV1ZrSUdGdVpDQnBibVJsZUdWa0lIQnliM0JsY25ScFpYTWdiMjRnUVhKeVlYbHpMbHh1SUNCcFppQW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQTlQVDBnTlNrZ2UxeHVJQ0FnSUdGTFpYbHpJRDBnVDJKcVpXTjBMbXRsZVhNb2RtRnNNU2s3WEc0Z0lDQWdkbUZ5SUdKTFpYbHpJRDBnVDJKcVpXTjBMbXRsZVhNb2RtRnNNaWs3SUM4dklGUm9aU0J3WVdseUlHMTFjM1FnYUdGMlpTQjBhR1VnYzJGdFpTQnVkVzFpWlhJZ2IyWWdiM2R1WldRZ2NISnZjR1Z5ZEdsbGN5NWNibHh1SUNBZ0lHbG1JQ2hoUzJWNWN5NXNaVzVuZEdnZ0lUMDlJR0pMWlhsekxteGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lIMWNiaUFnZlNBdkx5QkRhR1ZoY0NCclpYa2dkR1Z6ZEZ4dVhHNWNiaUFnZG1GeUlHa2dQU0F3TzF4dVhHNGdJR1p2Y2lBb095QnBJRHdnWVV0bGVYTXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0JwWmlBb0lXaGhjMDkzYmxCeWIzQmxjblI1S0haaGJESXNJR0ZMWlhselcybGRLU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHbG1JQ2h6ZEhKcFkzUWdKaVlnWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0E5UFQwZ05Ta2dlMXh1SUNBZ0lIWmhjaUJ6ZVcxaWIyeExaWGx6UVNBOUlHOWlhbVZqZEVkbGRFOTNibEJ5YjNCbGNuUjVVM2x0WW05c2N5aDJZV3d4S1R0Y2JseHVJQ0FnSUdsbUlDaHplVzFpYjJ4TFpYbHpRUzVzWlc1bmRHZ2dJVDA5SURBcElIdGNiaUFnSUNBZ0lIWmhjaUJqYjNWdWRDQTlJREE3WEc1Y2JpQWdJQ0FnSUdadmNpQW9hU0E5SURBN0lHa2dQQ0J6ZVcxaWIyeExaWGx6UVM1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2EyVjVJRDBnYzNsdFltOXNTMlY1YzBGYmFWMDdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tIQnliM0JsY25SNVNYTkZiblZ0WlhKaFlteGxLSFpoYkRFc0lHdGxlU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvSVhCeWIzQmxjblI1U1hORmJuVnRaWEpoWW14bEtIWmhiRElzSUd0bGVTa3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0JoUzJWNWN5NXdkWE5vS0d0bGVTazdYRzRnSUNBZ0lDQWdJQ0FnWTI5MWJuUXJLenRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNod2NtOXdaWEowZVVselJXNTFiV1Z5WVdKc1pTaDJZV3d5TENCclpYa3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhaaGNpQnplVzFpYjJ4TFpYbHpRaUE5SUc5aWFtVmpkRWRsZEU5M2JsQnliM0JsY25SNVUzbHRZbTlzY3loMllXd3lLVHRjYmx4dUlDQWdJQ0FnYVdZZ0tITjViV0p2YkV0bGVYTkJMbXhsYm1kMGFDQWhQVDBnYzNsdFltOXNTMlY1YzBJdWJHVnVaM1JvSUNZbUlHZGxkRVZ1ZFcxbGNtRmliR1Z6S0haaGJESXNJSE41YldKdmJFdGxlWE5DS1M1c1pXNW5kR2dnSVQwOUlHTnZkVzUwS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2RtRnlJRjl6ZVcxaWIyeExaWGx6UWlBOUlHOWlhbVZqZEVkbGRFOTNibEJ5YjNCbGNuUjVVM2x0WW05c2N5aDJZV3d5S1R0Y2JseHVJQ0FnSUNBZ2FXWWdLRjl6ZVcxaWIyeExaWGx6UWk1c1pXNW5kR2dnSVQwOUlEQWdKaVlnWjJWMFJXNTFiV1Z5WVdKc1pYTW9kbUZzTWl3Z1gzTjViV0p2YkV0bGVYTkNLUzVzWlc1bmRHZ2dJVDA5SURBcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdsbUlDaGhTMlY1Y3k1c1pXNW5kR2dnUFQwOUlEQWdKaVlnS0dsMFpYSmhkR2x2YmxSNWNHVWdQVDA5SUd0T2IwbDBaWEpoZEc5eUlIeDhJR2wwWlhKaGRHbHZibFI1Y0dVZ1BUMDlJR3RKYzBGeWNtRjVJQ1ltSUhaaGJERXViR1Z1WjNSb0lEMDlQU0F3SUh4OElIWmhiREV1YzJsNlpTQTlQVDBnTUNrcElIdGNiaUFnSUNCeVpYUjFjbTRnZEhKMVpUdGNiaUFnZlNBdkx5QlZjMlVnYldWdGIzTWdkRzhnYUdGdVpHeGxJR041WTJ4bGN5NWNibHh1WEc0Z0lHbG1JQ2h0WlcxdmN5QTlQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnYldWdGIzTWdQU0I3WEc0Z0lDQWdJQ0IyWVd3eE9pQnVaWGNnVFdGd0tDa3NYRzRnSUNBZ0lDQjJZV3d5T2lCdVpYY2dUV0Z3S0Nrc1hHNGdJQ0FnSUNCd2IzTnBkR2x2YmpvZ01GeHVJQ0FnSUgwN1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ0x5OGdWMlVnY0hKbGRtVnVkQ0IxY0NCMGJ5QjBkMjhnYldGd0xtaGhjeWg0S1NCallXeHNjeUJpZVNCa2FYSmxZM1JzZVNCeVpYUnlhV1YyYVc1bklIUm9aU0IyWVd4MVpWeHVJQ0FnSUM4dklHRnVaQ0JqYUdWamEybHVaeUJtYjNJZ2RXNWtaV1pwYm1Wa0xpQlVhR1VnYldGd0lHTmhiaUJ2Ym14NUlHTnZiblJoYVc0Z2JuVnRZbVZ5Y3l3Z2MyOGdhWFFnYVhOY2JpQWdJQ0F2THlCellXWmxJSFJ2SUdOb1pXTnJJR1p2Y2lCMWJtUmxabWx1WldRZ2IyNXNlUzVjYmlBZ0lDQjJZWElnZG1Gc01rMWxiVzlCSUQwZ2JXVnRiM011ZG1Gc01TNW5aWFFvZG1Gc01TazdYRzVjYmlBZ0lDQnBaaUFvZG1Gc01rMWxiVzlCSUNFOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQWdJSFpoY2lCMllXd3lUV1Z0YjBJZ1BTQnRaVzF2Y3k1MllXd3lMbWRsZENoMllXd3lLVHRjYmx4dUlDQWdJQ0FnYVdZZ0tIWmhiREpOWlcxdlFpQWhQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMllXd3lUV1Z0YjBFZ1BUMDlJSFpoYkRKTlpXMXZRanRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnRaVzF2Y3k1d2IzTnBkR2x2Ymlzck8xeHVJQ0I5WEc1Y2JpQWdiV1Z0YjNNdWRtRnNNUzV6WlhRb2RtRnNNU3dnYldWdGIzTXVjRzl6YVhScGIyNHBPMXh1SUNCdFpXMXZjeTUyWVd3eUxuTmxkQ2gyWVd3eUxDQnRaVzF2Y3k1d2IzTnBkR2x2YmlrN1hHNGdJSFpoY2lCaGNtVkZjU0E5SUc5aWFrVnhkV2wyS0haaGJERXNJSFpoYkRJc0lITjBjbWxqZEN3Z1lVdGxlWE1zSUcxbGJXOXpMQ0JwZEdWeVlYUnBiMjVVZVhCbEtUdGNiaUFnYldWdGIzTXVkbUZzTVM1a1pXeGxkR1VvZG1Gc01TazdYRzRnSUcxbGJXOXpMblpoYkRJdVpHVnNaWFJsS0haaGJESXBPMXh1SUNCeVpYUjFjbTRnWVhKbFJYRTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlITmxkRWhoYzBWeGRXRnNSV3hsYldWdWRDaHpaWFFzSUhaaGJERXNJSE4wY21samRDd2diV1Z0YnlrZ2UxeHVJQ0F2THlCSGJ5QnNiMjlyYVc1bkxseHVJQ0IyWVhJZ2MyVjBWbUZzZFdWeklEMGdZWEp5WVhsR2NtOXRVMlYwS0hObGRDazdYRzVjYmlBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQnpaWFJXWVd4MVpYTXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0IyWVhJZ2RtRnNNaUE5SUhObGRGWmhiSFZsYzF0cFhUdGNibHh1SUNBZ0lHbG1JQ2hwYm01bGNrUmxaWEJGY1hWaGJDaDJZV3d4TENCMllXd3lMQ0J6ZEhKcFkzUXNJRzFsYlc4cEtTQjdYRzRnSUNBZ0lDQXZMeUJTWlcxdmRtVWdkR2hsSUcxaGRHTm9hVzVuSUdWc1pXMWxiblFnZEc4Z2JXRnJaU0J6ZFhKbElIZGxJR1J2SUc1dmRDQmphR1ZqYXlCMGFHRjBJR0ZuWVdsdUxseHVJQ0FnSUNBZ2MyVjBMbVJsYkdWMFpTaDJZV3d5S1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUIwY25WbE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCbVlXeHpaVHRjYm4wZ0x5OGdVMlZsSUdoMGRIQnpPaTh2WkdWMlpXeHZjR1Z5TG0xdmVtbHNiR0V1YjNKbkwyVnVMVlZUTDJSdlkzTXZWMlZpTDBwaGRtRlRZM0pwY0hRdlJYRjFZV3hwZEhsZlkyOXRjR0Z5YVhOdmJuTmZZVzVrWDNOaGJXVnVaWE56STB4dmIzTmxYMlZ4ZFdGc2FYUjVYM1Z6YVc1blhHNHZMeUJUWVdSc2VTQnBkQ0JwY3lCdWIzUWdjRzl6YzJsaWJHVWdkRzhnWkdWMFpXTjBJR052Y25KbGMzQnZibVJwYm1jZ2RtRnNkV1Z6SUhCeWIzQmxjbXg1SUdsdUlHTmhjMlVnZEdobFhHNHZMeUIwZVhCbElHbHpJR0VnYzNSeWFXNW5MQ0J1ZFcxaVpYSXNJR0pwWjJsdWRDQnZjaUJpYjI5c1pXRnVMaUJVYUdVZ2NtVmhjMjl1SUdseklIUm9ZWFFnZEdodmMyVWdkbUZzZFdWelhHNHZMeUJqWVc0Z2JXRjBZMmdnYkc5MGN5QnZaaUJrYVdabVpYSmxiblFnYzNSeWFXNW5JSFpoYkhWbGN5QW9aUzVuTGl3Z01XNGdQVDBnSnlzd01EQXdNU2NwTGx4dVhHNWNibVoxYm1OMGFXOXVJR1pwYm1STWIyOXpaVTFoZEdOb2FXNW5VSEpwYldsMGFYWmxjeWh3Y21sdEtTQjdYRzRnSUhOM2FYUmphQ0FvWDNSNWNHVnZaaWh3Y21sdEtTa2dlMXh1SUNBZ0lHTmhjMlVnSjNWdVpHVm1hVzVsWkNjNlhHNGdJQ0FnSUNCeVpYUjFjbTRnYm5Wc2JEdGNibHh1SUNBZ0lHTmhjMlVnSjI5aWFtVmpkQ2M2WEc0Z0lDQWdJQ0F2THlCUGJteDVJSEJoYzNNZ2FXNGdiblZzYkNCaGN5QnZZbXBsWTNRaFhHNGdJQ0FnSUNCeVpYUjFjbTRnZFc1a1pXWnBibVZrTzF4dVhHNGdJQ0FnWTJGelpTQW5jM2x0WW05c0p6cGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmx4dUlDQWdJR05oYzJVZ0ozTjBjbWx1WnljNlhHNGdJQ0FnSUNCd2NtbHRJRDBnSzNCeWFXMDdYRzRnSUNBZ0x5OGdURzl2YzJVZ1pYRjFZV3dnWlc1MGNtbGxjeUJsZUdsemRDQnZibXg1SUdsbUlIUm9aU0J6ZEhKcGJtY2dhWE1nY0c5emMybGliR1VnZEc4Z1kyOXVkbVZ5ZENCMGIxeHVJQ0FnSUM4dklHRWdjbVZuZFd4aGNpQnVkVzFpWlhJZ1lXNWtJRzV2ZENCT1lVNHVYRzRnSUNBZ0x5OGdSbUZzYkNCMGFISnZkV2RvWEc1Y2JpQWdJQ0JqWVhObElDZHVkVzFpWlhJbk9seHVJQ0FnSUNBZ2FXWWdLRzUxYldKbGNrbHpUbUZPS0hCeWFXMHBLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNBZ0lIMWNibHh1SUNCOVhHNWNiaUFnY21WMGRYSnVJSFJ5ZFdVN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhObGRFMXBaMmgwU0dGMlpVeHZiM05sVUhKcGJTaGhMQ0JpTENCd2NtbHRLU0I3WEc0Z0lIWmhjaUJoYkhSV1lXeDFaU0E5SUdacGJtUk1iMjl6WlUxaGRHTm9hVzVuVUhKcGJXbDBhWFpsY3lod2NtbHRLVHRjYmlBZ2FXWWdLR0ZzZEZaaGJIVmxJQ0U5SUc1MWJHd3BJSEpsZEhWeWJpQmhiSFJXWVd4MVpUdGNiaUFnY21WMGRYSnVJR0l1YUdGektHRnNkRlpoYkhWbEtTQW1KaUFoWVM1b1lYTW9ZV3gwVm1Gc2RXVXBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnRZWEJOYVdkb2RFaGhkbVZNYjI5elpWQnlhVzBvWVN3Z1lpd2djSEpwYlN3Z2FYUmxiU3dnYldWdGJ5a2dlMXh1SUNCMllYSWdZV3gwVm1Gc2RXVWdQU0JtYVc1a1RHOXZjMlZOWVhSamFHbHVaMUJ5YVcxcGRHbDJaWE1vY0hKcGJTazdYRzVjYmlBZ2FXWWdLR0ZzZEZaaGJIVmxJQ0U5SUc1MWJHd3BJSHRjYmlBZ0lDQnlaWFIxY200Z1lXeDBWbUZzZFdVN1hHNGdJSDFjYmx4dUlDQjJZWElnWTNWeVFpQTlJR0l1WjJWMEtHRnNkRlpoYkhWbEtUdGNibHh1SUNCcFppQW9ZM1Z5UWlBOVBUMGdkVzVrWldacGJtVmtJQ1ltSUNGaUxtaGhjeWhoYkhSV1lXeDFaU2tnZkh3Z0lXbHVibVZ5UkdWbGNFVnhkV0ZzS0dsMFpXMHNJR04xY2tJc0lHWmhiSE5sTENCdFpXMXZLU2tnZTF4dUlDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlBaFlTNW9ZWE1vWVd4MFZtRnNkV1VwSUNZbUlHbHVibVZ5UkdWbGNFVnhkV0ZzS0dsMFpXMHNJR04xY2tJc0lHWmhiSE5sTENCdFpXMXZLVHRjYm4xY2JseHVablZ1WTNScGIyNGdjMlYwUlhGMWFYWW9ZU3dnWWl3Z2MzUnlhV04wTENCdFpXMXZLU0I3WEc0Z0lDOHZJRlJvYVhNZ2FYTWdZU0JzWVhwcGJIa2dhVzVwZEdsaGRHVmtJRk5sZENCdlppQmxiblJ5YVdWeklIZG9hV05vSUdoaGRtVWdkRzhnWW1VZ1kyOXRjR0Z5WldSY2JpQWdMeThnY0dGcGNuZHBjMlV1WEc0Z0lIWmhjaUJ6WlhRZ1BTQnVkV3hzTzF4dUlDQjJZWElnWVZaaGJIVmxjeUE5SUdGeWNtRjVSbkp2YlZObGRDaGhLVHRjYmx4dUlDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR0ZXWVd4MVpYTXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0IyWVhJZ2RtRnNJRDBnWVZaaGJIVmxjMXRwWFRzZ0x5OGdUbTkwWlRvZ1EyaGxZMnRwYm1jZ1ptOXlJSFJvWlNCdlltcGxZM1J6SUdacGNuTjBJR2x0Y0hKdmRtVnpJSFJvWlNCd1pYSm1iM0p0WVc1alpTQm1iM0lnYjJKcVpXTjBYRzRnSUNBZ0x5OGdhR1ZoZG5rZ2MyVjBjeUJpZFhRZ2FYUWdhWE1nWVNCdGFXNXZjaUJ6Ykc5M0lHUnZkMjRnWm05eUlIQnlhVzFwZEdsMlpYTXVJRUZ6SUhSb1pYa2dZWEpsSUdaaGMzUmNiaUFnSUNBdkx5QjBieUJqYUdWamF5QjBhR2x6SUdsdGNISnZkbVZ6SUhSb1pTQjNiM0p6ZENCallYTmxJSE5qWlc1aGNtbHZJR2x1YzNSbFlXUXVYRzVjYmlBZ0lDQnBaaUFvWDNSNWNHVnZaaWgyWVd3cElEMDlQU0FuYjJKcVpXTjBKeUFtSmlCMllXd2dJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJR2xtSUNoelpYUWdQVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJQ0FnYzJWMElEMGdibVYzSUZObGRDZ3BPMXh1SUNBZ0lDQWdmU0F2THlCSlppQjBhR1VnYzNCbFkybG1hV1ZrSUhaaGJIVmxJR1J2WlhOdUozUWdaWGhwYzNRZ2FXNGdkR2hsSUhObFkyOXVaQ0J6WlhRZ2FYUnpJR0Z1SUc1dmRDQnVkV3hzWEc0Z0lDQWdJQ0F2THlCdlltcGxZM1FnS0c5eUlHNXZiaUJ6ZEhKcFkzUWdiMjVzZVRvZ1lTQnViM1FnYldGMFkyaHBibWNnY0hKcGJXbDBhWFpsS1NCM1pTZHNiQ0J1WldWa0lIUnZJR2R2WEc0Z0lDQWdJQ0F2THlCb2RXNTBhVzVuSUdadmNpQnpiMjFsZEdocGJtY2dkR2hoZEhNZ1pHVmxjQzBvYzNSeWFXTjBMU2xsY1hWaGJDQjBieUJwZEM0Z1ZHOGdiV0ZyWlNCMGFHbHpYRzRnSUNBZ0lDQXZMeUJQS0c0Z2JHOW5JRzRwSUdOdmJYQnNaWGhwZEhrZ2QyVWdhR0YyWlNCMGJ5QmpiM0I1SUhSb1pYTmxJSFpoYkhWbGN5QnBiaUJoSUc1bGR5QnpaWFFnWm1seWMzUXVYRzVjYmx4dUlDQWdJQ0FnYzJWMExtRmtaQ2gyWVd3cE8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb0lXSXVhR0Z6S0haaGJDa3BJSHRjYmlBZ0lDQWdJR2xtSUNoemRISnBZM1FwSUhKbGRIVnliaUJtWVd4elpUc2dMeThnUm1GemRDQndZWFJvSUhSdklHUmxkR1ZqZENCdGFYTnphVzVuSUhOMGNtbHVaeXdnYzNsdFltOXNMQ0IxYm1SbFptbHVaV1FnWVc1a0lHNTFiR3dnZG1Gc2RXVnpMbHh1WEc0Z0lDQWdJQ0JwWmlBb0lYTmxkRTFwWjJoMFNHRjJaVXh2YjNObFVISnBiU2hoTENCaUxDQjJZV3dwS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tITmxkQ0E5UFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNCelpYUWdQU0J1WlhjZ1UyVjBLQ2s3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhObGRDNWhaR1FvZG1Gc0tUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnBaaUFvYzJWMElDRTlQU0J1ZFd4c0tTQjdYRzRnSUNBZ2RtRnlJR0pXWVd4MVpYTWdQU0JoY25KaGVVWnliMjFUWlhRb1lpazdYRzVjYmlBZ0lDQm1iM0lnS0haaGNpQmZhU0E5SURBN0lGOXBJRHdnWWxaaGJIVmxjeTVzWlc1bmRHZzdJRjlwS3lzcElIdGNiaUFnSUNBZ0lIWmhjaUJmZG1Gc0lEMGdZbFpoYkhWbGMxdGZhVjA3SUM4dklGZGxJR2hoZG1VZ2RHOGdZMmhsWTJzZ2FXWWdZU0J3Y21sdGFYUnBkbVVnZG1Gc2RXVWdhWE1nWVd4eVpXRmtlVnh1SUNBZ0lDQWdMeThnYldGMFkyaHBibWNnWVc1a0lHOXViSGtnYVdZZ2FYUW5jeUJ1YjNRc0lHZHZJR2gxYm5ScGJtY2dabTl5SUdsMExseHVYRzRnSUNBZ0lDQnBaaUFvWDNSNWNHVnZaaWhmZG1Gc0tTQTlQVDBnSjI5aWFtVmpkQ2NnSmlZZ1gzWmhiQ0FoUFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNCcFppQW9JWE5sZEVoaGMwVnhkV0ZzUld4bGJXVnVkQ2h6WlhRc0lGOTJZV3dzSUhOMGNtbGpkQ3dnYldWdGJ5a3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb0lYTjBjbWxqZENBbUppQWhZUzVvWVhNb1gzWmhiQ2tnSmlZZ0lYTmxkRWhoYzBWeGRXRnNSV3hsYldWdWRDaHpaWFFzSUY5MllXd3NJSE4wY21samRDd2diV1Z0YnlrcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJSEpsZEhWeWJpQnpaWFF1YzJsNlpTQTlQVDBnTUR0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCMGNuVmxPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnRZWEJJWVhORmNYVmhiRVZ1ZEhKNUtITmxkQ3dnYldGd0xDQnJaWGt4TENCcGRHVnRNU3dnYzNSeWFXTjBMQ0J0WlcxdktTQjdYRzRnSUM4dklGUnZJR0psSUdGaWJHVWdkRzhnYUdGdVpHeGxJR05oYzJWeklHeHBhMlU2WEc0Z0lDOHZJQ0FnVFdGd0tGdGJlMzBzSUNkaEoxMHNJRnQ3ZlN3Z0oySW5YVjBwSUhaeklFMWhjQ2hiVzN0OUxDQW5ZaWRkTENCYmUzMHNJQ2RoSjExZEtWeHVJQ0F2THlBdUxpNGdkMlVnYm1WbFpDQjBieUJqYjI1emFXUmxjaUFxWVd4c0tpQnRZWFJqYUdsdVp5QnJaWGx6TENCdWIzUWdhblZ6ZENCMGFHVWdabWx5YzNRZ2QyVWdabWx1WkM1Y2JpQWdkbUZ5SUhObGRGWmhiSFZsY3lBOUlHRnljbUY1Um5KdmJWTmxkQ2h6WlhRcE8xeHVYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2MyVjBWbUZzZFdWekxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdkbUZ5SUd0bGVUSWdQU0J6WlhSV1lXeDFaWE5iYVYwN1hHNWNiaUFnSUNCcFppQW9hVzV1WlhKRVpXVndSWEYxWVd3b2EyVjVNU3dnYTJWNU1pd2djM1J5YVdOMExDQnRaVzF2S1NBbUppQnBibTVsY2tSbFpYQkZjWFZoYkNocGRHVnRNU3dnYldGd0xtZGxkQ2hyWlhreUtTd2djM1J5YVdOMExDQnRaVzF2S1NrZ2UxeHVJQ0FnSUNBZ2MyVjBMbVJsYkdWMFpTaHJaWGt5S1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUIwY25WbE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCbVlXeHpaVHRjYm4xY2JseHVablZ1WTNScGIyNGdiV0Z3UlhGMWFYWW9ZU3dnWWl3Z2MzUnlhV04wTENCdFpXMXZLU0I3WEc0Z0lIWmhjaUJ6WlhRZ1BTQnVkV3hzTzF4dUlDQjJZWElnWVVWdWRISnBaWE1nUFNCaGNuSmhlVVp5YjIxTllYQW9ZU2s3WEc1Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JoUlc1MGNtbGxjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUhaaGNpQmZZVVZ1ZEhKcFpYTWthU0E5SUY5emJHbGpaV1JVYjBGeWNtRjVLR0ZGYm5SeWFXVnpXMmxkTENBeUtTeGNiaUFnSUNBZ0lDQWdhMlY1SUQwZ1gyRkZiblJ5YVdWekpHbGJNRjBzWEc0Z0lDQWdJQ0FnSUdsMFpXMHhJRDBnWDJGRmJuUnlhV1Z6SkdsYk1WMDdYRzVjYmlBZ0lDQnBaaUFvWDNSNWNHVnZaaWhyWlhrcElEMDlQU0FuYjJKcVpXTjBKeUFtSmlCclpYa2dJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJR2xtSUNoelpYUWdQVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJQ0FnYzJWMElEMGdibVYzSUZObGRDZ3BPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J6WlhRdVlXUmtLR3RsZVNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQzh2SUVKNUlHUnBjbVZqZEd4NUlISmxkSEpwWlhacGJtY2dkR2hsSUhaaGJIVmxJSGRsSUhCeVpYWmxiblFnWVc1dmRHaGxjaUJpTG1oaGN5aHJaWGtwSUdOb1pXTnJJR2x1WEc0Z0lDQWdJQ0F2THlCaGJHMXZjM1FnWVd4c0lIQnZjM05wWW14bElHTmhjMlZ6TGx4dUlDQWdJQ0FnZG1GeUlHbDBaVzB5SUQwZ1lpNW5aWFFvYTJWNUtUdGNibHh1SUNBZ0lDQWdhV1lnS0dsMFpXMHlJRDA5UFNCMWJtUmxabWx1WldRZ0ppWWdJV0l1YUdGektHdGxlU2tnZkh3Z0lXbHVibVZ5UkdWbGNFVnhkV0ZzS0dsMFpXMHhMQ0JwZEdWdE1pd2djM1J5YVdOMExDQnRaVzF2S1NrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvYzNSeWFXTjBLU0J5WlhSMWNtNGdabUZzYzJVN0lDOHZJRVpoYzNRZ2NHRjBhQ0IwYnlCa1pYUmxZM1FnYldsemMybHVaeUJ6ZEhKcGJtY3NJSE41YldKdmJDd2dkVzVrWldacGJtVmtJR0Z1WkNCdWRXeHNYRzRnSUNBZ0lDQWdJQzh2SUd0bGVYTXVYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tDRnRZWEJOYVdkb2RFaGhkbVZNYjI5elpWQnlhVzBvWVN3Z1lpd2dhMlY1TENCcGRHVnRNU3dnYldWdGJ5a3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvYzJWMElEMDlQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQWdJQ0FnYzJWMElEMGdibVYzSUZObGRDZ3BPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2MyVjBMbUZrWkNoclpYa3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR2xtSUNoelpYUWdJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQjJZWElnWWtWdWRISnBaWE1nUFNCaGNuSmhlVVp5YjIxTllYQW9ZaWs3WEc1Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJmYVRJZ1BTQXdPeUJmYVRJZ1BDQmlSVzUwY21sbGN5NXNaVzVuZEdnN0lGOXBNaXNyS1NCN1hHNGdJQ0FnSUNCMllYSWdYMkpGYm5SeWFXVnpKRjlwSUQwZ1gzTnNhV05sWkZSdlFYSnlZWGtvWWtWdWRISnBaWE5iWDJreVhTd2dNaWtzWEc0Z0lDQWdJQ0FnSUNBZ2EyVjVJRDBnWDJKRmJuUnlhV1Z6SkY5cFd6QmRMRnh1SUNBZ0lDQWdJQ0FnSUdsMFpXMGdQU0JmWWtWdWRISnBaWE1rWDJsYk1WMDdYRzVjYmlBZ0lDQWdJR2xtSUNoZmRIbHdaVzltS0d0bGVTa2dQVDA5SUNkdlltcGxZM1FuSUNZbUlHdGxlU0FoUFQwZ2JuVnNiQ2tnZTF4dUlDQWdJQ0FnSUNCcFppQW9JVzFoY0VoaGMwVnhkV0ZzUlc1MGNua29jMlYwTENCaExDQnJaWGtzSUdsMFpXMHNJSE4wY21samRDd2diV1Z0YnlrcElISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvSVhOMGNtbGpkQ0FtSmlBb0lXRXVhR0Z6S0d0bGVTa2dmSHdnSVdsdWJtVnlSR1ZsY0VWeGRXRnNLR0V1WjJWMEtHdGxlU2tzSUdsMFpXMHNJR1poYkhObExDQnRaVzF2S1NrZ0ppWWdJVzFoY0VoaGMwVnhkV0ZzUlc1MGNua29jMlYwTENCaExDQnJaWGtzSUdsMFpXMHNJR1poYkhObExDQnRaVzF2S1NrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlITmxkQzV6YVhwbElEMDlQU0F3TzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhSeWRXVTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHOWlha1Z4ZFdsMktHRXNJR0lzSUhOMGNtbGpkQ3dnYTJWNWN5d2diV1Z0YjNNc0lHbDBaWEpoZEdsdmJsUjVjR1VwSUh0Y2JpQWdMeThnVTJWMGN5QmhibVFnYldGd2N5QmtiMjRuZENCb1lYWmxJSFJvWldseUlHVnVkSEpwWlhNZ1lXTmpaWE56YVdKc1pTQjJhV0VnYm05eWJXRnNJRzlpYW1WamRGeHVJQ0F2THlCd2NtOXdaWEowYVdWekxseHVJQ0IyWVhJZ2FTQTlJREE3WEc1Y2JpQWdhV1lnS0dsMFpYSmhkR2x2YmxSNWNHVWdQVDA5SUd0SmMxTmxkQ2tnZTF4dUlDQWdJR2xtSUNnaGMyVjBSWEYxYVhZb1lTd2dZaXdnYzNSeWFXTjBMQ0J0WlcxdmN5a3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCcFppQW9hWFJsY21GMGFXOXVWSGx3WlNBOVBUMGdhMGx6VFdGd0tTQjdYRzRnSUNBZ2FXWWdLQ0Z0WVhCRmNYVnBkaWhoTENCaUxDQnpkSEpwWTNRc0lHMWxiVzl6S1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lIMWNiaUFnZlNCbGJITmxJR2xtSUNocGRHVnlZWFJwYjI1VWVYQmxJRDA5UFNCclNYTkJjbkpoZVNrZ2UxeHVJQ0FnSUdadmNpQW9PeUJwSUR3Z1lTNXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnYVdZZ0tHaGhjMDkzYmxCeWIzQmxjblI1S0dFc0lHa3BLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hhR0Z6VDNkdVVISnZjR1Z5ZEhrb1lpd2dhU2tnZkh3Z0lXbHVibVZ5UkdWbGNFVnhkV0ZzS0dGYmFWMHNJR0piYVYwc0lITjBjbWxqZEN3Z2JXVnRiM01wS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHaGhjMDkzYmxCeWIzQmxjblI1S0dJc0lHa3BLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDOHZJRUZ5Y21GNUlHbHpJSE53WVhKelpTNWNiaUFnSUNBZ0lDQWdkbUZ5SUd0bGVYTkJJRDBnVDJKcVpXTjBMbXRsZVhNb1lTazdYRzVjYmlBZ0lDQWdJQ0FnWm05eUlDZzdJR2tnUENCclpYbHpRUzVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJSFpoY2lCclpYa2dQU0JyWlhselFWdHBYVHRjYmx4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2doYUdGelQzZHVVSEp2Y0dWeWRIa29ZaXdnYTJWNUtTQjhmQ0FoYVc1dVpYSkVaV1Z3UlhGMVlXd29ZVnRyWlhsZExDQmlXMnRsZVYwc0lITjBjbWxqZEN3Z2JXVnRiM01wS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLR3RsZVhOQkxteGxibWQwYUNBaFBUMGdUMkpxWldOMExtdGxlWE1vWWlrdWJHVnVaM1JvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOUlDOHZJRlJvWlNCd1lXbHlJRzExYzNRZ2FHRjJaU0JsY1hWcGRtRnNaVzUwSUhaaGJIVmxjeUJtYjNJZ1pYWmxjbmtnWTI5eWNtVnpjRzl1WkdsdVp5QnJaWGt1WEc0Z0lDOHZJRkJ2YzNOcFlteDVJR1Y0Y0dWdWMybDJaU0JrWldWd0lIUmxjM1E2WEc1Y2JseHVJQ0JtYjNJZ0tHa2dQU0F3T3lCcElEd2dhMlY1Y3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lIWmhjaUJmYTJWNUlEMGdhMlY1YzF0cFhUdGNibHh1SUNBZ0lHbG1JQ2doYVc1dVpYSkVaV1Z3UlhGMVlXd29ZVnRmYTJWNVhTd2dZbHRmYTJWNVhTd2djM1J5YVdOMExDQnRaVzF2Y3lrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYVhORVpXVndSWEYxWVd3b2RtRnNNU3dnZG1Gc01pa2dlMXh1SUNCeVpYUjFjbTRnYVc1dVpYSkVaV1Z3UlhGMVlXd29kbUZzTVN3Z2RtRnNNaXdnYTB4dmIzTmxLVHRjYm4xY2JseHVablZ1WTNScGIyNGdhWE5FWldWd1UzUnlhV04wUlhGMVlXd29kbUZzTVN3Z2RtRnNNaWtnZTF4dUlDQnlaWFIxY200Z2FXNXVaWEpFWldWd1JYRjFZV3dvZG1Gc01Td2dkbUZzTWl3Z2ExTjBjbWxqZENrN1hHNTlYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZTF4dUlDQnBjMFJsWlhCRmNYVmhiRG9nYVhORVpXVndSWEYxWVd3c1hHNGdJR2x6UkdWbGNGTjBjbWxqZEVWeGRXRnNPaUJwYzBSbFpYQlRkSEpwWTNSRmNYVmhiRnh1ZlRzaUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUJtYVd4MFpYSWdQU0J5WlhGMWFYSmxLQ2RoY25KaGVTMW1hV3gwWlhJbktUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJoZG1GcGJHRmliR1ZVZVhCbFpFRnljbUY1Y3lncElIdGNibHgwY21WMGRYSnVJR1pwYkhSbGNpaGJYRzVjZEZ4MEowSnBaMGx1ZERZMFFYSnlZWGtuTEZ4dVhIUmNkQ2RDYVdkVmFXNTBOalJCY25KaGVTY3NYRzVjZEZ4MEowWnNiMkYwTXpKQmNuSmhlU2NzWEc1Y2RGeDBKMFpzYjJGME5qUkJjbkpoZVNjc1hHNWNkRngwSjBsdWRERTJRWEp5WVhrbkxGeHVYSFJjZENkSmJuUXpNa0Z5Y21GNUp5eGNibHgwWEhRblNXNTBPRUZ5Y21GNUp5eGNibHgwWEhRblZXbHVkREUyUVhKeVlYa25MRnh1WEhSY2RDZFZhVzUwTXpKQmNuSmhlU2NzWEc1Y2RGeDBKMVZwYm5RNFFYSnlZWGtuTEZ4dVhIUmNkQ2RWYVc1ME9FTnNZVzF3WldSQmNuSmhlU2RjYmx4MFhTd2dablZ1WTNScGIyNGdLSFI1Y0dWa1FYSnlZWGtwSUh0Y2JseDBYSFJ5WlhSMWNtNGdkSGx3Wlc5bUlHZHNiMkpoYkZ0MGVYQmxaRUZ5Y21GNVhTQTlQVDBnSjJaMWJtTjBhVzl1Snp0Y2JseDBmU2s3WEc1OU8xeHVJaXdpYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0J5WlhGMWFYSmxLQ2N1TDJ4cFlpOWhlR2x2Y3ljcE95SXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVkbUZ5SUhWMGFXeHpJRDBnY21WeGRXbHlaU2duTGk4dUxpOTFkR2xzY3ljcE8xeHVkbUZ5SUhObGRIUnNaU0E5SUhKbGNYVnBjbVVvSnk0dkxpNHZZMjl5WlM5elpYUjBiR1VuS1R0Y2JuWmhjaUJqYjI5cmFXVnpJRDBnY21WeGRXbHlaU2duTGk4dUxpOW9aV3h3WlhKekwyTnZiMnRwWlhNbktUdGNiblpoY2lCaWRXbHNaRlZTVENBOUlISmxjWFZwY21Vb0p5NHZMaTR2YUdWc2NHVnljeTlpZFdsc1pGVlNUQ2NwTzF4dWRtRnlJR0oxYVd4a1JuVnNiRkJoZEdnZ1BTQnlaWEYxYVhKbEtDY3VMaTlqYjNKbEwySjFhV3hrUm5Wc2JGQmhkR2duS1R0Y2JuWmhjaUJ3WVhKelpVaGxZV1JsY25NZ1BTQnlaWEYxYVhKbEtDY3VMeTR1TDJobGJIQmxjbk12Y0dGeWMyVklaV0ZrWlhKekp5azdYRzUyWVhJZ2FYTlZVa3hUWVcxbFQzSnBaMmx1SUQwZ2NtVnhkV2x5WlNnbkxpOHVMaTlvWld4d1pYSnpMMmx6VlZKTVUyRnRaVTl5YVdkcGJpY3BPMXh1ZG1GeUlHTnlaV0YwWlVWeWNtOXlJRDBnY21WeGRXbHlaU2duTGk0dlkyOXlaUzlqY21WaGRHVkZjbkp2Y2ljcE8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJSGhvY2tGa1lYQjBaWElvWTI5dVptbG5LU0I3WEc0Z0lISmxkSFZ5YmlCdVpYY2dVSEp2YldselpTaG1kVzVqZEdsdmJpQmthWE53WVhSamFGaG9jbEpsY1hWbGMzUW9jbVZ6YjJ4MlpTd2djbVZxWldOMEtTQjdYRzRnSUNBZ2RtRnlJSEpsY1hWbGMzUkVZWFJoSUQwZ1kyOXVabWxuTG1SaGRHRTdYRzRnSUNBZ2RtRnlJSEpsY1hWbGMzUklaV0ZrWlhKeklEMGdZMjl1Wm1sbkxtaGxZV1JsY25NN1hHNWNiaUFnSUNCcFppQW9kWFJwYkhNdWFYTkdiM0p0UkdGMFlTaHlaWEYxWlhOMFJHRjBZU2twSUh0Y2JpQWdJQ0FnSUdSbGJHVjBaU0J5WlhGMVpYTjBTR1ZoWkdWeWMxc25RMjl1ZEdWdWRDMVVlWEJsSjEwN0lDOHZJRXhsZENCMGFHVWdZbkp2ZDNObGNpQnpaWFFnYVhSY2JpQWdJQ0I5WEc1Y2JpQWdJQ0IyWVhJZ2NtVnhkV1Z6ZENBOUlHNWxkeUJZVFV4SWRIUndVbVZ4ZFdWemRDZ3BPMXh1WEc0Z0lDQWdMeThnU0ZSVVVDQmlZWE5wWXlCaGRYUm9aVzUwYVdOaGRHbHZibHh1SUNBZ0lHbG1JQ2hqYjI1bWFXY3VZWFYwYUNrZ2UxeHVJQ0FnSUNBZ2RtRnlJSFZ6WlhKdVlXMWxJRDBnWTI5dVptbG5MbUYxZEdndWRYTmxjbTVoYldVZ2ZId2dKeWM3WEc0Z0lDQWdJQ0IyWVhJZ2NHRnpjM2R2Y21RZ1BTQmpiMjVtYVdjdVlYVjBhQzV3WVhOemQyOXlaQ0EvSUhWdVpYTmpZWEJsS0dWdVkyOWtaVlZTU1VOdmJYQnZibVZ1ZENoamIyNW1hV2N1WVhWMGFDNXdZWE56ZDI5eVpDa3BJRG9nSnljN1hHNGdJQ0FnSUNCeVpYRjFaWE4wU0dWaFpHVnljeTVCZFhSb2IzSnBlbUYwYVc5dUlEMGdKMEpoYzJsaklDY2dLeUJpZEc5aEtIVnpaWEp1WVcxbElDc2dKem9uSUNzZ2NHRnpjM2R2Y21RcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhaaGNpQm1kV3hzVUdGMGFDQTlJR0oxYVd4a1JuVnNiRkJoZEdnb1kyOXVabWxuTG1KaGMyVlZVa3dzSUdOdmJtWnBaeTUxY213cE8xeHVJQ0FnSUhKbGNYVmxjM1F1YjNCbGJpaGpiMjVtYVdjdWJXVjBhRzlrTG5SdlZYQndaWEpEWVhObEtDa3NJR0oxYVd4a1ZWSk1LR1oxYkd4UVlYUm9MQ0JqYjI1bWFXY3VjR0Z5WVcxekxDQmpiMjVtYVdjdWNHRnlZVzF6VTJWeWFXRnNhWHBsY2lrc0lIUnlkV1VwTzF4dVhHNGdJQ0FnTHk4Z1UyVjBJSFJvWlNCeVpYRjFaWE4wSUhScGJXVnZkWFFnYVc0Z1RWTmNiaUFnSUNCeVpYRjFaWE4wTG5ScGJXVnZkWFFnUFNCamIyNW1hV2N1ZEdsdFpXOTFkRHRjYmx4dUlDQWdJQzh2SUV4cGMzUmxiaUJtYjNJZ2NtVmhaSGtnYzNSaGRHVmNiaUFnSUNCeVpYRjFaWE4wTG05dWNtVmhaSGx6ZEdGMFpXTm9ZVzVuWlNBOUlHWjFibU4wYVc5dUlHaGhibVJzWlV4dllXUW9LU0I3WEc0Z0lDQWdJQ0JwWmlBb0lYSmxjWFZsYzNRZ2ZId2djbVZ4ZFdWemRDNXlaV0ZrZVZOMFlYUmxJQ0U5UFNBMEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdMeThnVkdobElISmxjWFZsYzNRZ1pYSnliM0psWkNCdmRYUWdZVzVrSUhkbElHUnBaRzRuZENCblpYUWdZU0J5WlhOd2IyNXpaU3dnZEdocGN5QjNhV3hzSUdKbFhHNGdJQ0FnSUNBdkx5Qm9ZVzVrYkdWa0lHSjVJRzl1WlhKeWIzSWdhVzV6ZEdWaFpGeHVJQ0FnSUNBZ0x5OGdWMmwwYUNCdmJtVWdaWGhqWlhCMGFXOXVPaUJ5WlhGMVpYTjBJSFJvWVhRZ2RYTnBibWNnWm1sc1pUb2djSEp2ZEc5amIyd3NJRzF2YzNRZ1luSnZkM05sY25OY2JpQWdJQ0FnSUM4dklIZHBiR3dnY21WMGRYSnVJSE4wWVhSMWN5QmhjeUF3SUdWMlpXNGdkR2h2ZFdkb0lHbDBKM01nWVNCemRXTmpaWE56Wm5Wc0lISmxjWFZsYzNSY2JpQWdJQ0FnSUdsbUlDaHlaWEYxWlhOMExuTjBZWFIxY3lBOVBUMGdNQ0FtSmlBaEtISmxjWFZsYzNRdWNtVnpjRzl1YzJWVlVrd2dKaVlnY21WeGRXVnpkQzV5WlhOd2IyNXpaVlZTVEM1cGJtUmxlRTltS0NkbWFXeGxPaWNwSUQwOVBTQXdLU2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTQ3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUM4dklGQnlaWEJoY21VZ2RHaGxJSEpsYzNCdmJuTmxYRzRnSUNBZ0lDQjJZWElnY21WemNHOXVjMlZJWldGa1pYSnpJRDBnSjJkbGRFRnNiRkpsYzNCdmJuTmxTR1ZoWkdWeWN5Y2dhVzRnY21WeGRXVnpkQ0EvSUhCaGNuTmxTR1ZoWkdWeWN5aHlaWEYxWlhOMExtZGxkRUZzYkZKbGMzQnZibk5sU0dWaFpHVnljeWdwS1NBNklHNTFiR3c3WEc0Z0lDQWdJQ0IyWVhJZ2NtVnpjRzl1YzJWRVlYUmhJRDBnSVdOdmJtWnBaeTV5WlhOd2IyNXpaVlI1Y0dVZ2ZId2dZMjl1Wm1sbkxuSmxjM0J2Ym5ObFZIbHdaU0E5UFQwZ0ozUmxlSFFuSUQ4Z2NtVnhkV1Z6ZEM1eVpYTndiMjV6WlZSbGVIUWdPaUJ5WlhGMVpYTjBMbkpsYzNCdmJuTmxPMXh1SUNBZ0lDQWdkbUZ5SUhKbGMzQnZibk5sSUQwZ2UxeHVJQ0FnSUNBZ0lDQmtZWFJoT2lCeVpYTndiMjV6WlVSaGRHRXNYRzRnSUNBZ0lDQWdJSE4wWVhSMWN6b2djbVZ4ZFdWemRDNXpkR0YwZFhNc1hHNGdJQ0FnSUNBZ0lITjBZWFIxYzFSbGVIUTZJSEpsY1hWbGMzUXVjM1JoZEhWelZHVjRkQ3hjYmlBZ0lDQWdJQ0FnYUdWaFpHVnljem9nY21WemNHOXVjMlZJWldGa1pYSnpMRnh1SUNBZ0lDQWdJQ0JqYjI1bWFXYzZJR052Ym1acFp5eGNiaUFnSUNBZ0lDQWdjbVZ4ZFdWemREb2djbVZ4ZFdWemRGeHVJQ0FnSUNBZ2ZUdGNibHh1SUNBZ0lDQWdjMlYwZEd4bEtISmxjMjlzZG1Vc0lISmxhbVZqZEN3Z2NtVnpjRzl1YzJVcE8xeHVYRzRnSUNBZ0lDQXZMeUJEYkdWaGJpQjFjQ0J5WlhGMVpYTjBYRzRnSUNBZ0lDQnlaWEYxWlhOMElEMGdiblZzYkR0Y2JpQWdJQ0I5TzF4dVhHNGdJQ0FnTHk4Z1NHRnVaR3hsSUdKeWIzZHpaWElnY21WeGRXVnpkQ0JqWVc1alpXeHNZWFJwYjI0Z0tHRnpJRzl3Y0c5elpXUWdkRzhnWVNCdFlXNTFZV3dnWTJGdVkyVnNiR0YwYVc5dUtWeHVJQ0FnSUhKbGNYVmxjM1F1YjI1aFltOXlkQ0E5SUdaMWJtTjBhVzl1SUdoaGJtUnNaVUZpYjNKMEtDa2dlMXh1SUNBZ0lDQWdhV1lnS0NGeVpYRjFaWE4wS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2NtVnFaV04wS0dOeVpXRjBaVVZ5Y205eUtDZFNaWEYxWlhOMElHRmliM0owWldRbkxDQmpiMjVtYVdjc0lDZEZRMDlPVGtGQ1QxSlVSVVFuTENCeVpYRjFaWE4wS1NrN1hHNWNiaUFnSUNBZ0lDOHZJRU5zWldGdUlIVndJSEpsY1hWbGMzUmNiaUFnSUNBZ0lISmxjWFZsYzNRZ1BTQnVkV3hzTzF4dUlDQWdJSDA3WEc1Y2JpQWdJQ0F2THlCSVlXNWtiR1VnYkc5M0lHeGxkbVZzSUc1bGRIZHZjbXNnWlhKeWIzSnpYRzRnSUNBZ2NtVnhkV1Z6ZEM1dmJtVnljbTl5SUQwZ1puVnVZM1JwYjI0Z2FHRnVaR3hsUlhKeWIzSW9LU0I3WEc0Z0lDQWdJQ0F2THlCU1pXRnNJR1Z5Y205eWN5QmhjbVVnYUdsa1pHVnVJR1p5YjIwZ2RYTWdZbmtnZEdobElHSnliM2R6WlhKY2JpQWdJQ0FnSUM4dklHOXVaWEp5YjNJZ2MyaHZkV3hrSUc5dWJIa2dabWx5WlNCcFppQnBkQ2R6SUdFZ2JtVjBkMjl5YXlCbGNuSnZjbHh1SUNBZ0lDQWdjbVZxWldOMEtHTnlaV0YwWlVWeWNtOXlLQ2RPWlhSM2IzSnJJRVZ5Y205eUp5d2dZMjl1Wm1sbkxDQnVkV3hzTENCeVpYRjFaWE4wS1NrN1hHNWNiaUFnSUNBZ0lDOHZJRU5zWldGdUlIVndJSEpsY1hWbGMzUmNiaUFnSUNBZ0lISmxjWFZsYzNRZ1BTQnVkV3hzTzF4dUlDQWdJSDA3WEc1Y2JpQWdJQ0F2THlCSVlXNWtiR1VnZEdsdFpXOTFkRnh1SUNBZ0lISmxjWFZsYzNRdWIyNTBhVzFsYjNWMElEMGdablZ1WTNScGIyNGdhR0Z1Wkd4bFZHbHRaVzkxZENncElIdGNiaUFnSUNBZ0lIWmhjaUIwYVcxbGIzVjBSWEp5YjNKTlpYTnpZV2RsSUQwZ0ozUnBiV1Z2ZFhRZ2IyWWdKeUFySUdOdmJtWnBaeTUwYVcxbGIzVjBJQ3NnSjIxeklHVjRZMlZsWkdWa0p6dGNiaUFnSUNBZ0lHbG1JQ2hqYjI1bWFXY3VkR2x0Wlc5MWRFVnljbTl5VFdWemMyRm5aU2tnZTF4dUlDQWdJQ0FnSUNCMGFXMWxiM1YwUlhKeWIzSk5aWE56WVdkbElEMGdZMjl1Wm1sbkxuUnBiV1Z2ZFhSRmNuSnZjazFsYzNOaFoyVTdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnlaV3BsWTNRb1kzSmxZWFJsUlhKeWIzSW9kR2x0Wlc5MWRFVnljbTl5VFdWemMyRm5aU3dnWTI5dVptbG5MQ0FuUlVOUFRrNUJRazlTVkVWRUp5eGNiaUFnSUNBZ0lDQWdjbVZ4ZFdWemRDa3BPMXh1WEc0Z0lDQWdJQ0F2THlCRGJHVmhiaUIxY0NCeVpYRjFaWE4wWEc0Z0lDQWdJQ0J5WlhGMVpYTjBJRDBnYm5Wc2JEdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ0x5OGdRV1JrSUhoemNtWWdhR1ZoWkdWeVhHNGdJQ0FnTHk4Z1ZHaHBjeUJwY3lCdmJteDVJR1J2Ym1VZ2FXWWdjblZ1Ym1sdVp5QnBiaUJoSUhOMFlXNWtZWEprSUdKeWIzZHpaWElnWlc1MmFYSnZibTFsYm5RdVhHNGdJQ0FnTHk4Z1UzQmxZMmxtYVdOaGJHeDVJRzV2ZENCcFppQjNaU2R5WlNCcGJpQmhJSGRsWWlCM2IzSnJaWElzSUc5eUlISmxZV04wTFc1aGRHbDJaUzVjYmlBZ0lDQnBaaUFvZFhScGJITXVhWE5UZEdGdVpHRnlaRUp5YjNkelpYSkZibllvS1NrZ2UxeHVJQ0FnSUNBZ0x5OGdRV1JrSUhoemNtWWdhR1ZoWkdWeVhHNGdJQ0FnSUNCMllYSWdlSE55WmxaaGJIVmxJRDBnS0dOdmJtWnBaeTUzYVhSb1EzSmxaR1Z1ZEdsaGJITWdmSHdnYVhOVlVreFRZVzFsVDNKcFoybHVLR1oxYkd4UVlYUm9LU2tnSmlZZ1kyOXVabWxuTG5oemNtWkRiMjlyYVdWT1lXMWxJRDljYmlBZ0lDQWdJQ0FnWTI5dmEybGxjeTV5WldGa0tHTnZibVpwWnk1NGMzSm1RMjl2YTJsbFRtRnRaU2tnT2x4dUlDQWdJQ0FnSUNCMWJtUmxabWx1WldRN1hHNWNiaUFnSUNBZ0lHbG1JQ2g0YzNKbVZtRnNkV1VwSUh0Y2JpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEVobFlXUmxjbk5iWTI5dVptbG5Mbmh6Y21aSVpXRmtaWEpPWVcxbFhTQTlJSGh6Y21aV1lXeDFaVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJCWkdRZ2FHVmhaR1Z5Y3lCMGJ5QjBhR1VnY21WeGRXVnpkRnh1SUNBZ0lHbG1JQ2duYzJWMFVtVnhkV1Z6ZEVobFlXUmxjaWNnYVc0Z2NtVnhkV1Z6ZENrZ2UxeHVJQ0FnSUNBZ2RYUnBiSE11Wm05eVJXRmphQ2h5WlhGMVpYTjBTR1ZoWkdWeWN5d2dablZ1WTNScGIyNGdjMlYwVW1WeGRXVnpkRWhsWVdSbGNpaDJZV3dzSUd0bGVTa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2RIbHdaVzltSUhKbGNYVmxjM1JFWVhSaElEMDlQU0FuZFc1a1pXWnBibVZrSnlBbUppQnJaWGt1ZEc5TWIzZGxja05oYzJVb0tTQTlQVDBnSjJOdmJuUmxiblF0ZEhsd1pTY3BJSHRjYmlBZ0lDQWdJQ0FnSUNBdkx5QlNaVzF2ZG1VZ1EyOXVkR1Z1ZEMxVWVYQmxJR2xtSUdSaGRHRWdhWE1nZFc1a1pXWnBibVZrWEc0Z0lDQWdJQ0FnSUNBZ1pHVnNaWFJsSUhKbGNYVmxjM1JJWldGa1pYSnpXMnRsZVYwN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnVDNSb1pYSjNhWE5sSUdGa1pDQm9aV0ZrWlhJZ2RHOGdkR2hsSUhKbGNYVmxjM1JjYmlBZ0lDQWdJQ0FnSUNCeVpYRjFaWE4wTG5ObGRGSmxjWFZsYzNSSVpXRmtaWElvYTJWNUxDQjJZV3dwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOUtUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QkJaR1FnZDJsMGFFTnlaV1JsYm5ScFlXeHpJSFJ2SUhKbGNYVmxjM1FnYVdZZ2JtVmxaR1ZrWEc0Z0lDQWdhV1lnS0NGMWRHbHNjeTVwYzFWdVpHVm1hVzVsWkNoamIyNW1hV2N1ZDJsMGFFTnlaV1JsYm5ScFlXeHpLU2tnZTF4dUlDQWdJQ0FnY21WeGRXVnpkQzUzYVhSb1EzSmxaR1Z1ZEdsaGJITWdQU0FoSVdOdmJtWnBaeTUzYVhSb1EzSmxaR1Z1ZEdsaGJITTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdRV1JrSUhKbGMzQnZibk5sVkhsd1pTQjBieUJ5WlhGMVpYTjBJR2xtSUc1bFpXUmxaRnh1SUNBZ0lHbG1JQ2hqYjI1bWFXY3VjbVZ6Y0c5dWMyVlVlWEJsS1NCN1hHNGdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0J5WlhGMVpYTjBMbkpsYzNCdmJuTmxWSGx3WlNBOUlHTnZibVpwWnk1eVpYTndiMjV6WlZSNWNHVTdYRzRnSUNBZ0lDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdJQ0FnSUM4dklFVjRjR1ZqZEdWa0lFUlBUVVY0WTJWd2RHbHZiaUIwYUhKdmQyNGdZbmtnWW5KdmQzTmxjbk1nYm05MElHTnZiWEJoZEdsaWJHVWdXRTFNU0hSMGNGSmxjWFZsYzNRZ1RHVjJaV3dnTWk1Y2JpQWdJQ0FnSUNBZ0x5OGdRblYwTENCMGFHbHpJR05oYmlCaVpTQnpkWEJ3Y21WemMyVmtJR1p2Y2lBbmFuTnZiaWNnZEhsd1pTQmhjeUJwZENCallXNGdZbVVnY0dGeWMyVmtJR0o1SUdSbFptRjFiSFFnSjNSeVlXNXpabTl5YlZKbGMzQnZibk5sSnlCbWRXNWpkR2x2Ymk1Y2JpQWdJQ0FnSUNBZ2FXWWdLR052Ym1acFp5NXlaWE53YjI1elpWUjVjR1VnSVQwOUlDZHFjMjl1SnlrZ2UxeHVJQ0FnSUNBZ0lDQWdJSFJvY205M0lHVTdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJJWVc1a2JHVWdjSEp2WjNKbGMzTWdhV1lnYm1WbFpHVmtYRzRnSUNBZ2FXWWdLSFI1Y0dWdlppQmpiMjVtYVdjdWIyNUViM2R1Ykc5aFpGQnliMmR5WlhOeklEMDlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnSUNCeVpYRjFaWE4wTG1Ga1pFVjJaVzUwVEdsemRHVnVaWElvSjNCeWIyZHlaWE56Snl3Z1kyOXVabWxuTG05dVJHOTNibXh2WVdSUWNtOW5jbVZ6Y3lrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1RtOTBJR0ZzYkNCaWNtOTNjMlZ5Y3lCemRYQndiM0owSUhWd2JHOWhaQ0JsZG1WdWRITmNiaUFnSUNCcFppQW9kSGx3Wlc5bUlHTnZibVpwWnk1dmJsVndiRzloWkZCeWIyZHlaWE56SUQwOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUhKbGNYVmxjM1F1ZFhCc2IyRmtLU0I3WEc0Z0lDQWdJQ0J5WlhGMVpYTjBMblZ3Ykc5aFpDNWhaR1JGZG1WdWRFeHBjM1JsYm1WeUtDZHdjbTluY21WemN5Y3NJR052Ym1acFp5NXZibFZ3Ykc5aFpGQnliMmR5WlhOektUdGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9ZMjl1Wm1sbkxtTmhibU5sYkZSdmEyVnVLU0I3WEc0Z0lDQWdJQ0F2THlCSVlXNWtiR1VnWTJGdVkyVnNiR0YwYVc5dVhHNGdJQ0FnSUNCamIyNW1hV2N1WTJGdVkyVnNWRzlyWlc0dWNISnZiV2x6WlM1MGFHVnVLR1oxYm1OMGFXOXVJRzl1UTJGdVkyVnNaV1FvWTJGdVkyVnNLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hjbVZ4ZFdWemRDa2dlMXh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnlianRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lISmxjWFZsYzNRdVlXSnZjblFvS1R0Y2JpQWdJQ0FnSUNBZ2NtVnFaV04wS0dOaGJtTmxiQ2s3WEc0Z0lDQWdJQ0FnSUM4dklFTnNaV0Z1SUhWd0lISmxjWFZsYzNSY2JpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZENBOUlHNTFiR3c3WEc0Z0lDQWdJQ0I5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JwWmlBb0lYSmxjWFZsYzNSRVlYUmhLU0I3WEc0Z0lDQWdJQ0J5WlhGMVpYTjBSR0YwWVNBOUlHNTFiR3c3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnVTJWdVpDQjBhR1VnY21WeGRXVnpkRnh1SUNBZ0lISmxjWFZsYzNRdWMyVnVaQ2h5WlhGMVpYTjBSR0YwWVNrN1hHNGdJSDBwTzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1ZG1GeUlIVjBhV3h6SUQwZ2NtVnhkV2x5WlNnbkxpOTFkR2xzY3ljcE8xeHVkbUZ5SUdKcGJtUWdQU0J5WlhGMWFYSmxLQ2N1TDJobGJIQmxjbk12WW1sdVpDY3BPMXh1ZG1GeUlFRjRhVzl6SUQwZ2NtVnhkV2x5WlNnbkxpOWpiM0psTDBGNGFXOXpKeWs3WEc1MllYSWdiV1Z5WjJWRGIyNW1hV2NnUFNCeVpYRjFhWEpsS0NjdUwyTnZjbVV2YldWeVoyVkRiMjVtYVdjbktUdGNiblpoY2lCa1pXWmhkV3gwY3lBOUlISmxjWFZwY21Vb0p5NHZaR1ZtWVhWc2RITW5LVHRjYmx4dUx5b3FYRzRnS2lCRGNtVmhkR1VnWVc0Z2FXNXpkR0Z1WTJVZ2IyWWdRWGhwYjNOY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnWkdWbVlYVnNkRU52Ym1acFp5QlVhR1VnWkdWbVlYVnNkQ0JqYjI1bWFXY2dabTl5SUhSb1pTQnBibk4wWVc1alpWeHVJQ29nUUhKbGRIVnliaUI3UVhocGIzTjlJRUVnYm1WM0lHbHVjM1JoYm1ObElHOW1JRUY0YVc5elhHNGdLaTljYm1aMWJtTjBhVzl1SUdOeVpXRjBaVWx1YzNSaGJtTmxLR1JsWm1GMWJIUkRiMjVtYVdjcElIdGNiaUFnZG1GeUlHTnZiblJsZUhRZ1BTQnVaWGNnUVhocGIzTW9aR1ZtWVhWc2RFTnZibVpwWnlrN1hHNGdJSFpoY2lCcGJuTjBZVzVqWlNBOUlHSnBibVFvUVhocGIzTXVjSEp2ZEc5MGVYQmxMbkpsY1hWbGMzUXNJR052Ym5SbGVIUXBPMXh1WEc0Z0lDOHZJRU52Y0hrZ1lYaHBiM011Y0hKdmRHOTBlWEJsSUhSdklHbHVjM1JoYm1ObFhHNGdJSFYwYVd4ekxtVjRkR1Z1WkNocGJuTjBZVzVqWlN3Z1FYaHBiM011Y0hKdmRHOTBlWEJsTENCamIyNTBaWGgwS1R0Y2JseHVJQ0F2THlCRGIzQjVJR052Ym5SbGVIUWdkRzhnYVc1emRHRnVZMlZjYmlBZ2RYUnBiSE11WlhoMFpXNWtLR2x1YzNSaGJtTmxMQ0JqYjI1MFpYaDBLVHRjYmx4dUlDQnlaWFIxY200Z2FXNXpkR0Z1WTJVN1hHNTlYRzVjYmk4dklFTnlaV0YwWlNCMGFHVWdaR1ZtWVhWc2RDQnBibk4wWVc1alpTQjBieUJpWlNCbGVIQnZjblJsWkZ4dWRtRnlJR0Y0YVc5eklEMGdZM0psWVhSbFNXNXpkR0Z1WTJVb1pHVm1ZWFZzZEhNcE8xeHVYRzR2THlCRmVIQnZjMlVnUVhocGIzTWdZMnhoYzNNZ2RHOGdZV3hzYjNjZ1kyeGhjM01nYVc1b1pYSnBkR0Z1WTJWY2JtRjRhVzl6TGtGNGFXOXpJRDBnUVhocGIzTTdYRzVjYmk4dklFWmhZM1J2Y25rZ1ptOXlJR055WldGMGFXNW5JRzVsZHlCcGJuTjBZVzVqWlhOY2JtRjRhVzl6TG1OeVpXRjBaU0E5SUdaMWJtTjBhVzl1SUdOeVpXRjBaU2hwYm5OMFlXNWpaVU52Ym1acFp5a2dlMXh1SUNCeVpYUjFjbTRnWTNKbFlYUmxTVzV6ZEdGdVkyVW9iV1Z5WjJWRGIyNW1hV2NvWVhocGIzTXVaR1ZtWVhWc2RITXNJR2x1YzNSaGJtTmxRMjl1Wm1sbktTazdYRzU5TzF4dVhHNHZMeUJGZUhCdmMyVWdRMkZ1WTJWc0lDWWdRMkZ1WTJWc1ZHOXJaVzVjYm1GNGFXOXpMa05oYm1ObGJDQTlJSEpsY1hWcGNtVW9KeTR2WTJGdVkyVnNMME5oYm1ObGJDY3BPMXh1WVhocGIzTXVRMkZ1WTJWc1ZHOXJaVzRnUFNCeVpYRjFhWEpsS0NjdUwyTmhibU5sYkM5RFlXNWpaV3hVYjJ0bGJpY3BPMXh1WVhocGIzTXVhWE5EWVc1alpXd2dQU0J5WlhGMWFYSmxLQ2N1TDJOaGJtTmxiQzlwYzBOaGJtTmxiQ2NwTzF4dVhHNHZMeUJGZUhCdmMyVWdZV3hzTDNOd2NtVmhaRnh1WVhocGIzTXVZV3hzSUQwZ1puVnVZM1JwYjI0Z1lXeHNLSEJ5YjIxcGMyVnpLU0I3WEc0Z0lISmxkSFZ5YmlCUWNtOXRhWE5sTG1Gc2JDaHdjbTl0YVhObGN5azdYRzU5TzF4dVlYaHBiM011YzNCeVpXRmtJRDBnY21WeGRXbHlaU2duTGk5b1pXeHdaWEp6TDNOd2NtVmhaQ2NwTzF4dVhHNHZMeUJGZUhCdmMyVWdhWE5CZUdsdmMwVnljbTl5WEc1aGVHbHZjeTVwYzBGNGFXOXpSWEp5YjNJZ1BTQnlaWEYxYVhKbEtDY3VMMmhsYkhCbGNuTXZhWE5CZUdsdmMwVnljbTl5SnlrN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdZWGhwYjNNN1hHNWNiaTh2SUVGc2JHOTNJSFZ6WlNCdlppQmtaV1poZFd4MElHbHRjRzl5ZENCemVXNTBZWGdnYVc0Z1ZIbHdaVk5qY21sd2RGeHViVzlrZFd4bExtVjRjRzl5ZEhNdVpHVm1ZWFZzZENBOUlHRjRhVzl6TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNHZLaXBjYmlBcUlFRWdZRU5oYm1ObGJHQWdhWE1nWVc0Z2IySnFaV04wSUhSb1lYUWdhWE1nZEdoeWIzZHVJSGRvWlc0Z1lXNGdiM0JsY21GMGFXOXVJR2x6SUdOaGJtTmxiR1ZrTGx4dUlDcGNiaUFxSUVCamJHRnpjMXh1SUNvZ1FIQmhjbUZ0SUh0emRISnBibWM5ZlNCdFpYTnpZV2RsSUZSb1pTQnRaWE56WVdkbExseHVJQ292WEc1bWRXNWpkR2x2YmlCRFlXNWpaV3dvYldWemMyRm5aU2tnZTF4dUlDQjBhR2x6TG0xbGMzTmhaMlVnUFNCdFpYTnpZV2RsTzF4dWZWeHVYRzVEWVc1alpXd3VjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5JRDBnWm5WdVkzUnBiMjRnZEc5VGRISnBibWNvS1NCN1hHNGdJSEpsZEhWeWJpQW5RMkZ1WTJWc0p5QXJJQ2gwYUdsekxtMWxjM05oWjJVZ1B5QW5PaUFuSUNzZ2RHaHBjeTV0WlhOellXZGxJRG9nSnljcE8xeHVmVHRjYmx4dVEyRnVZMlZzTG5CeWIzUnZkSGx3WlM1ZlgwTkJUa05GVEY5ZklEMGdkSEoxWlR0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQkRZVzVqWld3N1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCRFlXNWpaV3dnUFNCeVpYRjFhWEpsS0NjdUwwTmhibU5sYkNjcE8xeHVYRzR2S2lwY2JpQXFJRUVnWUVOaGJtTmxiRlJ2YTJWdVlDQnBjeUJoYmlCdlltcGxZM1FnZEdoaGRDQmpZVzRnWW1VZ2RYTmxaQ0IwYnlCeVpYRjFaWE4wSUdOaGJtTmxiR3hoZEdsdmJpQnZaaUJoYmlCdmNHVnlZWFJwYjI0dVhHNGdLbHh1SUNvZ1FHTnNZWE56WEc0Z0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQmxlR1ZqZFhSdmNpQlVhR1VnWlhobFkzVjBiM0lnWm5WdVkzUnBiMjR1WEc0Z0tpOWNibVoxYm1OMGFXOXVJRU5oYm1ObGJGUnZhMlZ1S0dWNFpXTjFkRzl5S1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnWlhobFkzVjBiM0lnSVQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLQ2RsZUdWamRYUnZjaUJ0ZFhOMElHSmxJR0VnWm5WdVkzUnBiMjR1SnlrN1hHNGdJSDFjYmx4dUlDQjJZWElnY21WemIyeDJaVkJ5YjIxcGMyVTdYRzRnSUhSb2FYTXVjSEp2YldselpTQTlJRzVsZHlCUWNtOXRhWE5sS0daMWJtTjBhVzl1SUhCeWIyMXBjMlZGZUdWamRYUnZjaWh5WlhOdmJIWmxLU0I3WEc0Z0lDQWdjbVZ6YjJ4MlpWQnliMjFwYzJVZ1BTQnlaWE52YkhabE8xeHVJQ0I5S1R0Y2JseHVJQ0IyWVhJZ2RHOXJaVzRnUFNCMGFHbHpPMXh1SUNCbGVHVmpkWFJ2Y2lobWRXNWpkR2x2YmlCallXNWpaV3dvYldWemMyRm5aU2tnZTF4dUlDQWdJR2xtSUNoMGIydGxiaTV5WldGemIyNHBJSHRjYmlBZ0lDQWdJQzh2SUVOaGJtTmxiR3hoZEdsdmJpQm9ZWE1nWVd4eVpXRmtlU0JpWldWdUlISmxjWFZsYzNSbFpGeHVJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJSDFjYmx4dUlDQWdJSFJ2YTJWdUxuSmxZWE52YmlBOUlHNWxkeUJEWVc1alpXd29iV1Z6YzJGblpTazdYRzRnSUNBZ2NtVnpiMngyWlZCeWIyMXBjMlVvZEc5clpXNHVjbVZoYzI5dUtUdGNiaUFnZlNrN1hHNTlYRzVjYmk4cUtseHVJQ29nVkdoeWIzZHpJR0VnWUVOaGJtTmxiR0FnYVdZZ1kyRnVZMlZzYkdGMGFXOXVJR2hoY3lCaVpXVnVJSEpsY1hWbGMzUmxaQzVjYmlBcUwxeHVRMkZ1WTJWc1ZHOXJaVzR1Y0hKdmRHOTBlWEJsTG5Sb2NtOTNTV1pTWlhGMVpYTjBaV1FnUFNCbWRXNWpkR2x2YmlCMGFISnZkMGxtVW1WeGRXVnpkR1ZrS0NrZ2UxeHVJQ0JwWmlBb2RHaHBjeTV5WldGemIyNHBJSHRjYmlBZ0lDQjBhSEp2ZHlCMGFHbHpMbkpsWVhOdmJqdGNiaUFnZlZ4dWZUdGNibHh1THlvcVhHNGdLaUJTWlhSMWNtNXpJR0Z1SUc5aWFtVmpkQ0IwYUdGMElHTnZiblJoYVc1eklHRWdibVYzSUdCRFlXNWpaV3hVYjJ0bGJtQWdZVzVrSUdFZ1puVnVZM1JwYjI0Z2RHaGhkQ3dnZDJobGJpQmpZV3hzWldRc1hHNGdLaUJqWVc1alpXeHpJSFJvWlNCZ1EyRnVZMlZzVkc5clpXNWdMbHh1SUNvdlhHNURZVzVqWld4VWIydGxiaTV6YjNWeVkyVWdQU0JtZFc1amRHbHZiaUJ6YjNWeVkyVW9LU0I3WEc0Z0lIWmhjaUJqWVc1alpXdzdYRzRnSUhaaGNpQjBiMnRsYmlBOUlHNWxkeUJEWVc1alpXeFViMnRsYmlobWRXNWpkR2x2YmlCbGVHVmpkWFJ2Y2loaktTQjdYRzRnSUNBZ1kyRnVZMlZzSUQwZ1l6dGNiaUFnZlNrN1hHNGdJSEpsZEhWeWJpQjdYRzRnSUNBZ2RHOXJaVzQ2SUhSdmEyVnVMRnh1SUNBZ0lHTmhibU5sYkRvZ1kyRnVZMlZzWEc0Z0lIMDdYRzU5TzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlFTmhibU5sYkZSdmEyVnVPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUdselEyRnVZMlZzS0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlBaElTaDJZV3gxWlNBbUppQjJZV3gxWlM1ZlgwTkJUa05GVEY5ZktUdGNibjA3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUIxZEdsc2N5QTlJSEpsY1hWcGNtVW9KeTR2TGk0dmRYUnBiSE1uS1R0Y2JuWmhjaUJpZFdsc1pGVlNUQ0E5SUhKbGNYVnBjbVVvSnk0dUwyaGxiSEJsY25NdlluVnBiR1JWVWt3bktUdGNiblpoY2lCSmJuUmxjbU5sY0hSdmNrMWhibUZuWlhJZ1BTQnlaWEYxYVhKbEtDY3VMMGx1ZEdWeVkyVndkRzl5VFdGdVlXZGxjaWNwTzF4dWRtRnlJR1JwYzNCaGRHTm9VbVZ4ZFdWemRDQTlJSEpsY1hWcGNtVW9KeTR2WkdsemNHRjBZMmhTWlhGMVpYTjBKeWs3WEc1MllYSWdiV1Z5WjJWRGIyNW1hV2NnUFNCeVpYRjFhWEpsS0NjdUwyMWxjbWRsUTI5dVptbG5KeWs3WEc1Y2JpOHFLbHh1SUNvZ1EzSmxZWFJsSUdFZ2JtVjNJR2x1YzNSaGJtTmxJRzltSUVGNGFXOXpYRzRnS2x4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlHbHVjM1JoYm1ObFEyOXVabWxuSUZSb1pTQmtaV1poZFd4MElHTnZibVpwWnlCbWIzSWdkR2hsSUdsdWMzUmhibU5sWEc0Z0tpOWNibVoxYm1OMGFXOXVJRUY0YVc5ektHbHVjM1JoYm1ObFEyOXVabWxuS1NCN1hHNGdJSFJvYVhNdVpHVm1ZWFZzZEhNZ1BTQnBibk4wWVc1alpVTnZibVpwWnp0Y2JpQWdkR2hwY3k1cGJuUmxjbU5sY0hSdmNuTWdQU0I3WEc0Z0lDQWdjbVZ4ZFdWemREb2dibVYzSUVsdWRHVnlZMlZ3ZEc5eVRXRnVZV2RsY2lncExGeHVJQ0FnSUhKbGMzQnZibk5sT2lCdVpYY2dTVzUwWlhKalpYQjBiM0pOWVc1aFoyVnlLQ2xjYmlBZ2ZUdGNibjFjYmx4dUx5b3FYRzRnS2lCRWFYTndZWFJqYUNCaElISmxjWFZsYzNSY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnWTI5dVptbG5JRlJvWlNCamIyNW1hV2NnYzNCbFkybG1hV01nWm05eUlIUm9hWE1nY21WeGRXVnpkQ0FvYldWeVoyVmtJSGRwZEdnZ2RHaHBjeTVrWldaaGRXeDBjeWxjYmlBcUwxeHVRWGhwYjNNdWNISnZkRzkwZVhCbExuSmxjWFZsYzNRZ1BTQm1kVzVqZEdsdmJpQnlaWEYxWlhOMEtHTnZibVpwWnlrZ2UxeHVJQ0F2S21WemJHbHVkQ0J1Ynkxd1lYSmhiUzF5WldGemMybG5iam93S2k5Y2JpQWdMeThnUVd4c2IzY2dabTl5SUdGNGFXOXpLQ2RsZUdGdGNHeGxMM1Z5YkNkYkxDQmpiMjVtYVdkZEtTQmhJR3hoSUdabGRHTm9JRUZRU1Z4dUlDQnBaaUFvZEhsd1pXOW1JR052Ym1acFp5QTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0JqYjI1bWFXY2dQU0JoY21kMWJXVnVkSE5iTVYwZ2ZId2dlMzA3WEc0Z0lDQWdZMjl1Wm1sbkxuVnliQ0E5SUdGeVozVnRaVzUwYzFzd1hUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQmpiMjVtYVdjZ1BTQmpiMjVtYVdjZ2ZId2dlMzA3WEc0Z0lIMWNibHh1SUNCamIyNW1hV2NnUFNCdFpYSm5aVU52Ym1acFp5aDBhR2x6TG1SbFptRjFiSFJ6TENCamIyNW1hV2NwTzF4dVhHNGdJQzh2SUZObGRDQmpiMjVtYVdjdWJXVjBhRzlrWEc0Z0lHbG1JQ2hqYjI1bWFXY3ViV1YwYUc5a0tTQjdYRzRnSUNBZ1kyOXVabWxuTG0xbGRHaHZaQ0E5SUdOdmJtWnBaeTV0WlhSb2IyUXVkRzlNYjNkbGNrTmhjMlVvS1R0Y2JpQWdmU0JsYkhObElHbG1JQ2gwYUdsekxtUmxabUYxYkhSekxtMWxkR2h2WkNrZ2UxeHVJQ0FnSUdOdmJtWnBaeTV0WlhSb2IyUWdQU0IwYUdsekxtUmxabUYxYkhSekxtMWxkR2h2WkM1MGIweHZkMlZ5UTJGelpTZ3BPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR052Ym1acFp5NXRaWFJvYjJRZ1BTQW5aMlYwSnp0Y2JpQWdmVnh1WEc0Z0lDOHZJRWh2YjJzZ2RYQWdhVzUwWlhKalpYQjBiM0p6SUcxcFpHUnNaWGRoY21WY2JpQWdkbUZ5SUdOb1lXbHVJRDBnVzJScGMzQmhkR05vVW1WeGRXVnpkQ3dnZFc1a1pXWnBibVZrWFR0Y2JpQWdkbUZ5SUhCeWIyMXBjMlVnUFNCUWNtOXRhWE5sTG5KbGMyOXNkbVVvWTI5dVptbG5LVHRjYmx4dUlDQjBhR2x6TG1sdWRHVnlZMlZ3ZEc5eWN5NXlaWEYxWlhOMExtWnZja1ZoWTJnb1puVnVZM1JwYjI0Z2RXNXphR2xtZEZKbGNYVmxjM1JKYm5SbGNtTmxjSFJ2Y25Nb2FXNTBaWEpqWlhCMGIzSXBJSHRjYmlBZ0lDQmphR0ZwYmk1MWJuTm9hV1owS0dsdWRHVnlZMlZ3ZEc5eUxtWjFiR1pwYkd4bFpDd2dhVzUwWlhKalpYQjBiM0l1Y21WcVpXTjBaV1FwTzF4dUlDQjlLVHRjYmx4dUlDQjBhR2x6TG1sdWRHVnlZMlZ3ZEc5eWN5NXlaWE53YjI1elpTNW1iM0pGWVdOb0tHWjFibU4wYVc5dUlIQjFjMmhTWlhOd2IyNXpaVWx1ZEdWeVkyVndkRzl5Y3locGJuUmxjbU5sY0hSdmNpa2dlMXh1SUNBZ0lHTm9ZV2x1TG5CMWMyZ29hVzUwWlhKalpYQjBiM0l1Wm5Wc1ptbHNiR1ZrTENCcGJuUmxjbU5sY0hSdmNpNXlaV3BsWTNSbFpDazdYRzRnSUgwcE8xeHVYRzRnSUhkb2FXeGxJQ2hqYUdGcGJpNXNaVzVuZEdncElIdGNiaUFnSUNCd2NtOXRhWE5sSUQwZ2NISnZiV2x6WlM1MGFHVnVLR05vWVdsdUxuTm9hV1owS0Nrc0lHTm9ZV2x1TG5Ob2FXWjBLQ2twTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhCeWIyMXBjMlU3WEc1OU8xeHVYRzVCZUdsdmN5NXdjbTkwYjNSNWNHVXVaMlYwVlhKcElEMGdablZ1WTNScGIyNGdaMlYwVlhKcEtHTnZibVpwWnlrZ2UxeHVJQ0JqYjI1bWFXY2dQU0J0WlhKblpVTnZibVpwWnloMGFHbHpMbVJsWm1GMWJIUnpMQ0JqYjI1bWFXY3BPMXh1SUNCeVpYUjFjbTRnWW5WcGJHUlZVa3dvWTI5dVptbG5MblZ5YkN3Z1kyOXVabWxuTG5CaGNtRnRjeXdnWTI5dVptbG5MbkJoY21GdGMxTmxjbWxoYkdsNlpYSXBMbkpsY0d4aFkyVW9MMTVjWEQ4dkxDQW5KeWs3WEc1OU8xeHVYRzR2THlCUWNtOTJhV1JsSUdGc2FXRnpaWE1nWm05eUlITjFjSEJ2Y25SbFpDQnlaWEYxWlhOMElHMWxkR2h2WkhOY2JuVjBhV3h6TG1admNrVmhZMmdvV3lka1pXeGxkR1VuTENBbloyVjBKeXdnSjJobFlXUW5MQ0FuYjNCMGFXOXVjeWRkTENCbWRXNWpkR2x2YmlCbWIzSkZZV05vVFdWMGFHOWtUbTlFWVhSaEtHMWxkR2h2WkNrZ2UxeHVJQ0F2S21WemJHbHVkQ0JtZFc1akxXNWhiV1Z6T2pBcUwxeHVJQ0JCZUdsdmN5NXdjbTkwYjNSNWNHVmJiV1YwYUc5a1hTQTlJR1oxYm1OMGFXOXVLSFZ5YkN3Z1kyOXVabWxuS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnhkV1Z6ZENodFpYSm5aVU52Ym1acFp5aGpiMjVtYVdjZ2ZId2dlMzBzSUh0Y2JpQWdJQ0FnSUcxbGRHaHZaRG9nYldWMGFHOWtMRnh1SUNBZ0lDQWdkWEpzT2lCMWNtd3NYRzRnSUNBZ0lDQmtZWFJoT2lBb1kyOXVabWxuSUh4OElIdDlLUzVrWVhSaFhHNGdJQ0FnZlNrcE8xeHVJQ0I5TzF4dWZTazdYRzVjYm5WMGFXeHpMbVp2Y2tWaFkyZ29XeWR3YjNOMEp5d2dKM0IxZENjc0lDZHdZWFJqYUNkZExDQm1kVzVqZEdsdmJpQm1iM0pGWVdOb1RXVjBhRzlrVjJsMGFFUmhkR0VvYldWMGFHOWtLU0I3WEc0Z0lDOHFaWE5zYVc1MElHWjFibU10Ym1GdFpYTTZNQ292WEc0Z0lFRjRhVzl6TG5CeWIzUnZkSGx3WlZ0dFpYUm9iMlJkSUQwZ1puVnVZM1JwYjI0b2RYSnNMQ0JrWVhSaExDQmpiMjVtYVdjcElIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NXlaWEYxWlhOMEtHMWxjbWRsUTI5dVptbG5LR052Ym1acFp5QjhmQ0I3ZlN3Z2UxeHVJQ0FnSUNBZ2JXVjBhRzlrT2lCdFpYUm9iMlFzWEc0Z0lDQWdJQ0IxY213NklIVnliQ3hjYmlBZ0lDQWdJR1JoZEdFNklHUmhkR0ZjYmlBZ0lDQjlLU2s3WEc0Z0lIMDdYRzU5S1R0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQkJlR2x2Y3p0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVkbUZ5SUhWMGFXeHpJRDBnY21WeGRXbHlaU2duTGk4dUxpOTFkR2xzY3ljcE8xeHVYRzVtZFc1amRHbHZiaUJKYm5SbGNtTmxjSFJ2Y2sxaGJtRm5aWElvS1NCN1hHNGdJSFJvYVhNdWFHRnVaR3hsY25NZ1BTQmJYVHRjYm4xY2JseHVMeW9xWEc0Z0tpQkJaR1FnWVNCdVpYY2dhVzUwWlhKalpYQjBiM0lnZEc4Z2RHaGxJSE4wWVdOclhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ1puVnNabWxzYkdWa0lGUm9aU0JtZFc1amRHbHZiaUIwYnlCb1lXNWtiR1VnWUhSb1pXNWdJR1p2Y2lCaElHQlFjbTl0YVhObFlGeHVJQ29nUUhCaGNtRnRJSHRHZFc1amRHbHZibjBnY21WcVpXTjBaV1FnVkdobElHWjFibU4wYVc5dUlIUnZJR2hoYm1Sc1pTQmdjbVZxWldOMFlDQm1iM0lnWVNCZ1VISnZiV2x6WldCY2JpQXFYRzRnS2lCQWNtVjBkWEp1SUh0T2RXMWlaWEo5SUVGdUlFbEVJSFZ6WldRZ2RHOGdjbVZ0YjNabElHbHVkR1Z5WTJWd2RHOXlJR3hoZEdWeVhHNGdLaTljYmtsdWRHVnlZMlZ3ZEc5eVRXRnVZV2RsY2k1d2NtOTBiM1I1Y0dVdWRYTmxJRDBnWm5WdVkzUnBiMjRnZFhObEtHWjFiR1pwYkd4bFpDd2djbVZxWldOMFpXUXBJSHRjYmlBZ2RHaHBjeTVvWVc1a2JHVnljeTV3ZFhOb0tIdGNiaUFnSUNCbWRXeG1hV3hzWldRNklHWjFiR1pwYkd4bFpDeGNiaUFnSUNCeVpXcGxZM1JsWkRvZ2NtVnFaV04wWldSY2JpQWdmU2s3WEc0Z0lISmxkSFZ5YmlCMGFHbHpMbWhoYm1Sc1pYSnpMbXhsYm1kMGFDQXRJREU3WEc1OU8xeHVYRzR2S2lwY2JpQXFJRkpsYlc5MlpTQmhiaUJwYm5SbGNtTmxjSFJ2Y2lCbWNtOXRJSFJvWlNCemRHRmphMXh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdUblZ0WW1WeWZTQnBaQ0JVYUdVZ1NVUWdkR2hoZENCM1lYTWdjbVYwZFhKdVpXUWdZbmtnWUhWelpXQmNiaUFxTDF4dVNXNTBaWEpqWlhCMGIzSk5ZVzVoWjJWeUxuQnliM1J2ZEhsd1pTNWxhbVZqZENBOUlHWjFibU4wYVc5dUlHVnFaV04wS0dsa0tTQjdYRzRnSUdsbUlDaDBhR2x6TG1oaGJtUnNaWEp6VzJsa1hTa2dlMXh1SUNBZ0lIUm9hWE11YUdGdVpHeGxjbk5iYVdSZElEMGdiblZzYkR0Y2JpQWdmVnh1ZlR0Y2JseHVMeW9xWEc0Z0tpQkpkR1Z5WVhSbElHOTJaWElnWVd4c0lIUm9aU0J5WldkcGMzUmxjbVZrSUdsdWRHVnlZMlZ3ZEc5eWMxeHVJQ3BjYmlBcUlGUm9hWE1nYldWMGFHOWtJR2x6SUhCaGNuUnBZM1ZzWVhKc2VTQjFjMlZtZFd3Z1ptOXlJSE5yYVhCd2FXNW5JRzkyWlhJZ1lXNTVYRzRnS2lCcGJuUmxjbU5sY0hSdmNuTWdkR2hoZENCdFlYa2dhR0YyWlNCaVpXTnZiV1VnWUc1MWJHeGdJR05oYkd4cGJtY2dZR1ZxWldOMFlDNWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQm1iaUJVYUdVZ1puVnVZM1JwYjI0Z2RHOGdZMkZzYkNCbWIzSWdaV0ZqYUNCcGJuUmxjbU5sY0hSdmNseHVJQ292WEc1SmJuUmxjbU5sY0hSdmNrMWhibUZuWlhJdWNISnZkRzkwZVhCbExtWnZja1ZoWTJnZ1BTQm1kVzVqZEdsdmJpQm1iM0pGWVdOb0tHWnVLU0I3WEc0Z0lIVjBhV3h6TG1admNrVmhZMmdvZEdocGN5NW9ZVzVrYkdWeWN5d2dablZ1WTNScGIyNGdabTl5UldGamFFaGhibVJzWlhJb2FDa2dlMXh1SUNBZ0lHbG1JQ2hvSUNFOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNCbWJpaG9LVHRjYmlBZ0lDQjlYRzRnSUgwcE8xeHVmVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCSmJuUmxjbU5sY0hSdmNrMWhibUZuWlhJN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCcGMwRmljMjlzZFhSbFZWSk1JRDBnY21WeGRXbHlaU2duTGk0dmFHVnNjR1Z5Y3k5cGMwRmljMjlzZFhSbFZWSk1KeWs3WEc1MllYSWdZMjl0WW1sdVpWVlNUSE1nUFNCeVpYRjFhWEpsS0NjdUxpOW9aV3h3WlhKekwyTnZiV0pwYm1WVlVreHpKeWs3WEc1Y2JpOHFLbHh1SUNvZ1EzSmxZWFJsY3lCaElHNWxkeUJWVWt3Z1lua2dZMjl0WW1sdWFXNW5JSFJvWlNCaVlYTmxWVkpNSUhkcGRHZ2dkR2hsSUhKbGNYVmxjM1JsWkZWU1RDeGNiaUFxSUc5dWJIa2dkMmhsYmlCMGFHVWdjbVZ4ZFdWemRHVmtWVkpNSUdseklHNXZkQ0JoYkhKbFlXUjVJR0Z1SUdGaWMyOXNkWFJsSUZWU1RDNWNiaUFxSUVsbUlIUm9aU0J5WlhGMVpYTjBWVkpNSUdseklHRmljMjlzZFhSbExDQjBhR2x6SUdaMWJtTjBhVzl1SUhKbGRIVnlibk1nZEdobElISmxjWFZsYzNSbFpGVlNUQ0IxYm5SdmRXTm9aV1F1WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHR6ZEhKcGJtZDlJR0poYzJWVlVrd2dWR2hsSUdKaGMyVWdWVkpNWEc0Z0tpQkFjR0Z5WVcwZ2UzTjBjbWx1WjMwZ2NtVnhkV1Z6ZEdWa1ZWSk1JRUZpYzI5c2RYUmxJRzl5SUhKbGJHRjBhWFpsSUZWU1RDQjBieUJqYjIxaWFXNWxYRzRnS2lCQWNtVjBkWEp1Y3lCN2MzUnlhVzVuZlNCVWFHVWdZMjl0WW1sdVpXUWdablZzYkNCd1lYUm9YRzRnS2k5Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z1luVnBiR1JHZFd4c1VHRjBhQ2hpWVhObFZWSk1MQ0J5WlhGMVpYTjBaV1JWVWt3cElIdGNiaUFnYVdZZ0tHSmhjMlZWVWt3Z0ppWWdJV2x6UVdKemIyeDFkR1ZWVWt3b2NtVnhkV1Z6ZEdWa1ZWSk1LU2tnZTF4dUlDQWdJSEpsZEhWeWJpQmpiMjFpYVc1bFZWSk1jeWhpWVhObFZWSk1MQ0J5WlhGMVpYTjBaV1JWVWt3cE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYRjFaWE4wWldSVlVrdzdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWlc1b1lXNWpaVVZ5Y205eUlEMGdjbVZ4ZFdseVpTZ25MaTlsYm1oaGJtTmxSWEp5YjNJbktUdGNibHh1THlvcVhHNGdLaUJEY21WaGRHVWdZVzRnUlhKeWIzSWdkMmwwYUNCMGFHVWdjM0JsWTJsbWFXVmtJRzFsYzNOaFoyVXNJR052Ym1acFp5d2daWEp5YjNJZ1kyOWtaU3dnY21WeGRXVnpkQ0JoYm1RZ2NtVnpjRzl1YzJVdVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0emRISnBibWQ5SUcxbGMzTmhaMlVnVkdobElHVnljbTl5SUcxbGMzTmhaMlV1WEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ1kyOXVabWxuSUZSb1pTQmpiMjVtYVdjdVhHNGdLaUJBY0dGeVlXMGdlM04wY21sdVozMGdXMk52WkdWZElGUm9aU0JsY25KdmNpQmpiMlJsSUNobWIzSWdaWGhoYlhCc1pTd2dKMFZEVDA1T1FVSlBVbFJGUkNjcExseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJRnR5WlhGMVpYTjBYU0JVYUdVZ2NtVnhkV1Z6ZEM1Y2JpQXFJRUJ3WVhKaGJTQjdUMkpxWldOMGZTQmJjbVZ6Y0c5dWMyVmRJRlJvWlNCeVpYTndiMjV6WlM1Y2JpQXFJRUJ5WlhSMWNtNXpJSHRGY25KdmNuMGdWR2hsSUdOeVpXRjBaV1FnWlhKeWIzSXVYRzRnS2k5Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z1kzSmxZWFJsUlhKeWIzSW9iV1Z6YzJGblpTd2dZMjl1Wm1sbkxDQmpiMlJsTENCeVpYRjFaWE4wTENCeVpYTndiMjV6WlNrZ2UxeHVJQ0IyWVhJZ1pYSnliM0lnUFNCdVpYY2dSWEp5YjNJb2JXVnpjMkZuWlNrN1hHNGdJSEpsZEhWeWJpQmxibWhoYm1ObFJYSnliM0lvWlhKeWIzSXNJR052Ym1acFp5d2dZMjlrWlN3Z2NtVnhkV1Z6ZEN3Z2NtVnpjRzl1YzJVcE8xeHVmVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dWRtRnlJSFYwYVd4eklEMGdjbVZ4ZFdseVpTZ25MaTh1TGk5MWRHbHNjeWNwTzF4dWRtRnlJSFJ5WVc1elptOXliVVJoZEdFZ1BTQnlaWEYxYVhKbEtDY3VMM1J5WVc1elptOXliVVJoZEdFbktUdGNiblpoY2lCcGMwTmhibU5sYkNBOUlISmxjWFZwY21Vb0p5NHVMMk5oYm1ObGJDOXBjME5oYm1ObGJDY3BPMXh1ZG1GeUlHUmxabUYxYkhSeklEMGdjbVZ4ZFdseVpTZ25MaTR2WkdWbVlYVnNkSE1uS1R0Y2JseHVMeW9xWEc0Z0tpQlVhSEp2ZDNNZ1lTQmdRMkZ1WTJWc1lDQnBaaUJqWVc1alpXeHNZWFJwYjI0Z2FHRnpJR0psWlc0Z2NtVnhkV1Z6ZEdWa0xseHVJQ292WEc1bWRXNWpkR2x2YmlCMGFISnZkMGxtUTJGdVkyVnNiR0YwYVc5dVVtVnhkV1Z6ZEdWa0tHTnZibVpwWnlrZ2UxeHVJQ0JwWmlBb1kyOXVabWxuTG1OaGJtTmxiRlJ2YTJWdUtTQjdYRzRnSUNBZ1kyOXVabWxuTG1OaGJtTmxiRlJ2YTJWdUxuUm9jbTkzU1daU1pYRjFaWE4wWldRb0tUdGNiaUFnZlZ4dWZWeHVYRzR2S2lwY2JpQXFJRVJwYzNCaGRHTm9JR0VnY21WeGRXVnpkQ0IwYnlCMGFHVWdjMlZ5ZG1WeUlIVnphVzVuSUhSb1pTQmpiMjVtYVdkMWNtVmtJR0ZrWVhCMFpYSXVYRzRnS2x4dUlDb2dRSEJoY21GdElIdHZZbXBsWTNSOUlHTnZibVpwWnlCVWFHVWdZMjl1Wm1sbklIUm9ZWFFnYVhNZ2RHOGdZbVVnZFhObFpDQm1iM0lnZEdobElISmxjWFZsYzNSY2JpQXFJRUJ5WlhSMWNtNXpJSHRRY205dGFYTmxmU0JVYUdVZ1VISnZiV2x6WlNCMGJ5QmlaU0JtZFd4bWFXeHNaV1JjYmlBcUwxeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQmthWE53WVhSamFGSmxjWFZsYzNRb1kyOXVabWxuS1NCN1hHNGdJSFJvY205M1NXWkRZVzVqWld4c1lYUnBiMjVTWlhGMVpYTjBaV1FvWTI5dVptbG5LVHRjYmx4dUlDQXZMeUJGYm5OMWNtVWdhR1ZoWkdWeWN5QmxlR2x6ZEZ4dUlDQmpiMjVtYVdjdWFHVmhaR1Z5Y3lBOUlHTnZibVpwWnk1b1pXRmtaWEp6SUh4OElIdDlPMXh1WEc0Z0lDOHZJRlJ5WVc1elptOXliU0J5WlhGMVpYTjBJR1JoZEdGY2JpQWdZMjl1Wm1sbkxtUmhkR0VnUFNCMGNtRnVjMlp2Y20xRVlYUmhLRnh1SUNBZ0lHTnZibVpwWnk1a1lYUmhMRnh1SUNBZ0lHTnZibVpwWnk1b1pXRmtaWEp6TEZ4dUlDQWdJR052Ym1acFp5NTBjbUZ1YzJadmNtMVNaWEYxWlhOMFhHNGdJQ2s3WEc1Y2JpQWdMeThnUm14aGRIUmxiaUJvWldGa1pYSnpYRzRnSUdOdmJtWnBaeTVvWldGa1pYSnpJRDBnZFhScGJITXViV1Z5WjJVb1hHNGdJQ0FnWTI5dVptbG5MbWhsWVdSbGNuTXVZMjl0Ylc5dUlIeDhJSHQ5TEZ4dUlDQWdJR052Ym1acFp5NW9aV0ZrWlhKelcyTnZibVpwWnk1dFpYUm9iMlJkSUh4OElIdDlMRnh1SUNBZ0lHTnZibVpwWnk1b1pXRmtaWEp6WEc0Z0lDazdYRzVjYmlBZ2RYUnBiSE11Wm05eVJXRmphQ2hjYmlBZ0lDQmJKMlJsYkdWMFpTY3NJQ2RuWlhRbkxDQW5hR1ZoWkNjc0lDZHdiM04wSnl3Z0ozQjFkQ2NzSUNkd1lYUmphQ2NzSUNkamIyMXRiMjRuWFN4Y2JpQWdJQ0JtZFc1amRHbHZiaUJqYkdWaGJraGxZV1JsY2tOdmJtWnBaeWh0WlhSb2IyUXBJSHRjYmlBZ0lDQWdJR1JsYkdWMFpTQmpiMjVtYVdjdWFHVmhaR1Z5YzF0dFpYUm9iMlJkTzF4dUlDQWdJSDFjYmlBZ0tUdGNibHh1SUNCMllYSWdZV1JoY0hSbGNpQTlJR052Ym1acFp5NWhaR0Z3ZEdWeUlIeDhJR1JsWm1GMWJIUnpMbUZrWVhCMFpYSTdYRzVjYmlBZ2NtVjBkWEp1SUdGa1lYQjBaWElvWTI5dVptbG5LUzUwYUdWdUtHWjFibU4wYVc5dUlHOXVRV1JoY0hSbGNsSmxjMjlzZFhScGIyNG9jbVZ6Y0c5dWMyVXBJSHRjYmlBZ0lDQjBhSEp2ZDBsbVEyRnVZMlZzYkdGMGFXOXVVbVZ4ZFdWemRHVmtLR052Ym1acFp5azdYRzVjYmlBZ0lDQXZMeUJVY21GdWMyWnZjbTBnY21WemNHOXVjMlVnWkdGMFlWeHVJQ0FnSUhKbGMzQnZibk5sTG1SaGRHRWdQU0IwY21GdWMyWnZjbTFFWVhSaEtGeHVJQ0FnSUNBZ2NtVnpjRzl1YzJVdVpHRjBZU3hjYmlBZ0lDQWdJSEpsYzNCdmJuTmxMbWhsWVdSbGNuTXNYRzRnSUNBZ0lDQmpiMjVtYVdjdWRISmhibk5tYjNKdFVtVnpjRzl1YzJWY2JpQWdJQ0FwTzF4dVhHNGdJQ0FnY21WMGRYSnVJSEpsYzNCdmJuTmxPMXh1SUNCOUxDQm1kVzVqZEdsdmJpQnZia0ZrWVhCMFpYSlNaV3BsWTNScGIyNG9jbVZoYzI5dUtTQjdYRzRnSUNBZ2FXWWdLQ0ZwYzBOaGJtTmxiQ2h5WldGemIyNHBLU0I3WEc0Z0lDQWdJQ0IwYUhKdmQwbG1RMkZ1WTJWc2JHRjBhVzl1VW1WeGRXVnpkR1ZrS0dOdmJtWnBaeWs3WEc1Y2JpQWdJQ0FnSUM4dklGUnlZVzV6Wm05eWJTQnlaWE53YjI1elpTQmtZWFJoWEc0Z0lDQWdJQ0JwWmlBb2NtVmhjMjl1SUNZbUlISmxZWE52Ymk1eVpYTndiMjV6WlNrZ2UxeHVJQ0FnSUNBZ0lDQnlaV0Z6YjI0dWNtVnpjRzl1YzJVdVpHRjBZU0E5SUhSeVlXNXpabTl5YlVSaGRHRW9YRzRnSUNBZ0lDQWdJQ0FnY21WaGMyOXVMbkpsYzNCdmJuTmxMbVJoZEdFc1hHNGdJQ0FnSUNBZ0lDQWdjbVZoYzI5dUxuSmxjM0J2Ym5ObExtaGxZV1JsY25Nc1hHNGdJQ0FnSUNBZ0lDQWdZMjl1Wm1sbkxuUnlZVzV6Wm05eWJWSmxjM0J2Ym5ObFhHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUZCeWIyMXBjMlV1Y21WcVpXTjBLSEpsWVhOdmJpazdYRzRnSUgwcE8xeHVmVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dUx5b3FYRzRnS2lCVmNHUmhkR1VnWVc0Z1JYSnliM0lnZDJsMGFDQjBhR1VnYzNCbFkybG1hV1ZrSUdOdmJtWnBaeXdnWlhKeWIzSWdZMjlrWlN3Z1lXNWtJSEpsYzNCdmJuTmxMbHh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdSWEp5YjNKOUlHVnljbTl5SUZSb1pTQmxjbkp2Y2lCMGJ5QjFjR1JoZEdVdVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdZMjl1Wm1sbklGUm9aU0JqYjI1bWFXY3VYRzRnS2lCQWNHRnlZVzBnZTNOMGNtbHVaMzBnVzJOdlpHVmRJRlJvWlNCbGNuSnZjaUJqYjJSbElDaG1iM0lnWlhoaGJYQnNaU3dnSjBWRFQwNU9RVUpQVWxSRlJDY3BMbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUZ0eVpYRjFaWE4wWFNCVWFHVWdjbVZ4ZFdWemRDNWNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0JiY21WemNHOXVjMlZkSUZSb1pTQnlaWE53YjI1elpTNWNiaUFxSUVCeVpYUjFjbTV6SUh0RmNuSnZjbjBnVkdobElHVnljbTl5TGx4dUlDb3ZYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJR1Z1YUdGdVkyVkZjbkp2Y2lobGNuSnZjaXdnWTI5dVptbG5MQ0JqYjJSbExDQnlaWEYxWlhOMExDQnlaWE53YjI1elpTa2dlMXh1SUNCbGNuSnZjaTVqYjI1bWFXY2dQU0JqYjI1bWFXYzdYRzRnSUdsbUlDaGpiMlJsS1NCN1hHNGdJQ0FnWlhKeWIzSXVZMjlrWlNBOUlHTnZaR1U3WEc0Z0lIMWNibHh1SUNCbGNuSnZjaTV5WlhGMVpYTjBJRDBnY21WeGRXVnpkRHRjYmlBZ1pYSnliM0l1Y21WemNHOXVjMlVnUFNCeVpYTndiMjV6WlR0Y2JpQWdaWEp5YjNJdWFYTkJlR2x2YzBWeWNtOXlJRDBnZEhKMVpUdGNibHh1SUNCbGNuSnZjaTUwYjBwVFQwNGdQU0JtZFc1amRHbHZiaUIwYjBwVFQwNG9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIdGNiaUFnSUNBZ0lDOHZJRk4wWVc1a1lYSmtYRzRnSUNBZ0lDQnRaWE56WVdkbE9pQjBhR2x6TG0xbGMzTmhaMlVzWEc0Z0lDQWdJQ0J1WVcxbE9pQjBhR2x6TG01aGJXVXNYRzRnSUNBZ0lDQXZMeUJOYVdOeWIzTnZablJjYmlBZ0lDQWdJR1JsYzJOeWFYQjBhVzl1T2lCMGFHbHpMbVJsYzJOeWFYQjBhVzl1TEZ4dUlDQWdJQ0FnYm5WdFltVnlPaUIwYUdsekxtNTFiV0psY2l4Y2JpQWdJQ0FnSUM4dklFMXZlbWxzYkdGY2JpQWdJQ0FnSUdacGJHVk9ZVzFsT2lCMGFHbHpMbVpwYkdWT1lXMWxMRnh1SUNBZ0lDQWdiR2x1WlU1MWJXSmxjam9nZEdocGN5NXNhVzVsVG5WdFltVnlMRnh1SUNBZ0lDQWdZMjlzZFcxdVRuVnRZbVZ5T2lCMGFHbHpMbU52YkhWdGJrNTFiV0psY2l4Y2JpQWdJQ0FnSUhOMFlXTnJPaUIwYUdsekxuTjBZV05yTEZ4dUlDQWdJQ0FnTHk4Z1FYaHBiM05jYmlBZ0lDQWdJR052Ym1acFp6b2dkR2hwY3k1amIyNW1hV2NzWEc0Z0lDQWdJQ0JqYjJSbE9pQjBhR2x6TG1OdlpHVmNiaUFnSUNCOU8xeHVJQ0I5TzF4dUlDQnlaWFIxY200Z1pYSnliM0k3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ2RYUnBiSE1nUFNCeVpYRjFhWEpsS0NjdUxpOTFkR2xzY3ljcE8xeHVYRzR2S2lwY2JpQXFJRU52Ym1acFp5MXpjR1ZqYVdacFl5QnRaWEpuWlMxbWRXNWpkR2x2YmlCM2FHbGphQ0JqY21WaGRHVnpJR0VnYm1WM0lHTnZibVpwWnkxdlltcGxZM1JjYmlBcUlHSjVJRzFsY21kcGJtY2dkSGR2SUdOdmJtWnBaM1Z5WVhScGIyNGdiMkpxWldOMGN5QjBiMmRsZEdobGNpNWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ1kyOXVabWxuTVZ4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlHTnZibVpwWnpKY2JpQXFJRUJ5WlhSMWNtNXpJSHRQWW1wbFkzUjlJRTVsZHlCdlltcGxZM1FnY21WemRXeDBhVzVuSUdaeWIyMGdiV1Z5WjJsdVp5QmpiMjVtYVdjeUlIUnZJR052Ym1acFp6RmNiaUFxTDF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCdFpYSm5aVU52Ym1acFp5aGpiMjVtYVdjeExDQmpiMjVtYVdjeUtTQjdYRzRnSUM4dklHVnpiR2x1ZEMxa2FYTmhZbXhsTFc1bGVIUXRiR2x1WlNCdWJ5MXdZWEpoYlMxeVpXRnpjMmxuYmx4dUlDQmpiMjVtYVdjeUlEMGdZMjl1Wm1sbk1pQjhmQ0I3ZlR0Y2JpQWdkbUZ5SUdOdmJtWnBaeUE5SUh0OU8xeHVYRzRnSUhaaGNpQjJZV3gxWlVaeWIyMURiMjVtYVdjeVMyVjVjeUE5SUZzbmRYSnNKeXdnSjIxbGRHaHZaQ2NzSUNka1lYUmhKMTA3WEc0Z0lIWmhjaUJ0WlhKblpVUmxaWEJRY205d1pYSjBhV1Z6UzJWNWN5QTlJRnNuYUdWaFpHVnljeWNzSUNkaGRYUm9KeXdnSjNCeWIzaDVKeXdnSjNCaGNtRnRjeWRkTzF4dUlDQjJZWElnWkdWbVlYVnNkRlJ2UTI5dVptbG5Na3RsZVhNZ1BTQmJYRzRnSUNBZ0oySmhjMlZWVWt3bkxDQW5kSEpoYm5ObWIzSnRVbVZ4ZFdWemRDY3NJQ2QwY21GdWMyWnZjbTFTWlhOd2IyNXpaU2NzSUNkd1lYSmhiWE5UWlhKcFlXeHBlbVZ5Snl4Y2JpQWdJQ0FuZEdsdFpXOTFkQ2NzSUNkMGFXMWxiM1YwVFdWemMyRm5aU2NzSUNkM2FYUm9RM0psWkdWdWRHbGhiSE1uTENBbllXUmhjSFJsY2ljc0lDZHlaWE53YjI1elpWUjVjR1VuTENBbmVITnlaa052YjJ0cFpVNWhiV1VuTEZ4dUlDQWdJQ2Q0YzNKbVNHVmhaR1Z5VG1GdFpTY3NJQ2R2YmxWd2JHOWhaRkJ5YjJkeVpYTnpKeXdnSjI5dVJHOTNibXh2WVdSUWNtOW5jbVZ6Y3ljc0lDZGtaV052YlhCeVpYTnpKeXhjYmlBZ0lDQW5iV0Y0UTI5dWRHVnVkRXhsYm1kMGFDY3NJQ2R0WVhoQ2IyUjVUR1Z1WjNSb0p5d2dKMjFoZUZKbFpHbHlaV04wY3ljc0lDZDBjbUZ1YzNCdmNuUW5MQ0FuYUhSMGNFRm5aVzUwSnl4Y2JpQWdJQ0FuYUhSMGNITkJaMlZ1ZENjc0lDZGpZVzVqWld4VWIydGxiaWNzSUNkemIyTnJaWFJRWVhSb0p5d2dKM0psYzNCdmJuTmxSVzVqYjJScGJtY25YRzRnSUYwN1hHNGdJSFpoY2lCa2FYSmxZM1JOWlhKblpVdGxlWE1nUFNCYkozWmhiR2xrWVhSbFUzUmhkSFZ6SjEwN1hHNWNiaUFnWm5WdVkzUnBiMjRnWjJWMFRXVnlaMlZrVm1Gc2RXVW9kR0Z5WjJWMExDQnpiM1Z5WTJVcElIdGNiaUFnSUNCcFppQW9kWFJwYkhNdWFYTlFiR0ZwYms5aWFtVmpkQ2gwWVhKblpYUXBJQ1ltSUhWMGFXeHpMbWx6VUd4aGFXNVBZbXBsWTNRb2MyOTFjbU5sS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUhWMGFXeHpMbTFsY21kbEtIUmhjbWRsZEN3Z2MyOTFjbU5sS1R0Y2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0hWMGFXeHpMbWx6VUd4aGFXNVBZbXBsWTNRb2MyOTFjbU5sS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUhWMGFXeHpMbTFsY21kbEtIdDlMQ0J6YjNWeVkyVXBPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9kWFJwYkhNdWFYTkJjbkpoZVNoemIzVnlZMlVwS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYzI5MWNtTmxMbk5zYVdObEtDazdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ6YjNWeVkyVTdYRzRnSUgxY2JseHVJQ0JtZFc1amRHbHZiaUJ0WlhKblpVUmxaWEJRY205d1pYSjBhV1Z6S0hCeWIzQXBJSHRjYmlBZ0lDQnBaaUFvSVhWMGFXeHpMbWx6Vlc1a1pXWnBibVZrS0dOdmJtWnBaekpiY0hKdmNGMHBLU0I3WEc0Z0lDQWdJQ0JqYjI1bWFXZGJjSEp2Y0YwZ1BTQm5aWFJOWlhKblpXUldZV3gxWlNoamIyNW1hV2N4VzNCeWIzQmRMQ0JqYjI1bWFXY3lXM0J5YjNCZEtUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tDRjFkR2xzY3k1cGMxVnVaR1ZtYVc1bFpDaGpiMjVtYVdjeFczQnliM0JkS1NrZ2UxeHVJQ0FnSUNBZ1kyOXVabWxuVzNCeWIzQmRJRDBnWjJWMFRXVnlaMlZrVm1Gc2RXVW9kVzVrWldacGJtVmtMQ0JqYjI1bWFXY3hXM0J5YjNCZEtUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQjFkR2xzY3k1bWIzSkZZV05vS0haaGJIVmxSbkp2YlVOdmJtWnBaekpMWlhsekxDQm1kVzVqZEdsdmJpQjJZV3gxWlVaeWIyMURiMjVtYVdjeUtIQnliM0FwSUh0Y2JpQWdJQ0JwWmlBb0lYVjBhV3h6TG1selZXNWtaV1pwYm1Wa0tHTnZibVpwWnpKYmNISnZjRjBwS1NCN1hHNGdJQ0FnSUNCamIyNW1hV2RiY0hKdmNGMGdQU0JuWlhSTlpYSm5aV1JXWVd4MVpTaDFibVJsWm1sdVpXUXNJR052Ym1acFp6SmJjSEp2Y0YwcE8xeHVJQ0FnSUgxY2JpQWdmU2s3WEc1Y2JpQWdkWFJwYkhNdVptOXlSV0ZqYUNodFpYSm5aVVJsWlhCUWNtOXdaWEowYVdWelMyVjVjeXdnYldWeVoyVkVaV1Z3VUhKdmNHVnlkR2xsY3lrN1hHNWNiaUFnZFhScGJITXVabTl5UldGamFDaGtaV1poZFd4MFZHOURiMjVtYVdjeVMyVjVjeXdnWm5WdVkzUnBiMjRnWkdWbVlYVnNkRlJ2UTI5dVptbG5NaWh3Y205d0tTQjdYRzRnSUNBZ2FXWWdLQ0YxZEdsc2N5NXBjMVZ1WkdWbWFXNWxaQ2hqYjI1bWFXY3lXM0J5YjNCZEtTa2dlMXh1SUNBZ0lDQWdZMjl1Wm1sblczQnliM0JkSUQwZ1oyVjBUV1Z5WjJWa1ZtRnNkV1VvZFc1a1pXWnBibVZrTENCamIyNW1hV2N5VzNCeWIzQmRLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLQ0YxZEdsc2N5NXBjMVZ1WkdWbWFXNWxaQ2hqYjI1bWFXY3hXM0J5YjNCZEtTa2dlMXh1SUNBZ0lDQWdZMjl1Wm1sblczQnliM0JkSUQwZ1oyVjBUV1Z5WjJWa1ZtRnNkV1VvZFc1a1pXWnBibVZrTENCamIyNW1hV2N4VzNCeWIzQmRLVHRjYmlBZ0lDQjlYRzRnSUgwcE8xeHVYRzRnSUhWMGFXeHpMbVp2Y2tWaFkyZ29aR2x5WldOMFRXVnlaMlZMWlhsekxDQm1kVzVqZEdsdmJpQnRaWEpuWlNod2NtOXdLU0I3WEc0Z0lDQWdhV1lnS0hCeWIzQWdhVzRnWTI5dVptbG5NaWtnZTF4dUlDQWdJQ0FnWTI5dVptbG5XM0J5YjNCZElEMGdaMlYwVFdWeVoyVmtWbUZzZFdVb1kyOXVabWxuTVZ0d2NtOXdYU3dnWTI5dVptbG5NbHR3Y205d1hTazdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHdjbTl3SUdsdUlHTnZibVpwWnpFcElIdGNiaUFnSUNBZ0lHTnZibVpwWjF0d2NtOXdYU0E5SUdkbGRFMWxjbWRsWkZaaGJIVmxLSFZ1WkdWbWFXNWxaQ3dnWTI5dVptbG5NVnR3Y205d1hTazdYRzRnSUNBZ2ZWeHVJQ0I5S1R0Y2JseHVJQ0IyWVhJZ1lYaHBiM05MWlhseklEMGdkbUZzZFdWR2NtOXRRMjl1Wm1sbk1rdGxlWE5jYmlBZ0lDQXVZMjl1WTJGMEtHMWxjbWRsUkdWbGNGQnliM0JsY25ScFpYTkxaWGx6S1Z4dUlDQWdJQzVqYjI1allYUW9aR1ZtWVhWc2RGUnZRMjl1Wm1sbk1rdGxlWE1wWEc0Z0lDQWdMbU52Ym1OaGRDaGthWEpsWTNSTlpYSm5aVXRsZVhNcE8xeHVYRzRnSUhaaGNpQnZkR2hsY2t0bGVYTWdQU0JQWW1wbFkzUmNiaUFnSUNBdWEyVjVjeWhqYjI1bWFXY3hLVnh1SUNBZ0lDNWpiMjVqWVhRb1QySnFaV04wTG10bGVYTW9ZMjl1Wm1sbk1pa3BYRzRnSUNBZ0xtWnBiSFJsY2lobWRXNWpkR2x2YmlCbWFXeDBaWEpCZUdsdmMwdGxlWE1vYTJWNUtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1lYaHBiM05MWlhsekxtbHVaR1Y0VDJZb2EyVjVLU0E5UFQwZ0xURTdYRzRnSUNBZ2ZTazdYRzVjYmlBZ2RYUnBiSE11Wm05eVJXRmphQ2h2ZEdobGNrdGxlWE1zSUcxbGNtZGxSR1ZsY0ZCeWIzQmxjblJwWlhNcE8xeHVYRzRnSUhKbGRIVnliaUJqYjI1bWFXYzdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWTNKbFlYUmxSWEp5YjNJZ1BTQnlaWEYxYVhKbEtDY3VMMk55WldGMFpVVnljbTl5SnlrN1hHNWNiaThxS2x4dUlDb2dVbVZ6YjJ4MlpTQnZjaUJ5WldwbFkzUWdZU0JRY205dGFYTmxJR0poYzJWa0lHOXVJSEpsYzNCdmJuTmxJSE4wWVhSMWN5NWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQnlaWE52YkhabElFRWdablZ1WTNScGIyNGdkR2hoZENCeVpYTnZiSFpsY3lCMGFHVWdjSEp2YldselpTNWNiaUFxSUVCd1lYSmhiU0I3Um5WdVkzUnBiMjU5SUhKbGFtVmpkQ0JCSUdaMWJtTjBhVzl1SUhSb1lYUWdjbVZxWldOMGN5QjBhR1VnY0hKdmJXbHpaUzVjYmlBcUlFQndZWEpoYlNCN2IySnFaV04wZlNCeVpYTndiMjV6WlNCVWFHVWdjbVZ6Y0c5dWMyVXVYRzRnS2k5Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z2MyVjBkR3hsS0hKbGMyOXNkbVVzSUhKbGFtVmpkQ3dnY21WemNHOXVjMlVwSUh0Y2JpQWdkbUZ5SUhaaGJHbGtZWFJsVTNSaGRIVnpJRDBnY21WemNHOXVjMlV1WTI5dVptbG5MblpoYkdsa1lYUmxVM1JoZEhWek8xeHVJQ0JwWmlBb0lYSmxjM0J2Ym5ObExuTjBZWFIxY3lCOGZDQWhkbUZzYVdSaGRHVlRkR0YwZFhNZ2ZId2dkbUZzYVdSaGRHVlRkR0YwZFhNb2NtVnpjRzl1YzJVdWMzUmhkSFZ6S1NrZ2UxeHVJQ0FnSUhKbGMyOXNkbVVvY21WemNHOXVjMlVwTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGFtVmpkQ2hqY21WaGRHVkZjbkp2Y2loY2JpQWdJQ0FnSUNkU1pYRjFaWE4wSUdaaGFXeGxaQ0IzYVhSb0lITjBZWFIxY3lCamIyUmxJQ2NnS3lCeVpYTndiMjV6WlM1emRHRjBkWE1zWEc0Z0lDQWdJQ0J5WlhOd2IyNXpaUzVqYjI1bWFXY3NYRzRnSUNBZ0lDQnVkV3hzTEZ4dUlDQWdJQ0FnY21WemNHOXVjMlV1Y21WeGRXVnpkQ3hjYmlBZ0lDQWdJSEpsYzNCdmJuTmxYRzRnSUNBZ0tTazdYRzRnSUgxY2JuMDdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQjFkR2xzY3lBOUlISmxjWFZwY21Vb0p5NHZMaTR2ZFhScGJITW5LVHRjYmx4dUx5b3FYRzRnS2lCVWNtRnVjMlp2Y20wZ2RHaGxJR1JoZEdFZ1ptOXlJR0VnY21WeGRXVnpkQ0J2Y2lCaElISmxjM0J2Ym5ObFhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I4VTNSeWFXNW5mU0JrWVhSaElGUm9aU0JrWVhSaElIUnZJR0psSUhSeVlXNXpabTl5YldWa1hHNGdLaUJBY0dGeVlXMGdlMEZ5Y21GNWZTQm9aV0ZrWlhKeklGUm9aU0JvWldGa1pYSnpJR1p2Y2lCMGFHVWdjbVZ4ZFdWemRDQnZjaUJ5WlhOd2IyNXpaVnh1SUNvZ1FIQmhjbUZ0SUh0QmNuSmhlWHhHZFc1amRHbHZibjBnWm01eklFRWdjMmx1WjJ4bElHWjFibU4wYVc5dUlHOXlJRUZ5Y21GNUlHOW1JR1oxYm1OMGFXOXVjMXh1SUNvZ1FISmxkSFZ5Ym5NZ2V5cDlJRlJvWlNCeVpYTjFiSFJwYm1jZ2RISmhibk5tYjNKdFpXUWdaR0YwWVZ4dUlDb3ZYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJSFJ5WVc1elptOXliVVJoZEdFb1pHRjBZU3dnYUdWaFpHVnljeXdnWm01ektTQjdYRzRnSUM4cVpYTnNhVzUwSUc1dkxYQmhjbUZ0TFhKbFlYTnphV2R1T2pBcUwxeHVJQ0IxZEdsc2N5NW1iM0pGWVdOb0tHWnVjeXdnWm5WdVkzUnBiMjRnZEhKaGJuTm1iM0p0S0dadUtTQjdYRzRnSUNBZ1pHRjBZU0E5SUdadUtHUmhkR0VzSUdobFlXUmxjbk1wTzF4dUlDQjlLVHRjYmx4dUlDQnlaWFIxY200Z1pHRjBZVHRjYm4wN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCMWRHbHNjeUE5SUhKbGNYVnBjbVVvSnk0dmRYUnBiSE1uS1R0Y2JuWmhjaUJ1YjNKdFlXeHBlbVZJWldGa1pYSk9ZVzFsSUQwZ2NtVnhkV2x5WlNnbkxpOW9aV3h3WlhKekwyNXZjbTFoYkdsNlpVaGxZV1JsY2s1aGJXVW5LVHRjYmx4dWRtRnlJRVJGUmtGVlRGUmZRMDlPVkVWT1ZGOVVXVkJGSUQwZ2UxeHVJQ0FuUTI5dWRHVnVkQzFVZVhCbEp6b2dKMkZ3Y0d4cFkyRjBhVzl1TDNndGQzZDNMV1p2Y20wdGRYSnNaVzVqYjJSbFpDZGNibjA3WEc1Y2JtWjFibU4wYVc5dUlITmxkRU52Ym5SbGJuUlVlWEJsU1daVmJuTmxkQ2hvWldGa1pYSnpMQ0IyWVd4MVpTa2dlMXh1SUNCcFppQW9JWFYwYVd4ekxtbHpWVzVrWldacGJtVmtLR2hsWVdSbGNuTXBJQ1ltSUhWMGFXeHpMbWx6Vlc1a1pXWnBibVZrS0dobFlXUmxjbk5iSjBOdmJuUmxiblF0Vkhsd1pTZGRLU2tnZTF4dUlDQWdJR2hsWVdSbGNuTmJKME52Ym5SbGJuUXRWSGx3WlNkZElEMGdkbUZzZFdVN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdaMlYwUkdWbVlYVnNkRUZrWVhCMFpYSW9LU0I3WEc0Z0lIWmhjaUJoWkdGd2RHVnlPMXh1SUNCcFppQW9kSGx3Wlc5bUlGaE5URWgwZEhCU1pYRjFaWE4wSUNFOVBTQW5kVzVrWldacGJtVmtKeWtnZTF4dUlDQWdJQzh2SUVadmNpQmljbTkzYzJWeWN5QjFjMlVnV0VoU0lHRmtZWEIwWlhKY2JpQWdJQ0JoWkdGd2RHVnlJRDBnY21WeGRXbHlaU2duTGk5aFpHRndkR1Z5Y3k5NGFISW5LVHRjYmlBZ2ZTQmxiSE5sSUdsbUlDaDBlWEJsYjJZZ2NISnZZMlZ6Y3lBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NnSmlZZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1Wnk1allXeHNLSEJ5YjJObGMzTXBJRDA5UFNBblcyOWlhbVZqZENCd2NtOWpaWE56WFNjcElIdGNiaUFnSUNBdkx5QkdiM0lnYm05a1pTQjFjMlVnU0ZSVVVDQmhaR0Z3ZEdWeVhHNGdJQ0FnWVdSaGNIUmxjaUE5SUhKbGNYVnBjbVVvSnk0dllXUmhjSFJsY25NdmFIUjBjQ2NwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJoWkdGd2RHVnlPMXh1ZlZ4dVhHNTJZWElnWkdWbVlYVnNkSE1nUFNCN1hHNGdJR0ZrWVhCMFpYSTZJR2RsZEVSbFptRjFiSFJCWkdGd2RHVnlLQ2tzWEc1Y2JpQWdkSEpoYm5ObWIzSnRVbVZ4ZFdWemREb2dXMloxYm1OMGFXOXVJSFJ5WVc1elptOXliVkpsY1hWbGMzUW9aR0YwWVN3Z2FHVmhaR1Z5Y3lrZ2UxeHVJQ0FnSUc1dmNtMWhiR2w2WlVobFlXUmxjazVoYldVb2FHVmhaR1Z5Y3l3Z0owRmpZMlZ3ZENjcE8xeHVJQ0FnSUc1dmNtMWhiR2w2WlVobFlXUmxjazVoYldVb2FHVmhaR1Z5Y3l3Z0owTnZiblJsYm5RdFZIbHdaU2NwTzF4dUlDQWdJR2xtSUNoMWRHbHNjeTVwYzBadmNtMUVZWFJoS0dSaGRHRXBJSHg4WEc0Z0lDQWdJQ0IxZEdsc2N5NXBjMEZ5Y21GNVFuVm1abVZ5S0dSaGRHRXBJSHg4WEc0Z0lDQWdJQ0IxZEdsc2N5NXBjMEoxWm1abGNpaGtZWFJoS1NCOGZGeHVJQ0FnSUNBZ2RYUnBiSE11YVhOVGRISmxZVzBvWkdGMFlTa2dmSHhjYmlBZ0lDQWdJSFYwYVd4ekxtbHpSbWxzWlNoa1lYUmhLU0I4ZkZ4dUlDQWdJQ0FnZFhScGJITXVhWE5DYkc5aUtHUmhkR0VwWEc0Z0lDQWdLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdaR0YwWVR0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0hWMGFXeHpMbWx6UVhKeVlYbENkV1ptWlhKV2FXVjNLR1JoZEdFcEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1pHRjBZUzVpZFdabVpYSTdYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUlDaDFkR2xzY3k1cGMxVlNURk5sWVhKamFGQmhjbUZ0Y3loa1lYUmhLU2tnZTF4dUlDQWdJQ0FnYzJWMFEyOXVkR1Z1ZEZSNWNHVkpabFZ1YzJWMEtHaGxZV1JsY25Nc0lDZGhjSEJzYVdOaGRHbHZiaTk0TFhkM2R5MW1iM0p0TFhWeWJHVnVZMjlrWldRN1kyaGhjbk5sZEQxMWRHWXRPQ2NwTzF4dUlDQWdJQ0FnY21WMGRYSnVJR1JoZEdFdWRHOVRkSEpwYm1jb0tUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tIVjBhV3h6TG1selQySnFaV04wS0dSaGRHRXBLU0I3WEc0Z0lDQWdJQ0J6WlhSRGIyNTBaVzUwVkhsd1pVbG1WVzV6WlhRb2FHVmhaR1Z5Y3l3Z0oyRndjR3hwWTJGMGFXOXVMMnB6YjI0N1kyaGhjbk5sZEQxMWRHWXRPQ2NwTzF4dUlDQWdJQ0FnY21WMGRYSnVJRXBUVDA0dWMzUnlhVzVuYVdaNUtHUmhkR0VwTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z1pHRjBZVHRjYmlBZ2ZWMHNYRzVjYmlBZ2RISmhibk5tYjNKdFVtVnpjRzl1YzJVNklGdG1kVzVqZEdsdmJpQjBjbUZ1YzJadmNtMVNaWE53YjI1elpTaGtZWFJoS1NCN1hHNGdJQ0FnTHlwbGMyeHBiblFnYm04dGNHRnlZVzB0Y21WaGMzTnBaMjQ2TUNvdlhHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCa1lYUmhJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnWkdGMFlTQTlJRXBUVDA0dWNHRnljMlVvWkdGMFlTazdYRzRnSUNBZ0lDQjlJR05oZEdOb0lDaGxLU0I3SUM4cUlFbG5ibTl5WlNBcUx5QjlYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJrWVhSaE8xeHVJQ0I5WFN4Y2JseHVJQ0F2S2lwY2JpQWdJQ29nUVNCMGFXMWxiM1YwSUdsdUlHMXBiR3hwYzJWamIyNWtjeUIwYnlCaFltOXlkQ0JoSUhKbGNYVmxjM1F1SUVsbUlITmxkQ0IwYnlBd0lDaGtaV1poZFd4MEtTQmhYRzRnSUNBcUlIUnBiV1Z2ZFhRZ2FYTWdibTkwSUdOeVpXRjBaV1F1WEc0Z0lDQXFMMXh1SUNCMGFXMWxiM1YwT2lBd0xGeHVYRzRnSUhoemNtWkRiMjlyYVdWT1lXMWxPaUFuV0ZOU1JpMVVUMHRGVGljc1hHNGdJSGh6Y21aSVpXRmtaWEpPWVcxbE9pQW5XQzFZVTFKR0xWUlBTMFZPSnl4Y2JseHVJQ0J0WVhoRGIyNTBaVzUwVEdWdVozUm9PaUF0TVN4Y2JpQWdiV0Y0UW05a2VVeGxibWQwYURvZ0xURXNYRzVjYmlBZ2RtRnNhV1JoZEdWVGRHRjBkWE02SUdaMWJtTjBhVzl1SUhaaGJHbGtZWFJsVTNSaGRIVnpLSE4wWVhSMWN5a2dlMXh1SUNBZ0lISmxkSFZ5YmlCemRHRjBkWE1nUGowZ01qQXdJQ1ltSUhOMFlYUjFjeUE4SURNd01EdGNiaUFnZlZ4dWZUdGNibHh1WkdWbVlYVnNkSE11YUdWaFpHVnljeUE5SUh0Y2JpQWdZMjl0Ylc5dU9pQjdYRzRnSUNBZ0owRmpZMlZ3ZENjNklDZGhjSEJzYVdOaGRHbHZiaTlxYzI5dUxDQjBaWGgwTDNCc1lXbHVMQ0FxTHlvblhHNGdJSDFjYm4wN1hHNWNiblYwYVd4ekxtWnZja1ZoWTJnb1d5ZGtaV3hsZEdVbkxDQW5aMlYwSnl3Z0oyaGxZV1FuWFN3Z1puVnVZM1JwYjI0Z1ptOXlSV0ZqYUUxbGRHaHZaRTV2UkdGMFlTaHRaWFJvYjJRcElIdGNiaUFnWkdWbVlYVnNkSE11YUdWaFpHVnljMXR0WlhSb2IyUmRJRDBnZTMwN1hHNTlLVHRjYmx4dWRYUnBiSE11Wm05eVJXRmphQ2hiSjNCdmMzUW5MQ0FuY0hWMEp5d2dKM0JoZEdOb0oxMHNJR1oxYm1OMGFXOXVJR1p2Y2tWaFkyaE5aWFJvYjJSWGFYUm9SR0YwWVNodFpYUm9iMlFwSUh0Y2JpQWdaR1ZtWVhWc2RITXVhR1ZoWkdWeWMxdHRaWFJvYjJSZElEMGdkWFJwYkhNdWJXVnlaMlVvUkVWR1FWVk1WRjlEVDA1VVJVNVVYMVJaVUVVcE8xeHVmU2s3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1pHVm1ZWFZzZEhNN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdZbWx1WkNobWJpd2dkR2hwYzBGeVp5a2dlMXh1SUNCeVpYUjFjbTRnWm5WdVkzUnBiMjRnZDNKaGNDZ3BJSHRjYmlBZ0lDQjJZWElnWVhKbmN5QTlJRzVsZHlCQmNuSmhlU2hoY21kMWJXVnVkSE11YkdWdVozUm9LVHRjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR0Z5WjNNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJR0Z5WjNOYmFWMGdQU0JoY21kMWJXVnVkSE5iYVYwN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQm1iaTVoY0hCc2VTaDBhR2x6UVhKbkxDQmhjbWR6S1R0Y2JpQWdmVHRjYm4wN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCMWRHbHNjeUE5SUhKbGNYVnBjbVVvSnk0dkxpNHZkWFJwYkhNbktUdGNibHh1Wm5WdVkzUnBiMjRnWlc1amIyUmxLSFpoYkNrZ2UxeHVJQ0J5WlhSMWNtNGdaVzVqYjJSbFZWSkpRMjl0Y0c5dVpXNTBLSFpoYkNrdVhHNGdJQ0FnY21Wd2JHRmpaU2d2SlROQkwyZHBMQ0FuT2ljcExseHVJQ0FnSUhKbGNHeGhZMlVvTHlVeU5DOW5MQ0FuSkNjcExseHVJQ0FnSUhKbGNHeGhZMlVvTHlVeVF5OW5hU3dnSnl3bktTNWNiaUFnSUNCeVpYQnNZV05sS0M4bE1qQXZaeXdnSnlzbktTNWNiaUFnSUNCeVpYQnNZV05sS0M4bE5VSXZaMmtzSUNkYkp5a3VYRzRnSUNBZ2NtVndiR0ZqWlNndkpUVkVMMmRwTENBblhTY3BPMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFSjFhV3hrSUdFZ1ZWSk1JR0o1SUdGd2NHVnVaR2x1WnlCd1lYSmhiWE1nZEc4Z2RHaGxJR1Z1WkZ4dUlDcGNiaUFxSUVCd1lYSmhiU0I3YzNSeWFXNW5mU0IxY213Z1ZHaGxJR0poYzJVZ2IyWWdkR2hsSUhWeWJDQW9aUzVuTGl3Z2FIUjBjRG92TDNkM2R5NW5iMjluYkdVdVkyOXRLVnh1SUNvZ1FIQmhjbUZ0SUh0dlltcGxZM1I5SUZ0d1lYSmhiWE5kSUZSb1pTQndZWEpoYlhNZ2RHOGdZbVVnWVhCd1pXNWtaV1JjYmlBcUlFQnlaWFIxY201eklIdHpkSEpwYm1kOUlGUm9aU0JtYjNKdFlYUjBaV1FnZFhKc1hHNGdLaTljYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnWW5WcGJHUlZVa3dvZFhKc0xDQndZWEpoYlhNc0lIQmhjbUZ0YzFObGNtbGhiR2w2WlhJcElIdGNiaUFnTHlwbGMyeHBiblFnYm04dGNHRnlZVzB0Y21WaGMzTnBaMjQ2TUNvdlhHNGdJR2xtSUNnaGNHRnlZVzF6S1NCN1hHNGdJQ0FnY21WMGRYSnVJSFZ5YkR0Y2JpQWdmVnh1WEc0Z0lIWmhjaUJ6WlhKcFlXeHBlbVZrVUdGeVlXMXpPMXh1SUNCcFppQW9jR0Z5WVcxelUyVnlhV0ZzYVhwbGNpa2dlMXh1SUNBZ0lITmxjbWxoYkdsNlpXUlFZWEpoYlhNZ1BTQndZWEpoYlhOVFpYSnBZV3hwZW1WeUtIQmhjbUZ0Y3lrN1hHNGdJSDBnWld4elpTQnBaaUFvZFhScGJITXVhWE5WVWt4VFpXRnlZMmhRWVhKaGJYTW9jR0Z5WVcxektTa2dlMXh1SUNBZ0lITmxjbWxoYkdsNlpXUlFZWEpoYlhNZ1BTQndZWEpoYlhNdWRHOVRkSEpwYm1jb0tUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQjJZWElnY0dGeWRITWdQU0JiWFR0Y2JseHVJQ0FnSUhWMGFXeHpMbVp2Y2tWaFkyZ29jR0Z5WVcxekxDQm1kVzVqZEdsdmJpQnpaWEpwWVd4cGVtVW9kbUZzTENCclpYa3BJSHRjYmlBZ0lDQWdJR2xtSUNoMllXd2dQVDA5SUc1MWJHd2dmSHdnZEhsd1pXOW1JSFpoYkNBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCcFppQW9kWFJwYkhNdWFYTkJjbkpoZVNoMllXd3BLU0I3WEc0Z0lDQWdJQ0FnSUd0bGVTQTlJR3RsZVNBcklDZGJYU2M3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0IyWVd3Z1BTQmJkbUZzWFR0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2RYUnBiSE11Wm05eVJXRmphQ2gyWVd3c0lHWjFibU4wYVc5dUlIQmhjbk5sVm1Gc2RXVW9kaWtnZTF4dUlDQWdJQ0FnSUNCcFppQW9kWFJwYkhNdWFYTkVZWFJsS0hZcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnZGlBOUlIWXVkRzlKVTA5VGRISnBibWNvS1R0Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaDFkR2xzY3k1cGMwOWlhbVZqZENoMktTa2dlMXh1SUNBZ0lDQWdJQ0FnSUhZZ1BTQktVMDlPTG5OMGNtbHVaMmxtZVNoMktUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J3WVhKMGN5NXdkWE5vS0dWdVkyOWtaU2hyWlhrcElDc2dKejBuSUNzZ1pXNWpiMlJsS0hZcEtUdGNiaUFnSUNBZ0lIMHBPMXh1SUNBZ0lIMHBPMXh1WEc0Z0lDQWdjMlZ5YVdGc2FYcGxaRkJoY21GdGN5QTlJSEJoY25SekxtcHZhVzRvSnlZbktUdGNiaUFnZlZ4dVhHNGdJR2xtSUNoelpYSnBZV3hwZW1Wa1VHRnlZVzF6S1NCN1hHNGdJQ0FnZG1GeUlHaGhjMmh0WVhKclNXNWtaWGdnUFNCMWNtd3VhVzVrWlhoUFppZ25JeWNwTzF4dUlDQWdJR2xtSUNob1lYTm9iV0Z5YTBsdVpHVjRJQ0U5UFNBdE1Ta2dlMXh1SUNBZ0lDQWdkWEpzSUQwZ2RYSnNMbk5zYVdObEtEQXNJR2hoYzJodFlYSnJTVzVrWlhncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhWeWJDQXJQU0FvZFhKc0xtbHVaR1Y0VDJZb0p6OG5LU0E5UFQwZ0xURWdQeUFuUHljZ09pQW5KaWNwSUNzZ2MyVnlhV0ZzYVhwbFpGQmhjbUZ0Y3p0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCMWNtdzdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNHZLaXBjYmlBcUlFTnlaV0YwWlhNZ1lTQnVaWGNnVlZKTUlHSjVJR052YldKcGJtbHVaeUIwYUdVZ2MzQmxZMmxtYVdWa0lGVlNUSE5jYmlBcVhHNGdLaUJBY0dGeVlXMGdlM04wY21sdVozMGdZbUZ6WlZWU1RDQlVhR1VnWW1GelpTQlZVa3hjYmlBcUlFQndZWEpoYlNCN2MzUnlhVzVuZlNCeVpXeGhkR2wyWlZWU1RDQlVhR1VnY21Wc1lYUnBkbVVnVlZKTVhHNGdLaUJBY21WMGRYSnVjeUI3YzNSeWFXNW5mU0JVYUdVZ1kyOXRZbWx1WldRZ1ZWSk1YRzRnS2k5Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z1kyOXRZbWx1WlZWU1RITW9ZbUZ6WlZWU1RDd2djbVZzWVhScGRtVlZVa3dwSUh0Y2JpQWdjbVYwZFhKdUlISmxiR0YwYVhabFZWSk1YRzRnSUNBZ1B5QmlZWE5sVlZKTUxuSmxjR3hoWTJVb0wxeGNMeXNrTHl3Z0p5Y3BJQ3NnSnk4bklDc2djbVZzWVhScGRtVlZVa3d1Y21Wd2JHRmpaU2d2WGx4Y0x5c3ZMQ0FuSnlsY2JpQWdJQ0E2SUdKaGMyVlZVa3c3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ2RYUnBiSE1nUFNCeVpYRjFhWEpsS0NjdUx5NHVMM1YwYVd4ekp5azdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnS0Z4dUlDQjFkR2xzY3k1cGMxTjBZVzVrWVhKa1FuSnZkM05sY2tWdWRpZ3BJRDljYmx4dUlDQXZMeUJUZEdGdVpHRnlaQ0JpY205M2MyVnlJR1Z1ZG5NZ2MzVndjRzl5ZENCa2IyTjFiV1Z1ZEM1amIyOXJhV1ZjYmlBZ0lDQW9ablZ1WTNScGIyNGdjM1JoYm1SaGNtUkNjbTkzYzJWeVJXNTJLQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnZDNKcGRHVTZJR1oxYm1OMGFXOXVJSGR5YVhSbEtHNWhiV1VzSUhaaGJIVmxMQ0JsZUhCcGNtVnpMQ0J3WVhSb0xDQmtiMjFoYVc0c0lITmxZM1Z5WlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJSFpoY2lCamIyOXJhV1VnUFNCYlhUdGNiaUFnSUNBZ0lDQWdJQ0JqYjI5cmFXVXVjSFZ6YUNodVlXMWxJQ3NnSnowbklDc2daVzVqYjJSbFZWSkpRMjl0Y0c5dVpXNTBLSFpoYkhWbEtTazdYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9kWFJwYkhNdWFYTk9kVzFpWlhJb1pYaHdhWEpsY3lrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmIydHBaUzV3ZFhOb0tDZGxlSEJwY21WelBTY2dLeUJ1WlhjZ1JHRjBaU2hsZUhCcGNtVnpLUzUwYjBkTlZGTjBjbWx1WnlncEtUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZFhScGJITXVhWE5UZEhKcGJtY29jR0YwYUNrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmIydHBaUzV3ZFhOb0tDZHdZWFJvUFNjZ0t5QndZWFJvS1R0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9kWFJwYkhNdWFYTlRkSEpwYm1jb1pHOXRZV2x1S1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dmEybGxMbkIxYzJnb0oyUnZiV0ZwYmowbklDc2daRzl0WVdsdUtUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvYzJWamRYSmxJRDA5UFNCMGNuVmxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjlyYVdVdWNIVnphQ2duYzJWamRYSmxKeWs3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQ0FnWkc5amRXMWxiblF1WTI5dmEybGxJRDBnWTI5dmEybGxMbXB2YVc0b0p6c2dKeWs3WEc0Z0lDQWdJQ0FnSUgwc1hHNWNiaUFnSUNBZ0lDQWdjbVZoWkRvZ1puVnVZM1JwYjI0Z2NtVmhaQ2h1WVcxbEtTQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHMWhkR05vSUQwZ1pHOWpkVzFsYm5RdVkyOXZhMmxsTG0xaGRHTm9LRzVsZHlCU1pXZEZlSEFvSnloZWZEdGNYRnhjY3lvcEtDY2dLeUJ1WVcxbElDc2dKeWs5S0Z0ZU8xMHFLU2NwS1R0Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0tHMWhkR05vSUQ4Z1pHVmpiMlJsVlZKSlEyOXRjRzl1Wlc1MEtHMWhkR05vV3pOZEtTQTZJRzUxYkd3cE8xeHVJQ0FnSUNBZ0lDQjlMRnh1WEc0Z0lDQWdJQ0FnSUhKbGJXOTJaVG9nWm5WdVkzUnBiMjRnY21WdGIzWmxLRzVoYldVcElIdGNiaUFnSUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsS0c1aGJXVXNJQ2NuTENCRVlYUmxMbTV2ZHlncElDMGdPRFkwTURBd01EQXBPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5TzF4dUlDQWdJSDBwS0NrZ09seHVYRzRnSUM4dklFNXZiaUJ6ZEdGdVpHRnlaQ0JpY205M2MyVnlJR1Z1ZGlBb2QyVmlJSGR2Y210bGNuTXNJSEpsWVdOMExXNWhkR2wyWlNrZ2JHRmpheUJ1WldWa1pXUWdjM1Z3Y0c5eWRDNWNiaUFnSUNBb1puVnVZM1JwYjI0Z2JtOXVVM1JoYm1SaGNtUkNjbTkzYzJWeVJXNTJLQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnZDNKcGRHVTZJR1oxYm1OMGFXOXVJSGR5YVhSbEtDa2dlMzBzWEc0Z0lDQWdJQ0FnSUhKbFlXUTZJR1oxYm1OMGFXOXVJSEpsWVdRb0tTQjdJSEpsZEhWeWJpQnVkV3hzT3lCOUxGeHVJQ0FnSUNBZ0lDQnlaVzF2ZG1VNklHWjFibU4wYVc5dUlISmxiVzkyWlNncElIdDlYRzRnSUNBZ0lDQjlPMXh1SUNBZ0lIMHBLQ2xjYmlrN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiaThxS2x4dUlDb2dSR1YwWlhKdGFXNWxjeUIzYUdWMGFHVnlJSFJvWlNCemNHVmphV1pwWldRZ1ZWSk1JR2x6SUdGaWMyOXNkWFJsWEc0Z0tseHVJQ29nUUhCaGNtRnRJSHR6ZEhKcGJtZDlJSFZ5YkNCVWFHVWdWVkpNSUhSdklIUmxjM1JjYmlBcUlFQnlaWFIxY201eklIdGliMjlzWldGdWZTQlVjblZsSUdsbUlIUm9aU0J6Y0dWamFXWnBaV1FnVlZKTUlHbHpJR0ZpYzI5c2RYUmxMQ0J2ZEdobGNuZHBjMlVnWm1Gc2MyVmNiaUFxTDF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCcGMwRmljMjlzZFhSbFZWSk1LSFZ5YkNrZ2UxeHVJQ0F2THlCQklGVlNUQ0JwY3lCamIyNXphV1JsY21Wa0lHRmljMjlzZFhSbElHbG1JR2wwSUdKbFoybHVjeUIzYVhSb0lGd2lQSE5qYUdWdFpUNDZMeTljSWlCdmNpQmNJaTh2WENJZ0tIQnliM1J2WTI5c0xYSmxiR0YwYVhabElGVlNUQ2t1WEc0Z0lDOHZJRkpHUXlBek9UZzJJR1JsWm1sdVpYTWdjMk5vWlcxbElHNWhiV1VnWVhNZ1lTQnpaWEYxWlc1alpTQnZaaUJqYUdGeVlXTjBaWEp6SUdKbFoybHVibWx1WnlCM2FYUm9JR0VnYkdWMGRHVnlJR0Z1WkNCbWIyeHNiM2RsWkZ4dUlDQXZMeUJpZVNCaGJua2dZMjl0WW1sdVlYUnBiMjRnYjJZZ2JHVjBkR1Z5Y3l3Z1pHbG5hWFJ6TENCd2JIVnpMQ0J3WlhKcGIyUXNJRzl5SUdoNWNHaGxiaTVjYmlBZ2NtVjBkWEp1SUM5ZUtGdGhMWHBkVzJFdGVseGNaRnhjSzF4Y0xWeGNMbDBxT2lrL1hGd3ZYRnd2TDJrdWRHVnpkQ2gxY213cE8xeHVmVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dUx5b3FYRzRnS2lCRVpYUmxjbTFwYm1WeklIZG9aWFJvWlhJZ2RHaGxJSEJoZVd4dllXUWdhWE1nWVc0Z1pYSnliM0lnZEdoeWIzZHVJR0o1SUVGNGFXOXpYRzRnS2x4dUlDb2dRSEJoY21GdElIc3FmU0J3WVhsc2IyRmtJRlJvWlNCMllXeDFaU0IwYnlCMFpYTjBYRzRnS2lCQWNtVjBkWEp1Y3lCN1ltOXZiR1ZoYm4wZ1ZISjFaU0JwWmlCMGFHVWdjR0Y1Ykc5aFpDQnBjeUJoYmlCbGNuSnZjaUIwYUhKdmQyNGdZbmtnUVhocGIzTXNJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUdselFYaHBiM05GY25KdmNpaHdZWGxzYjJGa0tTQjdYRzRnSUhKbGRIVnliaUFvZEhsd1pXOW1JSEJoZVd4dllXUWdQVDA5SUNkdlltcGxZM1FuS1NBbUppQW9jR0Y1Ykc5aFpDNXBjMEY0YVc5elJYSnliM0lnUFQwOUlIUnlkV1VwTzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1ZG1GeUlIVjBhV3h6SUQwZ2NtVnhkV2x5WlNnbkxpOHVMaTkxZEdsc2N5Y3BPMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUNoY2JpQWdkWFJwYkhNdWFYTlRkR0Z1WkdGeVpFSnliM2R6WlhKRmJuWW9LU0EvWEc1Y2JpQWdMeThnVTNSaGJtUmhjbVFnWW5KdmQzTmxjaUJsYm5aeklHaGhkbVVnWm5Wc2JDQnpkWEJ3YjNKMElHOW1JSFJvWlNCQlVFbHpJRzVsWldSbFpDQjBieUIwWlhOMFhHNGdJQzh2SUhkb1pYUm9aWElnZEdobElISmxjWFZsYzNRZ1ZWSk1JR2x6SUc5bUlIUm9aU0J6WVcxbElHOXlhV2RwYmlCaGN5QmpkWEp5Wlc1MElHeHZZMkYwYVc5dUxseHVJQ0FnSUNobWRXNWpkR2x2YmlCemRHRnVaR0Z5WkVKeWIzZHpaWEpGYm5Zb0tTQjdYRzRnSUNBZ0lDQjJZWElnYlhOcFpTQTlJQzhvYlhOcFpYeDBjbWxrWlc1MEtTOXBMblJsYzNRb2JtRjJhV2RoZEc5eUxuVnpaWEpCWjJWdWRDazdYRzRnSUNBZ0lDQjJZWElnZFhKc1VHRnljMmx1WjA1dlpHVWdQU0JrYjJOMWJXVnVkQzVqY21WaGRHVkZiR1Z0Wlc1MEtDZGhKeWs3WEc0Z0lDQWdJQ0IyWVhJZ2IzSnBaMmx1VlZKTU8xeHVYRzRnSUNBZ0lDQXZLaXBjYmlBZ0lDQXFJRkJoY25ObElHRWdWVkpNSUhSdklHUnBjMk52ZG1WeUlHbDBKM01nWTI5dGNHOXVaVzUwYzF4dUlDQWdJQ3BjYmlBZ0lDQXFJRUJ3WVhKaGJTQjdVM1J5YVc1bmZTQjFjbXdnVkdobElGVlNUQ0IwYnlCaVpTQndZWEp6WldSY2JpQWdJQ0FxSUVCeVpYUjFjbTV6SUh0UFltcGxZM1I5WEc0Z0lDQWdLaTljYmlBZ0lDQWdJR1oxYm1OMGFXOXVJSEpsYzI5c2RtVlZVa3dvZFhKc0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCb2NtVm1JRDBnZFhKc08xeHVYRzRnSUNBZ0lDQWdJR2xtSUNodGMybGxLU0I3WEc0Z0lDQWdJQ0FnSUM4dklFbEZJRzVsWldSeklHRjBkSEpwWW5WMFpTQnpaWFFnZEhkcFkyVWdkRzhnYm05eWJXRnNhWHBsSUhCeWIzQmxjblJwWlhOY2JpQWdJQ0FnSUNBZ0lDQjFjbXhRWVhKemFXNW5UbTlrWlM1elpYUkJkSFJ5YVdKMWRHVW9KMmh5WldZbkxDQm9jbVZtS1R0Y2JpQWdJQ0FnSUNBZ0lDQm9jbVZtSUQwZ2RYSnNVR0Z5YzJsdVowNXZaR1V1YUhKbFpqdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUhWeWJGQmhjbk5wYm1kT2IyUmxMbk5sZEVGMGRISnBZblYwWlNnbmFISmxaaWNzSUdoeVpXWXBPMXh1WEc0Z0lDQWdJQ0FnSUM4dklIVnliRkJoY25OcGJtZE9iMlJsSUhCeWIzWnBaR1Z6SUhSb1pTQlZjbXhWZEdsc2N5QnBiblJsY21aaFkyVWdMU0JvZEhSd09pOHZkWEpzTG5Od1pXTXVkMmhoZEhkbkxtOXlaeThqZFhKc2RYUnBiSE5jYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQ0FnSUNCb2NtVm1PaUIxY214UVlYSnphVzVuVG05a1pTNW9jbVZtTEZ4dUlDQWdJQ0FnSUNBZ0lIQnliM1J2WTI5c09pQjFjbXhRWVhKemFXNW5UbTlrWlM1d2NtOTBiMk52YkNBL0lIVnliRkJoY25OcGJtZE9iMlJsTG5CeWIzUnZZMjlzTG5KbGNHeGhZMlVvTHpva0x5d2dKeWNwSURvZ0p5Y3NYRzRnSUNBZ0lDQWdJQ0FnYUc5emREb2dkWEpzVUdGeWMybHVaMDV2WkdVdWFHOXpkQ3hjYmlBZ0lDQWdJQ0FnSUNCelpXRnlZMmc2SUhWeWJGQmhjbk5wYm1kT2IyUmxMbk5sWVhKamFDQS9JSFZ5YkZCaGNuTnBibWRPYjJSbExuTmxZWEpqYUM1eVpYQnNZV05sS0M5ZVhGdy9MeXdnSnljcElEb2dKeWNzWEc0Z0lDQWdJQ0FnSUNBZ2FHRnphRG9nZFhKc1VHRnljMmx1WjA1dlpHVXVhR0Z6YUNBL0lIVnliRkJoY25OcGJtZE9iMlJsTG1oaGMyZ3VjbVZ3YkdGalpTZ3ZYaU12TENBbkp5a2dPaUFuSnl4Y2JpQWdJQ0FnSUNBZ0lDQm9iM04wYm1GdFpUb2dkWEpzVUdGeWMybHVaMDV2WkdVdWFHOXpkRzVoYldVc1hHNGdJQ0FnSUNBZ0lDQWdjRzl5ZERvZ2RYSnNVR0Z5YzJsdVowNXZaR1V1Y0c5eWRDeGNiaUFnSUNBZ0lDQWdJQ0J3WVhSb2JtRnRaVG9nS0hWeWJGQmhjbk5wYm1kT2IyUmxMbkJoZEdodVlXMWxMbU5vWVhKQmRDZ3dLU0E5UFQwZ0p5OG5LU0EvWEc0Z0lDQWdJQ0FnSUNBZ0lDQjFjbXhRWVhKemFXNW5UbTlrWlM1d1lYUm9ibUZ0WlNBNlhHNGdJQ0FnSUNBZ0lDQWdJQ0FuTHljZ0t5QjFjbXhRWVhKemFXNW5UbTlrWlM1d1lYUm9ibUZ0WlZ4dUlDQWdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnZjbWxuYVc1VlVrd2dQU0J5WlhOdmJIWmxWVkpNS0hkcGJtUnZkeTVzYjJOaGRHbHZiaTVvY21WbUtUdGNibHh1SUNBZ0lDQWdMeW9xWEc0Z0lDQWdLaUJFWlhSbGNtMXBibVVnYVdZZ1lTQlZVa3dnYzJoaGNtVnpJSFJvWlNCellXMWxJRzl5YVdkcGJpQmhjeUIwYUdVZ1kzVnljbVZ1ZENCc2IyTmhkR2x2Ymx4dUlDQWdJQ3BjYmlBZ0lDQXFJRUJ3WVhKaGJTQjdVM1J5YVc1bmZTQnlaWEYxWlhOMFZWSk1JRlJvWlNCVlVrd2dkRzhnZEdWemRGeHVJQ0FnSUNvZ1FISmxkSFZ5Ym5NZ2UySnZiMnhsWVc1OUlGUnlkV1VnYVdZZ1ZWSk1JSE5vWVhKbGN5QjBhR1VnYzJGdFpTQnZjbWxuYVc0c0lHOTBhR1Z5ZDJselpTQm1ZV3h6WlZ4dUlDQWdJQ292WEc0Z0lDQWdJQ0J5WlhSMWNtNGdablZ1WTNScGIyNGdhWE5WVWt4VFlXMWxUM0pwWjJsdUtISmxjWFZsYzNSVlVrd3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlIQmhjbk5sWkNBOUlDaDFkR2xzY3k1cGMxTjBjbWx1WnloeVpYRjFaWE4wVlZKTUtTa2dQeUJ5WlhOdmJIWmxWVkpNS0hKbGNYVmxjM1JWVWt3cElEb2djbVZ4ZFdWemRGVlNURHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJQ2h3WVhKelpXUXVjSEp2ZEc5amIyd2dQVDA5SUc5eWFXZHBibFZTVEM1d2NtOTBiMk52YkNBbUpseHVJQ0FnSUNBZ0lDQWdJQ0FnY0dGeWMyVmtMbWh2YzNRZ1BUMDlJRzl5YVdkcGJsVlNUQzVvYjNOMEtUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ2ZTa29LU0E2WEc1Y2JpQWdMeThnVG05dUlITjBZVzVrWVhKa0lHSnliM2R6WlhJZ1pXNTJjeUFvZDJWaUlIZHZjbXRsY25Nc0lISmxZV04wTFc1aGRHbDJaU2tnYkdGamF5QnVaV1ZrWldRZ2MzVndjRzl5ZEM1Y2JpQWdJQ0FvWm5WdVkzUnBiMjRnYm05dVUzUmhibVJoY21SQ2NtOTNjMlZ5Ulc1MktDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHWjFibU4wYVc5dUlHbHpWVkpNVTJGdFpVOXlhV2RwYmlncElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdJQ0I5TzF4dUlDQWdJSDBwS0NsY2JpazdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQjFkR2xzY3lBOUlISmxjWFZwY21Vb0p5NHVMM1YwYVd4ekp5azdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnYm05eWJXRnNhWHBsU0dWaFpHVnlUbUZ0WlNob1pXRmtaWEp6TENCdWIzSnRZV3hwZW1Wa1RtRnRaU2tnZTF4dUlDQjFkR2xzY3k1bWIzSkZZV05vS0dobFlXUmxjbk1zSUdaMWJtTjBhVzl1SUhCeWIyTmxjM05JWldGa1pYSW9kbUZzZFdVc0lHNWhiV1VwSUh0Y2JpQWdJQ0JwWmlBb2JtRnRaU0FoUFQwZ2JtOXliV0ZzYVhwbFpFNWhiV1VnSmlZZ2JtRnRaUzUwYjFWd2NHVnlRMkZ6WlNncElEMDlQU0J1YjNKdFlXeHBlbVZrVG1GdFpTNTBiMVZ3Y0dWeVEyRnpaU2dwS1NCN1hHNGdJQ0FnSUNCb1pXRmtaWEp6VzI1dmNtMWhiR2w2WldST1lXMWxYU0E5SUhaaGJIVmxPMXh1SUNBZ0lDQWdaR1ZzWlhSbElHaGxZV1JsY25OYmJtRnRaVjA3WEc0Z0lDQWdmVnh1SUNCOUtUdGNibjA3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUIxZEdsc2N5QTlJSEpsY1hWcGNtVW9KeTR2TGk0dmRYUnBiSE1uS1R0Y2JseHVMeThnU0dWaFpHVnljeUIzYUc5elpTQmtkWEJzYVdOaGRHVnpJR0Z5WlNCcFoyNXZjbVZrSUdKNUlHNXZaR1ZjYmk4dklHTXVaaTRnYUhSMGNITTZMeTl1YjJSbGFuTXViM0puTDJGd2FTOW9kSFJ3TG1oMGJXd2phSFIwY0Y5dFpYTnpZV2RsWDJobFlXUmxjbk5jYm5aaGNpQnBaMjV2Y21WRWRYQnNhV05oZEdWUFppQTlJRnRjYmlBZ0oyRm5aU2NzSUNkaGRYUm9iM0pwZW1GMGFXOXVKeXdnSjJOdmJuUmxiblF0YkdWdVozUm9KeXdnSjJOdmJuUmxiblF0ZEhsd1pTY3NJQ2RsZEdGbkp5eGNiaUFnSjJWNGNHbHlaWE1uTENBblpuSnZiU2NzSUNkb2IzTjBKeXdnSjJsbUxXMXZaR2xtYVdWa0xYTnBibU5sSnl3Z0oybG1MWFZ1Ylc5a2FXWnBaV1F0YzJsdVkyVW5MRnh1SUNBbmJHRnpkQzF0YjJScFptbGxaQ2NzSUNkc2IyTmhkR2x2Ymljc0lDZHRZWGd0Wm05eWQyRnlaSE1uTENBbmNISnZlSGt0WVhWMGFHOXlhWHBoZEdsdmJpY3NYRzRnSUNkeVpXWmxjbVZ5Snl3Z0ozSmxkSEo1TFdGbWRHVnlKeXdnSjNWelpYSXRZV2RsYm5RblhHNWRPMXh1WEc0dktpcGNiaUFxSUZCaGNuTmxJR2hsWVdSbGNuTWdhVzUwYnlCaGJpQnZZbXBsWTNSY2JpQXFYRzRnS2lCZ1lHQmNiaUFxSUVSaGRHVTZJRmRsWkN3Z01qY2dRWFZuSURJd01UUWdNRGc2TlRnNk5Ea2dSMDFVWEc0Z0tpQkRiMjUwWlc1MExWUjVjR1U2SUdGd2NHeHBZMkYwYVc5dUwycHpiMjVjYmlBcUlFTnZibTVsWTNScGIyNDZJR3RsWlhBdFlXeHBkbVZjYmlBcUlGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bk9pQmphSFZ1YTJWa1hHNGdLaUJnWUdCY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTFOMGNtbHVaMzBnYUdWaFpHVnljeUJJWldGa1pYSnpJRzVsWldScGJtY2dkRzhnWW1VZ2NHRnljMlZrWEc0Z0tpQkFjbVYwZFhKdWN5QjdUMkpxWldOMGZTQklaV0ZrWlhKeklIQmhjbk5sWkNCcGJuUnZJR0Z1SUc5aWFtVmpkRnh1SUNvdlhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlIQmhjbk5sU0dWaFpHVnljeWhvWldGa1pYSnpLU0I3WEc0Z0lIWmhjaUJ3WVhKelpXUWdQU0I3ZlR0Y2JpQWdkbUZ5SUd0bGVUdGNiaUFnZG1GeUlIWmhiRHRjYmlBZ2RtRnlJR2s3WEc1Y2JpQWdhV1lnS0NGb1pXRmtaWEp6S1NCN0lISmxkSFZ5YmlCd1lYSnpaV1E3SUgxY2JseHVJQ0IxZEdsc2N5NW1iM0pGWVdOb0tHaGxZV1JsY25NdWMzQnNhWFFvSjF4Y2JpY3BMQ0JtZFc1amRHbHZiaUJ3WVhKelpYSW9iR2x1WlNrZ2UxeHVJQ0FnSUdrZ1BTQnNhVzVsTG1sdVpHVjRUMllvSnpvbktUdGNiaUFnSUNCclpYa2dQU0IxZEdsc2N5NTBjbWx0S0d4cGJtVXVjM1ZpYzNSeUtEQXNJR2twS1M1MGIweHZkMlZ5UTJGelpTZ3BPMXh1SUNBZ0lIWmhiQ0E5SUhWMGFXeHpMblJ5YVcwb2JHbHVaUzV6ZFdKemRISW9hU0FySURFcEtUdGNibHh1SUNBZ0lHbG1JQ2hyWlhrcElIdGNiaUFnSUNBZ0lHbG1JQ2h3WVhKelpXUmJhMlY1WFNBbUppQnBaMjV2Y21WRWRYQnNhV05oZEdWUFppNXBibVJsZUU5bUtHdGxlU2tnUGowZ01Da2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNDdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBaaUFvYTJWNUlEMDlQU0FuYzJWMExXTnZiMnRwWlNjcElIdGNiaUFnSUNBZ0lDQWdjR0Z5YzJWa1cydGxlVjBnUFNBb2NHRnljMlZrVzJ0bGVWMGdQeUJ3WVhKelpXUmJhMlY1WFNBNklGdGRLUzVqYjI1allYUW9XM1poYkYwcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2NHRnljMlZrVzJ0bGVWMGdQU0J3WVhKelpXUmJhMlY1WFNBL0lIQmhjbk5sWkZ0clpYbGRJQ3NnSnl3Z0p5QXJJSFpoYkNBNklIWmhiRHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUgwcE8xeHVYRzRnSUhKbGRIVnliaUJ3WVhKelpXUTdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNHZLaXBjYmlBcUlGTjViblJoWTNScFl5QnpkV2RoY2lCbWIzSWdhVzUyYjJ0cGJtY2dZU0JtZFc1amRHbHZiaUJoYm1RZ1pYaHdZVzVrYVc1bklHRnVJR0Z5Y21GNUlHWnZjaUJoY21kMWJXVnVkSE11WEc0Z0tseHVJQ29nUTI5dGJXOXVJSFZ6WlNCallYTmxJSGR2ZFd4a0lHSmxJSFJ2SUhWelpTQmdSblZ1WTNScGIyNHVjSEp2ZEc5MGVYQmxMbUZ3Y0d4NVlDNWNiaUFxWEc0Z0tpQWdZR0JnYW5OY2JpQXFJQ0JtZFc1amRHbHZiaUJtS0hnc0lIa3NJSG9wSUh0OVhHNGdLaUFnZG1GeUlHRnlaM01nUFNCYk1Td2dNaXdnTTEwN1hHNGdLaUFnWmk1aGNIQnNlU2h1ZFd4c0xDQmhjbWR6S1R0Y2JpQXFJQ0JnWUdCY2JpQXFYRzRnS2lCWGFYUm9JR0J6Y0hKbFlXUmdJSFJvYVhNZ1pYaGhiWEJzWlNCallXNGdZbVVnY21VdGQzSnBkSFJsYmk1Y2JpQXFYRzRnS2lBZ1lHQmdhbk5jYmlBcUlDQnpjSEpsWVdRb1puVnVZM1JwYjI0b2VDd2dlU3dnZWlrZ2UzMHBLRnN4TENBeUxDQXpYU2s3WEc0Z0tpQWdZR0JnWEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRHZFc1amRHbHZibjBnWTJGc2JHSmhZMnRjYmlBcUlFQnlaWFIxY201eklIdEdkVzVqZEdsdmJuMWNiaUFxTDF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCemNISmxZV1FvWTJGc2JHSmhZMnNwSUh0Y2JpQWdjbVYwZFhKdUlHWjFibU4wYVc5dUlIZHlZWEFvWVhKeUtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdOaGJHeGlZV05yTG1Gd2NHeDVLRzUxYkd3c0lHRnljaWs3WEc0Z0lIMDdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWW1sdVpDQTlJSEpsY1hWcGNtVW9KeTR2YUdWc2NHVnljeTlpYVc1a0p5azdYRzVjYmk4cVoyeHZZbUZzSUhSdlUzUnlhVzVuT25SeWRXVXFMMXh1WEc0dkx5QjFkR2xzY3lCcGN5QmhJR3hwWW5KaGNua2diMllnWjJWdVpYSnBZeUJvWld4d1pYSWdablZ1WTNScGIyNXpJRzV2YmkxemNHVmphV1pwWXlCMGJ5QmhlR2x2YzF4dVhHNTJZWElnZEc5VGRISnBibWNnUFNCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTzF4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdGdUlFRnljbUY1WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJSFpoYkNCVWFHVWdkbUZzZFdVZ2RHOGdkR1Z6ZEZ4dUlDb2dRSEpsZEhWeWJuTWdlMkp2YjJ4bFlXNTlJRlJ5ZFdVZ2FXWWdkbUZzZFdVZ2FYTWdZVzRnUVhKeVlYa3NJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGMwRnljbUY1S0haaGJDa2dlMXh1SUNCeVpYUjFjbTRnZEc5VGRISnBibWN1WTJGc2JDaDJZV3dwSUQwOVBTQW5XMjlpYW1WamRDQkJjbkpoZVYwbk8xeHVmVnh1WEc0dktpcGNiaUFxSUVSbGRHVnliV2x1WlNCcFppQmhJSFpoYkhWbElHbHpJSFZ1WkdWbWFXNWxaRnh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdUMkpxWldOMGZTQjJZV3dnVkdobElIWmhiSFZsSUhSdklIUmxjM1JjYmlBcUlFQnlaWFIxY201eklIdGliMjlzWldGdWZTQlVjblZsSUdsbUlIUm9aU0IyWVd4MVpTQnBjeUIxYm1SbFptbHVaV1FzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMVZ1WkdWbWFXNWxaQ2gyWVd3cElIdGNiaUFnY21WMGRYSnVJSFI1Y0dWdlppQjJZV3dnUFQwOUlDZDFibVJsWm1sdVpXUW5PMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdFZ1FuVm1abVZ5WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJSFpoYkNCVWFHVWdkbUZzZFdVZ2RHOGdkR1Z6ZEZ4dUlDb2dRSEpsZEhWeWJuTWdlMkp2YjJ4bFlXNTlJRlJ5ZFdVZ2FXWWdkbUZzZFdVZ2FYTWdZU0JDZFdabVpYSXNJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGMwSjFabVpsY2loMllXd3BJSHRjYmlBZ2NtVjBkWEp1SUhaaGJDQWhQVDBnYm5Wc2JDQW1KaUFoYVhOVmJtUmxabWx1WldRb2RtRnNLU0FtSmlCMllXd3VZMjl1YzNSeWRXTjBiM0lnSVQwOUlHNTFiR3dnSmlZZ0lXbHpWVzVrWldacGJtVmtLSFpoYkM1amIyNXpkSEoxWTNSdmNpbGNiaUFnSUNBbUppQjBlWEJsYjJZZ2RtRnNMbU52Ym5OMGNuVmpkRzl5TG1selFuVm1abVZ5SUQwOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUhaaGJDNWpiMjV6ZEhKMVkzUnZjaTVwYzBKMVptWmxjaWgyWVd3cE8xeHVmVnh1WEc0dktpcGNiaUFxSUVSbGRHVnliV2x1WlNCcFppQmhJSFpoYkhWbElHbHpJR0Z1SUVGeWNtRjVRblZtWm1WeVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUhaaGJDQlVhR1VnZG1Gc2RXVWdkRzhnZEdWemRGeHVJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUZSeWRXVWdhV1lnZG1Gc2RXVWdhWE1nWVc0Z1FYSnlZWGxDZFdabVpYSXNJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGMwRnljbUY1UW5WbVptVnlLSFpoYkNrZ2UxeHVJQ0J5WlhSMWNtNGdkRzlUZEhKcGJtY3VZMkZzYkNoMllXd3BJRDA5UFNBblcyOWlhbVZqZENCQmNuSmhlVUoxWm1abGNsMG5PMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdFZ1JtOXliVVJoZEdGY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnZG1Gc0lGUm9aU0IyWVd4MVpTQjBieUIwWlhOMFhHNGdLaUJBY21WMGRYSnVjeUI3WW05dmJHVmhibjBnVkhKMVpTQnBaaUIyWVd4MVpTQnBjeUJoYmlCR2IzSnRSR0YwWVN3Z2IzUm9aWEozYVhObElHWmhiSE5sWEc0Z0tpOWNibVoxYm1OMGFXOXVJR2x6Um05eWJVUmhkR0VvZG1Gc0tTQjdYRzRnSUhKbGRIVnliaUFvZEhsd1pXOW1JRVp2Y20xRVlYUmhJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5a2dKaVlnS0haaGJDQnBibk4wWVc1alpXOW1JRVp2Y20xRVlYUmhLVHRjYm4xY2JseHVMeW9xWEc0Z0tpQkVaWFJsY20xcGJtVWdhV1lnWVNCMllXeDFaU0JwY3lCaElIWnBaWGNnYjI0Z1lXNGdRWEp5WVhsQ2RXWm1aWEpjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdkbUZzSUZSb1pTQjJZV3gxWlNCMGJ5QjBaWE4wWEc0Z0tpQkFjbVYwZFhKdWN5QjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjJZV3gxWlNCcGN5QmhJSFpwWlhjZ2IyNGdZVzRnUVhKeVlYbENkV1ptWlhJc0lHOTBhR1Z5ZDJselpTQm1ZV3h6WlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJwYzBGeWNtRjVRblZtWm1WeVZtbGxkeWgyWVd3cElIdGNiaUFnZG1GeUlISmxjM1ZzZER0Y2JpQWdhV1lnS0NoMGVYQmxiMllnUVhKeVlYbENkV1ptWlhJZ0lUMDlJQ2QxYm1SbFptbHVaV1FuS1NBbUppQW9RWEp5WVhsQ2RXWm1aWEl1YVhOV2FXVjNLU2tnZTF4dUlDQWdJSEpsYzNWc2RDQTlJRUZ5Y21GNVFuVm1abVZ5TG1selZtbGxkeWgyWVd3cE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxjM1ZzZENBOUlDaDJZV3dwSUNZbUlDaDJZV3d1WW5WbVptVnlLU0FtSmlBb2RtRnNMbUoxWm1abGNpQnBibk4wWVc1alpXOW1JRUZ5Y21GNVFuVm1abVZ5S1R0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnY21WemRXeDBPMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdFZ1UzUnlhVzVuWEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJSFpoYkNCVWFHVWdkbUZzZFdVZ2RHOGdkR1Z6ZEZ4dUlDb2dRSEpsZEhWeWJuTWdlMkp2YjJ4bFlXNTlJRlJ5ZFdVZ2FXWWdkbUZzZFdVZ2FYTWdZU0JUZEhKcGJtY3NJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGMxTjBjbWx1WnloMllXd3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUIyWVd3Z1BUMDlJQ2R6ZEhKcGJtY25PMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdFZ1RuVnRZbVZ5WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJSFpoYkNCVWFHVWdkbUZzZFdVZ2RHOGdkR1Z6ZEZ4dUlDb2dRSEpsZEhWeWJuTWdlMkp2YjJ4bFlXNTlJRlJ5ZFdVZ2FXWWdkbUZzZFdVZ2FYTWdZU0JPZFcxaVpYSXNJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGMwNTFiV0psY2loMllXd3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUIyWVd3Z1BUMDlJQ2R1ZFcxaVpYSW5PMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdGdUlFOWlhbVZqZEZ4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0IyWVd3Z1ZHaGxJSFpoYkhWbElIUnZJSFJsYzNSY2JpQXFJRUJ5WlhSMWNtNXpJSHRpYjI5c1pXRnVmU0JVY25WbElHbG1JSFpoYkhWbElHbHpJR0Z1SUU5aWFtVmpkQ3dnYjNSb1pYSjNhWE5sSUdaaGJITmxYRzRnS2k5Y2JtWjFibU4wYVc5dUlHbHpUMkpxWldOMEtIWmhiQ2tnZTF4dUlDQnlaWFIxY200Z2RtRnNJQ0U5UFNCdWRXeHNJQ1ltSUhSNWNHVnZaaUIyWVd3Z1BUMDlJQ2R2WW1wbFkzUW5PMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdFZ2NHeGhhVzRnVDJKcVpXTjBYRzRnS2x4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlIWmhiQ0JVYUdVZ2RtRnNkV1VnZEc4Z2RHVnpkRnh1SUNvZ1FISmxkSFZ5YmlCN1ltOXZiR1ZoYm4wZ1ZISjFaU0JwWmlCMllXeDFaU0JwY3lCaElIQnNZV2x1SUU5aWFtVmpkQ3dnYjNSb1pYSjNhWE5sSUdaaGJITmxYRzRnS2k5Y2JtWjFibU4wYVc5dUlHbHpVR3hoYVc1UFltcGxZM1FvZG1Gc0tTQjdYRzRnSUdsbUlDaDBiMU4wY21sdVp5NWpZV3hzS0haaGJDa2dJVDA5SUNkYmIySnFaV04wSUU5aWFtVmpkRjBuS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhCeWIzUnZkSGx3WlNBOUlFOWlhbVZqZEM1blpYUlFjbTkwYjNSNWNHVlBaaWgyWVd3cE8xeHVJQ0J5WlhSMWNtNGdjSEp2ZEc5MGVYQmxJRDA5UFNCdWRXeHNJSHg4SUhCeWIzUnZkSGx3WlNBOVBUMGdUMkpxWldOMExuQnliM1J2ZEhsd1pUdGNibjFjYmx4dUx5b3FYRzRnS2lCRVpYUmxjbTFwYm1VZ2FXWWdZU0IyWVd4MVpTQnBjeUJoSUVSaGRHVmNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2RtRnNJRlJvWlNCMllXeDFaU0IwYnlCMFpYTjBYRzRnS2lCQWNtVjBkWEp1Y3lCN1ltOXZiR1ZoYm4wZ1ZISjFaU0JwWmlCMllXeDFaU0JwY3lCaElFUmhkR1VzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMFJoZEdVb2RtRnNLU0I3WEc0Z0lISmxkSFZ5YmlCMGIxTjBjbWx1Wnk1allXeHNLSFpoYkNrZ1BUMDlJQ2RiYjJKcVpXTjBJRVJoZEdWZEp6dGNibjFjYmx4dUx5b3FYRzRnS2lCRVpYUmxjbTFwYm1VZ2FXWWdZU0IyWVd4MVpTQnBjeUJoSUVacGJHVmNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2RtRnNJRlJvWlNCMllXeDFaU0IwYnlCMFpYTjBYRzRnS2lCQWNtVjBkWEp1Y3lCN1ltOXZiR1ZoYm4wZ1ZISjFaU0JwWmlCMllXeDFaU0JwY3lCaElFWnBiR1VzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMFpwYkdVb2RtRnNLU0I3WEc0Z0lISmxkSFZ5YmlCMGIxTjBjbWx1Wnk1allXeHNLSFpoYkNrZ1BUMDlJQ2RiYjJKcVpXTjBJRVpwYkdWZEp6dGNibjFjYmx4dUx5b3FYRzRnS2lCRVpYUmxjbTFwYm1VZ2FXWWdZU0IyWVd4MVpTQnBjeUJoSUVKc2IySmNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2RtRnNJRlJvWlNCMllXeDFaU0IwYnlCMFpYTjBYRzRnS2lCQWNtVjBkWEp1Y3lCN1ltOXZiR1ZoYm4wZ1ZISjFaU0JwWmlCMllXeDFaU0JwY3lCaElFSnNiMklzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMEpzYjJJb2RtRnNLU0I3WEc0Z0lISmxkSFZ5YmlCMGIxTjBjbWx1Wnk1allXeHNLSFpoYkNrZ1BUMDlJQ2RiYjJKcVpXTjBJRUpzYjJKZEp6dGNibjFjYmx4dUx5b3FYRzRnS2lCRVpYUmxjbTFwYm1VZ2FXWWdZU0IyWVd4MVpTQnBjeUJoSUVaMWJtTjBhVzl1WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJSFpoYkNCVWFHVWdkbUZzZFdVZ2RHOGdkR1Z6ZEZ4dUlDb2dRSEpsZEhWeWJuTWdlMkp2YjJ4bFlXNTlJRlJ5ZFdVZ2FXWWdkbUZzZFdVZ2FYTWdZU0JHZFc1amRHbHZiaXdnYjNSb1pYSjNhWE5sSUdaaGJITmxYRzRnS2k5Y2JtWjFibU4wYVc5dUlHbHpSblZ1WTNScGIyNG9kbUZzS1NCN1hHNGdJSEpsZEhWeWJpQjBiMU4wY21sdVp5NWpZV3hzS0haaGJDa2dQVDA5SUNkYmIySnFaV04wSUVaMWJtTjBhVzl1WFNjN1hHNTlYRzVjYmk4cUtseHVJQ29nUkdWMFpYSnRhVzVsSUdsbUlHRWdkbUZzZFdVZ2FYTWdZU0JUZEhKbFlXMWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2RtRnNJRlJvWlNCMllXeDFaU0IwYnlCMFpYTjBYRzRnS2lCQWNtVjBkWEp1Y3lCN1ltOXZiR1ZoYm4wZ1ZISjFaU0JwWmlCMllXeDFaU0JwY3lCaElGTjBjbVZoYlN3Z2IzUm9aWEozYVhObElHWmhiSE5sWEc0Z0tpOWNibVoxYm1OMGFXOXVJR2x6VTNSeVpXRnRLSFpoYkNrZ2UxeHVJQ0J5WlhSMWNtNGdhWE5QWW1wbFkzUW9kbUZzS1NBbUppQnBjMFoxYm1OMGFXOXVLSFpoYkM1d2FYQmxLVHRjYm4xY2JseHVMeW9xWEc0Z0tpQkVaWFJsY20xcGJtVWdhV1lnWVNCMllXeDFaU0JwY3lCaElGVlNURk5sWVhKamFGQmhjbUZ0Y3lCdlltcGxZM1JjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdkbUZzSUZSb1pTQjJZV3gxWlNCMGJ5QjBaWE4wWEc0Z0tpQkFjbVYwZFhKdWN5QjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjJZV3gxWlNCcGN5QmhJRlZTVEZObFlYSmphRkJoY21GdGN5QnZZbXBsWTNRc0lHOTBhR1Z5ZDJselpTQm1ZV3h6WlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJwYzFWU1RGTmxZWEpqYUZCaGNtRnRjeWgyWVd3cElIdGNiaUFnY21WMGRYSnVJSFI1Y0dWdlppQlZVa3hUWldGeVkyaFFZWEpoYlhNZ0lUMDlJQ2QxYm1SbFptbHVaV1FuSUNZbUlIWmhiQ0JwYm5OMFlXNWpaVzltSUZWU1RGTmxZWEpqYUZCaGNtRnRjenRjYm4xY2JseHVMeW9xWEc0Z0tpQlVjbWx0SUdWNFkyVnpjeUIzYUdsMFpYTndZV05sSUc5bVppQjBhR1VnWW1WbmFXNXVhVzVuSUdGdVpDQmxibVFnYjJZZ1lTQnpkSEpwYm1kY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTFOMGNtbHVaMzBnYzNSeUlGUm9aU0JUZEhKcGJtY2dkRzhnZEhKcGJWeHVJQ29nUUhKbGRIVnlibk1nZTFOMGNtbHVaMzBnVkdobElGTjBjbWx1WnlCbWNtVmxaQ0J2WmlCbGVHTmxjM01nZDJocGRHVnpjR0ZqWlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUIwY21sdEtITjBjaWtnZTF4dUlDQnlaWFIxY200Z2MzUnlMbkpsY0d4aFkyVW9MMTVjWEhNcUx5d2dKeWNwTG5KbGNHeGhZMlVvTDF4Y2N5b2tMeXdnSnljcE8xeHVmVnh1WEc0dktpcGNiaUFxSUVSbGRHVnliV2x1WlNCcFppQjNaU2R5WlNCeWRXNXVhVzVuSUdsdUlHRWdjM1JoYm1SaGNtUWdZbkp2ZDNObGNpQmxiblpwY205dWJXVnVkRnh1SUNwY2JpQXFJRlJvYVhNZ1lXeHNiM2R6SUdGNGFXOXpJSFJ2SUhKMWJpQnBiaUJoSUhkbFlpQjNiM0pyWlhJc0lHRnVaQ0J5WldGamRDMXVZWFJwZG1VdVhHNGdLaUJDYjNSb0lHVnVkbWx5YjI1dFpXNTBjeUJ6ZFhCd2IzSjBJRmhOVEVoMGRIQlNaWEYxWlhOMExDQmlkWFFnYm05MElHWjFiR3g1SUhOMFlXNWtZWEprSUdkc2IySmhiSE11WEc0Z0tseHVJQ29nZDJWaUlIZHZjbXRsY25NNlhHNGdLaUFnZEhsd1pXOW1JSGRwYm1SdmR5QXRQaUIxYm1SbFptbHVaV1JjYmlBcUlDQjBlWEJsYjJZZ1pHOWpkVzFsYm5RZ0xUNGdkVzVrWldacGJtVmtYRzRnS2x4dUlDb2djbVZoWTNRdGJtRjBhWFpsT2x4dUlDb2dJRzVoZG1sbllYUnZjaTV3Y205a2RXTjBJQzArSUNkU1pXRmpkRTVoZEdsMlpTZGNiaUFxSUc1aGRHbDJaWE5qY21sd2RGeHVJQ29nSUc1aGRtbG5ZWFJ2Y2k1d2NtOWtkV04wSUMwK0lDZE9ZWFJwZG1WVFkzSnBjSFFuSUc5eUlDZE9VeWRjYmlBcUwxeHVablZ1WTNScGIyNGdhWE5UZEdGdVpHRnlaRUp5YjNkelpYSkZibllvS1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnYm1GMmFXZGhkRzl5SUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmlBb2JtRjJhV2RoZEc5eUxuQnliMlIxWTNRZ1BUMDlJQ2RTWldGamRFNWhkR2wyWlNjZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnVZWFpwWjJGMGIzSXVjSEp2WkhWamRDQTlQVDBnSjA1aGRHbDJaVk5qY21sd2RDY2dmSHhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J1WVhacFoyRjBiM0l1Y0hKdlpIVmpkQ0E5UFQwZ0owNVRKeWtwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJSDFjYmlBZ2NtVjBkWEp1SUNoY2JpQWdJQ0IwZVhCbGIyWWdkMmx1Wkc5M0lDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUpseHVJQ0FnSUhSNWNHVnZaaUJrYjJOMWJXVnVkQ0FoUFQwZ0ozVnVaR1ZtYVc1bFpDZGNiaUFnS1R0Y2JuMWNibHh1THlvcVhHNGdLaUJKZEdWeVlYUmxJRzkyWlhJZ1lXNGdRWEp5WVhrZ2IzSWdZVzRnVDJKcVpXTjBJR2x1ZG05cmFXNW5JR0VnWm5WdVkzUnBiMjRnWm05eUlHVmhZMmdnYVhSbGJTNWNiaUFxWEc0Z0tpQkpaaUJnYjJKcVlDQnBjeUJoYmlCQmNuSmhlU0JqWVd4c1ltRmpheUIzYVd4c0lHSmxJR05oYkd4bFpDQndZWE56YVc1blhHNGdLaUIwYUdVZ2RtRnNkV1VzSUdsdVpHVjRMQ0JoYm1RZ1kyOXRjR3hsZEdVZ1lYSnlZWGtnWm05eUlHVmhZMmdnYVhSbGJTNWNiaUFxWEc0Z0tpQkpaaUFuYjJKcUp5QnBjeUJoYmlCUFltcGxZM1FnWTJGc2JHSmhZMnNnZDJsc2JDQmlaU0JqWVd4c1pXUWdjR0Z6YzJsdVoxeHVJQ29nZEdobElIWmhiSFZsTENCclpYa3NJR0Z1WkNCamIyMXdiR1YwWlNCdlltcGxZM1FnWm05eUlHVmhZMmdnY0hKdmNHVnlkSGt1WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjhRWEp5WVhsOUlHOWlhaUJVYUdVZ2IySnFaV04wSUhSdklHbDBaWEpoZEdWY2JpQXFJRUJ3WVhKaGJTQjdSblZ1WTNScGIyNTlJR1p1SUZSb1pTQmpZV3hzWW1GamF5QjBieUJwYm5admEyVWdabTl5SUdWaFkyZ2dhWFJsYlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJtYjNKRllXTm9LRzlpYWl3Z1ptNHBJSHRjYmlBZ0x5OGdSRzl1SjNRZ1ltOTBhR1Z5SUdsbUlHNXZJSFpoYkhWbElIQnliM1pwWkdWa1hHNGdJR2xtSUNodlltb2dQVDA5SUc1MWJHd2dmSHdnZEhsd1pXOW1JRzlpYWlBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0J5WlhSMWNtNDdYRzRnSUgxY2JseHVJQ0F2THlCR2IzSmpaU0JoYmlCaGNuSmhlU0JwWmlCdWIzUWdZV3h5WldGa2VTQnpiMjFsZEdocGJtY2dhWFJsY21GaWJHVmNiaUFnYVdZZ0tIUjVjR1Z2WmlCdlltb2dJVDA5SUNkdlltcGxZM1FuS1NCN1hHNGdJQ0FnTHlwbGMyeHBiblFnYm04dGNHRnlZVzB0Y21WaGMzTnBaMjQ2TUNvdlhHNGdJQ0FnYjJKcUlEMGdXMjlpYWwwN1hHNGdJSDFjYmx4dUlDQnBaaUFvYVhOQmNuSmhlU2h2WW1vcEtTQjdYRzRnSUNBZ0x5OGdTWFJsY21GMFpTQnZkbVZ5SUdGeWNtRjVJSFpoYkhWbGMxeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdMQ0JzSUQwZ2IySnFMbXhsYm1kMGFEc2dhU0E4SUd3N0lHa3JLeWtnZTF4dUlDQWdJQ0FnWm00dVkyRnNiQ2h1ZFd4c0xDQnZZbXBiYVYwc0lHa3NJRzlpYWlrN1hHNGdJQ0FnZlZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUM4dklFbDBaWEpoZEdVZ2IzWmxjaUJ2WW1wbFkzUWdhMlY1YzF4dUlDQWdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQnZZbW9wSUh0Y2JpQWdJQ0FnSUdsbUlDaFBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1TG1OaGJHd29iMkpxTENCclpYa3BLU0I3WEc0Z0lDQWdJQ0FnSUdadUxtTmhiR3dvYm5Wc2JDd2diMkpxVzJ0bGVWMHNJR3RsZVN3Z2IySnFLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUgxY2JuMWNibHh1THlvcVhHNGdLaUJCWTJObGNIUnpJSFpoY21GeVozTWdaWGh3WldOMGFXNW5JR1ZoWTJnZ1lYSm5kVzFsYm5RZ2RHOGdZbVVnWVc0Z2IySnFaV04wTENCMGFHVnVYRzRnS2lCcGJXMTFkR0ZpYkhrZ2JXVnlaMlZ6SUhSb1pTQndjbTl3WlhKMGFXVnpJRzltSUdWaFkyZ2diMkpxWldOMElHRnVaQ0J5WlhSMWNtNXpJSEpsYzNWc2RDNWNiaUFxWEc0Z0tpQlhhR1Z1SUcxMWJIUnBjR3hsSUc5aWFtVmpkSE1nWTI5dWRHRnBiaUIwYUdVZ2MyRnRaU0JyWlhrZ2RHaGxJR3hoZEdWeUlHOWlhbVZqZENCcGJseHVJQ29nZEdobElHRnlaM1Z0Wlc1MGN5QnNhWE4wSUhkcGJHd2dkR0ZyWlNCd2NtVmpaV1JsYm1ObExseHVJQ3BjYmlBcUlFVjRZVzF3YkdVNlhHNGdLbHh1SUNvZ1lHQmdhbk5jYmlBcUlIWmhjaUJ5WlhOMWJIUWdQU0J0WlhKblpTaDdabTl2T2lBeE1qTjlMQ0I3Wm05dk9pQTBOVFo5S1R0Y2JpQXFJR052Ym5OdmJHVXViRzluS0hKbGMzVnNkQzVtYjI4cE95QXZMeUJ2ZFhSd2RYUnpJRFExTmx4dUlDb2dZR0JnWEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJRzlpYWpFZ1QySnFaV04wSUhSdklHMWxjbWRsWEc0Z0tpQkFjbVYwZFhKdWN5QjdUMkpxWldOMGZTQlNaWE4xYkhRZ2IyWWdZV3hzSUcxbGNtZGxJSEJ5YjNCbGNuUnBaWE5jYmlBcUwxeHVablZ1WTNScGIyNGdiV1Z5WjJVb0x5b2diMkpxTVN3Z2IySnFNaXdnYjJKcU15d2dMaTR1SUNvdktTQjdYRzRnSUhaaGNpQnlaWE4xYkhRZ1BTQjdmVHRjYmlBZ1puVnVZM1JwYjI0Z1lYTnphV2R1Vm1Gc2RXVW9kbUZzTENCclpYa3BJSHRjYmlBZ0lDQnBaaUFvYVhOUWJHRnBiazlpYW1WamRDaHlaWE4xYkhSYmEyVjVYU2tnSmlZZ2FYTlFiR0ZwYms5aWFtVmpkQ2gyWVd3cEtTQjdYRzRnSUNBZ0lDQnlaWE4xYkhSYmEyVjVYU0E5SUcxbGNtZGxLSEpsYzNWc2RGdHJaWGxkTENCMllXd3BPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9hWE5RYkdGcGJrOWlhbVZqZENoMllXd3BLU0I3WEc0Z0lDQWdJQ0J5WlhOMWJIUmJhMlY1WFNBOUlHMWxjbWRsS0h0OUxDQjJZV3dwTzF4dUlDQWdJSDBnWld4elpTQnBaaUFvYVhOQmNuSmhlU2gyWVd3cEtTQjdYRzRnSUNBZ0lDQnlaWE4xYkhSYmEyVjVYU0E5SUhaaGJDNXpiR2xqWlNncE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J5WlhOMWJIUmJhMlY1WFNBOUlIWmhiRHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Dd2diQ0E5SUdGeVozVnRaVzUwY3k1c1pXNW5kR2c3SUdrZ1BDQnNPeUJwS3lzcElIdGNiaUFnSUNCbWIzSkZZV05vS0dGeVozVnRaVzUwYzF0cFhTd2dZWE56YVdkdVZtRnNkV1VwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJ5WlhOMWJIUTdYRzU5WEc1Y2JpOHFLbHh1SUNvZ1JYaDBaVzVrY3lCdlltcGxZM1FnWVNCaWVTQnRkWFJoWW14NUlHRmtaR2x1WnlCMGJ5QnBkQ0IwYUdVZ2NISnZjR1Z5ZEdsbGN5QnZaaUJ2WW1wbFkzUWdZaTVjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdZU0JVYUdVZ2IySnFaV04wSUhSdklHSmxJR1Y0ZEdWdVpHVmtYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnWWlCVWFHVWdiMkpxWldOMElIUnZJR052Y0hrZ2NISnZjR1Z5ZEdsbGN5Qm1jbTl0WEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2RHaHBjMEZ5WnlCVWFHVWdiMkpxWldOMElIUnZJR0pwYm1RZ1puVnVZM1JwYjI0Z2RHOWNiaUFxSUVCeVpYUjFjbTRnZTA5aWFtVmpkSDBnVkdobElISmxjM1ZzZEdsdVp5QjJZV3gxWlNCdlppQnZZbXBsWTNRZ1lWeHVJQ292WEc1bWRXNWpkR2x2YmlCbGVIUmxibVFvWVN3Z1lpd2dkR2hwYzBGeVp5a2dlMXh1SUNCbWIzSkZZV05vS0dJc0lHWjFibU4wYVc5dUlHRnpjMmxuYmxaaGJIVmxLSFpoYkN3Z2EyVjVLU0I3WEc0Z0lDQWdhV1lnS0hSb2FYTkJjbWNnSmlZZ2RIbHdaVzltSUhaaGJDQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUNBZ1lWdHJaWGxkSUQwZ1ltbHVaQ2gyWVd3c0lIUm9hWE5CY21jcE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0JoVzJ0bGVWMGdQU0IyWVd3N1hHNGdJQ0FnZlZ4dUlDQjlLVHRjYmlBZ2NtVjBkWEp1SUdFN1hHNTlYRzVjYmk4cUtseHVJQ29nVW1WdGIzWmxJR0o1ZEdVZ2IzSmtaWElnYldGeWEyVnlMaUJVYUdseklHTmhkR05vWlhNZ1JVWWdRa0lnUWtZZ0tIUm9aU0JWVkVZdE9DQkNUMDBwWEc0Z0tseHVJQ29nUUhCaGNtRnRJSHR6ZEhKcGJtZDlJR052Ym5SbGJuUWdkMmwwYUNCQ1QwMWNiaUFxSUVCeVpYUjFjbTRnZTNOMGNtbHVaMzBnWTI5dWRHVnVkQ0IyWVd4MVpTQjNhWFJvYjNWMElFSlBUVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnpkSEpwY0VKUFRTaGpiMjUwWlc1MEtTQjdYRzRnSUdsbUlDaGpiMjUwWlc1MExtTm9ZWEpEYjJSbFFYUW9NQ2tnUFQwOUlEQjRSa1ZHUmlrZ2UxeHVJQ0FnSUdOdmJuUmxiblFnUFNCamIyNTBaVzUwTG5Oc2FXTmxLREVwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJqYjI1MFpXNTBPMXh1ZlZ4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlIdGNiaUFnYVhOQmNuSmhlVG9nYVhOQmNuSmhlU3hjYmlBZ2FYTkJjbkpoZVVKMVptWmxjam9nYVhOQmNuSmhlVUoxWm1abGNpeGNiaUFnYVhOQ2RXWm1aWEk2SUdselFuVm1abVZ5TEZ4dUlDQnBjMFp2Y20xRVlYUmhPaUJwYzBadmNtMUVZWFJoTEZ4dUlDQnBjMEZ5Y21GNVFuVm1abVZ5Vm1sbGR6b2dhWE5CY25KaGVVSjFabVpsY2xacFpYY3NYRzRnSUdselUzUnlhVzVuT2lCcGMxTjBjbWx1Wnl4Y2JpQWdhWE5PZFcxaVpYSTZJR2x6VG5WdFltVnlMRnh1SUNCcGMwOWlhbVZqZERvZ2FYTlBZbXBsWTNRc1hHNGdJR2x6VUd4aGFXNVBZbXBsWTNRNklHbHpVR3hoYVc1UFltcGxZM1FzWEc0Z0lHbHpWVzVrWldacGJtVmtPaUJwYzFWdVpHVm1hVzVsWkN4Y2JpQWdhWE5FWVhSbE9pQnBjMFJoZEdVc1hHNGdJR2x6Um1sc1pUb2dhWE5HYVd4bExGeHVJQ0JwYzBKc2IySTZJR2x6UW14dllpeGNiaUFnYVhOR2RXNWpkR2x2YmpvZ2FYTkdkVzVqZEdsdmJpeGNiaUFnYVhOVGRISmxZVzA2SUdselUzUnlaV0Z0TEZ4dUlDQnBjMVZTVEZObFlYSmphRkJoY21GdGN6b2dhWE5WVWt4VFpXRnlZMmhRWVhKaGJYTXNYRzRnSUdselUzUmhibVJoY21SQ2NtOTNjMlZ5Ulc1Mk9pQnBjMU4wWVc1a1lYSmtRbkp2ZDNObGNrVnVkaXhjYmlBZ1ptOXlSV0ZqYURvZ1ptOXlSV0ZqYUN4Y2JpQWdiV1Z5WjJVNklHMWxjbWRsTEZ4dUlDQmxlSFJsYm1RNklHVjRkR1Z1WkN4Y2JpQWdkSEpwYlRvZ2RISnBiU3hjYmlBZ2MzUnlhWEJDVDAwNklITjBjbWx3UWs5TlhHNTlPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdSMlYwU1c1MGNtbHVjMmxqSUQwZ2NtVnhkV2x5WlNnbloyVjBMV2x1ZEhKcGJuTnBZeWNwTzF4dVhHNTJZWElnWTJGc2JFSnBibVFnUFNCeVpYRjFhWEpsS0NjdUx5Y3BPMXh1WEc1MllYSWdKR2x1WkdWNFQyWWdQU0JqWVd4c1FtbHVaQ2hIWlhSSmJuUnlhVzV6YVdNb0oxTjBjbWx1Wnk1d2NtOTBiM1I1Y0dVdWFXNWtaWGhQWmljcEtUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJqWVd4c1FtOTFibVJKYm5SeWFXNXphV01vYm1GdFpTd2dZV3hzYjNkTmFYTnphVzVuS1NCN1hHNWNkSFpoY2lCcGJuUnlhVzV6YVdNZ1BTQkhaWFJKYm5SeWFXNXphV01vYm1GdFpTd2dJU0ZoYkd4dmQwMXBjM05wYm1jcE8xeHVYSFJwWmlBb2RIbHdaVzltSUdsdWRISnBibk5wWXlBOVBUMGdKMloxYm1OMGFXOXVKeUFtSmlBa2FXNWtaWGhQWmlodVlXMWxMQ0FuTG5CeWIzUnZkSGx3WlM0bktTQStJQzB4S1NCN1hHNWNkRngwY21WMGRYSnVJR05oYkd4Q2FXNWtLR2x1ZEhKcGJuTnBZeWs3WEc1Y2RIMWNibHgwY21WMGRYSnVJR2x1ZEhKcGJuTnBZenRjYm4wN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCaWFXNWtJRDBnY21WeGRXbHlaU2duWm5WdVkzUnBiMjR0WW1sdVpDY3BPMXh1ZG1GeUlFZGxkRWx1ZEhKcGJuTnBZeUE5SUhKbGNYVnBjbVVvSjJkbGRDMXBiblJ5YVc1emFXTW5LVHRjYmx4dWRtRnlJQ1JoY0hCc2VTQTlJRWRsZEVsdWRISnBibk5wWXlnbkpVWjFibU4wYVc5dUxuQnliM1J2ZEhsd1pTNWhjSEJzZVNVbktUdGNiblpoY2lBa1kyRnNiQ0E5SUVkbGRFbHVkSEpwYm5OcFl5Z25KVVoxYm1OMGFXOXVMbkJ5YjNSdmRIbHdaUzVqWVd4c0pTY3BPMXh1ZG1GeUlDUnlaV1pzWldOMFFYQndiSGtnUFNCSFpYUkpiblJ5YVc1emFXTW9KeVZTWldac1pXTjBMbUZ3Y0d4NUpTY3NJSFJ5ZFdVcElIeDhJR0pwYm1RdVkyRnNiQ2drWTJGc2JDd2dKR0Z3Y0d4NUtUdGNibHh1ZG1GeUlDUm5UMUJFSUQwZ1IyVjBTVzUwY21sdWMybGpLQ2NsVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNpVW5MQ0IwY25WbEtUdGNiblpoY2lBa1pHVm1hVzVsVUhKdmNHVnlkSGtnUFNCSFpYUkpiblJ5YVc1emFXTW9KeVZQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrbEp5d2dkSEoxWlNrN1hHNTJZWElnSkcxaGVDQTlJRWRsZEVsdWRISnBibk5wWXlnbkpVMWhkR2d1YldGNEpTY3BPMXh1WEc1cFppQW9KR1JsWm1sdVpWQnliM0JsY25SNUtTQjdYRzVjZEhSeWVTQjdYRzVjZEZ4MEpHUmxabWx1WlZCeWIzQmxjblI1S0h0OUxDQW5ZU2NzSUhzZ2RtRnNkV1U2SURFZ2ZTazdYRzVjZEgwZ1kyRjBZMmdnS0dVcElIdGNibHgwWEhRdkx5QkpSU0E0SUdoaGN5QmhJR0p5YjJ0bGJpQmtaV1pwYm1WUWNtOXdaWEowZVZ4dVhIUmNkQ1JrWldacGJtVlFjbTl3WlhKMGVTQTlJRzUxYkd3N1hHNWNkSDFjYm4xY2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQmpZV3hzUW1sdVpDaHZjbWxuYVc1aGJFWjFibU4wYVc5dUtTQjdYRzVjZEhaaGNpQm1kVzVqSUQwZ0pISmxabXhsWTNSQmNIQnNlU2hpYVc1a0xDQWtZMkZzYkN3Z1lYSm5kVzFsYm5SektUdGNibHgwYVdZZ0tDUm5UMUJFSUNZbUlDUmtaV1pwYm1WUWNtOXdaWEowZVNrZ2UxeHVYSFJjZEhaaGNpQmtaWE5qSUQwZ0pHZFBVRVFvWm5WdVl5d2dKMnhsYm1kMGFDY3BPMXh1WEhSY2RHbG1JQ2hrWlhOakxtTnZibVpwWjNWeVlXSnNaU2tnZTF4dVhIUmNkRngwTHk4Z2IzSnBaMmx1WVd3Z2JHVnVaM1JvTENCd2JIVnpJSFJvWlNCeVpXTmxhWFpsY2l3Z2JXbHVkWE1nWVc1NUlHRmtaR2wwYVc5dVlXd2dZWEpuZFcxbGJuUnpJQ2hoWm5SbGNpQjBhR1VnY21WalpXbDJaWElwWEc1Y2RGeDBYSFFrWkdWbWFXNWxVSEp2Y0dWeWRIa29YRzVjZEZ4MFhIUmNkR1oxYm1Nc1hHNWNkRngwWEhSY2RDZHNaVzVuZEdnbkxGeHVYSFJjZEZ4MFhIUjdJSFpoYkhWbE9pQXhJQ3NnSkcxaGVDZ3dMQ0J2Y21sbmFXNWhiRVoxYm1OMGFXOXVMbXhsYm1kMGFDQXRJQ2hoY21kMWJXVnVkSE11YkdWdVozUm9JQzBnTVNrcElIMWNibHgwWEhSY2RDazdYRzVjZEZ4MGZWeHVYSFI5WEc1Y2RISmxkSFZ5YmlCbWRXNWpPMXh1ZlR0Y2JseHVkbUZ5SUdGd2NHeDVRbWx1WkNBOUlHWjFibU4wYVc5dUlHRndjR3g1UW1sdVpDZ3BJSHRjYmx4MGNtVjBkWEp1SUNSeVpXWnNaV04wUVhCd2JIa29ZbWx1WkN3Z0pHRndjR3g1TENCaGNtZDFiV1Z1ZEhNcE8xeHVmVHRjYmx4dWFXWWdLQ1JrWldacGJtVlFjbTl3WlhKMGVTa2dlMXh1WEhRa1pHVm1hVzVsVUhKdmNHVnlkSGtvYlc5a2RXeGxMbVY0Y0c5eWRITXNJQ2RoY0hCc2VTY3NJSHNnZG1Gc2RXVTZJR0Z3Y0d4NVFtbHVaQ0I5S1R0Y2JuMGdaV3h6WlNCN1hHNWNkRzF2WkhWc1pTNWxlSEJ2Y25SekxtRndjR3g1SUQwZ1lYQndiSGxDYVc1a08xeHVmVnh1SWl3aUx5cG5iRzlpWVd3Z2QybHVaRzkzTENCbmJHOWlZV3dxTDF4dWRtRnlJSFYwYVd3Z1BTQnlaWEYxYVhKbEtGd2lkWFJwYkZ3aUtWeHVkbUZ5SUdGemMyVnlkQ0E5SUhKbGNYVnBjbVVvWENKaGMzTmxjblJjSWlsY2JtWjFibU4wYVc5dUlHNXZkeWdwSUhzZ2NtVjBkWEp1SUc1bGR5QkVZWFJsS0NrdVoyVjBWR2x0WlNncElIMWNibHh1ZG1GeUlITnNhV05sSUQwZ1FYSnlZWGt1Y0hKdmRHOTBlWEJsTG5Oc2FXTmxYRzUyWVhJZ1kyOXVjMjlzWlZ4dWRtRnlJSFJwYldWeklEMGdlMzFjYmx4dWFXWWdLSFI1Y0dWdlppQm5iRzlpWVd3Z0lUMDlJRndpZFc1a1pXWnBibVZrWENJZ0ppWWdaMnh2WW1Gc0xtTnZibk52YkdVcElIdGNiaUFnSUNCamIyNXpiMnhsSUQwZ1oyeHZZbUZzTG1OdmJuTnZiR1ZjYm4wZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUhkcGJtUnZkeUFoUFQwZ1hDSjFibVJsWm1sdVpXUmNJaUFtSmlCM2FXNWtiM2N1WTI5dWMyOXNaU2tnZTF4dUlDQWdJR052Ym5OdmJHVWdQU0IzYVc1a2IzY3VZMjl1YzI5c1pWeHVmU0JsYkhObElIdGNiaUFnSUNCamIyNXpiMnhsSUQwZ2UzMWNibjFjYmx4dWRtRnlJR1oxYm1OMGFXOXVjeUE5SUZ0Y2JpQWdJQ0JiYkc5bkxDQmNJbXh2WjF3aVhTeGNiaUFnSUNCYmFXNW1ieXdnWENKcGJtWnZYQ0pkTEZ4dUlDQWdJRnQzWVhKdUxDQmNJbmRoY201Y0lsMHNYRzRnSUNBZ1cyVnljbTl5TENCY0ltVnljbTl5WENKZExGeHVJQ0FnSUZ0MGFXMWxMQ0JjSW5ScGJXVmNJbDBzWEc0Z0lDQWdXM1JwYldWRmJtUXNJRndpZEdsdFpVVnVaRndpWFN4Y2JpQWdJQ0JiZEhKaFkyVXNJRndpZEhKaFkyVmNJbDBzWEc0Z0lDQWdXMlJwY2l3Z1hDSmthWEpjSWwwc1hHNGdJQ0FnVzJOdmJuTnZiR1ZCYzNObGNuUXNJRndpWVhOelpYSjBYQ0pkWEc1ZFhHNWNibVp2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnWm5WdVkzUnBiMjV6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ2RtRnlJSFIxY0d4bElEMGdablZ1WTNScGIyNXpXMmxkWEc0Z0lDQWdkbUZ5SUdZZ1BTQjBkWEJzWlZzd1hWeHVJQ0FnSUhaaGNpQnVZVzFsSUQwZ2RIVndiR1ZiTVYxY2JseHVJQ0FnSUdsbUlDZ2hZMjl1YzI5c1pWdHVZVzFsWFNrZ2UxeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bFcyNWhiV1ZkSUQwZ1pseHVJQ0FnSUgxY2JuMWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JqYjI1emIyeGxYRzVjYm1aMWJtTjBhVzl1SUd4dlp5Z3BJSHQ5WEc1Y2JtWjFibU4wYVc5dUlHbHVabThvS1NCN1hHNGdJQ0FnWTI5dWMyOXNaUzVzYjJjdVlYQndiSGtvWTI5dWMyOXNaU3dnWVhKbmRXMWxiblJ6S1Z4dWZWeHVYRzVtZFc1amRHbHZiaUIzWVhKdUtDa2dlMXh1SUNBZ0lHTnZibk52YkdVdWJHOW5MbUZ3Y0d4NUtHTnZibk52YkdVc0lHRnlaM1Z0Wlc1MGN5bGNibjFjYmx4dVpuVnVZM1JwYjI0Z1pYSnliM0lvS1NCN1hHNGdJQ0FnWTI5dWMyOXNaUzUzWVhKdUxtRndjR3g1S0dOdmJuTnZiR1VzSUdGeVozVnRaVzUwY3lsY2JuMWNibHh1Wm5WdVkzUnBiMjRnZEdsdFpTaHNZV0psYkNrZ2UxeHVJQ0FnSUhScGJXVnpXMnhoWW1Wc1hTQTlJRzV2ZHlncFhHNTlYRzVjYm1aMWJtTjBhVzl1SUhScGJXVkZibVFvYkdGaVpXd3BJSHRjYmlBZ0lDQjJZWElnZEdsdFpTQTlJSFJwYldWelcyeGhZbVZzWFZ4dUlDQWdJR2xtSUNnaGRHbHRaU2tnZTF4dUlDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvWENKT2J5QnpkV05vSUd4aFltVnNPaUJjSWlBcklHeGhZbVZzS1Z4dUlDQWdJSDFjYmx4dUlDQWdJR1JsYkdWMFpTQjBhVzFsYzF0c1lXSmxiRjFjYmlBZ0lDQjJZWElnWkhWeVlYUnBiMjRnUFNCdWIzY29LU0F0SUhScGJXVmNiaUFnSUNCamIyNXpiMnhsTG14dlp5aHNZV0psYkNBcklGd2lPaUJjSWlBcklHUjFjbUYwYVc5dUlDc2dYQ0p0YzF3aUtWeHVmVnh1WEc1bWRXNWpkR2x2YmlCMGNtRmpaU2dwSUh0Y2JpQWdJQ0IyWVhJZ1pYSnlJRDBnYm1WM0lFVnljbTl5S0NsY2JpQWdJQ0JsY25JdWJtRnRaU0E5SUZ3aVZISmhZMlZjSWx4dUlDQWdJR1Z5Y2k1dFpYTnpZV2RsSUQwZ2RYUnBiQzVtYjNKdFlYUXVZWEJ3Ykhrb2JuVnNiQ3dnWVhKbmRXMWxiblJ6S1Z4dUlDQWdJR052Ym5OdmJHVXVaWEp5YjNJb1pYSnlMbk4wWVdOcktWeHVmVnh1WEc1bWRXNWpkR2x2YmlCa2FYSW9iMkpxWldOMEtTQjdYRzRnSUNBZ1kyOXVjMjlzWlM1c2IyY29kWFJwYkM1cGJuTndaV04wS0c5aWFtVmpkQ2tnS3lCY0lseGNibHdpS1Z4dWZWeHVYRzVtZFc1amRHbHZiaUJqYjI1emIyeGxRWE56WlhKMEtHVjRjSEpsYzNOcGIyNHBJSHRjYmlBZ0lDQnBaaUFvSVdWNGNISmxjM05wYjI0cElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdGeWNpQTlJSE5zYVdObExtTmhiR3dvWVhKbmRXMWxiblJ6TENBeEtWeHVJQ0FnSUNBZ0lDQmhjM05sY25RdWIyc29abUZzYzJVc0lIVjBhV3d1Wm05eWJXRjBMbUZ3Y0d4NUtHNTFiR3dzSUdGeWNpa3BYRzRnSUNBZ2ZWeHVmVnh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdhMlY1Y3lBOUlISmxjWFZwY21Vb0oyOWlhbVZqZEMxclpYbHpKeWs3WEc1MllYSWdhR0Z6VTNsdFltOXNjeUE5SUhSNWNHVnZaaUJUZVcxaWIyd2dQVDA5SUNkbWRXNWpkR2x2YmljZ0ppWWdkSGx3Wlc5bUlGTjViV0p2YkNnblptOXZKeWtnUFQwOUlDZHplVzFpYjJ3bk8xeHVYRzUyWVhJZ2RHOVRkSElnUFNCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTzF4dWRtRnlJR052Ym1OaGRDQTlJRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNWpiMjVqWVhRN1hHNTJZWElnYjNKcFowUmxabWx1WlZCeWIzQmxjblI1SUQwZ1QySnFaV04wTG1SbFptbHVaVkJ5YjNCbGNuUjVPMXh1WEc1MllYSWdhWE5HZFc1amRHbHZiaUE5SUdaMWJtTjBhVzl1SUNobWJpa2dlMXh1WEhSeVpYUjFjbTRnZEhsd1pXOW1JR1p1SUQwOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUhSdlUzUnlMbU5oYkd3b1ptNHBJRDA5UFNBblcyOWlhbVZqZENCR2RXNWpkR2x2Ymwwbk8xeHVmVHRjYmx4dWRtRnlJR0Z5WlZCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y25OVGRYQndiM0owWldRZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc1Y2RIWmhjaUJ2WW1vZ1BTQjdmVHRjYmx4MGRISjVJSHRjYmx4MFhIUnZjbWxuUkdWbWFXNWxVSEp2Y0dWeWRIa29iMkpxTENBbmVDY3NJSHNnWlc1MWJXVnlZV0pzWlRvZ1ptRnNjMlVzSUhaaGJIVmxPaUJ2WW1vZ2ZTazdYRzVjZEZ4MEx5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJtVjRkQzFzYVc1bElHNXZMWFZ1ZFhObFpDMTJZWEp6TENCdWJ5MXlaWE4wY21samRHVmtMWE41Ym5SaGVGeHVYSFJjZEdadmNpQW9kbUZ5SUY4Z2FXNGdiMkpxS1NCN0lDOHZJR3B6WTNNNmFXZHViM0psSUdScGMyRnNiRzkzVlc1MWMyVmtWbUZ5YVdGaWJHVnpYRzVjZEZ4MFhIUnlaWFIxY200Z1ptRnNjMlU3WEc1Y2RGeDBmVnh1WEhSY2RISmxkSFZ5YmlCdlltb3VlQ0E5UFQwZ2IySnFPMXh1WEhSOUlHTmhkR05vSUNobEtTQjdJQzhxSUhSb2FYTWdhWE1nU1VVZ09DNGdLaTljYmx4MFhIUnlaWFIxY200Z1ptRnNjMlU3WEc1Y2RIMWNibjA3WEc1MllYSWdjM1Z3Y0c5eWRITkVaWE5qY21sd2RHOXljeUE5SUc5eWFXZEVaV1pwYm1WUWNtOXdaWEowZVNBbUppQmhjbVZRY205d1pYSjBlVVJsYzJOeWFYQjBiM0p6VTNWd2NHOXlkR1ZrS0NrN1hHNWNiblpoY2lCa1pXWnBibVZRY205d1pYSjBlU0E5SUdaMWJtTjBhVzl1SUNodlltcGxZM1FzSUc1aGJXVXNJSFpoYkhWbExDQndjbVZrYVdOaGRHVXBJSHRjYmx4MGFXWWdLRzVoYldVZ2FXNGdiMkpxWldOMElDWW1JQ2doYVhOR2RXNWpkR2x2Ymlod2NtVmthV05oZEdVcElIeDhJQ0Z3Y21Wa2FXTmhkR1VvS1NrcElIdGNibHgwWEhSeVpYUjFjbTQ3WEc1Y2RIMWNibHgwYVdZZ0tITjFjSEJ2Y25SelJHVnpZM0pwY0hSdmNuTXBJSHRjYmx4MFhIUnZjbWxuUkdWbWFXNWxVSEp2Y0dWeWRIa29iMkpxWldOMExDQnVZVzFsTENCN1hHNWNkRngwWEhSamIyNW1hV2QxY21GaWJHVTZJSFJ5ZFdVc1hHNWNkRngwWEhSbGJuVnRaWEpoWW14bE9pQm1ZV3h6WlN4Y2JseDBYSFJjZEhaaGJIVmxPaUIyWVd4MVpTeGNibHgwWEhSY2RIZHlhWFJoWW14bE9pQjBjblZsWEc1Y2RGeDBmU2s3WEc1Y2RIMGdaV3h6WlNCN1hHNWNkRngwYjJKcVpXTjBXMjVoYldWZElEMGdkbUZzZFdVN1hHNWNkSDFjYm4wN1hHNWNiblpoY2lCa1pXWnBibVZRY205d1pYSjBhV1Z6SUQwZ1puVnVZM1JwYjI0Z0tHOWlhbVZqZEN3Z2JXRndLU0I3WEc1Y2RIWmhjaUJ3Y21Wa2FXTmhkR1Z6SUQwZ1lYSm5kVzFsYm5SekxteGxibWQwYUNBK0lESWdQeUJoY21kMWJXVnVkSE5iTWwwZ09pQjdmVHRjYmx4MGRtRnlJSEJ5YjNCeklEMGdhMlY1Y3lodFlYQXBPMXh1WEhScFppQW9hR0Z6VTNsdFltOXNjeWtnZTF4dVhIUmNkSEJ5YjNCeklEMGdZMjl1WTJGMExtTmhiR3dvY0hKdmNITXNJRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVZONWJXSnZiSE1vYldGd0tTazdYRzVjZEgxY2JseDBabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J3Y205d2N5NXNaVzVuZEdnN0lHa2dLejBnTVNrZ2UxeHVYSFJjZEdSbFptbHVaVkJ5YjNCbGNuUjVLRzlpYW1WamRDd2djSEp2Y0hOYmFWMHNJRzFoY0Z0d2NtOXdjMXRwWFYwc0lIQnlaV1JwWTJGMFpYTmJjSEp2Y0hOYmFWMWRLVHRjYmx4MGZWeHVmVHRjYmx4dVpHVm1hVzVsVUhKdmNHVnlkR2xsY3k1emRYQndiM0owYzBSbGMyTnlhWEIwYjNKeklEMGdJU0Z6ZFhCd2IzSjBjMFJsYzJOeWFYQjBiM0p6TzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHUmxabWx1WlZCeWIzQmxjblJwWlhNN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCSFpYUkpiblJ5YVc1emFXTWdQU0J5WlhGMWFYSmxLQ2RuWlhRdGFXNTBjbWx1YzJsakp5azdYRzVjYm5aaGNpQWtaMDlRUkNBOUlFZGxkRWx1ZEhKcGJuTnBZeWduSlU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVUmxjMk55YVhCMGIzSWxKeWs3WEc1cFppQW9KR2RQVUVRcElIdGNibHgwZEhKNUlIdGNibHgwWEhRa1owOVFSQ2hiWFN3Z0oyeGxibWQwYUNjcE8xeHVYSFI5SUdOaGRHTm9JQ2hsS1NCN1hHNWNkRngwTHk4Z1NVVWdPQ0JvWVhNZ1lTQmljbTlyWlc0Z1owOVFSRnh1WEhSY2RDUm5UMUJFSUQwZ2JuVnNiRHRjYmx4MGZWeHVmVnh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUNSblQxQkVPMXh1SWl3aUx5b3FYRzRnS2lCRGIyUmxJSEpsWm1GamRHOXlaV1FnWm5KdmJTQk5iM3BwYkd4aElFUmxkbVZzYjNCbGNpQk9aWFIzYjNKck9seHVJQ29nYUhSMGNITTZMeTlrWlhabGJHOXdaWEl1Ylc5NmFXeHNZUzV2Y21jdlpXNHRWVk12Wkc5amN5OVhaV0l2U21GMllWTmpjbWx3ZEM5U1pXWmxjbVZ1WTJVdlIyeHZZbUZzWDA5aWFtVmpkSE12VDJKcVpXTjBMMkZ6YzJsbmJseHVJQ292WEc1Y2JpZDFjMlVnYzNSeWFXTjBKenRjYmx4dVpuVnVZM1JwYjI0Z1lYTnphV2R1S0hSaGNtZGxkQ3dnWm1seWMzUlRiM1Z5WTJVcElIdGNiaUFnYVdZZ0tIUmhjbWRsZENBOVBUMGdkVzVrWldacGJtVmtJSHg4SUhSaGNtZGxkQ0E5UFQwZ2JuVnNiQ2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjBOaGJtNXZkQ0JqYjI1MlpYSjBJR1pwY25OMElHRnlaM1Z0Wlc1MElIUnZJRzlpYW1WamRDY3BPMXh1SUNCOVhHNWNiaUFnZG1GeUlIUnZJRDBnVDJKcVpXTjBLSFJoY21kbGRDazdYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXhPeUJwSUR3Z1lYSm5kVzFsYm5SekxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdkbUZ5SUc1bGVIUlRiM1Z5WTJVZ1BTQmhjbWQxYldWdWRITmJhVjA3WEc0Z0lDQWdhV1lnS0c1bGVIUlRiM1Z5WTJVZ1BUMDlJSFZ1WkdWbWFXNWxaQ0I4ZkNCdVpYaDBVMjkxY21ObElEMDlQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNCOVhHNWNiaUFnSUNCMllYSWdhMlY1YzBGeWNtRjVJRDBnVDJKcVpXTjBMbXRsZVhNb1QySnFaV04wS0c1bGVIUlRiM1Z5WTJVcEtUdGNiaUFnSUNCbWIzSWdLSFpoY2lCdVpYaDBTVzVrWlhnZ1BTQXdMQ0JzWlc0Z1BTQnJaWGx6UVhKeVlYa3ViR1Z1WjNSb095QnVaWGgwU1c1a1pYZ2dQQ0JzWlc0N0lHNWxlSFJKYm1SbGVDc3JLU0I3WEc0Z0lDQWdJQ0IyWVhJZ2JtVjRkRXRsZVNBOUlHdGxlWE5CY25KaGVWdHVaWGgwU1c1a1pYaGRPMXh1SUNBZ0lDQWdkbUZ5SUdSbGMyTWdQU0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eUtHNWxlSFJUYjNWeVkyVXNJRzVsZUhSTFpYa3BPMXh1SUNBZ0lDQWdhV1lnS0dSbGMyTWdJVDA5SUhWdVpHVm1hVzVsWkNBbUppQmtaWE5qTG1WdWRXMWxjbUZpYkdVcElIdGNiaUFnSUNBZ0lDQWdkRzliYm1WNGRFdGxlVjBnUFNCdVpYaDBVMjkxY21ObFcyNWxlSFJMWlhsZE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1SUNCeVpYUjFjbTRnZEc4N1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhCdmJIbG1hV3hzS0NrZ2UxeHVJQ0JwWmlBb0lVOWlhbVZqZEM1aGMzTnBaMjRwSUh0Y2JpQWdJQ0JQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1QySnFaV04wTENBbllYTnphV2R1Snl3Z2UxeHVJQ0FnSUNBZ1pXNTFiV1Z5WVdKc1pUb2dabUZzYzJVc1hHNGdJQ0FnSUNCamIyNW1hV2QxY21GaWJHVTZJSFJ5ZFdVc1hHNGdJQ0FnSUNCM2NtbDBZV0pzWlRvZ2RISjFaU3hjYmlBZ0lDQWdJSFpoYkhWbE9pQmhjM05wWjI1Y2JpQWdJQ0I5S1R0Y2JpQWdmVnh1ZlZ4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlIdGNiaUFnWVhOemFXZHVPaUJoYzNOcFoyNHNYRzRnSUhCdmJIbG1hV3hzT2lCd2IyeDVabWxzYkZ4dWZUdGNiaUlzSWk4dklFTnZjSGx5YVdkb2RDQktiM2xsYm5Rc0lFbHVZeTRnWVc1a0lHOTBhR1Z5SUU1dlpHVWdZMjl1ZEhKcFluVjBiM0p6TGx4dUx5OWNiaTh2SUZCbGNtMXBjM05wYjI0Z2FYTWdhR1Z5WldKNUlHZHlZVzUwWldRc0lHWnlaV1VnYjJZZ1kyaGhjbWRsTENCMGJ5QmhibmtnY0dWeWMyOXVJRzlpZEdGcGJtbHVaeUJoWEc0dkx5QmpiM0I1SUc5bUlIUm9hWE1nYzI5bWRIZGhjbVVnWVc1a0lHRnpjMjlqYVdGMFpXUWdaRzlqZFcxbGJuUmhkR2x2YmlCbWFXeGxjeUFvZEdobFhHNHZMeUJjSWxOdlpuUjNZWEpsWENJcExDQjBieUJrWldGc0lHbHVJSFJvWlNCVGIyWjBkMkZ5WlNCM2FYUm9iM1YwSUhKbGMzUnlhV04wYVc5dUxDQnBibU5zZFdScGJtZGNiaTh2SUhkcGRHaHZkWFFnYkdsdGFYUmhkR2x2YmlCMGFHVWdjbWxuYUhSeklIUnZJSFZ6WlN3Z1kyOXdlU3dnYlc5a2FXWjVMQ0J0WlhKblpTd2djSFZpYkdsemFDeGNiaTh2SUdScGMzUnlhV0oxZEdVc0lITjFZbXhwWTJWdWMyVXNJR0Z1WkM5dmNpQnpaV3hzSUdOdmNHbGxjeUJ2WmlCMGFHVWdVMjltZEhkaGNtVXNJR0Z1WkNCMGJ5QndaWEp0YVhSY2JpOHZJSEJsY25OdmJuTWdkRzhnZDJodmJTQjBhR1VnVTI5bWRIZGhjbVVnYVhNZ1puVnlibWx6YUdWa0lIUnZJR1J2SUhOdkxDQnpkV0pxWldOMElIUnZJSFJvWlZ4dUx5OGdabTlzYkc5M2FXNW5JR052Ym1ScGRHbHZibk02WEc0dkwxeHVMeThnVkdobElHRmliM1psSUdOdmNIbHlhV2RvZENCdWIzUnBZMlVnWVc1a0lIUm9hWE1nY0dWeWJXbHpjMmx2YmlCdWIzUnBZMlVnYzJoaGJHd2dZbVVnYVc1amJIVmtaV1JjYmk4dklHbHVJR0ZzYkNCamIzQnBaWE1nYjNJZ2MzVmljM1JoYm5ScFlXd2djRzl5ZEdsdmJuTWdiMllnZEdobElGTnZablIzWVhKbExseHVMeTljYmk4dklGUklSU0JUVDBaVVYwRlNSU0JKVXlCUVVrOVdTVVJGUkNCY0lrRlRJRWxUWENJc0lGZEpWRWhQVlZRZ1YwRlNVa0ZPVkZrZ1QwWWdRVTVaSUV0SlRrUXNJRVZZVUZKRlUxTmNiaTh2SUU5U0lFbE5VRXhKUlVRc0lFbE9RMHhWUkVsT1J5QkNWVlFnVGs5VUlFeEpUVWxVUlVRZ1ZFOGdWRWhGSUZkQlVsSkJUbFJKUlZNZ1QwWmNiaTh2SUUxRlVrTklRVTVVUVVKSlRFbFVXU3dnUmtsVVRrVlRVeUJHVDFJZ1FTQlFRVkpVU1VOVlRFRlNJRkJWVWxCUFUwVWdRVTVFSUU1UFRrbE9SbEpKVGtkRlRVVk9WQzRnU1U1Y2JpOHZJRTVQSUVWV1JVNVVJRk5JUVV4TUlGUklSU0JCVlZSSVQxSlRJRTlTSUVOUFVGbFNTVWRJVkNCSVQweEVSVkpUSUVKRklFeEpRVUpNUlNCR1QxSWdRVTVaSUVOTVFVbE5MRnh1THk4Z1JFRk5RVWRGVXlCUFVpQlBWRWhGVWlCTVNVRkNTVXhKVkZrc0lGZElSVlJJUlZJZ1NVNGdRVTRnUVVOVVNVOU9JRTlHSUVOUFRsUlNRVU5VTENCVVQxSlVJRTlTWEc0dkx5QlBWRWhGVWxkSlUwVXNJRUZTU1ZOSlRrY2dSbEpQVFN3Z1QxVlVJRTlHSUU5U0lFbE9JRU5QVGs1RlExUkpUMDRnVjBsVVNDQlVTRVVnVTA5R1ZGZEJVa1VnVDFJZ1ZFaEZYRzR2THlCVlUwVWdUMUlnVDFSSVJWSWdSRVZCVEVsT1IxTWdTVTRnVkVoRklGTlBSbFJYUVZKRkxseHVYRzRuZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCU0lEMGdkSGx3Wlc5bUlGSmxabXhsWTNRZ1BUMDlJQ2R2WW1wbFkzUW5JRDhnVW1WbWJHVmpkQ0E2SUc1MWJHeGNiblpoY2lCU1pXWnNaV04wUVhCd2JIa2dQU0JTSUNZbUlIUjVjR1Z2WmlCU0xtRndjR3g1SUQwOVBTQW5ablZ1WTNScGIyNG5YRzRnSUQ4Z1VpNWhjSEJzZVZ4dUlDQTZJR1oxYm1OMGFXOXVJRkpsWm14bFkzUkJjSEJzZVNoMFlYSm5aWFFzSUhKbFkyVnBkbVZ5TENCaGNtZHpLU0I3WEc0Z0lDQWdjbVYwZFhKdUlFWjFibU4wYVc5dUxuQnliM1J2ZEhsd1pTNWhjSEJzZVM1allXeHNLSFJoY21kbGRDd2djbVZqWldsMlpYSXNJR0Z5WjNNcE8xeHVJQ0I5WEc1Y2JuWmhjaUJTWldac1pXTjBUM2R1UzJWNWMxeHVhV1lnS0ZJZ0ppWWdkSGx3Wlc5bUlGSXViM2R1UzJWNWN5QTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0JTWldac1pXTjBUM2R1UzJWNWN5QTlJRkl1YjNkdVMyVjVjMXh1ZlNCbGJITmxJR2xtSUNoUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbFRlVzFpYjJ4ektTQjdYRzRnSUZKbFpteGxZM1JQZDI1TFpYbHpJRDBnWm5WdVkzUnBiMjRnVW1WbWJHVmpkRTkzYmt0bGVYTW9kR0Z5WjJWMEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0hSaGNtZGxkQ2xjYmlBZ0lDQWdJQzVqYjI1allYUW9UMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjeWgwWVhKblpYUXBLVHRjYmlBZ2ZUdGNibjBnWld4elpTQjdYRzRnSUZKbFpteGxZM1JQZDI1TFpYbHpJRDBnWm5WdVkzUnBiMjRnVW1WbWJHVmpkRTkzYmt0bGVYTW9kR0Z5WjJWMEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0hSaGNtZGxkQ2s3WEc0Z0lIMDdYRzU5WEc1Y2JtWjFibU4wYVc5dUlGQnliMk5sYzNORmJXbDBWMkZ5Ym1sdVp5aDNZWEp1YVc1bktTQjdYRzRnSUdsbUlDaGpiMjV6YjJ4bElDWW1JR052Ym5OdmJHVXVkMkZ5YmlrZ1kyOXVjMjlzWlM1M1lYSnVLSGRoY201cGJtY3BPMXh1ZlZ4dVhHNTJZWElnVG5WdFltVnlTWE5PWVU0Z1BTQk9kVzFpWlhJdWFYTk9ZVTRnZkh3Z1puVnVZM1JwYjI0Z1RuVnRZbVZ5U1hOT1lVNG9kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJSFpoYkhWbElDRTlQU0IyWVd4MVpUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1JYWmxiblJGYldsMGRHVnlLQ2tnZTF4dUlDQkZkbVZ1ZEVWdGFYUjBaWEl1YVc1cGRDNWpZV3hzS0hSb2FYTXBPMXh1ZlZ4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCRmRtVnVkRVZ0YVhSMFpYSTdYRzV0YjJSMWJHVXVaWGh3YjNKMGN5NXZibU5sSUQwZ2IyNWpaVHRjYmx4dUx5OGdRbUZqYTNkaGNtUnpMV052YlhCaGRDQjNhWFJvSUc1dlpHVWdNQzR4TUM1NFhHNUZkbVZ1ZEVWdGFYUjBaWEl1UlhabGJuUkZiV2wwZEdWeUlEMGdSWFpsYm5SRmJXbDBkR1Z5TzF4dVhHNUZkbVZ1ZEVWdGFYUjBaWEl1Y0hKdmRHOTBlWEJsTGw5bGRtVnVkSE1nUFNCMWJtUmxabWx1WldRN1hHNUZkbVZ1ZEVWdGFYUjBaWEl1Y0hKdmRHOTBlWEJsTGw5bGRtVnVkSE5EYjNWdWRDQTlJREE3WEc1RmRtVnVkRVZ0YVhSMFpYSXVjSEp2ZEc5MGVYQmxMbDl0WVhoTWFYTjBaVzVsY25NZ1BTQjFibVJsWm1sdVpXUTdYRzVjYmk4dklFSjVJR1JsWm1GMWJIUWdSWFpsYm5SRmJXbDBkR1Z5Y3lCM2FXeHNJSEJ5YVc1MElHRWdkMkZ5Ym1sdVp5QnBaaUJ0YjNKbElIUm9ZVzRnTVRBZ2JHbHpkR1Z1WlhKeklHRnlaVnh1THk4Z1lXUmtaV1FnZEc4Z2FYUXVJRlJvYVhNZ2FYTWdZU0IxYzJWbWRXd2daR1ZtWVhWc2RDQjNhR2xqYUNCb1pXeHdjeUJtYVc1a2FXNW5JRzFsYlc5eWVTQnNaV0ZyY3k1Y2JuWmhjaUJrWldaaGRXeDBUV0Y0VEdsemRHVnVaWEp6SUQwZ01UQTdYRzVjYm1aMWJtTjBhVzl1SUdOb1pXTnJUR2x6ZEdWdVpYSW9iR2x6ZEdWdVpYSXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQnNhWE4wWlc1bGNpQWhQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oxUm9aU0JjSW14cGMzUmxibVZ5WENJZ1lYSm5kVzFsYm5RZ2JYVnpkQ0JpWlNCdlppQjBlWEJsSUVaMWJtTjBhVzl1TGlCU1pXTmxhWFpsWkNCMGVYQmxJQ2NnS3lCMGVYQmxiMllnYkdsemRHVnVaWElwTzF4dUlDQjlYRzU5WEc1Y2JrOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBlU2hGZG1WdWRFVnRhWFIwWlhJc0lDZGtaV1poZFd4MFRXRjRUR2x6ZEdWdVpYSnpKeXdnZTF4dUlDQmxiblZ0WlhKaFlteGxPaUIwY25WbExGeHVJQ0JuWlhRNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCa1pXWmhkV3gwVFdGNFRHbHpkR1Z1WlhKek8xeHVJQ0I5TEZ4dUlDQnpaWFE2SUdaMWJtTjBhVzl1S0dGeVp5a2dlMXh1SUNBZ0lHbG1JQ2gwZVhCbGIyWWdZWEpuSUNFOVBTQW5iblZ0WW1WeUp5QjhmQ0JoY21jZ1BDQXdJSHg4SUU1MWJXSmxja2x6VG1GT0tHRnlaeWtwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCU1lXNW5aVVZ5Y205eUtDZFVhR1VnZG1Gc2RXVWdiMllnWENKa1pXWmhkV3gwVFdGNFRHbHpkR1Z1WlhKelhDSWdhWE1nYjNWMElHOW1JSEpoYm1kbExpQkpkQ0J0ZFhOMElHSmxJR0VnYm05dUxXNWxaMkYwYVhabElHNTFiV0psY2k0Z1VtVmpaV2wyWldRZ0p5QXJJR0Z5WnlBcklDY3VKeWs3WEc0Z0lDQWdmVnh1SUNBZ0lHUmxabUYxYkhSTllYaE1hWE4wWlc1bGNuTWdQU0JoY21jN1hHNGdJSDFjYm4wcE8xeHVYRzVGZG1WdWRFVnRhWFIwWlhJdWFXNXBkQ0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVYRzRnSUdsbUlDaDBhR2x6TGw5bGRtVnVkSE1nUFQwOUlIVnVaR1ZtYVc1bFpDQjhmRnh1SUNBZ0lDQWdkR2hwY3k1ZlpYWmxiblJ6SUQwOVBTQlBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvZEdocGN5a3VYMlYyWlc1MGN5a2dlMXh1SUNBZ0lIUm9hWE11WDJWMlpXNTBjeUE5SUU5aWFtVmpkQzVqY21WaGRHVW9iblZzYkNrN1hHNGdJQ0FnZEdocGN5NWZaWFpsYm5SelEyOTFiblFnUFNBd08xeHVJQ0I5WEc1Y2JpQWdkR2hwY3k1ZmJXRjRUR2x6ZEdWdVpYSnpJRDBnZEdocGN5NWZiV0Y0VEdsemRHVnVaWEp6SUh4OElIVnVaR1ZtYVc1bFpEdGNibjA3WEc1Y2JpOHZJRTlpZG1sdmRYTnNlU0J1YjNRZ1lXeHNJRVZ0YVhSMFpYSnpJSE5vYjNWc1pDQmlaU0JzYVcxcGRHVmtJSFJ2SURFd0xpQlVhR2x6SUdaMWJtTjBhVzl1SUdGc2JHOTNjMXh1THk4Z2RHaGhkQ0IwYnlCaVpTQnBibU55WldGelpXUXVJRk5sZENCMGJ5QjZaWEp2SUdadmNpQjFibXhwYldsMFpXUXVYRzVGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExuTmxkRTFoZUV4cGMzUmxibVZ5Y3lBOUlHWjFibU4wYVc5dUlITmxkRTFoZUV4cGMzUmxibVZ5Y3lodUtTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2JpQWhQVDBnSjI1MWJXSmxjaWNnZkh3Z2JpQThJREFnZkh3Z1RuVnRZbVZ5U1hOT1lVNG9iaWtwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVW1GdVoyVkZjbkp2Y2lnblZHaGxJSFpoYkhWbElHOW1JRndpYmx3aUlHbHpJRzkxZENCdlppQnlZVzVuWlM0Z1NYUWdiWFZ6ZENCaVpTQmhJRzV2YmkxdVpXZGhkR2wyWlNCdWRXMWlaWEl1SUZKbFkyVnBkbVZrSUNjZ0t5QnVJQ3NnSnk0bktUdGNiaUFnZlZ4dUlDQjBhR2x6TGw5dFlYaE1hWE4wWlc1bGNuTWdQU0J1TzF4dUlDQnlaWFIxY200Z2RHaHBjenRjYm4wN1hHNWNibVoxYm1OMGFXOXVJRjluWlhSTllYaE1hWE4wWlc1bGNuTW9kR2hoZENrZ2UxeHVJQ0JwWmlBb2RHaGhkQzVmYldGNFRHbHpkR1Z1WlhKeklEMDlQU0IxYm1SbFptbHVaV1FwWEc0Z0lDQWdjbVYwZFhKdUlFVjJaVzUwUlcxcGRIUmxjaTVrWldaaGRXeDBUV0Y0VEdsemRHVnVaWEp6TzF4dUlDQnlaWFIxY200Z2RHaGhkQzVmYldGNFRHbHpkR1Z1WlhKek8xeHVmVnh1WEc1RmRtVnVkRVZ0YVhSMFpYSXVjSEp2ZEc5MGVYQmxMbWRsZEUxaGVFeHBjM1JsYm1WeWN5QTlJR1oxYm1OMGFXOXVJR2RsZEUxaGVFeHBjM1JsYm1WeWN5Z3BJSHRjYmlBZ2NtVjBkWEp1SUY5blpYUk5ZWGhNYVhOMFpXNWxjbk1vZEdocGN5azdYRzU5TzF4dVhHNUZkbVZ1ZEVWdGFYUjBaWEl1Y0hKdmRHOTBlWEJsTG1WdGFYUWdQU0JtZFc1amRHbHZiaUJsYldsMEtIUjVjR1VwSUh0Y2JpQWdkbUZ5SUdGeVozTWdQU0JiWFR0Y2JpQWdabTl5SUNoMllYSWdhU0E5SURFN0lHa2dQQ0JoY21kMWJXVnVkSE11YkdWdVozUm9PeUJwS3lzcElHRnlaM011Y0hWemFDaGhjbWQxYldWdWRITmJhVjBwTzF4dUlDQjJZWElnWkc5RmNuSnZjaUE5SUNoMGVYQmxJRDA5UFNBblpYSnliM0luS1R0Y2JseHVJQ0IyWVhJZ1pYWmxiblJ6SUQwZ2RHaHBjeTVmWlhabGJuUnpPMXh1SUNCcFppQW9aWFpsYm5SeklDRTlQU0IxYm1SbFptbHVaV1FwWEc0Z0lDQWdaRzlGY25KdmNpQTlJQ2hrYjBWeWNtOXlJQ1ltSUdWMlpXNTBjeTVsY25KdmNpQTlQVDBnZFc1a1pXWnBibVZrS1R0Y2JpQWdaV3h6WlNCcFppQW9JV1J2UlhKeWIzSXBYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1WEc0Z0lDOHZJRWxtSUhSb1pYSmxJR2x6SUc1dklDZGxjbkp2Y2ljZ1pYWmxiblFnYkdsemRHVnVaWElnZEdobGJpQjBhSEp2ZHk1Y2JpQWdhV1lnS0dSdlJYSnliM0lwSUh0Y2JpQWdJQ0IyWVhJZ1pYSTdYRzRnSUNBZ2FXWWdLR0Z5WjNNdWJHVnVaM1JvSUQ0Z01DbGNiaUFnSUNBZ0lHVnlJRDBnWVhKbmMxc3dYVHRjYmlBZ0lDQnBaaUFvWlhJZ2FXNXpkR0Z1WTJWdlppQkZjbkp2Y2lrZ2UxeHVJQ0FnSUNBZ0x5OGdUbTkwWlRvZ1ZHaGxJR052YlcxbGJuUnpJRzl1SUhSb1pTQmdkR2h5YjNkZ0lHeHBibVZ6SUdGeVpTQnBiblJsYm5ScGIyNWhiQ3dnZEdobGVTQnphRzkzWEc0Z0lDQWdJQ0F2THlCMWNDQnBiaUJPYjJSbEozTWdiM1YwY0hWMElHbG1JSFJvYVhNZ2NtVnpkV3gwY3lCcGJpQmhiaUIxYm1oaGJtUnNaV1FnWlhoalpYQjBhVzl1TGx4dUlDQWdJQ0FnZEdoeWIzY2daWEk3SUM4dklGVnVhR0Z1Wkd4bFpDQW5aWEp5YjNJbklHVjJaVzUwWEc0Z0lDQWdmVnh1SUNBZ0lDOHZJRUYwSUd4bFlYTjBJR2RwZG1VZ2MyOXRaU0JyYVc1a0lHOW1JR052Ym5SbGVIUWdkRzhnZEdobElIVnpaWEpjYmlBZ0lDQjJZWElnWlhKeUlEMGdibVYzSUVWeWNtOXlLQ2RWYm1oaGJtUnNaV1FnWlhKeWIzSXVKeUFySUNobGNpQS9JQ2NnS0NjZ0t5QmxjaTV0WlhOellXZGxJQ3NnSnlrbklEb2dKeWNwS1R0Y2JpQWdJQ0JsY25JdVkyOXVkR1Y0ZENBOUlHVnlPMXh1SUNBZ0lIUm9jbTkzSUdWeWNqc2dMeThnVlc1b1lXNWtiR1ZrSUNkbGNuSnZjaWNnWlhabGJuUmNiaUFnZlZ4dVhHNGdJSFpoY2lCb1lXNWtiR1Z5SUQwZ1pYWmxiblJ6VzNSNWNHVmRPMXh1WEc0Z0lHbG1JQ2hvWVc1a2JHVnlJRDA5UFNCMWJtUmxabWx1WldRcFhHNGdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVYRzRnSUdsbUlDaDBlWEJsYjJZZ2FHRnVaR3hsY2lBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJRkpsWm14bFkzUkJjSEJzZVNob1lXNWtiR1Z5TENCMGFHbHpMQ0JoY21kektUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQjJZWElnYkdWdUlEMGdhR0Z1Wkd4bGNpNXNaVzVuZEdnN1hHNGdJQ0FnZG1GeUlHeHBjM1JsYm1WeWN5QTlJR0Z5Y21GNVEyeHZibVVvYUdGdVpHeGxjaXdnYkdWdUtUdGNiaUFnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHeGxianNnS3l0cEtWeHVJQ0FnSUNBZ1VtVm1iR1ZqZEVGd2NHeDVLR3hwYzNSbGJtVnljMXRwWFN3Z2RHaHBjeXdnWVhKbmN5azdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JuMDdYRzVjYm1aMWJtTjBhVzl1SUY5aFpHUk1hWE4wWlc1bGNpaDBZWEpuWlhRc0lIUjVjR1VzSUd4cGMzUmxibVZ5TENCd2NtVndaVzVrS1NCN1hHNGdJSFpoY2lCdE8xeHVJQ0IyWVhJZ1pYWmxiblJ6TzF4dUlDQjJZWElnWlhocGMzUnBibWM3WEc1Y2JpQWdZMmhsWTJ0TWFYTjBaVzVsY2loc2FYTjBaVzVsY2lrN1hHNWNiaUFnWlhabGJuUnpJRDBnZEdGeVoyVjBMbDlsZG1WdWRITTdYRzRnSUdsbUlDaGxkbVZ1ZEhNZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJR1YyWlc1MGN5QTlJSFJoY21kbGRDNWZaWFpsYm5SeklEMGdUMkpxWldOMExtTnlaV0YwWlNodWRXeHNLVHRjYmlBZ0lDQjBZWEpuWlhRdVgyVjJaVzUwYzBOdmRXNTBJRDBnTUR0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNBdkx5QlVieUJoZG05cFpDQnlaV04xY25OcGIyNGdhVzRnZEdobElHTmhjMlVnZEdoaGRDQjBlWEJsSUQwOVBTQmNJbTVsZDB4cGMzUmxibVZ5WENJaElFSmxabTl5WlZ4dUlDQWdJQzh2SUdGa1pHbHVaeUJwZENCMGJ5QjBhR1VnYkdsemRHVnVaWEp6TENCbWFYSnpkQ0JsYldsMElGd2libVYzVEdsemRHVnVaWEpjSWk1Y2JpQWdJQ0JwWmlBb1pYWmxiblJ6TG01bGQweHBjM1JsYm1WeUlDRTlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0FnSUhSaGNtZGxkQzVsYldsMEtDZHVaWGRNYVhOMFpXNWxjaWNzSUhSNWNHVXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JzYVhOMFpXNWxjaTVzYVhOMFpXNWxjaUEvSUd4cGMzUmxibVZ5TG14cGMzUmxibVZ5SURvZ2JHbHpkR1Z1WlhJcE8xeHVYRzRnSUNBZ0lDQXZMeUJTWlMxaGMzTnBaMjRnWUdWMlpXNTBjMkFnWW1WallYVnpaU0JoSUc1bGQweHBjM1JsYm1WeUlHaGhibVJzWlhJZ1kyOTFiR1FnYUdGMlpTQmpZWFZ6WldRZ2RHaGxYRzRnSUNBZ0lDQXZMeUIwYUdsekxsOWxkbVZ1ZEhNZ2RHOGdZbVVnWVhOemFXZHVaV1FnZEc4Z1lTQnVaWGNnYjJKcVpXTjBYRzRnSUNBZ0lDQmxkbVZ1ZEhNZ1BTQjBZWEpuWlhRdVgyVjJaVzUwY3p0Y2JpQWdJQ0I5WEc0Z0lDQWdaWGhwYzNScGJtY2dQU0JsZG1WdWRITmJkSGx3WlYwN1hHNGdJSDFjYmx4dUlDQnBaaUFvWlhocGMzUnBibWNnUFQwOUlIVnVaR1ZtYVc1bFpDa2dlMXh1SUNBZ0lDOHZJRTl3ZEdsdGFYcGxJSFJvWlNCallYTmxJRzltSUc5dVpTQnNhWE4wWlc1bGNpNGdSRzl1SjNRZ2JtVmxaQ0IwYUdVZ1pYaDBjbUVnWVhKeVlYa2diMkpxWldOMExseHVJQ0FnSUdWNGFYTjBhVzVuSUQwZ1pYWmxiblJ6VzNSNWNHVmRJRDBnYkdsemRHVnVaWEk3WEc0Z0lDQWdLeXQwWVhKblpYUXVYMlYyWlc1MGMwTnZkVzUwTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdsbUlDaDBlWEJsYjJZZ1pYaHBjM1JwYm1jZ1BUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUM4dklFRmtaR2x1WnlCMGFHVWdjMlZqYjI1a0lHVnNaVzFsYm5Rc0lHNWxaV1FnZEc4Z1kyaGhibWRsSUhSdklHRnljbUY1TGx4dUlDQWdJQ0FnWlhocGMzUnBibWNnUFNCbGRtVnVkSE5iZEhsd1pWMGdQVnh1SUNBZ0lDQWdJQ0J3Y21Wd1pXNWtJRDhnVzJ4cGMzUmxibVZ5TENCbGVHbHpkR2x1WjEwZ09pQmJaWGhwYzNScGJtY3NJR3hwYzNSbGJtVnlYVHRjYmlBZ0lDQWdJQzh2SUVsbUlIZGxKM1psSUdGc2NtVmhaSGtnWjI5MElHRnVJR0Z5Y21GNUxDQnFkWE4wSUdGd2NHVnVaQzVjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLSEJ5WlhCbGJtUXBJSHRjYmlBZ0lDQWdJR1Y0YVhOMGFXNW5MblZ1YzJocFpuUW9iR2x6ZEdWdVpYSXBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCbGVHbHpkR2x1Wnk1d2RYTm9LR3hwYzNSbGJtVnlLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJEYUdWamF5Qm1iM0lnYkdsemRHVnVaWElnYkdWaGExeHVJQ0FnSUcwZ1BTQmZaMlYwVFdGNFRHbHpkR1Z1WlhKektIUmhjbWRsZENrN1hHNGdJQ0FnYVdZZ0tHMGdQaUF3SUNZbUlHVjRhWE4wYVc1bkxteGxibWQwYUNBK0lHMGdKaVlnSVdWNGFYTjBhVzVuTG5kaGNtNWxaQ2tnZTF4dUlDQWdJQ0FnWlhocGMzUnBibWN1ZDJGeWJtVmtJRDBnZEhKMVpUdGNiaUFnSUNBZ0lDOHZJRTV2SUdWeWNtOXlJR052WkdVZ1ptOXlJSFJvYVhNZ2MybHVZMlVnYVhRZ2FYTWdZU0JYWVhKdWFXNW5YRzRnSUNBZ0lDQXZMeUJsYzJ4cGJuUXRaR2x6WVdKc1pTMXVaWGgwTFd4cGJtVWdibTh0Y21WemRISnBZM1JsWkMxemVXNTBZWGhjYmlBZ0lDQWdJSFpoY2lCM0lEMGdibVYzSUVWeWNtOXlLQ2RRYjNOemFXSnNaU0JGZG1WdWRFVnRhWFIwWlhJZ2JXVnRiM0o1SUd4bFlXc2daR1YwWldOMFpXUXVJQ2NnSzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbGVHbHpkR2x1Wnk1c1pXNW5kR2dnS3lBbklDY2dLeUJUZEhKcGJtY29kSGx3WlNrZ0t5QW5JR3hwYzNSbGJtVnljeUFuSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0oyRmtaR1ZrTGlCVmMyVWdaVzFwZEhSbGNpNXpaWFJOWVhoTWFYTjBaVzVsY25Nb0tTQjBieUFuSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0oybHVZM0psWVhObElHeHBiV2wwSnlrN1hHNGdJQ0FnSUNCM0xtNWhiV1VnUFNBblRXRjRUR2x6ZEdWdVpYSnpSWGhqWldWa1pXUlhZWEp1YVc1bkp6dGNiaUFnSUNBZ0lIY3VaVzFwZEhSbGNpQTlJSFJoY21kbGREdGNiaUFnSUNBZ0lIY3VkSGx3WlNBOUlIUjVjR1U3WEc0Z0lDQWdJQ0IzTG1OdmRXNTBJRDBnWlhocGMzUnBibWN1YkdWdVozUm9PMXh1SUNBZ0lDQWdVSEp2WTJWemMwVnRhWFJYWVhKdWFXNW5LSGNwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUIwWVhKblpYUTdYRzU5WEc1Y2JrVjJaVzUwUlcxcGRIUmxjaTV3Y205MGIzUjVjR1V1WVdSa1RHbHpkR1Z1WlhJZ1BTQm1kVzVqZEdsdmJpQmhaR1JNYVhOMFpXNWxjaWgwZVhCbExDQnNhWE4wWlc1bGNpa2dlMXh1SUNCeVpYUjFjbTRnWDJGa1pFeHBjM1JsYm1WeUtIUm9hWE1zSUhSNWNHVXNJR3hwYzNSbGJtVnlMQ0JtWVd4elpTazdYRzU5TzF4dVhHNUZkbVZ1ZEVWdGFYUjBaWEl1Y0hKdmRHOTBlWEJsTG05dUlEMGdSWFpsYm5SRmJXbDBkR1Z5TG5CeWIzUnZkSGx3WlM1aFpHUk1hWE4wWlc1bGNqdGNibHh1UlhabGJuUkZiV2wwZEdWeUxuQnliM1J2ZEhsd1pTNXdjbVZ3Wlc1a1RHbHpkR1Z1WlhJZ1BWeHVJQ0FnSUdaMWJtTjBhVzl1SUhCeVpYQmxibVJNYVhOMFpXNWxjaWgwZVhCbExDQnNhWE4wWlc1bGNpa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlGOWhaR1JNYVhOMFpXNWxjaWgwYUdsekxDQjBlWEJsTENCc2FYTjBaVzVsY2l3Z2RISjFaU2s3WEc0Z0lDQWdmVHRjYmx4dVpuVnVZM1JwYjI0Z2IyNWpaVmR5WVhCd1pYSW9LU0I3WEc0Z0lHbG1JQ2doZEdocGN5NW1hWEpsWkNrZ2UxeHVJQ0FnSUhSb2FYTXVkR0Z5WjJWMExuSmxiVzkyWlV4cGMzUmxibVZ5S0hSb2FYTXVkSGx3WlN3Z2RHaHBjeTUzY21Gd1JtNHBPMXh1SUNBZ0lIUm9hWE11Wm1seVpXUWdQU0IwY25WbE8xeHVJQ0FnSUdsbUlDaGhjbWQxYldWdWRITXViR1Z1WjNSb0lEMDlQU0F3S1Z4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWJHbHpkR1Z1WlhJdVkyRnNiQ2gwYUdsekxuUmhjbWRsZENrN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdWJHbHpkR1Z1WlhJdVlYQndiSGtvZEdocGN5NTBZWEpuWlhRc0lHRnlaM1Z0Wlc1MGN5azdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnWDI5dVkyVlhjbUZ3S0hSaGNtZGxkQ3dnZEhsd1pTd2diR2x6ZEdWdVpYSXBJSHRjYmlBZ2RtRnlJSE4wWVhSbElEMGdleUJtYVhKbFpEb2dabUZzYzJVc0lIZHlZWEJHYmpvZ2RXNWtaV1pwYm1Wa0xDQjBZWEpuWlhRNklIUmhjbWRsZEN3Z2RIbHdaVG9nZEhsd1pTd2diR2x6ZEdWdVpYSTZJR3hwYzNSbGJtVnlJSDA3WEc0Z0lIWmhjaUIzY21Gd2NHVmtJRDBnYjI1alpWZHlZWEJ3WlhJdVltbHVaQ2h6ZEdGMFpTazdYRzRnSUhkeVlYQndaV1F1YkdsemRHVnVaWElnUFNCc2FYTjBaVzVsY2p0Y2JpQWdjM1JoZEdVdWQzSmhjRVp1SUQwZ2QzSmhjSEJsWkR0Y2JpQWdjbVYwZFhKdUlIZHlZWEJ3WldRN1hHNTlYRzVjYmtWMlpXNTBSVzFwZEhSbGNpNXdjbTkwYjNSNWNHVXViMjVqWlNBOUlHWjFibU4wYVc5dUlHOXVZMlVvZEhsd1pTd2diR2x6ZEdWdVpYSXBJSHRjYmlBZ1kyaGxZMnRNYVhOMFpXNWxjaWhzYVhOMFpXNWxjaWs3WEc0Z0lIUm9hWE11YjI0b2RIbHdaU3dnWDI5dVkyVlhjbUZ3S0hSb2FYTXNJSFI1Y0dVc0lHeHBjM1JsYm1WeUtTazdYRzRnSUhKbGRIVnliaUIwYUdsek8xeHVmVHRjYmx4dVJYWmxiblJGYldsMGRHVnlMbkJ5YjNSdmRIbHdaUzV3Y21Wd1pXNWtUMjVqWlV4cGMzUmxibVZ5SUQxY2JpQWdJQ0JtZFc1amRHbHZiaUJ3Y21Wd1pXNWtUMjVqWlV4cGMzUmxibVZ5S0hSNWNHVXNJR3hwYzNSbGJtVnlLU0I3WEc0Z0lDQWdJQ0JqYUdWamEweHBjM1JsYm1WeUtHeHBjM1JsYm1WeUtUdGNiaUFnSUNBZ0lIUm9hWE11Y0hKbGNHVnVaRXhwYzNSbGJtVnlLSFI1Y0dVc0lGOXZibU5sVjNKaGNDaDBhR2x6TENCMGVYQmxMQ0JzYVhOMFpXNWxjaWtwTzF4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnZlR0Y2JseHVMeThnUlcxcGRITWdZU0FuY21WdGIzWmxUR2x6ZEdWdVpYSW5JR1YyWlc1MElHbG1JR0Z1WkNCdmJteDVJR2xtSUhSb1pTQnNhWE4wWlc1bGNpQjNZWE1nY21WdGIzWmxaQzVjYmtWMlpXNTBSVzFwZEhSbGNpNXdjbTkwYjNSNWNHVXVjbVZ0YjNabFRHbHpkR1Z1WlhJZ1BWeHVJQ0FnSUdaMWJtTjBhVzl1SUhKbGJXOTJaVXhwYzNSbGJtVnlLSFI1Y0dVc0lHeHBjM1JsYm1WeUtTQjdYRzRnSUNBZ0lDQjJZWElnYkdsemRDd2daWFpsYm5SekxDQndiM05wZEdsdmJpd2dhU3dnYjNKcFoybHVZV3hNYVhOMFpXNWxjanRjYmx4dUlDQWdJQ0FnWTJobFkydE1hWE4wWlc1bGNpaHNhWE4wWlc1bGNpazdYRzVjYmlBZ0lDQWdJR1YyWlc1MGN5QTlJSFJvYVhNdVgyVjJaVzUwY3p0Y2JpQWdJQ0FnSUdsbUlDaGxkbVZ1ZEhNZ1BUMDlJSFZ1WkdWbWFXNWxaQ2xjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNWNiaUFnSUNBZ0lHeHBjM1FnUFNCbGRtVnVkSE5iZEhsd1pWMDdYRzRnSUNBZ0lDQnBaaUFvYkdsemRDQTlQVDBnZFc1a1pXWnBibVZrS1Z4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN6dGNibHh1SUNBZ0lDQWdhV1lnS0d4cGMzUWdQVDA5SUd4cGMzUmxibVZ5SUh4OElHeHBjM1F1YkdsemRHVnVaWElnUFQwOUlHeHBjM1JsYm1WeUtTQjdYRzRnSUNBZ0lDQWdJR2xtSUNndExYUm9hWE11WDJWMlpXNTBjME52ZFc1MElEMDlQU0F3S1Z4dUlDQWdJQ0FnSUNBZ0lIUm9hWE11WDJWMlpXNTBjeUE5SUU5aWFtVmpkQzVqY21WaGRHVW9iblZzYkNrN1hHNGdJQ0FnSUNBZ0lHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHUmxiR1YwWlNCbGRtVnVkSE5iZEhsd1pWMDdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHVjJaVzUwY3k1eVpXMXZkbVZNYVhOMFpXNWxjaWxjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WlcxcGRDZ25jbVZ0YjNabFRHbHpkR1Z1WlhJbkxDQjBlWEJsTENCc2FYTjBMbXhwYzNSbGJtVnlJSHg4SUd4cGMzUmxibVZ5S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaDBlWEJsYjJZZ2JHbHpkQ0FoUFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lDQWdJQ0J3YjNOcGRHbHZiaUE5SUMweE8xeHVYRzRnSUNBZ0lDQWdJR1p2Y2lBb2FTQTlJR3hwYzNRdWJHVnVaM1JvSUMwZ01Uc2dhU0ErUFNBd095QnBMUzBwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvYkdsemRGdHBYU0E5UFQwZ2JHbHpkR1Z1WlhJZ2ZId2diR2x6ZEZ0cFhTNXNhWE4wWlc1bGNpQTlQVDBnYkdsemRHVnVaWElwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJRzl5YVdkcGJtRnNUR2x6ZEdWdVpYSWdQU0JzYVhOMFcybGRMbXhwYzNSbGJtVnlPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NHOXphWFJwYjI0Z1BTQnBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tIQnZjMmwwYVc5dUlEd2dNQ2xjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN6dGNibHh1SUNBZ0lDQWdJQ0JwWmlBb2NHOXphWFJwYjI0Z1BUMDlJREFwWEc0Z0lDQWdJQ0FnSUNBZ2JHbHpkQzV6YUdsbWRDZ3BPMXh1SUNBZ0lDQWdJQ0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0J6Y0d4cFkyVlBibVVvYkdsemRDd2djRzl6YVhScGIyNHBPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLR3hwYzNRdWJHVnVaM1JvSUQwOVBTQXhLVnh1SUNBZ0lDQWdJQ0FnSUdWMlpXNTBjMXQwZVhCbFhTQTlJR3hwYzNSYk1GMDdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHVjJaVzUwY3k1eVpXMXZkbVZNYVhOMFpXNWxjaUFoUFQwZ2RXNWtaV1pwYm1Wa0tWeHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdVpXMXBkQ2duY21WdGIzWmxUR2x6ZEdWdVpYSW5MQ0IwZVhCbExDQnZjbWxuYVc1aGJFeHBjM1JsYm1WeUlIeDhJR3hwYzNSbGJtVnlLVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnZlR0Y2JseHVSWFpsYm5SRmJXbDBkR1Z5TG5CeWIzUnZkSGx3WlM1dlptWWdQU0JGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExuSmxiVzkyWlV4cGMzUmxibVZ5TzF4dVhHNUZkbVZ1ZEVWdGFYUjBaWEl1Y0hKdmRHOTBlWEJsTG5KbGJXOTJaVUZzYkV4cGMzUmxibVZ5Y3lBOVhHNGdJQ0FnWm5WdVkzUnBiMjRnY21WdGIzWmxRV3hzVEdsemRHVnVaWEp6S0hSNWNHVXBJSHRjYmlBZ0lDQWdJSFpoY2lCc2FYTjBaVzVsY25Nc0lHVjJaVzUwY3l3Z2FUdGNibHh1SUNBZ0lDQWdaWFpsYm5SeklEMGdkR2hwY3k1ZlpYWmxiblJ6TzF4dUlDQWdJQ0FnYVdZZ0tHVjJaVzUwY3lBOVBUMGdkVzVrWldacGJtVmtLVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JseHVJQ0FnSUNBZ0x5OGdibTkwSUd4cGMzUmxibWx1WnlCbWIzSWdjbVZ0YjNabFRHbHpkR1Z1WlhJc0lHNXZJRzVsWldRZ2RHOGdaVzFwZEZ4dUlDQWdJQ0FnYVdZZ0tHVjJaVzUwY3k1eVpXMXZkbVZNYVhOMFpXNWxjaUE5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ0lDQWdJR2xtSUNoaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RHaHBjeTVmWlhabGJuUnpJRDBnVDJKcVpXTjBMbU55WldGMFpTaHVkV3hzS1R0Y2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TGw5bGRtVnVkSE5EYjNWdWRDQTlJREE3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb1pYWmxiblJ6VzNSNWNHVmRJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb0xTMTBhR2x6TGw5bGRtVnVkSE5EYjNWdWRDQTlQVDBnTUNsY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyVjJaVzUwY3lBOUlFOWlhbVZqZEM1amNtVmhkR1VvYm5Wc2JDazdYRzRnSUNBZ0lDQWdJQ0FnWld4elpWeHVJQ0FnSUNBZ0lDQWdJQ0FnWkdWc1pYUmxJR1YyWlc1MGMxdDBlWEJsWFR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjenRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1pXMXBkQ0J5WlcxdmRtVk1hWE4wWlc1bGNpQm1iM0lnWVd4c0lHeHBjM1JsYm1WeWN5QnZiaUJoYkd3Z1pYWmxiblJ6WEc0Z0lDQWdJQ0JwWmlBb1lYSm5kVzFsYm5SekxteGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdhMlY1Y3lBOUlFOWlhbVZqZEM1clpYbHpLR1YyWlc1MGN5azdYRzRnSUNBZ0lDQWdJSFpoY2lCclpYazdYRzRnSUNBZ0lDQWdJR1p2Y2lBb2FTQTlJREE3SUdrZ1BDQnJaWGx6TG14bGJtZDBhRHNnS3l0cEtTQjdYRzRnSUNBZ0lDQWdJQ0FnYTJWNUlEMGdhMlY1YzF0cFhUdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2EyVjVJRDA5UFNBbmNtVnRiM1psVEdsemRHVnVaWEluS1NCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TG5KbGJXOTJaVUZzYkV4cGMzUmxibVZ5Y3loclpYa3BPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjbVZ0YjNabFFXeHNUR2x6ZEdWdVpYSnpLQ2R5WlcxdmRtVk1hWE4wWlc1bGNpY3BPMXh1SUNBZ0lDQWdJQ0IwYUdsekxsOWxkbVZ1ZEhNZ1BTQlBZbXBsWTNRdVkzSmxZWFJsS0c1MWJHd3BPMXh1SUNBZ0lDQWdJQ0IwYUdsekxsOWxkbVZ1ZEhORGIzVnVkQ0E5SURBN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JzYVhOMFpXNWxjbk1nUFNCbGRtVnVkSE5iZEhsd1pWMDdYRzVjYmlBZ0lDQWdJR2xtSUNoMGVYQmxiMllnYkdsemRHVnVaWEp6SUQwOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjbVZ0YjNabFRHbHpkR1Z1WlhJb2RIbHdaU3dnYkdsemRHVnVaWEp6S1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2JHbHpkR1Z1WlhKeklDRTlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdURWxHVHlCdmNtUmxjbHh1SUNBZ0lDQWdJQ0JtYjNJZ0tHa2dQU0JzYVhOMFpXNWxjbk11YkdWdVozUm9JQzBnTVRzZ2FTQStQU0F3T3lCcExTMHBJSHRjYmlBZ0lDQWdJQ0FnSUNCMGFHbHpMbkpsYlc5MlpVeHBjM1JsYm1WeUtIUjVjR1VzSUd4cGMzUmxibVZ5YzF0cFhTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnZlR0Y2JseHVablZ1WTNScGIyNGdYMnhwYzNSbGJtVnljeWgwWVhKblpYUXNJSFI1Y0dVc0lIVnVkM0poY0NrZ2UxeHVJQ0IyWVhJZ1pYWmxiblJ6SUQwZ2RHRnlaMlYwTGw5bGRtVnVkSE03WEc1Y2JpQWdhV1lnS0dWMlpXNTBjeUE5UFQwZ2RXNWtaV1pwYm1Wa0tWeHVJQ0FnSUhKbGRIVnliaUJiWFR0Y2JseHVJQ0IyWVhJZ1pYWnNhWE4wWlc1bGNpQTlJR1YyWlc1MGMxdDBlWEJsWFR0Y2JpQWdhV1lnS0dWMmJHbHpkR1Z1WlhJZ1BUMDlJSFZ1WkdWbWFXNWxaQ2xjYmlBZ0lDQnlaWFIxY200Z1cxMDdYRzVjYmlBZ2FXWWdLSFI1Y0dWdlppQmxkbXhwYzNSbGJtVnlJRDA5UFNBblpuVnVZM1JwYjI0bktWeHVJQ0FnSUhKbGRIVnliaUIxYm5keVlYQWdQeUJiWlhac2FYTjBaVzVsY2k1c2FYTjBaVzVsY2lCOGZDQmxkbXhwYzNSbGJtVnlYU0E2SUZ0bGRteHBjM1JsYm1WeVhUdGNibHh1SUNCeVpYUjFjbTRnZFc1M2NtRndJRDljYmlBZ0lDQjFibmR5WVhCTWFYTjBaVzVsY25Nb1pYWnNhWE4wWlc1bGNpa2dPaUJoY25KaGVVTnNiMjVsS0dWMmJHbHpkR1Z1WlhJc0lHVjJiR2x6ZEdWdVpYSXViR1Z1WjNSb0tUdGNibjFjYmx4dVJYWmxiblJGYldsMGRHVnlMbkJ5YjNSdmRIbHdaUzVzYVhOMFpXNWxjbk1nUFNCbWRXNWpkR2x2YmlCc2FYTjBaVzVsY25Nb2RIbHdaU2tnZTF4dUlDQnlaWFIxY200Z1gyeHBjM1JsYm1WeWN5aDBhR2x6TENCMGVYQmxMQ0IwY25WbEtUdGNibjA3WEc1Y2JrVjJaVzUwUlcxcGRIUmxjaTV3Y205MGIzUjVjR1V1Y21GM1RHbHpkR1Z1WlhKeklEMGdablZ1WTNScGIyNGdjbUYzVEdsemRHVnVaWEp6S0hSNWNHVXBJSHRjYmlBZ2NtVjBkWEp1SUY5c2FYTjBaVzVsY25Nb2RHaHBjeXdnZEhsd1pTd2dabUZzYzJVcE8xeHVmVHRjYmx4dVJYWmxiblJGYldsMGRHVnlMbXhwYzNSbGJtVnlRMjkxYm5RZ1BTQm1kVzVqZEdsdmJpaGxiV2wwZEdWeUxDQjBlWEJsS1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnWlcxcGRIUmxjaTVzYVhOMFpXNWxja052ZFc1MElEMDlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1Z0YVhSMFpYSXViR2x6ZEdWdVpYSkRiM1Z1ZENoMGVYQmxLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0J5WlhSMWNtNGdiR2x6ZEdWdVpYSkRiM1Z1ZEM1allXeHNLR1Z0YVhSMFpYSXNJSFI1Y0dVcE8xeHVJQ0I5WEc1OU8xeHVYRzVGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExteHBjM1JsYm1WeVEyOTFiblFnUFNCc2FYTjBaVzVsY2tOdmRXNTBPMXh1Wm5WdVkzUnBiMjRnYkdsemRHVnVaWEpEYjNWdWRDaDBlWEJsS1NCN1hHNGdJSFpoY2lCbGRtVnVkSE1nUFNCMGFHbHpMbDlsZG1WdWRITTdYRzVjYmlBZ2FXWWdLR1YyWlc1MGN5QWhQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnZG1GeUlHVjJiR2x6ZEdWdVpYSWdQU0JsZG1WdWRITmJkSGx3WlYwN1hHNWNiaUFnSUNCcFppQW9kSGx3Wlc5bUlHVjJiR2x6ZEdWdVpYSWdQVDA5SUNkbWRXNWpkR2x2YmljcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlBeE8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1pYWnNhWE4wWlc1bGNpQWhQVDBnZFc1a1pXWnBibVZrS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWlhac2FYTjBaVzVsY2k1c1pXNW5kR2c3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJREE3WEc1OVhHNWNia1YyWlc1MFJXMXBkSFJsY2k1d2NtOTBiM1I1Y0dVdVpYWmxiblJPWVcxbGN5QTlJR1oxYm1OMGFXOXVJR1YyWlc1MFRtRnRaWE1vS1NCN1hHNGdJSEpsZEhWeWJpQjBhR2x6TGw5bGRtVnVkSE5EYjNWdWRDQStJREFnUHlCU1pXWnNaV04wVDNkdVMyVjVjeWgwYUdsekxsOWxkbVZ1ZEhNcElEb2dXMTA3WEc1OU8xeHVYRzVtZFc1amRHbHZiaUJoY25KaGVVTnNiMjVsS0dGeWNpd2diaWtnZTF4dUlDQjJZWElnWTI5d2VTQTlJRzVsZHlCQmNuSmhlU2h1S1R0Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J1T3lBcksya3BYRzRnSUNBZ1kyOXdlVnRwWFNBOUlHRnljbHRwWFR0Y2JpQWdjbVYwZFhKdUlHTnZjSGs3WEc1OVhHNWNibVoxYm1OMGFXOXVJSE53YkdsalpVOXVaU2hzYVhOMExDQnBibVJsZUNrZ2UxeHVJQ0JtYjNJZ0tEc2dhVzVrWlhnZ0t5QXhJRHdnYkdsemRDNXNaVzVuZEdnN0lHbHVaR1Y0S3lzcFhHNGdJQ0FnYkdsemRGdHBibVJsZUYwZ1BTQnNhWE4wVzJsdVpHVjRJQ3NnTVYwN1hHNGdJR3hwYzNRdWNHOXdLQ2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJSFZ1ZDNKaGNFeHBjM1JsYm1WeWN5aGhjbklwSUh0Y2JpQWdkbUZ5SUhKbGRDQTlJRzVsZHlCQmNuSmhlU2hoY25JdWJHVnVaM1JvS1R0Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J5WlhRdWJHVnVaM1JvT3lBcksya3BJSHRjYmlBZ0lDQnlaWFJiYVYwZ1BTQmhjbkpiYVYwdWJHbHpkR1Z1WlhJZ2ZId2dZWEp5VzJsZE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYUTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHOXVZMlVvWlcxcGRIUmxjaXdnYm1GdFpTa2dlMXh1SUNCeVpYUjFjbTRnYm1WM0lGQnliMjFwYzJVb1puVnVZM1JwYjI0Z0tISmxjMjlzZG1Vc0lISmxhbVZqZENrZ2UxeHVJQ0FnSUdaMWJtTjBhVzl1SUdWeWNtOXlUR2x6ZEdWdVpYSW9aWEp5S1NCN1hHNGdJQ0FnSUNCbGJXbDBkR1Z5TG5KbGJXOTJaVXhwYzNSbGJtVnlLRzVoYldVc0lISmxjMjlzZG1WeUtUdGNiaUFnSUNBZ0lISmxhbVZqZENobGNuSXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHWjFibU4wYVc5dUlISmxjMjlzZG1WeUtDa2dlMXh1SUNBZ0lDQWdhV1lnS0hSNWNHVnZaaUJsYldsMGRHVnlMbkpsYlc5MlpVeHBjM1JsYm1WeUlEMDlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnSUNBZ0lHVnRhWFIwWlhJdWNtVnRiM1psVEdsemRHVnVaWElvSjJWeWNtOXlKeXdnWlhKeWIzSk1hWE4wWlc1bGNpazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnlaWE52YkhabEtGdGRMbk5zYVdObExtTmhiR3dvWVhKbmRXMWxiblJ6S1NrN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUdWMlpXNTBWR0Z5WjJWMFFXZHViM04wYVdOQlpHUk1hWE4wWlc1bGNpaGxiV2wwZEdWeUxDQnVZVzFsTENCeVpYTnZiSFpsY2l3Z2V5QnZibU5sT2lCMGNuVmxJSDBwTzF4dUlDQWdJR2xtSUNodVlXMWxJQ0U5UFNBblpYSnliM0luS1NCN1hHNGdJQ0FnSUNCaFpHUkZjbkp2Y2toaGJtUnNaWEpKWmtWMlpXNTBSVzFwZEhSbGNpaGxiV2wwZEdWeUxDQmxjbkp2Y2t4cGMzUmxibVZ5TENCN0lHOXVZMlU2SUhSeWRXVWdmU2s3WEc0Z0lDQWdmVnh1SUNCOUtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1lXUmtSWEp5YjNKSVlXNWtiR1Z5U1daRmRtVnVkRVZ0YVhSMFpYSW9aVzFwZEhSbGNpd2dhR0Z1Wkd4bGNpd2dabXhoWjNNcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCbGJXbDBkR1Z5TG05dUlEMDlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnWlhabGJuUlVZWEpuWlhSQloyNXZjM1JwWTBGa1pFeHBjM1JsYm1WeUtHVnRhWFIwWlhJc0lDZGxjbkp2Y2ljc0lHaGhibVJzWlhJc0lHWnNZV2R6S1R0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmxkbVZ1ZEZSaGNtZGxkRUZuYm05emRHbGpRV1JrVEdsemRHVnVaWElvWlcxcGRIUmxjaXdnYm1GdFpTd2diR2x6ZEdWdVpYSXNJR1pzWVdkektTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ1pXMXBkSFJsY2k1dmJpQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUdsbUlDaG1iR0ZuY3k1dmJtTmxLU0I3WEc0Z0lDQWdJQ0JsYldsMGRHVnlMbTl1WTJVb2JtRnRaU3dnYkdsemRHVnVaWElwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmxiV2wwZEdWeUxtOXVLRzVoYldVc0lHeHBjM1JsYm1WeUtUdGNiaUFnSUNCOVhHNGdJSDBnWld4elpTQnBaaUFvZEhsd1pXOW1JR1Z0YVhSMFpYSXVZV1JrUlhabGJuUk1hWE4wWlc1bGNpQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUM4dklFVjJaVzUwVkdGeVoyVjBJR1J2WlhNZ2JtOTBJR2hoZG1VZ1lHVnljbTl5WUNCbGRtVnVkQ0J6WlcxaGJuUnBZM01nYkdsclpTQk9iMlJsWEc0Z0lDQWdMeThnUlhabGJuUkZiV2wwZEdWeWN5d2dkMlVnWkc4Z2JtOTBJR3hwYzNSbGJpQm1iM0lnWUdWeWNtOXlZQ0JsZG1WdWRITWdhR1Z5WlM1Y2JpQWdJQ0JsYldsMGRHVnlMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9ibUZ0WlN3Z1puVnVZM1JwYjI0Z2QzSmhjRXhwYzNSbGJtVnlLR0Z5WnlrZ2UxeHVJQ0FnSUNBZ0x5OGdTVVVnWkc5bGN5QnViM1FnYUdGMlpTQmlkV2xzZEdsdUlHQjdJRzl1WTJVNklIUnlkV1VnZldBZ2MzVndjRzl5ZENCemJ5QjNaVnh1SUNBZ0lDQWdMeThnYUdGMlpTQjBieUJrYnlCcGRDQnRZVzUxWVd4c2VTNWNiaUFnSUNBZ0lHbG1JQ2htYkdGbmN5NXZibU5sS1NCN1hHNGdJQ0FnSUNBZ0lHVnRhWFIwWlhJdWNtVnRiM1psUlhabGJuUk1hWE4wWlc1bGNpaHVZVzFsTENCM2NtRndUR2x6ZEdWdVpYSXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdiR2x6ZEdWdVpYSW9ZWEpuS1R0Y2JpQWdJQ0I5S1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1ZIbHdaVVZ5Y205eUtDZFVhR1VnWENKbGJXbDBkR1Z5WENJZ1lYSm5kVzFsYm5RZ2JYVnpkQ0JpWlNCdlppQjBlWEJsSUVWMlpXNTBSVzFwZEhSbGNpNGdVbVZqWldsMlpXUWdkSGx3WlNBbklDc2dkSGx3Wlc5bUlHVnRhWFIwWlhJcE8xeHVJQ0I5WEc1OVhHNGlMQ0pjYm5aaGNpQm9ZWE5QZDI0Z1BTQlBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1TzF4dWRtRnlJSFJ2VTNSeWFXNW5JRDBnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaenRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCbWIzSkZZV05vSUNodlltb3NJR1p1TENCamRIZ3BJSHRjYmlBZ0lDQnBaaUFvZEc5VGRISnBibWN1WTJGc2JDaG1iaWtnSVQwOUlDZGJiMkpxWldOMElFWjFibU4wYVc5dVhTY3BJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnbmFYUmxjbUYwYjNJZ2JYVnpkQ0JpWlNCaElHWjFibU4wYVc5dUp5azdYRzRnSUNBZ2ZWeHVJQ0FnSUhaaGNpQnNJRDBnYjJKcUxteGxibWQwYUR0Y2JpQWdJQ0JwWmlBb2JDQTlQVDBnSzJ3cElIdGNiaUFnSUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHWnVMbU5oYkd3b1kzUjRMQ0J2WW1wYmFWMHNJR2tzSUc5aWFpazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnJJR2x1SUc5aWFpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLR2hoYzA5M2JpNWpZV3hzS0c5aWFpd2dheWtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCbWJpNWpZV3hzS0dOMGVDd2diMkpxVzJ0ZExDQnJMQ0J2WW1vcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dWZUdGNibHh1SWl3aUx5b2daWE5zYVc1MExXVnVkaUJpY205M2MyVnlJQ292WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUhSNWNHVnZaaUJ6Wld4bUlEMDlJQ2R2WW1wbFkzUW5JRDhnYzJWc1ppNUdiM0p0UkdGMFlTQTZJSGRwYm1SdmR5NUdiM0p0UkdGMFlUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1THlvZ1pYTnNhVzUwSUc1dkxXbHVkbUZzYVdRdGRHaHBjem9nTVNBcUwxeHVYRzUyWVhJZ1JWSlNUMUpmVFVWVFUwRkhSU0E5SUNkR2RXNWpkR2x2Ymk1d2NtOTBiM1I1Y0dVdVltbHVaQ0JqWVd4c1pXUWdiMjRnYVc1amIyMXdZWFJwWW14bElDYzdYRzUyWVhJZ2MyeHBZMlVnUFNCQmNuSmhlUzV3Y205MGIzUjVjR1V1YzJ4cFkyVTdYRzUyWVhJZ2RHOVRkSElnUFNCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTzF4dWRtRnlJR1oxYm1OVWVYQmxJRDBnSjF0dlltcGxZM1FnUm5WdVkzUnBiMjVkSnp0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQmlhVzVrS0hSb1lYUXBJSHRjYmlBZ0lDQjJZWElnZEdGeVoyVjBJRDBnZEdocGN6dGNiaUFnSUNCcFppQW9kSGx3Wlc5bUlIUmhjbWRsZENBaFBUMGdKMloxYm1OMGFXOXVKeUI4ZkNCMGIxTjBjaTVqWVd4c0tIUmhjbWRsZENrZ0lUMDlJR1oxYm1OVWVYQmxLU0I3WEc0Z0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb1JWSlNUMUpmVFVWVFUwRkhSU0FySUhSaGNtZGxkQ2s3WEc0Z0lDQWdmVnh1SUNBZ0lIWmhjaUJoY21keklEMGdjMnhwWTJVdVkyRnNiQ2hoY21kMWJXVnVkSE1zSURFcE8xeHVYRzRnSUNBZ2RtRnlJR0p2ZFc1a08xeHVJQ0FnSUhaaGNpQmlhVzVrWlhJZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBhR2x6SUdsdWMzUmhibU5sYjJZZ1ltOTFibVFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCeVpYTjFiSFFnUFNCMFlYSm5aWFF1WVhCd2JIa29YRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkR2hwY3l4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCaGNtZHpMbU52Ym1OaGRDaHpiR2xqWlM1allXeHNLR0Z5WjNWdFpXNTBjeWtwWEc0Z0lDQWdJQ0FnSUNBZ0lDQXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLRTlpYW1WamRDaHlaWE4xYkhRcElEMDlQU0J5WlhOMWJIUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdjbVZ6ZFd4ME8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE03WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHRnlaMlYwTG1Gd2NHeDVLRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvWVhRc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1lYSm5jeTVqYjI1allYUW9jMnhwWTJVdVkyRnNiQ2hoY21kMWJXVnVkSE1wS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJSDA3WEc1Y2JpQWdJQ0IyWVhJZ1ltOTFibVJNWlc1bmRHZ2dQU0JOWVhSb0xtMWhlQ2d3TENCMFlYSm5aWFF1YkdWdVozUm9JQzBnWVhKbmN5NXNaVzVuZEdncE8xeHVJQ0FnSUhaaGNpQmliM1Z1WkVGeVozTWdQU0JiWFR0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdKdmRXNWtUR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ1ltOTFibVJCY21kekxuQjFjMmdvSnlRbklDc2dhU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdZbTkxYm1RZ1BTQkdkVzVqZEdsdmJpZ25ZbWx1WkdWeUp5d2dKM0psZEhWeWJpQm1kVzVqZEdsdmJpQW9KeUFySUdKdmRXNWtRWEpuY3k1cWIybHVLQ2NzSnlrZ0t5QW5LWHNnY21WMGRYSnVJR0pwYm1SbGNpNWhjSEJzZVNoMGFHbHpMR0Z5WjNWdFpXNTBjeWs3SUgwbktTaGlhVzVrWlhJcE8xeHVYRzRnSUNBZ2FXWWdLSFJoY21kbGRDNXdjbTkwYjNSNWNHVXBJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlFVnRjSFI1SUQwZ1puVnVZM1JwYjI0Z1JXMXdkSGtvS1NCN2ZUdGNiaUFnSUNBZ0lDQWdSVzF3ZEhrdWNISnZkRzkwZVhCbElEMGdkR0Z5WjJWMExuQnliM1J2ZEhsd1pUdGNiaUFnSUNBZ0lDQWdZbTkxYm1RdWNISnZkRzkwZVhCbElEMGdibVYzSUVWdGNIUjVLQ2s3WEc0Z0lDQWdJQ0FnSUVWdGNIUjVMbkJ5YjNSdmRIbHdaU0E5SUc1MWJHdzdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUdKdmRXNWtPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVkbUZ5SUdsdGNHeGxiV1Z1ZEdGMGFXOXVJRDBnY21WeGRXbHlaU2duTGk5cGJYQnNaVzFsYm5SaGRHbHZiaWNwTzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlFWjFibU4wYVc5dUxuQnliM1J2ZEhsd1pTNWlhVzVrSUh4OElHbHRjR3hsYldWdWRHRjBhVzl1TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnZFc1a1pXWnBibVZrTzF4dVhHNTJZWElnSkZONWJuUmhlRVZ5Y205eUlEMGdVM2x1ZEdGNFJYSnliM0k3WEc1MllYSWdKRVoxYm1OMGFXOXVJRDBnUm5WdVkzUnBiMjQ3WEc1MllYSWdKRlI1Y0dWRmNuSnZjaUE5SUZSNWNHVkZjbkp2Y2p0Y2JseHVMeThnWlhOc2FXNTBMV1JwYzJGaWJHVXRibVY0ZEMxc2FXNWxJR052Ym5OcGMzUmxiblF0Y21WMGRYSnVYRzUyWVhJZ1oyVjBSWFpoYkd4bFpFTnZibk4wY25WamRHOXlJRDBnWm5WdVkzUnBiMjRnS0dWNGNISmxjM05wYjI1VGVXNTBZWGdwSUh0Y2JseDBkSEo1SUh0Y2JseDBYSFJ5WlhSMWNtNGdKRVoxYm1OMGFXOXVLQ2RjSW5WelpTQnpkSEpwWTNSY0lqc2djbVYwZFhKdUlDZ25JQ3NnWlhod2NtVnpjMmx2YmxONWJuUmhlQ0FySUNjcExtTnZibk4wY25WamRHOXlPeWNwS0NrN1hHNWNkSDBnWTJGMFkyZ2dLR1VwSUh0OVhHNTlPMXh1WEc1MllYSWdKR2RQVUVRZ1BTQlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxFWlhOamNtbHdkRzl5TzF4dWFXWWdLQ1JuVDFCRUtTQjdYRzVjZEhSeWVTQjdYRzVjZEZ4MEpHZFBVRVFvZTMwc0lDY25LVHRjYmx4MGZTQmpZWFJqYUNBb1pTa2dlMXh1WEhSY2RDUm5UMUJFSUQwZ2JuVnNiRHNnTHk4Z2RHaHBjeUJwY3lCSlJTQTRMQ0IzYUdsamFDQm9ZWE1nWVNCaWNtOXJaVzRnWjA5UVJGeHVYSFI5WEc1OVhHNWNiblpoY2lCMGFISnZkMVI1Y0dWRmNuSnZjaUE5SUdaMWJtTjBhVzl1SUNncElIdGNibHgwZEdoeWIzY2dibVYzSUNSVWVYQmxSWEp5YjNJb0tUdGNibjA3WEc1MllYSWdWR2h5YjNkVWVYQmxSWEp5YjNJZ1BTQWtaMDlRUkZ4dVhIUS9JQ2htZFc1amRHbHZiaUFvS1NCN1hHNWNkRngwZEhKNUlIdGNibHgwWEhSY2RDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXNWxlSFF0YkdsdVpTQnVieTExYm5WelpXUXRaWGh3Y21WemMybHZibk1zSUc1dkxXTmhiR3hsY2l3Z2JtOHRjbVZ6ZEhKcFkzUmxaQzF3Y205d1pYSjBhV1Z6WEc1Y2RGeDBYSFJoY21kMWJXVnVkSE11WTJGc2JHVmxPeUF2THlCSlJTQTRJR1J2WlhNZ2JtOTBJSFJvY205M0lHaGxjbVZjYmx4MFhIUmNkSEpsZEhWeWJpQjBhSEp2ZDFSNWNHVkZjbkp2Y2p0Y2JseDBYSFI5SUdOaGRHTm9JQ2hqWVd4c1pXVlVhSEp2ZDNNcElIdGNibHgwWEhSY2RIUnllU0I3WEc1Y2RGeDBYSFJjZEM4dklFbEZJRGdnZEdoeWIzZHpJRzl1SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVUmxjMk55YVhCMGIzSW9ZWEpuZFcxbGJuUnpMQ0FuSnlsY2JseDBYSFJjZEZ4MGNtVjBkWEp1SUNSblQxQkVLR0Z5WjNWdFpXNTBjeXdnSjJOaGJHeGxaU2NwTG1kbGREdGNibHgwWEhSY2RIMGdZMkYwWTJnZ0tHZFBVRVIwYUhKdmQzTXBJSHRjYmx4MFhIUmNkRngwY21WMGRYSnVJSFJvY205M1ZIbHdaVVZ5Y205eU8xeHVYSFJjZEZ4MGZWeHVYSFJjZEgxY2JseDBmU2dwS1Z4dVhIUTZJSFJvY205M1ZIbHdaVVZ5Y205eU8xeHVYRzUyWVhJZ2FHRnpVM2x0WW05c2N5QTlJSEpsY1hWcGNtVW9KMmhoY3kxemVXMWliMnh6Snlrb0tUdGNibHh1ZG1GeUlHZGxkRkJ5YjNSdklEMGdUMkpxWldOMExtZGxkRkJ5YjNSdmRIbHdaVTltSUh4OElHWjFibU4wYVc5dUlDaDRLU0I3SUhKbGRIVnliaUI0TGw5ZmNISnZkRzlmWHpzZ2ZUc2dMeThnWlhOc2FXNTBMV1JwYzJGaWJHVXRiR2x1WlNCdWJ5MXdjbTkwYjF4dVhHNTJZWElnYm1WbFpITkZkbUZzSUQwZ2UzMDdYRzVjYm5aaGNpQlVlWEJsWkVGeWNtRjVJRDBnZEhsd1pXOW1JRlZwYm5RNFFYSnlZWGtnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1oyVjBVSEp2ZEc4b1ZXbHVkRGhCY25KaGVTazdYRzVjYm5aaGNpQkpUbFJTU1U1VFNVTlRJRDBnZTF4dVhIUW5KVUZuWjNKbFoyRjBaVVZ5Y205eUpTYzZJSFI1Y0dWdlppQkJaMmR5WldkaGRHVkZjbkp2Y2lBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnUHlCMWJtUmxabWx1WldRZ09pQkJaMmR5WldkaGRHVkZjbkp2Y2l4Y2JseDBKeVZCY25KaGVTVW5PaUJCY25KaGVTeGNibHgwSnlWQmNuSmhlVUoxWm1abGNpVW5PaUIwZVhCbGIyWWdRWEp5WVhsQ2RXWm1aWElnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1FYSnlZWGxDZFdabVpYSXNYRzVjZENjbFFYSnlZWGxKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU1VuT2lCb1lYTlRlVzFpYjJ4eklEOGdaMlYwVUhKdmRHOG9XMTFiVTNsdFltOXNMbWwwWlhKaGRHOXlYU2dwS1NBNklIVnVaR1ZtYVc1bFpDeGNibHgwSnlWQmMzbHVZMFp5YjIxVGVXNWpTWFJsY21GMGIzSlFjbTkwYjNSNWNHVWxKem9nZFc1a1pXWnBibVZrTEZ4dVhIUW5KVUZ6ZVc1alJuVnVZM1JwYjI0bEp6b2dibVZsWkhORmRtRnNMRnh1WEhRbkpVRnplVzVqUjJWdVpYSmhkRzl5SlNjNklHNWxaV1J6UlhaaGJDeGNibHgwSnlWQmMzbHVZMGRsYm1WeVlYUnZja1oxYm1OMGFXOXVKU2M2SUc1bFpXUnpSWFpoYkN4Y2JseDBKeVZCYzNsdVkwbDBaWEpoZEc5eVVISnZkRzkwZVhCbEpTYzZJRzVsWldSelJYWmhiQ3hjYmx4MEp5VkJkRzl0YVdOekpTYzZJSFI1Y0dWdlppQkJkRzl0YVdOeklEMDlQU0FuZFc1a1pXWnBibVZrSnlBL0lIVnVaR1ZtYVc1bFpDQTZJRUYwYjIxcFkzTXNYRzVjZENjbFFtbG5TVzUwSlNjNklIUjVjR1Z2WmlCQ2FXZEpiblFnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1FtbG5TVzUwTEZ4dVhIUW5KVUp2YjJ4bFlXNGxKem9nUW05dmJHVmhiaXhjYmx4MEp5VkVZWFJoVm1sbGR5VW5PaUIwZVhCbGIyWWdSR0YwWVZacFpYY2dQVDA5SUNkMWJtUmxabWx1WldRbklEOGdkVzVrWldacGJtVmtJRG9nUkdGMFlWWnBaWGNzWEc1Y2RDY2xSR0YwWlNVbk9pQkVZWFJsTEZ4dVhIUW5KV1JsWTI5a1pWVlNTU1VuT2lCa1pXTnZaR1ZWVWtrc1hHNWNkQ2NsWkdWamIyUmxWVkpKUTI5dGNHOXVaVzUwSlNjNklHUmxZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDeGNibHgwSnlWbGJtTnZaR1ZWVWtrbEp6b2daVzVqYjJSbFZWSkpMRnh1WEhRbkpXVnVZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDVW5PaUJsYm1OdlpHVlZVa2xEYjIxd2IyNWxiblFzWEc1Y2RDY2xSWEp5YjNJbEp6b2dSWEp5YjNJc1hHNWNkQ2NsWlhaaGJDVW5PaUJsZG1Gc0xDQXZMeUJsYzJ4cGJuUXRaR2x6WVdKc1pTMXNhVzVsSUc1dkxXVjJZV3hjYmx4MEp5VkZkbUZzUlhKeWIzSWxKem9nUlhaaGJFVnljbTl5TEZ4dVhIUW5KVVpzYjJGME16SkJjbkpoZVNVbk9pQjBlWEJsYjJZZ1JteHZZWFF6TWtGeWNtRjVJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSFZ1WkdWbWFXNWxaQ0E2SUVac2IyRjBNekpCY25KaGVTeGNibHgwSnlWR2JHOWhkRFkwUVhKeVlYa2xKem9nZEhsd1pXOW1JRVpzYjJGME5qUkJjbkpoZVNBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnUHlCMWJtUmxabWx1WldRZ09pQkdiRzloZERZMFFYSnlZWGtzWEc1Y2RDY2xSbWx1WVd4cGVtRjBhVzl1VW1WbmFYTjBjbmtsSnpvZ2RIbHdaVzltSUVacGJtRnNhWHBoZEdsdmJsSmxaMmx6ZEhKNUlEMDlQU0FuZFc1a1pXWnBibVZrSnlBL0lIVnVaR1ZtYVc1bFpDQTZJRVpwYm1Gc2FYcGhkR2x2YmxKbFoybHpkSEo1TEZ4dVhIUW5KVVoxYm1OMGFXOXVKU2M2SUNSR2RXNWpkR2x2Yml4Y2JseDBKeVZIWlc1bGNtRjBiM0pHZFc1amRHbHZiaVVuT2lCdVpXVmtjMFYyWVd3c1hHNWNkQ2NsU1c1ME9FRnljbUY1SlNjNklIUjVjR1Z2WmlCSmJuUTRRWEp5WVhrZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2dTVzUwT0VGeWNtRjVMRnh1WEhRbkpVbHVkREUyUVhKeVlYa2xKem9nZEhsd1pXOW1JRWx1ZERFMlFYSnlZWGtnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1NXNTBNVFpCY25KaGVTeGNibHgwSnlWSmJuUXpNa0Z5Y21GNUpTYzZJSFI1Y0dWdlppQkpiblF6TWtGeWNtRjVJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSFZ1WkdWbWFXNWxaQ0E2SUVsdWRETXlRWEp5WVhrc1hHNWNkQ2NsYVhOR2FXNXBkR1VsSnpvZ2FYTkdhVzVwZEdVc1hHNWNkQ2NsYVhOT1lVNGxKem9nYVhOT1lVNHNYRzVjZENjbFNYUmxjbUYwYjNKUWNtOTBiM1I1Y0dVbEp6b2dhR0Z6VTNsdFltOXNjeUEvSUdkbGRGQnliM1J2S0dkbGRGQnliM1J2S0Z0ZFcxTjViV0p2YkM1cGRHVnlZWFJ2Y2wwb0tTa3BJRG9nZFc1a1pXWnBibVZrTEZ4dVhIUW5KVXBUVDA0bEp6b2dkSGx3Wlc5bUlFcFRUMDRnUFQwOUlDZHZZbXBsWTNRbklEOGdTbE5QVGlBNklIVnVaR1ZtYVc1bFpDeGNibHgwSnlWTllYQWxKem9nZEhsd1pXOW1JRTFoY0NBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnUHlCMWJtUmxabWx1WldRZ09pQk5ZWEFzWEc1Y2RDY2xUV0Z3U1hSbGNtRjBiM0pRY205MGIzUjVjR1VsSnpvZ2RIbHdaVzltSUUxaGNDQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ2ZId2dJV2hoYzFONWJXSnZiSE1nUHlCMWJtUmxabWx1WldRZ09pQm5aWFJRY205MGJ5aHVaWGNnVFdGd0tDbGJVM2x0WW05c0xtbDBaWEpoZEc5eVhTZ3BLU3hjYmx4MEp5Vk5ZWFJvSlNjNklFMWhkR2dzWEc1Y2RDY2xUblZ0WW1WeUpTYzZJRTUxYldKbGNpeGNibHgwSnlWUFltcGxZM1FsSnpvZ1QySnFaV04wTEZ4dVhIUW5KWEJoY25ObFJteHZZWFFsSnpvZ2NHRnljMlZHYkc5aGRDeGNibHgwSnlWd1lYSnpaVWx1ZENVbk9pQndZWEp6WlVsdWRDeGNibHgwSnlWUWNtOXRhWE5sSlNjNklIUjVjR1Z2WmlCUWNtOXRhWE5sSUQwOVBTQW5kVzVrWldacGJtVmtKeUEvSUhWdVpHVm1hVzVsWkNBNklGQnliMjFwYzJVc1hHNWNkQ2NsVUhKdmVIa2xKem9nZEhsd1pXOW1JRkJ5YjNoNUlEMDlQU0FuZFc1a1pXWnBibVZrSnlBL0lIVnVaR1ZtYVc1bFpDQTZJRkJ5YjNoNUxGeHVYSFFuSlZKaGJtZGxSWEp5YjNJbEp6b2dVbUZ1WjJWRmNuSnZjaXhjYmx4MEp5VlNaV1psY21WdVkyVkZjbkp2Y2lVbk9pQlNaV1psY21WdVkyVkZjbkp2Y2l4Y2JseDBKeVZTWldac1pXTjBKU2M2SUhSNWNHVnZaaUJTWldac1pXTjBJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSFZ1WkdWbWFXNWxaQ0E2SUZKbFpteGxZM1FzWEc1Y2RDY2xVbVZuUlhod0pTYzZJRkpsWjBWNGNDeGNibHgwSnlWVFpYUWxKem9nZEhsd1pXOW1JRk5sZENBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnUHlCMWJtUmxabWx1WldRZ09pQlRaWFFzWEc1Y2RDY2xVMlYwU1hSbGNtRjBiM0pRY205MGIzUjVjR1VsSnpvZ2RIbHdaVzltSUZObGRDQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ2ZId2dJV2hoYzFONWJXSnZiSE1nUHlCMWJtUmxabWx1WldRZ09pQm5aWFJRY205MGJ5aHVaWGNnVTJWMEtDbGJVM2x0WW05c0xtbDBaWEpoZEc5eVhTZ3BLU3hjYmx4MEp5VlRhR0Z5WldSQmNuSmhlVUoxWm1abGNpVW5PaUIwZVhCbGIyWWdVMmhoY21Wa1FYSnlZWGxDZFdabVpYSWdQVDA5SUNkMWJtUmxabWx1WldRbklEOGdkVzVrWldacGJtVmtJRG9nVTJoaGNtVmtRWEp5WVhsQ2RXWm1aWElzWEc1Y2RDY2xVM1J5YVc1bkpTYzZJRk4wY21sdVp5eGNibHgwSnlWVGRISnBibWRKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU1VuT2lCb1lYTlRlVzFpYjJ4eklEOGdaMlYwVUhKdmRHOG9KeWRiVTNsdFltOXNMbWwwWlhKaGRHOXlYU2dwS1NBNklIVnVaR1ZtYVc1bFpDeGNibHgwSnlWVGVXMWliMndsSnpvZ2FHRnpVM2x0WW05c2N5QS9JRk41YldKdmJDQTZJSFZ1WkdWbWFXNWxaQ3hjYmx4MEp5VlRlVzUwWVhoRmNuSnZjaVVuT2lBa1UzbHVkR0Y0UlhKeWIzSXNYRzVjZENjbFZHaHliM2RVZVhCbFJYSnliM0lsSnpvZ1ZHaHliM2RVZVhCbFJYSnliM0lzWEc1Y2RDY2xWSGx3WldSQmNuSmhlU1VuT2lCVWVYQmxaRUZ5Y21GNUxGeHVYSFFuSlZSNWNHVkZjbkp2Y2lVbk9pQWtWSGx3WlVWeWNtOXlMRnh1WEhRbkpWVnBiblE0UVhKeVlYa2xKem9nZEhsd1pXOW1JRlZwYm5RNFFYSnlZWGtnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1ZXbHVkRGhCY25KaGVTeGNibHgwSnlWVmFXNTBPRU5zWVcxd1pXUkJjbkpoZVNVbk9pQjBlWEJsYjJZZ1ZXbHVkRGhEYkdGdGNHVmtRWEp5WVhrZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2dWV2x1ZERoRGJHRnRjR1ZrUVhKeVlYa3NYRzVjZENjbFZXbHVkREUyUVhKeVlYa2xKem9nZEhsd1pXOW1JRlZwYm5ReE5rRnljbUY1SUQwOVBTQW5kVzVrWldacGJtVmtKeUEvSUhWdVpHVm1hVzVsWkNBNklGVnBiblF4TmtGeWNtRjVMRnh1WEhRbkpWVnBiblF6TWtGeWNtRjVKU2M2SUhSNWNHVnZaaUJWYVc1ME16SkJjbkpoZVNBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnUHlCMWJtUmxabWx1WldRZ09pQlZhVzUwTXpKQmNuSmhlU3hjYmx4MEp5VlZVa2xGY25KdmNpVW5PaUJWVWtsRmNuSnZjaXhjYmx4MEp5VlhaV0ZyVFdGd0pTYzZJSFI1Y0dWdlppQlhaV0ZyVFdGd0lEMDlQU0FuZFc1a1pXWnBibVZrSnlBL0lIVnVaR1ZtYVc1bFpDQTZJRmRsWVd0TllYQXNYRzVjZENjbFYyVmhhMUpsWmlVbk9pQjBlWEJsYjJZZ1YyVmhhMUpsWmlBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnUHlCMWJtUmxabWx1WldRZ09pQlhaV0ZyVW1WbUxGeHVYSFFuSlZkbFlXdFRaWFFsSnpvZ2RIbHdaVzltSUZkbFlXdFRaWFFnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1YyVmhhMU5sZEZ4dWZUdGNibHh1ZG1GeUlHUnZSWFpoYkNBOUlHWjFibU4wYVc5dUlHUnZSWFpoYkNodVlXMWxLU0I3WEc1Y2RIWmhjaUIyWVd4MVpUdGNibHgwYVdZZ0tHNWhiV1VnUFQwOUlDY2xRWE41Ym1OR2RXNWpkR2x2YmlVbktTQjdYRzVjZEZ4MGRtRnNkV1VnUFNCblpYUkZkbUZzYkdWa1EyOXVjM1J5ZFdOMGIzSW9KMkZ6ZVc1aklHWjFibU4wYVc5dUlDZ3BJSHQ5SnlrN1hHNWNkSDBnWld4elpTQnBaaUFvYm1GdFpTQTlQVDBnSnlWSFpXNWxjbUYwYjNKR2RXNWpkR2x2YmlVbktTQjdYRzVjZEZ4MGRtRnNkV1VnUFNCblpYUkZkbUZzYkdWa1EyOXVjM1J5ZFdOMGIzSW9KMloxYm1OMGFXOXVLaUFvS1NCN2ZTY3BPMXh1WEhSOUlHVnNjMlVnYVdZZ0tHNWhiV1VnUFQwOUlDY2xRWE41Ym1OSFpXNWxjbUYwYjNKR2RXNWpkR2x2YmlVbktTQjdYRzVjZEZ4MGRtRnNkV1VnUFNCblpYUkZkbUZzYkdWa1EyOXVjM1J5ZFdOMGIzSW9KMkZ6ZVc1aklHWjFibU4wYVc5dUtpQW9LU0I3ZlNjcE8xeHVYSFI5SUdWc2MyVWdhV1lnS0c1aGJXVWdQVDA5SUNjbFFYTjVibU5IWlc1bGNtRjBiM0lsSnlrZ2UxeHVYSFJjZEhaaGNpQm1iaUE5SUdSdlJYWmhiQ2duSlVGemVXNWpSMlZ1WlhKaGRHOXlSblZ1WTNScGIyNGxKeWs3WEc1Y2RGeDBhV1lnS0dadUtTQjdYRzVjZEZ4MFhIUjJZV3gxWlNBOUlHWnVMbkJ5YjNSdmRIbHdaVHRjYmx4MFhIUjlYRzVjZEgwZ1pXeHpaU0JwWmlBb2JtRnRaU0E5UFQwZ0p5VkJjM2x1WTBsMFpYSmhkRzl5VUhKdmRHOTBlWEJsSlNjcElIdGNibHgwWEhSMllYSWdaMlZ1SUQwZ1pHOUZkbUZzS0NjbFFYTjVibU5IWlc1bGNtRjBiM0lsSnlrN1hHNWNkRngwYVdZZ0tHZGxiaWtnZTF4dVhIUmNkRngwZG1Gc2RXVWdQU0JuWlhSUWNtOTBieWhuWlc0dWNISnZkRzkwZVhCbEtUdGNibHgwWEhSOVhHNWNkSDFjYmx4dVhIUkpUbFJTU1U1VFNVTlRXMjVoYldWZElEMGdkbUZzZFdVN1hHNWNibHgwY21WMGRYSnVJSFpoYkhWbE8xeHVmVHRjYmx4dWRtRnlJRXhGUjBGRFdWOUJURWxCVTBWVElEMGdlMXh1WEhRbkpVRnljbUY1UW5WbVptVnlVSEp2ZEc5MGVYQmxKU2M2SUZzblFYSnlZWGxDZFdabVpYSW5MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsUVhKeVlYbFFjbTkwYjNSNWNHVWxKem9nV3lkQmNuSmhlU2NzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWQmNuSmhlVkJ5YjNSdlgyVnVkSEpwWlhNbEp6b2dXeWRCY25KaGVTY3NJQ2R3Y205MGIzUjVjR1VuTENBblpXNTBjbWxsY3lkZExGeHVYSFFuSlVGeWNtRjVVSEp2ZEc5ZlptOXlSV0ZqYUNVbk9pQmJKMEZ5Y21GNUp5d2dKM0J5YjNSdmRIbHdaU2NzSUNkbWIzSkZZV05vSjEwc1hHNWNkQ2NsUVhKeVlYbFFjbTkwYjE5clpYbHpKU2M2SUZzblFYSnlZWGtuTENBbmNISnZkRzkwZVhCbEp5d2dKMnRsZVhNblhTeGNibHgwSnlWQmNuSmhlVkJ5YjNSdlgzWmhiSFZsY3lVbk9pQmJKMEZ5Y21GNUp5d2dKM0J5YjNSdmRIbHdaU2NzSUNkMllXeDFaWE1uWFN4Y2JseDBKeVZCYzNsdVkwWjFibU4wYVc5dVVISnZkRzkwZVhCbEpTYzZJRnNuUVhONWJtTkdkVzVqZEdsdmJpY3NJQ2R3Y205MGIzUjVjR1VuWFN4Y2JseDBKeVZCYzNsdVkwZGxibVZ5WVhSdmNpVW5PaUJiSjBGemVXNWpSMlZ1WlhKaGRHOXlSblZ1WTNScGIyNG5MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsUVhONWJtTkhaVzVsY21GMGIzSlFjbTkwYjNSNWNHVWxKem9nV3lkQmMzbHVZMGRsYm1WeVlYUnZja1oxYm1OMGFXOXVKeXdnSjNCeWIzUnZkSGx3WlNjc0lDZHdjbTkwYjNSNWNHVW5YU3hjYmx4MEp5VkNiMjlzWldGdVVISnZkRzkwZVhCbEpTYzZJRnNuUW05dmJHVmhiaWNzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWRVlYUmhWbWxsZDFCeWIzUnZkSGx3WlNVbk9pQmJKMFJoZEdGV2FXVjNKeXdnSjNCeWIzUnZkSGx3WlNkZExGeHVYSFFuSlVSaGRHVlFjbTkwYjNSNWNHVWxKem9nV3lkRVlYUmxKeXdnSjNCeWIzUnZkSGx3WlNkZExGeHVYSFFuSlVWeWNtOXlVSEp2ZEc5MGVYQmxKU2M2SUZzblJYSnliM0luTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFJYWmhiRVZ5Y205eVVISnZkRzkwZVhCbEpTYzZJRnNuUlhaaGJFVnljbTl5Snl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpVWnNiMkYwTXpKQmNuSmhlVkJ5YjNSdmRIbHdaU1VuT2lCYkowWnNiMkYwTXpKQmNuSmhlU2NzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWR2JHOWhkRFkwUVhKeVlYbFFjbTkwYjNSNWNHVWxKem9nV3lkR2JHOWhkRFkwUVhKeVlYa25MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsUm5WdVkzUnBiMjVRY205MGIzUjVjR1VsSnpvZ1d5ZEdkVzVqZEdsdmJpY3NJQ2R3Y205MGIzUjVjR1VuWFN4Y2JseDBKeVZIWlc1bGNtRjBiM0lsSnpvZ1d5ZEhaVzVsY21GMGIzSkdkVzVqZEdsdmJpY3NJQ2R3Y205MGIzUjVjR1VuWFN4Y2JseDBKeVZIWlc1bGNtRjBiM0pRY205MGIzUjVjR1VsSnpvZ1d5ZEhaVzVsY21GMGIzSkdkVzVqZEdsdmJpY3NJQ2R3Y205MGIzUjVjR1VuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFNXNTBPRUZ5Y21GNVVISnZkRzkwZVhCbEpTYzZJRnNuU1c1ME9FRnljbUY1Snl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpVbHVkREUyUVhKeVlYbFFjbTkwYjNSNWNHVWxKem9nV3lkSmJuUXhOa0Z5Y21GNUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVWx1ZERNeVFYSnlZWGxRY205MGIzUjVjR1VsSnpvZ1d5ZEpiblF6TWtGeWNtRjVKeXdnSjNCeWIzUnZkSGx3WlNkZExGeHVYSFFuSlVwVFQwNVFZWEp6WlNVbk9pQmJKMHBUVDA0bkxDQW5jR0Z5YzJVblhTeGNibHgwSnlWS1UwOU9VM1J5YVc1bmFXWjVKU2M2SUZzblNsTlBUaWNzSUNkemRISnBibWRwWm5rblhTeGNibHgwSnlWTllYQlFjbTkwYjNSNWNHVWxKem9nV3lkTllYQW5MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsVG5WdFltVnlVSEp2ZEc5MGVYQmxKU2M2SUZzblRuVnRZbVZ5Snl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpVOWlhbVZqZEZCeWIzUnZkSGx3WlNVbk9pQmJKMDlpYW1WamRDY3NJQ2R3Y205MGIzUjVjR1VuWFN4Y2JseDBKeVZQWW1wUWNtOTBiMTkwYjFOMGNtbHVaeVVuT2lCYkowOWlhbVZqZENjc0lDZHdjbTkwYjNSNWNHVW5MQ0FuZEc5VGRISnBibWNuWFN4Y2JseDBKeVZQWW1wUWNtOTBiMTkyWVd4MVpVOW1KU2M2SUZzblQySnFaV04wSnl3Z0ozQnliM1J2ZEhsd1pTY3NJQ2QyWVd4MVpVOW1KMTBzWEc1Y2RDY2xVSEp2YldselpWQnliM1J2ZEhsd1pTVW5PaUJiSjFCeWIyMXBjMlVuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFVISnZiV2x6WlZCeWIzUnZYM1JvWlc0bEp6b2dXeWRRY205dGFYTmxKeXdnSjNCeWIzUnZkSGx3WlNjc0lDZDBhR1Z1SjEwc1hHNWNkQ2NsVUhKdmJXbHpaVjloYkd3bEp6b2dXeWRRY205dGFYTmxKeXdnSjJGc2JDZGRMRnh1WEhRbkpWQnliMjFwYzJWZmNtVnFaV04wSlNjNklGc25VSEp2YldselpTY3NJQ2R5WldwbFkzUW5YU3hjYmx4MEp5VlFjbTl0YVhObFgzSmxjMjlzZG1VbEp6b2dXeWRRY205dGFYTmxKeXdnSjNKbGMyOXNkbVVuWFN4Y2JseDBKeVZTWVc1blpVVnljbTl5VUhKdmRHOTBlWEJsSlNjNklGc25VbUZ1WjJWRmNuSnZjaWNzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWU1pXWmxjbVZ1WTJWRmNuSnZjbEJ5YjNSdmRIbHdaU1VuT2lCYkoxSmxabVZ5Wlc1alpVVnljbTl5Snl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpWSmxaMFY0Y0ZCeWIzUnZkSGx3WlNVbk9pQmJKMUpsWjBWNGNDY3NJQ2R3Y205MGIzUjVjR1VuWFN4Y2JseDBKeVZUWlhSUWNtOTBiM1I1Y0dVbEp6b2dXeWRUWlhRbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xVMmhoY21Wa1FYSnlZWGxDZFdabVpYSlFjbTkwYjNSNWNHVWxKem9nV3lkVGFHRnlaV1JCY25KaGVVSjFabVpsY2ljc0lDZHdjbTkwYjNSNWNHVW5YU3hjYmx4MEp5VlRkSEpwYm1kUWNtOTBiM1I1Y0dVbEp6b2dXeWRUZEhKcGJtY25MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsVTNsdFltOXNVSEp2ZEc5MGVYQmxKU2M2SUZzblUzbHRZbTlzSnl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpWTjViblJoZUVWeWNtOXlVSEp2ZEc5MGVYQmxKU2M2SUZzblUzbHVkR0Y0UlhKeWIzSW5MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsVkhsd1pXUkJjbkpoZVZCeWIzUnZkSGx3WlNVbk9pQmJKMVI1Y0dWa1FYSnlZWGtuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFZIbHdaVVZ5Y205eVVISnZkRzkwZVhCbEpTYzZJRnNuVkhsd1pVVnljbTl5Snl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpWVnBiblE0UVhKeVlYbFFjbTkwYjNSNWNHVWxKem9nV3lkVmFXNTBPRUZ5Y21GNUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVlZwYm5RNFEyeGhiWEJsWkVGeWNtRjVVSEp2ZEc5MGVYQmxKU2M2SUZzblZXbHVkRGhEYkdGdGNHVmtRWEp5WVhrbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xWV2x1ZERFMlFYSnlZWGxRY205MGIzUjVjR1VsSnpvZ1d5ZFZhVzUwTVRaQmNuSmhlU2NzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWVmFXNTBNekpCY25KaGVWQnliM1J2ZEhsd1pTVW5PaUJiSjFWcGJuUXpNa0Z5Y21GNUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVlZTU1VWeWNtOXlVSEp2ZEc5MGVYQmxKU2M2SUZzblZWSkpSWEp5YjNJbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xWMlZoYTAxaGNGQnliM1J2ZEhsd1pTVW5PaUJiSjFkbFlXdE5ZWEFuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFYyVmhhMU5sZEZCeWIzUnZkSGx3WlNVbk9pQmJKMWRsWVd0VFpYUW5MQ0FuY0hKdmRHOTBlWEJsSjExY2JuMDdYRzVjYm5aaGNpQmlhVzVrSUQwZ2NtVnhkV2x5WlNnblpuVnVZM1JwYjI0dFltbHVaQ2NwTzF4dWRtRnlJR2hoYzA5M2JpQTlJSEpsY1hWcGNtVW9KMmhoY3ljcE8xeHVkbUZ5SUNSamIyNWpZWFFnUFNCaWFXNWtMbU5oYkd3b1JuVnVZM1JwYjI0dVkyRnNiQ3dnUVhKeVlYa3VjSEp2ZEc5MGVYQmxMbU52Ym1OaGRDazdYRzUyWVhJZ0pITndiR2xqWlVGd2NHeDVJRDBnWW1sdVpDNWpZV3hzS0VaMWJtTjBhVzl1TG1Gd2NHeDVMQ0JCY25KaGVTNXdjbTkwYjNSNWNHVXVjM0JzYVdObEtUdGNiblpoY2lBa2NtVndiR0ZqWlNBOUlHSnBibVF1WTJGc2JDaEdkVzVqZEdsdmJpNWpZV3hzTENCVGRISnBibWN1Y0hKdmRHOTBlWEJsTG5KbGNHeGhZMlVwTzF4dWRtRnlJQ1J6ZEhKVGJHbGpaU0E5SUdKcGJtUXVZMkZzYkNoR2RXNWpkR2x2Ymk1allXeHNMQ0JUZEhKcGJtY3VjSEp2ZEc5MGVYQmxMbk5zYVdObEtUdGNibHh1THlvZ1lXUmhjSFJsWkNCbWNtOXRJR2gwZEhCek9pOHZaMmwwYUhWaUxtTnZiUzlzYjJSaGMyZ3ZiRzlrWVhOb0wySnNiMkl2TkM0eE55NHhOUzlrYVhOMEwyeHZaR0Z6YUM1cWN5Tk1OamN6TlMxTU5qYzBOQ0FxTDF4dWRtRnlJSEpsVUhKdmNFNWhiV1VnUFNBdlcxNGxMbHRjWEYxZEszeGNYRnNvUHpvb0xUOWNYR1FyS0Q4NlhGd3VYRnhrS3lrL0tYd29XMXdpSjEwcEtDZy9PaWcvSVZ4Y01pbGJYbHhjWEZ4ZGZGeGNYRnd1S1NvL0tWeGNNaWxjWEYxOEtEODlLRDg2WEZ3dWZGeGNXMXhjWFNrb1B6cGNYQzU4WEZ4YlhGeGRmQ1VrS1Nrdlp6dGNiblpoY2lCeVpVVnpZMkZ3WlVOb1lYSWdQU0F2WEZ4Y1hDaGNYRnhjS1Q4dlp6c2dMeW9xSUZWelpXUWdkRzhnYldGMFkyZ2dZbUZqYTNOc1lYTm9aWE1nYVc0Z2NISnZjR1Z5ZEhrZ2NHRjBhSE11SUNvdlhHNTJZWElnYzNSeWFXNW5WRzlRWVhSb0lEMGdablZ1WTNScGIyNGdjM1J5YVc1blZHOVFZWFJvS0hOMGNtbHVaeWtnZTF4dVhIUjJZWElnWm1seWMzUWdQU0FrYzNSeVUyeHBZMlVvYzNSeWFXNW5MQ0F3TENBeEtUdGNibHgwZG1GeUlHeGhjM1FnUFNBa2MzUnlVMnhwWTJVb2MzUnlhVzVuTENBdE1TazdYRzVjZEdsbUlDaG1hWEp6ZENBOVBUMGdKeVVuSUNZbUlHeGhjM1FnSVQwOUlDY2xKeWtnZTF4dVhIUmNkSFJvY205M0lHNWxkeUFrVTNsdWRHRjRSWEp5YjNJb0oybHVkbUZzYVdRZ2FXNTBjbWx1YzJsaklITjViblJoZUN3Z1pYaHdaV04wWldRZ1kyeHZjMmx1WnlCZ0pXQW5LVHRjYmx4MGZTQmxiSE5sSUdsbUlDaHNZWE4wSUQwOVBTQW5KU2NnSmlZZ1ptbHljM1FnSVQwOUlDY2xKeWtnZTF4dVhIUmNkSFJvY205M0lHNWxkeUFrVTNsdWRHRjRSWEp5YjNJb0oybHVkbUZzYVdRZ2FXNTBjbWx1YzJsaklITjViblJoZUN3Z1pYaHdaV04wWldRZ2IzQmxibWx1WnlCZ0pXQW5LVHRjYmx4MGZWeHVYSFIyWVhJZ2NtVnpkV3gwSUQwZ1cxMDdYRzVjZENSeVpYQnNZV05sS0hOMGNtbHVaeXdnY21WUWNtOXdUbUZ0WlN3Z1puVnVZM1JwYjI0Z0tHMWhkR05vTENCdWRXMWlaWElzSUhGMWIzUmxMQ0J6ZFdKVGRISnBibWNwSUh0Y2JseDBYSFJ5WlhOMWJIUmJjbVZ6ZFd4MExteGxibWQwYUYwZ1BTQnhkVzkwWlNBL0lDUnlaWEJzWVdObEtITjFZbE4wY21sdVp5d2djbVZGYzJOaGNHVkRhR0Z5TENBbkpERW5LU0E2SUc1MWJXSmxjaUI4ZkNCdFlYUmphRHRjYmx4MGZTazdYRzVjZEhKbGRIVnliaUJ5WlhOMWJIUTdYRzU5TzF4dUx5b2daVzVrSUdGa1lYQjBZWFJwYjI0Z0tpOWNibHh1ZG1GeUlHZGxkRUpoYzJWSmJuUnlhVzV6YVdNZ1BTQm1kVzVqZEdsdmJpQm5aWFJDWVhObFNXNTBjbWx1YzJsaktHNWhiV1VzSUdGc2JHOTNUV2x6YzJsdVp5a2dlMXh1WEhSMllYSWdhVzUwY21sdWMybGpUbUZ0WlNBOUlHNWhiV1U3WEc1Y2RIWmhjaUJoYkdsaGN6dGNibHgwYVdZZ0tHaGhjMDkzYmloTVJVZEJRMWxmUVV4SlFWTkZVeXdnYVc1MGNtbHVjMmxqVG1GdFpTa3BJSHRjYmx4MFhIUmhiR2xoY3lBOUlFeEZSMEZEV1Y5QlRFbEJVMFZUVzJsdWRISnBibk5wWTA1aGJXVmRPMXh1WEhSY2RHbHVkSEpwYm5OcFkwNWhiV1VnUFNBbkpTY2dLeUJoYkdsaGMxc3dYU0FySUNjbEp6dGNibHgwZlZ4dVhHNWNkR2xtSUNob1lYTlBkMjRvU1U1VVVrbE9VMGxEVXl3Z2FXNTBjbWx1YzJsalRtRnRaU2twSUh0Y2JseDBYSFIyWVhJZ2RtRnNkV1VnUFNCSlRsUlNTVTVUU1VOVFcybHVkSEpwYm5OcFkwNWhiV1ZkTzF4dVhIUmNkR2xtSUNoMllXeDFaU0E5UFQwZ2JtVmxaSE5GZG1Gc0tTQjdYRzVjZEZ4MFhIUjJZV3gxWlNBOUlHUnZSWFpoYkNocGJuUnlhVzV6YVdOT1lXMWxLVHRjYmx4MFhIUjlYRzVjZEZ4MGFXWWdLSFI1Y0dWdlppQjJZV3gxWlNBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnSmlZZ0lXRnNiRzkzVFdsemMybHVaeWtnZTF4dVhIUmNkRngwZEdoeWIzY2dibVYzSUNSVWVYQmxSWEp5YjNJb0oybHVkSEpwYm5OcFl5QW5JQ3NnYm1GdFpTQXJJQ2NnWlhocGMzUnpMQ0JpZFhRZ2FYTWdibTkwSUdGMllXbHNZV0pzWlM0Z1VHeGxZWE5sSUdacGJHVWdZVzRnYVhOemRXVWhKeWs3WEc1Y2RGeDBmVnh1WEc1Y2RGeDBjbVYwZFhKdUlIdGNibHgwWEhSY2RHRnNhV0Z6T2lCaGJHbGhjeXhjYmx4MFhIUmNkRzVoYldVNklHbHVkSEpwYm5OcFkwNWhiV1VzWEc1Y2RGeDBYSFIyWVd4MVpUb2dkbUZzZFdWY2JseDBYSFI5TzF4dVhIUjlYRzVjYmx4MGRHaHliM2NnYm1WM0lDUlRlVzUwWVhoRmNuSnZjaWduYVc1MGNtbHVjMmxqSUNjZ0t5QnVZVzFsSUNzZ0p5QmtiMlZ6SUc1dmRDQmxlR2x6ZENFbktUdGNibjA3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z1IyVjBTVzUwY21sdWMybGpLRzVoYldVc0lHRnNiRzkzVFdsemMybHVaeWtnZTF4dVhIUnBaaUFvZEhsd1pXOW1JRzVoYldVZ0lUMDlJQ2R6ZEhKcGJtY25JSHg4SUc1aGJXVXViR1Z1WjNSb0lEMDlQU0F3S1NCN1hHNWNkRngwZEdoeWIzY2dibVYzSUNSVWVYQmxSWEp5YjNJb0oybHVkSEpwYm5OcFl5QnVZVzFsSUcxMWMzUWdZbVVnWVNCdWIyNHRaVzF3ZEhrZ2MzUnlhVzVuSnlrN1hHNWNkSDFjYmx4MGFXWWdLR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ2dQaUF4SUNZbUlIUjVjR1Z2WmlCaGJHeHZkMDFwYzNOcGJtY2dJVDA5SUNkaWIyOXNaV0Z1SnlrZ2UxeHVYSFJjZEhSb2NtOTNJRzVsZHlBa1ZIbHdaVVZ5Y205eUtDZGNJbUZzYkc5M1RXbHpjMmx1WjF3aUlHRnlaM1Z0Wlc1MElHMTFjM1FnWW1VZ1lTQmliMjlzWldGdUp5azdYRzVjZEgxY2JseHVYSFIyWVhJZ2NHRnlkSE1nUFNCemRISnBibWRVYjFCaGRHZ29ibUZ0WlNrN1hHNWNkSFpoY2lCcGJuUnlhVzV6YVdOQ1lYTmxUbUZ0WlNBOUlIQmhjblJ6TG14bGJtZDBhQ0ErSURBZ1B5QndZWEowYzFzd1hTQTZJQ2NuTzF4dVhHNWNkSFpoY2lCcGJuUnlhVzV6YVdNZ1BTQm5aWFJDWVhObFNXNTBjbWx1YzJsaktDY2xKeUFySUdsdWRISnBibk5wWTBKaGMyVk9ZVzFsSUNzZ0p5VW5MQ0JoYkd4dmQwMXBjM05wYm1jcE8xeHVYSFIyWVhJZ2FXNTBjbWx1YzJsalVtVmhiRTVoYldVZ1BTQnBiblJ5YVc1emFXTXVibUZ0WlR0Y2JseDBkbUZ5SUhaaGJIVmxJRDBnYVc1MGNtbHVjMmxqTG5aaGJIVmxPMXh1WEhSMllYSWdjMnRwY0VaMWNuUm9aWEpEWVdOb2FXNW5JRDBnWm1Gc2MyVTdYRzVjYmx4MGRtRnlJR0ZzYVdGeklEMGdhVzUwY21sdWMybGpMbUZzYVdGek8xeHVYSFJwWmlBb1lXeHBZWE1wSUh0Y2JseDBYSFJwYm5SeWFXNXphV05DWVhObFRtRnRaU0E5SUdGc2FXRnpXekJkTzF4dVhIUmNkQ1J6Y0d4cFkyVkJjSEJzZVNod1lYSjBjeXdnSkdOdmJtTmhkQ2hiTUN3Z01WMHNJR0ZzYVdGektTazdYRzVjZEgxY2JseHVYSFJtYjNJZ0tIWmhjaUJwSUQwZ01Td2dhWE5QZDI0Z1BTQjBjblZsT3lCcElEd2djR0Z5ZEhNdWJHVnVaM1JvT3lCcElDczlJREVwSUh0Y2JseDBYSFIyWVhJZ2NHRnlkQ0E5SUhCaGNuUnpXMmxkTzF4dVhIUmNkSFpoY2lCbWFYSnpkQ0E5SUNSemRISlRiR2xqWlNod1lYSjBMQ0F3TENBeEtUdGNibHgwWEhSMllYSWdiR0Z6ZENBOUlDUnpkSEpUYkdsalpTaHdZWEowTENBdE1TazdYRzVjZEZ4MGFXWWdLRnh1WEhSY2RGeDBLRnh1WEhSY2RGeDBYSFFvWm1seWMzUWdQVDA5SUNkY0lpY2dmSHdnWm1seWMzUWdQVDA5SUZ3aUoxd2lJSHg4SUdacGNuTjBJRDA5UFNBbllDY3BYRzVjZEZ4MFhIUmNkSHg4SUNoc1lYTjBJRDA5UFNBblhDSW5JSHg4SUd4aGMzUWdQVDA5SUZ3aUoxd2lJSHg4SUd4aGMzUWdQVDA5SUNkZ0p5bGNibHgwWEhSY2RDbGNibHgwWEhSY2RDWW1JR1pwY25OMElDRTlQU0JzWVhOMFhHNWNkRngwS1NCN1hHNWNkRngwWEhSMGFISnZkeUJ1WlhjZ0pGTjViblJoZUVWeWNtOXlLQ2R3Y205d1pYSjBlU0J1WVcxbGN5QjNhWFJvSUhGMWIzUmxjeUJ0ZFhOMElHaGhkbVVnYldGMFkyaHBibWNnY1hWdmRHVnpKeWs3WEc1Y2RGeDBmVnh1WEhSY2RHbG1JQ2h3WVhKMElEMDlQU0FuWTI5dWMzUnlkV04wYjNJbklIeDhJQ0ZwYzA5M2Jpa2dlMXh1WEhSY2RGeDBjMnRwY0VaMWNuUm9aWEpEWVdOb2FXNW5JRDBnZEhKMVpUdGNibHgwWEhSOVhHNWNibHgwWEhScGJuUnlhVzV6YVdOQ1lYTmxUbUZ0WlNBclBTQW5MaWNnS3lCd1lYSjBPMXh1WEhSY2RHbHVkSEpwYm5OcFkxSmxZV3hPWVcxbElEMGdKeVVuSUNzZ2FXNTBjbWx1YzJsalFtRnpaVTVoYldVZ0t5QW5KU2M3WEc1Y2JseDBYSFJwWmlBb2FHRnpUM2R1S0VsT1ZGSkpUbE5KUTFNc0lHbHVkSEpwYm5OcFkxSmxZV3hPWVcxbEtTa2dlMXh1WEhSY2RGeDBkbUZzZFdVZ1BTQkpUbFJTU1U1VFNVTlRXMmx1ZEhKcGJuTnBZMUpsWVd4T1lXMWxYVHRjYmx4MFhIUjlJR1ZzYzJVZ2FXWWdLSFpoYkhWbElDRTlJRzUxYkd3cElIdGNibHgwWEhSY2RHbG1JQ2doS0hCaGNuUWdhVzRnZG1Gc2RXVXBLU0I3WEc1Y2RGeDBYSFJjZEdsbUlDZ2hZV3hzYjNkTmFYTnphVzVuS1NCN1hHNWNkRngwWEhSY2RGeDBkR2h5YjNjZ2JtVjNJQ1JVZVhCbFJYSnliM0lvSjJKaGMyVWdhVzUwY21sdWMybGpJR1p2Y2lBbklDc2dibUZ0WlNBcklDY2daWGhwYzNSekxDQmlkWFFnZEdobElIQnliM0JsY25SNUlHbHpJRzV2ZENCaGRtRnBiR0ZpYkdVdUp5azdYRzVjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkRngwY21WMGRYSnVJSFp2YVdRZ2RXNWtaV1pwYm1Wa08xeHVYSFJjZEZ4MGZWeHVYSFJjZEZ4MGFXWWdLQ1JuVDFCRUlDWW1JQ2hwSUNzZ01Ta2dQajBnY0dGeWRITXViR1Z1WjNSb0tTQjdYRzVjZEZ4MFhIUmNkSFpoY2lCa1pYTmpJRDBnSkdkUFVFUW9kbUZzZFdVc0lIQmhjblFwTzF4dVhIUmNkRngwWEhScGMwOTNiaUE5SUNFaFpHVnpZenRjYmx4dVhIUmNkRngwWEhRdkx5QkNlU0JqYjI1MlpXNTBhVzl1TENCM2FHVnVJR0VnWkdGMFlTQndjbTl3WlhKMGVTQnBjeUJqYjI1MlpYSjBaV1FnZEc4Z1lXNGdZV05qWlhOemIzSmNibHgwWEhSY2RGeDBMeThnY0hKdmNHVnlkSGtnZEc4Z1pXMTFiR0YwWlNCaElHUmhkR0VnY0hKdmNHVnlkSGtnZEdoaGRDQmtiMlZ6SUc1dmRDQnpkV1ptWlhJZ1puSnZiVnh1WEhSY2RGeDBYSFF2THlCMGFHVWdiM1psY25KcFpHVWdiV2x6ZEdGclpTd2dkR2hoZENCaFkyTmxjM052Y2lkeklHZGxkSFJsY2lCcGN5QnRZWEpyWldRZ2QybDBhRnh1WEhSY2RGeDBYSFF2THlCaGJpQmdiM0pwWjJsdVlXeFdZV3gxWldBZ2NISnZjR1Z5ZEhrdUlFaGxjbVVzSUhkb1pXNGdkMlVnWkdWMFpXTjBJSFJvYVhNc0lIZGxYRzVjZEZ4MFhIUmNkQzh2SUhWd2FHOXNaQ0IwYUdVZ2FXeHNkWE5wYjI0Z1lua2djSEpsZEdWdVpHbHVaeUIwYnlCelpXVWdkR2hoZENCdmNtbG5hVzVoYkNCa1lYUmhYRzVjZEZ4MFhIUmNkQzh2SUhCeWIzQmxjblI1TENCcExtVXVMQ0J5WlhSMWNtNXBibWNnZEdobElIWmhiSFZsSUhKaGRHaGxjaUIwYUdGdUlIUm9aU0JuWlhSMFpYSmNibHgwWEhSY2RGeDBMeThnYVhSelpXeG1MbHh1WEhSY2RGeDBYSFJwWmlBb2FYTlBkMjRnSmlZZ0oyZGxkQ2NnYVc0Z1pHVnpZeUFtSmlBaEtDZHZjbWxuYVc1aGJGWmhiSFZsSnlCcGJpQmtaWE5qTG1kbGRDa3BJSHRjYmx4MFhIUmNkRngwWEhSMllXeDFaU0E5SUdSbGMyTXVaMlYwTzF4dVhIUmNkRngwWEhSOUlHVnNjMlVnZTF4dVhIUmNkRngwWEhSY2RIWmhiSFZsSUQwZ2RtRnNkV1ZiY0dGeWRGMDdYRzVjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkSDBnWld4elpTQjdYRzVjZEZ4MFhIUmNkR2x6VDNkdUlEMGdhR0Z6VDNkdUtIWmhiSFZsTENCd1lYSjBLVHRjYmx4MFhIUmNkRngwZG1Gc2RXVWdQU0IyWVd4MVpWdHdZWEowWFR0Y2JseDBYSFJjZEgxY2JseHVYSFJjZEZ4MGFXWWdLR2x6VDNkdUlDWW1JQ0Z6YTJsd1JuVnlkR2hsY2tOaFkyaHBibWNwSUh0Y2JseDBYSFJjZEZ4MFNVNVVVa2xPVTBsRFUxdHBiblJ5YVc1emFXTlNaV0ZzVG1GdFpWMGdQU0IyWVd4MVpUdGNibHgwWEhSY2RIMWNibHgwWEhSOVhHNWNkSDFjYmx4MGNtVjBkWEp1SUhaaGJIVmxPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVkbUZ5SUc5eWFXZFRlVzFpYjJ3Z1BTQjBlWEJsYjJZZ1UzbHRZbTlzSUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmlCVGVXMWliMnc3WEc1MllYSWdhR0Z6VTNsdFltOXNVMmhoYlNBOUlISmxjWFZwY21Vb0p5NHZjMmhoYlhNbktUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJvWVhOT1lYUnBkbVZUZVcxaWIyeHpLQ2tnZTF4dVhIUnBaaUFvZEhsd1pXOW1JRzl5YVdkVGVXMWliMndnSVQwOUlDZG1kVzVqZEdsdmJpY3BJSHNnY21WMGRYSnVJR1poYkhObE95QjlYRzVjZEdsbUlDaDBlWEJsYjJZZ1UzbHRZbTlzSUNFOVBTQW5ablZ1WTNScGIyNG5LU0I3SUhKbGRIVnliaUJtWVd4elpUc2dmVnh1WEhScFppQW9kSGx3Wlc5bUlHOXlhV2RUZVcxaWIyd29KMlp2YnljcElDRTlQU0FuYzNsdFltOXNKeWtnZXlCeVpYUjFjbTRnWm1Gc2MyVTdJSDFjYmx4MGFXWWdLSFI1Y0dWdlppQlRlVzFpYjJ3b0oySmhjaWNwSUNFOVBTQW5jM2x0WW05c0p5a2dleUJ5WlhSMWNtNGdabUZzYzJVN0lIMWNibHh1WEhSeVpYUjFjbTRnYUdGelUzbHRZbTlzVTJoaGJTZ3BPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVMeW9nWlhOc2FXNTBJR052YlhCc1pYaHBkSGs2SUZzeUxDQXhPRjBzSUcxaGVDMXpkR0YwWlcxbGJuUnpPaUJiTWl3Z016TmRJQ292WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUdoaGMxTjViV0p2YkhNb0tTQjdYRzVjZEdsbUlDaDBlWEJsYjJZZ1UzbHRZbTlzSUNFOVBTQW5ablZ1WTNScGIyNG5JSHg4SUhSNWNHVnZaaUJQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsVGVXMWliMnh6SUNFOVBTQW5ablZ1WTNScGIyNG5LU0I3SUhKbGRIVnliaUJtWVd4elpUc2dmVnh1WEhScFppQW9kSGx3Wlc5bUlGTjViV0p2YkM1cGRHVnlZWFJ2Y2lBOVBUMGdKM041YldKdmJDY3BJSHNnY21WMGRYSnVJSFJ5ZFdVN0lIMWNibHh1WEhSMllYSWdiMkpxSUQwZ2UzMDdYRzVjZEhaaGNpQnplVzBnUFNCVGVXMWliMndvSjNSbGMzUW5LVHRjYmx4MGRtRnlJSE41YlU5aWFpQTlJRTlpYW1WamRDaHplVzBwTzF4dVhIUnBaaUFvZEhsd1pXOW1JSE41YlNBOVBUMGdKM04wY21sdVp5Y3BJSHNnY21WMGRYSnVJR1poYkhObE95QjlYRzVjYmx4MGFXWWdLRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY3VZMkZzYkNoemVXMHBJQ0U5UFNBblcyOWlhbVZqZENCVGVXMWliMnhkSnlrZ2V5QnlaWFIxY200Z1ptRnNjMlU3SUgxY2JseDBhV1lnS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWN1WTJGc2JDaHplVzFQWW1vcElDRTlQU0FuVzI5aWFtVmpkQ0JUZVcxaWIyeGRKeWtnZXlCeVpYUjFjbTRnWm1Gc2MyVTdJSDFjYmx4dVhIUXZMeUIwWlcxd0lHUnBjMkZpYkdWa0lIQmxjaUJvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykdwb1lYSmlMMjlpYW1WamRDNWhjM05wWjI0dmFYTnpkV1Z6THpFM1hHNWNkQzh2SUdsbUlDaHplVzBnYVc1emRHRnVZMlZ2WmlCVGVXMWliMndwSUhzZ2NtVjBkWEp1SUdaaGJITmxPeUI5WEc1Y2RDOHZJSFJsYlhBZ1pHbHpZV0pzWldRZ2NHVnlJR2gwZEhCek9pOHZaMmwwYUhWaUxtTnZiUzlYWldKU1pXWnNaV04wYVc5dUwyZGxkQzF2ZDI0dGNISnZjR1Z5ZEhrdGMzbHRZbTlzY3k5cGMzTjFaWE12TkZ4dVhIUXZMeUJwWmlBb0lTaHplVzFQWW1vZ2FXNXpkR0Z1WTJWdlppQlRlVzFpYjJ3cEtTQjdJSEpsZEhWeWJpQm1ZV3h6WlRzZ2ZWeHVYRzVjZEM4dklHbG1JQ2gwZVhCbGIyWWdVM2x0WW05c0xuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5QWhQVDBnSjJaMWJtTjBhVzl1SnlrZ2V5QnlaWFIxY200Z1ptRnNjMlU3SUgxY2JseDBMeThnYVdZZ0tGTjBjbWx1WnloemVXMHBJQ0U5UFNCVGVXMWliMnd1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29jM2x0S1NrZ2V5QnlaWFIxY200Z1ptRnNjMlU3SUgxY2JseHVYSFIyWVhJZ2MzbHRWbUZzSUQwZ05ESTdYRzVjZEc5aWFsdHplVzFkSUQwZ2MzbHRWbUZzTzF4dVhIUm1iM0lnS0hONWJTQnBiaUJ2WW1vcElIc2djbVYwZFhKdUlHWmhiSE5sT3lCOUlDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXeHBibVVnYm04dGNtVnpkSEpwWTNSbFpDMXplVzUwWVhnc0lHNXZMWFZ1Y21WaFkyaGhZbXhsTFd4dmIzQmNibHgwYVdZZ0tIUjVjR1Z2WmlCUFltcGxZM1F1YTJWNWN5QTlQVDBnSjJaMWJtTjBhVzl1SnlBbUppQlBZbXBsWTNRdWEyVjVjeWh2WW1vcExteGxibWQwYUNBaFBUMGdNQ2tnZXlCeVpYUjFjbTRnWm1Gc2MyVTdJSDFjYmx4dVhIUnBaaUFvZEhsd1pXOW1JRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpJRDA5UFNBblpuVnVZM1JwYjI0bklDWW1JRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpLRzlpYWlrdWJHVnVaM1JvSUNFOVBTQXdLU0I3SUhKbGRIVnliaUJtWVd4elpUc2dmVnh1WEc1Y2RIWmhjaUJ6ZVcxeklEMGdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjeWh2WW1vcE8xeHVYSFJwWmlBb2MzbHRjeTVzWlc1bmRHZ2dJVDA5SURFZ2ZId2djM2x0YzFzd1hTQWhQVDBnYzNsdEtTQjdJSEpsZEhWeWJpQm1ZV3h6WlRzZ2ZWeHVYRzVjZEdsbUlDZ2hUMkpxWldOMExuQnliM1J2ZEhsd1pTNXdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaUzVqWVd4c0tHOWlhaXdnYzNsdEtTa2dleUJ5WlhSMWNtNGdabUZzYzJVN0lIMWNibHh1WEhScFppQW9kSGx3Wlc5bUlFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVVJsYzJOeWFYQjBiM0lnUFQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmx4MFhIUjJZWElnWkdWelkzSnBjSFJ2Y2lBOUlFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVVJsYzJOeWFYQjBiM0lvYjJKcUxDQnplVzBwTzF4dVhIUmNkR2xtSUNoa1pYTmpjbWx3ZEc5eUxuWmhiSFZsSUNFOVBTQnplVzFXWVd3Z2ZId2daR1Z6WTNKcGNIUnZjaTVsYm5WdFpYSmhZbXhsSUNFOVBTQjBjblZsS1NCN0lISmxkSFZ5YmlCbVlXeHpaVHNnZlZ4dVhIUjlYRzVjYmx4MGNtVjBkWEp1SUhSeWRXVTdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWW1sdVpDQTlJSEpsY1hWcGNtVW9KMloxYm1OMGFXOXVMV0pwYm1RbktUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JpYVc1a0xtTmhiR3dvUm5WdVkzUnBiMjR1WTJGc2JDd2dUMkpxWldOMExuQnliM1J2ZEhsd1pTNW9ZWE5QZDI1UWNtOXdaWEowZVNrN1hHNGlMQ0pwWmlBb2RIbHdaVzltSUU5aWFtVmpkQzVqY21WaGRHVWdQVDA5SUNkbWRXNWpkR2x2YmljcElIdGNiaUFnTHk4Z2FXMXdiR1Z0Wlc1MFlYUnBiMjRnWm5KdmJTQnpkR0Z1WkdGeVpDQnViMlJsTG1weklDZDFkR2xzSnlCdGIyUjFiR1ZjYmlBZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCcGJtaGxjbWwwY3loamRHOXlMQ0J6ZFhCbGNrTjBiM0lwSUh0Y2JpQWdJQ0JwWmlBb2MzVndaWEpEZEc5eUtTQjdYRzRnSUNBZ0lDQmpkRzl5TG5OMWNHVnlYeUE5SUhOMWNHVnlRM1J2Y2x4dUlDQWdJQ0FnWTNSdmNpNXdjbTkwYjNSNWNHVWdQU0JQWW1wbFkzUXVZM0psWVhSbEtITjFjR1Z5UTNSdmNpNXdjbTkwYjNSNWNHVXNJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMzUnlkV04wYjNJNklIdGNiaUFnSUNBZ0lDQWdJQ0IyWVd4MVpUb2dZM1J2Y2l4Y2JpQWdJQ0FnSUNBZ0lDQmxiblZ0WlhKaFlteGxPaUJtWVd4elpTeGNiaUFnSUNBZ0lDQWdJQ0IzY21sMFlXSnNaVG9nZEhKMVpTeGNiaUFnSUNBZ0lDQWdJQ0JqYjI1bWFXZDFjbUZpYkdVNklIUnlkV1ZjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlNsY2JpQWdJQ0I5WEc0Z0lIMDdYRzU5SUdWc2MyVWdlMXh1SUNBdkx5QnZiR1FnYzJOb2IyOXNJSE5vYVcwZ1ptOXlJRzlzWkNCaWNtOTNjMlZ5YzF4dUlDQnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlHbHVhR1Z5YVhSektHTjBiM0lzSUhOMWNHVnlRM1J2Y2lrZ2UxeHVJQ0FnSUdsbUlDaHpkWEJsY2tOMGIzSXBJSHRjYmlBZ0lDQWdJR04wYjNJdWMzVndaWEpmSUQwZ2MzVndaWEpEZEc5eVhHNGdJQ0FnSUNCMllYSWdWR1Z0Y0VOMGIzSWdQU0JtZFc1amRHbHZiaUFvS1NCN2ZWeHVJQ0FnSUNBZ1ZHVnRjRU4wYjNJdWNISnZkRzkwZVhCbElEMGdjM1Z3WlhKRGRHOXlMbkJ5YjNSdmRIbHdaVnh1SUNBZ0lDQWdZM1J2Y2k1d2NtOTBiM1I1Y0dVZ1BTQnVaWGNnVkdWdGNFTjBiM0lvS1Z4dUlDQWdJQ0FnWTNSdmNpNXdjbTkwYjNSNWNHVXVZMjl1YzNSeWRXTjBiM0lnUFNCamRHOXlYRzRnSUNBZ2ZWeHVJQ0I5WEc1OVhHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCb1lYTlViMU4wY21sdVoxUmhaeUE5SUhSNWNHVnZaaUJUZVcxaWIyd2dQVDA5SUNkbWRXNWpkR2x2YmljZ0ppWWdkSGx3Wlc5bUlGTjViV0p2YkM1MGIxTjBjbWx1WjFSaFp5QTlQVDBnSjNONWJXSnZiQ2M3WEc1MllYSWdZMkZzYkVKdmRXNWtJRDBnY21WeGRXbHlaU2duWTJGc2JDMWlhVzVrTDJOaGJHeENiM1Z1WkNjcE8xeHVYRzUyWVhJZ0pIUnZVM1J5YVc1bklEMGdZMkZzYkVKdmRXNWtLQ2RQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5KeWs3WEc1Y2JuWmhjaUJwYzFOMFlXNWtZWEprUVhKbmRXMWxiblJ6SUQwZ1puVnVZM1JwYjI0Z2FYTkJjbWQxYldWdWRITW9kbUZzZFdVcElIdGNibHgwYVdZZ0tHaGhjMVJ2VTNSeWFXNW5WR0ZuSUNZbUlIWmhiSFZsSUNZbUlIUjVjR1Z2WmlCMllXeDFaU0E5UFQwZ0oyOWlhbVZqZENjZ0ppWWdVM2x0WW05c0xuUnZVM1J5YVc1blZHRm5JR2x1SUhaaGJIVmxLU0I3WEc1Y2RGeDBjbVYwZFhKdUlHWmhiSE5sTzF4dVhIUjlYRzVjZEhKbGRIVnliaUFrZEc5VGRISnBibWNvZG1Gc2RXVXBJRDA5UFNBblcyOWlhbVZqZENCQmNtZDFiV1Z1ZEhOZEp6dGNibjA3WEc1Y2JuWmhjaUJwYzB4bFoyRmplVUZ5WjNWdFpXNTBjeUE5SUdaMWJtTjBhVzl1SUdselFYSm5kVzFsYm5SektIWmhiSFZsS1NCN1hHNWNkR2xtSUNocGMxTjBZVzVrWVhKa1FYSm5kVzFsYm5SektIWmhiSFZsS1NrZ2UxeHVYSFJjZEhKbGRIVnliaUIwY25WbE8xeHVYSFI5WEc1Y2RISmxkSFZ5YmlCMllXeDFaU0FoUFQwZ2JuVnNiQ0FtSmx4dVhIUmNkSFI1Y0dWdlppQjJZV3gxWlNBOVBUMGdKMjlpYW1WamRDY2dKaVpjYmx4MFhIUjBlWEJsYjJZZ2RtRnNkV1V1YkdWdVozUm9JRDA5UFNBbmJuVnRZbVZ5SnlBbUpseHVYSFJjZEhaaGJIVmxMbXhsYm1kMGFDQStQU0F3SUNZbVhHNWNkRngwSkhSdlUzUnlhVzVuS0haaGJIVmxLU0FoUFQwZ0oxdHZZbXBsWTNRZ1FYSnlZWGxkSnlBbUpseHVYSFJjZENSMGIxTjBjbWx1WnloMllXeDFaUzVqWVd4c1pXVXBJRDA5UFNBblcyOWlhbVZqZENCR2RXNWpkR2x2Ymwwbk8xeHVmVHRjYmx4dWRtRnlJSE4xY0hCdmNuUnpVM1JoYm1SaGNtUkJjbWQxYldWdWRITWdQU0FvWm5WdVkzUnBiMjRnS0NrZ2UxeHVYSFJ5WlhSMWNtNGdhWE5UZEdGdVpHRnlaRUZ5WjNWdFpXNTBjeWhoY21kMWJXVnVkSE1wTzF4dWZTZ3BLVHRjYmx4dWFYTlRkR0Z1WkdGeVpFRnlaM1Z0Wlc1MGN5NXBjMHhsWjJGamVVRnlaM1Z0Wlc1MGN5QTlJR2x6VEdWbllXTjVRWEpuZFcxbGJuUnpPeUF2THlCbWIzSWdkR1Z6ZEhOY2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQnpkWEJ3YjNKMGMxTjBZVzVrWVhKa1FYSm5kVzFsYm5SeklEOGdhWE5UZEdGdVpHRnlaRUZ5WjNWdFpXNTBjeUE2SUdselRHVm5ZV041UVhKbmRXMWxiblJ6TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnZEc5VGRISWdQU0JQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5PMXh1ZG1GeUlHWnVWRzlUZEhJZ1BTQkdkVzVqZEdsdmJpNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtYzdYRzUyWVhJZ2FYTkdibEpsWjJWNElEMGdMMTVjWEhNcUtEODZablZ1WTNScGIyNHBQMXhjS2k4N1hHNTJZWElnYUdGelZHOVRkSEpwYm1kVVlXY2dQU0IwZVhCbGIyWWdVM2x0WW05c0lEMDlQU0FuWm5WdVkzUnBiMjRuSUNZbUlIUjVjR1Z2WmlCVGVXMWliMnd1ZEc5VGRISnBibWRVWVdjZ1BUMDlJQ2R6ZVcxaWIyd25PMXh1ZG1GeUlHZGxkRkJ5YjNSdklEMGdUMkpxWldOMExtZGxkRkJ5YjNSdmRIbHdaVTltTzF4dWRtRnlJR2RsZEVkbGJtVnlZWFJ2Y2taMWJtTWdQU0JtZFc1amRHbHZiaUFvS1NCN0lDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXeHBibVVnWTI5dWMybHpkR1Z1ZEMxeVpYUjFjbTVjYmx4MGFXWWdLQ0ZvWVhOVWIxTjBjbWx1WjFSaFp5a2dlMXh1WEhSY2RISmxkSFZ5YmlCbVlXeHpaVHRjYmx4MGZWeHVYSFIwY25rZ2UxeHVYSFJjZEhKbGRIVnliaUJHZFc1amRHbHZiaWduY21WMGRYSnVJR1oxYm1OMGFXOXVLaWdwSUh0OUp5a29LVHRjYmx4MGZTQmpZWFJqYUNBb1pTa2dlMXh1WEhSOVhHNTlPMXh1ZG1GeUlHZGxibVZ5WVhSdmNrWjFibU1nUFNCblpYUkhaVzVsY21GMGIzSkdkVzVqS0NrN1hHNTJZWElnUjJWdVpYSmhkRzl5Um5WdVkzUnBiMjRnUFNCblpYUlFjbTkwYnlBbUppQm5aVzVsY21GMGIzSkdkVzVqSUQ4Z1oyVjBVSEp2ZEc4b1oyVnVaWEpoZEc5eVJuVnVZeWtnT2lCbVlXeHpaVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCcGMwZGxibVZ5WVhSdmNrWjFibU4wYVc5dUtHWnVLU0I3WEc1Y2RHbG1JQ2gwZVhCbGIyWWdabTRnSVQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmx4MFhIUnlaWFIxY200Z1ptRnNjMlU3WEc1Y2RIMWNibHgwYVdZZ0tHbHpSbTVTWldkbGVDNTBaWE4wS0dadVZHOVRkSEl1WTJGc2JDaG1iaWtwS1NCN1hHNWNkRngwY21WMGRYSnVJSFJ5ZFdVN1hHNWNkSDFjYmx4MGFXWWdLQ0ZvWVhOVWIxTjBjbWx1WjFSaFp5a2dlMXh1WEhSY2RIWmhjaUJ6ZEhJZ1BTQjBiMU4wY2k1allXeHNLR1p1S1R0Y2JseDBYSFJ5WlhSMWNtNGdjM1J5SUQwOVBTQW5XMjlpYW1WamRDQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJsMG5PMXh1WEhSOVhHNWNkSEpsZEhWeWJpQm5aWFJRY205MGJ5QW1KaUJuWlhSUWNtOTBieWhtYmlrZ1BUMDlJRWRsYm1WeVlYUnZja1oxYm1OMGFXOXVPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVMeW9nYUhSMGNEb3ZMM2QzZHk1bFkyMWhMV2x1ZEdWeWJtRjBhVzl1WVd3dWIzSm5MMlZqYldFdE1qWXlMell1TUM4amMyVmpMVzUxYldKbGNpNXBjMjVoYmlBcUwxeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJR2x6VG1GT0tIWmhiSFZsS1NCN1hHNWNkSEpsZEhWeWJpQjJZV3gxWlNBaFBUMGdkbUZzZFdVN1hHNTlPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdZMkZzYkVKcGJtUWdQU0J5WlhGMWFYSmxLQ2RqWVd4c0xXSnBibVFuS1R0Y2JuWmhjaUJrWldacGJtVWdQU0J5WlhGMWFYSmxLQ2RrWldacGJtVXRjSEp2Y0dWeWRHbGxjeWNwTzF4dVhHNTJZWElnYVcxd2JHVnRaVzUwWVhScGIyNGdQU0J5WlhGMWFYSmxLQ2N1TDJsdGNHeGxiV1Z1ZEdGMGFXOXVKeWs3WEc1MllYSWdaMlYwVUc5c2VXWnBiR3dnUFNCeVpYRjFhWEpsS0NjdUwzQnZiSGxtYVd4c0p5azdYRzUyWVhJZ2MyaHBiU0E5SUhKbGNYVnBjbVVvSnk0dmMyaHBiU2NwTzF4dVhHNTJZWElnY0c5c2VXWnBiR3dnUFNCallXeHNRbWx1WkNoblpYUlFiMng1Wm1sc2JDZ3BMQ0JPZFcxaVpYSXBPMXh1WEc0dktpQm9kSFJ3T2k4dmQzZDNMbVZqYldFdGFXNTBaWEp1WVhScGIyNWhiQzV2Y21jdlpXTnRZUzB5TmpJdk5pNHdMeU56WldNdGJuVnRZbVZ5TG1semJtRnVJQ292WEc1Y2JtUmxabWx1WlNod2IyeDVabWxzYkN3Z2UxeHVYSFJuWlhSUWIyeDVabWxzYkRvZ1oyVjBVRzlzZVdacGJHd3NYRzVjZEdsdGNHeGxiV1Z1ZEdGMGFXOXVPaUJwYlhCc1pXMWxiblJoZEdsdmJpeGNibHgwYzJocGJUb2djMmhwYlZ4dWZTazdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnY0c5c2VXWnBiR3c3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUJwYlhCc1pXMWxiblJoZEdsdmJpQTlJSEpsY1hWcGNtVW9KeTR2YVcxd2JHVnRaVzUwWVhScGIyNG5LVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCblpYUlFiMng1Wm1sc2JDZ3BJSHRjYmx4MGFXWWdLRTUxYldKbGNpNXBjMDVoVGlBbUppQk9kVzFpWlhJdWFYTk9ZVTRvVG1GT0tTQW1KaUFoVG5WdFltVnlMbWx6VG1GT0tDZGhKeWtwSUh0Y2JseDBYSFJ5WlhSMWNtNGdUblZ0WW1WeUxtbHpUbUZPTzF4dVhIUjlYRzVjZEhKbGRIVnliaUJwYlhCc1pXMWxiblJoZEdsdmJqdGNibjA3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUJrWldacGJtVWdQU0J5WlhGMWFYSmxLQ2RrWldacGJtVXRjSEp2Y0dWeWRHbGxjeWNwTzF4dWRtRnlJR2RsZEZCdmJIbG1hV3hzSUQwZ2NtVnhkV2x5WlNnbkxpOXdiMng1Wm1sc2JDY3BPMXh1WEc0dktpQm9kSFJ3T2k4dmQzZDNMbVZqYldFdGFXNTBaWEp1WVhScGIyNWhiQzV2Y21jdlpXTnRZUzB5TmpJdk5pNHdMeU56WldNdGJuVnRZbVZ5TG1semJtRnVJQ292WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z2MyaHBiVTUxYldKbGNrbHpUbUZPS0NrZ2UxeHVYSFIyWVhJZ2NHOXNlV1pwYkd3Z1BTQm5aWFJRYjJ4NVptbHNiQ2dwTzF4dVhIUmtaV1pwYm1Vb1RuVnRZbVZ5TENCN0lHbHpUbUZPT2lCd2IyeDVabWxzYkNCOUxDQjdYRzVjZEZ4MGFYTk9ZVTQ2SUdaMWJtTjBhVzl1SUhSbGMzUkpjMDVoVGlncElIdGNibHgwWEhSY2RISmxkSFZ5YmlCT2RXMWlaWEl1YVhOT1lVNGdJVDA5SUhCdmJIbG1hV3hzTzF4dVhIUmNkSDFjYmx4MGZTazdYRzVjZEhKbGRIVnliaUJ3YjJ4NVptbHNiRHRjYm4wN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCbWIzSkZZV05vSUQwZ2NtVnhkV2x5WlNnblptOXlaV0ZqYUNjcE8xeHVkbUZ5SUdGMllXbHNZV0pzWlZSNWNHVmtRWEp5WVhseklEMGdjbVZ4ZFdseVpTZ25ZWFpoYVd4aFlteGxMWFI1Y0dWa0xXRnljbUY1Y3ljcE8xeHVkbUZ5SUdOaGJHeENiM1Z1WkNBOUlISmxjWFZwY21Vb0oyTmhiR3d0WW1sdVpDOWpZV3hzUW05MWJtUW5LVHRjYmx4dWRtRnlJQ1IwYjFOMGNtbHVaeUE5SUdOaGJHeENiM1Z1WkNnblQySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1WnljcE8xeHVkbUZ5SUdoaGMxTjViV0p2YkhNZ1BTQnlaWEYxYVhKbEtDZG9ZWE10YzNsdFltOXNjeWNwS0NrN1hHNTJZWElnYUdGelZHOVRkSEpwYm1kVVlXY2dQU0JvWVhOVGVXMWliMnh6SUNZbUlIUjVjR1Z2WmlCVGVXMWliMnd1ZEc5VGRISnBibWRVWVdjZ1BUMDlJQ2R6ZVcxaWIyd25PMXh1WEc1MllYSWdkSGx3WldSQmNuSmhlWE1nUFNCaGRtRnBiR0ZpYkdWVWVYQmxaRUZ5Y21GNWN5Z3BPMXh1WEc1MllYSWdKR2x1WkdWNFQyWWdQU0JqWVd4c1FtOTFibVFvSjBGeWNtRjVMbkJ5YjNSdmRIbHdaUzVwYm1SbGVFOW1KeXdnZEhKMVpTa2dmSHdnWm5WdVkzUnBiMjRnYVc1a1pYaFBaaWhoY25KaGVTd2dkbUZzZFdVcElIdGNibHgwWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCaGNuSmhlUzVzWlc1bmRHZzdJR2tnS3owZ01Ta2dlMXh1WEhSY2RHbG1JQ2hoY25KaGVWdHBYU0E5UFQwZ2RtRnNkV1VwSUh0Y2JseDBYSFJjZEhKbGRIVnliaUJwTzF4dVhIUmNkSDFjYmx4MGZWeHVYSFJ5WlhSMWNtNGdMVEU3WEc1OU8xeHVkbUZ5SUNSemJHbGpaU0E5SUdOaGJHeENiM1Z1WkNnblUzUnlhVzVuTG5CeWIzUnZkSGx3WlM1emJHbGpaU2NwTzF4dWRtRnlJSFJ2VTNSeVZHRm5jeUE5SUh0OU8xeHVkbUZ5SUdkUFVFUWdQU0J5WlhGMWFYSmxLQ2RsY3kxaFluTjBjbUZqZEM5b1pXeHdaWEp6TDJkbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaWNwTzF4dWRtRnlJR2RsZEZCeWIzUnZkSGx3WlU5bUlEMGdUMkpxWldOMExtZGxkRkJ5YjNSdmRIbHdaVTltT3lBdkx5QnlaWEYxYVhKbEtDZG5aWFJ3Y205MGIzUjVjR1Z2WmljcE8xeHVhV1lnS0doaGMxUnZVM1J5YVc1blZHRm5JQ1ltSUdkUFVFUWdKaVlnWjJWMFVISnZkRzkwZVhCbFQyWXBJSHRjYmx4MFptOXlSV0ZqYUNoMGVYQmxaRUZ5Y21GNWN5d2dablZ1WTNScGIyNGdLSFI1Y0dWa1FYSnlZWGtwSUh0Y2JseDBYSFIyWVhJZ1lYSnlJRDBnYm1WM0lHZHNiMkpoYkZ0MGVYQmxaRUZ5Y21GNVhTZ3BPMXh1WEhSY2RHbG1JQ2doS0ZONWJXSnZiQzUwYjFOMGNtbHVaMVJoWnlCcGJpQmhjbklwS1NCN1hHNWNkRngwWEhSMGFISnZkeUJ1WlhjZ1JYWmhiRVZ5Y205eUtDZDBhR2x6SUdWdVoybHVaU0JvWVhNZ2MzVndjRzl5ZENCbWIzSWdVM2x0WW05c0xuUnZVM1J5YVc1blZHRm5MQ0JpZFhRZ0p5QXJJSFI1Y0dWa1FYSnlZWGtnS3lBbklHUnZaWE1nYm05MElHaGhkbVVnZEdobElIQnliM0JsY25SNUlTQlFiR1ZoYzJVZ2NtVndiM0owSUhSb2FYTXVKeWs3WEc1Y2RGeDBmVnh1WEhSY2RIWmhjaUJ3Y205MGJ5QTlJR2RsZEZCeWIzUnZkSGx3WlU5bUtHRnljaWs3WEc1Y2RGeDBkbUZ5SUdSbGMyTnlhWEIwYjNJZ1BTQm5UMUJFS0hCeWIzUnZMQ0JUZVcxaWIyd3VkRzlUZEhKcGJtZFVZV2NwTzF4dVhIUmNkR2xtSUNnaFpHVnpZM0pwY0hSdmNpa2dlMXh1WEhSY2RGeDBkbUZ5SUhOMWNHVnlVSEp2ZEc4Z1BTQm5aWFJRY205MGIzUjVjR1ZQWmlod2NtOTBieWs3WEc1Y2RGeDBYSFJrWlhOamNtbHdkRzl5SUQwZ1owOVFSQ2h6ZFhCbGNsQnliM1J2TENCVGVXMWliMnd1ZEc5VGRISnBibWRVWVdjcE8xeHVYSFJjZEgxY2JseDBYSFIwYjFOMGNsUmhaM05iZEhsd1pXUkJjbkpoZVYwZ1BTQmtaWE5qY21sd2RHOXlMbWRsZER0Y2JseDBmU2s3WEc1OVhHNWNiblpoY2lCMGNubFVlWEJsWkVGeWNtRjVjeUE5SUdaMWJtTjBhVzl1SUhSeWVVRnNiRlI1Y0dWa1FYSnlZWGx6S0haaGJIVmxLU0I3WEc1Y2RIWmhjaUJoYm5sVWNuVmxJRDBnWm1Gc2MyVTdYRzVjZEdadmNrVmhZMmdvZEc5VGRISlVZV2R6TENCbWRXNWpkR2x2YmlBb1oyVjBkR1Z5TENCMGVYQmxaRUZ5Y21GNUtTQjdYRzVjZEZ4MGFXWWdLQ0ZoYm5sVWNuVmxLU0I3WEc1Y2RGeDBYSFIwY25rZ2UxeHVYSFJjZEZ4MFhIUmhibmxVY25WbElEMGdaMlYwZEdWeUxtTmhiR3dvZG1Gc2RXVXBJRDA5UFNCMGVYQmxaRUZ5Y21GNU8xeHVYSFJjZEZ4MGZTQmpZWFJqYUNBb1pTa2dleUF2S2lvdklIMWNibHgwWEhSOVhHNWNkSDBwTzF4dVhIUnlaWFIxY200Z1lXNTVWSEoxWlR0Y2JuMDdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnYVhOVWVYQmxaRUZ5Y21GNUtIWmhiSFZsS1NCN1hHNWNkR2xtSUNnaGRtRnNkV1VnZkh3Z2RIbHdaVzltSUhaaGJIVmxJQ0U5UFNBbmIySnFaV04wSnlrZ2V5QnlaWFIxY200Z1ptRnNjMlU3SUgxY2JseDBhV1lnS0NGb1lYTlViMU4wY21sdVoxUmhaeWtnZTF4dVhIUmNkSFpoY2lCMFlXY2dQU0FrYzJ4cFkyVW9KSFJ2VTNSeWFXNW5LSFpoYkhWbEtTd2dPQ3dnTFRFcE8xeHVYSFJjZEhKbGRIVnliaUFrYVc1a1pYaFBaaWgwZVhCbFpFRnljbUY1Y3l3Z2RHRm5LU0ErSUMweE8xeHVYSFI5WEc1Y2RHbG1JQ2doWjA5UVJDa2dleUJ5WlhSMWNtNGdabUZzYzJVN0lIMWNibHgwY21WMGRYSnVJSFJ5ZVZSNWNHVmtRWEp5WVhsektIWmhiSFZsS1R0Y2JuMDdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQnVkVzFpWlhKSmMwNWhUaUE5SUdaMWJtTjBhVzl1SUNoMllXeDFaU2tnZTF4dVhIUnlaWFIxY200Z2RtRnNkV1VnSVQwOUlIWmhiSFZsTzF4dWZUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJwY3loaExDQmlLU0I3WEc1Y2RHbG1JQ2hoSUQwOVBTQXdJQ1ltSUdJZ1BUMDlJREFwSUh0Y2JseDBYSFJ5WlhSMWNtNGdNU0F2SUdFZ1BUMDlJREVnTHlCaU8xeHVYSFI5WEc1Y2RHbG1JQ2hoSUQwOVBTQmlLU0I3WEc1Y2RGeDBjbVYwZFhKdUlIUnlkV1U3WEc1Y2RIMWNibHgwYVdZZ0tHNTFiV0psY2tselRtRk9LR0VwSUNZbUlHNTFiV0psY2tselRtRk9LR0lwS1NCN1hHNWNkRngwY21WMGRYSnVJSFJ5ZFdVN1hHNWNkSDFjYmx4MGNtVjBkWEp1SUdaaGJITmxPMXh1ZlR0Y2JseHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ1pHVm1hVzVsSUQwZ2NtVnhkV2x5WlNnblpHVm1hVzVsTFhCeWIzQmxjblJwWlhNbktUdGNiblpoY2lCallXeHNRbWx1WkNBOUlISmxjWFZwY21Vb0oyTmhiR3d0WW1sdVpDY3BPMXh1WEc1MllYSWdhVzF3YkdWdFpXNTBZWFJwYjI0Z1BTQnlaWEYxYVhKbEtDY3VMMmx0Y0d4bGJXVnVkR0YwYVc5dUp5azdYRzUyWVhJZ1oyVjBVRzlzZVdacGJHd2dQU0J5WlhGMWFYSmxLQ2N1TDNCdmJIbG1hV3hzSnlrN1hHNTJZWElnYzJocGJTQTlJSEpsY1hWcGNtVW9KeTR2YzJocGJTY3BPMXh1WEc1MllYSWdjRzlzZVdacGJHd2dQU0JqWVd4c1FtbHVaQ2huWlhSUWIyeDVabWxzYkNncExDQlBZbXBsWTNRcE8xeHVYRzVrWldacGJtVW9jRzlzZVdacGJHd3NJSHRjYmx4MFoyVjBVRzlzZVdacGJHdzZJR2RsZEZCdmJIbG1hV3hzTEZ4dVhIUnBiWEJzWlcxbGJuUmhkR2x2YmpvZ2FXMXdiR1Z0Wlc1MFlYUnBiMjRzWEc1Y2RITm9hVzA2SUhOb2FXMWNibjBwTzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlIQnZiSGxtYVd4c08xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ2FXMXdiR1Z0Wlc1MFlYUnBiMjRnUFNCeVpYRjFhWEpsS0NjdUwybHRjR3hsYldWdWRHRjBhVzl1SnlrN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdaMlYwVUc5c2VXWnBiR3dvS1NCN1hHNWNkSEpsZEhWeWJpQjBlWEJsYjJZZ1QySnFaV04wTG1seklEMDlQU0FuWm5WdVkzUnBiMjRuSUQ4Z1QySnFaV04wTG1seklEb2dhVzF3YkdWdFpXNTBZWFJwYjI0N1hHNTlPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdaMlYwVUc5c2VXWnBiR3dnUFNCeVpYRjFhWEpsS0NjdUwzQnZiSGxtYVd4c0p5azdYRzUyWVhJZ1pHVm1hVzVsSUQwZ2NtVnhkV2x5WlNnblpHVm1hVzVsTFhCeWIzQmxjblJwWlhNbktUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJ6YUdsdFQySnFaV04wU1hNb0tTQjdYRzVjZEhaaGNpQndiMng1Wm1sc2JDQTlJR2RsZEZCdmJIbG1hV3hzS0NrN1hHNWNkR1JsWm1sdVpTaFBZbXBsWTNRc0lIc2dhWE02SUhCdmJIbG1hV3hzSUgwc0lIdGNibHgwWEhScGN6b2dablZ1WTNScGIyNGdkR1Z6ZEU5aWFtVmpkRWx6S0NrZ2UxeHVYSFJjZEZ4MGNtVjBkWEp1SUU5aWFtVmpkQzVwY3lBaFBUMGdjRzlzZVdacGJHdzdYRzVjZEZ4MGZWeHVYSFI5S1R0Y2JseDBjbVYwZFhKdUlIQnZiSGxtYVd4c08xeHVmVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dWRtRnlJR3RsZVhOVGFHbHRPMXh1YVdZZ0tDRlBZbXBsWTNRdWEyVjVjeWtnZTF4dVhIUXZMeUJ0YjJScFptbGxaQ0JtY205dElHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOWxjeTF6YUdsdGN5OWxjelV0YzJocGJWeHVYSFIyWVhJZ2FHRnpJRDBnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzVvWVhOUGQyNVFjbTl3WlhKMGVUdGNibHgwZG1GeUlIUnZVM1J5SUQwZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1Wnp0Y2JseDBkbUZ5SUdselFYSm5jeUE5SUhKbGNYVnBjbVVvSnk0dmFYTkJjbWQxYldWdWRITW5LVHNnTHk4Z1pYTnNhVzUwTFdScGMyRmliR1V0YkdsdVpTQm5iRzlpWVd3dGNtVnhkV2x5WlZ4dVhIUjJZWElnYVhORmJuVnRaWEpoWW14bElEMGdUMkpxWldOMExuQnliM1J2ZEhsd1pTNXdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaVHRjYmx4MGRtRnlJR2hoYzBSdmJuUkZiblZ0UW5WbklEMGdJV2x6Ulc1MWJXVnlZV0pzWlM1allXeHNLSHNnZEc5VGRISnBibWM2SUc1MWJHd2dmU3dnSjNSdlUzUnlhVzVuSnlrN1hHNWNkSFpoY2lCb1lYTlFjbTkwYjBWdWRXMUNkV2NnUFNCcGMwVnVkVzFsY21GaWJHVXVZMkZzYkNobWRXNWpkR2x2YmlBb0tTQjdmU3dnSjNCeWIzUnZkSGx3WlNjcE8xeHVYSFIyWVhJZ1pHOXVkRVZ1ZFcxeklEMGdXMXh1WEhSY2RDZDBiMU4wY21sdVp5Y3NYRzVjZEZ4MEozUnZURzlqWVd4bFUzUnlhVzVuSnl4Y2JseDBYSFFuZG1Gc2RXVlBaaWNzWEc1Y2RGeDBKMmhoYzA5M2JsQnliM0JsY25SNUp5eGNibHgwWEhRbmFYTlFjbTkwYjNSNWNHVlBaaWNzWEc1Y2RGeDBKM0J5YjNCbGNuUjVTWE5GYm5WdFpYSmhZbXhsSnl4Y2JseDBYSFFuWTI5dWMzUnlkV04wYjNJblhHNWNkRjA3WEc1Y2RIWmhjaUJsY1hWaGJITkRiMjV6ZEhKMVkzUnZjbEJ5YjNSdmRIbHdaU0E5SUdaMWJtTjBhVzl1SUNodktTQjdYRzVjZEZ4MGRtRnlJR04wYjNJZ1BTQnZMbU52Ym5OMGNuVmpkRzl5TzF4dVhIUmNkSEpsZEhWeWJpQmpkRzl5SUNZbUlHTjBiM0l1Y0hKdmRHOTBlWEJsSUQwOVBTQnZPMXh1WEhSOU8xeHVYSFIyWVhJZ1pYaGpiSFZrWldSTFpYbHpJRDBnZTF4dVhIUmNkQ1JoY0hCc2FXTmhkR2x2YmtOaFkyaGxPaUIwY25WbExGeHVYSFJjZENSamIyNXpiMnhsT2lCMGNuVmxMRnh1WEhSY2RDUmxlSFJsY201aGJEb2dkSEoxWlN4Y2JseDBYSFFrWm5KaGJXVTZJSFJ5ZFdVc1hHNWNkRngwSkdaeVlXMWxSV3hsYldWdWREb2dkSEoxWlN4Y2JseDBYSFFrWm5KaGJXVnpPaUIwY25WbExGeHVYSFJjZENScGJtNWxja2hsYVdkb2REb2dkSEoxWlN4Y2JseDBYSFFrYVc1dVpYSlhhV1IwYURvZ2RISjFaU3hjYmx4MFhIUWtiMjV0YjNwbWRXeHNjMk55WldWdVkyaGhibWRsT2lCMGNuVmxMRnh1WEhSY2RDUnZibTF2ZW1aMWJHeHpZM0psWlc1bGNuSnZjam9nZEhKMVpTeGNibHgwWEhRa2IzVjBaWEpJWldsbmFIUTZJSFJ5ZFdVc1hHNWNkRngwSkc5MWRHVnlWMmxrZEdnNklIUnlkV1VzWEc1Y2RGeDBKSEJoWjJWWVQyWm1jMlYwT2lCMGNuVmxMRnh1WEhSY2RDUndZV2RsV1U5bVpuTmxkRG9nZEhKMVpTeGNibHgwWEhRa2NHRnlaVzUwT2lCMGNuVmxMRnh1WEhSY2RDUnpZM0p2Ykd4TVpXWjBPaUIwY25WbExGeHVYSFJjZENSelkzSnZiR3hVYjNBNklIUnlkV1VzWEc1Y2RGeDBKSE5qY205c2JGZzZJSFJ5ZFdVc1hHNWNkRngwSkhOamNtOXNiRms2SUhSeWRXVXNYRzVjZEZ4MEpITmxiR1k2SUhSeWRXVXNYRzVjZEZ4MEpIZGxZbXRwZEVsdVpHVjRaV1JFUWpvZ2RISjFaU3hjYmx4MFhIUWtkMlZpYTJsMFUzUnZjbUZuWlVsdVptODZJSFJ5ZFdVc1hHNWNkRngwSkhkcGJtUnZkem9nZEhKMVpWeHVYSFI5TzF4dVhIUjJZWElnYUdGelFYVjBiMjFoZEdsdmJrVnhkV0ZzYVhSNVFuVm5JRDBnS0daMWJtTjBhVzl1SUNncElIdGNibHgwWEhRdktpQm5iRzlpWVd3Z2QybHVaRzkzSUNvdlhHNWNkRngwYVdZZ0tIUjVjR1Z2WmlCM2FXNWtiM2NnUFQwOUlDZDFibVJsWm1sdVpXUW5LU0I3SUhKbGRIVnliaUJtWVd4elpUc2dmVnh1WEhSY2RHWnZjaUFvZG1GeUlHc2dhVzRnZDJsdVpHOTNLU0I3WEc1Y2RGeDBYSFIwY25rZ2UxeHVYSFJjZEZ4MFhIUnBaaUFvSVdWNFkyeDFaR1ZrUzJWNWMxc25KQ2NnS3lCclhTQW1KaUJvWVhNdVkyRnNiQ2gzYVc1a2IzY3NJR3NwSUNZbUlIZHBibVJ2ZDF0clhTQWhQVDBnYm5Wc2JDQW1KaUIwZVhCbGIyWWdkMmx1Wkc5M1cydGRJRDA5UFNBbmIySnFaV04wSnlrZ2UxeHVYSFJjZEZ4MFhIUmNkSFJ5ZVNCN1hHNWNkRngwWEhSY2RGeDBYSFJsY1hWaGJITkRiMjV6ZEhKMVkzUnZjbEJ5YjNSdmRIbHdaU2gzYVc1a2IzZGJhMTBwTzF4dVhIUmNkRngwWEhSY2RIMGdZMkYwWTJnZ0tHVXBJSHRjYmx4MFhIUmNkRngwWEhSY2RISmxkSFZ5YmlCMGNuVmxPMXh1WEhSY2RGeDBYSFJjZEgxY2JseDBYSFJjZEZ4MGZWeHVYSFJjZEZ4MGZTQmpZWFJqYUNBb1pTa2dlMXh1WEhSY2RGeDBYSFJ5WlhSMWNtNGdkSEoxWlR0Y2JseDBYSFJjZEgxY2JseDBYSFI5WEc1Y2RGeDBjbVYwZFhKdUlHWmhiSE5sTzF4dVhIUjlLQ2twTzF4dVhIUjJZWElnWlhGMVlXeHpRMjl1YzNSeWRXTjBiM0pRY205MGIzUjVjR1ZKWms1dmRFSjFaMmQ1SUQwZ1puVnVZM1JwYjI0Z0tHOHBJSHRjYmx4MFhIUXZLaUJuYkc5aVlXd2dkMmx1Wkc5M0lDb3ZYRzVjZEZ4MGFXWWdLSFI1Y0dWdlppQjNhVzVrYjNjZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUh4OElDRm9ZWE5CZFhSdmJXRjBhVzl1UlhGMVlXeHBkSGxDZFdjcElIdGNibHgwWEhSY2RISmxkSFZ5YmlCbGNYVmhiSE5EYjI1emRISjFZM1J2Y2xCeWIzUnZkSGx3WlNodktUdGNibHgwWEhSOVhHNWNkRngwZEhKNUlIdGNibHgwWEhSY2RISmxkSFZ5YmlCbGNYVmhiSE5EYjI1emRISjFZM1J2Y2xCeWIzUnZkSGx3WlNodktUdGNibHgwWEhSOUlHTmhkR05vSUNobEtTQjdYRzVjZEZ4MFhIUnlaWFIxY200Z1ptRnNjMlU3WEc1Y2RGeDBmVnh1WEhSOU8xeHVYRzVjZEd0bGVYTlRhR2x0SUQwZ1puVnVZM1JwYjI0Z2EyVjVjeWh2WW1wbFkzUXBJSHRjYmx4MFhIUjJZWElnYVhOUFltcGxZM1FnUFNCdlltcGxZM1FnSVQwOUlHNTFiR3dnSmlZZ2RIbHdaVzltSUc5aWFtVmpkQ0E5UFQwZ0oyOWlhbVZqZENjN1hHNWNkRngwZG1GeUlHbHpSblZ1WTNScGIyNGdQU0IwYjFOMGNpNWpZV3hzS0c5aWFtVmpkQ2tnUFQwOUlDZGJiMkpxWldOMElFWjFibU4wYVc5dVhTYzdYRzVjZEZ4MGRtRnlJR2x6UVhKbmRXMWxiblJ6SUQwZ2FYTkJjbWR6S0c5aWFtVmpkQ2s3WEc1Y2RGeDBkbUZ5SUdselUzUnlhVzVuSUQwZ2FYTlBZbXBsWTNRZ0ppWWdkRzlUZEhJdVkyRnNiQ2h2WW1wbFkzUXBJRDA5UFNBblcyOWlhbVZqZENCVGRISnBibWRkSnp0Y2JseDBYSFIyWVhJZ2RHaGxTMlY1Y3lBOUlGdGRPMXh1WEc1Y2RGeDBhV1lnS0NGcGMwOWlhbVZqZENBbUppQWhhWE5HZFc1amRHbHZiaUFtSmlBaGFYTkJjbWQxYldWdWRITXBJSHRjYmx4MFhIUmNkSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjA5aWFtVmpkQzVyWlhseklHTmhiR3hsWkNCdmJpQmhJRzV2YmkxdlltcGxZM1FuS1R0Y2JseDBYSFI5WEc1Y2JseDBYSFIyWVhJZ2MydHBjRkJ5YjNSdklEMGdhR0Z6VUhKdmRHOUZiblZ0UW5WbklDWW1JR2x6Um5WdVkzUnBiMjQ3WEc1Y2RGeDBhV1lnS0dselUzUnlhVzVuSUNZbUlHOWlhbVZqZEM1c1pXNW5kR2dnUGlBd0lDWW1JQ0ZvWVhNdVkyRnNiQ2h2WW1wbFkzUXNJREFwS1NCN1hHNWNkRngwWEhSbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHOWlhbVZqZEM1c1pXNW5kR2c3SUNzcmFTa2dlMXh1WEhSY2RGeDBYSFIwYUdWTFpYbHpMbkIxYzJnb1UzUnlhVzVuS0drcEtUdGNibHgwWEhSY2RIMWNibHgwWEhSOVhHNWNibHgwWEhScFppQW9hWE5CY21kMWJXVnVkSE1nSmlZZ2IySnFaV04wTG14bGJtZDBhQ0ErSURBcElIdGNibHgwWEhSY2RHWnZjaUFvZG1GeUlHb2dQU0F3T3lCcUlEd2diMkpxWldOMExteGxibWQwYURzZ0t5dHFLU0I3WEc1Y2RGeDBYSFJjZEhSb1pVdGxlWE11Y0hWemFDaFRkSEpwYm1jb2Fpa3BPMXh1WEhSY2RGeDBmVnh1WEhSY2RIMGdaV3h6WlNCN1hHNWNkRngwWEhSbWIzSWdLSFpoY2lCdVlXMWxJR2x1SUc5aWFtVmpkQ2tnZTF4dVhIUmNkRngwWEhScFppQW9JU2h6YTJsd1VISnZkRzhnSmlZZ2JtRnRaU0E5UFQwZ0ozQnliM1J2ZEhsd1pTY3BJQ1ltSUdoaGN5NWpZV3hzS0c5aWFtVmpkQ3dnYm1GdFpTa3BJSHRjYmx4MFhIUmNkRngwWEhSMGFHVkxaWGx6TG5CMWMyZ29VM1J5YVc1bktHNWhiV1VwS1R0Y2JseDBYSFJjZEZ4MGZWeHVYSFJjZEZ4MGZWeHVYSFJjZEgxY2JseHVYSFJjZEdsbUlDaG9ZWE5FYjI1MFJXNTFiVUoxWnlrZ2UxeHVYSFJjZEZ4MGRtRnlJSE5yYVhCRGIyNXpkSEoxWTNSdmNpQTlJR1Z4ZFdGc2MwTnZibk4wY25WamRHOXlVSEp2ZEc5MGVYQmxTV1pPYjNSQ2RXZG5lU2h2WW1wbFkzUXBPMXh1WEc1Y2RGeDBYSFJtYjNJZ0tIWmhjaUJySUQwZ01Ec2dheUE4SUdSdmJuUkZiblZ0Y3k1c1pXNW5kR2c3SUNzcmF5a2dlMXh1WEhSY2RGeDBYSFJwWmlBb0lTaHphMmx3UTI5dWMzUnlkV04wYjNJZ0ppWWdaRzl1ZEVWdWRXMXpXMnRkSUQwOVBTQW5ZMjl1YzNSeWRXTjBiM0luS1NBbUppQm9ZWE11WTJGc2JDaHZZbXBsWTNRc0lHUnZiblJGYm5WdGMxdHJYU2twSUh0Y2JseDBYSFJjZEZ4MFhIUjBhR1ZMWlhsekxuQjFjMmdvWkc5dWRFVnVkVzF6VzJ0ZEtUdGNibHgwWEhSY2RGeDBmVnh1WEhSY2RGeDBmVnh1WEhSY2RIMWNibHgwWEhSeVpYUjFjbTRnZEdobFMyVjVjenRjYmx4MGZUdGNibjFjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnYTJWNWMxTm9hVzA3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUJ6YkdsalpTQTlJRUZ5Y21GNUxuQnliM1J2ZEhsd1pTNXpiR2xqWlR0Y2JuWmhjaUJwYzBGeVozTWdQU0J5WlhGMWFYSmxLQ2N1TDJselFYSm5kVzFsYm5Sekp5azdYRzVjYm5aaGNpQnZjbWxuUzJWNWN5QTlJRTlpYW1WamRDNXJaWGx6TzF4dWRtRnlJR3RsZVhOVGFHbHRJRDBnYjNKcFowdGxlWE1nUHlCbWRXNWpkR2x2YmlCclpYbHpLRzhwSUhzZ2NtVjBkWEp1SUc5eWFXZExaWGx6S0c4cE95QjlJRG9nY21WeGRXbHlaU2duTGk5cGJYQnNaVzFsYm5SaGRHbHZiaWNwTzF4dVhHNTJZWElnYjNKcFoybHVZV3hMWlhseklEMGdUMkpxWldOMExtdGxlWE03WEc1Y2JtdGxlWE5UYUdsdExuTm9hVzBnUFNCbWRXNWpkR2x2YmlCemFHbHRUMkpxWldOMFMyVjVjeWdwSUh0Y2JseDBhV1lnS0U5aWFtVmpkQzVyWlhsektTQjdYRzVjZEZ4MGRtRnlJR3RsZVhOWGIzSnJjMWRwZEdoQmNtZDFiV1Z1ZEhNZ1BTQW9ablZ1WTNScGIyNGdLQ2tnZTF4dVhIUmNkRngwTHk4Z1UyRm1ZWEpwSURVdU1DQmlkV2RjYmx4MFhIUmNkSFpoY2lCaGNtZHpJRDBnVDJKcVpXTjBMbXRsZVhNb1lYSm5kVzFsYm5SektUdGNibHgwWEhSY2RISmxkSFZ5YmlCaGNtZHpJQ1ltSUdGeVozTXViR1Z1WjNSb0lEMDlQU0JoY21kMWJXVnVkSE11YkdWdVozUm9PMXh1WEhSY2RIMG9NU3dnTWlrcE8xeHVYSFJjZEdsbUlDZ2hhMlY1YzFkdmNtdHpWMmwwYUVGeVozVnRaVzUwY3lrZ2UxeHVYSFJjZEZ4MFQySnFaV04wTG10bGVYTWdQU0JtZFc1amRHbHZiaUJyWlhsektHOWlhbVZqZENrZ2V5QXZMeUJsYzJ4cGJuUXRaR2x6WVdKc1pTMXNhVzVsSUdaMWJtTXRibUZ0WlMxdFlYUmphR2x1WjF4dVhIUmNkRngwWEhScFppQW9hWE5CY21kektHOWlhbVZqZENrcElIdGNibHgwWEhSY2RGeDBYSFJ5WlhSMWNtNGdiM0pwWjJsdVlXeExaWGx6S0hOc2FXTmxMbU5oYkd3b2IySnFaV04wS1NrN1hHNWNkRngwWEhSY2RIMWNibHgwWEhSY2RGeDBjbVYwZFhKdUlHOXlhV2RwYm1Gc1MyVjVjeWh2WW1wbFkzUXBPMXh1WEhSY2RGeDBmVHRjYmx4MFhIUjlYRzVjZEgwZ1pXeHpaU0I3WEc1Y2RGeDBUMkpxWldOMExtdGxlWE1nUFNCclpYbHpVMmhwYlR0Y2JseDBmVnh1WEhSeVpYUjFjbTRnVDJKcVpXTjBMbXRsZVhNZ2ZId2dhMlY1YzFOb2FXMDdYRzU5TzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHdGxlWE5UYUdsdE8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ2RHOVRkSElnUFNCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlHbHpRWEpuZFcxbGJuUnpLSFpoYkhWbEtTQjdYRzVjZEhaaGNpQnpkSElnUFNCMGIxTjBjaTVqWVd4c0tIWmhiSFZsS1R0Y2JseDBkbUZ5SUdselFYSm5jeUE5SUhOMGNpQTlQVDBnSjF0dlltcGxZM1FnUVhKbmRXMWxiblJ6WFNjN1hHNWNkR2xtSUNnaGFYTkJjbWR6S1NCN1hHNWNkRngwYVhOQmNtZHpJRDBnYzNSeUlDRTlQU0FuVzI5aWFtVmpkQ0JCY25KaGVWMG5JQ1ltWEc1Y2RGeDBYSFIyWVd4MVpTQWhQVDBnYm5Wc2JDQW1KbHh1WEhSY2RGeDBkSGx3Wlc5bUlIWmhiSFZsSUQwOVBTQW5iMkpxWldOMEp5QW1KbHh1WEhSY2RGeDBkSGx3Wlc5bUlIWmhiSFZsTG14bGJtZDBhQ0E5UFQwZ0oyNTFiV0psY2ljZ0ppWmNibHgwWEhSY2RIWmhiSFZsTG14bGJtZDBhQ0ErUFNBd0lDWW1YRzVjZEZ4MFhIUjBiMU4wY2k1allXeHNLSFpoYkhWbExtTmhiR3hsWlNrZ1BUMDlJQ2RiYjJKcVpXTjBJRVoxYm1OMGFXOXVYU2M3WEc1Y2RIMWNibHgwY21WMGRYSnVJR2x6UVhKbmN6dGNibjA3WEc0aUxDSXZMeUJ6YUdsdElHWnZjaUIxYzJsdVp5QndjbTlqWlhOeklHbHVJR0p5YjNkelpYSmNiblpoY2lCd2NtOWpaWE56SUQwZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN2ZUdGNibHh1THk4Z1kyRmphR1ZrSUdaeWIyMGdkMmhoZEdWMlpYSWdaMnh2WW1Gc0lHbHpJSEJ5WlhObGJuUWdjMjhnZEdoaGRDQjBaWE4wSUhKMWJtNWxjbk1nZEdoaGRDQnpkSFZpSUdsMFhHNHZMeUJrYjI0bmRDQmljbVZoYXlCMGFHbHVaM011SUNCQ2RYUWdkMlVnYm1WbFpDQjBieUIzY21Gd0lHbDBJR2x1SUdFZ2RISjVJR05oZEdOb0lHbHVJR05oYzJVZ2FYUWdhWE5jYmk4dklIZHlZWEJ3WldRZ2FXNGdjM1J5YVdOMElHMXZaR1VnWTI5a1pTQjNhR2xqYUNCa2IyVnpiaWQwSUdSbFptbHVaU0JoYm5rZ1oyeHZZbUZzY3k0Z0lFbDBKM01nYVc1emFXUmxJR0ZjYmk4dklHWjFibU4wYVc5dUlHSmxZMkYxYzJVZ2RISjVMMk5oZEdOb1pYTWdaR1Z2Y0hScGJXbDZaU0JwYmlCalpYSjBZV2x1SUdWdVoybHVaWE11WEc1Y2JuWmhjaUJqWVdOb1pXUlRaWFJVYVcxbGIzVjBPMXh1ZG1GeUlHTmhZMmhsWkVOc1pXRnlWR2x0Wlc5MWREdGNibHh1Wm5WdVkzUnBiMjRnWkdWbVlYVnNkRk5sZEZScGJXOTFkQ2dwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KM05sZEZScGJXVnZkWFFnYUdGeklHNXZkQ0JpWldWdUlHUmxabWx1WldRbktUdGNibjFjYm1aMWJtTjBhVzl1SUdSbFptRjFiSFJEYkdWaGNsUnBiV1Z2ZFhRZ0tDa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lnblkyeGxZWEpVYVcxbGIzVjBJR2hoY3lCdWIzUWdZbVZsYmlCa1pXWnBibVZrSnlrN1hHNTlYRzRvWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0FnSUhSeWVTQjdYRzRnSUNBZ0lDQWdJR2xtSUNoMGVYQmxiMllnYzJWMFZHbHRaVzkxZENBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDQTlJSE5sZEZScGJXVnZkWFE3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZV05vWldSVFpYUlVhVzFsYjNWMElEMGdaR1ZtWVhWc2RGTmxkRlJwYlc5MWREdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHRjYmlBZ0lDQWdJQ0FnWTJGamFHVmtVMlYwVkdsdFpXOTFkQ0E5SUdSbFptRjFiSFJUWlhSVWFXMXZkWFE3WEc0Z0lDQWdmVnh1SUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ1kyeGxZWEpVYVcxbGIzVjBJRDA5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCallXTm9aV1JEYkdWaGNsUnBiV1Z2ZFhRZ1BTQmpiR1ZoY2xScGJXVnZkWFE3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQU0JrWldaaGRXeDBRMnhsWVhKVWFXMWxiM1YwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnZlNCallYUmphQ0FvWlNrZ2UxeHVJQ0FnSUNBZ0lDQmpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQU0JrWldaaGRXeDBRMnhsWVhKVWFXMWxiM1YwTzF4dUlDQWdJSDFjYm4wZ0tDa3BYRzVtZFc1amRHbHZiaUJ5ZFc1VWFXMWxiM1YwS0daMWJpa2dlMXh1SUNBZ0lHbG1JQ2hqWVdOb1pXUlRaWFJVYVcxbGIzVjBJRDA5UFNCelpYUlVhVzFsYjNWMEtTQjdYRzRnSUNBZ0lDQWdJQzh2Ym05eWJXRnNJR1Z1ZG1seWIyMWxiblJ6SUdsdUlITmhibVVnYzJsMGRXRjBhVzl1YzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYzJWMFZHbHRaVzkxZENobWRXNHNJREFwTzF4dUlDQWdJSDFjYmlBZ0lDQXZMeUJwWmlCelpYUlVhVzFsYjNWMElIZGhjMjRuZENCaGRtRnBiR0ZpYkdVZ1luVjBJSGRoY3lCc1lYUjBaWElnWkdWbWFXNWxaRnh1SUNBZ0lHbG1JQ2dvWTJGamFHVmtVMlYwVkdsdFpXOTFkQ0E5UFQwZ1pHVm1ZWFZzZEZObGRGUnBiVzkxZENCOGZDQWhZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDa2dKaVlnYzJWMFZHbHRaVzkxZENrZ2UxeHVJQ0FnSUNBZ0lDQmpZV05vWldSVFpYUlVhVzFsYjNWMElEMGdjMlYwVkdsdFpXOTFkRHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSE5sZEZScGJXVnZkWFFvWm5WdUxDQXdLVHRjYmlBZ0lDQjlYRzRnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnTHk4Z2QyaGxiaUIzYUdWdUlITnZiV1ZpYjJSNUlHaGhjeUJ6WTNKbGQyVmtJSGRwZEdnZ2MyVjBWR2x0Wlc5MWRDQmlkWFFnYm04Z1NTNUZMaUJ0WVdSa2JtVnpjMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDaG1kVzRzSURBcE8xeHVJQ0FnSUgwZ1kyRjBZMmdvWlNsN1hHNGdJQ0FnSUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQXZMeUJYYUdWdUlIZGxJR0Z5WlNCcGJpQkpMa1V1SUdKMWRDQjBhR1VnYzJOeWFYQjBJR2hoY3lCaVpXVnVJR1YyWVd4bFpDQnpieUJKTGtVdUlHUnZaWE51SjNRZ2RISjFjM1FnZEdobElHZHNiMkpoYkNCdlltcGxZM1FnZDJobGJpQmpZV3hzWldRZ2JtOXliV0ZzYkhsY2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQmpZV05vWldSVFpYUlVhVzFsYjNWMExtTmhiR3dvYm5Wc2JDd2dablZ1TENBd0tUdGNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDaGxLWHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJSE5oYldVZ1lYTWdZV0p2ZG1VZ1luVjBJSGRvWlc0Z2FYUW5jeUJoSUhabGNuTnBiMjRnYjJZZ1NTNUZMaUIwYUdGMElHMTFjM1FnYUdGMlpTQjBhR1VnWjJ4dlltRnNJRzlpYW1WamRDQm1iM0lnSjNSb2FYTW5MQ0JvYjNCbWRXeHNlU0J2ZFhJZ1kyOXVkR1Y0ZENCamIzSnlaV04wSUc5MGFHVnlkMmx6WlNCcGRDQjNhV3hzSUhSb2NtOTNJR0VnWjJ4dlltRnNJR1Z5Y205eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZMkZqYUdWa1UyVjBWR2x0Wlc5MWRDNWpZV3hzS0hSb2FYTXNJR1oxYml3Z01DazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmx4dWZWeHVablZ1WTNScGIyNGdjblZ1UTJ4bFlYSlVhVzFsYjNWMEtHMWhjbXRsY2lrZ2UxeHVJQ0FnSUdsbUlDaGpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQVDA5SUdOc1pXRnlWR2x0Wlc5MWRDa2dlMXh1SUNBZ0lDQWdJQ0F2TDI1dmNtMWhiQ0JsYm5acGNtOXRaVzUwY3lCcGJpQnpZVzVsSUhOcGRIVmhkR2x2Ym5OY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdOc1pXRnlWR2x0Wlc5MWRDaHRZWEpyWlhJcE8xeHVJQ0FnSUgxY2JpQWdJQ0F2THlCcFppQmpiR1ZoY2xScGJXVnZkWFFnZDJGemJpZDBJR0YyWVdsc1lXSnNaU0JpZFhRZ2QyRnpJR3hoZEhSbGNpQmtaV1pwYm1Wa1hHNGdJQ0FnYVdZZ0tDaGpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQVDA5SUdSbFptRjFiSFJEYkdWaGNsUnBiV1Z2ZFhRZ2ZId2dJV05oWTJobFpFTnNaV0Z5VkdsdFpXOTFkQ2tnSmlZZ1kyeGxZWEpVYVcxbGIzVjBLU0I3WEc0Z0lDQWdJQ0FnSUdOaFkyaGxaRU5zWldGeVZHbHRaVzkxZENBOUlHTnNaV0Z5VkdsdFpXOTFkRHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR05zWldGeVZHbHRaVzkxZENodFlYSnJaWElwTzF4dUlDQWdJSDFjYmlBZ0lDQjBjbmtnZTF4dUlDQWdJQ0FnSUNBdkx5QjNhR1Z1SUhkb1pXNGdjMjl0WldKdlpIa2dhR0Z6SUhOamNtVjNaV1FnZDJsMGFDQnpaWFJVYVcxbGIzVjBJR0oxZENCdWJ5QkpMa1V1SUcxaFpHUnVaWE56WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJqWVdOb1pXUkRiR1ZoY2xScGJXVnZkWFFvYldGeWEyVnlLVHRjYmlBZ0lDQjlJR05oZEdOb0lDaGxLWHRjYmlBZ0lDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklGZG9aVzRnZDJVZ1lYSmxJR2x1SUVrdVJTNGdZblYwSUhSb1pTQnpZM0pwY0hRZ2FHRnpJR0psWlc0Z1pYWmhiR1ZrSUhOdklFa3VSUzRnWkc5bGMyNG5kQ0FnZEhKMWMzUWdkR2hsSUdkc2IySmhiQ0J2WW1wbFkzUWdkMmhsYmlCallXeHNaV1FnYm05eWJXRnNiSGxjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCallXTm9aV1JEYkdWaGNsUnBiV1Z2ZFhRdVkyRnNiQ2h1ZFd4c0xDQnRZWEpyWlhJcE8xeHVJQ0FnSUNBZ0lDQjlJR05oZEdOb0lDaGxLWHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJSE5oYldVZ1lYTWdZV0p2ZG1VZ1luVjBJSGRvWlc0Z2FYUW5jeUJoSUhabGNuTnBiMjRnYjJZZ1NTNUZMaUIwYUdGMElHMTFjM1FnYUdGMlpTQjBhR1VnWjJ4dlltRnNJRzlpYW1WamRDQm1iM0lnSjNSb2FYTW5MQ0JvYjNCbWRXeHNlU0J2ZFhJZ1kyOXVkR1Y0ZENCamIzSnlaV04wSUc5MGFHVnlkMmx6WlNCcGRDQjNhV3hzSUhSb2NtOTNJR0VnWjJ4dlltRnNJR1Z5Y205eUxseHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z1UyOXRaU0IyWlhKemFXOXVjeUJ2WmlCSkxrVXVJR2hoZG1VZ1pHbG1abVZ5Wlc1MElISjFiR1Z6SUdadmNpQmpiR1ZoY2xScGJXVnZkWFFnZG5NZ2MyVjBWR2x0Wlc5MWRGeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR05oWTJobFpFTnNaV0Z5VkdsdFpXOTFkQzVqWVd4c0tIUm9hWE1zSUcxaGNtdGxjaWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JseHVYRzU5WEc1MllYSWdjWFZsZFdVZ1BTQmJYVHRjYm5aaGNpQmtjbUZwYm1sdVp5QTlJR1poYkhObE8xeHVkbUZ5SUdOMWNuSmxiblJSZFdWMVpUdGNiblpoY2lCeGRXVjFaVWx1WkdWNElEMGdMVEU3WEc1Y2JtWjFibU4wYVc5dUlHTnNaV0Z1VlhCT1pYaDBWR2xqYXlncElIdGNiaUFnSUNCcFppQW9JV1J5WVdsdWFXNW5JSHg4SUNGamRYSnlaVzUwVVhWbGRXVXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVPMXh1SUNBZ0lIMWNiaUFnSUNCa2NtRnBibWx1WnlBOUlHWmhiSE5sTzF4dUlDQWdJR2xtSUNoamRYSnlaVzUwVVhWbGRXVXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJSEYxWlhWbElEMGdZM1Z5Y21WdWRGRjFaWFZsTG1OdmJtTmhkQ2h4ZFdWMVpTazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2NYVmxkV1ZKYm1SbGVDQTlJQzB4TzF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvY1hWbGRXVXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJR1J5WVdsdVVYVmxkV1VvS1R0Y2JpQWdJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR1J5WVdsdVVYVmxkV1VvS1NCN1hHNGdJQ0FnYVdZZ0tHUnlZV2x1YVc1bktTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNCOVhHNGdJQ0FnZG1GeUlIUnBiV1Z2ZFhRZ1BTQnlkVzVVYVcxbGIzVjBLR05zWldGdVZYQk9aWGgwVkdsamF5azdYRzRnSUNBZ1pISmhhVzVwYm1jZ1BTQjBjblZsTzF4dVhHNGdJQ0FnZG1GeUlHeGxiaUE5SUhGMVpYVmxMbXhsYm1kMGFEdGNiaUFnSUNCM2FHbHNaU2hzWlc0cElIdGNiaUFnSUNBZ0lDQWdZM1Z5Y21WdWRGRjFaWFZsSUQwZ2NYVmxkV1U3WEc0Z0lDQWdJQ0FnSUhGMVpYVmxJRDBnVzEwN1hHNGdJQ0FnSUNBZ0lIZG9hV3hsSUNnckszRjFaWFZsU1c1a1pYZ2dQQ0JzWlc0cElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdsbUlDaGpkWEp5Wlc1MFVYVmxkV1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCamRYSnlaVzUwVVhWbGRXVmJjWFZsZFdWSmJtUmxlRjB1Y25WdUtDazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdjWFZsZFdWSmJtUmxlQ0E5SUMweE8xeHVJQ0FnSUNBZ0lDQnNaVzRnUFNCeGRXVjFaUzVzWlc1bmRHZzdYRzRnSUNBZ2ZWeHVJQ0FnSUdOMWNuSmxiblJSZFdWMVpTQTlJRzUxYkd3N1hHNGdJQ0FnWkhKaGFXNXBibWNnUFNCbVlXeHpaVHRjYmlBZ0lDQnlkVzVEYkdWaGNsUnBiV1Z2ZFhRb2RHbHRaVzkxZENrN1hHNTlYRzVjYm5CeWIyTmxjM011Ym1WNGRGUnBZMnNnUFNCbWRXNWpkR2x2YmlBb1puVnVLU0I3WEc0Z0lDQWdkbUZ5SUdGeVozTWdQU0J1WlhjZ1FYSnlZWGtvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0F0SURFcE8xeHVJQ0FnSUdsbUlDaGhjbWQxYldWdWRITXViR1Z1WjNSb0lENGdNU2tnZTF4dUlDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNVHNnYVNBOElHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZWEpuYzF0cElDMGdNVjBnUFNCaGNtZDFiV1Z1ZEhOYmFWMDdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlYRzRnSUNBZ2NYVmxkV1V1Y0hWemFDaHVaWGNnU1hSbGJTaG1kVzRzSUdGeVozTXBLVHRjYmlBZ0lDQnBaaUFvY1hWbGRXVXViR1Z1WjNSb0lEMDlQU0F4SUNZbUlDRmtjbUZwYm1sdVp5a2dlMXh1SUNBZ0lDQWdJQ0J5ZFc1VWFXMWxiM1YwS0dSeVlXbHVVWFZsZFdVcE8xeHVJQ0FnSUgxY2JuMDdYRzVjYmk4dklIWTRJR3hwYTJWeklIQnlaV1JwWTNScFlteGxJRzlpYW1WamRITmNibVoxYm1OMGFXOXVJRWwwWlcwb1puVnVMQ0JoY25KaGVTa2dlMXh1SUNBZ0lIUm9hWE11Wm5WdUlEMGdablZ1TzF4dUlDQWdJSFJvYVhNdVlYSnlZWGtnUFNCaGNuSmhlVHRjYm4xY2JrbDBaVzB1Y0hKdmRHOTBlWEJsTG5KMWJpQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0IwYUdsekxtWjFiaTVoY0hCc2VTaHVkV3hzTENCMGFHbHpMbUZ5Y21GNUtUdGNibjA3WEc1d2NtOWpaWE56TG5ScGRHeGxJRDBnSjJKeWIzZHpaWEluTzF4dWNISnZZMlZ6Y3k1aWNtOTNjMlZ5SUQwZ2RISjFaVHRjYm5CeWIyTmxjM011Wlc1MklEMGdlMzA3WEc1d2NtOWpaWE56TG1GeVozWWdQU0JiWFR0Y2JuQnliMk5sYzNNdWRtVnljMmx2YmlBOUlDY25PeUF2THlCbGJYQjBlU0J6ZEhKcGJtY2dkRzhnWVhadmFXUWdjbVZuWlhod0lHbHpjM1ZsYzF4dWNISnZZMlZ6Y3k1MlpYSnphVzl1Y3lBOUlIdDlPMXh1WEc1bWRXNWpkR2x2YmlCdWIyOXdLQ2tnZTMxY2JseHVjSEp2WTJWemN5NXZiaUE5SUc1dmIzQTdYRzV3Y205alpYTnpMbUZrWkV4cGMzUmxibVZ5SUQwZ2JtOXZjRHRjYm5CeWIyTmxjM011YjI1alpTQTlJRzV2YjNBN1hHNXdjbTlqWlhOekxtOW1aaUE5SUc1dmIzQTdYRzV3Y205alpYTnpMbkpsYlc5MlpVeHBjM1JsYm1WeUlEMGdibTl2Y0R0Y2JuQnliMk5sYzNNdWNtVnRiM1psUVd4c1RHbHpkR1Z1WlhKeklEMGdibTl2Y0R0Y2JuQnliMk5sYzNNdVpXMXBkQ0E5SUc1dmIzQTdYRzV3Y205alpYTnpMbkJ5WlhCbGJtUk1hWE4wWlc1bGNpQTlJRzV2YjNBN1hHNXdjbTlqWlhOekxuQnlaWEJsYm1SUGJtTmxUR2x6ZEdWdVpYSWdQU0J1YjI5d08xeHVYRzV3Y205alpYTnpMbXhwYzNSbGJtVnljeUE5SUdaMWJtTjBhVzl1SUNodVlXMWxLU0I3SUhKbGRIVnliaUJiWFNCOVhHNWNibkJ5YjJObGMzTXVZbWx1WkdsdVp5QTlJR1oxYm1OMGFXOXVJQ2h1WVcxbEtTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Nkd2NtOWpaWE56TG1KcGJtUnBibWNnYVhNZ2JtOTBJSE4xY0hCdmNuUmxaQ2NwTzF4dWZUdGNibHh1Y0hKdlkyVnpjeTVqZDJRZ1BTQm1kVzVqZEdsdmJpQW9LU0I3SUhKbGRIVnliaUFuTHljZ2ZUdGNibkJ5YjJObGMzTXVZMmhrYVhJZ1BTQm1kVzVqZEdsdmJpQW9aR2x5S1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2R3Y205alpYTnpMbU5vWkdseUlHbHpJRzV2ZENCemRYQndiM0owWldRbktUdGNibjA3WEc1d2NtOWpaWE56TG5WdFlYTnJJRDBnWm5WdVkzUnBiMjRvS1NCN0lISmxkSFZ5YmlBd095QjlPMXh1SWl3aUx5OGdRMjl3ZVhKcFoyaDBJRXB2ZVdWdWRDd2dTVzVqTGlCaGJtUWdiM1JvWlhJZ1RtOWtaU0JqYjI1MGNtbGlkWFJ2Y25NdVhHNHZMMXh1THk4Z1VHVnliV2x6YzJsdmJpQnBjeUJvWlhKbFlua2daM0poYm5SbFpDd2dabkpsWlNCdlppQmphR0Z5WjJVc0lIUnZJR0Z1ZVNCd1pYSnpiMjRnYjJKMFlXbHVhVzVuSUdGY2JpOHZJR052Y0hrZ2IyWWdkR2hwY3lCemIyWjBkMkZ5WlNCaGJtUWdZWE56YjJOcFlYUmxaQ0JrYjJOMWJXVnVkR0YwYVc5dUlHWnBiR1Z6SUNoMGFHVmNiaTh2SUZ3aVUyOW1kSGRoY21WY0lpa3NJSFJ2SUdSbFlXd2dhVzRnZEdobElGTnZablIzWVhKbElIZHBkR2h2ZFhRZ2NtVnpkSEpwWTNScGIyNHNJR2x1WTJ4MVpHbHVaMXh1THk4Z2QybDBhRzkxZENCc2FXMXBkR0YwYVc5dUlIUm9aU0J5YVdkb2RITWdkRzhnZFhObExDQmpiM0I1TENCdGIyUnBabmtzSUcxbGNtZGxMQ0J3ZFdKc2FYTm9MRnh1THk4Z1pHbHpkSEpwWW5WMFpTd2djM1ZpYkdsalpXNXpaU3dnWVc1a0wyOXlJSE5sYkd3Z1kyOXdhV1Z6SUc5bUlIUm9aU0JUYjJaMGQyRnlaU3dnWVc1a0lIUnZJSEJsY20xcGRGeHVMeThnY0dWeWMyOXVjeUIwYnlCM2FHOXRJSFJvWlNCVGIyWjBkMkZ5WlNCcGN5Qm1kWEp1YVhOb1pXUWdkRzhnWkc4Z2MyOHNJSE4xWW1wbFkzUWdkRzhnZEdobFhHNHZMeUJtYjJ4c2IzZHBibWNnWTI5dVpHbDBhVzl1Y3pwY2JpOHZYRzR2THlCVWFHVWdZV0p2ZG1VZ1kyOXdlWEpwWjJoMElHNXZkR2xqWlNCaGJtUWdkR2hwY3lCd1pYSnRhWE56YVc5dUlHNXZkR2xqWlNCemFHRnNiQ0JpWlNCcGJtTnNkV1JsWkZ4dUx5OGdhVzRnWVd4c0lHTnZjR2xsY3lCdmNpQnpkV0p6ZEdGdWRHbGhiQ0J3YjNKMGFXOXVjeUJ2WmlCMGFHVWdVMjltZEhkaGNtVXVYRzR2TDF4dUx5OGdWRWhGSUZOUFJsUlhRVkpGSUVsVElGQlNUMVpKUkVWRUlGd2lRVk1nU1ZOY0lpd2dWMGxVU0U5VlZDQlhRVkpTUVU1VVdTQlBSaUJCVGxrZ1MwbE9SQ3dnUlZoUVVrVlRVMXh1THk4Z1QxSWdTVTFRVEVsRlJDd2dTVTVEVEZWRVNVNUhJRUpWVkNCT1QxUWdURWxOU1ZSRlJDQlVUeUJVU0VVZ1YwRlNVa0ZPVkVsRlV5QlBSbHh1THk4Z1RVVlNRMGhCVGxSQlFrbE1TVlJaTENCR1NWUk9SVk5USUVaUFVpQkJJRkJCVWxSSlExVk1RVklnVUZWU1VFOVRSU0JCVGtRZ1RrOU9TVTVHVWtsT1IwVk5SVTVVTGlCSlRseHVMeThnVGs4Z1JWWkZUbFFnVTBoQlRFd2dWRWhGSUVGVlZFaFBVbE1nVDFJZ1EwOVFXVkpKUjBoVUlFaFBURVJGVWxNZ1FrVWdURWxCUWt4RklFWlBVaUJCVGxrZ1EweEJTVTBzWEc0dkx5QkVRVTFCUjBWVElFOVNJRTlVU0VWU0lFeEpRVUpKVEVsVVdTd2dWMGhGVkVoRlVpQkpUaUJCVGlCQlExUkpUMDRnVDBZZ1EwOU9WRkpCUTFRc0lGUlBVbFFnVDFKY2JpOHZJRTlVU0VWU1YwbFRSU3dnUVZKSlUwbE9SeUJHVWs5TkxDQlBWVlFnVDBZZ1QxSWdTVTRnUTA5T1RrVkRWRWxQVGlCWFNWUklJRlJJUlNCVFQwWlVWMEZTUlNCUFVpQlVTRVZjYmk4dklGVlRSU0JQVWlCUFZFaEZVaUJFUlVGTVNVNUhVeUJKVGlCVVNFVWdVMDlHVkZkQlVrVXVYRzVjYmlkMWMyVWdjM1J5YVdOMEp6dGNibHh1THk4Z1NXWWdiMkpxTG1oaGMwOTNibEJ5YjNCbGNuUjVJR2hoY3lCaVpXVnVJRzkyWlhKeWFXUmtaVzRzSUhSb1pXNGdZMkZzYkdsdVoxeHVMeThnYjJKcUxtaGhjMDkzYmxCeWIzQmxjblI1S0hCeWIzQXBJSGRwYkd3Z1luSmxZV3N1WEc0dkx5QlRaV1U2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5cWIzbGxiblF2Ym05a1pTOXBjM04xWlhNdk1UY3dOMXh1Wm5WdVkzUnBiMjRnYUdGelQzZHVVSEp2Y0dWeWRIa29iMkpxTENCd2NtOXdLU0I3WEc0Z0lISmxkSFZ5YmlCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG1oaGMwOTNibEJ5YjNCbGNuUjVMbU5oYkd3b2IySnFMQ0J3Y205d0tUdGNibjFjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmloeGN5d2djMlZ3TENCbGNTd2diM0IwYVc5dWN5a2dlMXh1SUNCelpYQWdQU0J6WlhBZ2ZId2dKeVluTzF4dUlDQmxjU0E5SUdWeElIeDhJQ2M5Snp0Y2JpQWdkbUZ5SUc5aWFpQTlJSHQ5TzF4dVhHNGdJR2xtSUNoMGVYQmxiMllnY1hNZ0lUMDlJQ2R6ZEhKcGJtY25JSHg4SUhGekxteGxibWQwYUNBOVBUMGdNQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQnZZbW83WEc0Z0lIMWNibHh1SUNCMllYSWdjbVZuWlhod0lEMGdMMXhjS3k5bk8xeHVJQ0J4Y3lBOUlIRnpMbk53YkdsMEtITmxjQ2s3WEc1Y2JpQWdkbUZ5SUcxaGVFdGxlWE1nUFNBeE1EQXdPMXh1SUNCcFppQW9iM0IwYVc5dWN5QW1KaUIwZVhCbGIyWWdiM0IwYVc5dWN5NXRZWGhMWlhseklEMDlQU0FuYm5WdFltVnlKeWtnZTF4dUlDQWdJRzFoZUV0bGVYTWdQU0J2Y0hScGIyNXpMbTFoZUV0bGVYTTdYRzRnSUgxY2JseHVJQ0IyWVhJZ2JHVnVJRDBnY1hNdWJHVnVaM1JvTzF4dUlDQXZMeUJ0WVhoTFpYbHpJRHc5SURBZ2JXVmhibk1nZEdoaGRDQjNaU0J6YUc5MWJHUWdibTkwSUd4cGJXbDBJR3RsZVhNZ1kyOTFiblJjYmlBZ2FXWWdLRzFoZUV0bGVYTWdQaUF3SUNZbUlHeGxiaUErSUcxaGVFdGxlWE1wSUh0Y2JpQWdJQ0JzWlc0Z1BTQnRZWGhMWlhsek8xeHVJQ0I5WEc1Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JzWlc0N0lDc3JhU2tnZTF4dUlDQWdJSFpoY2lCNElEMGdjWE5iYVYwdWNtVndiR0ZqWlNoeVpXZGxlSEFzSUNjbE1qQW5LU3hjYmlBZ0lDQWdJQ0FnYVdSNElEMGdlQzVwYm1SbGVFOW1LR1Z4S1N4Y2JpQWdJQ0FnSUNBZ2EzTjBjaXdnZG5OMGNpd2dheXdnZGp0Y2JseHVJQ0FnSUdsbUlDaHBaSGdnUGowZ01Da2dlMXh1SUNBZ0lDQWdhM04wY2lBOUlIZ3VjM1ZpYzNSeUtEQXNJR2xrZUNrN1hHNGdJQ0FnSUNCMmMzUnlJRDBnZUM1emRXSnpkSElvYVdSNElDc2dNU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHdHpkSElnUFNCNE8xeHVJQ0FnSUNBZ2RuTjBjaUE5SUNjbk8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdzZ1BTQmtaV052WkdWVlVrbERiMjF3YjI1bGJuUW9hM04wY2lrN1hHNGdJQ0FnZGlBOUlHUmxZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDaDJjM1J5S1R0Y2JseHVJQ0FnSUdsbUlDZ2hhR0Z6VDNkdVVISnZjR1Z5ZEhrb2IySnFMQ0JyS1NrZ2UxeHVJQ0FnSUNBZ2IySnFXMnRkSUQwZ2RqdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tFRnljbUY1TG1selFYSnlZWGtvYjJKcVcydGRLU2tnZTF4dUlDQWdJQ0FnYjJKcVcydGRMbkIxYzJnb2RpazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUc5aWFsdHJYU0E5SUZ0dlltcGJhMTBzSUhaZE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCdlltbzdYRzU5TzF4dUlpd2lMeThnUTI5d2VYSnBaMmgwSUVwdmVXVnVkQ3dnU1c1akxpQmhibVFnYjNSb1pYSWdUbTlrWlNCamIyNTBjbWxpZFhSdmNuTXVYRzR2TDF4dUx5OGdVR1Z5YldsemMybHZiaUJwY3lCb1pYSmxZbmtnWjNKaGJuUmxaQ3dnWm5KbFpTQnZaaUJqYUdGeVoyVXNJSFJ2SUdGdWVTQndaWEp6YjI0Z2IySjBZV2x1YVc1bklHRmNiaTh2SUdOdmNIa2diMllnZEdocGN5QnpiMlowZDJGeVpTQmhibVFnWVhOemIyTnBZWFJsWkNCa2IyTjFiV1Z1ZEdGMGFXOXVJR1pwYkdWeklDaDBhR1ZjYmk4dklGd2lVMjltZEhkaGNtVmNJaWtzSUhSdklHUmxZV3dnYVc0Z2RHaGxJRk52Wm5SM1lYSmxJSGRwZEdodmRYUWdjbVZ6ZEhKcFkzUnBiMjRzSUdsdVkyeDFaR2x1WjF4dUx5OGdkMmwwYUc5MWRDQnNhVzFwZEdGMGFXOXVJSFJvWlNCeWFXZG9kSE1nZEc4Z2RYTmxMQ0JqYjNCNUxDQnRiMlJwWm5rc0lHMWxjbWRsTENCd2RXSnNhWE5vTEZ4dUx5OGdaR2x6ZEhKcFluVjBaU3dnYzNWaWJHbGpaVzV6WlN3Z1lXNWtMMjl5SUhObGJHd2dZMjl3YVdWeklHOW1JSFJvWlNCVGIyWjBkMkZ5WlN3Z1lXNWtJSFJ2SUhCbGNtMXBkRnh1THk4Z2NHVnljMjl1Y3lCMGJ5QjNhRzl0SUhSb1pTQlRiMlowZDJGeVpTQnBjeUJtZFhKdWFYTm9aV1FnZEc4Z1pHOGdjMjhzSUhOMVltcGxZM1FnZEc4Z2RHaGxYRzR2THlCbWIyeHNiM2RwYm1jZ1kyOXVaR2wwYVc5dWN6cGNiaTh2WEc0dkx5QlVhR1VnWVdKdmRtVWdZMjl3ZVhKcFoyaDBJRzV2ZEdsalpTQmhibVFnZEdocGN5QndaWEp0YVhOemFXOXVJRzV2ZEdsalpTQnphR0ZzYkNCaVpTQnBibU5zZFdSbFpGeHVMeThnYVc0Z1lXeHNJR052Y0dsbGN5QnZjaUJ6ZFdKemRHRnVkR2xoYkNCd2IzSjBhVzl1Y3lCdlppQjBhR1VnVTI5bWRIZGhjbVV1WEc0dkwxeHVMeThnVkVoRklGTlBSbFJYUVZKRklFbFRJRkJTVDFaSlJFVkVJRndpUVZNZ1NWTmNJaXdnVjBsVVNFOVZWQ0JYUVZKU1FVNVVXU0JQUmlCQlRsa2dTMGxPUkN3Z1JWaFFVa1ZUVTF4dUx5OGdUMUlnU1UxUVRFbEZSQ3dnU1U1RFRGVkVTVTVISUVKVlZDQk9UMVFnVEVsTlNWUkZSQ0JVVHlCVVNFVWdWMEZTVWtGT1ZFbEZVeUJQUmx4dUx5OGdUVVZTUTBoQlRsUkJRa2xNU1ZSWkxDQkdTVlJPUlZOVElFWlBVaUJCSUZCQlVsUkpRMVZNUVZJZ1VGVlNVRTlUUlNCQlRrUWdUazlPU1U1R1VrbE9SMFZOUlU1VUxpQkpUbHh1THk4Z1RrOGdSVlpGVGxRZ1UwaEJURXdnVkVoRklFRlZWRWhQVWxNZ1QxSWdRMDlRV1ZKSlIwaFVJRWhQVEVSRlVsTWdRa1VnVEVsQlFreEZJRVpQVWlCQlRsa2dRMHhCU1Uwc1hHNHZMeUJFUVUxQlIwVlRJRTlTSUU5VVNFVlNJRXhKUVVKSlRFbFVXU3dnVjBoRlZFaEZVaUJKVGlCQlRpQkJRMVJKVDA0Z1QwWWdRMDlPVkZKQlExUXNJRlJQVWxRZ1QxSmNiaTh2SUU5VVNFVlNWMGxUUlN3Z1FWSkpVMGxPUnlCR1VrOU5MQ0JQVlZRZ1QwWWdUMUlnU1U0Z1EwOU9Ua1ZEVkVsUFRpQlhTVlJJSUZSSVJTQlRUMFpVVjBGU1JTQlBVaUJVU0VWY2JpOHZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVXlCSlRpQlVTRVVnVTA5R1ZGZEJVa1V1WEc1Y2JpZDFjMlVnYzNSeWFXTjBKenRjYmx4dWRtRnlJSE4wY21sdVoybG1lVkJ5YVcxcGRHbDJaU0E5SUdaMWJtTjBhVzl1S0hZcElIdGNiaUFnYzNkcGRHTm9JQ2gwZVhCbGIyWWdkaWtnZTF4dUlDQWdJR05oYzJVZ0ozTjBjbWx1WnljNlhHNGdJQ0FnSUNCeVpYUjFjbTRnZGp0Y2JseHVJQ0FnSUdOaGMyVWdKMkp2YjJ4bFlXNG5PbHh1SUNBZ0lDQWdjbVYwZFhKdUlIWWdQeUFuZEhKMVpTY2dPaUFuWm1Gc2MyVW5PMXh1WEc0Z0lDQWdZMkZ6WlNBbmJuVnRZbVZ5SnpwY2JpQWdJQ0FnSUhKbGRIVnliaUJwYzBacGJtbDBaU2gyS1NBL0lIWWdPaUFuSnp0Y2JseHVJQ0FnSUdSbFptRjFiSFE2WEc0Z0lDQWdJQ0J5WlhSMWNtNGdKeWM3WEc0Z0lIMWNibjA3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2IySnFMQ0J6WlhBc0lHVnhMQ0J1WVcxbEtTQjdYRzRnSUhObGNDQTlJSE5sY0NCOGZDQW5KaWM3WEc0Z0lHVnhJRDBnWlhFZ2ZId2dKejBuTzF4dUlDQnBaaUFvYjJKcUlEMDlQU0J1ZFd4c0tTQjdYRzRnSUNBZ2IySnFJRDBnZFc1a1pXWnBibVZrTzF4dUlDQjlYRzVjYmlBZ2FXWWdLSFI1Y0dWdlppQnZZbW9nUFQwOUlDZHZZbXBsWTNRbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUU5aWFtVmpkQzVyWlhsektHOWlhaWt1YldGd0tHWjFibU4wYVc5dUtHc3BJSHRjYmlBZ0lDQWdJSFpoY2lCcmN5QTlJR1Z1WTI5a1pWVlNTVU52YlhCdmJtVnVkQ2h6ZEhKcGJtZHBabmxRY21sdGFYUnBkbVVvYXlrcElDc2daWEU3WEc0Z0lDQWdJQ0JwWmlBb1FYSnlZWGt1YVhOQmNuSmhlU2h2WW1wYmExMHBLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ2WW1wYmExMHViV0Z3S0daMWJtTjBhVzl1S0hZcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdhM01nS3lCbGJtTnZaR1ZWVWtsRGIyMXdiMjVsYm5Rb2MzUnlhVzVuYVdaNVVISnBiV2wwYVhabEtIWXBLVHRjYmlBZ0lDQWdJQ0FnZlNrdWFtOXBiaWh6WlhBcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUd0eklDc2daVzVqYjJSbFZWSkpRMjl0Y0c5dVpXNTBLSE4wY21sdVoybG1lVkJ5YVcxcGRHbDJaU2h2WW1wYmExMHBLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlLUzVxYjJsdUtITmxjQ2s3WEc1Y2JpQWdmVnh1WEc0Z0lHbG1JQ2doYm1GdFpTa2djbVYwZFhKdUlDY25PMXh1SUNCeVpYUjFjbTRnWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0hOMGNtbHVaMmxtZVZCeWFXMXBkR2wyWlNodVlXMWxLU2tnS3lCbGNTQXJYRzRnSUNBZ0lDQWdJQ0JsYm1OdlpHVlZVa2xEYjIxd2IyNWxiblFvYzNSeWFXNW5hV1o1VUhKcGJXbDBhWFpsS0c5aWFpa3BPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVaWGh3YjNKMGN5NWtaV052WkdVZ1BTQmxlSEJ2Y25SekxuQmhjbk5sSUQwZ2NtVnhkV2x5WlNnbkxpOWtaV052WkdVbktUdGNibVY0Y0c5eWRITXVaVzVqYjJSbElEMGdaWGh3YjNKMGN5NXpkSEpwYm1kcFpua2dQU0J5WlhGMWFYSmxLQ2N1TDJWdVkyOWtaU2NwTzF4dUlpd2lhVzF3YjNKMElIc2dTVzFuZFhKRGJHbGxiblFnZlNCbWNtOXRJQ2N1TGk5amJHbGxiblFuTzF4dWFXMXdiM0owSUhzZ1FVeENWVTFmUlU1RVVFOUpUbFFnZlNCbWNtOXRJQ2N1TGk5amIyMXRiMjR2Wlc1a2NHOXBiblJ6Snp0Y2JtbHRjRzl5ZENCN0lFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVc0lFRnNZblZ0UkdGMFlTQjlJR1p5YjIwZ0p5NHVMMk52YlcxdmJpOTBlWEJsY3ljN1hHNXBiWEJ2Y25RZ2V5Qm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDNWMGFXeHpKenRjYmx4dVpYaHdiM0owSUdGemVXNWpJR1oxYm1OMGFXOXVJR2RsZEVGc1luVnRLRnh1SUNCamJHbGxiblE2SUVsdFozVnlRMnhwWlc1MExGeHVJQ0JoYkdKMWJVaGhjMmc2SUhOMGNtbHVaMXh1S1RvZ1VISnZiV2x6WlR4SmJXZDFja0Z3YVZKbGMzQnZibk5sUEVGc1luVnRSR0YwWVQ0K0lIdGNiaUFnWTI5dWMzUWdkWEpzSUQwZ1lDUjdRVXhDVlUxZlJVNUVVRTlKVGxSOUx5UjdZV3hpZFcxSVlYTm9mV0E3WEc0Z0lISmxkSFZ5YmlCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxLR0YzWVdsMElHTnNhV1Z1ZEM1eVpYRjFaWE4wS0h0MWNteDlLU2tnWVhNZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlR4QmJHSjFiVVJoZEdFK08xeHVmVnh1SWl3aVpYaHdiM0owSUNvZ1puSnZiU0FuTGk5blpYUkJiR0oxYlNjN1hHNGlMQ0pwYlhCdmNuUWdleUJGZG1WdWRFVnRhWFIwWlhJZ2ZTQm1jbTl0SUNkbGRtVnVkSE1uTzF4dWFXMXdiM0owSUhzZ1oyVjBRWFYwYUc5eWFYcGhkR2x2YmtobFlXUmxjaUI5SUdaeWIyMGdKeTR2WjJWMFFYVjBhRzl5YVhwaGRHbHZia2hsWVdSbGNpYzdYRzVwYlhCdmNuUWdlMXh1SUNCa1pXeGxkR1ZKYldGblpTeGNiaUFnWm1GMmIzSnBkR1ZKYldGblpTeGNiaUFnWjJWMFNXMWhaMlVzWEc0Z0lIVndiRzloWkN4Y2JpQWdkWEJrWVhSbFNXMWhaMlVzWEc0Z0lGVndaR0YwWlVsdFlXZGxVR0Y1Ykc5aFpDeGNibjBnWm5KdmJTQW5MaTlwYldGblpTYzdYRzVwYlhCdmNuUWdlMXh1SUNCSFlXeHNaWEo1VDNCMGFXOXVjeXhjYmlBZ1oyVjBSMkZzYkdWeWVTeGNiaUFnWjJWMFUzVmljbVZrWkdsMFIyRnNiR1Z5ZVN4Y2JpQWdVM1ZpY21Wa1pHbDBSMkZzYkdWeWVVOXdkR2x2Ym5Nc1hHNGdJSE5sWVhKamFFZGhiR3hsY25rc1hHNGdJRk5sWVhKamFFZGhiR3hsY25sUGNIUnBiMjV6TEZ4dWZTQm1jbTl0SUNjdUwyZGhiR3hsY25rbk8xeHVhVzF3YjNKMElIc2daMlYwUVd4aWRXMGdmU0JtY205dElDY3VMMkZzWW5WdEp6dGNibWx0Y0c5eWRDQjdJRWxOUjFWU1gwRlFTVjlRVWtWR1NWZ2dmU0JtY205dElDY3VMMk52YlcxdmJpOWxibVJ3YjJsdWRITW5PMXh1YVcxd2IzSjBJSHRjYmlBZ1FXeGlkVzFFWVhSaExGeHVJQ0JEY21Wa1pXNTBhV0ZzY3l4Y2JpQWdSMkZzYkdWeWVVUmhkR0VzWEc0Z0lFbHRZV2RsUkdGMFlTeGNiaUFnU1cxbmRYSkJjR2xTWlhOd2IyNXpaU3hjYmlBZ1VHRjViRzloWkN4Y2JuMGdabkp2YlNBbkxpOWpiMjF0YjI0dmRIbHdaWE1uTzF4dVhHNWpiMjV6ZENCVlUwVlNRVWRGVGxRZ1BTQW5hVzFuZFhJdmJtVjRkQ0FvYUhSMGNITTZMeTluYVhSb2RXSXVZMjl0TDJ0aGFXMWhiR3hsWVM5dWIyUmxMV2x0WjNWeUtTYzdYRzVjYm1sdGNHOXlkQ0JoZUdsdmN5d2dleUJCZUdsdmMwbHVjM1JoYm1ObExDQkJlR2x2YzFKbGMzQnZibk5sTENCQmVHbHZjMUpsY1hWbGMzUkRiMjVtYVdjZ2ZTQm1jbTl0SUNkaGVHbHZjeWM3WEc1Y2JtVjRjRzl5ZENCamJHRnpjeUJKYldkMWNrTnNhV1Z1ZENCbGVIUmxibVJ6SUVWMlpXNTBSVzFwZEhSbGNpQjdYRzRnSUhCeWFYWmhkR1VnY0d4aGFXNUdaWFJqYUdWeU9pQkJlR2x2YzBsdWMzUmhibU5sTzF4dUlDQndjbWwyWVhSbElHWmxkR05vWlhJNklFRjRhVzl6U1c1emRHRnVZMlU3WEc1Y2JpQWdZMjl1YzNSeWRXTjBiM0lvY21WaFpHOXViSGtnWTNKbFpHVnVkR2xoYkhNNklFTnlaV1JsYm5ScFlXeHpLU0I3WEc0Z0lDQWdjM1Z3WlhJb0tUdGNibHh1SUNBZ0lIUm9hWE11Y0d4aGFXNUdaWFJqYUdWeUlEMGdZWGhwYjNNdVkzSmxZWFJsS0h0Y2JpQWdJQ0FnSUdKaGMyVlZVa3c2SUVsTlIxVlNYMEZRU1Y5UVVrVkdTVmdzWEc0Z0lDQWdJQ0JvWldGa1pYSnpPaUI3WEc0Z0lDQWdJQ0FnSUNkMWMyVnlMV0ZuWlc1MEp6b2dWVk5GVWtGSFJVNVVMRnh1SUNBZ0lDQWdmU3hjYmlBZ0lDQWdJSEpsYzNCdmJuTmxWSGx3WlRvZ0oycHpiMjRuTEZ4dUlDQWdJSDBwTzF4dUlDQWdJSFJvYVhNdVptVjBZMmhsY2lBOUlHRjRhVzl6TG1OeVpXRjBaU2g3WEc0Z0lDQWdJQ0JpWVhObFZWSk1PaUJKVFVkVlVsOUJVRWxmVUZKRlJrbFlMRnh1SUNBZ0lDQWdhR1ZoWkdWeWN6b2dlMXh1SUNBZ0lDQWdJQ0FuZFhObGNpMWhaMlZ1ZENjNklGVlRSVkpCUjBWT1ZDeGNiaUFnSUNBZ0lIMHNYRzRnSUNBZ0lDQnlaWE53YjI1elpWUjVjR1U2SUNkcWMyOXVKeXhjYmlBZ0lDQjlLVHRjYmlBZ0lDQjBhR2x6TG1abGRHTm9aWEl1YVc1MFpYSmpaWEIwYjNKekxuSmxjWFZsYzNRdWRYTmxLRnh1SUNBZ0lDQWdZWE41Ym1NZ0tHTnZibVpwWnpvZ1FYaHBiM05TWlhGMVpYTjBRMjl1Wm1sbktTQTlQaUI3WEc0Z0lDQWdJQ0FnSUdOdmJtWnBaeTVvWldGa1pYSnpJRDBnWTI5dVptbG5MbWhsWVdSbGNuTWdQeUJqYjI1bWFXY3VhR1ZoWkdWeWN5QTZJSHQ5TzF4dUlDQWdJQ0FnSUNCamIyNW1hV2N1YUdWaFpHVnljeTVoZFhSb2IzSnBlbUYwYVc5dUlEMGdZWGRoYVhRZ1oyVjBRWFYwYUc5eWFYcGhkR2x2YmtobFlXUmxjaWgwYUdsektUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHTnZibVpwWnp0Y2JpQWdJQ0FnSUgwc1hHNGdJQ0FnSUNBb1pUb2dSWEp5YjNJcElEMCtJRkJ5YjIxcGMyVXVjbVZxWldOMEtHVXBYRzRnSUNBZ0tUdGNiaUFnZlZ4dVhHNGdJSEJzWVdsdVVtVnhkV1Z6ZENodmNIUnBiMjV6T2lCQmVHbHZjMUpsY1hWbGMzUkRiMjVtYVdjcE9pQlFjbTl0YVhObFBFRjRhVzl6VW1WemNHOXVjMlU4ZFc1cmJtOTNiajQrSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3k1d2JHRnBia1psZEdOb1pYSW9iM0IwYVc5dWN5azdYRzRnSUgxY2JseHVJQ0J5WlhGMVpYTjBLRzl3ZEdsdmJuTTZJRUY0YVc5elVtVnhkV1Z6ZEVOdmJtWnBaeUE5SUh0OUtUb2dVSEp2YldselpUeEJlR2x2YzFKbGMzQnZibk5sUEhWdWEyNXZkMjQrUGlCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNdVptVjBZMmhsY2lodmNIUnBiMjV6S1R0Y2JpQWdmVnh1WEc0Z0lHUmxiR1YwWlVsdFlXZGxLR2x0WVdkbFNHRnphRG9nYzNSeWFXNW5LVG9nVUhKdmJXbHpaVHhKYldkMWNrRndhVkpsYzNCdmJuTmxQR0p2YjJ4bFlXNCtQaUI3WEc0Z0lDQWdjbVYwZFhKdUlHUmxiR1YwWlVsdFlXZGxLSFJvYVhNc0lHbHRZV2RsU0dGemFDazdYRzRnSUgxY2JseHVJQ0JtWVhadmNtbDBaVWx0WVdkbEtHbHRZV2RsU0dGemFEb2djM1J5YVc1bktUb2dVSEp2YldselpUeEpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBITjBjbWx1Wno0K0lIdGNiaUFnSUNCeVpYUjFjbTRnWm1GMmIzSnBkR1ZKYldGblpTaDBhR2x6TENCcGJXRm5aVWhoYzJncE8xeHVJQ0I5WEc1Y2JpQWdaMlYwUVd4aWRXMG9ZV3hpZFcxSVlYTm9PaUJ6ZEhKcGJtY3BPaUJRY205dGFYTmxQRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVThRV3hpZFcxRVlYUmhQajRnZTF4dUlDQWdJSEpsZEhWeWJpQm5aWFJCYkdKMWJTaDBhR2x6TENCaGJHSjFiVWhoYzJncE8xeHVJQ0I5WEc1Y2JpQWdaMlYwUjJGc2JHVnllU2h2Y0hScGIyNXpPaUJIWVd4c1pYSjVUM0IwYVc5dWN5azZJRkJ5YjIxcGMyVThTVzFuZFhKQmNHbFNaWE53YjI1elpUeEhZV3hzWlhKNVJHRjBZVDQrSUh0Y2JpQWdJQ0J5WlhSMWNtNGdaMlYwUjJGc2JHVnllU2gwYUdsekxDQnZjSFJwYjI1ektUdGNiaUFnZlZ4dVhHNGdJR2RsZEZOMVluSmxaR1JwZEVkaGJHeGxjbmtvWEc0Z0lDQWdiM0IwYVc5dWN6b2dVM1ZpY21Wa1pHbDBSMkZzYkdWeWVVOXdkR2x2Ym5OY2JpQWdLVG9nVUhKdmJXbHpaVHhKYldkMWNrRndhVkpsYzNCdmJuTmxQRWRoYkd4bGNubEVZWFJoUGo0Z2UxeHVJQ0FnSUhKbGRIVnliaUJuWlhSVGRXSnlaV1JrYVhSSFlXeHNaWEo1S0hSb2FYTXNJRzl3ZEdsdmJuTXBPMXh1SUNCOVhHNWNiaUFnYzJWaGNtTm9SMkZzYkdWeWVTaGNiaUFnSUNCdmNIUnBiMjV6T2lCVFpXRnlZMmhIWVd4c1pYSjVUM0IwYVc5dWMxeHVJQ0FwT2lCUWNtOXRhWE5sUEVsdFozVnlRWEJwVW1WemNHOXVjMlU4UjJGc2JHVnllVVJoZEdFK1BpQjdYRzRnSUNBZ2NtVjBkWEp1SUhObFlYSmphRWRoYkd4bGNua29kR2hwY3l3Z2IzQjBhVzl1Y3lrN1hHNGdJSDFjYmx4dUlDQm5aWFJKYldGblpTaHBiV0ZuWlVoaGMyZzZJSE4wY21sdVp5azZJRkJ5YjIxcGMyVThTVzFuZFhKQmNHbFNaWE53YjI1elpUeEpiV0ZuWlVSaGRHRStQaUI3WEc0Z0lDQWdjbVYwZFhKdUlHZGxkRWx0WVdkbEtIUm9hWE1zSUdsdFlXZGxTR0Z6YUNrN1hHNGdJSDFjYmx4dUlDQjFjR1JoZEdWSmJXRm5aU2hjYmlBZ0lDQndZWGxzYjJGa09pQlZjR1JoZEdWSmJXRm5aVkJoZVd4dllXUWdmQ0JWY0dSaGRHVkpiV0ZuWlZCaGVXeHZZV1JiWFZ4dUlDQXBPaUJRY205dGFYTmxQRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVThZbTl2YkdWaGJqNGdmQ0JKYldkMWNrRndhVkpsYzNCdmJuTmxQR0p2YjJ4bFlXNCtXMTArSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkWEJrWVhSbFNXMWhaMlVvZEdocGN5d2djR0Y1Ykc5aFpDazdYRzRnSUgxY2JseHVJQ0IxY0d4dllXUW9YRzRnSUNBZ2NHRjViRzloWkRvZ2MzUnlhVzVuSUh3Z2MzUnlhVzVuVzEwZ2ZDQlFZWGxzYjJGa0lId2dVR0Y1Ykc5aFpGdGRYRzRnSUNrNklGQnliMjFwYzJVOFNXMW5kWEpCY0dsU1pYTndiMjV6WlR4SmJXRm5aVVJoZEdFK0lId2dTVzFuZFhKQmNHbFNaWE53YjI1elpUeEpiV0ZuWlVSaGRHRStXMTArSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkWEJzYjJGa0tIUm9hWE1zSUhCaGVXeHZZV1FwTzF4dUlDQjlYRzU5WEc0aUxDSmxlSEJ2Y25RZ1kyOXVjM1FnU1UxSFZWSmZRVkJKWDFCU1JVWkpXQ0E5SUNkb2RIUndjem92TDJGd2FTNXBiV2QxY2k1amIyMG5PMXh1WEc1bGVIQnZjblFnWTI5dWMzUWdRVkJKWDFaRlVsTkpUMDRnUFNBbk15YzdYRzVjYm1WNGNHOXlkQ0JqYjI1emRDQkJWVlJJVDFKSldrVmZSVTVFVUU5SlRsUWdQU0FuYjJGMWRHZ3lMMkYxZEdodmNtbDZaU2M3WEc1Y2JtVjRjRzl5ZENCamIyNXpkQ0JCVEVKVlRWOUZUa1JRVDBsT1ZDQTlJR0FrZTBGUVNWOVdSVkpUU1U5T2ZTOWhiR0oxYldBN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCSlRVRkhSVjlGVGtSUVQwbE9WQ0E5SUdBa2UwRlFTVjlXUlZKVFNVOU9mUzlwYldGblpXQTdYRzVjYm1WNGNHOXlkQ0JqYjI1emRDQlZVRXhQUVVSZlJVNUVVRTlKVGxRZ1BTQmdKSHRCVUVsZlZrVlNVMGxQVG4wdmRYQnNiMkZrWUR0Y2JseHVaWGh3YjNKMElHTnZibk4wSUVkQlRFeEZVbGxmUlU1RVVFOUpUbFFnUFNCZ0pIdEJVRWxmVmtWU1UwbFBUbjB2WjJGc2JHVnllV0E3WEc1Y2JtVjRjRzl5ZENCamIyNXpkQ0JUVlVKU1JVUkVTVlJmUjBGTVRFVlNXVjlGVGtSUVQwbE9WQ0E5SUdBa2UwRlFTVjlXUlZKVFNVOU9mUzluWVd4c1pYSjVMM0pnTzF4dVhHNWxlSEJ2Y25RZ1kyOXVjM1FnVTBWQlVrTklYMGRCVEV4RlVsbGZSVTVFVUU5SlRsUWdQU0JnSkh0QlVFbGZWa1ZTVTBsUFRuMHZaMkZzYkdWeWVTOXpaV0Z5WTJoZ08xeHVJaXdpYVcxd2IzSjBJSHNnVW1WaFpHRmliR1VnZlNCbWNtOXRJRndpYzNSeVpXRnRYQ0k3WEc1Y2JtVjRjRzl5ZENCcGJuUmxjbVpoWTJVZ1FXTmpaWE56Vkc5clpXNGdlMXh1SUNCaFkyTmxjM05VYjJ0bGJqb2djM1J5YVc1bk8xeHVmVnh1WEc1bGVIQnZjblFnYVc1MFpYSm1ZV05sSUVOc2FXVnVkRWxrSUh0Y2JpQWdZMnhwWlc1MFNXUTZJSE4wY21sdVp6dGNibjFjYmx4dVpYaHdiM0owSUdsdWRHVnlabUZqWlNCTWIyZHBiaUJsZUhSbGJtUnpJRU5zYVdWdWRFbGtJSHRjYmlBZ2RYTmxjbTVoYldVNklITjBjbWx1Wnp0Y2JpQWdjR0Z6YzNkdmNtUTZJSE4wY21sdVp6dGNibjFjYmx4dVpYaHdiM0owSUhSNWNHVWdRM0psWkdWdWRHbGhiSE1nUFNCQlkyTmxjM05VYjJ0bGJpQjhJRU5zYVdWdWRFbGtJSHdnVEc5bmFXNDdYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJwYzBGalkyVnpjMVJ2YTJWdUtHRnlaem9nZFc1cmJtOTNiaWs2SUdGeVp5QnBjeUJCWTJObGMzTlViMnRsYmlCN1hHNGdJSEpsZEhWeWJpQW9ZWEpuSUdGeklFRmpZMlZ6YzFSdmEyVnVLUzVoWTJObGMzTlViMnRsYmlBaFBUMGdkVzVrWldacGJtVmtPMXh1ZlZ4dVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z2FYTkRiR2xsYm5SSlpDaGhjbWM2SUhWdWEyNXZkMjRwT2lCaGNtY2dhWE1nUTJ4cFpXNTBTV1FnZTF4dUlDQnlaWFIxY200Z0tHRnlaeUJoY3lCRGJHbGxiblJKWkNrdVkyeHBaVzUwU1dRZ0lUMDlJSFZ1WkdWbWFXNWxaRHRjYm4xY2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHbHpURzluYVc0b1lYSm5PaUIxYm10dWIzZHVLVG9nWVhKbklHbHpJRXh2WjJsdUlIdGNiaUFnY21WMGRYSnVJQ2hjYmlBZ0lDQW9ZWEpuSUdGeklFeHZaMmx1S1M1amJHbGxiblJKWkNBaFBUMGdkVzVrWldacGJtVmtJQ1ltWEc0Z0lDQWdLR0Z5WnlCaGN5Qk1iMmRwYmlrdWRYTmxjbTVoYldVZ0lUMDlJSFZ1WkdWbWFXNWxaQ0FtSmx4dUlDQWdJQ2hoY21jZ1lYTWdURzluYVc0cExuQmhjM04zYjNKa0lDRTlQU0IxYm1SbFptbHVaV1JjYmlBZ0tUdGNibjFjYmx4dWFXNTBaWEptWVdObElFTnZiVzF2YmtSaGRHRWdlMXh1SUNCcFpEb2djM1J5YVc1bk8xeHVJQ0IwYVhSc1pUb2djM1J5YVc1bklId2diblZzYkR0Y2JpQWdaR1Z6WTNKcGNIUnBiMjQ2SUhOMGNtbHVaeUI4SUc1MWJHdzdYRzRnSUdSaGRHVjBhVzFsT2lCdWRXMWlaWEk3WEc0Z0lHeHBibXM2SUhOMGNtbHVaenRjYmx4dUlDQmhaRjlqYjI1bWFXYy9PaUI3WEc0Z0lDQWdjMkZtWlVac1lXZHpPaUJ6ZEhKcGJtZGJYVHRjYmlBZ0lDQm9hV2RvVW1semEwWnNZV2R6T2lCemRISnBibWRiWFR0Y2JpQWdJQ0IxYm5OaFptVkdiR0ZuY3pvZ2MzUnlhVzVuVzEwN1hHNGdJQ0FnZDJGc2JGVnVjMkZtWlVac1lXZHpPaUJ6ZEhKcGJtZGJYVHRjYmlBZ0lDQnphRzkzYzBGa2N6b2dZbTl2YkdWaGJqdGNiaUFnZlR0Y2JpQWdZV1JmZEhsd1pUb2diblZ0WW1WeU8xeHVJQ0JoWkY5MWNtdzZJSE4wY21sdVp6dGNibHh1SUNCaFkyTnZkVzUwWDNWeWJEb2djM1J5YVc1bklId2diblZzYkR0Y2JpQWdZV05qYjNWdWRGOXBaRG9nYzNSeWFXNW5JSHdnYm5Wc2JEdGNiaUFnWm1GMmIzSnBkR1U2SUdKdmIyeGxZVzQ3WEc0Z0lHbHpYMkZrT2lCaWIyOXNaV0Z1TzF4dUlDQnBjMTloYkdKMWJUb2dZbTl2YkdWaGJqdGNiaUFnYVc1ZloyRnNiR1Z5ZVRvZ1ltOXZiR1ZoYmp0Y2JpQWdhVzVmYlc5emRGOTJhWEpoYkRvZ1ltOXZiR1ZoYmp0Y2JpQWdibk5tZHpvZ1ltOXZiR1ZoYmlCOElHNTFiR3c3WEc0Z0lITmxZM1JwYjI0NklITjBjbWx1WnlCOElHNTFiR3c3WEc0Z0lIUmhaM002SUVGeWNtRjVQSHRjYmlBZ0lDQnVZVzFsT2lCemRISnBibWM3WEc0Z0lDQWdaR2x6Y0d4aGVWOXVZVzFsT2lCemRISnBibWM3WEc0Z0lDQWdabTlzYkc5M1pYSnpPaUJ1ZFcxaVpYSTdYRzRnSUNBZ2RHOTBZV3hmYVhSbGJYTTZJRzUxYldKbGNqdGNiaUFnSUNCbWIyeHNiM2RwYm1jNklHSnZiMnhsWVc0N1hHNGdJQ0FnYVhOZmQyaHBkR1ZzYVhOMFpXUTZJR0p2YjJ4bFlXNDdYRzRnSUNBZ1ltRmphMmR5YjNWdVpGOW9ZWE5vT2lCemRISnBibWM3WEc0Z0lDQWdkR2gxYldKdVlXbHNYMmhoYzJnNklITjBjbWx1WnlCOElHNTFiR3c3WEc0Z0lDQWdZV05qWlc1ME9pQnpkSEpwYm1jN1hHNGdJQ0FnWW1GamEyZHliM1Z1WkY5cGMxOWhibWx0WVhSbFpEb2dZbTl2YkdWaGJqdGNiaUFnSUNCMGFIVnRZbTVoYVd4ZmFYTmZZVzVwYldGMFpXUTZJR0p2YjJ4bFlXNDdYRzRnSUNBZ2FYTmZjSEp2Ylc5MFpXUTZJR0p2YjJ4bFlXNDdYRzRnSUNBZ1pHVnpZM0pwY0hScGIyNDZJSE4wY21sdVp6dGNiaUFnSUNCc2IyZHZYMmhoYzJnNklITjBjbWx1WnlCOElHNTFiR3c3WEc0Z0lDQWdiRzluYjE5a1pYTjBhVzVoZEdsdmJsOTFjbXc2SUhOMGNtbHVaeUI4SUc1MWJHdzdYRzRnSUNBZ1pHVnpZM0pwY0hScGIyNWZZVzV1YjNSaGRHbHZibk02SUZKbFkyOXlaRHh6ZEhKcGJtY3NJSFZ1YTI1dmQyNCtPMXh1SUNCOVBqdGNiaUFnZEc5d2FXTTZJSE4wY21sdVp5QjhJRzUxYkd3N1hHNGdJSFJ2Y0dsalgybGtPaUJ6ZEhKcGJtY2dmQ0J1ZFd4c08xeHVJQ0IyYjNSbE9pQnVkV3hzTzF4dVhHNGdJR052YlcxbGJuUmZZMjkxYm5RNklHNTFiV0psY2lCOElHNTFiR3c3WEc0Z0lHWmhkbTl5YVhSbFgyTnZkVzUwT2lCdWRXMWlaWElnZkNCdWRXeHNPMXh1SUNCMWNITTZJRzUxYldKbGNpQjhJRzUxYkd3N1hHNGdJR1J2ZDI1ek9pQnVkVzFpWlhJZ2ZDQnVkV3hzTzF4dUlDQnpZMjl5WlRvZ2JuVnRZbVZ5SUh3Z2JuVnNiRHRjYmlBZ2NHOXBiblJ6T2lCdWRXMWlaWElnZkNCdWRXeHNPMXh1SUNCMmFXVjNjem9nYm5WdFltVnlPMXh1ZlZ4dVpYaHdiM0owSUdsdWRHVnlabUZqWlNCSmJXRm5aVVJoZEdFZ1pYaDBaVzVrY3lCRGIyMXRiMjVFWVhSaElIdGNiaUFnZEhsd1pUb2djM1J5YVc1bk8xeHVJQ0IzYVdSMGFEb2diblZ0WW1WeU8xeHVJQ0JvWldsbmFIUTZJRzUxYldKbGNqdGNiaUFnYzJsNlpUb2diblZ0WW1WeU8xeHVJQ0JrWld4bGRHVm9ZWE5vUHpvZ2MzUnlhVzVuTzF4dUlDQmlZVzVrZDJsa2RHZzZJRzUxYldKbGNqdGNiaUFnWVc1cGJXRjBaV1E2SUdKdmIyeGxZVzQ3WEc0Z0lHaGhjMTl6YjNWdVpEb2dZbTl2YkdWaGJqdGNiaUFnWldScGRHVmtPaUJ6ZEhKcGJtYzdYRzRnSUcxd05GOXphWHBsUHpvZ2JuVnRZbVZ5TzF4dUlDQnRjRFEvT2lCemRISnBibWM3WEc0Z0lHZHBablkvT2lCemRISnBibWM3WEc0Z0lHaHNjejg2SUhOMGNtbHVaenRjYmlBZ2JHOXZjR2x1Wno4NklHSnZiMnhsWVc0N1hHNGdJSEJ5YjJObGMzTnBibWMvT2lCN1hHNGdJQ0FnYzNSaGRIVnpPaUFuY0dWdVpHbHVaeWNnZkNBblkyOXRjR3hsZEdWa0p6dGNiaUFnZlR0Y2JuMWNibHh1Wlhod2IzSjBJR2x1ZEdWeVptRmpaU0JCYkdKMWJVUmhkR0VnWlhoMFpXNWtjeUJEYjIxdGIyNUVZWFJoSUh0Y2JpQWdZMjkyWlhJNklITjBjbWx1WnlCOElHNTFiR3c3WEc0Z0lHTnZkbVZ5WDNkcFpIUm9PaUJ1ZFcxaVpYSWdmQ0J1ZFd4c08xeHVJQ0JqYjNabGNsOW9aV2xuYUhRNklHNTFiV0psY2lCOElHNTFiR3c3WEc0Z0lHeGhlVzkxZERvZ2MzUnlhVzVuTzF4dUlDQndjbWwyWVdONU9pQnpkSEpwYm1jN1hHNGdJR2x1WTJ4MVpHVmZZV3hpZFcxZllXUnpPaUJpYjI5c1pXRnVPMXh1SUNCcGJXRm5aWE02SUVsdFlXZGxSR0YwWVZ0ZE8xeHVJQ0JwYldGblpYTmZZMjkxYm5RNklHNTFiV0psY2p0Y2JuMWNibHh1Wlhod2IzSjBJSFI1Y0dVZ1IyRnNiR1Z5ZVVSaGRHRWdQU0JCY25KaGVUeEpiV0ZuWlVSaGRHRWdmQ0JCYkdKMWJVUmhkR0UrTzF4dVpYaHdiM0owSUdsdWRHVnlabUZqWlNCUVlYbHNiMkZrSUh0Y2JpQWdhVzFoWjJVL09pQnpkSEpwYm1jN1hHNGdJR0poYzJVMk5EODZJSE4wY21sdVp6dGNiaUFnZEhsd1pUODZJQ2R6ZEhKbFlXMG5JSHdnSjNWeWJDY2dmQ0FuWW1GelpUWTBKenRjYmlBZ2JtRnRaVDg2SUhOMGNtbHVaenRjYmlBZ2RHbDBiR1UvT2lCemRISnBibWM3WEc0Z0lHUmxjMk55YVhCMGFXOXVQem9nYzNSeWFXNW5PMXh1SUNCaGJHSjFiVDg2SUhOMGNtbHVaenRjYmlBZ2MzUnlaV0Z0UHpvZ1VtVmhaR0ZpYkdVN1hHNGdJR1JwYzJGaWJHVmZZWFZrYVc4L09pQW5NU2NnZkNBbk1DYzdYRzU5WEc1bGVIQnZjblFnYVc1MFpYSm1ZV05sSUVsdFozVnlRWEJwVW1WemNHOXVjMlU4WEc0Z0lGUWdQU0JTWldOdmNtUThjM1J5YVc1bkxDQjFibXR1YjNkdVBpQjhJRkpsWTI5eVpEeHpkSEpwYm1jc0lIVnVhMjV2ZDI0K1cxMGdmQ0J6ZEhKcGJtY2dmQ0JpYjI5c1pXRnVJSHdnU1cxaFoyVkVZWFJoSUh3Z1IyRnNiR1Z5ZVVSaGRHRWdmQ0JCYkdKMWJVUmhkR0ZjYmo0Z2UxeHVJQ0JrWVhSaE9pQlVPMXh1SUNCemRHRjBkWE02SUc1MWJXSmxjanRjYmlBZ2MzVmpZMlZ6Y3pvZ1ltOXZiR1ZoYmp0Y2JuMGlMQ0pwYlhCdmNuUWdleUJCZUdsdmMxSmxjM0J2Ym5ObElIMGdabkp2YlNBbllYaHBiM01uTzF4dWFXMXdiM0owSUVadmNtMUVZWFJoSUdaeWIyMGdKMlp2Y20wdFpHRjBZU2M3WEc1cGJYQnZjblFnZXlCSmJXZDFja0Z3YVZKbGMzQnZibk5sTENCUVlYbHNiMkZrSUgwZ1puSnZiU0FuTGk5MGVYQmxjeWM3WEc1cGJYQnZjblFnZXlCU1pXRmtZV0pzWlNCOUlHWnliMjBnSjNOMGNtVmhiU2M3WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCcGMwSmhjMlUyTkNod1lYbHNiMkZrT2lCemRISnBibWNnZkNCUVlYbHNiMkZrS1RvZ1ltOXZiR1ZoYmlCN1hHNGdJR2xtSUNoMGVYQmxiMllnY0dGNWJHOWhaQ0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlIQmhlV3h2WVdRdVltRnpaVFkwSUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmlCd1lYbHNiMkZrTG5SNWNHVWdQVDA5SUNkaVlYTmxOalFuTzF4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdhWE5KYldGblpWVnliQ2h3WVhsc2IyRmtPaUJ6ZEhKcGJtY2dmQ0JRWVhsc2IyRmtLVG9nWW05dmJHVmhiaUI3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdjR0Y1Ykc5aFpDQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnY0dGNWJHOWhaQzVwYldGblpTQWhQVDBnSjNWdVpHVm1hVzVsWkNjZ0ppWWdjR0Y1Ykc5aFpDNTBlWEJsSUQwOVBTQW5kWEpzSnp0Y2JuMWNibHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJR2x6VTNSeVpXRnRLSEJoZVd4dllXUTZJSE4wY21sdVp5QjhJRkJoZVd4dllXUXBPaUJpYjI5c1pXRnVJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQndZWGxzYjJGa0lEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnY0dGNWJHOWhaQzV6ZEhKbFlXMGdJVDA5SUNkMWJtUmxabWx1WldRbk8xeHVmVnh1WEc0dkx5QlVUMFJQT2lCU1pXWmhZM1J2Y2lCMGFHbHpJSFJ2SUdKbElHRWdkVzVwY1hWbElHNWhiV1VnYjJZZ2MyOXRaU0JyYVc1a0lDaGhJR2hoYzJnL0tWeHVaWGh3YjNKMElHWjFibU4wYVc5dUlHZGxkRk52ZFhKalpTaHdZWGxzYjJGa09pQnpkSEpwYm1jZ2ZDQlFZWGxzYjJGa0tUb2djM1J5YVc1bklId2dVbVZoWkdGaWJHVWdlMXh1SUNCcFppQW9kSGx3Wlc5bUlIQmhlV3h2WVdRZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdjbVYwZFhKdUlIQmhlV3h2WVdRN1hHNGdJSDFjYmx4dUlDQnBaaUFvYVhOQ1lYTmxOalFvY0dGNWJHOWhaQ2twSUh0Y2JpQWdJQ0J5WlhSMWNtNGdYQ0p3WVhsc2IyRmtMbUpoYzJVMk5Gd2lJR0Z6SUhOMGNtbHVaenRjYmlBZ2ZTQmxiSE5sSUdsbUlDaHBjMU4wY21WaGJTaHdZWGxzYjJGa0tTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCY0luQmhlV3h2WVdRdWMzUnlaV0Z0WENJZ1lYTWdjM1J5YVc1bk8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxkSFZ5YmlCd1lYbHNiMkZrTG1sdFlXZGxJR0Z6SUhOMGNtbHVaenRjYmlBZ2ZWeHVmVnh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWTNKbFlYUmxSbTl5YlNod1lYbHNiMkZrT2lCemRISnBibWNnZkNCUVlYbHNiMkZrS1RvZ1JtOXliVVJoZEdFZ2UxeHVJQ0JqYjI1emRDQm1iM0p0SUQwZ2JtVjNJRVp2Y20xRVlYUmhLQ2s3WEc1Y2JpQWdhV1lnS0hSNWNHVnZaaUJ3WVhsc2IyRmtJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUdadmNtMHVZWEJ3Wlc1a0tDZHBiV0ZuWlNjc0lIQmhlV3h2WVdRcE8xeHVJQ0FnSUhKbGRIVnliaUJtYjNKdE8xeHVJQ0I5WEc1Y2JpQWdabTl5SUNoamIyNXpkQ0JiYTJWNUxDQjJZV3gxWlYwZ2IyWWdUMkpxWldOMExtVnVkSEpwWlhNb2NHRjViRzloWkNrcElIdGNiaUFnSUNCamIyNXpkQ0J6ZFhCd2IzSjBaV1JWY0d4dllXUlBZbXBsWTNSVWVYQmxjeUE5SUZzblltRnpaVFkwSnl3Z0ozTjBjbVZoYlNkZFhHNGdJQ0FnYVdZZ0tITjFjSEJ2Y25SbFpGVndiRzloWkU5aWFtVmpkRlI1Y0dWekxtbHVaR1Y0VDJZb2EyVjVLU0FoUFQwZ0xURXBJSHRjYmlBZ0lDQWdJR2xtSUNoemRYQndiM0owWldSVmNHeHZZV1JQWW1wbFkzUlVlWEJsY3k1cGJtUmxlRTltS0hCaGVXeHZZV1F1ZEhsd1pTQmhjeUJ6ZEhKcGJtY3BJQ0U5UFNBdE1Ta2dlMXh1SUNBZ0lDQWdJQ0JtYjNKdExtRndjR1Z1WkNoclpYa3NJSEJoZVd4dllXUXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCbWIzSnRMbUZ3Y0dWdVpDaHJaWGtzSUhaaGJIVmxLVHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdjbVYwZFhKdUlHWnZjbTA3WEc1OVhHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sS0Z4dUlDQnlaWE53YjI1elpUb2dRWGhwYjNOU1pYTndiMjV6WlZ4dUtUb2dTVzFuZFhKQmNHbFNaWE53YjI1elpTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2NtVnpjRzl1YzJVdVpHRjBZVDh1YzNSaGRIVnpJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUIwZVhCbGIyWWdjbVZ6Y0c5dWMyVXVaR0YwWVQ4dWMzVmpZMlZ6Y3lBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdjbVZ6Y0c5dWMyVXVaR0YwWVZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0JrWVhSaE9pQnlaWE53YjI1elpTNWtZWFJoTEZ4dUlDQWdJSE4wWVhSMWN6b2djbVZ6Y0c5dWMyVXVjM1JoZEhWekxGeHVJQ0FnSUM4dklGUlBSRTg2SUdSbGRHVnliV2x1WlNCMGFHVWdjM1ZqWTJWemN5QnZaaUIwYUdVZ1kyRnNiRDljYmlBZ0lDQnpkV05qWlhOek9pQjBjblZsTEZ4dUlDQjlYRzU5WEc0aUxDSnBiWEJ2Y25RZ2V5QkpiV2QxY2tOc2FXVnVkQ0I5SUdaeWIyMGdKeTR1TDJOc2FXVnVkQ2M3WEc1cGJYQnZjblFnZXlCSFFVeE1SVkpaWDBWT1JGQlBTVTVVTENCSlRVZFZVbDlCVUVsZlVGSkZSa2xZSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDJWdVpIQnZhVzUwY3ljN1hHNXBiWEJ2Y25RZ2V5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObExDQkhZV3hzWlhKNVJHRjBZU0I5SUdaeWIyMGdKeTR1TDJOdmJXMXZiaTkwZVhCbGN5YzdYRzVwYlhCdmNuUWdleUJWVWt3Z2ZTQm1jbTl0SUNkMWNtd25PMXh1YVcxd2IzSjBJSHNnWjJWMFNXMW5kWEpCY0dsU1pYTndiMjV6WlVaeWIyMVNaWE53YjI1elpTQjlJR1p5YjIwZ0p5NHVMMk52YlcxdmJpOTFkR2xzY3ljN1hHNWNibVY0Y0c5eWRDQjBlWEJsSUVOdmJXMXZibE5sWTNScGIyNVFjbTl3Y3lBOUlIdGNiaUFnYzI5eWREODZJQ2QyYVhKaGJDY2dmQ0FuZEc5d0p5QjhJQ2QwYVcxbEp6dGNiaUFnY0dGblpUODZJRzUxYldKbGNqdGNibjA3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRWh2ZEZObFkzUnBiMjRnUFNCRGIyMXRiMjVUWldOMGFXOXVVSEp2Y0hNZ0ppQjdYRzRnSUhObFkzUnBiMjQ2SUNkb2IzUW5PMXh1ZlR0Y2JseHVaWGh3YjNKMElIUjVjR1VnVkc5d1UyVmpkR2x2YmlBOUlFTnZiVzF2YmxObFkzUnBiMjVRY205d2N5QW1JSHRjYmlBZ2MyVmpkR2x2YmpvZ0ozUnZjQ2M3WEc0Z0lIZHBibVJ2ZHo4NklDZGtZWGtuSUh3Z0ozZGxaV3NuSUh3Z0oyMXZiblJvSnlCOElDZDVaV0Z5SnlCOElDZGhiR3duTzF4dWZUdGNibHh1Wlhod2IzSjBJSFI1Y0dVZ1ZYTmxjbE5sWTNScGIyNGdQU0JQYldsMFBFTnZiVzF2YmxObFkzUnBiMjVRY205d2N5d2dKM052Y25RblBpQW1JSHRjYmlBZ2MyVmpkR2x2YmpvZ0ozVnpaWEluTzF4dUlDQnpiM0owUHpvZ0ozWnBjbUZzSnlCOElDZDBiM0FuSUh3Z0ozUnBiV1VuSUh3Z0ozSnBjMmx1WnljN1hHNTlPMXh1WEc1bGVIQnZjblFnZEhsd1pTQlRaV04wYVc5dVQzQjBhVzl1Y3lBOUlFaHZkRk5sWTNScGIyNGdmQ0JVYjNCVFpXTjBhVzl1SUh3Z1ZYTmxjbE5sWTNScGIyNDdYRzVjYm1WNGNHOXlkQ0IwZVhCbElGQnlaWE5sYm5SaGRHbHZiazl3ZEdsdmJuTWdQU0I3WEc0Z0lITm9iM2RXYVhKaGJEODZJR0p2YjJ4bFlXNDdYRzRnSUcxaGRIVnlaVDg2SUdKdmIyeGxZVzQ3WEc0Z0lHRnNZblZ0WDNCeVpYWnBaWGR6UHpvZ1ltOXZiR1ZoYmp0Y2JuMDdYRzVjYm1WNGNHOXlkQ0IwZVhCbElFZGhiR3hsY25sUGNIUnBiMjV6SUQwZ1UyVmpkR2x2Yms5d2RHbHZibk1nSmlCUWNtVnpaVzUwWVhScGIyNVBjSFJwYjI1ek8xeHVYRzVqYjI1emRDQmtaV1poZFd4MFQzQjBhVzl1Y3pvZ1IyRnNiR1Z5ZVU5d2RHbHZibk1nUFNCN1hHNGdJSE5sWTNScGIyNDZJQ2RvYjNRbkxGeHVJQ0J6YjNKME9pQW5kbWx5WVd3bkxGeHVmVHRjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdOdmJuTjBjblZqZEVkaGJHeGxjbmxWY213b2IzQjBhVzl1Y3pvZ1IyRnNiR1Z5ZVU5d2RHbHZibk1wT2lCVlVrd2dlMXh1SUNCamIyNXpkQ0J0WlhKblpXUlBjSFJwYjI1eklEMGdUMkpxWldOMExtRnpjMmxuYmloN2ZTd2daR1ZtWVhWc2RFOXdkR2x2Ym5Nc0lHOXdkR2x2Ym5NcE8xeHVYRzRnSUd4bGRDQjFjbWtnUFNCZ0pIdHRaWEpuWldSUGNIUnBiMjV6TG5ObFkzUnBiMjU5WUR0Y2JseHVJQ0JwWmlBb2JXVnlaMlZrVDNCMGFXOXVjeTV6YjNKMEtTQjdYRzRnSUNBZ2RYSnBJQ3M5SUdBdkpIdHRaWEpuWldSUGNIUnBiMjV6TG5OdmNuUjlZRHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHRaWEpuWldSUGNIUnBiMjV6TG5ObFkzUnBiMjRnUFQwOUlDZDBiM0FuSUNZbUlHMWxjbWRsWkU5d2RHbHZibk11ZDJsdVpHOTNLU0I3WEc0Z0lDQWdkWEpwSUNzOUlHQXZKSHR0WlhKblpXUlBjSFJwYjI1ekxuZHBibVJ2ZDMxZ08xeHVJQ0I5WEc1Y2JpQWdhV1lnS0cxbGNtZGxaRTl3ZEdsdmJuTXVjR0ZuWlNrZ2UxeHVJQ0FnSUhWeWFTQXJQU0JnTHlSN2JXVnlaMlZrVDNCMGFXOXVjeTV3WVdkbGZXQTdYRzRnSUgxY2JseHVJQ0JqYjI1emRDQjFjbXdnUFNCdVpYY2dWVkpNS0dBa2UwbE5SMVZTWDBGUVNWOVFVa1ZHU1ZoOUx5UjdSMEZNVEVWU1dWOUZUa1JRVDBsT1ZIMHZKSHQxY21sOVlDazdYRzVjYmlBZ2FXWWdLRzFsY21kbFpFOXdkR2x2Ym5NdWMyaHZkMVpwY21Gc0lDRTlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0IxY213dWMyVmhjbU5vVUdGeVlXMXpMbUZ3Y0dWdVpDZ25jMmh2ZDFacGNtRnNKeXdnYldWeVoyVmtUM0IwYVc5dWN5NXphRzkzVm1seVlXd3VkRzlUZEhKcGJtY29LU2s3WEc0Z0lIMWNibHh1SUNCcFppQW9iV1Z5WjJWa1QzQjBhVzl1Y3k1dFlYUjFjbVVnSVQwOUlIVnVaR1ZtYVc1bFpDa2dlMXh1SUNBZ0lIVnliQzV6WldGeVkyaFFZWEpoYlhNdVlYQndaVzVrS0NkdFlYUjFjbVVuTENCdFpYSm5aV1JQY0hScGIyNXpMbTFoZEhWeVpTNTBiMU4wY21sdVp5Z3BLVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHRaWEpuWldSUGNIUnBiMjV6TG1Gc1luVnRYM0J5WlhacFpYZHpJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNCMWNtd3VjMlZoY21Ob1VHRnlZVzF6TG1Gd2NHVnVaQ2hjYmlBZ0lDQWdJQ2RoYkdKMWJWOXdjbVYyYVdWM2N5Y3NYRzRnSUNBZ0lDQnRaWEpuWldSUGNIUnBiMjV6TG1Gc1luVnRYM0J5WlhacFpYZHpMblJ2VTNSeWFXNW5LQ2xjYmlBZ0lDQXBPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJSFZ5YkR0Y2JuMWNibHh1Wlhod2IzSjBJR0Z6ZVc1aklHWjFibU4wYVc5dUlHZGxkRWRoYkd4bGNua29YRzRnSUdOc2FXVnVkRG9nU1cxbmRYSkRiR2xsYm5Rc1hHNGdJRzl3ZEdsdmJuTTZJRWRoYkd4bGNubFBjSFJwYjI1eklEMGdaR1ZtWVhWc2RFOXdkR2x2Ym5OY2JpazZJRkJ5YjIxcGMyVThTVzFuZFhKQmNHbFNaWE53YjI1elpUeEhZV3hzWlhKNVJHRjBZVDQrSUh0Y2JpQWdZMjl1YzNRZ2V5QndZWFJvYm1GdFpTQjlJRDBnWTI5dWMzUnlkV04wUjJGc2JHVnllVlZ5YkNodmNIUnBiMjV6S1R0Y2JpQWdMeThnYzJsdVkyVWdkMlVuY21VZ2RYTnBibWNnY0hKbFptbDRWWEpzSUhkcGRHZ2daMjkwTENCM1pTQm9ZWFpsSUhSdklISmxiVzkyWlNCMGFHVWdjM1JoY25ScGJtY2djMnhoYzJnZ2IzSWdhWFFuYkd3Z2RHaHliM2RjYmlBZ1kyOXVjM1FnWm1sdVlXeFFZWFJvYm1GdFpTQTlJSEJoZEdodVlXMWxMbk5zYVdObEtERXBPMXh1WEc0Z0lISmxkSFZ5YmlCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxLR0YzWVdsMElHTnNhV1Z1ZEM1eVpYRjFaWE4wS0hzZ2RYSnNPaUJtYVc1aGJGQmhkR2h1WVcxbElIMHBLU0JoY3lCSmJXZDFja0Z3YVZKbGMzQnZibk5sUEVkaGJHeGxjbmxFWVhSaFBqdGNibjFjYmlJc0ltbHRjRzl5ZENCN0lFbHRaM1Z5UTJ4cFpXNTBJSDBnWm5KdmJTQW5MaTR2WTJ4cFpXNTBKenRjYm1sdGNHOXlkQ0I3WEc0Z0lGTlZRbEpGUkVSSlZGOUhRVXhNUlZKWlgwVk9SRkJQU1U1VUxGeHVJQ0JKVFVkVlVsOUJVRWxmVUZKRlJrbFlMRnh1ZlNCbWNtOXRJQ2N1TGk5amIyMXRiMjR2Wlc1a2NHOXBiblJ6Snp0Y2JtbHRjRzl5ZENCN0lFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVc0lFZGhiR3hsY25sRVlYUmhJSDBnWm5KdmJTQW5MaTR2WTI5dGJXOXVMM1I1Y0dWekp6dGNibWx0Y0c5eWRDQjdJRlZTVENCOUlHWnliMjBnSjNWeWJDYzdYRzVwYlhCdmNuUWdleUJuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObElIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwzVjBhV3h6Snp0Y2JseHVaWGh3YjNKMElIUjVjR1VnVkdsdFpVOXdkR2x2Ym5NZ1BTQjdYRzRnSUhOMVluSmxaR1JwZERvZ2MzUnlhVzVuTzF4dUlDQnpiM0owUHpvZ0ozUnBiV1VuTzF4dUlDQndZV2RsUHpvZ2JuVnRZbVZ5TzF4dWZUdGNibHh1Wlhod2IzSjBJSFI1Y0dVZ1ZHOXdUM0IwYVc5dWN5QTlJRTl0YVhROFZHbHRaVTl3ZEdsdmJuTXNJQ2R6YjNKMEp6NGdKaUI3WEc0Z0lITnZjblEvT2lBbmRHOXdKenRjYmlBZ2QybHVaRzkzUHpvZ0oyUmhlU2NnZkNBbmQyVmxheWNnZkNBbmJXOXVkR2duSUh3Z0ozbGxZWEluSUh3Z0oyRnNiQ2M3WEc1OU8xeHVYRzVsZUhCdmNuUWdkSGx3WlNCVGRXSnlaV1JrYVhSSFlXeHNaWEo1VDNCMGFXOXVjeUE5SUZScGJXVlBjSFJwYjI1eklId2dWRzl3VDNCMGFXOXVjenRjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdOdmJuTjBjblZqZEZOMVluSmxaR1JwZEVkaGJHeGxjbmxWY213b1hHNGdJRzl3ZEdsdmJuTTZJRk4xWW5KbFpHUnBkRWRoYkd4bGNubFBjSFJwYjI1elhHNHBPaUJWVWt3Z2UxeHVJQ0JzWlhRZ2RYSnBJRDBnWUNSN2IzQjBhVzl1Y3k1emRXSnlaV1JrYVhSOVlEdGNibHh1SUNCcFppQW9iM0IwYVc5dWN5NXpiM0owS1NCN1hHNGdJQ0FnZFhKcElDczlJR0F2Skh0dmNIUnBiMjV6TG5OdmNuUjlZRHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHZjSFJwYjI1ekxuTnZjblFnUFQwOUlDZDBiM0FuSUNZbUlHOXdkR2x2Ym5NdWQybHVaRzkzS1NCN1hHNGdJQ0FnZFhKcElDczlJR0F2Skh0dmNIUnBiMjV6TG5kcGJtUnZkMzFnTzF4dUlDQjlYRzVjYmlBZ2FXWWdLRzl3ZEdsdmJuTXVjR0ZuWlNrZ2UxeHVJQ0FnSUhWeWFTQXJQU0JnTHlSN2IzQjBhVzl1Y3k1d1lXZGxmV0E3WEc0Z0lIMWNibHh1SUNCamIyNXpkQ0IxY213Z1BTQnVaWGNnVlZKTUtGeHVJQ0FnSUdBa2UwbE5SMVZTWDBGUVNWOVFVa1ZHU1ZoOUx5UjdVMVZDVWtWRVJFbFVYMGRCVEV4RlVsbGZSVTVFVUU5SlRsUjlMeVI3ZFhKcGZXQmNiaUFnS1R0Y2JseHVJQ0J5WlhSMWNtNGdkWEpzTzF4dWZWeHVYRzVsZUhCdmNuUWdZWE41Ym1NZ1puVnVZM1JwYjI0Z1oyVjBVM1ZpY21Wa1pHbDBSMkZzYkdWeWVTaGNiaUFnWTJ4cFpXNTBPaUJKYldkMWNrTnNhV1Z1ZEN4Y2JpQWdiM0IwYVc5dWN6b2dVM1ZpY21Wa1pHbDBSMkZzYkdWeWVVOXdkR2x2Ym5OY2JpazZJRkJ5YjIxcGMyVThTVzFuZFhKQmNHbFNaWE53YjI1elpUeEhZV3hzWlhKNVJHRjBZVDQrSUh0Y2JpQWdZMjl1YzNRZ2V5QndZWFJvYm1GdFpTQjlJRDBnWTI5dWMzUnlkV04wVTNWaWNtVmtaR2wwUjJGc2JHVnllVlZ5YkNodmNIUnBiMjV6S1R0Y2JpQWdMeThnYzJsdVkyVWdkMlVuY21VZ2RYTnBibWNnY0hKbFptbDRWWEpzSUhkcGRHZ2daMjkwTENCM1pTQm9ZWFpsSUhSdklISmxiVzkyWlNCMGFHVWdjM1JoY25ScGJtY2djMnhoYzJnZ2IzSWdhWFFuYkd3Z2RHaHliM2RjYmlBZ1kyOXVjM1FnWm1sdVlXeFFZWFJvYm1GdFpTQTlJSEJoZEdodVlXMWxMbk5zYVdObEtERXBPMXh1WEc0Z0lISmxkSFZ5YmlCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxLR0YzWVdsMElHTnNhV1Z1ZEM1eVpYRjFaWE4wS0hzZ2RYSnNPaUJtYVc1aGJGQmhkR2h1WVcxbElIMHBLU0JoY3lCSmJXZDFja0Z3YVZKbGMzQnZibk5sUEVkaGJHeGxjbmxFWVhSaFBqdGNibjFjYmlJc0ltVjRjRzl5ZENBcUlHWnliMjBnSnk0dloyVjBSMkZzYkdWeWVTYzdYRzVsZUhCdmNuUWdLaUJtY205dElDY3VMMmRsZEZOMVluSmxaR1JwZEVkaGJHeGxjbmtuTzF4dVpYaHdiM0owSUNvZ1puSnZiU0FuTGk5elpXRnlZMmhIWVd4c1pYSjVKenRjYmlJc0ltbHRjRzl5ZENCN0lFbHRaM1Z5UTJ4cFpXNTBJSDBnWm5KdmJTQW5MaTR2WTJ4cFpXNTBKenRjYm1sdGNHOXlkQ0I3SUZORlFWSkRTRjlIUVV4TVJWSlpYMFZPUkZCUFNVNVVMQ0JKVFVkVlVsOUJVRWxmVUZKRlJrbFlJSDBnWm5KdmJTQW5MaTR2WTI5dGJXOXVMMlZ1WkhCdmFXNTBjeWM3WEc1cGJYQnZjblFnZXlCSmJXZDFja0Z3YVZKbGMzQnZibk5sTENCSFlXeHNaWEo1UkdGMFlTQjlJR1p5YjIwZ0p5NHVMMk52YlcxdmJpOTBlWEJsY3ljN1hHNXBiWEJ2Y25RZ2V5Qm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDNWMGFXeHpKenRjYm1sdGNHOXlkQ0I3SUZWU1RDQjlJR1p5YjIwZ0ozVnliQ2M3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRk5sWVhKamFFOXdkR2x2Ym5NZ1BTQjdYRzRnSUhFL09pQnpkSEpwYm1jN1hHNGdJSEYxWlhKNVB6b2djM1J5YVc1bk8xeHVJQ0J6YjNKMFB6b2dKM1JwYldVbklId2dKM1pwY21Gc0p6dGNiaUFnY0dGblpUODZJRzUxYldKbGNqdGNibjA3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRlJ2Y0ZObFlYSmphRTl3ZEdsdmJuTWdQU0JQYldsMFBGTmxZWEpqYUU5d2RHbHZibk1zSUNkemIzSjBKejRnSmlCN1hHNGdJSE52Y25RL09pQW5kRzl3Snp0Y2JpQWdkMmx1Wkc5M1B6b2dKMlJoZVNjZ2ZDQW5kMlZsYXljZ2ZDQW5iVzl1ZEdnbklId2dKM2xsWVhJbklId2dKMkZzYkNjN1hHNTlPMXh1WEc1bGVIQnZjblFnZEhsd1pTQkJaSFpoYm1ObFpGTmxZWEpqYUZGMVpYSjVVR0Z5WVcxbGRHVnljeUE5SUh0Y2JpQWdjVjloYkd3L09pQnpkSEpwYm1jN1hHNGdJSEZmWVc1NVB6b2djM1J5YVc1bk8xeHVJQ0J4WDJWNFlXTjBiSGsvT2lCemRISnBibWM3WEc0Z0lIRmZibTkwUHpvZ2MzUnlhVzVuTzF4dUlDQnhYM1I1Y0dVL09pQW5hbkJuSnlCOElDZHdibWNuSUh3Z0oyZHBaaWNnZkNBbllXNXBaMmxtSnlCOElDZGhiR0oxYlNjN1hHNGdJSEZmYzJsNlpWOXdlRDg2SUNkemJXRnNiQ2NnZkNBbmJXVmtKeUI4SUNkaWFXY25JSHdnSjJ4eVp5Y2dmQ0FuYUhWblpTYzdYRzU5TzF4dVhHNWpiMjV6ZENCaFpIWmhibU5sWkZCaGNtRnRaWFJsY25NNklFRnljbUY1UEd0bGVXOW1JRUZrZG1GdVkyVmtVMlZoY21Ob1VYVmxjbmxRWVhKaGJXVjBaWEp6UGlBOUlGdGNiaUFnSjNGZllXeHNKeXhjYmlBZ0ozRmZZVzU1Snl4Y2JpQWdKM0ZmWlhoaFkzUnNlU2NzWEc0Z0lDZHhYMjV2ZENjc1hHNGdJQ2R4WDNSNWNHVW5MRnh1SUNBbmNWOXphWHBsWDNCNEp5eGNibDA3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRk5sWVhKamFFZGhiR3hsY25sUGNIUnBiMjV6SUQwZ0tGTmxZWEpqYUU5d2RHbHZibk1nZkNCVWIzQlRaV0Z5WTJoUGNIUnBiMjV6S1NBbVhHNGdJRUZrZG1GdVkyVmtVMlZoY21Ob1VYVmxjbmxRWVhKaGJXVjBaWEp6TzF4dVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1kyOXVjM1J5ZFdOMFUyVmhjbU5vUjJGc2JHVnllVlZ5YkNodmNIUnBiMjV6T2lCVFpXRnlZMmhIWVd4c1pYSjVUM0IwYVc5dWN5azZJRlZTVENCN1hHNGdJR3hsZENCMWNta2dQU0FuSnp0Y2JseHVJQ0JwWmlBb2IzQjBhVzl1Y3k1emIzSjBLU0I3WEc0Z0lDQWdkWEpwSUNzOUlHQXZKSHR2Y0hScGIyNXpMbk52Y25SOVlEdGNiaUFnZlZ4dVhHNGdJR2xtSUNodmNIUnBiMjV6TG5OdmNuUWdQVDA5SUNkMGIzQW5JQ1ltSUc5d2RHbHZibk11ZDJsdVpHOTNLU0I3WEc0Z0lDQWdkWEpwSUNzOUlHQXZKSHR2Y0hScGIyNXpMbmRwYm1SdmQzMWdPMXh1SUNCOVhHNWNiaUFnYVdZZ0tHOXdkR2x2Ym5NdWNHRm5aU2tnZTF4dUlDQWdJSFZ5YVNBclBTQmdMeVI3YjNCMGFXOXVjeTV3WVdkbGZXQTdYRzRnSUgxY2JseHVJQ0JqYjI1emRDQjFjbXdnUFNCdVpYY2dWVkpNS0dBa2UwbE5SMVZTWDBGUVNWOVFVa1ZHU1ZoOUx5UjdVMFZCVWtOSVgwZEJURXhGVWxsZlJVNUVVRTlKVGxSOUpIdDFjbWw5WUNrN1hHNWNiaUFnWVdSMllXNWpaV1JRWVhKaGJXVjBaWEp6TG1admNrVmhZMmdvS0hCaGNtRnRLU0E5UGlCN1hHNGdJQ0FnYVdZZ0tHOXdkR2x2Ym5OYmNHRnlZVzFkUHk1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUhWeWJDNXpaV0Z5WTJoUVlYSmhiWE11WVhCd1pXNWtLSEJoY21GdExDQnZjSFJwYjI1elczQmhjbUZ0WFNCaGN5QnpkSEpwYm1jcE8xeHVJQ0FnSUgxY2JpQWdmU2s3WEc1Y2JpQWdhV1lnS0NGMWNtd3VjMlZoY21Ob0tTQjdYRzRnSUNBZ1kyOXVjM1FnY1hWbGNua2dQU0J2Y0hScGIyNXpMbkVnZkh3Z2IzQjBhVzl1Y3k1eGRXVnllVHRjYmlBZ0lDQnBaaUFvSVhGMVpYSjVLU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMDV2SUhGMVpYSjVJSGRoY3lCd2NtOTJhV1JsWkNjcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhWeWJDNXpaV0Z5WTJoUVlYSmhiWE11WVhCd1pXNWtLQ2R4Snl3Z2NYVmxjbmtwTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhWeWJEdGNibjFjYmx4dVpYaHdiM0owSUdGemVXNWpJR1oxYm1OMGFXOXVJSE5sWVhKamFFZGhiR3hsY25rb1hHNGdJR05zYVdWdWREb2dTVzFuZFhKRGJHbGxiblFzWEc0Z0lHOXdkR2x2Ym5NNklGTmxZWEpqYUVkaGJHeGxjbmxQY0hScGIyNXpYRzRwT2lCUWNtOXRhWE5sUEVsdFozVnlRWEJwVW1WemNHOXVjMlU4UjJGc2JHVnllVVJoZEdFK1BpQjdYRzRnSUdOdmJuTjBJSHNnY0dGMGFHNWhiV1VnZlNBOUlHTnZibk4wY25WamRGTmxZWEpqYUVkaGJHeGxjbmxWY213b2IzQjBhVzl1Y3lrN1hHNGdJQzh2SUhOcGJtTmxJSGRsSjNKbElIVnphVzVuSUhCeVpXWnBlRlZ5YkNCM2FYUm9JR2R2ZEN3Z2QyVWdhR0YyWlNCMGJ5QnlaVzF2ZG1VZ2RHaGxJSE4wWVhKMGFXNW5JSE5zWVhOb0lHOXlJR2wwSjJ4c0lIUm9jbTkzWEc0Z0lHTnZibk4wSUdacGJtRnNVR0YwYUc1aGJXVWdQU0J3WVhSb2JtRnRaUzV6YkdsalpTZ3hLVHRjYmx4dUlDQnlaWFIxY200Z1oyVjBTVzFuZFhKQmNHbFNaWE53YjI1elpVWnliMjFTWlhOd2IyNXpaU2hoZDJGcGRDQmpiR2xsYm5RdWNtVnhkV1Z6ZENoN0lIVnliRG9nWm1sdVlXeFFZWFJvYm1GdFpTQjlLU2tnWVhNZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlR4SFlXeHNaWEo1UkdGMFlUNDdYRzU5WEc0aUxDSnBiWEJ2Y25RZ2UxeHVJQ0JCWTJObGMzTlViMnRsYml4Y2JpQWdhWE5CWTJObGMzTlViMnRsYml4Y2JpQWdhWE5EYkdsbGJuUkpaQ3hjYmlBZ2FYTk1iMmRwYml4Y2JuMGdabkp2YlNBbkxpOWpiMjF0YjI0dmRIbHdaWE1uTzF4dWFXMXdiM0owSUhzZ1NXMW5kWEpEYkdsbGJuUWdmU0JtY205dElDY3VMMk5zYVdWdWRDYzdYRzVwYlhCdmNuUWdleUJKVFVkVlVsOUJVRWxmVUZKRlJrbFlMQ0JCVlZSSVQxSkpXa1ZmUlU1RVVFOUpUbFFnZlNCbWNtOXRJQ2N1TDJOdmJXMXZiaTlsYm1Sd2IybHVkSE1uTzF4dVhHNWxlSEJ2Y25RZ1lYTjVibU1nWm5WdVkzUnBiMjRnWjJWMFFYVjBhRzl5YVhwaGRHbHZia2hsWVdSbGNpaGNiaUFnWTJ4cFpXNTBPaUJKYldkMWNrTnNhV1Z1ZEZ4dUtUb2dVSEp2YldselpUeHpkSEpwYm1jK0lIdGNiaUFnYVdZZ0tHbHpRV05qWlhOelZHOXJaVzRvWTJ4cFpXNTBMbU55WldSbGJuUnBZV3h6S1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJnUW1WaGNtVnlJQ1I3WTJ4cFpXNTBMbU55WldSbGJuUnBZV3h6TG1GalkyVnpjMVJ2YTJWdWZXQTdYRzRnSUgxY2JseHVJQ0JwWmlBb2FYTkRiR2xsYm5SSlpDaGpiR2xsYm5RdVkzSmxaR1Z1ZEdsaGJITXBJQ1ltSUNGcGMweHZaMmx1S0dOc2FXVnVkQzVqY21Wa1pXNTBhV0ZzY3lrcElIdGNiaUFnSUNCeVpYUjFjbTRnWUVOc2FXVnVkQzFKUkNBa2UyTnNhV1Z1ZEM1amNtVmtaVzUwYVdGc2N5NWpiR2xsYm5SSlpIMWdPMXh1SUNCOVhHNWNiaUFnWTI5dWMzUWdleUJqYkdsbGJuUkpaQ3dnZFhObGNtNWhiV1VzSUhCaGMzTjNiM0prSUgwZ1BTQmpiR2xsYm5RdVkzSmxaR1Z1ZEdsaGJITTdYRzVjYmlBZ1kyOXVjM1FnYjNCMGFXOXVjem9nVW1WamIzSmtQSE4wY21sdVp5d2dkVzVyYm05M2JqNGdQU0I3WEc0Z0lDQWdkWEpzT2lCQlZWUklUMUpKV2tWZlJVNUVVRTlKVGxRc1hHNGdJQ0FnWW1GelpWVlNURG9nU1UxSFZWSmZRVkJKWDFCU1JVWkpXQ3hjYmlBZ0lDQndZWEpoYlhNNklIdGNiaUFnSUNBZ0lHTnNhV1Z1ZEY5cFpEb2dZMnhwWlc1MFNXUXNYRzRnSUNBZ0lDQnlaWE53YjI1elpWOTBlWEJsT2lBbmRHOXJaVzRuTEZ4dUlDQWdJSDBzWEc0Z0lIMDdYRzVjYmlBZ2JHVjBJSEpsYzNCdmJuTmxJRDBnWVhkaGFYUWdZMnhwWlc1MExuQnNZV2x1VW1WeGRXVnpkQ2h2Y0hScGIyNXpLVHRjYmx4dUlDQmpiMjV6ZENCamIyOXJhV1Z6SUQwZ1FYSnlZWGt1YVhOQmNuSmhlU2h5WlhOd2IyNXpaUzVvWldGa1pYSnpXeWR6WlhRdFkyOXZhMmxsSjEwcFhHNGdJQ0FnUHlCeVpYTndiMjV6WlM1b1pXRmtaWEp6V3lkelpYUXRZMjl2YTJsbEoxMWJNRjFjYmlBZ0lDQTZJSEpsYzNCdmJuTmxMbWhsWVdSbGNuTmJKM05sZEMxamIyOXJhV1VuWFR0Y2JseHVJQ0JwWmlBb0lXTnZiMnRwWlhNcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjA1dklHTnZiMnRwWlhNZ2QyVnlaU0J6WlhRZ1pIVnlhVzVuSUdGMWRHaHZjbWw2WVhScGIyNG5LVHRjYmlBZ2ZWeHVYRzRnSUdOdmJuTjBJRzFoZEdOb1pYTWdQU0JqYjI5cmFXVnpMbTFoZEdOb0tDY29Ybnc3S1Z0elhTcGhkWFJvYjNKcGVtVmZkRzlyWlc0OUtGdGVPMTBxS1NjcE8xeHVYRzRnSUdsbUlDZ2hiV0YwWTJobGN5QjhmQ0J0WVhSamFHVnpMbXhsYm1kMGFDQThJRE1wSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMVZ1WVdKc1pTQjBieUJtYVc1a0lHRjFkR2h2Y21sNlpWOTBiMnRsYmlCamIyOXJhV1VuS1R0Y2JpQWdmVnh1WEc0Z0lHTnZibk4wSUdGMWRHaHZjbWw2WlZSdmEyVnVJRDBnYldGMFkyaGxjMXN5WFR0Y2JseHVJQ0J2Y0hScGIyNXpMbTFsZEdodlpDQTlJQ2RRVDFOVUp6dGNiaUFnYjNCMGFXOXVjeTVrWVhSaElEMGdlMXh1SUNBZ0lIVnpaWEp1WVcxbExGeHVJQ0FnSUhCaGMzTjNiM0prTEZ4dUlDQWdJR0ZzYkc5M09pQmhkWFJvYjNKcGVtVlViMnRsYml4Y2JpQWdmVHRjYmx4dUlDQnZjSFJwYjI1ekxtWnZiR3h2ZDFKbFpHbHlaV04wSUQwZ1ptRnNjMlU3WEc0Z0lHOXdkR2x2Ym5NdWFHVmhaR1Z5Y3lBOUlIdGNiaUFnSUNCamIyOXJhV1U2SUdCaGRYUm9iM0pwZW1WZmRHOXJaVzQ5Skh0aGRYUm9iM0pwZW1WVWIydGxibjFnTEZ4dUlDQjlPMXh1WEc0Z0lISmxjM0J2Ym5ObElEMGdZWGRoYVhRZ1kyeHBaVzUwTG5Cc1lXbHVVbVZ4ZFdWemRDaHZjSFJwYjI1ektUdGNiaUFnWTI5dWMzUWdiRzlqWVhScGIyNGdQU0J5WlhOd2IyNXpaUzVvWldGa1pYSnpMbXh2WTJGMGFXOXVPMXh1SUNCcFppQW9JV3h2WTJGMGFXOXVLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZFZibUZpYkdVZ2RHOGdjR0Z5YzJVZ2JHOWpZWFJwYjI0bktUdGNiaUFnZlZ4dVhHNGdJR052Ym5OMElIUnZhMlZ1SUQwZ1NsTlBUaTV3WVhKelpTaGNiaUFnSUNBbmUxd2lKeUFyWEc0Z0lDQWdJQ0JrWldOdlpHVlZVa2tvYkc5allYUnBiMjR1YzJ4cFkyVW9iRzlqWVhScGIyNHVhVzVrWlhoUFppZ25JeWNwSUNzZ01Ta3BYRzRnSUNBZ0lDQWdJQzV5WlhCc1lXTmxLQzljSWk5bkxDQW5YRnhjWEZ3aUp5bGNiaUFnSUNBZ0lDQWdMbkpsY0d4aFkyVW9MeVl2Wnl3Z0oxd2lMRndpSnlsY2JpQWdJQ0FnSUNBZ0xuSmxjR3hoWTJVb0x6MHZaeXdnSjF3aU9sd2lKeWtnSzF4dUlDQWdJQ0FnSjF3aWZTZGNiaUFnS1R0Y2JseHVJQ0JqYjI1emRDQmhZMk5sYzNOVWIydGxiaUE5SUhSdmEyVnVMbUZqWTJWemMxOTBiMnRsYmp0Y2JpQWdLQ2hqYkdsbGJuUXVZM0psWkdWdWRHbGhiSE1nWVhNZ2RXNXJibTkzYmlrZ1lYTWdRV05qWlhOelZHOXJaVzRwTG1GalkyVnpjMVJ2YTJWdUlEMGdZV05qWlhOelZHOXJaVzQ3WEc0Z0lGeHVJQ0J5WlhSMWNtNGdZRUpsWVhKbGNpQWtlMkZqWTJWemMxUnZhMlZ1ZldBN1hHNTlYRzRpTENKcGJYQnZjblFnZXlCSmJXZDFja05zYVdWdWRDQjlJR1p5YjIwZ0p5NHVMMk5zYVdWdWRDYzdYRzVwYlhCdmNuUWdleUJKVFVGSFJWOUZUa1JRVDBsT1ZDQjlJR1p5YjIwZ0p5NHVMMk52YlcxdmJpOWxibVJ3YjJsdWRITW5PMXh1YVcxd2IzSjBJSHNnU1cxbmRYSkJjR2xTWlhOd2IyNXpaU0I5SUdaeWIyMGdKeTR1TDJOdmJXMXZiaTkwZVhCbGN5YzdYRzVwYlhCdmNuUWdleUJuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObElIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwzVjBhV3h6Snp0Y2JseHVaWGh3YjNKMElHRnplVzVqSUdaMWJtTjBhVzl1SUdSbGJHVjBaVWx0WVdkbEtGeHVJQ0JqYkdsbGJuUTZJRWx0WjNWeVEyeHBaVzUwTEZ4dUlDQnBiV0ZuWlVoaGMyZzZJSE4wY21sdVoxeHVLVG9nVUhKdmJXbHpaVHhKYldkMWNrRndhVkpsYzNCdmJuTmxQR0p2YjJ4bFlXNCtQaUI3WEc0Z0lHTnZibk4wSUhWeWJDQTlJR0FrZTBsTlFVZEZYMFZPUkZCUFNVNVVmUzhrZTJsdFlXZGxTR0Z6YUgxZ08xeHVJQ0J5WlhSMWNtNGdaMlYwU1cxbmRYSkJjR2xTWlhOd2IyNXpaVVp5YjIxU1pYTndiMjV6WlNoaGQyRnBkQ0JqYkdsbGJuUXVjbVZ4ZFdWemRDaDdJSFZ5YkN3Z2JXVjBhRzlrT2lBblJFVk1SVlJGSnlCOUtTa2dZWE1nU1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhpYjI5c1pXRnVQanRjYm4xY2JpSXNJbWx0Y0c5eWRDQjdJRWx0WjNWeVEyeHBaVzUwSUgwZ1puSnZiU0FuTGk0dlkyeHBaVzUwSnp0Y2JtbHRjRzl5ZENCN0lFbE5RVWRGWDBWT1JGQlBTVTVVSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDJWdVpIQnZhVzUwY3ljN1hHNXBiWEJ2Y25RZ2V5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObElIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwzUjVjR1Z6Snp0Y2JtbHRjRzl5ZENCN0lHZGxkRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVkdjbTl0VW1WemNHOXVjMlVnZlNCbWNtOXRJQ2N1TGk5amIyMXRiMjR2ZFhScGJITW5PMXh1WEc1bGVIQnZjblFnWVhONWJtTWdablZ1WTNScGIyNGdabUYyYjNKcGRHVkpiV0ZuWlNoY2JpQWdZMnhwWlc1ME9pQkpiV2QxY2tOc2FXVnVkQ3hjYmlBZ2FXMWhaMlZJWVhOb09pQnpkSEpwYm1kY2JpazZJRkJ5YjIxcGMyVThTVzFuZFhKQmNHbFNaWE53YjI1elpUd25abUYyYjNKcGRHVmtKejQrSUh0Y2JpQWdZMjl1YzNRZ2RYSnNJRDBnWUNSN1NVMUJSMFZmUlU1RVVFOUpUbFI5THlSN2FXMWhaMlZJWVhOb2ZTOW1ZWFp2Y21sMFpXQTdYRzRnSUhKbGRIVnliaUJuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObEtHRjNZV2wwSUdOc2FXVnVkQzV5WlhGMVpYTjBLSHNnZFhKc0xDQnRaWFJvYjJRNklDZFFUMU5VSnlCOUtTa2dZWE1nU1cxbmRYSkJjR2xTWlhOd2IyNXpaVHduWm1GMmIzSnBkR1ZrSno0N1hHNTlYRzRpTENKcGJYQnZjblFnZXlCSmJXZDFja05zYVdWdWRDQjlJR1p5YjIwZ0p5NHVMMk5zYVdWdWRDYzdYRzVwYlhCdmNuUWdleUJKVFVGSFJWOUZUa1JRVDBsT1ZDQjlJR1p5YjIwZ0p5NHVMMk52YlcxdmJpOWxibVJ3YjJsdWRITW5PMXh1YVcxd2IzSjBJSHNnU1cxbmRYSkJjR2xTWlhOd2IyNXpaU3dnU1cxaFoyVkVZWFJoSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDNSNWNHVnpKenRjYm1sdGNHOXlkQ0I3SUdkbGRFbHRaM1Z5UVhCcFVtVnpjRzl1YzJWR2NtOXRVbVZ6Y0c5dWMyVWdmU0JtY205dElDY3VMaTlqYjIxdGIyNHZkWFJwYkhNbk8xeHVYRzVsZUhCdmNuUWdZWE41Ym1NZ1puVnVZM1JwYjI0Z1oyVjBTVzFoWjJVb1hHNGdJR05zYVdWdWREb2dTVzFuZFhKRGJHbGxiblFzWEc0Z0lHbHRZV2RsU0dGemFEb2djM1J5YVc1blhHNHBPaUJRY205dGFYTmxQRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVThTVzFoWjJWRVlYUmhQajRnZTF4dUlDQmpiMjV6ZENCMWNtd2dQU0JnSkh0SlRVRkhSVjlGVGtSUVQwbE9WSDB2Skh0cGJXRm5aVWhoYzJoOVlEdGNiaUFnY21WMGRYSnVJR2RsZEVsdFozVnlRWEJwVW1WemNHOXVjMlZHY205dFVtVnpjRzl1YzJVb1lYZGhhWFFnWTJ4cFpXNTBMbkpsY1hWbGMzUW9leUIxY213Z2ZTa3BJR0Z6SUVsdFozVnlRWEJwVW1WemNHOXVjMlU4U1cxaFoyVkVZWFJoUGx4dWZWeHVJaXdpWlhod2IzSjBJQ29nWm5KdmJTQW5MaTlrWld4bGRHVkpiV0ZuWlNjN1hHNWxlSEJ2Y25RZ0tpQm1jbTl0SUNjdUwyWmhkbTl5YVhSbFNXMWhaMlVuTzF4dVpYaHdiM0owSUNvZ1puSnZiU0FuTGk5blpYUkpiV0ZuWlNjN1hHNWxlSEJ2Y25RZ0tpQm1jbTl0SUNjdUwzVndaR0YwWlVsdFlXZGxKenRjYm1WNGNHOXlkQ0FxSUdaeWIyMGdKeTR2ZFhCc2IyRmtKenRjYmlJc0ltbHRjRzl5ZENCN0lFbHRaM1Z5UTJ4cFpXNTBJSDBnWm5KdmJTQW5MaTR2WTJ4cFpXNTBKenRjYm1sdGNHOXlkQ0I3SUVsTlFVZEZYMFZPUkZCUFNVNVVJSDBnWm5KdmJTQW5MaTR2WTI5dGJXOXVMMlZ1WkhCdmFXNTBjeWM3WEc1cGJYQnZjblFnZXlCamNtVmhkR1ZHYjNKdExDQm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDNWMGFXeHpKenRjYm1sdGNHOXlkQ0I3SUZCaGVXeHZZV1FzSUVsdFozVnlRWEJwVW1WemNHOXVjMlVnZlNCbWNtOXRJQ2N1TGk5amIyMXRiMjR2ZEhsd1pYTW5PMXh1WEc1bGVIQnZjblFnYVc1MFpYSm1ZV05sSUZWd1pHRjBaVWx0WVdkbFVHRjViRzloWkZ4dUlDQmxlSFJsYm1SeklGQnBZMnM4VUdGNWJHOWhaQ3dnSjNScGRHeGxKeUI4SUNka1pYTmpjbWx3ZEdsdmJpYytJSHRjYmlBZ2FXMWhaMlZJWVhOb09pQnpkSEpwYm1jN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdselZtRnNhV1JWY0dSaGRHVlFZWGxzYjJGa0tIQTZJRlZ3WkdGMFpVbHRZV2RsVUdGNWJHOWhaQ2tnZTF4dUlDQnlaWFIxY200Z2RIbHdaVzltSUhBdWRHbDBiR1VnUFQwOUlDZHpkSEpwYm1jbklIeDhJSFI1Y0dWdlppQndMbVJsYzJOeWFYQjBhVzl1SUQwOVBTQW5jM1J5YVc1bkp6dGNibjFjYmx4dVpYaHdiM0owSUdGemVXNWpJR1oxYm1OMGFXOXVJSFZ3WkdGMFpVbHRZV2RsS0Z4dUlDQmpiR2xsYm5RNklFbHRaM1Z5UTJ4cFpXNTBMRnh1SUNCd1lYbHNiMkZrT2lCVmNHUmhkR1ZKYldGblpWQmhlV3h2WVdRZ2ZDQlZjR1JoZEdWSmJXRm5aVkJoZVd4dllXUmJYVnh1S1RvZ1VISnZiV2x6WlR4SmJXZDFja0Z3YVZKbGMzQnZibk5sUEdKdmIyeGxZVzQrSUh3Z1NXMW5kWEpCY0dsU1pYTndiMjV6WlR4aWIyOXNaV0Z1UGx0ZFBpQjdYRzRnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0hCaGVXeHZZV1FwS1NCN1hHNGdJQ0FnWTI5dWMzUWdjSEp2YldselpYTWdQU0J3WVhsc2IyRmtMbTFoY0Nnb2NEb2dWWEJrWVhSbFNXMWhaMlZRWVhsc2IyRmtLU0E5UGlCN1hHNGdJQ0FnSUNCcFppQW9JV2x6Vm1Gc2FXUlZjR1JoZEdWUVlYbHNiMkZrS0hBcEtTQjdYRzRnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25WWEJrWVhSbElISmxjWFZwY21WeklHRWdkR2wwYkdVZ1lXNWtMMjl5SUdSbGMyTnlhWEIwYVc5dUp5azdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJR052Ym5OMElIVnliQ0E5SUdBa2UwbE5RVWRGWDBWT1JGQlBTVTVVZlM4a2UzQXVhVzFoWjJWSVlYTm9mV0E3WEc0Z0lDQWdJQ0JqYjI1emRDQm1iM0p0SUQwZ1kzSmxZWFJsUm05eWJTaHdLVHRjYmlBZ0lDQWdJQzhxSUdWemJHbHVkQ0J1YnkxaGMzbHVZeTF3Y205dGFYTmxMV1Y0WldOMWRHOXlPaUF3SUNvdlhHNGdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lGQnliMjFwYzJVb1lYTjVibU1nWm5WdVkzUnBiMjRvY21WemIyeDJaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCeVpYTnZiSFpsS0dkbGRFbHRaM1Z5UVhCcFVtVnpjRzl1YzJWR2NtOXRVbVZ6Y0c5dWMyVW9ZWGRoYVhRZ1kyeHBaVzUwTG5KbGNYVmxjM1FvZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkWEpzTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdiV1YwYUc5a09pQW5VRTlUVkNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0JrWVhSaE9pQm1iM0p0TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnY21WemIyeDJaVUp2WkhsUGJteDVPaUIwY25WbExGeHVJQ0FnSUNBZ0lDQWdJSDBwS1NCaGN5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBHSnZiMnhsWVc0K0tWeHVJQ0FnSUNBZ0lDQjlLU0JoY3lCUWNtOXRhWE5sUEVsdFozVnlRWEJwVW1WemNHOXVjMlU4WW05dmJHVmhiajQrTzF4dUlDQWdJSDBwTzF4dVhHNGdJQ0FnY21WMGRYSnVJR0YzWVdsMElGQnliMjFwYzJVdVlXeHNLSEJ5YjIxcGMyVnpLVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDZ2hhWE5XWVd4cFpGVndaR0YwWlZCaGVXeHZZV1FvY0dGNWJHOWhaQ2twSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMVZ3WkdGMFpTQnlaWEYxYVhKbGN5QmhJSFJwZEd4bElHRnVaQzl2Y2lCa1pYTmpjbWx3ZEdsdmJpY3BPMXh1SUNCOVhHNWNiaUFnWTI5dWMzUWdkWEpzSUQwZ1lDUjdTVTFCUjBWZlJVNUVVRTlKVGxSOUx5UjdjR0Y1Ykc5aFpDNXBiV0ZuWlVoaGMyaDlZRHRjYmlBZ1kyOXVjM1FnWm05eWJTQTlJR055WldGMFpVWnZjbTBvY0dGNWJHOWhaQ2s3WEc0Z0lISmxkSFZ5YmlCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxLR0YzWVdsMElHTnNhV1Z1ZEM1eVpYRjFaWE4wS0h0Y2JpQWdJQ0IxY213c1hHNGdJQ0FnYldWMGFHOWtPaUFuVUU5VFZDY3NYRzRnSUNBZ1pHRjBZVG9nWm05eWJTeGNiaUFnSUNBdkx5QnlaWE52YkhabFFtOWtlVTl1YkhrNklIUnlkV1VzWEc0Z0lIMHBLU0JoY3lCSmJXZDFja0Z3YVZKbGMzQnZibk5sUEdKdmIyeGxZVzQrWEc1OVhHNGlMQ0pwYlhCdmNuUWdleUJKYldkMWNrTnNhV1Z1ZENCOUlHWnliMjBnSnk0dUwyTnNhV1Z1ZENjN1hHNXBiWEJ2Y25RZ2UxeHVJQ0JqY21WaGRHVkdiM0p0TEZ4dUlDQm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sTEZ4dUlDQXZMeUJuWlhSVGIzVnlZMlVzWEc1OUlHWnliMjBnSnk0dUwyTnZiVzF2Ymk5MWRHbHNjeWM3WEc1cGJYQnZjblFnZXlCUVlYbHNiMkZrTENCSmJXZDFja0Z3YVZKbGMzQnZibk5sTENCSmJXRm5aVVJoZEdFZ2ZTQm1jbTl0SUNjdUxpOWpiMjF0YjI0dmRIbHdaWE1uTzF4dWFXMXdiM0owSUhzZ1ZWQk1UMEZFWDBWT1JGQlBTVTVVSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDJWdVpIQnZhVzUwY3ljN1hHNWNibVY0Y0c5eWRDQmhjM2x1WXlCbWRXNWpkR2x2YmlCMWNHeHZZV1FvWEc0Z0lHTnNhV1Z1ZERvZ1NXMW5kWEpEYkdsbGJuUXNYRzRnSUhCaGVXeHZZV1E2SUhOMGNtbHVaeUI4SUhOMGNtbHVaMXRkSUh3Z1VHRjViRzloWkNCOElGQmhlV3h2WVdSYlhWeHVLVG9nVUhKdmJXbHpaVHhKYldkMWNrRndhVkpsYzNCdmJuTmxQRWx0WVdkbFJHRjBZVDRnZkNCSmJXZDFja0Z3YVZKbGMzQnZibk5sUEVsdFlXZGxSR0YwWVQ1YlhUNGdlMXh1SUNCcFppQW9RWEp5WVhrdWFYTkJjbkpoZVNod1lYbHNiMkZrS1NrZ2UxeHVJQ0FnSUdOdmJuTjBJSEJ5YjIxcGMyVnpJRDBnY0dGNWJHOWhaQzV0WVhBb0tIQTZJSE4wY21sdVp5QjhJRkJoZVd4dllXUXBJRDArSUh0Y2JpQWdJQ0FnSUdOdmJuTjBJR1p2Y20wZ1BTQmpjbVZoZEdWR2IzSnRLSEFwTzF4dVhHNGdJQ0FnSUNBdktpQmxjMnhwYm5RZ2JtOHRZWE41Ym1NdGNISnZiV2x6WlMxbGVHVmpkWFJ2Y2pvZ01DQXFMMXh1SUNBZ0lDQWdjbVYwZFhKdUlHNWxkeUJRY205dGFYTmxLR0Z6ZVc1aklDaHlaWE52YkhabEtTQTlQaUI3WEc0Z0lDQWdJQ0FnSUhKbGMyOXNkbVVvWjJWMFNXMW5kWEpCY0dsU1pYTndiMjV6WlVaeWIyMVNaWE53YjI1elpTaGNiaUFnSUNBZ0lDQWdJQ0FnSUdGM1lXbDBJR05zYVdWdWRDNXlaWEYxWlhOMEtIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2RYSnNPaUJWVUV4UFFVUmZSVTVFVUU5SlRsUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHMWxkR2h2WkRvZ0oxQlBVMVFuTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0JrWVhSaE9pQm1iM0p0TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J2YmxWd2JHOWhaRkJ5YjJkeVpYTnpPaUFvY0hKdlozSmxjM05GZG1WdWRDa2dQVDRnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuTnZiR1V1Ykc5bktIc2djSEp2WjNKbGMzTkZkbVZ1ZENCOUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiR2xsYm5RdVpXMXBkQ2duZFhCc2IyRmtVSEp2WjNKbGMzTW5MQ0I3SUM0dUxuQnliMmR5WlhOelJYWmxiblFnZlNrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUgwc1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5S1Z4dUlDQWdJQ0FnSUNBZ0lDa2dZWE1nU1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhKYldGblpVUmhkR0UrS1R0Y2JpQWdJQ0FnSUgwcElHRnpJRkJ5YjIxcGMyVThTVzFuZFhKQmNHbFNaWE53YjI1elpUeEpiV0ZuWlVSaGRHRStQanRjYmlBZ0lDQjlLVHRjYmlBZ0lDQnlaWFIxY200Z1lYZGhhWFFnVUhKdmJXbHpaUzVoYkd3b2NISnZiV2x6WlhNcE8xeHVJQ0I5WEc1Y2JpQWdZMjl1YzNRZ1ptOXliU0E5SUdOeVpXRjBaVVp2Y20wb2NHRjViRzloWkNrN1hHNGdJQzh2SUdOdmJuTjBJR2xrSUQwZ1JHRjBaUzV1YjNjdWRHOVRkSEpwYm1jb0tUdGNiaUFnWTI5dWMzUWdjbVZ4ZFdWemRDQTlJR0YzWVdsMElHTnNhV1Z1ZEM1eVpYRjFaWE4wS0h0Y2JpQWdJQ0IxY213NklGVlFURTlCUkY5RlRrUlFUMGxPVkN4Y2JpQWdJQ0J0WlhSb2IyUTZJQ2RRVDFOVUp5eGNiaUFnSUNCa1lYUmhPaUJtYjNKdExGeHVJQ0FnSUc5dVZYQnNiMkZrVUhKdlozSmxjM002SUNod2NtOW5jbVZ6YzBWMlpXNTBLU0E5UGlCN1hHNGdJQ0FnSUNCamIyNXpiMnhsTG14dlp5aDdJSEJ5YjJkeVpYTnpSWFpsYm5RZ2ZTazdYRzRnSUNBZ0lDQmpiR2xsYm5RdVpXMXBkQ2duZFhCc2IyRmtVSEp2WjNKbGMzTW5MQ0I3SUM0dUxuQnliMmR5WlhOelJYWmxiblFnZlNrN1hHNGdJQ0FnZlN4Y2JpQWdmU2s3WEc1Y2JpQWdjbVYwZFhKdUlGQnliMjFwYzJVdWNtVnpiMngyWlNoY2JpQWdJQ0JuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObEtISmxjWFZsYzNRcElHRnpJRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVThTVzFoWjJWRVlYUmhQbHh1SUNBcE8xeHVmVnh1SWl3aUx5b2hJQ29xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcVhISmNia052Y0hseWFXZG9kQ0FvWXlrZ1RXbGpjbTl6YjJaMElFTnZjbkJ2Y21GMGFXOXVMbHh5WEc1Y2NseHVVR1Z5YldsemMybHZiaUIwYnlCMWMyVXNJR052Y0hrc0lHMXZaR2xtZVN3Z1lXNWtMMjl5SUdScGMzUnlhV0oxZEdVZ2RHaHBjeUJ6YjJaMGQyRnlaU0JtYjNJZ1lXNTVYSEpjYm5CMWNuQnZjMlVnZDJsMGFDQnZjaUIzYVhSb2IzVjBJR1psWlNCcGN5Qm9aWEpsWW5rZ1ozSmhiblJsWkM1Y2NseHVYSEpjYmxSSVJTQlRUMFpVVjBGU1JTQkpVeUJRVWs5V1NVUkZSQ0JjSWtGVElFbFRYQ0lnUVU1RUlGUklSU0JCVlZSSVQxSWdSRWxUUTB4QlNVMVRJRUZNVENCWFFWSlNRVTVVU1VWVElGZEpWRWhjY2x4dVVrVkhRVkpFSUZSUElGUklTVk1nVTA5R1ZGZEJVa1VnU1U1RFRGVkVTVTVISUVGTVRDQkpUVkJNU1VWRUlGZEJVbEpCVGxSSlJWTWdUMFlnVFVWU1EwaEJUbFJCUWtsTVNWUlpYSEpjYmtGT1JDQkdTVlJPUlZOVExpQkpUaUJPVHlCRlZrVk9WQ0JUU0VGTVRDQlVTRVVnUVZWVVNFOVNJRUpGSUV4SlFVSk1SU0JHVDFJZ1FVNVpJRk5RUlVOSlFVd3NJRVJKVWtWRFZDeGNjbHh1U1U1RVNWSkZRMVFzSUU5U0lFTlBUbE5GVVZWRlRsUkpRVXdnUkVGTlFVZEZVeUJQVWlCQlRsa2dSRUZOUVVkRlV5QlhTRUZVVTA5RlZrVlNJRkpGVTFWTVZFbE9SeUJHVWs5TlhISmNia3hQVTFNZ1QwWWdWVk5GTENCRVFWUkJJRTlTSUZCU1QwWkpWRk1zSUZkSVJWUklSVklnU1U0Z1FVNGdRVU5VU1U5T0lFOUdJRU5QVGxSU1FVTlVMQ0JPUlVkTVNVZEZUa05GSUU5U1hISmNiazlVU0VWU0lGUlBVbFJKVDFWVElFRkRWRWxQVGl3Z1FWSkpVMGxPUnlCUFZWUWdUMFlnVDFJZ1NVNGdRMDlPVGtWRFZFbFBUaUJYU1ZSSUlGUklSU0JWVTBVZ1QxSmNjbHh1VUVWU1JrOVNUVUZPUTBVZ1QwWWdWRWhKVXlCVFQwWlVWMEZTUlM1Y2NseHVLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvZ0tpOWNjbHh1THlvZ1oyeHZZbUZzSUZKbFpteGxZM1FzSUZCeWIyMXBjMlVnS2k5Y2NseHVYSEpjYm5aaGNpQmxlSFJsYm1SVGRHRjBhV056SUQwZ1puVnVZM1JwYjI0b1pDd2dZaWtnZTF4eVhHNGdJQ0FnWlhoMFpXNWtVM1JoZEdsamN5QTlJRTlpYW1WamRDNXpaWFJRY205MGIzUjVjR1ZQWmlCOGZGeHlYRzRnSUNBZ0lDQWdJQ2g3SUY5ZmNISnZkRzlmWHpvZ1cxMGdmU0JwYm5OMFlXNWpaVzltSUVGeWNtRjVJQ1ltSUdaMWJtTjBhVzl1SUNoa0xDQmlLU0I3SUdRdVgxOXdjbTkwYjE5ZklEMGdZanNnZlNrZ2ZIeGNjbHh1SUNBZ0lDQWdJQ0JtZFc1amRHbHZiaUFvWkN3Z1lpa2dleUJtYjNJZ0tIWmhjaUJ3SUdsdUlHSXBJR2xtSUNoaUxtaGhjMDkzYmxCeWIzQmxjblI1S0hBcEtTQmtXM0JkSUQwZ1lsdHdYVHNnZlR0Y2NseHVJQ0FnSUhKbGRIVnliaUJsZUhSbGJtUlRkR0YwYVdOektHUXNJR0lwTzF4eVhHNTlPMXh5WEc1Y2NseHVaWGh3YjNKMElHWjFibU4wYVc5dUlGOWZaWGgwWlc1a2N5aGtMQ0JpS1NCN1hISmNiaUFnSUNCbGVIUmxibVJUZEdGMGFXTnpLR1FzSUdJcE8xeHlYRzRnSUNBZ1puVnVZM1JwYjI0Z1gxOG9LU0I3SUhSb2FYTXVZMjl1YzNSeWRXTjBiM0lnUFNCa095QjlYSEpjYmlBZ0lDQmtMbkJ5YjNSdmRIbHdaU0E5SUdJZ1BUMDlJRzUxYkd3Z1B5QlBZbXBsWTNRdVkzSmxZWFJsS0dJcElEb2dLRjlmTG5CeWIzUnZkSGx3WlNBOUlHSXVjSEp2ZEc5MGVYQmxMQ0J1WlhjZ1gxOG9LU2s3WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCMllYSWdYMTloYzNOcFoyNGdQU0JtZFc1amRHbHZiaWdwSUh0Y2NseHVJQ0FnSUY5ZllYTnphV2R1SUQwZ1QySnFaV04wTG1GemMybG5iaUI4ZkNCbWRXNWpkR2x2YmlCZlgyRnpjMmxuYmloMEtTQjdYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaDJZWElnY3l3Z2FTQTlJREVzSUc0Z1BTQmhjbWQxYldWdWRITXViR1Z1WjNSb095QnBJRHdnYmpzZ2FTc3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSE1nUFNCaGNtZDFiV1Z1ZEhOYmFWMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlIQWdhVzRnY3lrZ2FXWWdLRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVhR0Z6VDNkdVVISnZjR1Z5ZEhrdVkyRnNiQ2h6TENCd0tTa2dkRnR3WFNBOUlITmJjRjA3WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lDQWdjbVYwZFhKdUlGOWZZWE56YVdkdUxtRndjR3g1S0hSb2FYTXNJR0Z5WjNWdFpXNTBjeWs3WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgzSmxjM1FvY3l3Z1pTa2dlMXh5WEc0Z0lDQWdkbUZ5SUhRZ1BTQjdmVHRjY2x4dUlDQWdJR1p2Y2lBb2RtRnlJSEFnYVc0Z2N5a2dhV1lnS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1YUdGelQzZHVVSEp2Y0dWeWRIa3VZMkZzYkNoekxDQndLU0FtSmlCbExtbHVaR1Y0VDJZb2NDa2dQQ0F3S1Z4eVhHNGdJQ0FnSUNBZ0lIUmJjRjBnUFNCelczQmRPMXh5WEc0Z0lDQWdhV1lnS0hNZ0lUMGdiblZzYkNBbUppQjBlWEJsYjJZZ1QySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVVM2x0WW05c2N5QTlQVDBnWENKbWRXNWpkR2x2Ymx3aUtWeHlYRzRnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd0xDQndJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVUzbHRZbTlzY3loektUc2dhU0E4SUhBdWJHVnVaM1JvT3lCcEt5c3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0dVdWFXNWtaWGhQWmlod1cybGRLU0E4SURBZ0ppWWdUMkpxWldOMExuQnliM1J2ZEhsd1pTNXdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaUzVqWVd4c0tITXNJSEJiYVYwcEtWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkRnR3VzJsZFhTQTlJSE5iY0Z0cFhWMDdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnY21WMGRYSnVJSFE3WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgyUmxZMjl5WVhSbEtHUmxZMjl5WVhSdmNuTXNJSFJoY21kbGRDd2dhMlY1TENCa1pYTmpLU0I3WEhKY2JpQWdJQ0IyWVhJZ1l5QTlJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ3NJSElnUFNCaklEd2dNeUEvSUhSaGNtZGxkQ0E2SUdSbGMyTWdQVDA5SUc1MWJHd2dQeUJrWlhOaklEMGdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y2loMFlYSm5aWFFzSUd0bGVTa2dPaUJrWlhOakxDQmtPMXh5WEc0Z0lDQWdhV1lnS0hSNWNHVnZaaUJTWldac1pXTjBJRDA5UFNCY0ltOWlhbVZqZEZ3aUlDWW1JSFI1Y0dWdlppQlNaV1pzWldOMExtUmxZMjl5WVhSbElEMDlQU0JjSW1aMWJtTjBhVzl1WENJcElISWdQU0JTWldac1pXTjBMbVJsWTI5eVlYUmxLR1JsWTI5eVlYUnZjbk1zSUhSaGNtZGxkQ3dnYTJWNUxDQmtaWE5qS1R0Y2NseHVJQ0FnSUdWc2MyVWdabTl5SUNoMllYSWdhU0E5SUdSbFkyOXlZWFJ2Y25NdWJHVnVaM1JvSUMwZ01Uc2dhU0ErUFNBd095QnBMUzBwSUdsbUlDaGtJRDBnWkdWamIzSmhkRzl5YzF0cFhTa2djaUE5SUNoaklEd2dNeUEvSUdRb2Npa2dPaUJqSUQ0Z015QS9JR1FvZEdGeVoyVjBMQ0JyWlhrc0lISXBJRG9nWkNoMFlYSm5aWFFzSUd0bGVTa3BJSHg4SUhJN1hISmNiaUFnSUNCeVpYUjFjbTRnWXlBK0lETWdKaVlnY2lBbUppQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvZEdGeVoyVjBMQ0JyWlhrc0lISXBMQ0J5TzF4eVhHNTlYSEpjYmx4eVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1gxOXdZWEpoYlNod1lYSmhiVWx1WkdWNExDQmtaV052Y21GMGIzSXBJSHRjY2x4dUlDQWdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpQW9kR0Z5WjJWMExDQnJaWGtwSUhzZ1pHVmpiM0poZEc5eUtIUmhjbWRsZEN3Z2EyVjVMQ0J3WVhKaGJVbHVaR1Y0S1RzZ2ZWeHlYRzU5WEhKY2JseHlYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdYMTl0WlhSaFpHRjBZU2h0WlhSaFpHRjBZVXRsZVN3Z2JXVjBZV1JoZEdGV1lXeDFaU2tnZTF4eVhHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCU1pXWnNaV04wSUQwOVBTQmNJbTlpYW1WamRGd2lJQ1ltSUhSNWNHVnZaaUJTWldac1pXTjBMbTFsZEdGa1lYUmhJRDA5UFNCY0ltWjFibU4wYVc5dVhDSXBJSEpsZEhWeWJpQlNaV1pzWldOMExtMWxkR0ZrWVhSaEtHMWxkR0ZrWVhSaFMyVjVMQ0J0WlhSaFpHRjBZVlpoYkhWbEtUdGNjbHh1ZlZ4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmWVhkaGFYUmxjaWgwYUdselFYSm5MQ0JmWVhKbmRXMWxiblJ6TENCUUxDQm5aVzVsY21GMGIzSXBJSHRjY2x4dUlDQWdJR1oxYm1OMGFXOXVJR0ZrYjNCMEtIWmhiSFZsS1NCN0lISmxkSFZ5YmlCMllXeDFaU0JwYm5OMFlXNWpaVzltSUZBZ1B5QjJZV3gxWlNBNklHNWxkeUJRS0daMWJtTjBhVzl1SUNoeVpYTnZiSFpsS1NCN0lISmxjMjlzZG1Vb2RtRnNkV1VwT3lCOUtUc2dmVnh5WEc0Z0lDQWdjbVYwZFhKdUlHNWxkeUFvVUNCOGZDQW9VQ0E5SUZCeWIyMXBjMlVwS1NobWRXNWpkR2x2YmlBb2NtVnpiMngyWlN3Z2NtVnFaV04wS1NCN1hISmNiaUFnSUNBZ0lDQWdablZ1WTNScGIyNGdablZzWm1sc2JHVmtLSFpoYkhWbEtTQjdJSFJ5ZVNCN0lITjBaWEFvWjJWdVpYSmhkRzl5TG01bGVIUW9kbUZzZFdVcEtUc2dmU0JqWVhSamFDQW9aU2tnZXlCeVpXcGxZM1FvWlNrN0lIMGdmVnh5WEc0Z0lDQWdJQ0FnSUdaMWJtTjBhVzl1SUhKbGFtVmpkR1ZrS0haaGJIVmxLU0I3SUhSeWVTQjdJSE4wWlhBb1oyVnVaWEpoZEc5eVcxd2lkR2h5YjNkY0lsMG9kbUZzZFdVcEtUc2dmU0JqWVhSamFDQW9aU2tnZXlCeVpXcGxZM1FvWlNrN0lIMGdmVnh5WEc0Z0lDQWdJQ0FnSUdaMWJtTjBhVzl1SUhOMFpYQW9jbVZ6ZFd4MEtTQjdJSEpsYzNWc2RDNWtiMjVsSUQ4Z2NtVnpiMngyWlNoeVpYTjFiSFF1ZG1Gc2RXVXBJRG9nWVdSdmNIUW9jbVZ6ZFd4MExuWmhiSFZsS1M1MGFHVnVLR1oxYkdacGJHeGxaQ3dnY21WcVpXTjBaV1FwT3lCOVhISmNiaUFnSUNBZ0lDQWdjM1JsY0Nnb1oyVnVaWEpoZEc5eUlEMGdaMlZ1WlhKaGRHOXlMbUZ3Y0d4NUtIUm9hWE5CY21jc0lGOWhjbWQxYldWdWRITWdmSHdnVzEwcEtTNXVaWGgwS0NrcE8xeHlYRzRnSUNBZ2ZTazdYSEpjYm4xY2NseHVYSEpjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJmWDJkbGJtVnlZWFJ2Y2loMGFHbHpRWEpuTENCaWIyUjVLU0I3WEhKY2JpQWdJQ0IyWVhJZ1h5QTlJSHNnYkdGaVpXdzZJREFzSUhObGJuUTZJR1oxYm1OMGFXOXVLQ2tnZXlCcFppQW9kRnN3WFNBbUlERXBJSFJvY205M0lIUmJNVjA3SUhKbGRIVnliaUIwV3pGZE95QjlMQ0IwY25sek9pQmJYU3dnYjNCek9pQmJYU0I5TENCbUxDQjVMQ0IwTENCbk8xeHlYRzRnSUNBZ2NtVjBkWEp1SUdjZ1BTQjdJRzVsZUhRNklIWmxjbUlvTUNrc0lGd2lkR2h5YjNkY0lqb2dkbVZ5WWlneEtTd2dYQ0p5WlhSMWNtNWNJam9nZG1WeVlpZ3lLU0I5TENCMGVYQmxiMllnVTNsdFltOXNJRDA5UFNCY0ltWjFibU4wYVc5dVhDSWdKaVlnS0dkYlUzbHRZbTlzTG1sMFpYSmhkRzl5WFNBOUlHWjFibU4wYVc5dUtDa2dleUJ5WlhSMWNtNGdkR2hwY3pzZ2ZTa3NJR2M3WEhKY2JpQWdJQ0JtZFc1amRHbHZiaUIyWlhKaUtHNHBJSHNnY21WMGRYSnVJR1oxYm1OMGFXOXVJQ2gyS1NCN0lISmxkSFZ5YmlCemRHVndLRnR1TENCMlhTazdJSDA3SUgxY2NseHVJQ0FnSUdaMWJtTjBhVzl1SUhOMFpYQW9iM0FwSUh0Y2NseHVJQ0FnSUNBZ0lDQnBaaUFvWmlrZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpaGNJa2RsYm1WeVlYUnZjaUJwY3lCaGJISmxZV1I1SUdWNFpXTjFkR2x1Wnk1Y0lpazdYSEpjYmlBZ0lDQWdJQ0FnZDJocGJHVWdLRjhwSUhSeWVTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2htSUQwZ01Td2dlU0FtSmlBb2RDQTlJRzl3V3pCZElDWWdNaUEvSUhsYlhDSnlaWFIxY201Y0lsMGdPaUJ2Y0Zzd1hTQS9JSGxiWENKMGFISnZkMXdpWFNCOGZDQW9LSFFnUFNCNVcxd2ljbVYwZFhKdVhDSmRLU0FtSmlCMExtTmhiR3dvZVNrc0lEQXBJRG9nZVM1dVpYaDBLU0FtSmlBaEtIUWdQU0IwTG1OaGJHd29lU3dnYjNCYk1WMHBLUzVrYjI1bEtTQnlaWFIxY200Z2REdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSGtnUFNBd0xDQjBLU0J2Y0NBOUlGdHZjRnN3WFNBbUlESXNJSFF1ZG1Gc2RXVmRPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnpkMmwwWTJnZ0tHOXdXekJkS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpZWE5sSURBNklHTmhjMlVnTVRvZ2RDQTlJRzl3T3lCaWNtVmhhenRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdORG9nWHk1c1lXSmxiQ3NyT3lCeVpYUjFjbTRnZXlCMllXeDFaVG9nYjNCYk1WMHNJR1J2Ym1VNklHWmhiSE5sSUgwN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpZWE5sSURVNklGOHViR0ZpWld3ckt6c2dlU0E5SUc5d1d6RmRPeUJ2Y0NBOUlGc3dYVHNnWTI5dWRHbHVkV1U3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCallYTmxJRGM2SUc5d0lEMGdYeTV2Y0hNdWNHOXdLQ2s3SUY4dWRISjVjeTV3YjNBb0tUc2dZMjl1ZEdsdWRXVTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JrWldaaGRXeDBPbHh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2doS0hRZ1BTQmZMblJ5ZVhNc0lIUWdQU0IwTG14bGJtZDBhQ0ErSURBZ0ppWWdkRnQwTG14bGJtZDBhQ0F0SURGZEtTQW1KaUFvYjNCYk1GMGdQVDA5SURZZ2ZId2diM0JiTUYwZ1BUMDlJRElwS1NCN0lGOGdQU0F3T3lCamIyNTBhVzUxWlRzZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaHZjRnN3WFNBOVBUMGdNeUFtSmlBb0lYUWdmSHdnS0c5d1d6RmRJRDRnZEZzd1hTQW1KaUJ2Y0ZzeFhTQThJSFJiTTEwcEtTa2dleUJmTG14aFltVnNJRDBnYjNCYk1WMDdJR0p5WldGck95QjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLRzl3V3pCZElEMDlQU0EySUNZbUlGOHViR0ZpWld3Z1BDQjBXekZkS1NCN0lGOHViR0ZpWld3Z1BTQjBXekZkT3lCMElEMGdiM0E3SUdKeVpXRnJPeUI5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hRZ0ppWWdYeTVzWVdKbGJDQThJSFJiTWwwcElIc2dYeTVzWVdKbGJDQTlJSFJiTWwwN0lGOHViM0J6TG5CMWMyZ29iM0FwT3lCaWNtVmhhenNnZlZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoMFd6SmRLU0JmTG05d2N5NXdiM0FvS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JmTG5SeWVYTXVjRzl3S0NrN0lHTnZiblJwYm5WbE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUc5d0lEMGdZbTlrZVM1allXeHNLSFJvYVhOQmNtY3NJRjhwTzF4eVhHNGdJQ0FnSUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHNnYjNBZ1BTQmJOaXdnWlYwN0lIa2dQU0F3T3lCOUlHWnBibUZzYkhrZ2V5Qm1JRDBnZENBOUlEQTdJSDFjY2x4dUlDQWdJQ0FnSUNCcFppQW9iM0JiTUYwZ0ppQTFLU0IwYUhKdmR5QnZjRnN4WFRzZ2NtVjBkWEp1SUhzZ2RtRnNkV1U2SUc5d1d6QmRJRDhnYjNCYk1WMGdPaUIyYjJsa0lEQXNJR1J2Ym1VNklIUnlkV1VnZlR0Y2NseHVJQ0FnSUgxY2NseHVmVnh5WEc1Y2NseHVaWGh3YjNKMElHWjFibU4wYVc5dUlGOWZZM0psWVhSbFFtbHVaR2x1WnlodkxDQnRMQ0JyTENCck1pa2dlMXh5WEc0Z0lDQWdhV1lnS0dzeUlEMDlQU0IxYm1SbFptbHVaV1FwSUdzeUlEMGdhenRjY2x4dUlDQWdJRzliYXpKZElEMGdiVnRyWFR0Y2NseHVmVnh5WEc1Y2NseHVaWGh3YjNKMElHWjFibU4wYVc5dUlGOWZaWGh3YjNKMFUzUmhjaWh0TENCbGVIQnZjblJ6S1NCN1hISmNiaUFnSUNCbWIzSWdLSFpoY2lCd0lHbHVJRzBwSUdsbUlDaHdJQ0U5UFNCY0ltUmxabUYxYkhSY0lpQW1KaUFoWlhod2IzSjBjeTVvWVhOUGQyNVFjbTl3WlhKMGVTaHdLU2tnWlhod2IzSjBjMXR3WFNBOUlHMWJjRjA3WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgzWmhiSFZsY3lodktTQjdYSEpjYmlBZ0lDQjJZWElnY3lBOUlIUjVjR1Z2WmlCVGVXMWliMndnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCVGVXMWliMnd1YVhSbGNtRjBiM0lzSUcwZ1BTQnpJQ1ltSUc5YmMxMHNJR2tnUFNBd08xeHlYRzRnSUNBZ2FXWWdLRzBwSUhKbGRIVnliaUJ0TG1OaGJHd29ieWs3WEhKY2JpQWdJQ0JwWmlBb2J5QW1KaUIwZVhCbGIyWWdieTVzWlc1bmRHZ2dQVDA5SUZ3aWJuVnRZbVZ5WENJcElISmxkSFZ5YmlCN1hISmNiaUFnSUNBZ0lDQWdibVY0ZERvZ1puVnVZM1JwYjI0Z0tDa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvYnlBbUppQnBJRDQ5SUc4dWJHVnVaM1JvS1NCdklEMGdkbTlwWkNBd08xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnZXlCMllXeDFaVG9nYnlBbUppQnZXMmtySzEwc0lHUnZibVU2SUNGdklIMDdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnZlR0Y2NseHVJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb2N5QS9JRndpVDJKcVpXTjBJR2x6SUc1dmRDQnBkR1Z5WVdKc1pTNWNJaUE2SUZ3aVUzbHRZbTlzTG1sMFpYSmhkRzl5SUdseklHNXZkQ0JrWldacGJtVmtMbHdpS1R0Y2NseHVmVnh5WEc1Y2NseHVaWGh3YjNKMElHWjFibU4wYVc5dUlGOWZjbVZoWkNodkxDQnVLU0I3WEhKY2JpQWdJQ0IyWVhJZ2JTQTlJSFI1Y0dWdlppQlRlVzFpYjJ3Z1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQnZXMU41YldKdmJDNXBkR1Z5WVhSdmNsMDdYSEpjYmlBZ0lDQnBaaUFvSVcwcElISmxkSFZ5YmlCdk8xeHlYRzRnSUNBZ2RtRnlJR2tnUFNCdExtTmhiR3dvYnlrc0lISXNJR0Z5SUQwZ1cxMHNJR1U3WEhKY2JpQWdJQ0IwY25rZ2UxeHlYRzRnSUNBZ0lDQWdJSGRvYVd4bElDZ29iaUE5UFQwZ2RtOXBaQ0F3SUh4OElHNHRMU0ErSURBcElDWW1JQ0VvY2lBOUlHa3VibVY0ZENncEtTNWtiMjVsS1NCaGNpNXdkWE5vS0hJdWRtRnNkV1VwTzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnWTJGMFkyZ2dLR1Z5Y205eUtTQjdJR1VnUFNCN0lHVnljbTl5T2lCbGNuSnZjaUI5T3lCOVhISmNiaUFnSUNCbWFXNWhiR3g1SUh0Y2NseHVJQ0FnSUNBZ0lDQjBjbmtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2NpQW1KaUFoY2k1a2IyNWxJQ1ltSUNodElEMGdhVnRjSW5KbGRIVnlibHdpWFNrcElHMHVZMkZzYkNocEtUdGNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ1ptbHVZV3hzZVNCN0lHbG1JQ2hsS1NCMGFISnZkeUJsTG1WeWNtOXlPeUI5WEhKY2JpQWdJQ0I5WEhKY2JpQWdJQ0J5WlhSMWNtNGdZWEk3WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgzTndjbVZoWkNncElIdGNjbHh1SUNBZ0lHWnZjaUFvZG1GeUlHRnlJRDBnVzEwc0lHa2dQU0F3T3lCcElEd2dZWEpuZFcxbGJuUnpMbXhsYm1kMGFEc2dhU3NyS1Z4eVhHNGdJQ0FnSUNBZ0lHRnlJRDBnWVhJdVkyOXVZMkYwS0Y5ZmNtVmhaQ2hoY21kMWJXVnVkSE5iYVYwcEtUdGNjbHh1SUNBZ0lISmxkSFZ5YmlCaGNqdGNjbHh1ZlZ4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmYzNCeVpXRmtRWEp5WVhsektDa2dlMXh5WEc0Z0lDQWdabTl5SUNoMllYSWdjeUE5SURBc0lHa2dQU0F3TENCcGJDQTlJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZzdJR2tnUENCcGJEc2dhU3NyS1NCeklDczlJR0Z5WjNWdFpXNTBjMXRwWFM1c1pXNW5kR2c3WEhKY2JpQWdJQ0JtYjNJZ0tIWmhjaUJ5SUQwZ1FYSnlZWGtvY3lrc0lHc2dQU0F3TENCcElEMGdNRHNnYVNBOElHbHNPeUJwS3lzcFhISmNiaUFnSUNBZ0lDQWdabTl5SUNoMllYSWdZU0E5SUdGeVozVnRaVzUwYzF0cFhTd2dhaUE5SURBc0lHcHNJRDBnWVM1c1pXNW5kR2c3SUdvZ1BDQnFiRHNnYWlzckxDQnJLeXNwWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSEpiYTEwZ1BTQmhXMnBkTzF4eVhHNGdJQ0FnY21WMGRYSnVJSEk3WEhKY2JuMDdYSEpjYmx4eVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1gxOWhkMkZwZENoMktTQjdYSEpjYmlBZ0lDQnlaWFIxY200Z2RHaHBjeUJwYm5OMFlXNWpaVzltSUY5ZllYZGhhWFFnUHlBb2RHaHBjeTUySUQwZ2Rpd2dkR2hwY3lrZ09pQnVaWGNnWDE5aGQyRnBkQ2gyS1R0Y2NseHVmVnh5WEc1Y2NseHVaWGh3YjNKMElHWjFibU4wYVc5dUlGOWZZWE41Ym1OSFpXNWxjbUYwYjNJb2RHaHBjMEZ5Wnl3Z1gyRnlaM1Z0Wlc1MGN5d2daMlZ1WlhKaGRHOXlLU0I3WEhKY2JpQWdJQ0JwWmlBb0lWTjViV0p2YkM1aGMzbHVZMGwwWlhKaGRHOXlLU0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0Z3aVUzbHRZbTlzTG1GemVXNWpTWFJsY21GMGIzSWdhWE1nYm05MElHUmxabWx1WldRdVhDSXBPMXh5WEc0Z0lDQWdkbUZ5SUdjZ1BTQm5aVzVsY21GMGIzSXVZWEJ3Ykhrb2RHaHBjMEZ5Wnl3Z1gyRnlaM1Z0Wlc1MGN5QjhmQ0JiWFNrc0lHa3NJSEVnUFNCYlhUdGNjbHh1SUNBZ0lISmxkSFZ5YmlCcElEMGdlMzBzSUhabGNtSW9YQ0p1WlhoMFhDSXBMQ0IyWlhKaUtGd2lkR2h5YjNkY0lpa3NJSFpsY21Jb1hDSnlaWFIxY201Y0lpa3NJR2xiVTNsdFltOXNMbUZ6ZVc1alNYUmxjbUYwYjNKZElEMGdablZ1WTNScGIyNGdLQ2tnZXlCeVpYUjFjbTRnZEdocGN6c2dmU3dnYVR0Y2NseHVJQ0FnSUdaMWJtTjBhVzl1SUhabGNtSW9iaWtnZXlCcFppQW9aMXR1WFNrZ2FWdHVYU0E5SUdaMWJtTjBhVzl1SUNoMktTQjdJSEpsZEhWeWJpQnVaWGNnVUhKdmJXbHpaU2htZFc1amRHbHZiaUFvWVN3Z1lpa2dleUJ4TG5CMWMyZ29XMjRzSUhZc0lHRXNJR0pkS1NBK0lERWdmSHdnY21WemRXMWxLRzRzSUhZcE95QjlLVHNnZlRzZ2ZWeHlYRzRnSUNBZ1puVnVZM1JwYjI0Z2NtVnpkVzFsS0c0c0lIWXBJSHNnZEhKNUlIc2djM1JsY0NoblcyNWRLSFlwS1RzZ2ZTQmpZWFJqYUNBb1pTa2dleUJ6WlhSMGJHVW9jVnN3WFZzelhTd2daU2s3SUgwZ2ZWeHlYRzRnSUNBZ1puVnVZM1JwYjI0Z2MzUmxjQ2h5S1NCN0lISXVkbUZzZFdVZ2FXNXpkR0Z1WTJWdlppQmZYMkYzWVdsMElEOGdVSEp2YldselpTNXlaWE52YkhabEtISXVkbUZzZFdVdWRpa3VkR2hsYmlobWRXeG1hV3hzTENCeVpXcGxZM1FwSURvZ2MyVjBkR3hsS0hGYk1GMWJNbDBzSUhJcE95QjlYSEpjYmlBZ0lDQm1kVzVqZEdsdmJpQm1kV3htYVd4c0tIWmhiSFZsS1NCN0lISmxjM1Z0WlNoY0ltNWxlSFJjSWl3Z2RtRnNkV1VwT3lCOVhISmNiaUFnSUNCbWRXNWpkR2x2YmlCeVpXcGxZM1FvZG1Gc2RXVXBJSHNnY21WemRXMWxLRndpZEdoeWIzZGNJaXdnZG1Gc2RXVXBPeUI5WEhKY2JpQWdJQ0JtZFc1amRHbHZiaUJ6WlhSMGJHVW9aaXdnZGlrZ2V5QnBaaUFvWmloMktTd2djUzV6YUdsbWRDZ3BMQ0J4TG14bGJtZDBhQ2tnY21WemRXMWxLSEZiTUYxYk1GMHNJSEZiTUYxYk1WMHBPeUI5WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgyRnplVzVqUkdWc1pXZGhkRzl5S0c4cElIdGNjbHh1SUNBZ0lIWmhjaUJwTENCd08xeHlYRzRnSUNBZ2NtVjBkWEp1SUdrZ1BTQjdmU3dnZG1WeVlpaGNJbTVsZUhSY0lpa3NJSFpsY21Jb1hDSjBhSEp2ZDF3aUxDQm1kVzVqZEdsdmJpQW9aU2tnZXlCMGFISnZkeUJsT3lCOUtTd2dkbVZ5WWloY0luSmxkSFZ5Ymx3aUtTd2dhVnRUZVcxaWIyd3VhWFJsY21GMGIzSmRJRDBnWm5WdVkzUnBiMjRnS0NrZ2V5QnlaWFIxY200Z2RHaHBjenNnZlN3Z2FUdGNjbHh1SUNBZ0lHWjFibU4wYVc5dUlIWmxjbUlvYml3Z1ppa2dleUJwVzI1ZElEMGdiMXR1WFNBL0lHWjFibU4wYVc5dUlDaDJLU0I3SUhKbGRIVnliaUFvY0NBOUlDRndLU0EvSUhzZ2RtRnNkV1U2SUY5ZllYZGhhWFFvYjF0dVhTaDJLU2tzSUdSdmJtVTZJRzRnUFQwOUlGd2ljbVYwZFhKdVhDSWdmU0E2SUdZZ1B5Qm1LSFlwSURvZ2Rqc2dmU0E2SUdZN0lIMWNjbHh1ZlZ4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmWVhONWJtTldZV3gxWlhNb2J5a2dlMXh5WEc0Z0lDQWdhV1lnS0NGVGVXMWliMnd1WVhONWJtTkpkR1Z5WVhSdmNpa2dkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWhjSWxONWJXSnZiQzVoYzNsdVkwbDBaWEpoZEc5eUlHbHpJRzV2ZENCa1pXWnBibVZrTGx3aUtUdGNjbHh1SUNBZ0lIWmhjaUJ0SUQwZ2IxdFRlVzFpYjJ3dVlYTjVibU5KZEdWeVlYUnZjbDBzSUdrN1hISmNiaUFnSUNCeVpYUjFjbTRnYlNBL0lHMHVZMkZzYkNodktTQTZJQ2h2SUQwZ2RIbHdaVzltSUY5ZmRtRnNkV1Z6SUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lnUHlCZlgzWmhiSFZsY3lodktTQTZJRzliVTNsdFltOXNMbWwwWlhKaGRHOXlYU2dwTENCcElEMGdlMzBzSUhabGNtSW9YQ0p1WlhoMFhDSXBMQ0IyWlhKaUtGd2lkR2h5YjNkY0lpa3NJSFpsY21Jb1hDSnlaWFIxY201Y0lpa3NJR2xiVTNsdFltOXNMbUZ6ZVc1alNYUmxjbUYwYjNKZElEMGdablZ1WTNScGIyNGdLQ2tnZXlCeVpYUjFjbTRnZEdocGN6c2dmU3dnYVNrN1hISmNiaUFnSUNCbWRXNWpkR2x2YmlCMlpYSmlLRzRwSUhzZ2FWdHVYU0E5SUc5YmJsMGdKaVlnWm5WdVkzUnBiMjRnS0hZcElIc2djbVYwZFhKdUlHNWxkeUJRY205dGFYTmxLR1oxYm1OMGFXOXVJQ2h5WlhOdmJIWmxMQ0J5WldwbFkzUXBJSHNnZGlBOUlHOWJibDBvZGlrc0lITmxkSFJzWlNoeVpYTnZiSFpsTENCeVpXcGxZM1FzSUhZdVpHOXVaU3dnZGk1MllXeDFaU2s3SUgwcE95QjlPeUI5WEhKY2JpQWdJQ0JtZFc1amRHbHZiaUJ6WlhSMGJHVW9jbVZ6YjJ4MlpTd2djbVZxWldOMExDQmtMQ0IyS1NCN0lGQnliMjFwYzJVdWNtVnpiMngyWlNoMktTNTBhR1Z1S0daMWJtTjBhVzl1S0hZcElIc2djbVZ6YjJ4MlpTaDdJSFpoYkhWbE9pQjJMQ0JrYjI1bE9pQmtJSDBwT3lCOUxDQnlaV3BsWTNRcE95QjlYSEpjYm4xY2NseHVYSEpjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJmWDIxaGEyVlVaVzF3YkdGMFpVOWlhbVZqZENoamIyOXJaV1FzSUhKaGR5a2dlMXh5WEc0Z0lDQWdhV1lnS0U5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGVTa2dleUJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1kyOXZhMlZrTENCY0luSmhkMXdpTENCN0lIWmhiSFZsT2lCeVlYY2dmU2s3SUgwZ1pXeHpaU0I3SUdOdmIydGxaQzV5WVhjZ1BTQnlZWGM3SUgxY2NseHVJQ0FnSUhKbGRIVnliaUJqYjI5clpXUTdYSEpjYm4wN1hISmNibHh5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWDE5cGJYQnZjblJUZEdGeUtHMXZaQ2tnZTF4eVhHNGdJQ0FnYVdZZ0tHMXZaQ0FtSmlCdGIyUXVYMTlsYzAxdlpIVnNaU2tnY21WMGRYSnVJRzF2WkR0Y2NseHVJQ0FnSUhaaGNpQnlaWE4xYkhRZ1BTQjdmVHRjY2x4dUlDQWdJR2xtSUNodGIyUWdJVDBnYm5Wc2JDa2dabTl5SUNoMllYSWdheUJwYmlCdGIyUXBJR2xtSUNoUFltcGxZM1F1YUdGelQzZHVVSEp2Y0dWeWRIa3VZMkZzYkNodGIyUXNJR3NwS1NCeVpYTjFiSFJiYTEwZ1BTQnRiMlJiYTEwN1hISmNiaUFnSUNCeVpYTjFiSFF1WkdWbVlYVnNkQ0E5SUcxdlpEdGNjbHh1SUNBZ0lISmxkSFZ5YmlCeVpYTjFiSFE3WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgybHRjRzl5ZEVSbFptRjFiSFFvYlc5a0tTQjdYSEpjYmlBZ0lDQnlaWFIxY200Z0tHMXZaQ0FtSmlCdGIyUXVYMTlsYzAxdlpIVnNaU2tnUHlCdGIyUWdPaUI3SUdSbFptRjFiSFE2SUcxdlpDQjlPMXh5WEc1OVhISmNibHh5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWDE5amJHRnpjMUJ5YVhaaGRHVkdhV1ZzWkVkbGRDaHlaV05sYVhabGNpd2djSEpwZG1GMFpVMWhjQ2tnZTF4eVhHNGdJQ0FnYVdZZ0tDRndjbWwyWVhSbFRXRndMbWhoY3loeVpXTmxhWFpsY2lrcElIdGNjbHh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0Z3aVlYUjBaVzF3ZEdWa0lIUnZJR2RsZENCd2NtbDJZWFJsSUdacFpXeGtJRzl1SUc1dmJpMXBibk4wWVc1alpWd2lLVHRjY2x4dUlDQWdJSDFjY2x4dUlDQWdJSEpsZEhWeWJpQndjbWwyWVhSbFRXRndMbWRsZENoeVpXTmxhWFpsY2lrN1hISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmZYMk5zWVhOelVISnBkbUYwWlVacFpXeGtVMlYwS0hKbFkyVnBkbVZ5TENCd2NtbDJZWFJsVFdGd0xDQjJZV3gxWlNrZ2UxeHlYRzRnSUNBZ2FXWWdLQ0Z3Y21sMllYUmxUV0Z3TG1oaGN5aHlaV05sYVhabGNpa3BJSHRjY2x4dUlDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1ZIbHdaVVZ5Y205eUtGd2lZWFIwWlcxd2RHVmtJSFJ2SUhObGRDQndjbWwyWVhSbElHWnBaV3hrSUc5dUlHNXZiaTFwYm5OMFlXNWpaVndpS1R0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhCeWFYWmhkR1ZOWVhBdWMyVjBLSEpsWTJWcGRtVnlMQ0IyWVd4MVpTazdYSEpjYmlBZ0lDQnlaWFIxY200Z2RtRnNkV1U3WEhKY2JuMWNjbHh1SWl3aUx5b2hJR2gwZEhCek9pOHZiWFJvY3k1aVpTOXdkVzU1WTI5a1pTQjJNUzR6TGpJZ1lua2dRRzFoZEdocFlYTWdLaTljYmpzb1puVnVZM1JwYjI0b2NtOXZkQ2tnZTF4dVhHNWNkQzhxS2lCRVpYUmxZM1FnWm5KbFpTQjJZWEpwWVdKc1pYTWdLaTljYmx4MGRtRnlJR1p5WldWRmVIQnZjblJ6SUQwZ2RIbHdaVzltSUdWNGNHOXlkSE1nUFQwZ0oyOWlhbVZqZENjZ0ppWWdaWGh3YjNKMGN5QW1KbHh1WEhSY2RDRmxlSEJ2Y25SekxtNXZaR1ZVZVhCbElDWW1JR1Y0Y0c5eWRITTdYRzVjZEhaaGNpQm1jbVZsVFc5a2RXeGxJRDBnZEhsd1pXOW1JRzF2WkhWc1pTQTlQU0FuYjJKcVpXTjBKeUFtSmlCdGIyUjFiR1VnSmlaY2JseDBYSFFoYlc5a2RXeGxMbTV2WkdWVWVYQmxJQ1ltSUcxdlpIVnNaVHRjYmx4MGRtRnlJR1p5WldWSGJHOWlZV3dnUFNCMGVYQmxiMllnWjJ4dlltRnNJRDA5SUNkdlltcGxZM1FuSUNZbUlHZHNiMkpoYkR0Y2JseDBhV1lnS0Z4dVhIUmNkR1p5WldWSGJHOWlZV3d1WjJ4dlltRnNJRDA5UFNCbWNtVmxSMnh2WW1Gc0lIeDhYRzVjZEZ4MFpuSmxaVWRzYjJKaGJDNTNhVzVrYjNjZ1BUMDlJR1p5WldWSGJHOWlZV3dnZkh4Y2JseDBYSFJtY21WbFIyeHZZbUZzTG5ObGJHWWdQVDA5SUdaeVpXVkhiRzlpWVd4Y2JseDBLU0I3WEc1Y2RGeDBjbTl2ZENBOUlHWnlaV1ZIYkc5aVlXdzdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nVkdobElHQndkVzU1WTI5a1pXQWdiMkpxWldOMExseHVYSFFnS2lCQWJtRnRaU0J3ZFc1NVkyOWtaVnh1WEhRZ0tpQkFkSGx3WlNCUFltcGxZM1JjYmx4MElDb3ZYRzVjZEhaaGNpQndkVzU1WTI5a1pTeGNibHh1WEhRdktpb2dTR2xuYUdWemRDQndiM05wZEdsMlpTQnphV2R1WldRZ016SXRZbWwwSUdac2IyRjBJSFpoYkhWbElDb3ZYRzVjZEcxaGVFbHVkQ0E5SURJeE5EYzBPRE0yTkRjc0lDOHZJR0ZyWVM0Z01IZzNSa1pHUmtaR1JpQnZjaUF5WGpNeExURmNibHh1WEhRdktpb2dRbTl2ZEhOMGNtbHVaeUJ3WVhKaGJXVjBaWEp6SUNvdlhHNWNkR0poYzJVZ1BTQXpOaXhjYmx4MGRFMXBiaUE5SURFc1hHNWNkSFJOWVhnZ1BTQXlOaXhjYmx4MGMydGxkeUE5SURNNExGeHVYSFJrWVcxd0lEMGdOekF3TEZ4dVhIUnBibWwwYVdGc1FtbGhjeUE5SURjeUxGeHVYSFJwYm1sMGFXRnNUaUE5SURFeU9Dd2dMeThnTUhnNE1GeHVYSFJrWld4cGJXbDBaWElnUFNBbkxTY3NJQzh2SUNkY1hIZ3lSQ2RjYmx4dVhIUXZLaW9nVW1WbmRXeGhjaUJsZUhCeVpYTnphVzl1Y3lBcUwxeHVYSFJ5WldkbGVGQjFibmxqYjJSbElEMGdMMTU0YmkwdEx5eGNibHgwY21WblpYaE9iMjVCVTBOSlNTQTlJQzliWGx4Y2VESXdMVnhjZURkRlhTOHNJQzh2SUhWdWNISnBiblJoWW14bElFRlRRMGxKSUdOb1lYSnpJQ3NnYm05dUxVRlRRMGxKSUdOb1lYSnpYRzVjZEhKbFoyVjRVMlZ3WVhKaGRHOXljeUE5SUM5YlhGeDRNa1ZjWEhVek1EQXlYRngxUmtZd1JWeGNkVVpHTmpGZEwyY3NJQzh2SUZKR1F5QXpORGt3SUhObGNHRnlZWFJ2Y25OY2JseHVYSFF2S2lvZ1JYSnliM0lnYldWemMyRm5aWE1nS2k5Y2JseDBaWEp5YjNKeklEMGdlMXh1WEhSY2RDZHZkbVZ5Wm14dmR5YzZJQ2RQZG1WeVpteHZkem9nYVc1d2RYUWdibVZsWkhNZ2QybGtaWElnYVc1MFpXZGxjbk1nZEc4Z2NISnZZMlZ6Y3ljc1hHNWNkRngwSjI1dmRDMWlZWE5wWXljNklDZEpiR3hsWjJGc0lHbHVjSFYwSUQ0OUlEQjRPREFnS0c1dmRDQmhJR0poYzJsaklHTnZaR1VnY0c5cGJuUXBKeXhjYmx4MFhIUW5hVzUyWVd4cFpDMXBibkIxZENjNklDZEpiblpoYkdsa0lHbHVjSFYwSjF4dVhIUjlMRnh1WEc1Y2RDOHFLaUJEYjI1MlpXNXBaVzVqWlNCemFHOXlkR04xZEhNZ0tpOWNibHgwWW1GelpVMXBiblZ6VkUxcGJpQTlJR0poYzJVZ0xTQjBUV2x1TEZ4dVhIUm1iRzl2Y2lBOUlFMWhkR2d1Wm14dmIzSXNYRzVjZEhOMGNtbHVaMFp5YjIxRGFHRnlRMjlrWlNBOUlGTjBjbWx1Wnk1bWNtOXRRMmhoY2tOdlpHVXNYRzVjYmx4MEx5b3FJRlJsYlhCdmNtRnllU0IyWVhKcFlXSnNaU0FxTDF4dVhIUnJaWGs3WEc1Y2JseDBMeW90TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFNvdlhHNWNibHgwTHlvcVhHNWNkQ0FxSUVFZ1oyVnVaWEpwWXlCbGNuSnZjaUIxZEdsc2FYUjVJR1oxYm1OMGFXOXVMbHh1WEhRZ0tpQkFjSEpwZG1GMFpWeHVYSFFnS2lCQWNHRnlZVzBnZTFOMGNtbHVaMzBnZEhsd1pTQlVhR1VnWlhKeWIzSWdkSGx3WlM1Y2JseDBJQ29nUUhKbGRIVnlibk1nZTBWeWNtOXlmU0JVYUhKdmQzTWdZU0JnVW1GdVoyVkZjbkp2Y21BZ2QybDBhQ0IwYUdVZ1lYQndiR2xqWVdKc1pTQmxjbkp2Y2lCdFpYTnpZV2RsTGx4dVhIUWdLaTljYmx4MFpuVnVZM1JwYjI0Z1pYSnliM0lvZEhsd1pTa2dlMXh1WEhSY2RIUm9jbTkzSUZKaGJtZGxSWEp5YjNJb1pYSnliM0p6VzNSNWNHVmRLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCQklHZGxibVZ5YVdNZ1lFRnljbUY1STIxaGNHQWdkWFJwYkdsMGVTQm1kVzVqZEdsdmJpNWNibHgwSUNvZ1FIQnlhWFpoZEdWY2JseDBJQ29nUUhCaGNtRnRJSHRCY25KaGVYMGdZWEp5WVhrZ1ZHaGxJR0Z5Y21GNUlIUnZJR2wwWlhKaGRHVWdiM1psY2k1Y2JseDBJQ29nUUhCaGNtRnRJSHRHZFc1amRHbHZibjBnWTJGc2JHSmhZMnNnVkdobElHWjFibU4wYVc5dUlIUm9ZWFFnWjJWMGN5QmpZV3hzWldRZ1ptOXlJR1YyWlhKNUlHRnljbUY1WEc1Y2RDQXFJR2wwWlcwdVhHNWNkQ0FxSUVCeVpYUjFjbTV6SUh0QmNuSmhlWDBnUVNCdVpYY2dZWEp5WVhrZ2IyWWdkbUZzZFdWeklISmxkSFZ5Ym1Wa0lHSjVJSFJvWlNCallXeHNZbUZqYXlCbWRXNWpkR2x2Ymk1Y2JseDBJQ292WEc1Y2RHWjFibU4wYVc5dUlHMWhjQ2hoY25KaGVTd2dabTRwSUh0Y2JseDBYSFIyWVhJZ2JHVnVaM1JvSUQwZ1lYSnlZWGt1YkdWdVozUm9PMXh1WEhSY2RIWmhjaUJ5WlhOMWJIUWdQU0JiWFR0Y2JseDBYSFIzYUdsc1pTQW9iR1Z1WjNSb0xTMHBJSHRjYmx4MFhIUmNkSEpsYzNWc2RGdHNaVzVuZEdoZElEMGdabTRvWVhKeVlYbGJiR1Z1WjNSb1hTazdYRzVjZEZ4MGZWeHVYSFJjZEhKbGRIVnliaUJ5WlhOMWJIUTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nUVNCemFXMXdiR1VnWUVGeWNtRjVJMjFoY0dBdGJHbHJaU0IzY21Gd2NHVnlJSFJ2SUhkdmNtc2dkMmwwYUNCa2IyMWhhVzRnYm1GdFpTQnpkSEpwYm1keklHOXlJR1Z0WVdsc1hHNWNkQ0FxSUdGa1pISmxjM05sY3k1Y2JseDBJQ29nUUhCeWFYWmhkR1ZjYmx4MElDb2dRSEJoY21GdElIdFRkSEpwYm1kOUlHUnZiV0ZwYmlCVWFHVWdaRzl0WVdsdUlHNWhiV1VnYjNJZ1pXMWhhV3dnWVdSa2NtVnpjeTVjYmx4MElDb2dRSEJoY21GdElIdEdkVzVqZEdsdmJuMGdZMkZzYkdKaFkyc2dWR2hsSUdaMWJtTjBhVzl1SUhSb1lYUWdaMlYwY3lCallXeHNaV1FnWm05eUlHVjJaWEo1WEc1Y2RDQXFJR05vWVhKaFkzUmxjaTVjYmx4MElDb2dRSEpsZEhWeWJuTWdlMEZ5Y21GNWZTQkJJRzVsZHlCemRISnBibWNnYjJZZ1kyaGhjbUZqZEdWeWN5QnlaWFIxY201bFpDQmllU0IwYUdVZ1kyRnNiR0poWTJ0Y2JseDBJQ29nWm5WdVkzUnBiMjR1WEc1Y2RDQXFMMXh1WEhSbWRXNWpkR2x2YmlCdFlYQkViMjFoYVc0b2MzUnlhVzVuTENCbWJpa2dlMXh1WEhSY2RIWmhjaUJ3WVhKMGN5QTlJSE4wY21sdVp5NXpjR3hwZENnblFDY3BPMXh1WEhSY2RIWmhjaUJ5WlhOMWJIUWdQU0FuSnp0Y2JseDBYSFJwWmlBb2NHRnlkSE11YkdWdVozUm9JRDRnTVNrZ2UxeHVYSFJjZEZ4MEx5OGdTVzRnWlcxaGFXd2dZV1JrY21WemMyVnpMQ0J2Ym14NUlIUm9aU0JrYjIxaGFXNGdibUZ0WlNCemFHOTFiR1FnWW1VZ2NIVnVlV052WkdWa0xpQk1aV0YyWlZ4dVhIUmNkRngwTHk4Z2RHaGxJR3h2WTJGc0lIQmhjblFnS0drdVpTNGdaWFpsY25sMGFHbHVaeUIxY0NCMGJ5QmdRR0FwSUdsdWRHRmpkQzVjYmx4MFhIUmNkSEpsYzNWc2RDQTlJSEJoY25Seld6QmRJQ3NnSjBBbk8xeHVYSFJjZEZ4MGMzUnlhVzVuSUQwZ2NHRnlkSE5iTVYwN1hHNWNkRngwZlZ4dVhIUmNkQzh2SUVGMmIybGtJR0J6Y0d4cGRDaHlaV2RsZUNsZ0lHWnZjaUJKUlRnZ1kyOXRjR0YwYVdKcGJHbDBlUzRnVTJWbElDTXhOeTVjYmx4MFhIUnpkSEpwYm1jZ1BTQnpkSEpwYm1jdWNtVndiR0ZqWlNoeVpXZGxlRk5sY0dGeVlYUnZjbk1zSUNkY1hIZ3lSU2NwTzF4dVhIUmNkSFpoY2lCc1lXSmxiSE1nUFNCemRISnBibWN1YzNCc2FYUW9KeTRuS1R0Y2JseDBYSFIyWVhJZ1pXNWpiMlJsWkNBOUlHMWhjQ2hzWVdKbGJITXNJR1p1S1M1cWIybHVLQ2N1SnlrN1hHNWNkRngwY21WMGRYSnVJSEpsYzNWc2RDQXJJR1Z1WTI5a1pXUTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nUTNKbFlYUmxjeUJoYmlCaGNuSmhlU0JqYjI1MFlXbHVhVzVuSUhSb1pTQnVkVzFsY21saklHTnZaR1VnY0c5cGJuUnpJRzltSUdWaFkyZ2dWVzVwWTI5a1pWeHVYSFFnS2lCamFHRnlZV04wWlhJZ2FXNGdkR2hsSUhOMGNtbHVaeTRnVjJocGJHVWdTbUYyWVZOamNtbHdkQ0IxYzJWeklGVkRVeTB5SUdsdWRHVnlibUZzYkhrc1hHNWNkQ0FxSUhSb2FYTWdablZ1WTNScGIyNGdkMmxzYkNCamIyNTJaWEowSUdFZ2NHRnBjaUJ2WmlCemRYSnliMmRoZEdVZ2FHRnNkbVZ6SUNobFlXTm9JRzltSUhkb2FXTm9YRzVjZENBcUlGVkRVeTB5SUdWNGNHOXpaWE1nWVhNZ2MyVndZWEpoZEdVZ1kyaGhjbUZqZEdWeWN5a2dhVzUwYnlCaElITnBibWRzWlNCamIyUmxJSEJ2YVc1MExGeHVYSFFnS2lCdFlYUmphR2x1WnlCVlZFWXRNVFl1WEc1Y2RDQXFJRUJ6WldVZ1lIQjFibmxqYjJSbExuVmpjekl1Wlc1amIyUmxZRnh1WEhRZ0tpQkFjMlZsSUR4b2RIUndjem92TDIxaGRHaHBZWE5pZVc1bGJuTXVZbVV2Ym05MFpYTXZhbUYyWVhOamNtbHdkQzFsYm1OdlpHbHVaejVjYmx4MElDb2dRRzFsYldKbGNrOW1JSEIxYm5samIyUmxMblZqY3pKY2JseDBJQ29nUUc1aGJXVWdaR1ZqYjJSbFhHNWNkQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0J6ZEhKcGJtY2dWR2hsSUZWdWFXTnZaR1VnYVc1d2RYUWdjM1J5YVc1bklDaFZRMU10TWlrdVhHNWNkQ0FxSUVCeVpYUjFjbTV6SUh0QmNuSmhlWDBnVkdobElHNWxkeUJoY25KaGVTQnZaaUJqYjJSbElIQnZhVzUwY3k1Y2JseDBJQ292WEc1Y2RHWjFibU4wYVc5dUlIVmpjekprWldOdlpHVW9jM1J5YVc1bktTQjdYRzVjZEZ4MGRtRnlJRzkxZEhCMWRDQTlJRnRkTEZ4dVhIUmNkQ0FnSUNCamIzVnVkR1Z5SUQwZ01DeGNibHgwWEhRZ0lDQWdiR1Z1WjNSb0lEMGdjM1J5YVc1bkxteGxibWQwYUN4Y2JseDBYSFFnSUNBZ2RtRnNkV1VzWEc1Y2RGeDBJQ0FnSUdWNGRISmhPMXh1WEhSY2RIZG9hV3hsSUNoamIzVnVkR1Z5SUR3Z2JHVnVaM1JvS1NCN1hHNWNkRngwWEhSMllXeDFaU0E5SUhOMGNtbHVaeTVqYUdGeVEyOWtaVUYwS0dOdmRXNTBaWElyS3lrN1hHNWNkRngwWEhScFppQW9kbUZzZFdVZ1BqMGdNSGhFT0RBd0lDWW1JSFpoYkhWbElEdzlJREI0UkVKR1JpQW1KaUJqYjNWdWRHVnlJRHdnYkdWdVozUm9LU0I3WEc1Y2RGeDBYSFJjZEM4dklHaHBaMmdnYzNWeWNtOW5ZWFJsTENCaGJtUWdkR2hsY21VZ2FYTWdZU0J1WlhoMElHTm9ZWEpoWTNSbGNseHVYSFJjZEZ4MFhIUmxlSFJ5WVNBOUlITjBjbWx1Wnk1amFHRnlRMjlrWlVGMEtHTnZkVzUwWlhJckt5azdYRzVjZEZ4MFhIUmNkR2xtSUNnb1pYaDBjbUVnSmlBd2VFWkRNREFwSUQwOUlEQjRSRU13TUNrZ2V5QXZMeUJzYjNjZ2MzVnljbTluWVhSbFhHNWNkRngwWEhSY2RGeDBiM1YwY0hWMExuQjFjMmdvS0NoMllXeDFaU0FtSURCNE0wWkdLU0E4UENBeE1Da2dLeUFvWlhoMGNtRWdKaUF3ZUROR1Jpa2dLeUF3ZURFd01EQXdLVHRjYmx4MFhIUmNkRngwZlNCbGJITmxJSHRjYmx4MFhIUmNkRngwWEhRdkx5QjFibTFoZEdOb1pXUWdjM1Z5Y205bllYUmxPeUJ2Ym14NUlHRndjR1Z1WkNCMGFHbHpJR052WkdVZ2RXNXBkQ3dnYVc0Z1kyRnpaU0IwYUdVZ2JtVjRkRnh1WEhSY2RGeDBYSFJjZEM4dklHTnZaR1VnZFc1cGRDQnBjeUIwYUdVZ2FHbG5hQ0J6ZFhKeWIyZGhkR1VnYjJZZ1lTQnpkWEp5YjJkaGRHVWdjR0ZwY2x4dVhIUmNkRngwWEhSY2RHOTFkSEIxZEM1d2RYTm9LSFpoYkhWbEtUdGNibHgwWEhSY2RGeDBYSFJqYjNWdWRHVnlMUzA3WEc1Y2RGeDBYSFJjZEgxY2JseDBYSFJjZEgwZ1pXeHpaU0I3WEc1Y2RGeDBYSFJjZEc5MWRIQjFkQzV3ZFhOb0tIWmhiSFZsS1R0Y2JseDBYSFJjZEgxY2JseDBYSFI5WEc1Y2RGeDBjbVYwZFhKdUlHOTFkSEIxZER0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkRjbVZoZEdWeklHRWdjM1J5YVc1bklHSmhjMlZrSUc5dUlHRnVJR0Z5Y21GNUlHOW1JRzUxYldWeWFXTWdZMjlrWlNCd2IybHVkSE11WEc1Y2RDQXFJRUJ6WldVZ1lIQjFibmxqYjJSbExuVmpjekl1WkdWamIyUmxZRnh1WEhRZ0tpQkFiV1Z0WW1WeVQyWWdjSFZ1ZVdOdlpHVXVkV056TWx4dVhIUWdLaUJBYm1GdFpTQmxibU52WkdWY2JseDBJQ29nUUhCaGNtRnRJSHRCY25KaGVYMGdZMjlrWlZCdmFXNTBjeUJVYUdVZ1lYSnlZWGtnYjJZZ2JuVnRaWEpwWXlCamIyUmxJSEJ2YVc1MGN5NWNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UxTjBjbWx1WjMwZ1ZHaGxJRzVsZHlCVmJtbGpiMlJsSUhOMGNtbHVaeUFvVlVOVExUSXBMbHh1WEhRZ0tpOWNibHgwWm5WdVkzUnBiMjRnZFdOek1tVnVZMjlrWlNoaGNuSmhlU2tnZTF4dVhIUmNkSEpsZEhWeWJpQnRZWEFvWVhKeVlYa3NJR1oxYm1OMGFXOXVLSFpoYkhWbEtTQjdYRzVjZEZ4MFhIUjJZWElnYjNWMGNIVjBJRDBnSnljN1hHNWNkRngwWEhScFppQW9kbUZzZFdVZ1BpQXdlRVpHUmtZcElIdGNibHgwWEhSY2RGeDBkbUZzZFdVZ0xUMGdNSGd4TURBd01EdGNibHgwWEhSY2RGeDBiM1YwY0hWMElDczlJSE4wY21sdVowWnliMjFEYUdGeVEyOWtaU2gyWVd4MVpTQStQajRnTVRBZ0ppQXdlRE5HUmlCOElEQjRSRGd3TUNrN1hHNWNkRngwWEhSY2RIWmhiSFZsSUQwZ01IaEVRekF3SUh3Z2RtRnNkV1VnSmlBd2VETkdSanRjYmx4MFhIUmNkSDFjYmx4MFhIUmNkRzkxZEhCMWRDQXJQU0J6ZEhKcGJtZEdjbTl0UTJoaGNrTnZaR1VvZG1Gc2RXVXBPMXh1WEhSY2RGeDBjbVYwZFhKdUlHOTFkSEIxZER0Y2JseDBYSFI5S1M1cWIybHVLQ2NuS1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkRiMjUyWlhKMGN5QmhJR0poYzJsaklHTnZaR1VnY0c5cGJuUWdhVzUwYnlCaElHUnBaMmwwTDJsdWRHVm5aWEl1WEc1Y2RDQXFJRUJ6WldVZ1lHUnBaMmwwVkc5Q1lYTnBZeWdwWUZ4dVhIUWdLaUJBY0hKcGRtRjBaVnh1WEhRZ0tpQkFjR0Z5WVcwZ2UwNTFiV0psY24wZ1kyOWtaVkJ2YVc1MElGUm9aU0JpWVhOcFl5QnVkVzFsY21saklHTnZaR1VnY0c5cGJuUWdkbUZzZFdVdVhHNWNkQ0FxSUVCeVpYUjFjbTV6SUh0T2RXMWlaWEo5SUZSb1pTQnVkVzFsY21saklIWmhiSFZsSUc5bUlHRWdZbUZ6YVdNZ1kyOWtaU0J3YjJsdWRDQW9abTl5SUhWelpTQnBibHh1WEhRZ0tpQnlaWEJ5WlhObGJuUnBibWNnYVc1MFpXZGxjbk1wSUdsdUlIUm9aU0J5WVc1blpTQmdNR0FnZEc4Z1lHSmhjMlVnTFNBeFlDd2diM0lnWUdKaGMyVmdJR2xtWEc1Y2RDQXFJSFJvWlNCamIyUmxJSEJ2YVc1MElHUnZaWE1nYm05MElISmxjSEpsYzJWdWRDQmhJSFpoYkhWbExseHVYSFFnS2k5Y2JseDBablZ1WTNScGIyNGdZbUZ6YVdOVWIwUnBaMmwwS0dOdlpHVlFiMmx1ZENrZ2UxeHVYSFJjZEdsbUlDaGpiMlJsVUc5cGJuUWdMU0EwT0NBOElERXdLU0I3WEc1Y2RGeDBYSFJ5WlhSMWNtNGdZMjlrWlZCdmFXNTBJQzBnTWpJN1hHNWNkRngwZlZ4dVhIUmNkR2xtSUNoamIyUmxVRzlwYm5RZ0xTQTJOU0E4SURJMktTQjdYRzVjZEZ4MFhIUnlaWFIxY200Z1kyOWtaVkJ2YVc1MElDMGdOalU3WEc1Y2RGeDBmVnh1WEhSY2RHbG1JQ2hqYjJSbFVHOXBiblFnTFNBNU55QThJREkyS1NCN1hHNWNkRngwWEhSeVpYUjFjbTRnWTI5a1pWQnZhVzUwSUMwZ09UYzdYRzVjZEZ4MGZWeHVYSFJjZEhKbGRIVnliaUJpWVhObE8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRU52Ym5abGNuUnpJR0VnWkdsbmFYUXZhVzUwWldkbGNpQnBiblJ2SUdFZ1ltRnphV01nWTI5a1pTQndiMmx1ZEM1Y2JseDBJQ29nUUhObFpTQmdZbUZ6YVdOVWIwUnBaMmwwS0NsZ1hHNWNkQ0FxSUVCd2NtbDJZWFJsWEc1Y2RDQXFJRUJ3WVhKaGJTQjdUblZ0WW1WeWZTQmthV2RwZENCVWFHVWdiblZ0WlhKcFl5QjJZV3gxWlNCdlppQmhJR0poYzJsaklHTnZaR1VnY0c5cGJuUXVYRzVjZENBcUlFQnlaWFIxY201eklIdE9kVzFpWlhKOUlGUm9aU0JpWVhOcFl5QmpiMlJsSUhCdmFXNTBJSGRvYjNObElIWmhiSFZsSUNoM2FHVnVJSFZ6WldRZ1ptOXlYRzVjZENBcUlISmxjSEpsYzJWdWRHbHVaeUJwYm5SbFoyVnljeWtnYVhNZ1lHUnBaMmwwWUN3Z2QyaHBZMmdnYm1WbFpITWdkRzhnWW1VZ2FXNGdkR2hsSUhKaGJtZGxYRzVjZENBcUlHQXdZQ0IwYnlCZ1ltRnpaU0F0SURGZ0xpQkpaaUJnWm14aFoyQWdhWE1nYm05dUxYcGxjbThzSUhSb1pTQjFjSEJsY21OaGMyVWdabTl5YlNCcGMxeHVYSFFnS2lCMWMyVmtPeUJsYkhObExDQjBhR1VnYkc5M1pYSmpZWE5sSUdadmNtMGdhWE1nZFhObFpDNGdWR2hsSUdKbGFHRjJhVzl5SUdseklIVnVaR1ZtYVc1bFpGeHVYSFFnS2lCcFppQmdabXhoWjJBZ2FYTWdibTl1TFhwbGNtOGdZVzVrSUdCa2FXZHBkR0FnYUdGeklHNXZJSFZ3Y0dWeVkyRnpaU0JtYjNKdExseHVYSFFnS2k5Y2JseDBablZ1WTNScGIyNGdaR2xuYVhSVWIwSmhjMmxqS0dScFoybDBMQ0JtYkdGbktTQjdYRzVjZEZ4MEx5OGdJREF1TGpJMUlHMWhjQ0IwYnlCQlUwTkpTU0JoTGk1NklHOXlJRUV1TGxwY2JseDBYSFF2THlBeU5pNHVNelVnYldGd0lIUnZJRUZUUTBsSklEQXVMamxjYmx4MFhIUnlaWFIxY200Z1pHbG5hWFFnS3lBeU1pQXJJRGMxSUNvZ0tHUnBaMmwwSUR3Z01qWXBJQzBnS0NobWJHRm5JQ0U5SURBcElEdzhJRFVwTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFSnBZWE1nWVdSaGNIUmhkR2x2YmlCbWRXNWpkR2x2YmlCaGN5QndaWElnYzJWamRHbHZiaUF6TGpRZ2IyWWdVa1pESURNME9USXVYRzVjZENBcUlHaDBkSEE2THk5MGIyOXNjeTVwWlhSbUxtOXlaeTlvZEcxc0wzSm1Zek0wT1RJamMyVmpkR2x2YmkwekxqUmNibHgwSUNvZ1FIQnlhWFpoZEdWY2JseDBJQ292WEc1Y2RHWjFibU4wYVc5dUlHRmtZWEIwS0dSbGJIUmhMQ0J1ZFcxUWIybHVkSE1zSUdacGNuTjBWR2x0WlNrZ2UxeHVYSFJjZEhaaGNpQnJJRDBnTUR0Y2JseDBYSFJrWld4MFlTQTlJR1pwY25OMFZHbHRaU0EvSUdac2IyOXlLR1JsYkhSaElDOGdaR0Z0Y0NrZ09pQmtaV3gwWVNBK1BpQXhPMXh1WEhSY2RHUmxiSFJoSUNzOUlHWnNiMjl5S0dSbGJIUmhJQzhnYm5WdFVHOXBiblJ6S1R0Y2JseDBYSFJtYjNJZ0tDOHFJRzV2SUdsdWFYUnBZV3hwZW1GMGFXOXVJQ292T3lCa1pXeDBZU0ErSUdKaGMyVk5hVzUxYzFSTmFXNGdLaUIwVFdGNElENCtJREU3SUdzZ0t6MGdZbUZ6WlNrZ2UxeHVYSFJjZEZ4MFpHVnNkR0VnUFNCbWJHOXZjaWhrWld4MFlTQXZJR0poYzJWTmFXNTFjMVJOYVc0cE8xeHVYSFJjZEgxY2JseDBYSFJ5WlhSMWNtNGdabXh2YjNJb2F5QXJJQ2hpWVhObFRXbHVkWE5VVFdsdUlDc2dNU2tnS2lCa1pXeDBZU0F2SUNoa1pXeDBZU0FySUhOclpYY3BLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCRGIyNTJaWEowY3lCaElGQjFibmxqYjJSbElITjBjbWx1WnlCdlppQkJVME5KU1MxdmJteDVJSE41YldKdmJITWdkRzhnWVNCemRISnBibWNnYjJZZ1ZXNXBZMjlrWlZ4dVhIUWdLaUJ6ZVcxaWIyeHpMbHh1WEhRZ0tpQkFiV1Z0WW1WeVQyWWdjSFZ1ZVdOdlpHVmNibHgwSUNvZ1FIQmhjbUZ0SUh0VGRISnBibWQ5SUdsdWNIVjBJRlJvWlNCUWRXNTVZMjlrWlNCemRISnBibWNnYjJZZ1FWTkRTVWt0YjI1c2VTQnplVzFpYjJ4ekxseHVYSFFnS2lCQWNtVjBkWEp1Y3lCN1UzUnlhVzVuZlNCVWFHVWdjbVZ6ZFd4MGFXNW5JSE4wY21sdVp5QnZaaUJWYm1samIyUmxJSE41YldKdmJITXVYRzVjZENBcUwxeHVYSFJtZFc1amRHbHZiaUJrWldOdlpHVW9hVzV3ZFhRcElIdGNibHgwWEhRdkx5QkViMjRuZENCMWMyVWdWVU5UTFRKY2JseDBYSFIyWVhJZ2IzVjBjSFYwSUQwZ1cxMHNYRzVjZEZ4MElDQWdJR2x1Y0hWMFRHVnVaM1JvSUQwZ2FXNXdkWFF1YkdWdVozUm9MRnh1WEhSY2RDQWdJQ0J2ZFhRc1hHNWNkRngwSUNBZ0lHa2dQU0F3TEZ4dVhIUmNkQ0FnSUNCdUlEMGdhVzVwZEdsaGJFNHNYRzVjZEZ4MElDQWdJR0pwWVhNZ1BTQnBibWwwYVdGc1FtbGhjeXhjYmx4MFhIUWdJQ0FnWW1GemFXTXNYRzVjZEZ4MElDQWdJR29zWEc1Y2RGeDBJQ0FnSUdsdVpHVjRMRnh1WEhSY2RDQWdJQ0J2YkdScExGeHVYSFJjZENBZ0lDQjNMRnh1WEhSY2RDQWdJQ0JyTEZ4dVhIUmNkQ0FnSUNCa2FXZHBkQ3hjYmx4MFhIUWdJQ0FnZEN4Y2JseDBYSFFnSUNBZ0x5b3FJRU5oWTJobFpDQmpZV3hqZFd4aGRHbHZiaUJ5WlhOMWJIUnpJQ292WEc1Y2RGeDBJQ0FnSUdKaGMyVk5hVzUxYzFRN1hHNWNibHgwWEhRdkx5QklZVzVrYkdVZ2RHaGxJR0poYzJsaklHTnZaR1VnY0c5cGJuUnpPaUJzWlhRZ1lHSmhjMmxqWUNCaVpTQjBhR1VnYm5WdFltVnlJRzltSUdsdWNIVjBJR052WkdWY2JseDBYSFF2THlCd2IybHVkSE1nWW1WbWIzSmxJSFJvWlNCc1lYTjBJR1JsYkdsdGFYUmxjaXdnYjNJZ1lEQmdJR2xtSUhSb1pYSmxJR2x6SUc1dmJtVXNJSFJvWlc0Z1kyOXdlVnh1WEhSY2RDOHZJSFJvWlNCbWFYSnpkQ0JpWVhOcFl5QmpiMlJsSUhCdmFXNTBjeUIwYnlCMGFHVWdiM1YwY0hWMExseHVYRzVjZEZ4MFltRnphV01nUFNCcGJuQjFkQzVzWVhOMFNXNWtaWGhQWmloa1pXeHBiV2wwWlhJcE8xeHVYSFJjZEdsbUlDaGlZWE5wWXlBOElEQXBJSHRjYmx4MFhIUmNkR0poYzJsaklEMGdNRHRjYmx4MFhIUjlYRzVjYmx4MFhIUm1iM0lnS0dvZ1BTQXdPeUJxSUR3Z1ltRnphV003SUNzcmFpa2dlMXh1WEhSY2RGeDBMeThnYVdZZ2FYUW5jeUJ1YjNRZ1lTQmlZWE5wWXlCamIyUmxJSEJ2YVc1MFhHNWNkRngwWEhScFppQW9hVzV3ZFhRdVkyaGhja052WkdWQmRDaHFLU0ErUFNBd2VEZ3dLU0I3WEc1Y2RGeDBYSFJjZEdWeWNtOXlLQ2R1YjNRdFltRnphV01uS1R0Y2JseDBYSFJjZEgxY2JseDBYSFJjZEc5MWRIQjFkQzV3ZFhOb0tHbHVjSFYwTG1Ob1lYSkRiMlJsUVhRb2Fpa3BPMXh1WEhSY2RIMWNibHh1WEhSY2RDOHZJRTFoYVc0Z1pHVmpiMlJwYm1jZ2JHOXZjRG9nYzNSaGNuUWdhblZ6ZENCaFpuUmxjaUIwYUdVZ2JHRnpkQ0JrWld4cGJXbDBaWElnYVdZZ1lXNTVJR0poYzJsaklHTnZaR1ZjYmx4MFhIUXZMeUJ3YjJsdWRITWdkMlZ5WlNCamIzQnBaV1E3SUhOMFlYSjBJR0YwSUhSb1pTQmlaV2RwYm01cGJtY2diM1JvWlhKM2FYTmxMbHh1WEc1Y2RGeDBabTl5SUNocGJtUmxlQ0E5SUdKaGMybGpJRDRnTUNBL0lHSmhjMmxqSUNzZ01TQTZJREE3SUdsdVpHVjRJRHdnYVc1d2RYUk1aVzVuZEdnN0lDOHFJRzV2SUdacGJtRnNJR1Y0Y0hKbGMzTnBiMjRnS2k4cElIdGNibHh1WEhSY2RGeDBMeThnWUdsdVpHVjRZQ0JwY3lCMGFHVWdhVzVrWlhnZ2IyWWdkR2hsSUc1bGVIUWdZMmhoY21GamRHVnlJSFJ2SUdKbElHTnZibk4xYldWa0xseHVYSFJjZEZ4MEx5OGdSR1ZqYjJSbElHRWdaMlZ1WlhKaGJHbDZaV1FnZG1GeWFXRmliR1V0YkdWdVozUm9JR2x1ZEdWblpYSWdhVzUwYnlCZ1pHVnNkR0ZnTEZ4dVhIUmNkRngwTHk4Z2QyaHBZMmdnWjJWMGN5QmhaR1JsWkNCMGJ5QmdhV0F1SUZSb1pTQnZkbVZ5Wm14dmR5QmphR1ZqYTJsdVp5QnBjeUJsWVhOcFpYSmNibHgwWEhSY2RDOHZJR2xtSUhkbElHbHVZM0psWVhObElHQnBZQ0JoY3lCM1pTQm5ieXdnZEdobGJpQnpkV0owY21GamRDQnZabVlnYVhSeklITjBZWEowYVc1blhHNWNkRngwWEhRdkx5QjJZV3gxWlNCaGRDQjBhR1VnWlc1a0lIUnZJRzlpZEdGcGJpQmdaR1ZzZEdGZ0xseHVYSFJjZEZ4MFptOXlJQ2h2YkdScElEMGdhU3dnZHlBOUlERXNJR3NnUFNCaVlYTmxPeUF2S2lCdWJ5QmpiMjVrYVhScGIyNGdLaTg3SUdzZ0t6MGdZbUZ6WlNrZ2UxeHVYRzVjZEZ4MFhIUmNkR2xtSUNocGJtUmxlQ0ErUFNCcGJuQjFkRXhsYm1kMGFDa2dlMXh1WEhSY2RGeDBYSFJjZEdWeWNtOXlLQ2RwYm5aaGJHbGtMV2x1Y0hWMEp5azdYRzVjZEZ4MFhIUmNkSDFjYmx4dVhIUmNkRngwWEhSa2FXZHBkQ0E5SUdKaGMybGpWRzlFYVdkcGRDaHBibkIxZEM1amFHRnlRMjlrWlVGMEtHbHVaR1Y0S3lzcEtUdGNibHh1WEhSY2RGeDBYSFJwWmlBb1pHbG5hWFFnUGowZ1ltRnpaU0I4ZkNCa2FXZHBkQ0ErSUdac2IyOXlLQ2h0WVhoSmJuUWdMU0JwS1NBdklIY3BLU0I3WEc1Y2RGeDBYSFJjZEZ4MFpYSnliM0lvSjI5MlpYSm1iRzkzSnlrN1hHNWNkRngwWEhSY2RIMWNibHh1WEhSY2RGeDBYSFJwSUNzOUlHUnBaMmwwSUNvZ2R6dGNibHgwWEhSY2RGeDBkQ0E5SUdzZ1BEMGdZbWxoY3lBL0lIUk5hVzRnT2lBb2F5QStQU0JpYVdGeklDc2dkRTFoZUNBL0lIUk5ZWGdnT2lCcklDMGdZbWxoY3lrN1hHNWNibHgwWEhSY2RGeDBhV1lnS0dScFoybDBJRHdnZENrZ2UxeHVYSFJjZEZ4MFhIUmNkR0p5WldGck8xeHVYSFJjZEZ4MFhIUjlYRzVjYmx4MFhIUmNkRngwWW1GelpVMXBiblZ6VkNBOUlHSmhjMlVnTFNCME8xeHVYSFJjZEZ4MFhIUnBaaUFvZHlBK0lHWnNiMjl5S0cxaGVFbHVkQ0F2SUdKaGMyVk5hVzUxYzFRcEtTQjdYRzVjZEZ4MFhIUmNkRngwWlhKeWIzSW9KMjkyWlhKbWJHOTNKeWs3WEc1Y2RGeDBYSFJjZEgxY2JseHVYSFJjZEZ4MFhIUjNJQ285SUdKaGMyVk5hVzUxYzFRN1hHNWNibHgwWEhSY2RIMWNibHh1WEhSY2RGeDBiM1YwSUQwZ2IzVjBjSFYwTG14bGJtZDBhQ0FySURFN1hHNWNkRngwWEhSaWFXRnpJRDBnWVdSaGNIUW9hU0F0SUc5c1pHa3NJRzkxZEN3Z2IyeGthU0E5UFNBd0tUdGNibHh1WEhSY2RGeDBMeThnWUdsZ0lIZGhjeUJ6ZFhCd2IzTmxaQ0IwYnlCM2NtRndJR0Z5YjNWdVpDQm1jbTl0SUdCdmRYUmdJSFJ2SUdBd1lDeGNibHgwWEhSY2RDOHZJR2x1WTNKbGJXVnVkR2x1WnlCZ2JtQWdaV0ZqYUNCMGFXMWxMQ0J6YnlCM1pTZHNiQ0JtYVhnZ2RHaGhkQ0J1YjNjNlhHNWNkRngwWEhScFppQW9abXh2YjNJb2FTQXZJRzkxZENrZ1BpQnRZWGhKYm5RZ0xTQnVLU0I3WEc1Y2RGeDBYSFJjZEdWeWNtOXlLQ2R2ZG1WeVpteHZkeWNwTzF4dVhIUmNkRngwZlZ4dVhHNWNkRngwWEhSdUlDczlJR1pzYjI5eUtHa2dMeUJ2ZFhRcE8xeHVYSFJjZEZ4MGFTQWxQU0J2ZFhRN1hHNWNibHgwWEhSY2RDOHZJRWx1YzJWeWRDQmdibUFnWVhRZ2NHOXphWFJwYjI0Z1lHbGdJRzltSUhSb1pTQnZkWFJ3ZFhSY2JseDBYSFJjZEc5MWRIQjFkQzV6Y0d4cFkyVW9hU3NyTENBd0xDQnVLVHRjYmx4dVhIUmNkSDFjYmx4dVhIUmNkSEpsZEhWeWJpQjFZM015Wlc1amIyUmxLRzkxZEhCMWRDazdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nUTI5dWRtVnlkSE1nWVNCemRISnBibWNnYjJZZ1ZXNXBZMjlrWlNCemVXMWliMnh6SUNobExtY3VJR0VnWkc5dFlXbHVJRzVoYldVZ2JHRmlaV3dwSUhSdklHRmNibHgwSUNvZ1VIVnVlV052WkdVZ2MzUnlhVzVuSUc5bUlFRlRRMGxKTFc5dWJIa2djM2x0WW05c2N5NWNibHgwSUNvZ1FHMWxiV0psY2s5bUlIQjFibmxqYjJSbFhHNWNkQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0JwYm5CMWRDQlVhR1VnYzNSeWFXNW5JRzltSUZWdWFXTnZaR1VnYzNsdFltOXNjeTVjYmx4MElDb2dRSEpsZEhWeWJuTWdlMU4wY21sdVozMGdWR2hsSUhKbGMzVnNkR2x1WnlCUWRXNTVZMjlrWlNCemRISnBibWNnYjJZZ1FWTkRTVWt0YjI1c2VTQnplVzFpYjJ4ekxseHVYSFFnS2k5Y2JseDBablZ1WTNScGIyNGdaVzVqYjJSbEtHbHVjSFYwS1NCN1hHNWNkRngwZG1GeUlHNHNYRzVjZEZ4MElDQWdJR1JsYkhSaExGeHVYSFJjZENBZ0lDQm9ZVzVrYkdWa1ExQkRiM1Z1ZEN4Y2JseDBYSFFnSUNBZ1ltRnphV05NWlc1bmRHZ3NYRzVjZEZ4MElDQWdJR0pwWVhNc1hHNWNkRngwSUNBZ0lHb3NYRzVjZEZ4MElDQWdJRzBzWEc1Y2RGeDBJQ0FnSUhFc1hHNWNkRngwSUNBZ0lHc3NYRzVjZEZ4MElDQWdJSFFzWEc1Y2RGeDBJQ0FnSUdOMWNuSmxiblJXWVd4MVpTeGNibHgwWEhRZ0lDQWdiM1YwY0hWMElEMGdXMTBzWEc1Y2RGeDBJQ0FnSUM4cUtpQmdhVzV3ZFhSTVpXNW5kR2hnSUhkcGJHd2dhRzlzWkNCMGFHVWdiblZ0WW1WeUlHOW1JR052WkdVZ2NHOXBiblJ6SUdsdUlHQnBibkIxZEdBdUlDb3ZYRzVjZEZ4MElDQWdJR2x1Y0hWMFRHVnVaM1JvTEZ4dVhIUmNkQ0FnSUNBdktpb2dRMkZqYUdWa0lHTmhiR04xYkdGMGFXOXVJSEpsYzNWc2RITWdLaTljYmx4MFhIUWdJQ0FnYUdGdVpHeGxaRU5RUTI5MWJuUlFiSFZ6VDI1bExGeHVYSFJjZENBZ0lDQmlZWE5sVFdsdWRYTlVMRnh1WEhSY2RDQWdJQ0J4VFdsdWRYTlVPMXh1WEc1Y2RGeDBMeThnUTI5dWRtVnlkQ0IwYUdVZ2FXNXdkWFFnYVc0Z1ZVTlRMVElnZEc4Z1ZXNXBZMjlrWlZ4dVhIUmNkR2x1Y0hWMElEMGdkV056TW1SbFkyOWtaU2hwYm5CMWRDazdYRzVjYmx4MFhIUXZMeUJEWVdOb1pTQjBhR1VnYkdWdVozUm9YRzVjZEZ4MGFXNXdkWFJNWlc1bmRHZ2dQU0JwYm5CMWRDNXNaVzVuZEdnN1hHNWNibHgwWEhRdkx5QkpibWwwYVdGc2FYcGxJSFJvWlNCemRHRjBaVnh1WEhSY2RHNGdQU0JwYm1sMGFXRnNUanRjYmx4MFhIUmtaV3gwWVNBOUlEQTdYRzVjZEZ4MFltbGhjeUE5SUdsdWFYUnBZV3hDYVdGek8xeHVYRzVjZEZ4MEx5OGdTR0Z1Wkd4bElIUm9aU0JpWVhOcFl5QmpiMlJsSUhCdmFXNTBjMXh1WEhSY2RHWnZjaUFvYWlBOUlEQTdJR29nUENCcGJuQjFkRXhsYm1kMGFEc2dLeXRxS1NCN1hHNWNkRngwWEhSamRYSnlaVzUwVm1Gc2RXVWdQU0JwYm5CMWRGdHFYVHRjYmx4MFhIUmNkR2xtSUNoamRYSnlaVzUwVm1Gc2RXVWdQQ0F3ZURnd0tTQjdYRzVjZEZ4MFhIUmNkRzkxZEhCMWRDNXdkWE5vS0hOMGNtbHVaMFp5YjIxRGFHRnlRMjlrWlNoamRYSnlaVzUwVm1Gc2RXVXBLVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjYmx4MFhIUm9ZVzVrYkdWa1ExQkRiM1Z1ZENBOUlHSmhjMmxqVEdWdVozUm9JRDBnYjNWMGNIVjBMbXhsYm1kMGFEdGNibHh1WEhSY2RDOHZJR0JvWVc1a2JHVmtRMUJEYjNWdWRHQWdhWE1nZEdobElHNTFiV0psY2lCdlppQmpiMlJsSUhCdmFXNTBjeUIwYUdGMElHaGhkbVVnWW1WbGJpQm9ZVzVrYkdWa08xeHVYSFJjZEM4dklHQmlZWE5wWTB4bGJtZDBhR0FnYVhNZ2RHaGxJRzUxYldKbGNpQnZaaUJpWVhOcFl5QmpiMlJsSUhCdmFXNTBjeTVjYmx4dVhIUmNkQzh2SUVacGJtbHphQ0IwYUdVZ1ltRnphV01nYzNSeWFXNW5JQzBnYVdZZ2FYUWdhWE1nYm05MElHVnRjSFI1SUMwZ2QybDBhQ0JoSUdSbGJHbHRhWFJsY2x4dVhIUmNkR2xtSUNoaVlYTnBZMHhsYm1kMGFDa2dlMXh1WEhSY2RGeDBiM1YwY0hWMExuQjFjMmdvWkdWc2FXMXBkR1Z5S1R0Y2JseDBYSFI5WEc1Y2JseDBYSFF2THlCTllXbHVJR1Z1WTI5a2FXNW5JR3h2YjNBNlhHNWNkRngwZDJocGJHVWdLR2hoYm1Sc1pXUkRVRU52ZFc1MElEd2dhVzV3ZFhSTVpXNW5kR2dwSUh0Y2JseHVYSFJjZEZ4MEx5OGdRV3hzSUc1dmJpMWlZWE5wWXlCamIyUmxJSEJ2YVc1MGN5QThJRzRnYUdGMlpTQmlaV1Z1SUdoaGJtUnNaV1FnWVd4eVpXRmtlUzRnUm1sdVpDQjBhR1VnYm1WNGRGeHVYSFJjZEZ4MEx5OGdiR0Z5WjJWeUlHOXVaVHBjYmx4MFhIUmNkR1p2Y2lBb2JTQTlJRzFoZUVsdWRDd2dhaUE5SURBN0lHb2dQQ0JwYm5CMWRFeGxibWQwYURzZ0t5dHFLU0I3WEc1Y2RGeDBYSFJjZEdOMWNuSmxiblJXWVd4MVpTQTlJR2x1Y0hWMFcycGRPMXh1WEhSY2RGeDBYSFJwWmlBb1kzVnljbVZ1ZEZaaGJIVmxJRDQ5SUc0Z0ppWWdZM1Z5Y21WdWRGWmhiSFZsSUR3Z2JTa2dlMXh1WEhSY2RGeDBYSFJjZEcwZ1BTQmpkWEp5Wlc1MFZtRnNkV1U3WEc1Y2RGeDBYSFJjZEgxY2JseDBYSFJjZEgxY2JseHVYSFJjZEZ4MEx5OGdTVzVqY21WaGMyVWdZR1JsYkhSaFlDQmxibTkxWjJnZ2RHOGdZV1IyWVc1alpTQjBhR1VnWkdWamIyUmxjaWR6SUR4dUxHaytJSE4wWVhSbElIUnZJRHh0TERBK0xGeHVYSFJjZEZ4MEx5OGdZblYwSUdkMVlYSmtJR0ZuWVdsdWMzUWdiM1psY21ac2IzZGNibHgwWEhSY2RHaGhibVJzWldSRFVFTnZkVzUwVUd4MWMwOXVaU0E5SUdoaGJtUnNaV1JEVUVOdmRXNTBJQ3NnTVR0Y2JseDBYSFJjZEdsbUlDaHRJQzBnYmlBK0lHWnNiMjl5S0NodFlYaEpiblFnTFNCa1pXeDBZU2tnTHlCb1lXNWtiR1ZrUTFCRGIzVnVkRkJzZFhOUGJtVXBLU0I3WEc1Y2RGeDBYSFJjZEdWeWNtOXlLQ2R2ZG1WeVpteHZkeWNwTzF4dVhIUmNkRngwZlZ4dVhHNWNkRngwWEhSa1pXeDBZU0FyUFNBb2JTQXRJRzRwSUNvZ2FHRnVaR3hsWkVOUVEyOTFiblJRYkhWelQyNWxPMXh1WEhSY2RGeDBiaUE5SUcwN1hHNWNibHgwWEhSY2RHWnZjaUFvYWlBOUlEQTdJR29nUENCcGJuQjFkRXhsYm1kMGFEc2dLeXRxS1NCN1hHNWNkRngwWEhSY2RHTjFjbkpsYm5SV1lXeDFaU0E5SUdsdWNIVjBXMnBkTzF4dVhHNWNkRngwWEhSY2RHbG1JQ2hqZFhKeVpXNTBWbUZzZFdVZ1BDQnVJQ1ltSUNzclpHVnNkR0VnUGlCdFlYaEpiblFwSUh0Y2JseDBYSFJjZEZ4MFhIUmxjbkp2Y2lnbmIzWmxjbVpzYjNjbktUdGNibHgwWEhSY2RGeDBmVnh1WEc1Y2RGeDBYSFJjZEdsbUlDaGpkWEp5Wlc1MFZtRnNkV1VnUFQwZ2Jpa2dlMXh1WEhSY2RGeDBYSFJjZEM4dklGSmxjSEpsYzJWdWRDQmtaV3gwWVNCaGN5QmhJR2RsYm1WeVlXeHBlbVZrSUhaaGNtbGhZbXhsTFd4bGJtZDBhQ0JwYm5SbFoyVnlYRzVjZEZ4MFhIUmNkRngwWm05eUlDaHhJRDBnWkdWc2RHRXNJR3NnUFNCaVlYTmxPeUF2S2lCdWJ5QmpiMjVrYVhScGIyNGdLaTg3SUdzZ0t6MGdZbUZ6WlNrZ2UxeHVYSFJjZEZ4MFhIUmNkRngwZENBOUlHc2dQRDBnWW1saGN5QS9JSFJOYVc0Z09pQW9heUErUFNCaWFXRnpJQ3NnZEUxaGVDQS9JSFJOWVhnZ09pQnJJQzBnWW1saGN5azdYRzVjZEZ4MFhIUmNkRngwWEhScFppQW9jU0E4SUhRcElIdGNibHgwWEhSY2RGeDBYSFJjZEZ4MFluSmxZV3M3WEc1Y2RGeDBYSFJjZEZ4MFhIUjlYRzVjZEZ4MFhIUmNkRngwWEhSeFRXbHVkWE5VSUQwZ2NTQXRJSFE3WEc1Y2RGeDBYSFJjZEZ4MFhIUmlZWE5sVFdsdWRYTlVJRDBnWW1GelpTQXRJSFE3WEc1Y2RGeDBYSFJjZEZ4MFhIUnZkWFJ3ZFhRdWNIVnphQ2hjYmx4MFhIUmNkRngwWEhSY2RGeDBjM1J5YVc1blJuSnZiVU5vWVhKRGIyUmxLR1JwWjJsMFZHOUNZWE5wWXloMElDc2djVTFwYm5WelZDQWxJR0poYzJWTmFXNTFjMVFzSURBcEtWeHVYSFJjZEZ4MFhIUmNkRngwS1R0Y2JseDBYSFJjZEZ4MFhIUmNkSEVnUFNCbWJHOXZjaWh4VFdsdWRYTlVJQzhnWW1GelpVMXBiblZ6VkNrN1hHNWNkRngwWEhSY2RGeDBmVnh1WEc1Y2RGeDBYSFJjZEZ4MGIzVjBjSFYwTG5CMWMyZ29jM1J5YVc1blJuSnZiVU5vWVhKRGIyUmxLR1JwWjJsMFZHOUNZWE5wWXloeExDQXdLU2twTzF4dVhIUmNkRngwWEhSY2RHSnBZWE1nUFNCaFpHRndkQ2hrWld4MFlTd2dhR0Z1Wkd4bFpFTlFRMjkxYm5SUWJIVnpUMjVsTENCb1lXNWtiR1ZrUTFCRGIzVnVkQ0E5UFNCaVlYTnBZMHhsYm1kMGFDazdYRzVjZEZ4MFhIUmNkRngwWkdWc2RHRWdQU0F3TzF4dVhIUmNkRngwWEhSY2RDc3JhR0Z1Wkd4bFpFTlFRMjkxYm5RN1hHNWNkRngwWEhSY2RIMWNibHgwWEhSY2RIMWNibHh1WEhSY2RGeDBLeXRrWld4MFlUdGNibHgwWEhSY2RDc3JianRjYmx4dVhIUmNkSDFjYmx4MFhIUnlaWFIxY200Z2IzVjBjSFYwTG1wdmFXNG9KeWNwTzF4dVhIUjlYRzVjYmx4MEx5b3FYRzVjZENBcUlFTnZiblpsY25SeklHRWdVSFZ1ZVdOdlpHVWdjM1J5YVc1bklISmxjSEpsYzJWdWRHbHVaeUJoSUdSdmJXRnBiaUJ1WVcxbElHOXlJR0Z1SUdWdFlXbHNJR0ZrWkhKbGMzTmNibHgwSUNvZ2RHOGdWVzVwWTI5a1pTNGdUMjVzZVNCMGFHVWdVSFZ1ZVdOdlpHVmtJSEJoY25SeklHOW1JSFJvWlNCcGJuQjFkQ0IzYVd4c0lHSmxJR052Ym5abGNuUmxaQ3dnYVM1bExseHVYSFFnS2lCcGRDQmtiMlZ6YmlkMElHMWhkSFJsY2lCcFppQjViM1VnWTJGc2JDQnBkQ0J2YmlCaElITjBjbWx1WnlCMGFHRjBJR2hoY3lCaGJISmxZV1I1SUdKbFpXNWNibHgwSUNvZ1kyOXVkbVZ5ZEdWa0lIUnZJRlZ1YVdOdlpHVXVYRzVjZENBcUlFQnRaVzFpWlhKUFppQndkVzU1WTI5a1pWeHVYSFFnS2lCQWNHRnlZVzBnZTFOMGNtbHVaMzBnYVc1d2RYUWdWR2hsSUZCMWJubGpiMlJsWkNCa2IyMWhhVzRnYm1GdFpTQnZjaUJsYldGcGJDQmhaR1J5WlhOeklIUnZYRzVjZENBcUlHTnZiblpsY25RZ2RHOGdWVzVwWTI5a1pTNWNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UxTjBjbWx1WjMwZ1ZHaGxJRlZ1YVdOdlpHVWdjbVZ3Y21WelpXNTBZWFJwYjI0Z2IyWWdkR2hsSUdkcGRtVnVJRkIxYm5samIyUmxYRzVjZENBcUlITjBjbWx1Wnk1Y2JseDBJQ292WEc1Y2RHWjFibU4wYVc5dUlIUnZWVzVwWTI5a1pTaHBibkIxZENrZ2UxeHVYSFJjZEhKbGRIVnliaUJ0WVhCRWIyMWhhVzRvYVc1d2RYUXNJR1oxYm1OMGFXOXVLSE4wY21sdVp5a2dlMXh1WEhSY2RGeDBjbVYwZFhKdUlISmxaMlY0VUhWdWVXTnZaR1V1ZEdWemRDaHpkSEpwYm1jcFhHNWNkRngwWEhSY2REOGdaR1ZqYjJSbEtITjBjbWx1Wnk1emJHbGpaU2cwS1M1MGIweHZkMlZ5UTJGelpTZ3BLVnh1WEhSY2RGeDBYSFE2SUhOMGNtbHVaenRjYmx4MFhIUjlLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFnS2lCRGIyNTJaWEowY3lCaElGVnVhV052WkdVZ2MzUnlhVzVuSUhKbGNISmxjMlZ1ZEdsdVp5QmhJR1J2YldGcGJpQnVZVzFsSUc5eUlHRnVJR1Z0WVdsc0lHRmtaSEpsYzNNZ2RHOWNibHgwSUNvZ1VIVnVlV052WkdVdUlFOXViSGtnZEdobElHNXZiaTFCVTBOSlNTQndZWEowY3lCdlppQjBhR1VnWkc5dFlXbHVJRzVoYldVZ2QybHNiQ0JpWlNCamIyNTJaWEowWldRc1hHNWNkQ0FxSUdrdVpTNGdhWFFnWkc5bGMyNG5kQ0J0WVhSMFpYSWdhV1lnZVc5MUlHTmhiR3dnYVhRZ2QybDBhQ0JoSUdSdmJXRnBiaUIwYUdGMEozTWdZV3h5WldGa2VTQnBibHh1WEhRZ0tpQkJVME5KU1M1Y2JseDBJQ29nUUcxbGJXSmxjazltSUhCMWJubGpiMlJsWEc1Y2RDQXFJRUJ3WVhKaGJTQjdVM1J5YVc1bmZTQnBibkIxZENCVWFHVWdaRzl0WVdsdUlHNWhiV1VnYjNJZ1pXMWhhV3dnWVdSa2NtVnpjeUIwYnlCamIyNTJaWEowTENCaGN5QmhYRzVjZENBcUlGVnVhV052WkdVZ2MzUnlhVzVuTGx4dVhIUWdLaUJBY21WMGRYSnVjeUI3VTNSeWFXNW5mU0JVYUdVZ1VIVnVlV052WkdVZ2NtVndjbVZ6Wlc1MFlYUnBiMjRnYjJZZ2RHaGxJR2RwZG1WdUlHUnZiV0ZwYmlCdVlXMWxJRzl5WEc1Y2RDQXFJR1Z0WVdsc0lHRmtaSEpsYzNNdVhHNWNkQ0FxTDF4dVhIUm1kVzVqZEdsdmJpQjBiMEZUUTBsSktHbHVjSFYwS1NCN1hHNWNkRngwY21WMGRYSnVJRzFoY0VSdmJXRnBiaWhwYm5CMWRDd2dablZ1WTNScGIyNG9jM1J5YVc1bktTQjdYRzVjZEZ4MFhIUnlaWFIxY200Z2NtVm5aWGhPYjI1QlUwTkpTUzUwWlhOMEtITjBjbWx1WnlsY2JseDBYSFJjZEZ4MFB5QW5lRzR0TFNjZ0t5QmxibU52WkdVb2MzUnlhVzVuS1Z4dVhIUmNkRngwWEhRNklITjBjbWx1Wnp0Y2JseDBYSFI5S1R0Y2JseDBmVnh1WEc1Y2RDOHFMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzBxTDF4dVhHNWNkQzhxS2lCRVpXWnBibVVnZEdobElIQjFZbXhwWXlCQlVFa2dLaTljYmx4MGNIVnVlV052WkdVZ1BTQjdYRzVjZEZ4MEx5b3FYRzVjZEZ4MElDb2dRU0J6ZEhKcGJtY2djbVZ3Y21WelpXNTBhVzVuSUhSb1pTQmpkWEp5Wlc1MElGQjFibmxqYjJSbExtcHpJSFpsY25OcGIyNGdiblZ0WW1WeUxseHVYSFJjZENBcUlFQnRaVzFpWlhKUFppQndkVzU1WTI5a1pWeHVYSFJjZENBcUlFQjBlWEJsSUZOMGNtbHVaMXh1WEhSY2RDQXFMMXh1WEhSY2RDZDJaWEp6YVc5dUp6b2dKekV1TXk0eUp5eGNibHgwWEhRdktpcGNibHgwWEhRZ0tpQkJiaUJ2WW1wbFkzUWdiMllnYldWMGFHOWtjeUIwYnlCamIyNTJaWEowSUdaeWIyMGdTbUYyWVZOamNtbHdkQ2R6SUdsdWRHVnlibUZzSUdOb1lYSmhZM1JsY2x4dVhIUmNkQ0FxSUhKbGNISmxjMlZ1ZEdGMGFXOXVJQ2hWUTFNdE1pa2dkRzhnVlc1cFkyOWtaU0JqYjJSbElIQnZhVzUwY3l3Z1lXNWtJR0poWTJzdVhHNWNkRngwSUNvZ1FITmxaU0E4YUhSMGNITTZMeTl0WVhSb2FXRnpZbmx1Wlc1ekxtSmxMMjV2ZEdWekwycGhkbUZ6WTNKcGNIUXRaVzVqYjJScGJtYytYRzVjZEZ4MElDb2dRRzFsYldKbGNrOW1JSEIxYm5samIyUmxYRzVjZEZ4MElDb2dRSFI1Y0dVZ1QySnFaV04wWEc1Y2RGeDBJQ292WEc1Y2RGeDBKM1ZqY3pJbk9pQjdYRzVjZEZ4MFhIUW5aR1ZqYjJSbEp6b2dkV056TW1SbFkyOWtaU3hjYmx4MFhIUmNkQ2RsYm1OdlpHVW5PaUIxWTNNeVpXNWpiMlJsWEc1Y2RGeDBmU3hjYmx4MFhIUW5aR1ZqYjJSbEp6b2daR1ZqYjJSbExGeHVYSFJjZENkbGJtTnZaR1VuT2lCbGJtTnZaR1VzWEc1Y2RGeDBKM1J2UVZORFNVa25PaUIwYjBGVFEwbEpMRnh1WEhSY2RDZDBiMVZ1YVdOdlpHVW5PaUIwYjFWdWFXTnZaR1ZjYmx4MGZUdGNibHh1WEhRdktpb2dSWGh3YjNObElHQndkVzU1WTI5a1pXQWdLaTljYmx4MEx5OGdVMjl0WlNCQlRVUWdZblZwYkdRZ2IzQjBhVzFwZW1WeWN5d2diR2xyWlNCeUxtcHpMQ0JqYUdWamF5Qm1iM0lnYzNCbFkybG1hV01nWTI5dVpHbDBhVzl1SUhCaGRIUmxjbTV6WEc1Y2RDOHZJR3hwYTJVZ2RHaGxJR1p2Ykd4dmQybHVaenBjYmx4MGFXWWdLRnh1WEhSY2RIUjVjR1Z2WmlCa1pXWnBibVVnUFQwZ0oyWjFibU4wYVc5dUp5QW1KbHh1WEhSY2RIUjVjR1Z2WmlCa1pXWnBibVV1WVcxa0lEMDlJQ2R2WW1wbFkzUW5JQ1ltWEc1Y2RGeDBaR1ZtYVc1bExtRnRaRnh1WEhRcElIdGNibHgwWEhSa1pXWnBibVVvSjNCMWJubGpiMlJsSnl3Z1puVnVZM1JwYjI0b0tTQjdYRzVjZEZ4MFhIUnlaWFIxY200Z2NIVnVlV052WkdVN1hHNWNkRngwZlNrN1hHNWNkSDBnWld4elpTQnBaaUFvWm5KbFpVVjRjRzl5ZEhNZ0ppWWdabkpsWlUxdlpIVnNaU2tnZTF4dVhIUmNkR2xtSUNodGIyUjFiR1V1Wlhod2IzSjBjeUE5UFNCbWNtVmxSWGh3YjNKMGN5a2dleUF2THlCcGJpQk9iMlJsTG1weklHOXlJRkpwYm1kdlNsTWdkakF1T0M0d0sxeHVYSFJjZEZ4MFpuSmxaVTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdjSFZ1ZVdOdlpHVTdYRzVjZEZ4MGZTQmxiSE5sSUhzZ0x5OGdhVzRnVG1GeWQyaGhiQ0J2Y2lCU2FXNW5iMHBUSUhZd0xqY3VNQzFjYmx4MFhIUmNkR1p2Y2lBb2EyVjVJR2x1SUhCMWJubGpiMlJsS1NCN1hHNWNkRngwWEhSY2RIQjFibmxqYjJSbExtaGhjMDkzYmxCeWIzQmxjblI1S0d0bGVTa2dKaVlnS0daeVpXVkZlSEJ2Y25SelcydGxlVjBnUFNCd2RXNTVZMjlrWlZ0clpYbGRLVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjZEgwZ1pXeHpaU0I3SUM4dklHbHVJRkpvYVc1dklHOXlJR0VnZDJWaUlHSnliM2R6WlhKY2JseDBYSFJ5YjI5MExuQjFibmxqYjJSbElEMGdjSFZ1ZVdOdlpHVTdYRzVjZEgxY2JseHVmU2gwYUdsektTazdYRzRpTENJdkx5QkRiM0I1Y21sbmFIUWdTbTk1Wlc1MExDQkpibU11SUdGdVpDQnZkR2hsY2lCT2IyUmxJR052Ym5SeWFXSjFkRzl5Y3k1Y2JpOHZYRzR2THlCUVpYSnRhWE56YVc5dUlHbHpJR2hsY21WaWVTQm5jbUZ1ZEdWa0xDQm1jbVZsSUc5bUlHTm9ZWEpuWlN3Z2RHOGdZVzU1SUhCbGNuTnZiaUJ2WW5SaGFXNXBibWNnWVZ4dUx5OGdZMjl3ZVNCdlppQjBhR2x6SUhOdlpuUjNZWEpsSUdGdVpDQmhjM052WTJsaGRHVmtJR1J2WTNWdFpXNTBZWFJwYjI0Z1ptbHNaWE1nS0hSb1pWeHVMeThnWENKVGIyWjBkMkZ5WlZ3aUtTd2dkRzhnWkdWaGJDQnBiaUIwYUdVZ1UyOW1kSGRoY21VZ2QybDBhRzkxZENCeVpYTjBjbWxqZEdsdmJpd2dhVzVqYkhWa2FXNW5YRzR2THlCM2FYUm9iM1YwSUd4cGJXbDBZWFJwYjI0Z2RHaGxJSEpwWjJoMGN5QjBieUIxYzJVc0lHTnZjSGtzSUcxdlpHbG1lU3dnYldWeVoyVXNJSEIxWW14cGMyZ3NYRzR2THlCa2FYTjBjbWxpZFhSbExDQnpkV0pzYVdObGJuTmxMQ0JoYm1RdmIzSWdjMlZzYkNCamIzQnBaWE1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMQ0JoYm1RZ2RHOGdjR1Z5YldsMFhHNHZMeUJ3WlhKemIyNXpJSFJ2SUhkb2IyMGdkR2hsSUZOdlpuUjNZWEpsSUdseklHWjFjbTVwYzJobFpDQjBieUJrYnlCemJ5d2djM1ZpYW1WamRDQjBieUIwYUdWY2JpOHZJR1p2Ykd4dmQybHVaeUJqYjI1a2FYUnBiMjV6T2x4dUx5OWNiaTh2SUZSb1pTQmhZbTkyWlNCamIzQjVjbWxuYUhRZ2JtOTBhV05sSUdGdVpDQjBhR2x6SUhCbGNtMXBjM05wYjI0Z2JtOTBhV05sSUhOb1lXeHNJR0psSUdsdVkyeDFaR1ZrWEc0dkx5QnBiaUJoYkd3Z1kyOXdhV1Z6SUc5eUlITjFZbk4wWVc1MGFXRnNJSEJ2Y25ScGIyNXpJRzltSUhSb1pTQlRiMlowZDJGeVpTNWNiaTh2WEc0dkx5QlVTRVVnVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1hDSkJVeUJKVTF3aUxDQlhTVlJJVDFWVUlGZEJVbEpCVGxSWklFOUdJRUZPV1NCTFNVNUVMQ0JGV0ZCU1JWTlRYRzR2THlCUFVpQkpUVkJNU1VWRUxDQkpUa05NVlVSSlRrY2dRbFZVSUU1UFZDQk1TVTFKVkVWRUlGUlBJRlJJUlNCWFFWSlNRVTVVU1VWVElFOUdYRzR2THlCTlJWSkRTRUZPVkVGQ1NVeEpWRmtzSUVaSlZFNUZVMU1nUms5U0lFRWdVRUZTVkVsRFZVeEJVaUJRVlZKUVQxTkZJRUZPUkNCT1QwNUpUa1pTU1U1SFJVMUZUbFF1SUVsT1hHNHZMeUJPVHlCRlZrVk9WQ0JUU0VGTVRDQlVTRVVnUVZWVVNFOVNVeUJQVWlCRFQxQlpVa2xIU0ZRZ1NFOU1SRVZTVXlCQ1JTQk1TVUZDVEVVZ1JrOVNJRUZPV1NCRFRFRkpUU3hjYmk4dklFUkJUVUZIUlZNZ1QxSWdUMVJJUlZJZ1RFbEJRa2xNU1ZSWkxDQlhTRVZVU0VWU0lFbE9JRUZPSUVGRFZFbFBUaUJQUmlCRFQwNVVVa0ZEVkN3Z1ZFOVNWQ0JQVWx4dUx5OGdUMVJJUlZKWFNWTkZMQ0JCVWtsVFNVNUhJRVpTVDAwc0lFOVZWQ0JQUmlCUFVpQkpUaUJEVDA1T1JVTlVTVTlPSUZkSlZFZ2dWRWhGSUZOUFJsUlhRVkpGSUU5U0lGUklSVnh1THk4Z1ZWTkZJRTlTSUU5VVNFVlNJRVJGUVV4SlRrZFRJRWxPSUZSSVJTQlRUMFpVVjBGU1JTNWNibHh1SjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ2NIVnVlV052WkdVZ1BTQnlaWEYxYVhKbEtDZHdkVzU1WTI5a1pTY3BPMXh1ZG1GeUlIVjBhV3dnUFNCeVpYRjFhWEpsS0NjdUwzVjBhV3duS1R0Y2JseHVaWGh3YjNKMGN5NXdZWEp6WlNBOUlIVnliRkJoY25ObE8xeHVaWGh3YjNKMGN5NXlaWE52YkhabElEMGdkWEpzVW1WemIyeDJaVHRjYm1WNGNHOXlkSE11Y21WemIyeDJaVTlpYW1WamRDQTlJSFZ5YkZKbGMyOXNkbVZQWW1wbFkzUTdYRzVsZUhCdmNuUnpMbVp2Y20xaGRDQTlJSFZ5YkVadmNtMWhkRHRjYmx4dVpYaHdiM0owY3k1VmNtd2dQU0JWY213N1hHNWNibVoxYm1OMGFXOXVJRlZ5YkNncElIdGNiaUFnZEdocGN5NXdjbTkwYjJOdmJDQTlJRzUxYkd3N1hHNGdJSFJvYVhNdWMyeGhjMmhsY3lBOUlHNTFiR3c3WEc0Z0lIUm9hWE11WVhWMGFDQTlJRzUxYkd3N1hHNGdJSFJvYVhNdWFHOXpkQ0E5SUc1MWJHdzdYRzRnSUhSb2FYTXVjRzl5ZENBOUlHNTFiR3c3WEc0Z0lIUm9hWE11YUc5emRHNWhiV1VnUFNCdWRXeHNPMXh1SUNCMGFHbHpMbWhoYzJnZ1BTQnVkV3hzTzF4dUlDQjBhR2x6TG5ObFlYSmphQ0E5SUc1MWJHdzdYRzRnSUhSb2FYTXVjWFZsY25rZ1BTQnVkV3hzTzF4dUlDQjBhR2x6TG5CaGRHaHVZVzFsSUQwZ2JuVnNiRHRjYmlBZ2RHaHBjeTV3WVhSb0lEMGdiblZzYkR0Y2JpQWdkR2hwY3k1b2NtVm1JRDBnYm5Wc2JEdGNibjFjYmx4dUx5OGdVbVZtWlhKbGJtTmxPaUJTUmtNZ016azROaXdnVWtaRElERTRNRGdzSUZKR1F5QXlNemsyWEc1Y2JpOHZJR1JsWm1sdVpTQjBhR1Z6WlNCb1pYSmxJSE52SUdGMElHeGxZWE4wSUhSb1pYa2diMjVzZVNCb1lYWmxJSFJ2SUdKbFhHNHZMeUJqYjIxd2FXeGxaQ0J2Ym1ObElHOXVJSFJvWlNCbWFYSnpkQ0J0YjJSMWJHVWdiRzloWkM1Y2JuWmhjaUJ3Y205MGIyTnZiRkJoZEhSbGNtNGdQU0F2WGloYllTMTZNQzA1TGlzdFhTczZLUzlwTEZ4dUlDQWdJSEJ2Y25SUVlYUjBaWEp1SUQwZ0x6cGJNQzA1WFNva0x5eGNibHh1SUNBZ0lDOHZJRk53WldOcFlXd2dZMkZ6WlNCbWIzSWdZU0J6YVcxd2JHVWdjR0YwYUNCVlVreGNiaUFnSUNCemFXMXdiR1ZRWVhSb1VHRjBkR1Z5YmlBOUlDOWVLRnhjTDF4Y0x6OG9QeUZjWEM4cFcxNWNYRDljWEhOZEtpa29YRncvVzE1Y1hITmRLaWsvSkM4c1hHNWNiaUFnSUNBdkx5QlNSa01nTWpNNU5qb2dZMmhoY21GamRHVnljeUJ5WlhObGNuWmxaQ0JtYjNJZ1pHVnNhVzFwZEdsdVp5QlZVa3h6TGx4dUlDQWdJQzh2SUZkbElHRmpkSFZoYkd4NUlHcDFjM1FnWVhWMGJ5MWxjMk5oY0dVZ2RHaGxjMlV1WEc0Z0lDQWdaR1ZzYVcxeklEMGdXeWM4Snl3Z0p6NG5MQ0FuWENJbkxDQW5ZQ2NzSUNjZ0p5d2dKMXhjY2ljc0lDZGNYRzRuTENBblhGeDBKMTBzWEc1Y2JpQWdJQ0F2THlCU1JrTWdNak01TmpvZ1kyaGhjbUZqZEdWeWN5QnViM1FnWVd4c2IzZGxaQ0JtYjNJZ2RtRnlhVzkxY3lCeVpXRnpiMjV6TGx4dUlDQWdJSFZ1ZDJselpTQTlJRnNuZXljc0lDZDlKeXdnSjN3bkxDQW5YRnhjWENjc0lDZGVKeXdnSjJBblhTNWpiMjVqWVhRb1pHVnNhVzF6S1N4Y2JseHVJQ0FnSUM4dklFRnNiRzkzWldRZ1lua2dVa1pEY3l3Z1luVjBJR05oZFhObElHOW1JRmhUVXlCaGRIUmhZMnR6TGlBZ1FXeDNZWGx6SUdWelkyRndaU0IwYUdWelpTNWNiaUFnSUNCaGRYUnZSWE5qWVhCbElEMGdXeWRjWENjblhTNWpiMjVqWVhRb2RXNTNhWE5sS1N4Y2JpQWdJQ0F2THlCRGFHRnlZV04wWlhKeklIUm9ZWFFnWVhKbElHNWxkbVZ5SUdWMlpYSWdZV3hzYjNkbFpDQnBiaUJoSUdodmMzUnVZVzFsTGx4dUlDQWdJQzh2SUU1dmRHVWdkR2hoZENCaGJua2dhVzUyWVd4cFpDQmphR0Z5Y3lCaGNtVWdZV3h6YnlCb1lXNWtiR1ZrTENCaWRYUWdkR2hsYzJWY2JpQWdJQ0F2THlCaGNtVWdkR2hsSUc5dVpYTWdkR2hoZENCaGNtVWdLbVY0Y0dWamRHVmtLaUIwYnlCaVpTQnpaV1Z1TENCemJ5QjNaU0JtWVhOMExYQmhkR2hjYmlBZ0lDQXZMeUIwYUdWdExseHVJQ0FnSUc1dmJraHZjM1JEYUdGeWN5QTlJRnNuSlNjc0lDY3ZKeXdnSno4bkxDQW5PeWNzSUNjakoxMHVZMjl1WTJGMEtHRjFkRzlGYzJOaGNHVXBMRnh1SUNBZ0lHaHZjM1JGYm1ScGJtZERhR0Z5Y3lBOUlGc25MeWNzSUNjL0p5d2dKeU1uWFN4Y2JpQWdJQ0JvYjNOMGJtRnRaVTFoZUV4bGJpQTlJREkxTlN4Y2JpQWdJQ0JvYjNOMGJtRnRaVkJoY25SUVlYUjBaWEp1SUQwZ0wxNWJLMkV0ZWpBdE9VRXRXbDh0WFhzd0xEWXpmU1F2TEZ4dUlDQWdJR2h2YzNSdVlXMWxVR0Z5ZEZOMFlYSjBJRDBnTDE0b1d5dGhMWG93TFRsQkxWcGZMVjE3TUN3Mk0zMHBLQzRxS1NRdkxGeHVJQ0FnSUM4dklIQnliM1J2WTI5c2N5QjBhR0YwSUdOaGJpQmhiR3h2ZHlCY0luVnVjMkZtWlZ3aUlHRnVaQ0JjSW5WdWQybHpaVndpSUdOb1lYSnpMbHh1SUNBZ0lIVnVjMkZtWlZCeWIzUnZZMjlzSUQwZ2UxeHVJQ0FnSUNBZ0oycGhkbUZ6WTNKcGNIUW5PaUIwY25WbExGeHVJQ0FnSUNBZ0oycGhkbUZ6WTNKcGNIUTZKem9nZEhKMVpWeHVJQ0FnSUgwc1hHNGdJQ0FnTHk4Z2NISnZkRzlqYjJ4eklIUm9ZWFFnYm1WMlpYSWdhR0YyWlNCaElHaHZjM1J1WVcxbExseHVJQ0FnSUdodmMzUnNaWE56VUhKdmRHOWpiMndnUFNCN1hHNGdJQ0FnSUNBbmFtRjJZWE5qY21sd2RDYzZJSFJ5ZFdVc1hHNGdJQ0FnSUNBbmFtRjJZWE5qY21sd2REb25PaUIwY25WbFhHNGdJQ0FnZlN4Y2JpQWdJQ0F2THlCd2NtOTBiMk52YkhNZ2RHaGhkQ0JoYkhkaGVYTWdZMjl1ZEdGcGJpQmhJQzh2SUdKcGRDNWNiaUFnSUNCemJHRnphR1ZrVUhKdmRHOWpiMndnUFNCN1hHNGdJQ0FnSUNBbmFIUjBjQ2M2SUhSeWRXVXNYRzRnSUNBZ0lDQW5hSFIwY0hNbk9pQjBjblZsTEZ4dUlDQWdJQ0FnSjJaMGNDYzZJSFJ5ZFdVc1hHNGdJQ0FnSUNBbloyOXdhR1Z5SnpvZ2RISjFaU3hjYmlBZ0lDQWdJQ2RtYVd4bEp6b2dkSEoxWlN4Y2JpQWdJQ0FnSUNkb2RIUndPaWM2SUhSeWRXVXNYRzRnSUNBZ0lDQW5hSFIwY0hNNkp6b2dkSEoxWlN4Y2JpQWdJQ0FnSUNkbWRIQTZKem9nZEhKMVpTeGNiaUFnSUNBZ0lDZG5iM0JvWlhJNkp6b2dkSEoxWlN4Y2JpQWdJQ0FnSUNkbWFXeGxPaWM2SUhSeWRXVmNiaUFnSUNCOUxGeHVJQ0FnSUhGMVpYSjVjM1J5YVc1bklEMGdjbVZ4ZFdseVpTZ25jWFZsY25semRISnBibWNuS1R0Y2JseHVablZ1WTNScGIyNGdkWEpzVUdGeWMyVW9kWEpzTENCd1lYSnpaVkYxWlhKNVUzUnlhVzVuTENCemJHRnphR1Z6UkdWdWIzUmxTRzl6ZENrZ2UxeHVJQ0JwWmlBb2RYSnNJQ1ltSUhWMGFXd3VhWE5QWW1wbFkzUW9kWEpzS1NBbUppQjFjbXdnYVc1emRHRnVZMlZ2WmlCVmNtd3BJSEpsZEhWeWJpQjFjbXc3WEc1Y2JpQWdkbUZ5SUhVZ1BTQnVaWGNnVlhKc08xeHVJQ0IxTG5CaGNuTmxLSFZ5YkN3Z2NHRnljMlZSZFdWeWVWTjBjbWx1Wnl3Z2MyeGhjMmhsYzBSbGJtOTBaVWh2YzNRcE8xeHVJQ0J5WlhSMWNtNGdkVHRjYm4xY2JseHVWWEpzTG5CeWIzUnZkSGx3WlM1d1lYSnpaU0E5SUdaMWJtTjBhVzl1S0hWeWJDd2djR0Z5YzJWUmRXVnllVk4wY21sdVp5d2djMnhoYzJobGMwUmxibTkwWlVodmMzUXBJSHRjYmlBZ2FXWWdLQ0YxZEdsc0xtbHpVM1J5YVc1bktIVnliQ2twSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0Z3aVVHRnlZVzFsZEdWeUlDZDFjbXduSUcxMWMzUWdZbVVnWVNCemRISnBibWNzSUc1dmRDQmNJaUFySUhSNWNHVnZaaUIxY213cE8xeHVJQ0I5WEc1Y2JpQWdMeThnUTI5d2VTQmphSEp2YldVc0lFbEZMQ0J2Y0dWeVlTQmlZV05yYzJ4aGMyZ3RhR0Z1Wkd4cGJtY2dZbVZvWVhacGIzSXVYRzRnSUM4dklFSmhZMnNnYzJ4aGMyaGxjeUJpWldadmNtVWdkR2hsSUhGMVpYSjVJSE4wY21sdVp5Qm5aWFFnWTI5dWRtVnlkR1ZrSUhSdklHWnZjbmRoY21RZ2MyeGhjMmhsYzF4dUlDQXZMeUJUWldVNklHaDBkSEJ6T2k4dlkyOWtaUzVuYjI5bmJHVXVZMjl0TDNBdlkyaHliMjFwZFcwdmFYTnpkV1Z6TDJSbGRHRnBiRDlwWkQweU5Ua3hObHh1SUNCMllYSWdjWFZsY25sSmJtUmxlQ0E5SUhWeWJDNXBibVJsZUU5bUtDYy9KeWtzWEc0Z0lDQWdJQ0J6Y0d4cGRIUmxjaUE5WEc0Z0lDQWdJQ0FnSUNBZ0tIRjFaWEo1U1c1a1pYZ2dJVDA5SUMweElDWW1JSEYxWlhKNVNXNWtaWGdnUENCMWNtd3VhVzVrWlhoUFppZ25JeWNwS1NBL0lDYy9KeUE2SUNjakp5eGNiaUFnSUNBZ0lIVlRjR3hwZENBOUlIVnliQzV6Y0d4cGRDaHpjR3hwZEhSbGNpa3NYRzRnSUNBZ0lDQnpiR0Z6YUZKbFoyVjRJRDBnTDF4Y1hGd3ZaenRjYmlBZ2RWTndiR2wwV3pCZElEMGdkVk53YkdsMFd6QmRMbkpsY0d4aFkyVW9jMnhoYzJoU1pXZGxlQ3dnSnk4bktUdGNiaUFnZFhKc0lEMGdkVk53YkdsMExtcHZhVzRvYzNCc2FYUjBaWElwTzF4dVhHNGdJSFpoY2lCeVpYTjBJRDBnZFhKc08xeHVYRzRnSUM4dklIUnlhVzBnWW1WbWIzSmxJSEJ5YjJObFpXUnBibWN1WEc0Z0lDOHZJRlJvYVhNZ2FYTWdkRzhnYzNWd2NHOXlkQ0J3WVhKelpTQnpkSFZtWmlCc2FXdGxJRndpSUNCb2RIUndPaTh2Wm05dkxtTnZiU0FnWEZ4dVhDSmNiaUFnY21WemRDQTlJSEpsYzNRdWRISnBiU2dwTzF4dVhHNGdJR2xtSUNnaGMyeGhjMmhsYzBSbGJtOTBaVWh2YzNRZ0ppWWdkWEpzTG5Od2JHbDBLQ2NqSnlrdWJHVnVaM1JvSUQwOVBTQXhLU0I3WEc0Z0lDQWdMeThnVkhKNUlHWmhjM1FnY0dGMGFDQnlaV2RsZUhCY2JpQWdJQ0IyWVhJZ2MybHRjR3hsVUdGMGFDQTlJSE5wYlhCc1pWQmhkR2hRWVhSMFpYSnVMbVY0WldNb2NtVnpkQ2s3WEc0Z0lDQWdhV1lnS0hOcGJYQnNaVkJoZEdncElIdGNiaUFnSUNBZ0lIUm9hWE11Y0dGMGFDQTlJSEpsYzNRN1hHNGdJQ0FnSUNCMGFHbHpMbWh5WldZZ1BTQnlaWE4wTzF4dUlDQWdJQ0FnZEdocGN5NXdZWFJvYm1GdFpTQTlJSE5wYlhCc1pWQmhkR2hiTVYwN1hHNGdJQ0FnSUNCcFppQW9jMmx0Y0d4bFVHRjBhRnN5WFNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5ObFlYSmphQ0E5SUhOcGJYQnNaVkJoZEdoYk1sMDdYRzRnSUNBZ0lDQWdJR2xtSUNod1lYSnpaVkYxWlhKNVUzUnlhVzVuS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY3k1eGRXVnllU0E5SUhGMVpYSjVjM1J5YVc1bkxuQmhjbk5sS0hSb2FYTXVjMlZoY21Ob0xuTjFZbk4wY2lneEtTazdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnZEdocGN5NXhkV1Z5ZVNBOUlIUm9hWE11YzJWaGNtTm9Mbk4xWW5OMGNpZ3hLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlNCbGJITmxJR2xtSUNod1lYSnpaVkYxWlhKNVUzUnlhVzVuS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11YzJWaGNtTm9JRDBnSnljN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y1hWbGNua2dQU0I3ZlR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhKbGRIVnliaUIwYUdsek8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lIWmhjaUJ3Y205MGJ5QTlJSEJ5YjNSdlkyOXNVR0YwZEdWeWJpNWxlR1ZqS0hKbGMzUXBPMXh1SUNCcFppQW9jSEp2ZEc4cElIdGNiaUFnSUNCd2NtOTBieUE5SUhCeWIzUnZXekJkTzF4dUlDQWdJSFpoY2lCc2IzZGxjbEJ5YjNSdklEMGdjSEp2ZEc4dWRHOU1iM2RsY2tOaGMyVW9LVHRjYmlBZ0lDQjBhR2x6TG5CeWIzUnZZMjlzSUQwZ2JHOTNaWEpRY205MGJ6dGNiaUFnSUNCeVpYTjBJRDBnY21WemRDNXpkV0p6ZEhJb2NISnZkRzh1YkdWdVozUm9LVHRjYmlBZ2ZWeHVYRzRnSUM4dklHWnBaM1Z5WlNCdmRYUWdhV1lnYVhRbmN5Qm5iM1FnWVNCb2IzTjBYRzRnSUM4dklIVnpaWEpBYzJWeWRtVnlJR2x6SUNwaGJIZGhlWE1xSUdsdWRHVnljSEpsZEdWa0lHRnpJR0VnYUc5emRHNWhiV1VzSUdGdVpDQjFjbXhjYmlBZ0x5OGdjbVZ6YjJ4MWRHbHZiaUIzYVd4c0lIUnlaV0YwSUM4dlptOXZMMkpoY2lCaGN5Qm9iM04wUFdadmJ5eHdZWFJvUFdKaGNpQmlaV05oZFhObElIUm9ZWFFuYzF4dUlDQXZMeUJvYjNjZ2RHaGxJR0p5YjNkelpYSWdjbVZ6YjJ4MlpYTWdjbVZzWVhScGRtVWdWVkpNY3k1Y2JpQWdhV1lnS0hOc1lYTm9aWE5FWlc1dmRHVkliM04wSUh4OElIQnliM1J2SUh4OElISmxjM1F1YldGMFkyZ29MMTVjWEM5Y1hDOWJYa0JjWEM5ZEswQmJYa0JjWEM5ZEt5OHBLU0I3WEc0Z0lDQWdkbUZ5SUhOc1lYTm9aWE1nUFNCeVpYTjBMbk4xWW5OMGNpZ3dMQ0F5S1NBOVBUMGdKeTh2Snp0Y2JpQWdJQ0JwWmlBb2MyeGhjMmhsY3lBbUppQWhLSEJ5YjNSdklDWW1JR2h2YzNSc1pYTnpVSEp2ZEc5amIyeGJjSEp2ZEc5ZEtTa2dlMXh1SUNBZ0lDQWdjbVZ6ZENBOUlISmxjM1F1YzNWaWMzUnlLRElwTzF4dUlDQWdJQ0FnZEdocGN5NXpiR0Z6YUdWeklEMGdkSEoxWlR0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCcFppQW9JV2h2YzNSc1pYTnpVSEp2ZEc5amIyeGJjSEp2ZEc5ZElDWW1YRzRnSUNBZ0lDQW9jMnhoYzJobGN5QjhmQ0FvY0hKdmRHOGdKaVlnSVhOc1lYTm9aV1JRY205MGIyTnZiRnR3Y205MGIxMHBLU2tnZTF4dVhHNGdJQ0FnTHk4Z2RHaGxjbVVuY3lCaElHaHZjM1J1WVcxbExseHVJQ0FnSUM4dklIUm9aU0JtYVhKemRDQnBibk4wWVc1alpTQnZaaUF2TENBL0xDQTdMQ0J2Y2lBaklHVnVaSE1nZEdobElHaHZjM1F1WEc0Z0lDQWdMeTljYmlBZ0lDQXZMeUJKWmlCMGFHVnlaU0JwY3lCaGJpQkFJR2x1SUhSb1pTQm9iM04wYm1GdFpTd2dkR2hsYmlCdWIyNHRhRzl6ZENCamFHRnljeUFxWVhKbEtpQmhiR3h2ZDJWa1hHNGdJQ0FnTHk4Z2RHOGdkR2hsSUd4bFpuUWdiMllnZEdobElHeGhjM1FnUUNCemFXZHVMQ0IxYm14bGMzTWdjMjl0WlNCb2IzTjBMV1Z1WkdsdVp5QmphR0Z5WVdOMFpYSmNiaUFnSUNBdkx5QmpiMjFsY3lBcVltVm1iM0psS2lCMGFHVWdRQzF6YVdkdUxseHVJQ0FnSUM4dklGVlNUSE1nWVhKbElHOWlibTk0YVc5MWN5NWNiaUFnSUNBdkwxeHVJQ0FnSUM4dklHVjRPbHh1SUNBZ0lDOHZJR2gwZEhBNkx5OWhRR0pBWXk4Z1BUNGdkWE5sY2pwaFFHSWdhRzl6ZERwalhHNGdJQ0FnTHk4Z2FIUjBjRG92TDJGQVlqOUFZeUE5UGlCMWMyVnlPbUVnYUc5emREcGpJSEJoZEdnNkx6OUFZMXh1WEc0Z0lDQWdMeThnZGpBdU1USWdWRTlFVHlocGMyRmhZM01wT2lCVWFHbHpJR2x6SUc1dmRDQnhkV2wwWlNCb2IzY2dRMmh5YjIxbElHUnZaWE1nZEdocGJtZHpMbHh1SUNBZ0lDOHZJRkpsZG1sbGR5QnZkWElnZEdWemRDQmpZWE5sSUdGbllXbHVjM1FnWW5KdmQzTmxjbk1nYlc5eVpTQmpiMjF3Y21Wb1pXNXphWFpsYkhrdVhHNWNiaUFnSUNBdkx5Qm1hVzVrSUhSb1pTQm1hWEp6ZENCcGJuTjBZVzVqWlNCdlppQmhibmtnYUc5emRFVnVaR2x1WjBOb1lYSnpYRzRnSUNBZ2RtRnlJR2h2YzNSRmJtUWdQU0F0TVR0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdodmMzUkZibVJwYm1kRGFHRnljeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2RtRnlJR2hsWXlBOUlISmxjM1F1YVc1a1pYaFBaaWhvYjNOMFJXNWthVzVuUTJoaGNuTmJhVjBwTzF4dUlDQWdJQ0FnYVdZZ0tHaGxZeUFoUFQwZ0xURWdKaVlnS0dodmMzUkZibVFnUFQwOUlDMHhJSHg4SUdobFl5QThJR2h2YzNSRmJtUXBLVnh1SUNBZ0lDQWdJQ0JvYjNOMFJXNWtJRDBnYUdWak8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklHRjBJSFJvYVhNZ2NHOXBiblFzSUdWcGRHaGxjaUIzWlNCb1lYWmxJR0Z1SUdWNGNHeHBZMmwwSUhCdmFXNTBJSGRvWlhKbElIUm9aVnh1SUNBZ0lDOHZJR0YxZEdnZ2NHOXlkR2x2YmlCallXNXViM1FnWjI4Z2NHRnpkQ3dnYjNJZ2RHaGxJR3hoYzNRZ1FDQmphR0Z5SUdseklIUm9aU0JrWldOcFpHVnlMbHh1SUNBZ0lIWmhjaUJoZFhSb0xDQmhkRk5wWjI0N1hHNGdJQ0FnYVdZZ0tHaHZjM1JGYm1RZ1BUMDlJQzB4S1NCN1hHNGdJQ0FnSUNBdkx5QmhkRk5wWjI0Z1kyRnVJR0psSUdGdWVYZG9aWEpsTGx4dUlDQWdJQ0FnWVhSVGFXZHVJRDBnY21WemRDNXNZWE4wU1c1a1pYaFBaaWduUUNjcE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0F2THlCaGRGTnBaMjRnYlhWemRDQmlaU0JwYmlCaGRYUm9JSEJ2Y25ScGIyNHVYRzRnSUNBZ0lDQXZMeUJvZEhSd09pOHZZVUJpTDJOQVpDQTlQaUJvYjNOME9tSWdZWFYwYURwaElIQmhkR2c2TDJOQVpGeHVJQ0FnSUNBZ1lYUlRhV2R1SUQwZ2NtVnpkQzVzWVhOMFNXNWtaWGhQWmlnblFDY3NJR2h2YzNSRmJtUXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJRTV2ZHlCM1pTQm9ZWFpsSUdFZ2NHOXlkR2x2YmlCM2FHbGphQ0JwY3lCa1pXWnBibWwwWld4NUlIUm9aU0JoZFhSb0xseHVJQ0FnSUM4dklGQjFiR3dnZEdoaGRDQnZabVl1WEc0Z0lDQWdhV1lnS0dGMFUybG5iaUFoUFQwZ0xURXBJSHRjYmlBZ0lDQWdJR0YxZEdnZ1BTQnlaWE4wTG5Oc2FXTmxLREFzSUdGMFUybG5iaWs3WEc0Z0lDQWdJQ0J5WlhOMElEMGdjbVZ6ZEM1emJHbGpaU2hoZEZOcFoyNGdLeUF4S1R0Y2JpQWdJQ0FnSUhSb2FYTXVZWFYwYUNBOUlHUmxZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDaGhkWFJvS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCMGFHVWdhRzl6ZENCcGN5QjBhR1VnY21WdFlXbHVhVzVuSUhSdklIUm9aU0JzWldaMElHOW1JSFJvWlNCbWFYSnpkQ0J1YjI0dGFHOXpkQ0JqYUdGeVhHNGdJQ0FnYUc5emRFVnVaQ0E5SUMweE8xeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2JtOXVTRzl6ZEVOb1lYSnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNCMllYSWdhR1ZqSUQwZ2NtVnpkQzVwYm1SbGVFOW1LRzV2YmtodmMzUkRhR0Z5YzF0cFhTazdYRzRnSUNBZ0lDQnBaaUFvYUdWaklDRTlQU0F0TVNBbUppQW9hRzl6ZEVWdVpDQTlQVDBnTFRFZ2ZId2dhR1ZqSUR3Z2FHOXpkRVZ1WkNrcFhHNGdJQ0FnSUNBZ0lHaHZjM1JGYm1RZ1BTQm9aV003WEc0Z0lDQWdmVnh1SUNBZ0lDOHZJR2xtSUhkbElITjBhV3hzSUdoaGRtVWdibTkwSUdocGRDQnBkQ3dnZEdobGJpQjBhR1VnWlc1MGFYSmxJSFJvYVc1bklHbHpJR0VnYUc5emRDNWNiaUFnSUNCcFppQW9hRzl6ZEVWdVpDQTlQVDBnTFRFcFhHNGdJQ0FnSUNCb2IzTjBSVzVrSUQwZ2NtVnpkQzVzWlc1bmRHZzdYRzVjYmlBZ0lDQjBhR2x6TG1odmMzUWdQU0J5WlhOMExuTnNhV05sS0RBc0lHaHZjM1JGYm1RcE8xeHVJQ0FnSUhKbGMzUWdQU0J5WlhOMExuTnNhV05sS0dodmMzUkZibVFwTzF4dVhHNGdJQ0FnTHk4Z2NIVnNiQ0J2ZFhRZ2NHOXlkQzVjYmlBZ0lDQjBhR2x6TG5CaGNuTmxTRzl6ZENncE8xeHVYRzRnSUNBZ0x5OGdkMlVuZG1VZ2FXNWthV05oZEdWa0lIUm9ZWFFnZEdobGNtVWdhWE1nWVNCb2IzTjBibUZ0WlN4Y2JpQWdJQ0F2THlCemJ5QmxkbVZ1SUdsbUlHbDBKM01nWlcxd2RIa3NJR2wwSUdoaGN5QjBieUJpWlNCd2NtVnpaVzUwTGx4dUlDQWdJSFJvYVhNdWFHOXpkRzVoYldVZ1BTQjBhR2x6TG1odmMzUnVZVzFsSUh4OElDY25PMXh1WEc0Z0lDQWdMeThnYVdZZ2FHOXpkRzVoYldVZ1ltVm5hVzV6SUhkcGRHZ2dXeUJoYm1RZ1pXNWtjeUIzYVhSb0lGMWNiaUFnSUNBdkx5QmhjM04xYldVZ2RHaGhkQ0JwZENkeklHRnVJRWxRZGpZZ1lXUmtjbVZ6Y3k1Y2JpQWdJQ0IyWVhJZ2FYQjJOa2h2YzNSdVlXMWxJRDBnZEdocGN5NW9iM04wYm1GdFpWc3dYU0E5UFQwZ0oxc25JQ1ltWEc0Z0lDQWdJQ0FnSUhSb2FYTXVhRzl6ZEc1aGJXVmJkR2hwY3k1b2IzTjBibUZ0WlM1c1pXNW5kR2dnTFNBeFhTQTlQVDBnSjEwbk8xeHVYRzRnSUNBZ0x5OGdkbUZzYVdSaGRHVWdZU0JzYVhSMGJHVXVYRzRnSUNBZ2FXWWdLQ0ZwY0hZMlNHOXpkRzVoYldVcElIdGNiaUFnSUNBZ0lIWmhjaUJvYjNOMGNHRnlkSE1nUFNCMGFHbHpMbWh2YzNSdVlXMWxMbk53YkdsMEtDOWNYQzR2S1R0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdMQ0JzSUQwZ2FHOXpkSEJoY25SekxteGxibWQwYURzZ2FTQThJR3c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2NHRnlkQ0E5SUdodmMzUndZWEowYzF0cFhUdGNiaUFnSUNBZ0lDQWdhV1lnS0NGd1lYSjBLU0JqYjI1MGFXNTFaVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRndZWEowTG0xaGRHTm9LR2h2YzNSdVlXMWxVR0Z5ZEZCaGRIUmxjbTRwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUc1bGQzQmhjblFnUFNBbkp6dGNiaUFnSUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJxSUQwZ01Dd2dheUE5SUhCaGNuUXViR1Z1WjNSb095QnFJRHdnYXpzZ2Fpc3JLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvY0dGeWRDNWphR0Z5UTI5a1pVRjBLR29wSUQ0Z01USTNLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUhkbElISmxjR3hoWTJVZ2JtOXVMVUZUUTBsSklHTm9ZWElnZDJsMGFDQmhJSFJsYlhCdmNtRnllU0J3YkdGalpXaHZiR1JsY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0F2THlCM1pTQnVaV1ZrSUhSb2FYTWdkRzhnYldGclpTQnpkWEpsSUhOcGVtVWdiMllnYUc5emRHNWhiV1VnYVhNZ2JtOTBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDOHZJR0p5YjJ0bGJpQmllU0J5WlhCc1lXTnBibWNnYm05dUxVRlRRMGxKSUdKNUlHNXZkR2hwYm1kY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYm1WM2NHRnlkQ0FyUFNBbmVDYzdYRzRnSUNBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J1Wlhkd1lYSjBJQ3M5SUhCaGNuUmJhbDA3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNBZ0lDOHZJSGRsSUhSbGMzUWdZV2RoYVc0Z2QybDBhQ0JCVTBOSlNTQmphR0Z5SUc5dWJIbGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb0lXNWxkM0JoY25RdWJXRjBZMmdvYUc5emRHNWhiV1ZRWVhKMFVHRjBkR1Z5YmlrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhaaGNpQjJZV3hwWkZCaGNuUnpJRDBnYUc5emRIQmhjblJ6TG5Oc2FXTmxLREFzSUdrcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlHNXZkRWh2YzNRZ1BTQm9iM04wY0dGeWRITXVjMnhwWTJVb2FTQXJJREVwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdkbUZ5SUdKcGRDQTlJSEJoY25RdWJXRjBZMmdvYUc5emRHNWhiV1ZRWVhKMFUzUmhjblFwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0dKcGRDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjJZV3hwWkZCaGNuUnpMbkIxYzJnb1ltbDBXekZkS1R0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYm05MFNHOXpkQzUxYm5Ob2FXWjBLR0pwZEZzeVhTazdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2JtOTBTRzl6ZEM1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WemRDQTlJQ2N2SnlBcklHNXZkRWh2YzNRdWFtOXBiaWduTGljcElDc2djbVZ6ZER0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11YUc5emRHNWhiV1VnUFNCMllXeHBaRkJoY25SekxtcHZhVzRvSnk0bktUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDaDBhR2x6TG1odmMzUnVZVzFsTG14bGJtZDBhQ0ErSUdodmMzUnVZVzFsVFdGNFRHVnVLU0I3WEc0Z0lDQWdJQ0IwYUdsekxtaHZjM1J1WVcxbElEMGdKeWM3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDOHZJR2h2YzNSdVlXMWxjeUJoY21VZ1lXeDNZWGx6SUd4dmQyVnlJR05oYzJVdVhHNGdJQ0FnSUNCMGFHbHpMbWh2YzNSdVlXMWxJRDBnZEdocGN5NW9iM04wYm1GdFpTNTBiMHh2ZDJWeVEyRnpaU2dwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNnaGFYQjJOa2h2YzNSdVlXMWxLU0I3WEc0Z0lDQWdJQ0F2THlCSlJFNUJJRk4xY0hCdmNuUTZJRkpsZEhWeWJuTWdZU0J3ZFc1NVkyOWtaV1FnY21Wd2NtVnpaVzUwWVhScGIyNGdiMllnWENKa2IyMWhhVzVjSWk1Y2JpQWdJQ0FnSUM4dklFbDBJRzl1YkhrZ1kyOXVkbVZ5ZEhNZ2NHRnlkSE1nYjJZZ2RHaGxJR1J2YldGcGJpQnVZVzFsSUhSb1lYUmNiaUFnSUNBZ0lDOHZJR2hoZG1VZ2JtOXVMVUZUUTBsSklHTm9ZWEpoWTNSbGNuTXNJR2t1WlM0Z2FYUWdaRzlsYzI0bmRDQnRZWFIwWlhJZ2FXWmNiaUFnSUNBZ0lDOHZJSGx2ZFNCallXeHNJR2wwSUhkcGRHZ2dZU0JrYjIxaGFXNGdkR2hoZENCaGJISmxZV1I1SUdseklFRlRRMGxKTFc5dWJIa3VYRzRnSUNBZ0lDQjBhR2x6TG1odmMzUnVZVzFsSUQwZ2NIVnVlV052WkdVdWRHOUJVME5KU1NoMGFHbHpMbWh2YzNSdVlXMWxLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQjJZWElnY0NBOUlIUm9hWE11Y0c5eWRDQS9JQ2M2SnlBcklIUm9hWE11Y0c5eWRDQTZJQ2NuTzF4dUlDQWdJSFpoY2lCb0lEMGdkR2hwY3k1b2IzTjBibUZ0WlNCOGZDQW5KenRjYmlBZ0lDQjBhR2x6TG1odmMzUWdQU0JvSUNzZ2NEdGNiaUFnSUNCMGFHbHpMbWh5WldZZ0t6MGdkR2hwY3k1b2IzTjBPMXh1WEc0Z0lDQWdMeThnYzNSeWFYQWdXeUJoYm1RZ1hTQm1jbTl0SUhSb1pTQm9iM04wYm1GdFpWeHVJQ0FnSUM4dklIUm9aU0JvYjNOMElHWnBaV3hrSUhOMGFXeHNJSEpsZEdGcGJuTWdkR2hsYlN3Z2RHaHZkV2RvWEc0Z0lDQWdhV1lnS0dsd2RqWkliM04wYm1GdFpTa2dlMXh1SUNBZ0lDQWdkR2hwY3k1b2IzTjBibUZ0WlNBOUlIUm9hWE11YUc5emRHNWhiV1V1YzNWaWMzUnlLREVzSUhSb2FYTXVhRzl6ZEc1aGJXVXViR1Z1WjNSb0lDMGdNaWs3WEc0Z0lDQWdJQ0JwWmlBb2NtVnpkRnN3WFNBaFBUMGdKeThuS1NCN1hHNGdJQ0FnSUNBZ0lISmxjM1FnUFNBbkx5Y2dLeUJ5WlhOME8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lDOHZJRzV2ZHlCeVpYTjBJR2x6SUhObGRDQjBieUIwYUdVZ2NHOXpkQzFvYjNOMElITjBkV1ptTGx4dUlDQXZMeUJqYUc5d0lHOW1aaUJoYm5rZ1pHVnNhVzBnWTJoaGNuTXVYRzRnSUdsbUlDZ2hkVzV6WVdabFVISnZkRzlqYjJ4YmJHOTNaWEpRY205MGIxMHBJSHRjYmx4dUlDQWdJQzh2SUVacGNuTjBMQ0J0WVd0bElERXdNQ1VnYzNWeVpTQjBhR0YwSUdGdWVTQmNJbUYxZEc5RmMyTmhjR1ZjSWlCamFHRnljeUJuWlhSY2JpQWdJQ0F2THlCbGMyTmhjR1ZrTENCbGRtVnVJR2xtSUdWdVkyOWtaVlZTU1VOdmJYQnZibVZ1ZENCa2IyVnpiaWQwSUhSb2FXNXJJSFJvWlhsY2JpQWdJQ0F2THlCdVpXVmtJSFJ2SUdKbExseHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdMQ0JzSUQwZ1lYVjBiMFZ6WTJGd1pTNXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQWdJSFpoY2lCaFpTQTlJR0YxZEc5RmMyTmhjR1ZiYVYwN1hHNGdJQ0FnSUNCcFppQW9jbVZ6ZEM1cGJtUmxlRTltS0dGbEtTQTlQVDBnTFRFcFhHNGdJQ0FnSUNBZ0lHTnZiblJwYm5WbE8xeHVJQ0FnSUNBZ2RtRnlJR1Z6WXlBOUlHVnVZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDaGhaU2s3WEc0Z0lDQWdJQ0JwWmlBb1pYTmpJRDA5UFNCaFpTa2dlMXh1SUNBZ0lDQWdJQ0JsYzJNZ1BTQmxjMk5oY0dVb1lXVXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdjbVZ6ZENBOUlISmxjM1F1YzNCc2FYUW9ZV1VwTG1wdmFXNG9aWE5qS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1WEc0Z0lDOHZJR05vYjNBZ2IyWm1JR1p5YjIwZ2RHaGxJSFJoYVd3Z1ptbHljM1F1WEc0Z0lIWmhjaUJvWVhOb0lEMGdjbVZ6ZEM1cGJtUmxlRTltS0Njakp5azdYRzRnSUdsbUlDaG9ZWE5vSUNFOVBTQXRNU2tnZTF4dUlDQWdJQzh2SUdkdmRDQmhJR1p5WVdkdFpXNTBJSE4wY21sdVp5NWNiaUFnSUNCMGFHbHpMbWhoYzJnZ1BTQnlaWE4wTG5OMVluTjBjaWhvWVhOb0tUdGNiaUFnSUNCeVpYTjBJRDBnY21WemRDNXpiR2xqWlNnd0xDQm9ZWE5vS1R0Y2JpQWdmVnh1SUNCMllYSWdjVzBnUFNCeVpYTjBMbWx1WkdWNFQyWW9KejhuS1R0Y2JpQWdhV1lnS0hGdElDRTlQU0F0TVNrZ2UxeHVJQ0FnSUhSb2FYTXVjMlZoY21Ob0lEMGdjbVZ6ZEM1emRXSnpkSElvY1cwcE8xeHVJQ0FnSUhSb2FYTXVjWFZsY25rZ1BTQnlaWE4wTG5OMVluTjBjaWh4YlNBcklERXBPMXh1SUNBZ0lHbG1JQ2h3WVhKelpWRjFaWEo1VTNSeWFXNW5LU0I3WEc0Z0lDQWdJQ0IwYUdsekxuRjFaWEo1SUQwZ2NYVmxjbmx6ZEhKcGJtY3VjR0Z5YzJVb2RHaHBjeTV4ZFdWeWVTazdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGMzUWdQU0J5WlhOMExuTnNhV05sS0RBc0lIRnRLVHRjYmlBZ2ZTQmxiSE5sSUdsbUlDaHdZWEp6WlZGMVpYSjVVM1J5YVc1bktTQjdYRzRnSUNBZ0x5OGdibThnY1hWbGNua2djM1J5YVc1bkxDQmlkWFFnY0dGeWMyVlJkV1Z5ZVZOMGNtbHVaeUJ6ZEdsc2JDQnlaWEYxWlhOMFpXUmNiaUFnSUNCMGFHbHpMbk5sWVhKamFDQTlJQ2NuTzF4dUlDQWdJSFJvYVhNdWNYVmxjbmtnUFNCN2ZUdGNiaUFnZlZ4dUlDQnBaaUFvY21WemRDa2dkR2hwY3k1d1lYUm9ibUZ0WlNBOUlISmxjM1E3WEc0Z0lHbG1JQ2h6YkdGemFHVmtVSEp2ZEc5amIyeGJiRzkzWlhKUWNtOTBiMTBnSmlaY2JpQWdJQ0FnSUhSb2FYTXVhRzl6ZEc1aGJXVWdKaVlnSVhSb2FYTXVjR0YwYUc1aGJXVXBJSHRjYmlBZ0lDQjBhR2x6TG5CaGRHaHVZVzFsSUQwZ0p5OG5PMXh1SUNCOVhHNWNiaUFnTHk5MGJ5QnpkWEJ3YjNKMElHaDBkSEF1Y21WeGRXVnpkRnh1SUNCcFppQW9kR2hwY3k1d1lYUm9ibUZ0WlNCOGZDQjBhR2x6TG5ObFlYSmphQ2tnZTF4dUlDQWdJSFpoY2lCd0lEMGdkR2hwY3k1d1lYUm9ibUZ0WlNCOGZDQW5KenRjYmlBZ0lDQjJZWElnY3lBOUlIUm9hWE11YzJWaGNtTm9JSHg4SUNjbk8xeHVJQ0FnSUhSb2FYTXVjR0YwYUNBOUlIQWdLeUJ6TzF4dUlDQjlYRzVjYmlBZ0x5OGdabWx1WVd4c2VTd2djbVZqYjI1emRISjFZM1FnZEdobElHaHlaV1lnWW1GelpXUWdiMjRnZDJoaGRDQm9ZWE1nWW1WbGJpQjJZV3hwWkdGMFpXUXVYRzRnSUhSb2FYTXVhSEpsWmlBOUlIUm9hWE11Wm05eWJXRjBLQ2s3WEc0Z0lISmxkSFZ5YmlCMGFHbHpPMXh1ZlR0Y2JseHVMeThnWm05eWJXRjBJR0VnY0dGeWMyVmtJRzlpYW1WamRDQnBiblJ2SUdFZ2RYSnNJSE4wY21sdVoxeHVablZ1WTNScGIyNGdkWEpzUm05eWJXRjBLRzlpYWlrZ2UxeHVJQ0F2THlCbGJuTjFjbVVnYVhRbmN5QmhiaUJ2WW1wbFkzUXNJR0Z1WkNCdWIzUWdZU0J6ZEhKcGJtY2dkWEpzTGx4dUlDQXZMeUJKWmlCcGRDZHpJR0Z1SUc5aWFpd2dkR2hwY3lCcGN5QmhJRzV2TFc5d0xseHVJQ0F2THlCMGFHbHpJSGRoZVN3Z2VXOTFJR05oYmlCallXeHNJSFZ5YkY5bWIzSnRZWFFvS1NCdmJpQnpkSEpwYm1kelhHNGdJQzh2SUhSdklHTnNaV0Z1SUhWd0lIQnZkR1Z1ZEdsaGJHeDVJSGR2Ym10NUlIVnliSE11WEc0Z0lHbG1JQ2gxZEdsc0xtbHpVM1J5YVc1bktHOWlhaWtwSUc5aWFpQTlJSFZ5YkZCaGNuTmxLRzlpYWlrN1hHNGdJR2xtSUNnaEtHOWlhaUJwYm5OMFlXNWpaVzltSUZWeWJDa3BJSEpsZEhWeWJpQlZjbXd1Y0hKdmRHOTBlWEJsTG1admNtMWhkQzVqWVd4c0tHOWlhaWs3WEc0Z0lISmxkSFZ5YmlCdlltb3VabTl5YldGMEtDazdYRzU5WEc1Y2JsVnliQzV3Y205MGIzUjVjR1V1Wm05eWJXRjBJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJSFpoY2lCaGRYUm9JRDBnZEdocGN5NWhkWFJvSUh4OElDY25PMXh1SUNCcFppQW9ZWFYwYUNrZ2UxeHVJQ0FnSUdGMWRHZ2dQU0JsYm1OdlpHVlZVa2xEYjIxd2IyNWxiblFvWVhWMGFDazdYRzRnSUNBZ1lYVjBhQ0E5SUdGMWRHZ3VjbVZ3YkdGalpTZ3ZKVE5CTDJrc0lDYzZKeWs3WEc0Z0lDQWdZWFYwYUNBclBTQW5RQ2M3WEc0Z0lIMWNibHh1SUNCMllYSWdjSEp2ZEc5amIyd2dQU0IwYUdsekxuQnliM1J2WTI5c0lIeDhJQ2NuTEZ4dUlDQWdJQ0FnY0dGMGFHNWhiV1VnUFNCMGFHbHpMbkJoZEdodVlXMWxJSHg4SUNjbkxGeHVJQ0FnSUNBZ2FHRnphQ0E5SUhSb2FYTXVhR0Z6YUNCOGZDQW5KeXhjYmlBZ0lDQWdJR2h2YzNRZ1BTQm1ZV3h6WlN4Y2JpQWdJQ0FnSUhGMVpYSjVJRDBnSnljN1hHNWNiaUFnYVdZZ0tIUm9hWE11YUc5emRDa2dlMXh1SUNBZ0lHaHZjM1FnUFNCaGRYUm9JQ3NnZEdocGN5NW9iM04wTzF4dUlDQjlJR1ZzYzJVZ2FXWWdLSFJvYVhNdWFHOXpkRzVoYldVcElIdGNiaUFnSUNCb2IzTjBJRDBnWVhWMGFDQXJJQ2gwYUdsekxtaHZjM1J1WVcxbExtbHVaR1Y0VDJZb0p6b25LU0E5UFQwZ0xURWdQMXh1SUNBZ0lDQWdJQ0IwYUdsekxtaHZjM1J1WVcxbElEcGNiaUFnSUNBZ0lDQWdKMXNuSUNzZ2RHaHBjeTVvYjNOMGJtRnRaU0FySUNkZEp5azdYRzRnSUNBZ2FXWWdLSFJvYVhNdWNHOXlkQ2tnZTF4dUlDQWdJQ0FnYUc5emRDQXJQU0FuT2ljZ0t5QjBhR2x6TG5CdmNuUTdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdhV1lnS0hSb2FYTXVjWFZsY25rZ0ppWmNiaUFnSUNBZ0lIVjBhV3d1YVhOUFltcGxZM1FvZEdocGN5NXhkV1Z5ZVNrZ0ppWmNiaUFnSUNBZ0lFOWlhbVZqZEM1clpYbHpLSFJvYVhNdWNYVmxjbmtwTG14bGJtZDBhQ2tnZTF4dUlDQWdJSEYxWlhKNUlEMGdjWFZsY25semRISnBibWN1YzNSeWFXNW5hV1o1S0hSb2FYTXVjWFZsY25rcE8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhObFlYSmphQ0E5SUhSb2FYTXVjMlZoY21Ob0lIeDhJQ2h4ZFdWeWVTQW1KaUFvSno4bklDc2djWFZsY25rcEtTQjhmQ0FuSnp0Y2JseHVJQ0JwWmlBb2NISnZkRzlqYjJ3Z0ppWWdjSEp2ZEc5amIyd3VjM1ZpYzNSeUtDMHhLU0FoUFQwZ0p6b25LU0J3Y205MGIyTnZiQ0FyUFNBbk9pYzdYRzVjYmlBZ0x5OGdiMjVzZVNCMGFHVWdjMnhoYzJobFpGQnliM1J2WTI5c2N5Qm5aWFFnZEdobElDOHZMaUFnVG05MElHMWhhV3gwYnpvc0lIaHRjSEE2TENCbGRHTXVYRzRnSUM4dklIVnViR1Z6Y3lCMGFHVjVJR2hoWkNCMGFHVnRJSFJ2SUdKbFoybHVJSGRwZEdndVhHNGdJR2xtSUNoMGFHbHpMbk5zWVhOb1pYTWdmSHhjYmlBZ0lDQWdJQ2doY0hKdmRHOWpiMndnZkh3Z2MyeGhjMmhsWkZCeWIzUnZZMjlzVzNCeWIzUnZZMjlzWFNrZ0ppWWdhRzl6ZENBaFBUMGdabUZzYzJVcElIdGNiaUFnSUNCb2IzTjBJRDBnSnk4dkp5QXJJQ2hvYjNOMElIeDhJQ2NuS1R0Y2JpQWdJQ0JwWmlBb2NHRjBhRzVoYldVZ0ppWWdjR0YwYUc1aGJXVXVZMmhoY2tGMEtEQXBJQ0U5UFNBbkx5Y3BJSEJoZEdodVlXMWxJRDBnSnk4bklDc2djR0YwYUc1aGJXVTdYRzRnSUgwZ1pXeHpaU0JwWmlBb0lXaHZjM1FwSUh0Y2JpQWdJQ0JvYjNOMElEMGdKeWM3WEc0Z0lIMWNibHh1SUNCcFppQW9hR0Z6YUNBbUppQm9ZWE5vTG1Ob1lYSkJkQ2d3S1NBaFBUMGdKeU1uS1NCb1lYTm9JRDBnSnlNbklDc2dhR0Z6YUR0Y2JpQWdhV1lnS0hObFlYSmphQ0FtSmlCelpXRnlZMmd1WTJoaGNrRjBLREFwSUNFOVBTQW5QeWNwSUhObFlYSmphQ0E5SUNjL0p5QXJJSE5sWVhKamFEdGNibHh1SUNCd1lYUm9ibUZ0WlNBOUlIQmhkR2h1WVcxbExuSmxjR3hoWTJVb0wxcy9JMTB2Wnl3Z1puVnVZM1JwYjI0b2JXRjBZMmdwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdaVzVqYjJSbFZWSkpRMjl0Y0c5dVpXNTBLRzFoZEdOb0tUdGNiaUFnZlNrN1hHNGdJSE5sWVhKamFDQTlJSE5sWVhKamFDNXlaWEJzWVdObEtDY2pKeXdnSnlVeU15Y3BPMXh1WEc0Z0lISmxkSFZ5YmlCd2NtOTBiMk52YkNBcklHaHZjM1FnS3lCd1lYUm9ibUZ0WlNBcklITmxZWEpqYUNBcklHaGhjMmc3WEc1OU8xeHVYRzVtZFc1amRHbHZiaUIxY214U1pYTnZiSFpsS0hOdmRYSmpaU3dnY21Wc1lYUnBkbVVwSUh0Y2JpQWdjbVYwZFhKdUlIVnliRkJoY25ObEtITnZkWEpqWlN3Z1ptRnNjMlVzSUhSeWRXVXBMbkpsYzI5c2RtVW9jbVZzWVhScGRtVXBPMXh1ZlZ4dVhHNVZjbXd1Y0hKdmRHOTBlWEJsTG5KbGMyOXNkbVVnUFNCbWRXNWpkR2x2YmloeVpXeGhkR2wyWlNrZ2UxeHVJQ0J5WlhSMWNtNGdkR2hwY3k1eVpYTnZiSFpsVDJKcVpXTjBLSFZ5YkZCaGNuTmxLSEpsYkdGMGFYWmxMQ0JtWVd4elpTd2dkSEoxWlNrcExtWnZjbTFoZENncE8xeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z2RYSnNVbVZ6YjJ4MlpVOWlhbVZqZENoemIzVnlZMlVzSUhKbGJHRjBhWFpsS1NCN1hHNGdJR2xtSUNnaGMyOTFjbU5sS1NCeVpYUjFjbTRnY21Wc1lYUnBkbVU3WEc0Z0lISmxkSFZ5YmlCMWNteFFZWEp6WlNoemIzVnlZMlVzSUdaaGJITmxMQ0IwY25WbEtTNXlaWE52YkhabFQySnFaV04wS0hKbGJHRjBhWFpsS1R0Y2JuMWNibHh1VlhKc0xuQnliM1J2ZEhsd1pTNXlaWE52YkhabFQySnFaV04wSUQwZ1puVnVZM1JwYjI0b2NtVnNZWFJwZG1VcElIdGNiaUFnYVdZZ0tIVjBhV3d1YVhOVGRISnBibWNvY21Wc1lYUnBkbVVwS1NCN1hHNGdJQ0FnZG1GeUlISmxiQ0E5SUc1bGR5QlZjbXdvS1R0Y2JpQWdJQ0J5Wld3dWNHRnljMlVvY21Wc1lYUnBkbVVzSUdaaGJITmxMQ0IwY25WbEtUdGNiaUFnSUNCeVpXeGhkR2wyWlNBOUlISmxiRHRjYmlBZ2ZWeHVYRzRnSUhaaGNpQnlaWE4xYkhRZ1BTQnVaWGNnVlhKc0tDazdYRzRnSUhaaGNpQjBhMlY1Y3lBOUlFOWlhbVZqZEM1clpYbHpLSFJvYVhNcE8xeHVJQ0JtYjNJZ0tIWmhjaUIwYXlBOUlEQTdJSFJySUR3Z2RHdGxlWE11YkdWdVozUm9PeUIwYXlzcktTQjdYRzRnSUNBZ2RtRnlJSFJyWlhrZ1BTQjBhMlY1YzF0MGExMDdYRzRnSUNBZ2NtVnpkV3gwVzNSclpYbGRJRDBnZEdocGMxdDBhMlY1WFR0Y2JpQWdmVnh1WEc0Z0lDOHZJR2hoYzJnZ2FYTWdZV3gzWVhseklHOTJaWEp5YVdSa1pXNHNJRzV2SUcxaGRIUmxjaUIzYUdGMExseHVJQ0F2THlCbGRtVnVJR2h5WldZOVhDSmNJaUIzYVd4c0lISmxiVzkyWlNCcGRDNWNiaUFnY21WemRXeDBMbWhoYzJnZ1BTQnlaV3hoZEdsMlpTNW9ZWE5vTzF4dVhHNGdJQzh2SUdsbUlIUm9aU0J5Wld4aGRHbDJaU0IxY213Z2FYTWdaVzF3ZEhrc0lIUm9aVzRnZEdobGNtVW5jeUJ1YjNSb2FXNW5JR3hsWm5RZ2RHOGdaRzhnYUdWeVpTNWNiaUFnYVdZZ0tISmxiR0YwYVhabExtaHlaV1lnUFQwOUlDY25LU0I3WEc0Z0lDQWdjbVZ6ZFd4MExtaHlaV1lnUFNCeVpYTjFiSFF1Wm05eWJXRjBLQ2s3WEc0Z0lDQWdjbVYwZFhKdUlISmxjM1ZzZER0Y2JpQWdmVnh1WEc0Z0lDOHZJR2h5WldaeklHeHBhMlVnTHk5bWIyOHZZbUZ5SUdGc2QyRjVjeUJqZFhRZ2RHOGdkR2hsSUhCeWIzUnZZMjlzTGx4dUlDQnBaaUFvY21Wc1lYUnBkbVV1YzJ4aGMyaGxjeUFtSmlBaGNtVnNZWFJwZG1VdWNISnZkRzlqYjJ3cElIdGNiaUFnSUNBdkx5QjBZV3RsSUdWMlpYSjVkR2hwYm1jZ1pYaGpaWEIwSUhSb1pTQndjbTkwYjJOdmJDQm1jbTl0SUhKbGJHRjBhWFpsWEc0Z0lDQWdkbUZ5SUhKclpYbHpJRDBnVDJKcVpXTjBMbXRsZVhNb2NtVnNZWFJwZG1VcE8xeHVJQ0FnSUdadmNpQW9kbUZ5SUhKcklEMGdNRHNnY21zZ1BDQnlhMlY1Y3k1c1pXNW5kR2c3SUhKckt5c3BJSHRjYmlBZ0lDQWdJSFpoY2lCeWEyVjVJRDBnY210bGVYTmJjbXRkTzF4dUlDQWdJQ0FnYVdZZ0tISnJaWGtnSVQwOUlDZHdjbTkwYjJOdmJDY3BYRzRnSUNBZ0lDQWdJSEpsYzNWc2RGdHlhMlY1WFNBOUlISmxiR0YwYVhabFczSnJaWGxkTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2ZFhKc1VHRnljMlVnWVhCd1pXNWtjeUIwY21GcGJHbHVaeUF2SUhSdklIVnliSE1nYkdsclpTQm9kSFJ3T2k4dmQzZDNMbVY0WVcxd2JHVXVZMjl0WEc0Z0lDQWdhV1lnS0hOc1lYTm9aV1JRY205MGIyTnZiRnR5WlhOMWJIUXVjSEp2ZEc5amIyeGRJQ1ltWEc0Z0lDQWdJQ0FnSUhKbGMzVnNkQzVvYjNOMGJtRnRaU0FtSmlBaGNtVnpkV3gwTG5CaGRHaHVZVzFsS1NCN1hHNGdJQ0FnSUNCeVpYTjFiSFF1Y0dGMGFDQTlJSEpsYzNWc2RDNXdZWFJvYm1GdFpTQTlJQ2N2Snp0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhOMWJIUXVhSEpsWmlBOUlISmxjM1ZzZEM1bWIzSnRZWFFvS1R0Y2JpQWdJQ0J5WlhSMWNtNGdjbVZ6ZFd4ME8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0hKbGJHRjBhWFpsTG5CeWIzUnZZMjlzSUNZbUlISmxiR0YwYVhabExuQnliM1J2WTI5c0lDRTlQU0J5WlhOMWJIUXVjSEp2ZEc5amIyd3BJSHRjYmlBZ0lDQXZMeUJwWmlCcGRDZHpJR0VnYTI1dmQyNGdkWEpzSUhCeWIzUnZZMjlzTENCMGFHVnVJR05vWVc1bmFXNW5YRzRnSUNBZ0x5OGdkR2hsSUhCeWIzUnZZMjlzSUdSdlpYTWdkMlZwY21RZ2RHaHBibWR6WEc0Z0lDQWdMeThnWm1seWMzUXNJR2xtSUdsMEozTWdibTkwSUdacGJHVTZMQ0IwYUdWdUlIZGxJRTFWVTFRZ2FHRjJaU0JoSUdodmMzUXNYRzRnSUNBZ0x5OGdZVzVrSUdsbUlIUm9aWEpsSUhkaGN5QmhJSEJoZEdoY2JpQWdJQ0F2THlCMGJ5QmlaV2RwYmlCM2FYUm9MQ0IwYUdWdUlIZGxJRTFWVTFRZ2FHRjJaU0JoSUhCaGRHZ3VYRzRnSUNBZ0x5OGdhV1lnYVhRZ2FYTWdabWxzWlRvc0lIUm9aVzRnZEdobElHaHZjM1FnYVhNZ1pISnZjSEJsWkN4Y2JpQWdJQ0F2THlCaVpXTmhkWE5sSUhSb1lYUW5jeUJyYm05M2JpQjBieUJpWlNCb2IzTjBiR1Z6Y3k1Y2JpQWdJQ0F2THlCaGJubDBhR2x1WnlCbGJITmxJR2x6SUdGemMzVnRaV1FnZEc4Z1ltVWdZV0p6YjJ4MWRHVXVYRzRnSUNBZ2FXWWdLQ0Z6YkdGemFHVmtVSEp2ZEc5amIyeGJjbVZzWVhScGRtVXVjSEp2ZEc5amIyeGRLU0I3WEc0Z0lDQWdJQ0IyWVhJZ2EyVjVjeUE5SUU5aWFtVmpkQzVyWlhsektISmxiR0YwYVhabEtUdGNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlIWWdQU0F3T3lCMklEd2dhMlY1Y3k1c1pXNW5kR2c3SUhZckt5a2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2F5QTlJR3RsZVhOYmRsMDdYRzRnSUNBZ0lDQWdJSEpsYzNWc2RGdHJYU0E5SUhKbGJHRjBhWFpsVzJ0ZE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVnpkV3gwTG1oeVpXWWdQU0J5WlhOMWJIUXVabTl5YldGMEtDazdYRzRnSUNBZ0lDQnlaWFIxY200Z2NtVnpkV3gwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEpsYzNWc2RDNXdjbTkwYjJOdmJDQTlJSEpsYkdGMGFYWmxMbkJ5YjNSdlkyOXNPMXh1SUNBZ0lHbG1JQ2doY21Wc1lYUnBkbVV1YUc5emRDQW1KaUFoYUc5emRHeGxjM05RY205MGIyTnZiRnR5Wld4aGRHbDJaUzV3Y205MGIyTnZiRjBwSUh0Y2JpQWdJQ0FnSUhaaGNpQnlaV3hRWVhSb0lEMGdLSEpsYkdGMGFYWmxMbkJoZEdodVlXMWxJSHg4SUNjbktTNXpjR3hwZENnbkx5Y3BPMXh1SUNBZ0lDQWdkMmhwYkdVZ0tISmxiRkJoZEdndWJHVnVaM1JvSUNZbUlDRW9jbVZzWVhScGRtVXVhRzl6ZENBOUlISmxiRkJoZEdndWMyaHBablFvS1NrcE8xeHVJQ0FnSUNBZ2FXWWdLQ0Z5Wld4aGRHbDJaUzVvYjNOMEtTQnlaV3hoZEdsMlpTNW9iM04wSUQwZ0p5YzdYRzRnSUNBZ0lDQnBaaUFvSVhKbGJHRjBhWFpsTG1odmMzUnVZVzFsS1NCeVpXeGhkR2wyWlM1b2IzTjBibUZ0WlNBOUlDY25PMXh1SUNBZ0lDQWdhV1lnS0hKbGJGQmhkR2hiTUYwZ0lUMDlJQ2NuS1NCeVpXeFFZWFJvTG5WdWMyaHBablFvSnljcE8xeHVJQ0FnSUNBZ2FXWWdLSEpsYkZCaGRHZ3ViR1Z1WjNSb0lEd2dNaWtnY21Wc1VHRjBhQzUxYm5Ob2FXWjBLQ2NuS1R0Y2JpQWdJQ0FnSUhKbGMzVnNkQzV3WVhSb2JtRnRaU0E5SUhKbGJGQmhkR2d1YW05cGJpZ25MeWNwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWE4xYkhRdWNHRjBhRzVoYldVZ1BTQnlaV3hoZEdsMlpTNXdZWFJvYm1GdFpUdGNiaUFnSUNCOVhHNGdJQ0FnY21WemRXeDBMbk5sWVhKamFDQTlJSEpsYkdGMGFYWmxMbk5sWVhKamFEdGNiaUFnSUNCeVpYTjFiSFF1Y1hWbGNua2dQU0J5Wld4aGRHbDJaUzV4ZFdWeWVUdGNiaUFnSUNCeVpYTjFiSFF1YUc5emRDQTlJSEpsYkdGMGFYWmxMbWh2YzNRZ2ZId2dKeWM3WEc0Z0lDQWdjbVZ6ZFd4MExtRjFkR2dnUFNCeVpXeGhkR2wyWlM1aGRYUm9PMXh1SUNBZ0lISmxjM1ZzZEM1b2IzTjBibUZ0WlNBOUlISmxiR0YwYVhabExtaHZjM1J1WVcxbElIeDhJSEpsYkdGMGFYWmxMbWh2YzNRN1hHNGdJQ0FnY21WemRXeDBMbkJ2Y25RZ1BTQnlaV3hoZEdsMlpTNXdiM0owTzF4dUlDQWdJQzh2SUhSdklITjFjSEJ2Y25RZ2FIUjBjQzV5WlhGMVpYTjBYRzRnSUNBZ2FXWWdLSEpsYzNWc2RDNXdZWFJvYm1GdFpTQjhmQ0J5WlhOMWJIUXVjMlZoY21Ob0tTQjdYRzRnSUNBZ0lDQjJZWElnY0NBOUlISmxjM1ZzZEM1d1lYUm9ibUZ0WlNCOGZDQW5KenRjYmlBZ0lDQWdJSFpoY2lCeklEMGdjbVZ6ZFd4MExuTmxZWEpqYUNCOGZDQW5KenRjYmlBZ0lDQWdJSEpsYzNWc2RDNXdZWFJvSUQwZ2NDQXJJSE03WEc0Z0lDQWdmVnh1SUNBZ0lISmxjM1ZzZEM1emJHRnphR1Z6SUQwZ2NtVnpkV3gwTG5Oc1lYTm9aWE1nZkh3Z2NtVnNZWFJwZG1VdWMyeGhjMmhsY3p0Y2JpQWdJQ0J5WlhOMWJIUXVhSEpsWmlBOUlISmxjM1ZzZEM1bWIzSnRZWFFvS1R0Y2JpQWdJQ0J5WlhSMWNtNGdjbVZ6ZFd4ME8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUdselUyOTFjbU5sUVdKeklEMGdLSEpsYzNWc2RDNXdZWFJvYm1GdFpTQW1KaUJ5WlhOMWJIUXVjR0YwYUc1aGJXVXVZMmhoY2tGMEtEQXBJRDA5UFNBbkx5Y3BMRnh1SUNBZ0lDQWdhWE5TWld4QlluTWdQU0FvWEc0Z0lDQWdJQ0FnSUNBZ2NtVnNZWFJwZG1VdWFHOXpkQ0I4ZkZ4dUlDQWdJQ0FnSUNBZ0lISmxiR0YwYVhabExuQmhkR2h1WVcxbElDWW1JSEpsYkdGMGFYWmxMbkJoZEdodVlXMWxMbU5vWVhKQmRDZ3dLU0E5UFQwZ0p5OG5YRzRnSUNBZ0lDQXBMRnh1SUNBZ0lDQWdiWFZ6ZEVWdVpFRmljeUE5SUNocGMxSmxiRUZpY3lCOGZDQnBjMU52ZFhKalpVRmljeUI4ZkZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQW9jbVZ6ZFd4MExtaHZjM1FnSmlZZ2NtVnNZWFJwZG1VdWNHRjBhRzVoYldVcEtTeGNiaUFnSUNBZ0lISmxiVzkyWlVGc2JFUnZkSE1nUFNCdGRYTjBSVzVrUVdKekxGeHVJQ0FnSUNBZ2MzSmpVR0YwYUNBOUlISmxjM1ZzZEM1d1lYUm9ibUZ0WlNBbUppQnlaWE4xYkhRdWNHRjBhRzVoYldVdWMzQnNhWFFvSnk4bktTQjhmQ0JiWFN4Y2JpQWdJQ0FnSUhKbGJGQmhkR2dnUFNCeVpXeGhkR2wyWlM1d1lYUm9ibUZ0WlNBbUppQnlaV3hoZEdsMlpTNXdZWFJvYm1GdFpTNXpjR3hwZENnbkx5Y3BJSHg4SUZ0ZExGeHVJQ0FnSUNBZ2NITjVZMmh2ZEdsaklEMGdjbVZ6ZFd4MExuQnliM1J2WTI5c0lDWW1JQ0Z6YkdGemFHVmtVSEp2ZEc5amIyeGJjbVZ6ZFd4MExuQnliM1J2WTI5c1hUdGNibHh1SUNBdkx5QnBaaUIwYUdVZ2RYSnNJR2x6SUdFZ2JtOXVMWE5zWVhOb1pXUWdkWEpzTENCMGFHVnVJSEpsYkdGMGFYWmxYRzRnSUM4dklHeHBibXR6SUd4cGEyVWdMaTR2TGk0Z2MyaHZkV3hrSUdKbElHRmliR1ZjYmlBZ0x5OGdkRzhnWTNKaGQyd2dkWEFnZEc4Z2RHaGxJR2h2YzNSdVlXMWxMQ0JoY3lCM1pXeHNMaUFnVkdocGN5QnBjeUJ6ZEhKaGJtZGxMbHh1SUNBdkx5QnlaWE4xYkhRdWNISnZkRzlqYjJ3Z2FHRnpJR0ZzY21WaFpIa2dZbVZsYmlCelpYUWdZbmtnYm05M0xseHVJQ0F2THlCTVlYUmxjaUJ2Yml3Z2NIVjBJSFJvWlNCbWFYSnpkQ0J3WVhSb0lIQmhjblFnYVc1MGJ5QjBhR1VnYUc5emRDQm1hV1ZzWkM1Y2JpQWdhV1lnS0hCemVXTm9iM1JwWXlrZ2UxeHVJQ0FnSUhKbGMzVnNkQzVvYjNOMGJtRnRaU0E5SUNjbk8xeHVJQ0FnSUhKbGMzVnNkQzV3YjNKMElEMGdiblZzYkR0Y2JpQWdJQ0JwWmlBb2NtVnpkV3gwTG1odmMzUXBJSHRjYmlBZ0lDQWdJR2xtSUNoemNtTlFZWFJvV3pCZElEMDlQU0FuSnlrZ2MzSmpVR0YwYUZzd1hTQTlJSEpsYzNWc2RDNW9iM04wTzF4dUlDQWdJQ0FnWld4elpTQnpjbU5RWVhSb0xuVnVjMmhwWm5Rb2NtVnpkV3gwTG1odmMzUXBPMXh1SUNBZ0lIMWNiaUFnSUNCeVpYTjFiSFF1YUc5emRDQTlJQ2NuTzF4dUlDQWdJR2xtSUNoeVpXeGhkR2wyWlM1d2NtOTBiMk52YkNrZ2UxeHVJQ0FnSUNBZ2NtVnNZWFJwZG1VdWFHOXpkRzVoYldVZ1BTQnVkV3hzTzF4dUlDQWdJQ0FnY21Wc1lYUnBkbVV1Y0c5eWRDQTlJRzUxYkd3N1hHNGdJQ0FnSUNCcFppQW9jbVZzWVhScGRtVXVhRzl6ZENrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvY21Wc1VHRjBhRnN3WFNBOVBUMGdKeWNwSUhKbGJGQmhkR2hiTUYwZ1BTQnlaV3hoZEdsMlpTNW9iM04wTzF4dUlDQWdJQ0FnSUNCbGJITmxJSEpsYkZCaGRHZ3VkVzV6YUdsbWRDaHlaV3hoZEdsMlpTNW9iM04wS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUhKbGJHRjBhWFpsTG1odmMzUWdQU0J1ZFd4c08xeHVJQ0FnSUgxY2JpQWdJQ0J0ZFhOMFJXNWtRV0p6SUQwZ2JYVnpkRVZ1WkVGaWN5QW1KaUFvY21Wc1VHRjBhRnN3WFNBOVBUMGdKeWNnZkh3Z2MzSmpVR0YwYUZzd1hTQTlQVDBnSnljcE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0dselVtVnNRV0p6S1NCN1hHNGdJQ0FnTHk4Z2FYUW5jeUJoWW5OdmJIVjBaUzVjYmlBZ0lDQnlaWE4xYkhRdWFHOXpkQ0E5SUNoeVpXeGhkR2wyWlM1b2IzTjBJSHg4SUhKbGJHRjBhWFpsTG1odmMzUWdQVDA5SUNjbktTQS9YRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5Wld4aGRHbDJaUzVvYjNOMElEb2djbVZ6ZFd4MExtaHZjM1E3WEc0Z0lDQWdjbVZ6ZFd4MExtaHZjM1J1WVcxbElEMGdLSEpsYkdGMGFYWmxMbWh2YzNSdVlXMWxJSHg4SUhKbGJHRjBhWFpsTG1odmMzUnVZVzFsSUQwOVBTQW5KeWtnUDF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsYkdGMGFYWmxMbWh2YzNSdVlXMWxJRG9nY21WemRXeDBMbWh2YzNSdVlXMWxPMXh1SUNBZ0lISmxjM1ZzZEM1elpXRnlZMmdnUFNCeVpXeGhkR2wyWlM1elpXRnlZMmc3WEc0Z0lDQWdjbVZ6ZFd4MExuRjFaWEo1SUQwZ2NtVnNZWFJwZG1VdWNYVmxjbms3WEc0Z0lDQWdjM0pqVUdGMGFDQTlJSEpsYkZCaGRHZzdYRzRnSUNBZ0x5OGdabUZzYkNCMGFISnZkV2RvSUhSdklIUm9aU0JrYjNRdGFHRnVaR3hwYm1jZ1ltVnNiM2N1WEc0Z0lIMGdaV3h6WlNCcFppQW9jbVZzVUdGMGFDNXNaVzVuZEdncElIdGNiaUFnSUNBdkx5QnBkQ2R6SUhKbGJHRjBhWFpsWEc0Z0lDQWdMeThnZEdoeWIzY2dZWGRoZVNCMGFHVWdaWGhwYzNScGJtY2dabWxzWlN3Z1lXNWtJSFJoYTJVZ2RHaGxJRzVsZHlCd1lYUm9JR2x1YzNSbFlXUXVYRzRnSUNBZ2FXWWdLQ0Z6Y21OUVlYUm9LU0J6Y21OUVlYUm9JRDBnVzEwN1hHNGdJQ0FnYzNKalVHRjBhQzV3YjNBb0tUdGNiaUFnSUNCemNtTlFZWFJvSUQwZ2MzSmpVR0YwYUM1amIyNWpZWFFvY21Wc1VHRjBhQ2s3WEc0Z0lDQWdjbVZ6ZFd4MExuTmxZWEpqYUNBOUlISmxiR0YwYVhabExuTmxZWEpqYUR0Y2JpQWdJQ0J5WlhOMWJIUXVjWFZsY25rZ1BTQnlaV3hoZEdsMlpTNXhkV1Z5ZVR0Y2JpQWdmU0JsYkhObElHbG1JQ2doZFhScGJDNXBjMDUxYkd4UGNsVnVaR1ZtYVc1bFpDaHlaV3hoZEdsMlpTNXpaV0Z5WTJncEtTQjdYRzRnSUNBZ0x5OGdhblZ6ZENCd2RXeHNJRzkxZENCMGFHVWdjMlZoY21Ob0xseHVJQ0FnSUM4dklHeHBhMlVnYUhKbFpqMG5QMlp2YnljdVhHNGdJQ0FnTHk4Z1VIVjBJSFJvYVhNZ1lXWjBaWElnZEdobElHOTBhR1Z5SUhSM2J5QmpZWE5sY3lCaVpXTmhkWE5sSUdsMElITnBiWEJzYVdacFpYTWdkR2hsSUdKdmIyeGxZVzV6WEc0Z0lDQWdhV1lnS0hCemVXTm9iM1JwWXlrZ2UxeHVJQ0FnSUNBZ2NtVnpkV3gwTG1odmMzUnVZVzFsSUQwZ2NtVnpkV3gwTG1odmMzUWdQU0J6Y21OUVlYUm9Mbk5vYVdaMEtDazdYRzRnSUNBZ0lDQXZMMjlqWTJGMGFXOXVZV3g1SUhSb1pTQmhkWFJvSUdOaGJpQm5aWFFnYzNSMVkyc2diMjVzZVNCcGJpQm9iM04wWEc0Z0lDQWdJQ0F2TDNSb2FYTWdaWE53WldOcFlXeHNlU0JvWVhCd1pXNXpJR2x1SUdOaGMyVnpJR3hwYTJWY2JpQWdJQ0FnSUM4dmRYSnNMbkpsYzI5c2RtVlBZbXBsWTNRb0oyMWhhV3gwYnpwc2IyTmhiREZBWkc5dFlXbHVNU2NzSUNkc2IyTmhiREpBWkc5dFlXbHVNaWNwWEc0Z0lDQWdJQ0IyWVhJZ1lYVjBhRWx1U0c5emRDQTlJSEpsYzNWc2RDNW9iM04wSUNZbUlISmxjM1ZzZEM1b2IzTjBMbWx1WkdWNFQyWW9KMEFuS1NBK0lEQWdQMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRdWFHOXpkQzV6Y0d4cGRDZ25RQ2NwSURvZ1ptRnNjMlU3WEc0Z0lDQWdJQ0JwWmlBb1lYVjBhRWx1U0c5emRDa2dlMXh1SUNBZ0lDQWdJQ0J5WlhOMWJIUXVZWFYwYUNBOUlHRjFkR2hKYmtodmMzUXVjMmhwWm5Rb0tUdGNiaUFnSUNBZ0lDQWdjbVZ6ZFd4MExtaHZjM1FnUFNCeVpYTjFiSFF1YUc5emRHNWhiV1VnUFNCaGRYUm9TVzVJYjNOMExuTm9hV1owS0NrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQWdJSEpsYzNWc2RDNXpaV0Z5WTJnZ1BTQnlaV3hoZEdsMlpTNXpaV0Z5WTJnN1hHNGdJQ0FnY21WemRXeDBMbkYxWlhKNUlEMGdjbVZzWVhScGRtVXVjWFZsY25rN1hHNGdJQ0FnTHk5MGJ5QnpkWEJ3YjNKMElHaDBkSEF1Y21WeGRXVnpkRnh1SUNBZ0lHbG1JQ2doZFhScGJDNXBjMDUxYkd3b2NtVnpkV3gwTG5CaGRHaHVZVzFsS1NCOGZDQWhkWFJwYkM1cGMwNTFiR3dvY21WemRXeDBMbk5sWVhKamFDa3BJSHRjYmlBZ0lDQWdJSEpsYzNWc2RDNXdZWFJvSUQwZ0tISmxjM1ZzZEM1d1lYUm9ibUZ0WlNBL0lISmxjM1ZzZEM1d1lYUm9ibUZ0WlNBNklDY25LU0FyWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDaHlaWE4xYkhRdWMyVmhjbU5vSUQ4Z2NtVnpkV3gwTG5ObFlYSmphQ0E2SUNjbktUdGNiaUFnSUNCOVhHNGdJQ0FnY21WemRXeDBMbWh5WldZZ1BTQnlaWE4xYkhRdVptOXliV0YwS0NrN1hHNGdJQ0FnY21WMGRYSnVJSEpsYzNWc2REdGNiaUFnZlZ4dVhHNGdJR2xtSUNnaGMzSmpVR0YwYUM1c1pXNW5kR2dwSUh0Y2JpQWdJQ0F2THlCdWJ5QndZWFJvSUdGMElHRnNiQzRnSUdWaGMza3VYRzRnSUNBZ0x5OGdkMlVuZG1VZ1lXeHlaV0ZrZVNCb1lXNWtiR1ZrSUhSb1pTQnZkR2hsY2lCemRIVm1aaUJoWW05MlpTNWNiaUFnSUNCeVpYTjFiSFF1Y0dGMGFHNWhiV1VnUFNCdWRXeHNPMXh1SUNBZ0lDOHZkRzhnYzNWd2NHOXlkQ0JvZEhSd0xuSmxjWFZsYzNSY2JpQWdJQ0JwWmlBb2NtVnpkV3gwTG5ObFlYSmphQ2tnZTF4dUlDQWdJQ0FnY21WemRXeDBMbkJoZEdnZ1BTQW5MeWNnS3lCeVpYTjFiSFF1YzJWaGNtTm9PMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCeVpYTjFiSFF1Y0dGMGFDQTlJRzUxYkd3N1hHNGdJQ0FnZlZ4dUlDQWdJSEpsYzNWc2RDNW9jbVZtSUQwZ2NtVnpkV3gwTG1admNtMWhkQ2dwTzF4dUlDQWdJSEpsZEhWeWJpQnlaWE4xYkhRN1hHNGdJSDFjYmx4dUlDQXZMeUJwWmlCaElIVnliQ0JGVGtSeklHbHVJQzRnYjNJZ0xpNHNJSFJvWlc0Z2FYUWdiWFZ6ZENCblpYUWdZU0IwY21GcGJHbHVaeUJ6YkdGemFDNWNiaUFnTHk4Z2FHOTNaWFpsY2l3Z2FXWWdhWFFnWlc1a2N5QnBiaUJoYm5sMGFHbHVaeUJsYkhObElHNXZiaTF6YkdGemFIa3NYRzRnSUM4dklIUm9aVzRnYVhRZ2JYVnpkQ0JPVDFRZ1oyVjBJR0VnZEhKaGFXeHBibWNnYzJ4aGMyZ3VYRzRnSUhaaGNpQnNZWE4wSUQwZ2MzSmpVR0YwYUM1emJHbGpaU2d0TVNsYk1GMDdYRzRnSUhaaGNpQm9ZWE5VY21GcGJHbHVaMU5zWVhOb0lEMGdLRnh1SUNBZ0lDQWdLSEpsYzNWc2RDNW9iM04wSUh4OElISmxiR0YwYVhabExtaHZjM1FnZkh3Z2MzSmpVR0YwYUM1c1pXNW5kR2dnUGlBeEtTQW1KbHh1SUNBZ0lDQWdLR3hoYzNRZ1BUMDlJQ2N1SnlCOGZDQnNZWE4wSUQwOVBTQW5MaTRuS1NCOGZDQnNZWE4wSUQwOVBTQW5KeWs3WEc1Y2JpQWdMeThnYzNSeWFYQWdjMmx1WjJ4bElHUnZkSE1zSUhKbGMyOXNkbVVnWkc5MVlteGxJR1J2ZEhNZ2RHOGdjR0Z5Wlc1MElHUnBjbHh1SUNBdkx5QnBaaUIwYUdVZ2NHRjBhQ0IwY21sbGN5QjBieUJuYnlCaFltOTJaU0IwYUdVZ2NtOXZkQ3dnWUhWd1lDQmxibVJ6SUhWd0lENGdNRnh1SUNCMllYSWdkWEFnUFNBd08xeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ2MzSmpVR0YwYUM1c1pXNW5kR2c3SUdrZ1BqMGdNRHNnYVMwdEtTQjdYRzRnSUNBZ2JHRnpkQ0E5SUhOeVkxQmhkR2hiYVYwN1hHNGdJQ0FnYVdZZ0tHeGhjM1FnUFQwOUlDY3VKeWtnZTF4dUlDQWdJQ0FnYzNKalVHRjBhQzV6Y0d4cFkyVW9hU3dnTVNrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoc1lYTjBJRDA5UFNBbkxpNG5LU0I3WEc0Z0lDQWdJQ0J6Y21OUVlYUm9Mbk53YkdsalpTaHBMQ0F4S1R0Y2JpQWdJQ0FnSUhWd0t5czdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaDFjQ2tnZTF4dUlDQWdJQ0FnYzNKalVHRjBhQzV6Y0d4cFkyVW9hU3dnTVNrN1hHNGdJQ0FnSUNCMWNDMHRPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJQzh2SUdsbUlIUm9aU0J3WVhSb0lHbHpJR0ZzYkc5M1pXUWdkRzhnWjI4Z1lXSnZkbVVnZEdobElISnZiM1FzSUhKbGMzUnZjbVVnYkdWaFpHbHVaeUF1TG5OY2JpQWdhV1lnS0NGdGRYTjBSVzVrUVdKeklDWW1JQ0Z5WlcxdmRtVkJiR3hFYjNSektTQjdYRzRnSUNBZ1ptOXlJQ2c3SUhWd0xTMDdJSFZ3S1NCN1hHNGdJQ0FnSUNCemNtTlFZWFJvTG5WdWMyaHBablFvSnk0dUp5azdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdhV1lnS0cxMWMzUkZibVJCWW5NZ0ppWWdjM0pqVUdGMGFGc3dYU0FoUFQwZ0p5Y2dKaVpjYmlBZ0lDQWdJQ2doYzNKalVHRjBhRnN3WFNCOGZDQnpjbU5RWVhSb1d6QmRMbU5vWVhKQmRDZ3dLU0FoUFQwZ0p5OG5LU2tnZTF4dUlDQWdJSE55WTFCaGRHZ3VkVzV6YUdsbWRDZ25KeWs3WEc0Z0lIMWNibHh1SUNCcFppQW9hR0Z6VkhKaGFXeHBibWRUYkdGemFDQW1KaUFvYzNKalVHRjBhQzVxYjJsdUtDY3ZKeWt1YzNWaWMzUnlLQzB4S1NBaFBUMGdKeThuS1NrZ2UxeHVJQ0FnSUhOeVkxQmhkR2d1Y0hWemFDZ25KeWs3WEc0Z0lIMWNibHh1SUNCMllYSWdhWE5CWW5OdmJIVjBaU0E5SUhOeVkxQmhkR2hiTUYwZ1BUMDlJQ2NuSUh4OFhHNGdJQ0FnSUNBb2MzSmpVR0YwYUZzd1hTQW1KaUJ6Y21OUVlYUm9XekJkTG1Ob1lYSkJkQ2d3S1NBOVBUMGdKeThuS1R0Y2JseHVJQ0F2THlCd2RYUWdkR2hsSUdodmMzUWdZbUZqYTF4dUlDQnBaaUFvY0hONVkyaHZkR2xqS1NCN1hHNGdJQ0FnY21WemRXeDBMbWh2YzNSdVlXMWxJRDBnY21WemRXeDBMbWh2YzNRZ1BTQnBjMEZpYzI5c2RYUmxJRDhnSnljZ09seHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjM0pqVUdGMGFDNXNaVzVuZEdnZ1B5QnpjbU5RWVhSb0xuTm9hV1owS0NrZ09pQW5KenRjYmlBZ0lDQXZMMjlqWTJGMGFXOXVZV3g1SUhSb1pTQmhkWFJvSUdOaGJpQm5aWFFnYzNSMVkyc2diMjVzZVNCcGJpQm9iM04wWEc0Z0lDQWdMeTkwYUdseklHVnpjR1ZqYVdGc2JIa2dhR0Z3Y0dWdWN5QnBiaUJqWVhObGN5QnNhV3RsWEc0Z0lDQWdMeTkxY213dWNtVnpiMngyWlU5aWFtVmpkQ2duYldGcGJIUnZPbXh2WTJGc01VQmtiMjFoYVc0eEp5d2dKMnh2WTJGc01rQmtiMjFoYVc0eUp5bGNiaUFnSUNCMllYSWdZWFYwYUVsdVNHOXpkQ0E5SUhKbGMzVnNkQzVvYjNOMElDWW1JSEpsYzNWc2RDNW9iM04wTG1sdVpHVjRUMllvSjBBbktTQStJREFnUDF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVZ6ZFd4MExtaHZjM1F1YzNCc2FYUW9KMEFuS1NBNklHWmhiSE5sTzF4dUlDQWdJR2xtSUNoaGRYUm9TVzVJYjNOMEtTQjdYRzRnSUNBZ0lDQnlaWE4xYkhRdVlYVjBhQ0E5SUdGMWRHaEpia2h2YzNRdWMyaHBablFvS1R0Y2JpQWdJQ0FnSUhKbGMzVnNkQzVvYjNOMElEMGdjbVZ6ZFd4MExtaHZjM1J1WVcxbElEMGdZWFYwYUVsdVNHOXpkQzV6YUdsbWRDZ3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJRzExYzNSRmJtUkJZbk1nUFNCdGRYTjBSVzVrUVdKeklIeDhJQ2h5WlhOMWJIUXVhRzl6ZENBbUppQnpjbU5RWVhSb0xteGxibWQwYUNrN1hHNWNiaUFnYVdZZ0tHMTFjM1JGYm1SQlluTWdKaVlnSVdselFXSnpiMngxZEdVcElIdGNiaUFnSUNCemNtTlFZWFJvTG5WdWMyaHBablFvSnljcE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0NGemNtTlFZWFJvTG14bGJtZDBhQ2tnZTF4dUlDQWdJSEpsYzNWc2RDNXdZWFJvYm1GdFpTQTlJRzUxYkd3N1hHNGdJQ0FnY21WemRXeDBMbkJoZEdnZ1BTQnVkV3hzTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGMzVnNkQzV3WVhSb2JtRnRaU0E5SUhOeVkxQmhkR2d1YW05cGJpZ25MeWNwTzF4dUlDQjlYRzVjYmlBZ0x5OTBieUJ6ZFhCd2IzSjBJSEpsY1hWbGMzUXVhSFIwY0Z4dUlDQnBaaUFvSVhWMGFXd3VhWE5PZFd4c0tISmxjM1ZzZEM1d1lYUm9ibUZ0WlNrZ2ZId2dJWFYwYVd3dWFYTk9kV3hzS0hKbGMzVnNkQzV6WldGeVkyZ3BLU0I3WEc0Z0lDQWdjbVZ6ZFd4MExuQmhkR2dnUFNBb2NtVnpkV3gwTG5CaGRHaHVZVzFsSUQ4Z2NtVnpkV3gwTG5CaGRHaHVZVzFsSURvZ0p5Y3BJQ3RjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNoeVpYTjFiSFF1YzJWaGNtTm9JRDhnY21WemRXeDBMbk5sWVhKamFDQTZJQ2NuS1R0Y2JpQWdmVnh1SUNCeVpYTjFiSFF1WVhWMGFDQTlJSEpsYkdGMGFYWmxMbUYxZEdnZ2ZId2djbVZ6ZFd4MExtRjFkR2c3WEc0Z0lISmxjM1ZzZEM1emJHRnphR1Z6SUQwZ2NtVnpkV3gwTG5Oc1lYTm9aWE1nZkh3Z2NtVnNZWFJwZG1VdWMyeGhjMmhsY3p0Y2JpQWdjbVZ6ZFd4MExtaHlaV1lnUFNCeVpYTjFiSFF1Wm05eWJXRjBLQ2s3WEc0Z0lISmxkSFZ5YmlCeVpYTjFiSFE3WEc1OU8xeHVYRzVWY213dWNISnZkRzkwZVhCbExuQmhjbk5sU0c5emRDQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQjJZWElnYUc5emRDQTlJSFJvYVhNdWFHOXpkRHRjYmlBZ2RtRnlJSEJ2Y25RZ1BTQndiM0owVUdGMGRHVnliaTVsZUdWaktHaHZjM1FwTzF4dUlDQnBaaUFvY0c5eWRDa2dlMXh1SUNBZ0lIQnZjblFnUFNCd2IzSjBXekJkTzF4dUlDQWdJR2xtSUNod2IzSjBJQ0U5UFNBbk9pY3BJSHRjYmlBZ0lDQWdJSFJvYVhNdWNHOXlkQ0E5SUhCdmNuUXVjM1ZpYzNSeUtERXBPMXh1SUNBZ0lIMWNiaUFnSUNCb2IzTjBJRDBnYUc5emRDNXpkV0p6ZEhJb01Dd2dhRzl6ZEM1c1pXNW5kR2dnTFNCd2IzSjBMbXhsYm1kMGFDazdYRzRnSUgxY2JpQWdhV1lnS0dodmMzUXBJSFJvYVhNdWFHOXpkRzVoYldVZ1BTQm9iM04wTzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0I3WEc0Z0lHbHpVM1J5YVc1bk9pQm1kVzVqZEdsdmJpaGhjbWNwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkSGx3Wlc5bUtHRnlaeWtnUFQwOUlDZHpkSEpwYm1jbk8xeHVJQ0I5TEZ4dUlDQnBjMDlpYW1WamREb2dablZ1WTNScGIyNG9ZWEpuS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFI1Y0dWdlppaGhjbWNwSUQwOVBTQW5iMkpxWldOMEp5QW1KaUJoY21jZ0lUMDlJRzUxYkd3N1hHNGdJSDBzWEc0Z0lHbHpUblZzYkRvZ1puVnVZM1JwYjI0b1lYSm5LU0I3WEc0Z0lDQWdjbVYwZFhKdUlHRnlaeUE5UFQwZ2JuVnNiRHRjYmlBZ2ZTeGNiaUFnYVhOT2RXeHNUM0pWYm1SbFptbHVaV1E2SUdaMWJtTjBhVzl1S0dGeVp5a2dlMXh1SUNBZ0lISmxkSFZ5YmlCaGNtY2dQVDBnYm5Wc2JEdGNiaUFnZlZ4dWZUdGNiaUlzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnYVhOQ2RXWm1aWElvWVhKbktTQjdYRzRnSUhKbGRIVnliaUJoY21jZ0ppWWdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0oyOWlhbVZqZENkY2JpQWdJQ0FtSmlCMGVYQmxiMllnWVhKbkxtTnZjSGtnUFQwOUlDZG1kVzVqZEdsdmJpZGNiaUFnSUNBbUppQjBlWEJsYjJZZ1lYSm5MbVpwYkd3Z1BUMDlJQ2RtZFc1amRHbHZiaWRjYmlBZ0lDQW1KaUIwZVhCbGIyWWdZWEpuTG5KbFlXUlZTVzUwT0NBOVBUMGdKMloxYm1OMGFXOXVKenRjYm4waUxDSXZMeUJEZFhKeVpXNTBiSGtnYVc0Z2MzbHVZeUIzYVhSb0lFNXZaR1V1YW5NZ2JHbGlMMmx1ZEdWeWJtRnNMM1YwYVd3dmRIbHdaWE11YW5OY2JpOHZJR2gwZEhCek9pOHZaMmwwYUhWaUxtTnZiUzl1YjJSbGFuTXZibTlrWlM5amIyMXRhWFF2TVRFeVkyTTNZekkzTlRVeE1qVTBZV0V5WWpFM01EazRabUkzTnpRNE5qZG1NRFZsWkRCa09WeHVYRzRuZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCcGMwRnlaM1Z0Wlc1MGMwOWlhbVZqZENBOUlISmxjWFZwY21Vb0oybHpMV0Z5WjNWdFpXNTBjeWNwTzF4dWRtRnlJR2x6UjJWdVpYSmhkRzl5Um5WdVkzUnBiMjRnUFNCeVpYRjFhWEpsS0NkcGN5MW5aVzVsY21GMGIzSXRablZ1WTNScGIyNG5LVHRjYm5aaGNpQjNhR2xqYUZSNWNHVmtRWEp5WVhrZ1BTQnlaWEYxYVhKbEtDZDNhR2xqYUMxMGVYQmxaQzFoY25KaGVTY3BPMXh1ZG1GeUlHbHpWSGx3WldSQmNuSmhlU0E5SUhKbGNYVnBjbVVvSjJsekxYUjVjR1ZrTFdGeWNtRjVKeWs3WEc1Y2JtWjFibU4wYVc5dUlIVnVZM1Z5Y25sVWFHbHpLR1lwSUh0Y2JpQWdjbVYwZFhKdUlHWXVZMkZzYkM1aWFXNWtLR1lwTzF4dWZWeHVYRzUyWVhJZ1FtbG5TVzUwVTNWd2NHOXlkR1ZrSUQwZ2RIbHdaVzltSUVKcFowbHVkQ0FoUFQwZ0ozVnVaR1ZtYVc1bFpDYzdYRzUyWVhJZ1UzbHRZbTlzVTNWd2NHOXlkR1ZrSUQwZ2RIbHdaVzltSUZONWJXSnZiQ0FoUFQwZ0ozVnVaR1ZtYVc1bFpDYzdYRzVjYm5aaGNpQlBZbXBsWTNSVWIxTjBjbWx1WnlBOUlIVnVZM1Z5Y25sVWFHbHpLRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY3BPMXh1WEc1MllYSWdiblZ0WW1WeVZtRnNkV1VnUFNCMWJtTjFjbko1VkdocGN5aE9kVzFpWlhJdWNISnZkRzkwZVhCbExuWmhiSFZsVDJZcE8xeHVkbUZ5SUhOMGNtbHVaMVpoYkhWbElEMGdkVzVqZFhKeWVWUm9hWE1vVTNSeWFXNW5MbkJ5YjNSdmRIbHdaUzUyWVd4MVpVOW1LVHRjYm5aaGNpQmliMjlzWldGdVZtRnNkV1VnUFNCMWJtTjFjbko1VkdocGN5aENiMjlzWldGdUxuQnliM1J2ZEhsd1pTNTJZV3gxWlU5bUtUdGNibHh1YVdZZ0tFSnBaMGx1ZEZOMWNIQnZjblJsWkNrZ2UxeHVJQ0IyWVhJZ1ltbG5TVzUwVm1Gc2RXVWdQU0IxYm1OMWNuSjVWR2hwY3loQ2FXZEpiblF1Y0hKdmRHOTBlWEJsTG5aaGJIVmxUMllwTzF4dWZWeHVYRzVwWmlBb1UzbHRZbTlzVTNWd2NHOXlkR1ZrS1NCN1hHNGdJSFpoY2lCemVXMWliMnhXWVd4MVpTQTlJSFZ1WTNWeWNubFVhR2x6S0ZONWJXSnZiQzV3Y205MGIzUjVjR1V1ZG1Gc2RXVlBaaWs3WEc1OVhHNWNibVoxYm1OMGFXOXVJR05vWldOclFtOTRaV1JRY21sdGFYUnBkbVVvZG1Gc2RXVXNJSEJ5YjNSdmRIbHdaVlpoYkhWbFQyWXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQjJZV3gxWlNBaFBUMGdKMjlpYW1WamRDY3BJSHRjYmlBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lIMWNiaUFnZEhKNUlIdGNiaUFnSUNCd2NtOTBiM1I1Y0dWV1lXeDFaVTltS0haaGJIVmxLVHRjYmlBZ0lDQnlaWFIxY200Z2RISjFaVHRjYmlBZ2ZTQmpZWFJqYUNobEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNCOVhHNTlYRzVjYm1WNGNHOXlkSE11YVhOQmNtZDFiV1Z1ZEhOUFltcGxZM1FnUFNCcGMwRnlaM1Z0Wlc1MGMwOWlhbVZqZER0Y2JtVjRjRzl5ZEhNdWFYTkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpQTlJR2x6UjJWdVpYSmhkRzl5Um5WdVkzUnBiMjQ3WEc1bGVIQnZjblJ6TG1selZIbHdaV1JCY25KaGVTQTlJR2x6Vkhsd1pXUkJjbkpoZVR0Y2JseHVMeThnVkdGclpXNGdabkp2YlNCb1pYSmxJR0Z1WkNCdGIyUnBabWxsWkNCbWIzSWdZbVYwZEdWeUlHSnliM2R6WlhJZ2MzVndjRzl5ZEZ4dUx5OGdhSFIwY0hNNkx5OW5hWFJvZFdJdVkyOXRMM05wYm1SeVpYTnZjbWgxY3k5d0xXbHpMWEJ5YjIxcGMyVXZZbXh2WWk5alpHRXpOV0UxTVROaVpHRXdNMlk1TnpkaFpEVmpaR1V6WVRBM09XUXlNemRsT0RKa04yVm1MMmx1WkdWNExtcHpYRzVtZFc1amRHbHZiaUJwYzFCeWIyMXBjMlVvYVc1d2RYUXBJSHRjYmx4MGNtVjBkWEp1SUNoY2JseDBYSFFvWEc1Y2RGeDBYSFIwZVhCbGIyWWdVSEp2YldselpTQWhQVDBnSjNWdVpHVm1hVzVsWkNjZ0ppWmNibHgwWEhSY2RHbHVjSFYwSUdsdWMzUmhibU5sYjJZZ1VISnZiV2x6WlZ4dVhIUmNkQ2tnZkh4Y2JseDBYSFFvWEc1Y2RGeDBYSFJwYm5CMWRDQWhQVDBnYm5Wc2JDQW1KbHh1WEhSY2RGeDBkSGx3Wlc5bUlHbHVjSFYwSUQwOVBTQW5iMkpxWldOMEp5QW1KbHh1WEhSY2RGeDBkSGx3Wlc5bUlHbHVjSFYwTG5Sb1pXNGdQVDA5SUNkbWRXNWpkR2x2YmljZ0ppWmNibHgwWEhSY2RIUjVjR1Z2WmlCcGJuQjFkQzVqWVhSamFDQTlQVDBnSjJaMWJtTjBhVzl1SjF4dVhIUmNkQ2xjYmx4MEtUdGNibjFjYm1WNGNHOXlkSE11YVhOUWNtOXRhWE5sSUQwZ2FYTlFjbTl0YVhObE8xeHVYRzVtZFc1amRHbHZiaUJwYzBGeWNtRjVRblZtWm1WeVZtbGxkeWgyWVd4MVpTa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlFRnljbUY1UW5WbVptVnlJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUJCY25KaGVVSjFabVpsY2k1cGMxWnBaWGNwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdRWEp5WVhsQ2RXWm1aWEl1YVhOV2FXVjNLSFpoYkhWbEtUdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQW9YRzRnSUNBZ2FYTlVlWEJsWkVGeWNtRjVLSFpoYkhWbEtTQjhmRnh1SUNBZ0lHbHpSR0YwWVZacFpYY29kbUZzZFdVcFhHNGdJQ2s3WEc1OVhHNWxlSEJ2Y25SekxtbHpRWEp5WVhsQ2RXWm1aWEpXYVdWM0lEMGdhWE5CY25KaGVVSjFabVpsY2xacFpYYzdYRzVjYmx4dVpuVnVZM1JwYjI0Z2FYTlZhVzUwT0VGeWNtRjVLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUIzYUdsamFGUjVjR1ZrUVhKeVlYa29kbUZzZFdVcElEMDlQU0FuVldsdWREaEJjbkpoZVNjN1hHNTlYRzVsZUhCdmNuUnpMbWx6VldsdWREaEJjbkpoZVNBOUlHbHpWV2x1ZERoQmNuSmhlVHRjYmx4dVpuVnVZM1JwYjI0Z2FYTlZhVzUwT0VOc1lXMXdaV1JCY25KaGVTaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdkMmhwWTJoVWVYQmxaRUZ5Y21GNUtIWmhiSFZsS1NBOVBUMGdKMVZwYm5RNFEyeGhiWEJsWkVGeWNtRjVKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTlZhVzUwT0VOc1lXMXdaV1JCY25KaGVTQTlJR2x6VldsdWREaERiR0Z0Y0dWa1FYSnlZWGs3WEc1Y2JtWjFibU4wYVc5dUlHbHpWV2x1ZERFMlFYSnlZWGtvZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUhkb2FXTm9WSGx3WldSQmNuSmhlU2gyWVd4MVpTa2dQVDA5SUNkVmFXNTBNVFpCY25KaGVTYzdYRzU5WEc1bGVIQnZjblJ6TG1selZXbHVkREUyUVhKeVlYa2dQU0JwYzFWcGJuUXhOa0Z5Y21GNU8xeHVYRzVtZFc1amRHbHZiaUJwYzFWcGJuUXpNa0Z5Y21GNUtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQjNhR2xqYUZSNWNHVmtRWEp5WVhrb2RtRnNkV1VwSUQwOVBTQW5WV2x1ZERNeVFYSnlZWGtuTzF4dWZWeHVaWGh3YjNKMGN5NXBjMVZwYm5Rek1rRnljbUY1SUQwZ2FYTlZhVzUwTXpKQmNuSmhlVHRjYmx4dVpuVnVZM1JwYjI0Z2FYTkpiblE0UVhKeVlYa29kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJSGRvYVdOb1ZIbHdaV1JCY25KaGVTaDJZV3gxWlNrZ1BUMDlJQ2RKYm5RNFFYSnlZWGtuTzF4dWZWeHVaWGh3YjNKMGN5NXBjMGx1ZERoQmNuSmhlU0E5SUdselNXNTBPRUZ5Y21GNU8xeHVYRzVtZFc1amRHbHZiaUJwYzBsdWRERTJRWEp5WVhrb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlIZG9hV05vVkhsd1pXUkJjbkpoZVNoMllXeDFaU2tnUFQwOUlDZEpiblF4TmtGeWNtRjVKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTkpiblF4TmtGeWNtRjVJRDBnYVhOSmJuUXhOa0Z5Y21GNU8xeHVYRzVtZFc1amRHbHZiaUJwYzBsdWRETXlRWEp5WVhrb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlIZG9hV05vVkhsd1pXUkJjbkpoZVNoMllXeDFaU2tnUFQwOUlDZEpiblF6TWtGeWNtRjVKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTkpiblF6TWtGeWNtRjVJRDBnYVhOSmJuUXpNa0Z5Y21GNU8xeHVYRzVtZFc1amRHbHZiaUJwYzBac2IyRjBNekpCY25KaGVTaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdkMmhwWTJoVWVYQmxaRUZ5Y21GNUtIWmhiSFZsS1NBOVBUMGdKMFpzYjJGME16SkJjbkpoZVNjN1hHNTlYRzVsZUhCdmNuUnpMbWx6Um14dllYUXpNa0Z5Y21GNUlEMGdhWE5HYkc5aGRETXlRWEp5WVhrN1hHNWNibVoxYm1OMGFXOXVJR2x6Um14dllYUTJORUZ5Y21GNUtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQjNhR2xqYUZSNWNHVmtRWEp5WVhrb2RtRnNkV1VwSUQwOVBTQW5SbXh2WVhRMk5FRnljbUY1Snp0Y2JuMWNibVY0Y0c5eWRITXVhWE5HYkc5aGREWTBRWEp5WVhrZ1BTQnBjMFpzYjJGME5qUkJjbkpoZVR0Y2JseHVablZ1WTNScGIyNGdhWE5DYVdkSmJuUTJORUZ5Y21GNUtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQjNhR2xqYUZSNWNHVmtRWEp5WVhrb2RtRnNkV1VwSUQwOVBTQW5RbWxuU1c1ME5qUkJjbkpoZVNjN1hHNTlYRzVsZUhCdmNuUnpMbWx6UW1sblNXNTBOalJCY25KaGVTQTlJR2x6UW1sblNXNTBOalJCY25KaGVUdGNibHh1Wm5WdVkzUnBiMjRnYVhOQ2FXZFZhVzUwTmpSQmNuSmhlU2gyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnZDJocFkyaFVlWEJsWkVGeWNtRjVLSFpoYkhWbEtTQTlQVDBnSjBKcFoxVnBiblEyTkVGeWNtRjVKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTkNhV2RWYVc1ME5qUkJjbkpoZVNBOUlHbHpRbWxuVldsdWREWTBRWEp5WVhrN1hHNWNibVoxYm1OMGFXOXVJR2x6VFdGd1ZHOVRkSEpwYm1jb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlFOWlhbVZqZEZSdlUzUnlhVzVuS0haaGJIVmxLU0E5UFQwZ0oxdHZZbXBsWTNRZ1RXRndYU2M3WEc1OVhHNXBjMDFoY0ZSdlUzUnlhVzVuTG5kdmNtdHBibWNnUFNBb1hHNGdJSFI1Y0dWdlppQk5ZWEFnSVQwOUlDZDFibVJsWm1sdVpXUW5JQ1ltWEc0Z0lHbHpUV0Z3Vkc5VGRISnBibWNvYm1WM0lFMWhjQ2dwS1Z4dUtUdGNibHh1Wm5WdVkzUnBiMjRnYVhOTllYQW9kbUZzZFdVcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCTllYQWdQVDA5SUNkMWJtUmxabWx1WldRbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR2x6VFdGd1ZHOVRkSEpwYm1jdWQyOXlhMmx1WjF4dUlDQWdJRDhnYVhOTllYQlViMU4wY21sdVp5aDJZV3gxWlNsY2JpQWdJQ0E2SUhaaGJIVmxJR2x1YzNSaGJtTmxiMllnVFdGd08xeHVmVnh1Wlhod2IzSjBjeTVwYzAxaGNDQTlJR2x6VFdGd08xeHVYRzVtZFc1amRHbHZiaUJwYzFObGRGUnZVM1J5YVc1bktIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQlBZbXBsWTNSVWIxTjBjbWx1WnloMllXeDFaU2tnUFQwOUlDZGJiMkpxWldOMElGTmxkRjBuTzF4dWZWeHVhWE5UWlhSVWIxTjBjbWx1Wnk1M2IzSnJhVzVuSUQwZ0tGeHVJQ0IwZVhCbGIyWWdVMlYwSUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmx4dUlDQnBjMU5sZEZSdlUzUnlhVzVuS0c1bGR5QlRaWFFvS1NsY2JpazdYRzVtZFc1amRHbHZiaUJwYzFObGRDaDJZV3gxWlNrZ2UxeHVJQ0JwWmlBb2RIbHdaVzltSUZObGRDQTlQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdhWE5UWlhSVWIxTjBjbWx1Wnk1M2IzSnJhVzVuWEc0Z0lDQWdQeUJwYzFObGRGUnZVM1J5YVc1bktIWmhiSFZsS1Z4dUlDQWdJRG9nZG1Gc2RXVWdhVzV6ZEdGdVkyVnZaaUJUWlhRN1hHNTlYRzVsZUhCdmNuUnpMbWx6VTJWMElEMGdhWE5UWlhRN1hHNWNibVoxYm1OMGFXOXVJR2x6VjJWaGEwMWhjRlJ2VTNSeWFXNW5LSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUlViMU4wY21sdVp5aDJZV3gxWlNrZ1BUMDlJQ2RiYjJKcVpXTjBJRmRsWVd0TllYQmRKenRjYm4xY2JtbHpWMlZoYTAxaGNGUnZVM1J5YVc1bkxuZHZjbXRwYm1jZ1BTQW9YRzRnSUhSNWNHVnZaaUJYWldGclRXRndJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KbHh1SUNCcGMxZGxZV3ROWVhCVWIxTjBjbWx1WnlodVpYY2dWMlZoYTAxaGNDZ3BLVnh1S1R0Y2JtWjFibU4wYVc5dUlHbHpWMlZoYTAxaGNDaDJZV3gxWlNrZ2UxeHVJQ0JwWmlBb2RIbHdaVzltSUZkbFlXdE5ZWEFnUFQwOUlDZDFibVJsWm1sdVpXUW5LU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdselYyVmhhMDFoY0ZSdlUzUnlhVzVuTG5kdmNtdHBibWRjYmlBZ0lDQS9JR2x6VjJWaGEwMWhjRlJ2VTNSeWFXNW5LSFpoYkhWbEtWeHVJQ0FnSURvZ2RtRnNkV1VnYVc1emRHRnVZMlZ2WmlCWFpXRnJUV0Z3TzF4dWZWeHVaWGh3YjNKMGN5NXBjMWRsWVd0TllYQWdQU0JwYzFkbFlXdE5ZWEE3WEc1Y2JtWjFibU4wYVc5dUlHbHpWMlZoYTFObGRGUnZVM1J5YVc1bktIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQlBZbXBsWTNSVWIxTjBjbWx1WnloMllXeDFaU2tnUFQwOUlDZGJiMkpxWldOMElGZGxZV3RUWlhSZEp6dGNibjFjYm1selYyVmhhMU5sZEZSdlUzUnlhVzVuTG5kdmNtdHBibWNnUFNBb1hHNGdJSFI1Y0dWdlppQlhaV0ZyVTJWMElDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUpseHVJQ0JwYzFkbFlXdFRaWFJVYjFOMGNtbHVaeWh1WlhjZ1YyVmhhMU5sZENncEtWeHVLVHRjYm1aMWJtTjBhVzl1SUdselYyVmhhMU5sZENoMllXeDFaU2tnZTF4dUlDQnlaWFIxY200Z2FYTlhaV0ZyVTJWMFZHOVRkSEpwYm1jb2RtRnNkV1VwTzF4dWZWeHVaWGh3YjNKMGN5NXBjMWRsWVd0VFpYUWdQU0JwYzFkbFlXdFRaWFE3WEc1Y2JtWjFibU4wYVc5dUlHbHpRWEp5WVhsQ2RXWm1aWEpVYjFOMGNtbHVaeWgyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnVDJKcVpXTjBWRzlUZEhKcGJtY29kbUZzZFdVcElEMDlQU0FuVzI5aWFtVmpkQ0JCY25KaGVVSjFabVpsY2wwbk8xeHVmVnh1YVhOQmNuSmhlVUoxWm1abGNsUnZVM1J5YVc1bkxuZHZjbXRwYm1jZ1BTQW9YRzRnSUhSNWNHVnZaaUJCY25KaGVVSjFabVpsY2lBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NnSmlaY2JpQWdhWE5CY25KaGVVSjFabVpsY2xSdlUzUnlhVzVuS0c1bGR5QkJjbkpoZVVKMVptWmxjaWdwS1Z4dUtUdGNibVoxYm1OMGFXOXVJR2x6UVhKeVlYbENkV1ptWlhJb2RtRnNkV1VwSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUJCY25KaGVVSjFabVpsY2lBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2FYTkJjbkpoZVVKMVptWmxjbFJ2VTNSeWFXNW5MbmR2Y210cGJtZGNiaUFnSUNBL0lHbHpRWEp5WVhsQ2RXWm1aWEpVYjFOMGNtbHVaeWgyWVd4MVpTbGNiaUFnSUNBNklIWmhiSFZsSUdsdWMzUmhibU5sYjJZZ1FYSnlZWGxDZFdabVpYSTdYRzU5WEc1bGVIQnZjblJ6TG1selFYSnlZWGxDZFdabVpYSWdQU0JwYzBGeWNtRjVRblZtWm1WeU8xeHVYRzVtZFc1amRHbHZiaUJwYzBSaGRHRldhV1YzVkc5VGRISnBibWNvZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUU5aWFtVmpkRlJ2VTNSeWFXNW5LSFpoYkhWbEtTQTlQVDBnSjF0dlltcGxZM1FnUkdGMFlWWnBaWGRkSnp0Y2JuMWNibWx6UkdGMFlWWnBaWGRVYjFOMGNtbHVaeTUzYjNKcmFXNW5JRDBnS0Z4dUlDQjBlWEJsYjJZZ1FYSnlZWGxDZFdabVpYSWdJVDA5SUNkMWJtUmxabWx1WldRbklDWW1YRzRnSUhSNWNHVnZaaUJFWVhSaFZtbGxkeUFoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dKaVpjYmlBZ2FYTkVZWFJoVm1sbGQxUnZVM1J5YVc1bktHNWxkeUJFWVhSaFZtbGxkeWh1WlhjZ1FYSnlZWGxDZFdabVpYSW9NU2tzSURBc0lERXBLVnh1S1R0Y2JtWjFibU4wYVc5dUlHbHpSR0YwWVZacFpYY29kbUZzZFdVcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCRVlYUmhWbWxsZHlBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2FYTkVZWFJoVm1sbGQxUnZVM1J5YVc1bkxuZHZjbXRwYm1kY2JpQWdJQ0EvSUdselJHRjBZVlpwWlhkVWIxTjBjbWx1WnloMllXeDFaU2xjYmlBZ0lDQTZJSFpoYkhWbElHbHVjM1JoYm1ObGIyWWdSR0YwWVZacFpYYzdYRzU5WEc1bGVIQnZjblJ6TG1selJHRjBZVlpwWlhjZ1BTQnBjMFJoZEdGV2FXVjNPMXh1WEc1bWRXNWpkR2x2YmlCcGMxTm9ZWEpsWkVGeWNtRjVRblZtWm1WeVZHOVRkSEpwYm1jb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlFOWlhbVZqZEZSdlUzUnlhVzVuS0haaGJIVmxLU0E5UFQwZ0oxdHZZbXBsWTNRZ1UyaGhjbVZrUVhKeVlYbENkV1ptWlhKZEp6dGNibjFjYm1selUyaGhjbVZrUVhKeVlYbENkV1ptWlhKVWIxTjBjbWx1Wnk1M2IzSnJhVzVuSUQwZ0tGeHVJQ0IwZVhCbGIyWWdVMmhoY21Wa1FYSnlZWGxDZFdabVpYSWdJVDA5SUNkMWJtUmxabWx1WldRbklDWW1YRzRnSUdselUyaGhjbVZrUVhKeVlYbENkV1ptWlhKVWIxTjBjbWx1WnlodVpYY2dVMmhoY21Wa1FYSnlZWGxDZFdabVpYSW9LU2xjYmlrN1hHNW1kVzVqZEdsdmJpQnBjMU5vWVhKbFpFRnljbUY1UW5WbVptVnlLSFpoYkhWbEtTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ1UyaGhjbVZrUVhKeVlYbENkV1ptWlhJZ1BUMDlJQ2QxYm1SbFptbHVaV1FuS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHbHpVMmhoY21Wa1FYSnlZWGxDZFdabVpYSlViMU4wY21sdVp5NTNiM0pyYVc1blhHNGdJQ0FnUHlCcGMxTm9ZWEpsWkVGeWNtRjVRblZtWm1WeVZHOVRkSEpwYm1jb2RtRnNkV1VwWEc0Z0lDQWdPaUIyWVd4MVpTQnBibk4wWVc1alpXOW1JRk5vWVhKbFpFRnljbUY1UW5WbVptVnlPMXh1ZlZ4dVpYaHdiM0owY3k1cGMxTm9ZWEpsWkVGeWNtRjVRblZtWm1WeUlEMGdhWE5UYUdGeVpXUkJjbkpoZVVKMVptWmxjanRjYmx4dVpuVnVZM1JwYjI0Z2FYTkJjM2x1WTBaMWJtTjBhVzl1S0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCUFltcGxZM1JVYjFOMGNtbHVaeWgyWVd4MVpTa2dQVDA5SUNkYmIySnFaV04wSUVGemVXNWpSblZ1WTNScGIyNWRKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTkJjM2x1WTBaMWJtTjBhVzl1SUQwZ2FYTkJjM2x1WTBaMWJtTjBhVzl1TzF4dVhHNW1kVzVqZEdsdmJpQnBjMDFoY0VsMFpYSmhkRzl5S0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCUFltcGxZM1JVYjFOMGNtbHVaeWgyWVd4MVpTa2dQVDA5SUNkYmIySnFaV04wSUUxaGNDQkpkR1Z5WVhSdmNsMG5PMXh1ZlZ4dVpYaHdiM0owY3k1cGMwMWhjRWwwWlhKaGRHOXlJRDBnYVhOTllYQkpkR1Z5WVhSdmNqdGNibHh1Wm5WdVkzUnBiMjRnYVhOVFpYUkpkR1Z5WVhSdmNpaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdUMkpxWldOMFZHOVRkSEpwYm1jb2RtRnNkV1VwSUQwOVBTQW5XMjlpYW1WamRDQlRaWFFnU1hSbGNtRjBiM0pkSnp0Y2JuMWNibVY0Y0c5eWRITXVhWE5UWlhSSmRHVnlZWFJ2Y2lBOUlHbHpVMlYwU1hSbGNtRjBiM0k3WEc1Y2JtWjFibU4wYVc5dUlHbHpSMlZ1WlhKaGRHOXlUMkpxWldOMEtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQlBZbXBsWTNSVWIxTjBjbWx1WnloMllXeDFaU2tnUFQwOUlDZGJiMkpxWldOMElFZGxibVZ5WVhSdmNsMG5PMXh1ZlZ4dVpYaHdiM0owY3k1cGMwZGxibVZ5WVhSdmNrOWlhbVZqZENBOUlHbHpSMlZ1WlhKaGRHOXlUMkpxWldOME8xeHVYRzVtZFc1amRHbHZiaUJwYzFkbFlrRnpjMlZ0WW14NVEyOXRjR2xzWldSTmIyUjFiR1VvZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUU5aWFtVmpkRlJ2VTNSeWFXNW5LSFpoYkhWbEtTQTlQVDBnSjF0dlltcGxZM1FnVjJWaVFYTnpaVzFpYkhrdVRXOWtkV3hsWFNjN1hHNTlYRzVsZUhCdmNuUnpMbWx6VjJWaVFYTnpaVzFpYkhsRGIyMXdhV3hsWkUxdlpIVnNaU0E5SUdselYyVmlRWE56WlcxaWJIbERiMjF3YVd4bFpFMXZaSFZzWlR0Y2JseHVablZ1WTNScGIyNGdhWE5PZFcxaVpYSlBZbXBsWTNRb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlHTm9aV05yUW05NFpXUlFjbWx0YVhScGRtVW9kbUZzZFdVc0lHNTFiV0psY2xaaGJIVmxLVHRjYm4xY2JtVjRjRzl5ZEhNdWFYTk9kVzFpWlhKUFltcGxZM1FnUFNCcGMwNTFiV0psY2s5aWFtVmpkRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTlRkSEpwYm1kUFltcGxZM1FvZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUdOb1pXTnJRbTk0WldSUWNtbHRhWFJwZG1Vb2RtRnNkV1VzSUhOMGNtbHVaMVpoYkhWbEtUdGNibjFjYm1WNGNHOXlkSE11YVhOVGRISnBibWRQWW1wbFkzUWdQU0JwYzFOMGNtbHVaMDlpYW1WamREdGNibHh1Wm5WdVkzUnBiMjRnYVhOQ2IyOXNaV0Z1VDJKcVpXTjBLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUJqYUdWamEwSnZlR1ZrVUhKcGJXbDBhWFpsS0haaGJIVmxMQ0JpYjI5c1pXRnVWbUZzZFdVcE8xeHVmVnh1Wlhod2IzSjBjeTVwYzBKdmIyeGxZVzVQWW1wbFkzUWdQU0JwYzBKdmIyeGxZVzVQWW1wbFkzUTdYRzVjYm1aMWJtTjBhVzl1SUdselFtbG5TVzUwVDJKcVpXTjBLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUJDYVdkSmJuUlRkWEJ3YjNKMFpXUWdKaVlnWTJobFkydENiM2hsWkZCeWFXMXBkR2wyWlNoMllXeDFaU3dnWW1sblNXNTBWbUZzZFdVcE8xeHVmVnh1Wlhod2IzSjBjeTVwYzBKcFowbHVkRTlpYW1WamRDQTlJR2x6UW1sblNXNTBUMkpxWldOME8xeHVYRzVtZFc1amRHbHZiaUJwYzFONWJXSnZiRTlpYW1WamRDaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdVM2x0WW05c1UzVndjRzl5ZEdWa0lDWW1JR05vWldOclFtOTRaV1JRY21sdGFYUnBkbVVvZG1Gc2RXVXNJSE41YldKdmJGWmhiSFZsS1R0Y2JuMWNibVY0Y0c5eWRITXVhWE5UZVcxaWIyeFBZbXBsWTNRZ1BTQnBjMU41YldKdmJFOWlhbVZqZER0Y2JseHVablZ1WTNScGIyNGdhWE5DYjNobFpGQnlhVzFwZEdsMlpTaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdLRnh1SUNBZ0lHbHpUblZ0WW1WeVQySnFaV04wS0haaGJIVmxLU0I4ZkZ4dUlDQWdJR2x6VTNSeWFXNW5UMkpxWldOMEtIWmhiSFZsS1NCOGZGeHVJQ0FnSUdselFtOXZiR1ZoYms5aWFtVmpkQ2gyWVd4MVpTa2dmSHhjYmlBZ0lDQnBjMEpwWjBsdWRFOWlhbVZqZENoMllXeDFaU2tnZkh4Y2JpQWdJQ0JwYzFONWJXSnZiRTlpYW1WamRDaDJZV3gxWlNsY2JpQWdLVHRjYm4xY2JtVjRjRzl5ZEhNdWFYTkNiM2hsWkZCeWFXMXBkR2wyWlNBOUlHbHpRbTk0WldSUWNtbHRhWFJwZG1VN1hHNWNibVoxYm1OMGFXOXVJR2x6UVc1NVFYSnlZWGxDZFdabVpYSW9kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJSFI1Y0dWdlppQlZhVzUwT0VGeWNtRjVJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUFvWEc0Z0lDQWdhWE5CY25KaGVVSjFabVpsY2loMllXeDFaU2tnZkh4Y2JpQWdJQ0JwYzFOb1lYSmxaRUZ5Y21GNVFuVm1abVZ5S0haaGJIVmxLVnh1SUNBcE8xeHVmVnh1Wlhod2IzSjBjeTVwYzBGdWVVRnljbUY1UW5WbVptVnlJRDBnYVhOQmJubEJjbkpoZVVKMVptWmxjanRjYmx4dVd5ZHBjMUJ5YjNoNUp5d2dKMmx6UlhoMFpYSnVZV3duTENBbmFYTk5iMlIxYkdWT1lXMWxjM0JoWTJWUFltcGxZM1FuWFM1bWIzSkZZV05vS0daMWJtTjBhVzl1S0cxbGRHaHZaQ2tnZTF4dUlDQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvWlhod2IzSjBjeXdnYldWMGFHOWtMQ0I3WEc0Z0lDQWdaVzUxYldWeVlXSnNaVG9nWm1Gc2MyVXNYRzRnSUNBZ2RtRnNkV1U2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0cxbGRHaHZaQ0FySUNjZ2FYTWdibTkwSUhOMWNIQnZjblJsWkNCcGJpQjFjMlZ5YkdGdVpDY3BPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNTlLVHRjYmlJc0lpOHZJRU52Y0hseWFXZG9kQ0JLYjNsbGJuUXNJRWx1WXk0Z1lXNWtJRzkwYUdWeUlFNXZaR1VnWTI5dWRISnBZblYwYjNKekxseHVMeTljYmk4dklGQmxjbTFwYzNOcGIyNGdhWE1nYUdWeVpXSjVJR2R5WVc1MFpXUXNJR1p5WldVZ2IyWWdZMmhoY21kbExDQjBieUJoYm5rZ2NHVnljMjl1SUc5aWRHRnBibWx1WnlCaFhHNHZMeUJqYjNCNUlHOW1JSFJvYVhNZ2MyOW1kSGRoY21VZ1lXNWtJR0Z6YzI5amFXRjBaV1FnWkc5amRXMWxiblJoZEdsdmJpQm1hV3hsY3lBb2RHaGxYRzR2THlCY0lsTnZablIzWVhKbFhDSXBMQ0IwYnlCa1pXRnNJR2x1SUhSb1pTQlRiMlowZDJGeVpTQjNhWFJvYjNWMElISmxjM1J5YVdOMGFXOXVMQ0JwYm1Oc2RXUnBibWRjYmk4dklIZHBkR2h2ZFhRZ2JHbHRhWFJoZEdsdmJpQjBhR1VnY21sbmFIUnpJSFJ2SUhWelpTd2dZMjl3ZVN3Z2JXOWthV1o1TENCdFpYSm5aU3dnY0hWaWJHbHphQ3hjYmk4dklHUnBjM1J5YVdKMWRHVXNJSE4xWW14cFkyVnVjMlVzSUdGdVpDOXZjaUJ6Wld4c0lHTnZjR2xsY3lCdlppQjBhR1VnVTI5bWRIZGhjbVVzSUdGdVpDQjBieUJ3WlhKdGFYUmNiaTh2SUhCbGNuTnZibk1nZEc4Z2QyaHZiU0IwYUdVZ1UyOW1kSGRoY21VZ2FYTWdablZ5Ym1semFHVmtJSFJ2SUdSdklITnZMQ0J6ZFdKcVpXTjBJSFJ2SUhSb1pWeHVMeThnWm05c2JHOTNhVzVuSUdOdmJtUnBkR2x2Ym5NNlhHNHZMMXh1THk4Z1ZHaGxJR0ZpYjNabElHTnZjSGx5YVdkb2RDQnViM1JwWTJVZ1lXNWtJSFJvYVhNZ2NHVnliV2x6YzJsdmJpQnViM1JwWTJVZ2MyaGhiR3dnWW1VZ2FXNWpiSFZrWldSY2JpOHZJR2x1SUdGc2JDQmpiM0JwWlhNZ2IzSWdjM1ZpYzNSaGJuUnBZV3dnY0c5eWRHbHZibk1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMbHh1THk5Y2JpOHZJRlJJUlNCVFQwWlVWMEZTUlNCSlV5QlFVazlXU1VSRlJDQmNJa0ZUSUVsVFhDSXNJRmRKVkVoUFZWUWdWMEZTVWtGT1ZGa2dUMFlnUVU1WklFdEpUa1FzSUVWWVVGSkZVMU5jYmk4dklFOVNJRWxOVUV4SlJVUXNJRWxPUTB4VlJFbE9SeUJDVlZRZ1RrOVVJRXhKVFVsVVJVUWdWRThnVkVoRklGZEJVbEpCVGxSSlJWTWdUMFpjYmk4dklFMUZVa05JUVU1VVFVSkpURWxVV1N3Z1JrbFVUa1ZUVXlCR1QxSWdRU0JRUVZKVVNVTlZURUZTSUZCVlVsQlBVMFVnUVU1RUlFNVBUa2xPUmxKSlRrZEZUVVZPVkM0Z1NVNWNiaTh2SUU1UElFVldSVTVVSUZOSVFVeE1JRlJJUlNCQlZWUklUMUpUSUU5U0lFTlBVRmxTU1VkSVZDQklUMHhFUlZKVElFSkZJRXhKUVVKTVJTQkdUMUlnUVU1WklFTk1RVWxOTEZ4dUx5OGdSRUZOUVVkRlV5QlBVaUJQVkVoRlVpQk1TVUZDU1V4SlZGa3NJRmRJUlZSSVJWSWdTVTRnUVU0Z1FVTlVTVTlPSUU5R0lFTlBUbFJTUVVOVUxDQlVUMUpVSUU5U1hHNHZMeUJQVkVoRlVsZEpVMFVzSUVGU1NWTkpUa2NnUmxKUFRTd2dUMVZVSUU5R0lFOVNJRWxPSUVOUFRrNUZRMVJKVDA0Z1YwbFVTQ0JVU0VVZ1UwOUdWRmRCVWtVZ1QxSWdWRWhGWEc0dkx5QlZVMFVnVDFJZ1QxUklSVklnUkVWQlRFbE9SMU1nU1U0Z1ZFaEZJRk5QUmxSWFFWSkZMbHh1WEc1MllYSWdaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eWN5QTlJRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVVSbGMyTnlhWEIwYjNKeklIeDhYRzRnSUdaMWJtTjBhVzl1SUdkbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjbk1vYjJKcUtTQjdYRzRnSUNBZ2RtRnlJR3RsZVhNZ1BTQlBZbXBsWTNRdWEyVjVjeWh2WW1vcE8xeHVJQ0FnSUhaaGNpQmtaWE5qY21sd2RHOXljeUE5SUh0OU8xeHVJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2EyVjVjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ1pHVnpZM0pwY0hSdmNuTmJhMlY1YzF0cFhWMGdQU0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eUtHOWlhaXdnYTJWNWMxdHBYU2s3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCa1pYTmpjbWx3ZEc5eWN6dGNiaUFnZlR0Y2JseHVkbUZ5SUdadmNtMWhkRkpsWjBWNGNDQTlJQzhsVzNOa2FpVmRMMmM3WEc1bGVIQnZjblJ6TG1admNtMWhkQ0E5SUdaMWJtTjBhVzl1S0dZcElIdGNiaUFnYVdZZ0tDRnBjMU4wY21sdVp5aG1LU2tnZTF4dUlDQWdJSFpoY2lCdlltcGxZM1J6SUQwZ1cxMDdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQmhjbWQxYldWdWRITXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUc5aWFtVmpkSE11Y0hWemFDaHBibk53WldOMEtHRnlaM1Z0Wlc1MGMxdHBYU2twTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z2IySnFaV04wY3k1cWIybHVLQ2NnSnlrN1hHNGdJSDFjYmx4dUlDQjJZWElnYVNBOUlERTdYRzRnSUhaaGNpQmhjbWR6SUQwZ1lYSm5kVzFsYm5Sek8xeHVJQ0IyWVhJZ2JHVnVJRDBnWVhKbmN5NXNaVzVuZEdnN1hHNGdJSFpoY2lCemRISWdQU0JUZEhKcGJtY29aaWt1Y21Wd2JHRmpaU2htYjNKdFlYUlNaV2RGZUhBc0lHWjFibU4wYVc5dUtIZ3BJSHRjYmlBZ0lDQnBaaUFvZUNBOVBUMGdKeVVsSnlrZ2NtVjBkWEp1SUNjbEp6dGNiaUFnSUNCcFppQW9hU0ErUFNCc1pXNHBJSEpsZEhWeWJpQjRPMXh1SUNBZ0lITjNhWFJqYUNBb2VDa2dlMXh1SUNBZ0lDQWdZMkZ6WlNBbkpYTW5PaUJ5WlhSMWNtNGdVM1J5YVc1bktHRnlaM05iYVNzclhTazdYRzRnSUNBZ0lDQmpZWE5sSUNjbFpDYzZJSEpsZEhWeWJpQk9kVzFpWlhJb1lYSm5jMXRwS3l0ZEtUdGNiaUFnSUNBZ0lHTmhjMlVnSnlWcUp6cGNiaUFnSUNBZ0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z1NsTlBUaTV6ZEhKcGJtZHBabmtvWVhKbmMxdHBLeXRkS1R0Y2JpQWdJQ0FnSUNBZ2ZTQmpZWFJqYUNBb1h5a2dlMXh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUFuVzBOcGNtTjFiR0Z5WFNjN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lHUmxabUYxYkhRNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCNE8xeHVJQ0FnSUgxY2JpQWdmU2s3WEc0Z0lHWnZjaUFvZG1GeUlIZ2dQU0JoY21kelcybGRPeUJwSUR3Z2JHVnVPeUI0SUQwZ1lYSm5jMXNySzJsZEtTQjdYRzRnSUNBZ2FXWWdLR2x6VG5Wc2JDaDRLU0I4ZkNBaGFYTlBZbXBsWTNRb2VDa3BJSHRjYmlBZ0lDQWdJSE4wY2lBclBTQW5JQ2NnS3lCNE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J6ZEhJZ0t6MGdKeUFuSUNzZ2FXNXpjR1ZqZENoNEtUdGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUhOMGNqdGNibjA3WEc1Y2JseHVMeThnVFdGeWF5QjBhR0YwSUdFZ2JXVjBhRzlrSUhOb2IzVnNaQ0J1YjNRZ1ltVWdkWE5sWkM1Y2JpOHZJRkpsZEhWeWJuTWdZU0J0YjJScFptbGxaQ0JtZFc1amRHbHZiaUIzYUdsamFDQjNZWEp1Y3lCdmJtTmxJR0o1SUdSbFptRjFiSFF1WEc0dkx5QkpaaUF0TFc1dkxXUmxjSEpsWTJGMGFXOXVJR2x6SUhObGRDd2dkR2hsYmlCcGRDQnBjeUJoSUc1dkxXOXdMbHh1Wlhod2IzSjBjeTVrWlhCeVpXTmhkR1VnUFNCbWRXNWpkR2x2YmlobWJpd2diWE5uS1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnY0hKdlkyVnpjeUFoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dKaVlnY0hKdlkyVnpjeTV1YjBSbGNISmxZMkYwYVc5dUlEMDlQU0IwY25WbEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdadU8xeHVJQ0I5WEc1Y2JpQWdMeThnUVd4c2IzY2dabTl5SUdSbGNISmxZMkYwYVc1bklIUm9hVzVuY3lCcGJpQjBhR1VnY0hKdlkyVnpjeUJ2WmlCemRHRnlkR2x1WnlCMWNDNWNiaUFnYVdZZ0tIUjVjR1Z2WmlCd2NtOWpaWE56SUQwOVBTQW5kVzVrWldacGJtVmtKeWtnZTF4dUlDQWdJSEpsZEhWeWJpQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmxlSEJ2Y25SekxtUmxjSEpsWTJGMFpTaG1iaXdnYlhObktTNWhjSEJzZVNoMGFHbHpMQ0JoY21kMWJXVnVkSE1wTzF4dUlDQWdJSDA3WEc0Z0lIMWNibHh1SUNCMllYSWdkMkZ5Ym1Wa0lEMGdabUZzYzJVN1hHNGdJR1oxYm1OMGFXOXVJR1JsY0hKbFkyRjBaV1FvS1NCN1hHNGdJQ0FnYVdZZ0tDRjNZWEp1WldRcElIdGNiaUFnSUNBZ0lHbG1JQ2h3Y205alpYTnpMblJvY205M1JHVndjbVZqWVhScGIyNHBJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLRzF6WnlrN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tIQnliMk5sYzNNdWRISmhZMlZFWlhCeVpXTmhkR2x2YmlrZ2UxeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExuUnlZV05sS0cxelp5azdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0cxelp5azdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQjNZWEp1WldRZ1BTQjBjblZsTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWFIxY200Z1ptNHVZWEJ3Ykhrb2RHaHBjeXdnWVhKbmRXMWxiblJ6S1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCa1pYQnlaV05oZEdWa08xeHVmVHRjYmx4dVhHNTJZWElnWkdWaWRXZHpJRDBnZTMwN1hHNTJZWElnWkdWaWRXZEZiblpTWldkbGVDQTlJQzllSkM4N1hHNWNibWxtSUNod2NtOWpaWE56TG1WdWRpNU9UMFJGWDBSRlFsVkhLU0I3WEc0Z0lIWmhjaUJrWldKMVowVnVkaUE5SUhCeWIyTmxjM011Wlc1MkxrNVBSRVZmUkVWQ1ZVYzdYRzRnSUdSbFluVm5SVzUySUQwZ1pHVmlkV2RGYm5ZdWNtVndiR0ZqWlNndlczeGNYRnhjZTMwb0tWdGNYRjFlSkNzL0xsMHZaeXdnSjF4Y1hGd2tKaWNwWEc0Z0lDQWdMbkpsY0d4aFkyVW9MMXhjS2k5bkxDQW5MaW9uS1Z4dUlDQWdJQzV5WlhCc1lXTmxLQzhzTDJjc0lDY2tmRjRuS1Z4dUlDQWdJQzUwYjFWd2NHVnlRMkZ6WlNncE8xeHVJQ0JrWldKMVowVnVkbEpsWjJWNElEMGdibVYzSUZKbFowVjRjQ2duWGljZ0t5QmtaV0oxWjBWdWRpQXJJQ2NrSnl3Z0oya25LVHRjYm4xY2JtVjRjRzl5ZEhNdVpHVmlkV2RzYjJjZ1BTQm1kVzVqZEdsdmJpaHpaWFFwSUh0Y2JpQWdjMlYwSUQwZ2MyVjBMblJ2VlhCd1pYSkRZWE5sS0NrN1hHNGdJR2xtSUNnaFpHVmlkV2R6VzNObGRGMHBJSHRjYmlBZ0lDQnBaaUFvWkdWaWRXZEZiblpTWldkbGVDNTBaWE4wS0hObGRDa3BJSHRjYmlBZ0lDQWdJSFpoY2lCd2FXUWdQU0J3Y205alpYTnpMbkJwWkR0Y2JpQWdJQ0FnSUdSbFluVm5jMXR6WlhSZElEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQnRjMmNnUFNCbGVIQnZjblJ6TG1admNtMWhkQzVoY0hCc2VTaGxlSEJ2Y25SekxDQmhjbWQxYldWdWRITXBPMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMbVZ5Y205eUtDY2xjeUFsWkRvZ0pYTW5MQ0J6WlhRc0lIQnBaQ3dnYlhObktUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdSbFluVm5jMXR6WlhSZElEMGdablZ1WTNScGIyNG9LU0I3ZlR0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJR1JsWW5WbmMxdHpaWFJkTzF4dWZUdGNibHh1WEc0dktpcGNiaUFxSUVWamFHOXpJSFJvWlNCMllXeDFaU0J2WmlCaElIWmhiSFZsTGlCVWNubHpJSFJ2SUhCeWFXNTBJSFJvWlNCMllXeDFaU0J2ZFhSY2JpQXFJR2x1SUhSb1pTQmlaWE4wSUhkaGVTQndiM056YVdKc1pTQm5hWFpsYmlCMGFHVWdaR2xtWm1WeVpXNTBJSFI1Y0dWekxseHVJQ3BjYmlBcUlFQndZWEpoYlNCN1QySnFaV04wZlNCdlltb2dWR2hsSUc5aWFtVmpkQ0IwYnlCd2NtbHVkQ0J2ZFhRdVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdiM0IwY3lCUGNIUnBiMjVoYkNCdmNIUnBiMjV6SUc5aWFtVmpkQ0IwYUdGMElHRnNkR1Z5Y3lCMGFHVWdiM1YwY0hWMExseHVJQ292WEc0dktpQnNaV2RoWTNrNklHOWlhaXdnYzJodmQwaHBaR1JsYml3Z1pHVndkR2dzSUdOdmJHOXljeW92WEc1bWRXNWpkR2x2YmlCcGJuTndaV04wS0c5aWFpd2diM0IwY3lrZ2UxeHVJQ0F2THlCa1pXWmhkV3gwSUc5d2RHbHZibk5jYmlBZ2RtRnlJR04wZUNBOUlIdGNiaUFnSUNCelpXVnVPaUJiWFN4Y2JpQWdJQ0J6ZEhsc2FYcGxPaUJ6ZEhsc2FYcGxUbTlEYjJ4dmNseHVJQ0I5TzF4dUlDQXZMeUJzWldkaFkza3VMaTVjYmlBZ2FXWWdLR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ2dQajBnTXlrZ1kzUjRMbVJsY0hSb0lEMGdZWEpuZFcxbGJuUnpXekpkTzF4dUlDQnBaaUFvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0ErUFNBMEtTQmpkSGd1WTI5c2IzSnpJRDBnWVhKbmRXMWxiblJ6V3pOZE8xeHVJQ0JwWmlBb2FYTkNiMjlzWldGdUtHOXdkSE1wS1NCN1hHNGdJQ0FnTHk4Z2JHVm5ZV041TGk0dVhHNGdJQ0FnWTNSNExuTm9iM2RJYVdSa1pXNGdQU0J2Y0hSek8xeHVJQ0I5SUdWc2MyVWdhV1lnS0c5d2RITXBJSHRjYmlBZ0lDQXZMeUJuYjNRZ1lXNGdYQ0p2Y0hScGIyNXpYQ0lnYjJKcVpXTjBYRzRnSUNBZ1pYaHdiM0owY3k1ZlpYaDBaVzVrS0dOMGVDd2diM0IwY3lrN1hHNGdJSDFjYmlBZ0x5OGdjMlYwSUdSbFptRjFiSFFnYjNCMGFXOXVjMXh1SUNCcFppQW9hWE5WYm1SbFptbHVaV1FvWTNSNExuTm9iM2RJYVdSa1pXNHBLU0JqZEhndWMyaHZkMGhwWkdSbGJpQTlJR1poYkhObE8xeHVJQ0JwWmlBb2FYTlZibVJsWm1sdVpXUW9ZM1I0TG1SbGNIUm9LU2tnWTNSNExtUmxjSFJvSUQwZ01qdGNiaUFnYVdZZ0tHbHpWVzVrWldacGJtVmtLR04wZUM1amIyeHZjbk1wS1NCamRIZ3VZMjlzYjNKeklEMGdabUZzYzJVN1hHNGdJR2xtSUNocGMxVnVaR1ZtYVc1bFpDaGpkSGd1WTNWemRHOXRTVzV6Y0dWamRDa3BJR04wZUM1amRYTjBiMjFKYm5Od1pXTjBJRDBnZEhKMVpUdGNiaUFnYVdZZ0tHTjBlQzVqYjJ4dmNuTXBJR04wZUM1emRIbHNhWHBsSUQwZ2MzUjViR2w2WlZkcGRHaERiMnh2Y2p0Y2JpQWdjbVYwZFhKdUlHWnZjbTFoZEZaaGJIVmxLR04wZUN3Z2IySnFMQ0JqZEhndVpHVndkR2dwTzF4dWZWeHVaWGh3YjNKMGN5NXBibk53WldOMElEMGdhVzV6Y0dWamREdGNibHh1WEc0dkx5Qm9kSFJ3T2k4dlpXNHVkMmxyYVhCbFpHbGhMbTl5Wnk5M2FXdHBMMEZPVTBsZlpYTmpZWEJsWDJOdlpHVWpaM0poY0docFkzTmNibWx1YzNCbFkzUXVZMjlzYjNKeklEMGdlMXh1SUNBblltOXNaQ2NnT2lCYk1Td2dNakpkTEZ4dUlDQW5hWFJoYkdsakp5QTZJRnN6TENBeU0xMHNYRzRnSUNkMWJtUmxjbXhwYm1VbklEb2dXelFzSURJMFhTeGNiaUFnSjJsdWRtVnljMlVuSURvZ1d6Y3NJREkzWFN4Y2JpQWdKM2RvYVhSbEp5QTZJRnN6Tnl3Z016bGRMRnh1SUNBblozSmxlU2NnT2lCYk9UQXNJRE01WFN4Y2JpQWdKMkpzWVdOckp5QTZJRnN6TUN3Z016bGRMRnh1SUNBbllteDFaU2NnT2lCYk16UXNJRE01WFN4Y2JpQWdKMk41WVc0bklEb2dXek0yTENBek9WMHNYRzRnSUNkbmNtVmxiaWNnT2lCYk16SXNJRE01WFN4Y2JpQWdKMjFoWjJWdWRHRW5JRG9nV3pNMUxDQXpPVjBzWEc0Z0lDZHlaV1FuSURvZ1d6TXhMQ0F6T1Ywc1hHNGdJQ2Q1Wld4c2IzY25JRG9nV3pNekxDQXpPVjFjYm4wN1hHNWNiaTh2SUVSdmJpZDBJSFZ6WlNBbllteDFaU2NnYm05MElIWnBjMmxpYkdVZ2IyNGdZMjFrTG1WNFpWeHVhVzV6Y0dWamRDNXpkSGxzWlhNZ1BTQjdYRzRnSUNkemNHVmphV0ZzSnpvZ0oyTjVZVzRuTEZ4dUlDQW5iblZ0WW1WeUp6b2dKM2xsYkd4dmR5Y3NYRzRnSUNkaWIyOXNaV0Z1SnpvZ0ozbGxiR3h2ZHljc1hHNGdJQ2QxYm1SbFptbHVaV1FuT2lBblozSmxlU2NzWEc0Z0lDZHVkV3hzSnpvZ0oySnZiR1FuTEZ4dUlDQW5jM1J5YVc1bkp6b2dKMmR5WldWdUp5eGNiaUFnSjJSaGRHVW5PaUFuYldGblpXNTBZU2NzWEc0Z0lDOHZJRndpYm1GdFpWd2lPaUJwYm5SbGJuUnBiMjVoYkd4NUlHNXZkQ0J6ZEhsc2FXNW5YRzRnSUNkeVpXZGxlSEFuT2lBbmNtVmtKMXh1ZlR0Y2JseHVYRzVtZFc1amRHbHZiaUJ6ZEhsc2FYcGxWMmwwYUVOdmJHOXlLSE4wY2l3Z2MzUjViR1ZVZVhCbEtTQjdYRzRnSUhaaGNpQnpkSGxzWlNBOUlHbHVjM0JsWTNRdWMzUjViR1Z6VzNOMGVXeGxWSGx3WlYwN1hHNWNiaUFnYVdZZ0tITjBlV3hsS1NCN1hHNGdJQ0FnY21WMGRYSnVJQ2RjWEhVd01ERmlXeWNnS3lCcGJuTndaV04wTG1OdmJHOXljMXR6ZEhsc1pWMWJNRjBnS3lBbmJTY2dLeUJ6ZEhJZ0sxeHVJQ0FnSUNBZ0lDQWdJQ0FuWEZ4MU1EQXhZbHNuSUNzZ2FXNXpjR1ZqZEM1amIyeHZjbk5iYzNSNWJHVmRXekZkSUNzZ0oyMG5PMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsZEhWeWJpQnpkSEk3WEc0Z0lIMWNibjFjYmx4dVhHNW1kVzVqZEdsdmJpQnpkSGxzYVhwbFRtOURiMnh2Y2loemRISXNJSE4wZVd4bFZIbHdaU2tnZTF4dUlDQnlaWFIxY200Z2MzUnlPMXh1ZlZ4dVhHNWNibVoxYm1OMGFXOXVJR0Z5Y21GNVZHOUlZWE5vS0dGeWNtRjVLU0I3WEc0Z0lIWmhjaUJvWVhOb0lEMGdlMzA3WEc1Y2JpQWdZWEp5WVhrdVptOXlSV0ZqYUNobWRXNWpkR2x2YmloMllXd3NJR2xrZUNrZ2UxeHVJQ0FnSUdoaGMyaGJkbUZzWFNBOUlIUnlkV1U3WEc0Z0lIMHBPMXh1WEc0Z0lISmxkSFZ5YmlCb1lYTm9PMXh1ZlZ4dVhHNWNibVoxYm1OMGFXOXVJR1p2Y20xaGRGWmhiSFZsS0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeWtnZTF4dUlDQXZMeUJRY205MmFXUmxJR0VnYUc5dmF5Qm1iM0lnZFhObGNpMXpjR1ZqYVdacFpXUWdhVzV6Y0dWamRDQm1kVzVqZEdsdmJuTXVYRzRnSUM4dklFTm9aV05ySUhSb1lYUWdkbUZzZFdVZ2FYTWdZVzRnYjJKcVpXTjBJSGRwZEdnZ1lXNGdhVzV6Y0dWamRDQm1kVzVqZEdsdmJpQnZiaUJwZEZ4dUlDQnBaaUFvWTNSNExtTjFjM1J2YlVsdWMzQmxZM1FnSmlaY2JpQWdJQ0FnSUhaaGJIVmxJQ1ltWEc0Z0lDQWdJQ0JwYzBaMWJtTjBhVzl1S0haaGJIVmxMbWx1YzNCbFkzUXBJQ1ltWEc0Z0lDQWdJQ0F2THlCR2FXeDBaWElnYjNWMElIUm9aU0IxZEdsc0lHMXZaSFZzWlN3Z2FYUW5jeUJwYm5Od1pXTjBJR1oxYm1OMGFXOXVJR2x6SUhOd1pXTnBZV3hjYmlBZ0lDQWdJSFpoYkhWbExtbHVjM0JsWTNRZ0lUMDlJR1Y0Y0c5eWRITXVhVzV6Y0dWamRDQW1KbHh1SUNBZ0lDQWdMeThnUVd4emJ5Qm1hV3gwWlhJZ2IzVjBJR0Z1ZVNCd2NtOTBiM1I1Y0dVZ2IySnFaV04wY3lCMWMybHVaeUIwYUdVZ1kybHlZM1ZzWVhJZ1kyaGxZMnN1WEc0Z0lDQWdJQ0FoS0haaGJIVmxMbU52Ym5OMGNuVmpkRzl5SUNZbUlIWmhiSFZsTG1OdmJuTjBjblZqZEc5eUxuQnliM1J2ZEhsd1pTQTlQVDBnZG1Gc2RXVXBLU0I3WEc0Z0lDQWdkbUZ5SUhKbGRDQTlJSFpoYkhWbExtbHVjM0JsWTNRb2NtVmpkWEp6WlZScGJXVnpMQ0JqZEhncE8xeHVJQ0FnSUdsbUlDZ2hhWE5UZEhKcGJtY29jbVYwS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBJRDBnWm05eWJXRjBWbUZzZFdVb1kzUjRMQ0J5WlhRc0lISmxZM1Z5YzJWVWFXMWxjeWs3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCeVpYUTdYRzRnSUgxY2JseHVJQ0F2THlCUWNtbHRhWFJwZG1VZ2RIbHdaWE1nWTJGdWJtOTBJR2hoZG1VZ2NISnZjR1Z5ZEdsbGMxeHVJQ0IyWVhJZ2NISnBiV2wwYVhabElEMGdabTl5YldGMFVISnBiV2wwYVhabEtHTjBlQ3dnZG1Gc2RXVXBPMXh1SUNCcFppQW9jSEpwYldsMGFYWmxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlIQnlhVzFwZEdsMlpUdGNiaUFnZlZ4dVhHNGdJQzh2SUV4dmIyc2dkWEFnZEdobElHdGxlWE1nYjJZZ2RHaGxJRzlpYW1WamRDNWNiaUFnZG1GeUlHdGxlWE1nUFNCUFltcGxZM1F1YTJWNWN5aDJZV3gxWlNrN1hHNGdJSFpoY2lCMmFYTnBZbXhsUzJWNWN5QTlJR0Z5Y21GNVZHOUlZWE5vS0d0bGVYTXBPMXh1WEc0Z0lHbG1JQ2hqZEhndWMyaHZkMGhwWkdSbGJpa2dlMXh1SUNBZ0lHdGxlWE1nUFNCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbE9ZVzFsY3loMllXeDFaU2s3WEc0Z0lIMWNibHh1SUNBdkx5QkpSU0JrYjJWemJpZDBJRzFoYTJVZ1pYSnliM0lnWm1sbGJHUnpJRzV2YmkxbGJuVnRaWEpoWW14bFhHNGdJQzh2SUdoMGRIQTZMeTl0YzJSdUxtMXBZM0p2YzI5bWRDNWpiMjB2Wlc0dGRYTXZiR2xpY21GeWVTOXBaUzlrZDNjMU1uTmlkQ2gyUFhaekxqazBLUzVoYzNCNFhHNGdJR2xtSUNocGMwVnljbTl5S0haaGJIVmxLVnh1SUNBZ0lDQWdKaVlnS0d0bGVYTXVhVzVrWlhoUFppZ25iV1Z6YzJGblpTY3BJRDQ5SURBZ2ZId2dhMlY1Y3k1cGJtUmxlRTltS0Nka1pYTmpjbWx3ZEdsdmJpY3BJRDQ5SURBcEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdadmNtMWhkRVZ5Y205eUtIWmhiSFZsS1R0Y2JpQWdmVnh1WEc0Z0lDOHZJRk52YldVZ2RIbHdaU0J2WmlCdlltcGxZM1FnZDJsMGFHOTFkQ0J3Y205d1pYSjBhV1Z6SUdOaGJpQmlaU0J6YUc5eWRHTjFkSFJsWkM1Y2JpQWdhV1lnS0d0bGVYTXViR1Z1WjNSb0lEMDlQU0F3S1NCN1hHNGdJQ0FnYVdZZ0tHbHpSblZ1WTNScGIyNG9kbUZzZFdVcEtTQjdYRzRnSUNBZ0lDQjJZWElnYm1GdFpTQTlJSFpoYkhWbExtNWhiV1VnUHlBbk9pQW5JQ3NnZG1Gc2RXVXVibUZ0WlNBNklDY25PMXh1SUNBZ0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLQ2RiUm5WdVkzUnBiMjRuSUNzZ2JtRnRaU0FySUNkZEp5d2dKM053WldOcFlXd25LVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR2x6VW1WblJYaHdLSFpoYkhWbEtTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLRkpsWjBWNGNDNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY3VZMkZzYkNoMllXeDFaU2tzSUNkeVpXZGxlSEFuS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0dselJHRjBaU2gyWVd4MVpTa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmpkSGd1YzNSNWJHbDZaU2hFWVhSbExuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5NWpZV3hzS0haaGJIVmxLU3dnSjJSaGRHVW5LVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR2x6UlhKeWIzSW9kbUZzZFdVcEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1ptOXliV0YwUlhKeWIzSW9kbUZzZFdVcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lIWmhjaUJpWVhObElEMGdKeWNzSUdGeWNtRjVJRDBnWm1Gc2MyVXNJR0p5WVdObGN5QTlJRnNuZXljc0lDZDlKMTA3WEc1Y2JpQWdMeThnVFdGclpTQkJjbkpoZVNCellYa2dkR2hoZENCMGFHVjVJR0Z5WlNCQmNuSmhlVnh1SUNCcFppQW9hWE5CY25KaGVTaDJZV3gxWlNrcElIdGNiaUFnSUNCaGNuSmhlU0E5SUhSeWRXVTdYRzRnSUNBZ1luSmhZMlZ6SUQwZ1d5ZGJKeXdnSjEwblhUdGNiaUFnZlZ4dVhHNGdJQzh2SUUxaGEyVWdablZ1WTNScGIyNXpJSE5oZVNCMGFHRjBJSFJvWlhrZ1lYSmxJR1oxYm1OMGFXOXVjMXh1SUNCcFppQW9hWE5HZFc1amRHbHZiaWgyWVd4MVpTa3BJSHRjYmlBZ0lDQjJZWElnYmlBOUlIWmhiSFZsTG01aGJXVWdQeUFuT2lBbklDc2dkbUZzZFdVdWJtRnRaU0E2SUNjbk8xeHVJQ0FnSUdKaGMyVWdQU0FuSUZ0R2RXNWpkR2x2YmljZ0t5QnVJQ3NnSjEwbk8xeHVJQ0I5WEc1Y2JpQWdMeThnVFdGclpTQlNaV2RGZUhCeklITmhlU0IwYUdGMElIUm9aWGtnWVhKbElGSmxaMFY0Y0hOY2JpQWdhV1lnS0dselVtVm5SWGh3S0haaGJIVmxLU2tnZTF4dUlDQWdJR0poYzJVZ1BTQW5JQ2NnS3lCU1pXZEZlSEF1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29kbUZzZFdVcE8xeHVJQ0I5WEc1Y2JpQWdMeThnVFdGclpTQmtZWFJsY3lCM2FYUm9JSEJ5YjNCbGNuUnBaWE1nWm1seWMzUWdjMkY1SUhSb1pTQmtZWFJsWEc0Z0lHbG1JQ2hwYzBSaGRHVW9kbUZzZFdVcEtTQjdYRzRnSUNBZ1ltRnpaU0E5SUNjZ0p5QXJJRVJoZEdVdWNISnZkRzkwZVhCbExuUnZWVlJEVTNSeWFXNW5MbU5oYkd3b2RtRnNkV1VwTzF4dUlDQjlYRzVjYmlBZ0x5OGdUV0ZyWlNCbGNuSnZjaUIzYVhSb0lHMWxjM05oWjJVZ1ptbHljM1FnYzJGNUlIUm9aU0JsY25KdmNseHVJQ0JwWmlBb2FYTkZjbkp2Y2loMllXeDFaU2twSUh0Y2JpQWdJQ0JpWVhObElEMGdKeUFuSUNzZ1ptOXliV0YwUlhKeWIzSW9kbUZzZFdVcE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0d0bGVYTXViR1Z1WjNSb0lEMDlQU0F3SUNZbUlDZ2hZWEp5WVhrZ2ZId2dkbUZzZFdVdWJHVnVaM1JvSUQwOUlEQXBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHSnlZV05sYzFzd1hTQXJJR0poYzJVZ0t5QmljbUZqWlhOYk1WMDdYRzRnSUgxY2JseHVJQ0JwWmlBb2NtVmpkWEp6WlZScGJXVnpJRHdnTUNrZ2UxeHVJQ0FnSUdsbUlDaHBjMUpsWjBWNGNDaDJZV3gxWlNrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCamRIZ3VjM1I1YkdsNlpTaFNaV2RGZUhBdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bkxtTmhiR3dvZG1Gc2RXVXBMQ0FuY21WblpYaHdKeWs3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCamRIZ3VjM1I1YkdsNlpTZ25XMDlpYW1WamRGMG5MQ0FuYzNCbFkybGhiQ2NwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdOMGVDNXpaV1Z1TG5CMWMyZ29kbUZzZFdVcE8xeHVYRzRnSUhaaGNpQnZkWFJ3ZFhRN1hHNGdJR2xtSUNoaGNuSmhlU2tnZTF4dUlDQWdJRzkxZEhCMWRDQTlJR1p2Y20xaGRFRnljbUY1S0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeXdnZG1semFXSnNaVXRsZVhNc0lHdGxlWE1wTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUc5MWRIQjFkQ0E5SUd0bGVYTXViV0Z3S0daMWJtTjBhVzl1S0d0bGVTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHWnZjbTFoZEZCeWIzQmxjblI1S0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeXdnZG1semFXSnNaVXRsZVhNc0lHdGxlU3dnWVhKeVlYa3BPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNWNiaUFnWTNSNExuTmxaVzR1Y0c5d0tDazdYRzVjYmlBZ2NtVjBkWEp1SUhKbFpIVmpaVlJ2VTJsdVoyeGxVM1J5YVc1bktHOTFkSEIxZEN3Z1ltRnpaU3dnWW5KaFkyVnpLVHRjYm4xY2JseHVYRzVtZFc1amRHbHZiaUJtYjNKdFlYUlFjbWx0YVhScGRtVW9ZM1I0TENCMllXeDFaU2tnZTF4dUlDQnBaaUFvYVhOVmJtUmxabWx1WldRb2RtRnNkV1VwS1Z4dUlDQWdJSEpsZEhWeWJpQmpkSGd1YzNSNWJHbDZaU2duZFc1a1pXWnBibVZrSnl3Z0ozVnVaR1ZtYVc1bFpDY3BPMXh1SUNCcFppQW9hWE5UZEhKcGJtY29kbUZzZFdVcEtTQjdYRzRnSUNBZ2RtRnlJSE5wYlhCc1pTQTlJQ2RjWENjbklDc2dTbE5QVGk1emRISnBibWRwWm5rb2RtRnNkV1VwTG5KbGNHeGhZMlVvTDE1Y0lueGNJaVF2Wnl3Z0p5Y3BYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F1Y21Wd2JHRmpaU2d2Snk5bkxDQmNJbHhjWEZ3blhDSXBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F1Y21Wd2JHRmpaU2d2WEZ4Y1hGd2lMMmNzSUNkY0lpY3BJQ3NnSjF4Y0p5YzdYRzRnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtITnBiWEJzWlN3Z0ozTjBjbWx1WnljcE8xeHVJQ0I5WEc0Z0lHbG1JQ2hwYzA1MWJXSmxjaWgyWVd4MVpTa3BYRzRnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtDY25JQ3NnZG1Gc2RXVXNJQ2R1ZFcxaVpYSW5LVHRjYmlBZ2FXWWdLR2x6UW05dmJHVmhiaWgyWVd4MVpTa3BYRzRnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtDY25JQ3NnZG1Gc2RXVXNJQ2RpYjI5c1pXRnVKeWs3WEc0Z0lDOHZJRVp2Y2lCemIyMWxJSEpsWVhOdmJpQjBlWEJsYjJZZ2JuVnNiQ0JwY3lCY0ltOWlhbVZqZEZ3aUxDQnpieUJ6Y0dWamFXRnNJR05oYzJVZ2FHVnlaUzVjYmlBZ2FXWWdLR2x6VG5Wc2JDaDJZV3gxWlNrcFhHNGdJQ0FnY21WMGRYSnVJR04wZUM1emRIbHNhWHBsS0NkdWRXeHNKeXdnSjI1MWJHd25LVHRjYm4xY2JseHVYRzVtZFc1amRHbHZiaUJtYjNKdFlYUkZjbkp2Y2loMllXeDFaU2tnZTF4dUlDQnlaWFIxY200Z0oxc25JQ3NnUlhKeWIzSXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5MbU5oYkd3b2RtRnNkV1VwSUNzZ0oxMG5PMXh1ZlZ4dVhHNWNibVoxYm1OMGFXOXVJR1p2Y20xaGRFRnljbUY1S0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeXdnZG1semFXSnNaVXRsZVhNc0lHdGxlWE1wSUh0Y2JpQWdkbUZ5SUc5MWRIQjFkQ0E5SUZ0ZE8xeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Dd2diQ0E5SUhaaGJIVmxMbXhsYm1kMGFEc2dhU0E4SUd3N0lDc3JhU2tnZTF4dUlDQWdJR2xtSUNob1lYTlBkMjVRY205d1pYSjBlU2gyWVd4MVpTd2dVM1J5YVc1bktHa3BLU2tnZTF4dUlDQWdJQ0FnYjNWMGNIVjBMbkIxYzJnb1ptOXliV0YwVUhKdmNHVnlkSGtvWTNSNExDQjJZV3gxWlN3Z2NtVmpkWEp6WlZScGJXVnpMQ0IyYVhOcFlteGxTMlY1Y3l4Y2JpQWdJQ0FnSUNBZ0lDQlRkSEpwYm1jb2FTa3NJSFJ5ZFdVcEtUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnYjNWMGNIVjBMbkIxYzJnb0p5Y3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQnJaWGx6TG1admNrVmhZMmdvWm5WdVkzUnBiMjRvYTJWNUtTQjdYRzRnSUNBZ2FXWWdLQ0ZyWlhrdWJXRjBZMmdvTDE1Y1hHUXJKQzhwS1NCN1hHNGdJQ0FnSUNCdmRYUndkWFF1Y0hWemFDaG1iM0p0WVhSUWNtOXdaWEowZVNoamRIZ3NJSFpoYkhWbExDQnlaV04xY25ObFZHbHRaWE1zSUhacGMybGliR1ZMWlhsekxGeHVJQ0FnSUNBZ0lDQWdJR3RsZVN3Z2RISjFaU2twTzF4dUlDQWdJSDFjYmlBZ2ZTazdYRzRnSUhKbGRIVnliaUJ2ZFhSd2RYUTdYRzU5WEc1Y2JseHVablZ1WTNScGIyNGdabTl5YldGMFVISnZjR1Z5ZEhrb1kzUjRMQ0IyWVd4MVpTd2djbVZqZFhKelpWUnBiV1Z6TENCMmFYTnBZbXhsUzJWNWN5d2dhMlY1TENCaGNuSmhlU2tnZTF4dUlDQjJZWElnYm1GdFpTd2djM1J5TENCa1pYTmpPMXh1SUNCa1pYTmpJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNpaDJZV3gxWlN3Z2EyVjVLU0I4ZkNCN0lIWmhiSFZsT2lCMllXeDFaVnRyWlhsZElIMDdYRzRnSUdsbUlDaGtaWE5qTG1kbGRDa2dlMXh1SUNBZ0lHbG1JQ2hrWlhOakxuTmxkQ2tnZTF4dUlDQWdJQ0FnYzNSeUlEMGdZM1I0TG5OMGVXeHBlbVVvSjF0SFpYUjBaWEl2VTJWMGRHVnlYU2NzSUNkemNHVmphV0ZzSnlrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSE4wY2lBOUlHTjBlQzV6ZEhsc2FYcGxLQ2RiUjJWMGRHVnlYU2NzSUNkemNHVmphV0ZzSnlrN1hHNGdJQ0FnZlZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdsbUlDaGtaWE5qTG5ObGRDa2dlMXh1SUNBZ0lDQWdjM1J5SUQwZ1kzUjRMbk4wZVd4cGVtVW9KMXRUWlhSMFpYSmRKeXdnSjNOd1pXTnBZV3duS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnYVdZZ0tDRm9ZWE5QZDI1UWNtOXdaWEowZVNoMmFYTnBZbXhsUzJWNWN5d2dhMlY1S1NrZ2UxeHVJQ0FnSUc1aGJXVWdQU0FuV3ljZ0t5QnJaWGtnS3lBblhTYzdYRzRnSUgxY2JpQWdhV1lnS0NGemRISXBJSHRjYmlBZ0lDQnBaaUFvWTNSNExuTmxaVzR1YVc1a1pYaFBaaWhrWlhOakxuWmhiSFZsS1NBOElEQXBJSHRjYmlBZ0lDQWdJR2xtSUNocGMwNTFiR3dvY21WamRYSnpaVlJwYldWektTa2dlMXh1SUNBZ0lDQWdJQ0J6ZEhJZ1BTQm1iM0p0WVhSV1lXeDFaU2hqZEhnc0lHUmxjMk11ZG1Gc2RXVXNJRzUxYkd3cE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2MzUnlJRDBnWm05eWJXRjBWbUZzZFdVb1kzUjRMQ0JrWlhOakxuWmhiSFZsTENCeVpXTjFjbk5sVkdsdFpYTWdMU0F4S1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUdsbUlDaHpkSEl1YVc1a1pYaFBaaWduWEZ4dUp5a2dQaUF0TVNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWVhKeVlYa3BJSHRjYmlBZ0lDQWdJQ0FnSUNCemRISWdQU0J6ZEhJdWMzQnNhWFFvSjF4Y2JpY3BMbTFoY0NobWRXNWpkR2x2Ymloc2FXNWxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0p5QWdKeUFySUd4cGJtVTdYRzRnSUNBZ0lDQWdJQ0FnZlNrdWFtOXBiaWduWEZ4dUp5a3VjM1ZpYzNSeUtESXBPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUhOMGNpQTlJQ2RjWEc0bklDc2djM1J5TG5Od2JHbDBLQ2RjWEc0bktTNXRZWEFvWm5WdVkzUnBiMjRvYkdsdVpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUNjZ0lDQW5JQ3NnYkdsdVpUdGNiaUFnSUNBZ0lDQWdJQ0I5S1M1cWIybHVLQ2RjWEc0bktUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCemRISWdQU0JqZEhndWMzUjViR2w2WlNnblcwTnBjbU4xYkdGeVhTY3NJQ2R6Y0dWamFXRnNKeWs3WEc0Z0lDQWdmVnh1SUNCOVhHNGdJR2xtSUNocGMxVnVaR1ZtYVc1bFpDaHVZVzFsS1NrZ2UxeHVJQ0FnSUdsbUlDaGhjbkpoZVNBbUppQnJaWGt1YldGMFkyZ29MMTVjWEdRckpDOHBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdjM1J5TzF4dUlDQWdJSDFjYmlBZ0lDQnVZVzFsSUQwZ1NsTlBUaTV6ZEhKcGJtZHBabmtvSnljZ0t5QnJaWGtwTzF4dUlDQWdJR2xtSUNodVlXMWxMbTFoZEdOb0tDOWVYQ0lvVzJFdGVrRXRXbDlkVzJFdGVrRXRXbDh3TFRsZEtpbGNJaVF2S1NrZ2UxeHVJQ0FnSUNBZ2JtRnRaU0E5SUc1aGJXVXVjM1ZpYzNSeUtERXNJRzVoYldVdWJHVnVaM1JvSUMwZ01pazdYRzRnSUNBZ0lDQnVZVzFsSUQwZ1kzUjRMbk4wZVd4cGVtVW9ibUZ0WlN3Z0oyNWhiV1VuS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdibUZ0WlNBOUlHNWhiV1V1Y21Wd2JHRmpaU2d2Snk5bkxDQmNJbHhjWEZ3blhDSXBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzV5WlhCc1lXTmxLQzljWEZ4Y1hDSXZaeXdnSjF3aUp5bGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMbkpsY0d4aFkyVW9MeWhlWENKOFhDSWtLUzluTENCY0lpZGNJaWs3WEc0Z0lDQWdJQ0J1WVcxbElEMGdZM1I0TG5OMGVXeHBlbVVvYm1GdFpTd2dKM04wY21sdVp5Y3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQnVZVzFsSUNzZ0p6b2dKeUFySUhOMGNqdGNibjFjYmx4dVhHNW1kVzVqZEdsdmJpQnlaV1IxWTJWVWIxTnBibWRzWlZOMGNtbHVaeWh2ZFhSd2RYUXNJR0poYzJVc0lHSnlZV05sY3lrZ2UxeHVJQ0IyWVhJZ2JuVnRUR2x1WlhORmMzUWdQU0F3TzF4dUlDQjJZWElnYkdWdVozUm9JRDBnYjNWMGNIVjBMbkpsWkhWalpTaG1kVzVqZEdsdmJpaHdjbVYyTENCamRYSXBJSHRjYmlBZ0lDQnVkVzFNYVc1bGMwVnpkQ3NyTzF4dUlDQWdJR2xtSUNoamRYSXVhVzVrWlhoUFppZ25YRnh1SnlrZ1BqMGdNQ2tnYm5WdFRHbHVaWE5GYzNRckt6dGNiaUFnSUNCeVpYUjFjbTRnY0hKbGRpQXJJR04xY2k1eVpYQnNZV05sS0M5Y1hIVXdNREZpWEZ4YlhGeGtYRnhrUDIwdlp5d2dKeWNwTG14bGJtZDBhQ0FySURFN1hHNGdJSDBzSURBcE8xeHVYRzRnSUdsbUlDaHNaVzVuZEdnZ1BpQTJNQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQmljbUZqWlhOYk1GMGdLMXh1SUNBZ0lDQWdJQ0FnSUNBb1ltRnpaU0E5UFQwZ0p5Y2dQeUFuSnlBNklHSmhjMlVnS3lBblhGeHVJQ2NwSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdKeUFuSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdiM1YwY0hWMExtcHZhVzRvSnl4Y1hHNGdJQ2NwSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdKeUFuSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdZbkpoWTJWeld6RmRPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR0p5WVdObGMxc3dYU0FySUdKaGMyVWdLeUFuSUNjZ0t5QnZkWFJ3ZFhRdWFtOXBiaWduTENBbktTQXJJQ2NnSnlBcklHSnlZV05sYzFzeFhUdGNibjFjYmx4dVhHNHZMeUJPVDFSRk9pQlVhR1Z6WlNCMGVYQmxJR05vWldOcmFXNW5JR1oxYm1OMGFXOXVjeUJwYm5SbGJuUnBiMjVoYkd4NUlHUnZiaWQwSUhWelpTQmdhVzV6ZEdGdVkyVnZabUJjYmk4dklHSmxZMkYxYzJVZ2FYUWdhWE1nWm5KaFoybHNaU0JoYm1RZ1kyRnVJR0psSUdWaGMybHNlU0JtWVd0bFpDQjNhWFJvSUdCUFltcGxZM1F1WTNKbFlYUmxLQ2xnTGx4dVpYaHdiM0owY3k1MGVYQmxjeUE5SUhKbGNYVnBjbVVvSnk0dmMzVndjRzl5ZEM5MGVYQmxjeWNwTzF4dVhHNW1kVzVqZEdsdmJpQnBjMEZ5Y21GNUtHRnlLU0I3WEc0Z0lISmxkSFZ5YmlCQmNuSmhlUzVwYzBGeWNtRjVLR0Z5S1R0Y2JuMWNibVY0Y0c5eWRITXVhWE5CY25KaGVTQTlJR2x6UVhKeVlYazdYRzVjYm1aMWJtTjBhVzl1SUdselFtOXZiR1ZoYmloaGNtY3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJoY21jZ1BUMDlJQ2RpYjI5c1pXRnVKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTkNiMjlzWldGdUlEMGdhWE5DYjI5c1pXRnVPMXh1WEc1bWRXNWpkR2x2YmlCcGMwNTFiR3dvWVhKbktTQjdYRzRnSUhKbGRIVnliaUJoY21jZ1BUMDlJRzUxYkd3N1hHNTlYRzVsZUhCdmNuUnpMbWx6VG5Wc2JDQTlJR2x6VG5Wc2JEdGNibHh1Wm5WdVkzUnBiMjRnYVhOT2RXeHNUM0pWYm1SbFptbHVaV1FvWVhKbktTQjdYRzRnSUhKbGRIVnliaUJoY21jZ1BUMGdiblZzYkR0Y2JuMWNibVY0Y0c5eWRITXVhWE5PZFd4c1QzSlZibVJsWm1sdVpXUWdQU0JwYzA1MWJHeFBjbFZ1WkdWbWFXNWxaRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTk9kVzFpWlhJb1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnWVhKbklEMDlQU0FuYm5WdFltVnlKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTk9kVzFpWlhJZ1BTQnBjMDUxYldKbGNqdGNibHh1Wm5WdVkzUnBiMjRnYVhOVGRISnBibWNvWVhKbktTQjdYRzRnSUhKbGRIVnliaUIwZVhCbGIyWWdZWEpuSUQwOVBTQW5jM1J5YVc1bkp6dGNibjFjYm1WNGNHOXlkSE11YVhOVGRISnBibWNnUFNCcGMxTjBjbWx1Wnp0Y2JseHVablZ1WTNScGIyNGdhWE5UZVcxaWIyd29ZWEpuS1NCN1hHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmMzbHRZbTlzSnp0Y2JuMWNibVY0Y0c5eWRITXVhWE5UZVcxaWIyd2dQU0JwYzFONWJXSnZiRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTlZibVJsWm1sdVpXUW9ZWEpuS1NCN1hHNGdJSEpsZEhWeWJpQmhjbWNnUFQwOUlIWnZhV1FnTUR0Y2JuMWNibVY0Y0c5eWRITXVhWE5WYm1SbFptbHVaV1FnUFNCcGMxVnVaR1ZtYVc1bFpEdGNibHh1Wm5WdVkzUnBiMjRnYVhOU1pXZEZlSEFvY21VcElIdGNiaUFnY21WMGRYSnVJR2x6VDJKcVpXTjBLSEpsS1NBbUppQnZZbXBsWTNSVWIxTjBjbWx1WnloeVpTa2dQVDA5SUNkYmIySnFaV04wSUZKbFowVjRjRjBuTzF4dWZWeHVaWGh3YjNKMGN5NXBjMUpsWjBWNGNDQTlJR2x6VW1WblJYaHdPMXh1Wlhod2IzSjBjeTUwZVhCbGN5NXBjMUpsWjBWNGNDQTlJR2x6VW1WblJYaHdPMXh1WEc1bWRXNWpkR2x2YmlCcGMwOWlhbVZqZENoaGNtY3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJoY21jZ1BUMDlJQ2R2WW1wbFkzUW5JQ1ltSUdGeVp5QWhQVDBnYm5Wc2JEdGNibjFjYm1WNGNHOXlkSE11YVhOUFltcGxZM1FnUFNCcGMwOWlhbVZqZER0Y2JseHVablZ1WTNScGIyNGdhWE5FWVhSbEtHUXBJSHRjYmlBZ2NtVjBkWEp1SUdselQySnFaV04wS0dRcElDWW1JRzlpYW1WamRGUnZVM1J5YVc1bktHUXBJRDA5UFNBblcyOWlhbVZqZENCRVlYUmxYU2M3WEc1OVhHNWxlSEJ2Y25SekxtbHpSR0YwWlNBOUlHbHpSR0YwWlR0Y2JtVjRjRzl5ZEhNdWRIbHdaWE11YVhORVlYUmxJRDBnYVhORVlYUmxPMXh1WEc1bWRXNWpkR2x2YmlCcGMwVnljbTl5S0dVcElIdGNiaUFnY21WMGRYSnVJR2x6VDJKcVpXTjBLR1VwSUNZbVhHNGdJQ0FnSUNBb2IySnFaV04wVkc5VGRISnBibWNvWlNrZ1BUMDlJQ2RiYjJKcVpXTjBJRVZ5Y205eVhTY2dmSHdnWlNCcGJuTjBZVzVqWlc5bUlFVnljbTl5S1R0Y2JuMWNibVY0Y0c5eWRITXVhWE5GY25KdmNpQTlJR2x6UlhKeWIzSTdYRzVsZUhCdmNuUnpMblI1Y0dWekxtbHpUbUYwYVhabFJYSnliM0lnUFNCcGMwVnljbTl5TzF4dVhHNW1kVzVqZEdsdmJpQnBjMFoxYm1OMGFXOXVLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0oyWjFibU4wYVc5dUp6dGNibjFjYm1WNGNHOXlkSE11YVhOR2RXNWpkR2x2YmlBOUlHbHpSblZ1WTNScGIyNDdYRzVjYm1aMWJtTjBhVzl1SUdselVISnBiV2wwYVhabEtHRnlaeWtnZTF4dUlDQnlaWFIxY200Z1lYSm5JRDA5UFNCdWRXeHNJSHg4WEc0Z0lDQWdJQ0FnSUNCMGVYQmxiMllnWVhKbklEMDlQU0FuWW05dmJHVmhiaWNnZkh4Y2JpQWdJQ0FnSUNBZ0lIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkdWRXMWlaWEluSUh4OFhHNGdJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmMzUnlhVzVuSnlCOGZGeHVJQ0FnSUNBZ0lDQWdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0ozTjViV0p2YkNjZ2ZId2dJQzh2SUVWVE5pQnplVzFpYjJ4Y2JpQWdJQ0FnSUNBZ0lIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkMWJtUmxabWx1WldRbk8xeHVmVnh1Wlhod2IzSjBjeTVwYzFCeWFXMXBkR2wyWlNBOUlHbHpVSEpwYldsMGFYWmxPMXh1WEc1bGVIQnZjblJ6TG1selFuVm1abVZ5SUQwZ2NtVnhkV2x5WlNnbkxpOXpkWEJ3YjNKMEwybHpRblZtWm1WeUp5azdYRzVjYm1aMWJtTjBhVzl1SUc5aWFtVmpkRlJ2VTNSeWFXNW5LRzhwSUh0Y2JpQWdjbVYwZFhKdUlFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWRHOVRkSEpwYm1jdVkyRnNiQ2h2S1R0Y2JuMWNibHh1WEc1bWRXNWpkR2x2YmlCd1lXUW9iaWtnZTF4dUlDQnlaWFIxY200Z2JpQThJREV3SUQ4Z0p6QW5JQ3NnYmk1MGIxTjBjbWx1WnlneE1Da2dPaUJ1TG5SdlUzUnlhVzVuS0RFd0tUdGNibjFjYmx4dVhHNTJZWElnYlc5dWRHaHpJRDBnV3lkS1lXNG5MQ0FuUm1WaUp5d2dKMDFoY2ljc0lDZEJjSEluTENBblRXRjVKeXdnSjBwMWJpY3NJQ2RLZFd3bkxDQW5RWFZuSnl3Z0oxTmxjQ2NzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ2RQWTNRbkxDQW5UbTkySnl3Z0owUmxZeWRkTzF4dVhHNHZMeUF5TmlCR1pXSWdNVFk2TVRrNk16UmNibVoxYm1OMGFXOXVJSFJwYldWemRHRnRjQ2dwSUh0Y2JpQWdkbUZ5SUdRZ1BTQnVaWGNnUkdGMFpTZ3BPMXh1SUNCMllYSWdkR2x0WlNBOUlGdHdZV1FvWkM1blpYUkliM1Z5Y3lncEtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2NHRmtLR1F1WjJWMFRXbHVkWFJsY3lncEtTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2NHRmtLR1F1WjJWMFUyVmpiMjVrY3lncEtWMHVhbTlwYmlnbk9pY3BPMXh1SUNCeVpYUjFjbTRnVzJRdVoyVjBSR0YwWlNncExDQnRiMjUwYUhOYlpDNW5aWFJOYjI1MGFDZ3BYU3dnZEdsdFpWMHVhbTlwYmlnbklDY3BPMXh1ZlZ4dVhHNWNiaTh2SUd4dlp5QnBjeUJxZFhOMElHRWdkR2hwYmlCM2NtRndjR1Z5SUhSdklHTnZibk52YkdVdWJHOW5JSFJvWVhRZ2NISmxjR1Z1WkhNZ1lTQjBhVzFsYzNSaGJYQmNibVY0Y0c5eWRITXViRzluSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUdOdmJuTnZiR1V1Ykc5bktDY2xjeUF0SUNWekp5d2dkR2x0WlhOMFlXMXdLQ2tzSUdWNGNHOXlkSE11Wm05eWJXRjBMbUZ3Y0d4NUtHVjRjRzl5ZEhNc0lHRnlaM1Z0Wlc1MGN5a3BPMXh1ZlR0Y2JseHVYRzR2S2lwY2JpQXFJRWx1YUdWeWFYUWdkR2hsSUhCeWIzUnZkSGx3WlNCdFpYUm9iMlJ6SUdaeWIyMGdiMjVsSUdOdmJuTjBjblZqZEc5eUlHbHVkRzhnWVc1dmRHaGxjaTVjYmlBcVhHNGdLaUJVYUdVZ1JuVnVZM1JwYjI0dWNISnZkRzkwZVhCbExtbHVhR1Z5YVhSeklHWnliMjBnYkdGdVp5NXFjeUJ5WlhkeWFYUjBaVzRnWVhNZ1lTQnpkR0Z1WkdGc2IyNWxYRzRnS2lCbWRXNWpkR2x2YmlBb2JtOTBJRzl1SUVaMWJtTjBhVzl1TG5CeWIzUnZkSGx3WlNrdUlFNVBWRVU2SUVsbUlIUm9hWE1nWm1sc1pTQnBjeUIwYnlCaVpTQnNiMkZrWldSY2JpQXFJR1IxY21sdVp5QmliMjkwYzNSeVlYQndhVzVuSUhSb2FYTWdablZ1WTNScGIyNGdibVZsWkhNZ2RHOGdZbVVnY21WM2NtbDBkR1Z1SUhWemFXNW5JSE52YldVZ2JtRjBhWFpsWEc0Z0tpQm1kVzVqZEdsdmJuTWdZWE1nY0hKdmRHOTBlWEJsSUhObGRIVndJSFZ6YVc1bklHNXZjbTFoYkNCS1lYWmhVMk55YVhCMElHUnZaWE1nYm05MElIZHZjbXNnWVhOY2JpQXFJR1Y0Y0dWamRHVmtJR1IxY21sdVp5QmliMjkwYzNSeVlYQndhVzVuSUNoelpXVWdiV2x5Y205eUxtcHpJR2x1SUhJeE1UUTVNRE1wTGx4dUlDcGNiaUFxSUVCd1lYSmhiU0I3Wm5WdVkzUnBiMjU5SUdOMGIzSWdRMjl1YzNSeWRXTjBiM0lnWm5WdVkzUnBiMjRnZDJocFkyZ2dibVZsWkhNZ2RHOGdhVzVvWlhKcGRDQjBhR1ZjYmlBcUlDQWdJQ0J3Y205MGIzUjVjR1V1WEc0Z0tpQkFjR0Z5WVcwZ2UyWjFibU4wYVc5dWZTQnpkWEJsY2tOMGIzSWdRMjl1YzNSeWRXTjBiM0lnWm5WdVkzUnBiMjRnZEc4Z2FXNW9aWEpwZENCd2NtOTBiM1I1Y0dVZ1puSnZiUzVjYmlBcUwxeHVaWGh3YjNKMGN5NXBibWhsY21sMGN5QTlJSEpsY1hWcGNtVW9KMmx1YUdWeWFYUnpKeWs3WEc1Y2JtVjRjRzl5ZEhNdVgyVjRkR1Z1WkNBOUlHWjFibU4wYVc5dUtHOXlhV2RwYml3Z1lXUmtLU0I3WEc0Z0lDOHZJRVJ2YmlkMElHUnZJR0Z1ZVhSb2FXNW5JR2xtSUdGa1pDQnBjMjRuZENCaGJpQnZZbXBsWTNSY2JpQWdhV1lnS0NGaFpHUWdmSHdnSVdselQySnFaV04wS0dGa1pDa3BJSEpsZEhWeWJpQnZjbWxuYVc0N1hHNWNiaUFnZG1GeUlHdGxlWE1nUFNCUFltcGxZM1F1YTJWNWN5aGhaR1FwTzF4dUlDQjJZWElnYVNBOUlHdGxlWE11YkdWdVozUm9PMXh1SUNCM2FHbHNaU0FvYVMwdEtTQjdYRzRnSUNBZ2IzSnBaMmx1VzJ0bGVYTmJhVjFkSUQwZ1lXUmtXMnRsZVhOYmFWMWRPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnZjbWxuYVc0N1hHNTlPMXh1WEc1bWRXNWpkR2x2YmlCb1lYTlBkMjVRY205d1pYSjBlU2h2WW1vc0lIQnliM0FwSUh0Y2JpQWdjbVYwZFhKdUlFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWFHRnpUM2R1VUhKdmNHVnlkSGt1WTJGc2JDaHZZbW9zSUhCeWIzQXBPMXh1ZlZ4dVhHNTJZWElnYTBOMWMzUnZiVkJ5YjIxcGMybG1hV1ZrVTNsdFltOXNJRDBnZEhsd1pXOW1JRk41YldKdmJDQWhQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QlRlVzFpYjJ3b0ozVjBhV3d1Y0hKdmJXbHphV1o1TG1OMWMzUnZiU2NwSURvZ2RXNWtaV1pwYm1Wa08xeHVYRzVsZUhCdmNuUnpMbkJ5YjIxcGMybG1lU0E5SUdaMWJtTjBhVzl1SUhCeWIyMXBjMmxtZVNodmNtbG5hVzVoYkNrZ2UxeHVJQ0JwWmlBb2RIbHdaVzltSUc5eWFXZHBibUZzSUNFOVBTQW5ablZ1WTNScGIyNG5LVnh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMVJvWlNCY0ltOXlhV2RwYm1Gc1hDSWdZWEpuZFcxbGJuUWdiWFZ6ZENCaVpTQnZaaUIwZVhCbElFWjFibU4wYVc5dUp5azdYRzVjYmlBZ2FXWWdLR3REZFhOMGIyMVFjbTl0YVhOcFptbGxaRk41YldKdmJDQW1KaUJ2Y21sbmFXNWhiRnRyUTNWemRHOXRVSEp2YldsemFXWnBaV1JUZVcxaWIyeGRLU0I3WEc0Z0lDQWdkbUZ5SUdadUlEMGdiM0pwWjJsdVlXeGJhME4xYzNSdmJWQnliMjFwYzJsbWFXVmtVM2x0WW05c1hUdGNiaUFnSUNCcFppQW9kSGx3Wlc5bUlHWnVJQ0U5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLQ2RVYUdVZ1hDSjFkR2xzTG5CeWIyMXBjMmxtZVM1amRYTjBiMjFjSWlCaGNtZDFiV1Z1ZENCdGRYTjBJR0psSUc5bUlIUjVjR1VnUm5WdVkzUnBiMjRuS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1S0dadUxDQnJRM1Z6ZEc5dFVISnZiV2x6YVdacFpXUlRlVzFpYjJ3c0lIdGNiaUFnSUNBZ0lIWmhiSFZsT2lCbWJpd2daVzUxYldWeVlXSnNaVG9nWm1Gc2MyVXNJSGR5YVhSaFlteGxPaUJtWVd4elpTd2dZMjl1Wm1sbmRYSmhZbXhsT2lCMGNuVmxYRzRnSUNBZ2ZTazdYRzRnSUNBZ2NtVjBkWEp1SUdadU8xeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdabTRvS1NCN1hHNGdJQ0FnZG1GeUlIQnliMjFwYzJWU1pYTnZiSFpsTENCd2NtOXRhWE5sVW1WcVpXTjBPMXh1SUNBZ0lIWmhjaUJ3Y205dGFYTmxJRDBnYm1WM0lGQnliMjFwYzJVb1puVnVZM1JwYjI0Z0tISmxjMjlzZG1Vc0lISmxhbVZqZENrZ2UxeHVJQ0FnSUNBZ2NISnZiV2x6WlZKbGMyOXNkbVVnUFNCeVpYTnZiSFpsTzF4dUlDQWdJQ0FnY0hKdmJXbHpaVkpsYW1WamRDQTlJSEpsYW1WamREdGNiaUFnSUNCOUtUdGNibHh1SUNBZ0lIWmhjaUJoY21keklEMGdXMTA3WEc0Z0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JoY21kMWJXVnVkSE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lHRnlaM011Y0hWemFDaGhjbWQxYldWdWRITmJhVjBwTzF4dUlDQWdJSDFjYmlBZ0lDQmhjbWR6TG5CMWMyZ29ablZ1WTNScGIyNGdLR1Z5Y2l3Z2RtRnNkV1VwSUh0Y2JpQWdJQ0FnSUdsbUlDaGxjbklwSUh0Y2JpQWdJQ0FnSUNBZ2NISnZiV2x6WlZKbGFtVmpkQ2hsY25JcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2NISnZiV2x6WlZKbGMyOXNkbVVvZG1Gc2RXVXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHBPMXh1WEc0Z0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUc5eWFXZHBibUZzTG1Gd2NHeDVLSFJvYVhNc0lHRnlaM01wTzF4dUlDQWdJSDBnWTJGMFkyZ2dLR1Z5Y2lrZ2UxeHVJQ0FnSUNBZ2NISnZiV2x6WlZKbGFtVmpkQ2hsY25JcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUJ3Y205dGFYTmxPMXh1SUNCOVhHNWNiaUFnVDJKcVpXTjBMbk5sZEZCeWIzUnZkSGx3WlU5bUtHWnVMQ0JQWW1wbFkzUXVaMlYwVUhKdmRHOTBlWEJsVDJZb2IzSnBaMmx1WVd3cEtUdGNibHh1SUNCcFppQW9hME4xYzNSdmJWQnliMjFwYzJsbWFXVmtVM2x0WW05c0tTQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvWm00c0lHdERkWE4wYjIxUWNtOXRhWE5wWm1sbFpGTjViV0p2YkN3Z2UxeHVJQ0FnSUhaaGJIVmxPaUJtYml3Z1pXNTFiV1Z5WVdKc1pUb2dabUZzYzJVc0lIZHlhWFJoWW14bE9pQm1ZV3h6WlN3Z1kyOXVabWxuZFhKaFlteGxPaUIwY25WbFhHNGdJSDBwTzF4dUlDQnlaWFIxY200Z1QySnFaV04wTG1SbFptbHVaVkJ5YjNCbGNuUnBaWE1vWEc0Z0lDQWdabTRzWEc0Z0lDQWdaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eWN5aHZjbWxuYVc1aGJDbGNiaUFnS1R0Y2JuMWNibHh1Wlhod2IzSjBjeTV3Y205dGFYTnBabmt1WTNWemRHOXRJRDBnYTBOMWMzUnZiVkJ5YjIxcGMybG1hV1ZrVTNsdFltOXNYRzVjYm1aMWJtTjBhVzl1SUdOaGJHeGlZV05yYVdaNVQyNVNaV3BsWTNSbFpDaHlaV0Z6YjI0c0lHTmlLU0I3WEc0Z0lDOHZJR0FoY21WaGMyOXVZQ0JuZFdGeVpDQnBibk53YVhKbFpDQmllU0JpYkhWbFltbHlaQ0FvVW1WbU9pQm9kSFJ3Y3pvdkwyZHZieTVuYkM5ME5VbFROazBwTGx4dUlDQXZMeUJDWldOaGRYTmxJR0J1ZFd4c1lDQnBjeUJoSUhOd1pXTnBZV3dnWlhKeWIzSWdkbUZzZFdVZ2FXNGdZMkZzYkdKaFkydHpJSGRvYVdOb0lHMWxZVzV6SUZ3aWJtOGdaWEp5YjNKY2JpQWdMeThnYjJOamRYSnlaV1JjSWl3Z2QyVWdaWEp5YjNJdGQzSmhjQ0J6YnlCMGFHVWdZMkZzYkdKaFkyc2dZMjl1YzNWdFpYSWdZMkZ1SUdScGMzUnBibWQxYVhOb0lHSmxkSGRsWlc1Y2JpQWdMeThnWENKMGFHVWdjSEp2YldselpTQnlaV3BsWTNSbFpDQjNhWFJvSUc1MWJHeGNJaUJ2Y2lCY0luUm9aU0J3Y205dGFYTmxJR1oxYkdacGJHeGxaQ0IzYVhSb0lIVnVaR1ZtYVc1bFpGd2lMbHh1SUNCcFppQW9JWEpsWVhOdmJpa2dlMXh1SUNBZ0lIWmhjaUJ1WlhkU1pXRnpiMjRnUFNCdVpYY2dSWEp5YjNJb0oxQnliMjFwYzJVZ2QyRnpJSEpsYW1WamRHVmtJSGRwZEdnZ1lTQm1ZV3h6ZVNCMllXeDFaU2NwTzF4dUlDQWdJRzVsZDFKbFlYTnZiaTV5WldGemIyNGdQU0J5WldGemIyNDdYRzRnSUNBZ2NtVmhjMjl1SUQwZ2JtVjNVbVZoYzI5dU8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCallpaHlaV0Z6YjI0cE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCallXeHNZbUZqYTJsbWVTaHZjbWxuYVc1aGJDa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlHOXlhV2RwYm1Gc0lDRTlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2lnblZHaGxJRndpYjNKcFoybHVZV3hjSWlCaGNtZDFiV1Z1ZENCdGRYTjBJR0psSUc5bUlIUjVjR1VnUm5WdVkzUnBiMjRuS1R0Y2JpQWdmVnh1WEc0Z0lDOHZJRmRsSUVSUElFNVBWQ0J5WlhSMWNtNGdkR2hsSUhCeWIyMXBjMlVnWVhNZ2FYUWdaMmwyWlhNZ2RHaGxJSFZ6WlhJZ1lTQm1ZV3h6WlNCelpXNXpaU0IwYUdGMFhHNGdJQzh2SUhSb1pTQndjbTl0YVhObElHbHpJR0ZqZEhWaGJHeDVJSE52YldWb2IzY2djbVZzWVhSbFpDQjBieUIwYUdVZ1kyRnNiR0poWTJzbmN5QmxlR1ZqZFhScGIyNWNiaUFnTHk4Z1lXNWtJSFJvWVhRZ2RHaGxJR05oYkd4aVlXTnJJSFJvY205M2FXNW5JSGRwYkd3Z2NtVnFaV04wSUhSb1pTQndjbTl0YVhObExseHVJQ0JtZFc1amRHbHZiaUJqWVd4c1ltRmphMmxtYVdWa0tDa2dlMXh1SUNBZ0lIWmhjaUJoY21keklEMGdXMTA3WEc0Z0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JoY21kMWJXVnVkSE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lHRnlaM011Y0hWemFDaGhjbWQxYldWdWRITmJhVjBwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCdFlYbGlaVU5pSUQwZ1lYSm5jeTV3YjNBb0tUdGNiaUFnSUNCcFppQW9kSGx3Wlc5bUlHMWhlV0psUTJJZ0lUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0oxUm9aU0JzWVhOMElHRnlaM1Z0Wlc1MElHMTFjM1FnWW1VZ2IyWWdkSGx3WlNCR2RXNWpkR2x2YmljcE8xeHVJQ0FnSUgxY2JpQWdJQ0IyWVhJZ2MyVnNaaUE5SUhSb2FYTTdYRzRnSUNBZ2RtRnlJR05pSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2JXRjVZbVZEWWk1aGNIQnNlU2h6Wld4bUxDQmhjbWQxYldWdWRITXBPMXh1SUNBZ0lIMDdYRzRnSUNBZ0x5OGdTVzRnZEhKMVpTQnViMlJsSUhOMGVXeGxJSGRsSUhCeWIyTmxjM01nZEdobElHTmhiR3hpWVdOcklHOXVJR0J1WlhoMFZHbGphMkFnZDJsMGFDQmhiR3dnZEdobFhHNGdJQ0FnTHk4Z2FXMXdiR2xqWVhScGIyNXpJQ2h6ZEdGamF5d2dZSFZ1WTJGMVoyaDBSWGhqWlhCMGFXOXVZQ3dnWUdGemVXNWpYMmh2YjJ0ellDbGNiaUFnSUNCdmNtbG5hVzVoYkM1aGNIQnNlU2gwYUdsekxDQmhjbWR6S1Z4dUlDQWdJQ0FnTG5Sb1pXNG9ablZ1WTNScGIyNG9jbVYwS1NCN0lIQnliMk5sYzNNdWJtVjRkRlJwWTJzb1kySXVZbWx1WkNodWRXeHNMQ0J1ZFd4c0xDQnlaWFFwS1NCOUxGeHVJQ0FnSUNBZ0lDQWdJQ0FnWm5WdVkzUnBiMjRvY21WcUtTQjdJSEJ5YjJObGMzTXVibVY0ZEZScFkyc29ZMkZzYkdKaFkydHBabmxQYmxKbGFtVmpkR1ZrTG1KcGJtUW9iblZzYkN3Z2NtVnFMQ0JqWWlrcElIMHBPMXh1SUNCOVhHNWNiaUFnVDJKcVpXTjBMbk5sZEZCeWIzUnZkSGx3WlU5bUtHTmhiR3hpWVdOcmFXWnBaV1FzSUU5aWFtVmpkQzVuWlhSUWNtOTBiM1I1Y0dWUFppaHZjbWxuYVc1aGJDa3BPMXh1SUNCUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRHbGxjeWhqWVd4c1ltRmphMmxtYVdWa0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm5aWFJQZDI1UWNtOXdaWEowZVVSbGMyTnlhWEIwYjNKektHOXlhV2RwYm1Gc0tTazdYRzRnSUhKbGRIVnliaUJqWVd4c1ltRmphMmxtYVdWa08xeHVmVnh1Wlhod2IzSjBjeTVqWVd4c1ltRmphMmxtZVNBOUlHTmhiR3hpWVdOcmFXWjVPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdabTl5UldGamFDQTlJSEpsY1hWcGNtVW9KMlp2Y21WaFkyZ25LVHRjYm5aaGNpQmhkbUZwYkdGaWJHVlVlWEJsWkVGeWNtRjVjeUE5SUhKbGNYVnBjbVVvSjJGMllXbHNZV0pzWlMxMGVYQmxaQzFoY25KaGVYTW5LVHRjYm5aaGNpQmpZV3hzUW05MWJtUWdQU0J5WlhGMWFYSmxLQ2RqWVd4c0xXSnBibVF2WTJGc2JFSnZkVzVrSnlrN1hHNWNiblpoY2lBa2RHOVRkSEpwYm1jZ1BTQmpZV3hzUW05MWJtUW9KMDlpYW1WamRDNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY25LVHRjYm5aaGNpQm9ZWE5UZVcxaWIyeHpJRDBnY21WeGRXbHlaU2duYUdGekxYTjViV0p2YkhNbktTZ3BPMXh1ZG1GeUlHaGhjMVJ2VTNSeWFXNW5WR0ZuSUQwZ2FHRnpVM2x0WW05c2N5QW1KaUIwZVhCbGIyWWdVM2x0WW05c0xuUnZVM1J5YVc1blZHRm5JRDA5UFNBbmMzbHRZbTlzSnp0Y2JseHVkbUZ5SUhSNWNHVmtRWEp5WVhseklEMGdZWFpoYVd4aFlteGxWSGx3WldSQmNuSmhlWE1vS1R0Y2JseHVkbUZ5SUNSemJHbGpaU0E5SUdOaGJHeENiM1Z1WkNnblUzUnlhVzVuTG5CeWIzUnZkSGx3WlM1emJHbGpaU2NwTzF4dWRtRnlJSFJ2VTNSeVZHRm5jeUE5SUh0OU8xeHVkbUZ5SUdkUFVFUWdQU0J5WlhGMWFYSmxLQ2RsY3kxaFluTjBjbUZqZEM5b1pXeHdaWEp6TDJkbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaWNwTzF4dWRtRnlJR2RsZEZCeWIzUnZkSGx3WlU5bUlEMGdUMkpxWldOMExtZGxkRkJ5YjNSdmRIbHdaVTltT3lBdkx5QnlaWEYxYVhKbEtDZG5aWFJ3Y205MGIzUjVjR1Z2WmljcE8xeHVhV1lnS0doaGMxUnZVM1J5YVc1blZHRm5JQ1ltSUdkUFVFUWdKaVlnWjJWMFVISnZkRzkwZVhCbFQyWXBJSHRjYmx4MFptOXlSV0ZqYUNoMGVYQmxaRUZ5Y21GNWN5d2dablZ1WTNScGIyNGdLSFI1Y0dWa1FYSnlZWGtwSUh0Y2JseDBYSFJwWmlBb2RIbHdaVzltSUdkc2IySmhiRnQwZVhCbFpFRnljbUY1WFNBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dVhIUmNkRngwZG1GeUlHRnljaUE5SUc1bGR5Qm5iRzlpWVd4YmRIbHdaV1JCY25KaGVWMG9LVHRjYmx4MFhIUmNkR2xtSUNnaEtGTjViV0p2YkM1MGIxTjBjbWx1WjFSaFp5QnBiaUJoY25JcEtTQjdYRzVjZEZ4MFhIUmNkSFJvY205M0lHNWxkeUJGZG1Gc1JYSnliM0lvSjNSb2FYTWdaVzVuYVc1bElHaGhjeUJ6ZFhCd2IzSjBJR1p2Y2lCVGVXMWliMnd1ZEc5VGRISnBibWRVWVdjc0lHSjFkQ0FuSUNzZ2RIbHdaV1JCY25KaGVTQXJJQ2NnWkc5bGN5QnViM1FnYUdGMlpTQjBhR1VnY0hKdmNHVnlkSGtoSUZCc1pXRnpaU0J5WlhCdmNuUWdkR2hwY3k0bktUdGNibHgwWEhSY2RIMWNibHgwWEhSY2RIWmhjaUJ3Y205MGJ5QTlJR2RsZEZCeWIzUnZkSGx3WlU5bUtHRnljaWs3WEc1Y2RGeDBYSFIyWVhJZ1pHVnpZM0pwY0hSdmNpQTlJR2RQVUVRb2NISnZkRzhzSUZONWJXSnZiQzUwYjFOMGNtbHVaMVJoWnlrN1hHNWNkRngwWEhScFppQW9JV1JsYzJOeWFYQjBiM0lwSUh0Y2JseDBYSFJjZEZ4MGRtRnlJSE4xY0dWeVVISnZkRzhnUFNCblpYUlFjbTkwYjNSNWNHVlBaaWh3Y205MGJ5azdYRzVjZEZ4MFhIUmNkR1JsYzJOeWFYQjBiM0lnUFNCblQxQkVLSE4xY0dWeVVISnZkRzhzSUZONWJXSnZiQzUwYjFOMGNtbHVaMVJoWnlrN1hHNWNkRngwWEhSOVhHNWNkRngwWEhSMGIxTjBjbFJoWjNOYmRIbHdaV1JCY25KaGVWMGdQU0JrWlhOamNtbHdkRzl5TG1kbGREdGNibHgwWEhSOVhHNWNkSDBwTzF4dWZWeHVYRzUyWVhJZ2RISjVWSGx3WldSQmNuSmhlWE1nUFNCbWRXNWpkR2x2YmlCMGNubEJiR3hVZVhCbFpFRnljbUY1Y3loMllXeDFaU2tnZTF4dVhIUjJZWElnWm05MWJtUk9ZVzFsSUQwZ1ptRnNjMlU3WEc1Y2RHWnZja1ZoWTJnb2RHOVRkSEpVWVdkekxDQm1kVzVqZEdsdmJpQW9aMlYwZEdWeUxDQjBlWEJsWkVGeWNtRjVLU0I3WEc1Y2RGeDBhV1lnS0NGbWIzVnVaRTVoYldVcElIdGNibHgwWEhSY2RIUnllU0I3WEc1Y2RGeDBYSFJjZEhaaGNpQnVZVzFsSUQwZ1oyVjBkR1Z5TG1OaGJHd29kbUZzZFdVcE8xeHVYSFJjZEZ4MFhIUnBaaUFvYm1GdFpTQTlQVDBnZEhsd1pXUkJjbkpoZVNrZ2UxeHVYSFJjZEZ4MFhIUmNkR1p2ZFc1a1RtRnRaU0E5SUc1aGJXVTdYRzVjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkSDBnWTJGMFkyZ2dLR1VwSUh0OVhHNWNkRngwZlZ4dVhIUjlLVHRjYmx4MGNtVjBkWEp1SUdadmRXNWtUbUZ0WlR0Y2JuMDdYRzVjYm5aaGNpQnBjMVI1Y0dWa1FYSnlZWGtnUFNCeVpYRjFhWEpsS0NkcGN5MTBlWEJsWkMxaGNuSmhlU2NwTzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlIZG9hV05vVkhsd1pXUkJjbkpoZVNoMllXeDFaU2tnZTF4dVhIUnBaaUFvSVdselZIbHdaV1JCY25KaGVTaDJZV3gxWlNrcElIc2djbVYwZFhKdUlHWmhiSE5sT3lCOVhHNWNkR2xtSUNnaGFHRnpWRzlUZEhKcGJtZFVZV2NwSUhzZ2NtVjBkWEp1SUNSemJHbGpaU2drZEc5VGRISnBibWNvZG1Gc2RXVXBMQ0E0TENBdE1TazdJSDFjYmx4MGNtVjBkWEp1SUhSeWVWUjVjR1ZrUVhKeVlYbHpLSFpoYkhWbEtUdGNibjA3WEc0aUxDSXZMeUJVYUdVZ2JXOWtkV3hsSUdOaFkyaGxYRzUyWVhJZ1gxOTNaV0p3WVdOclgyMXZaSFZzWlY5allXTm9aVjlmSUQwZ2UzMDdYRzVjYmk4dklGUm9aU0J5WlhGMWFYSmxJR1oxYm1OMGFXOXVYRzVtZFc1amRHbHZiaUJmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0cxdlpIVnNaVWxrS1NCN1hHNWNkQzh2SUVOb1pXTnJJR2xtSUcxdlpIVnNaU0JwY3lCcGJpQmpZV05vWlZ4dVhIUjJZWElnWTJGamFHVmtUVzlrZFd4bElEMGdYMTkzWldKd1lXTnJYMjF2WkhWc1pWOWpZV05vWlY5ZlcyMXZaSFZzWlVsa1hUdGNibHgwYVdZZ0tHTmhZMmhsWkUxdlpIVnNaU0FoUFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzVjZEZ4MGNtVjBkWEp1SUdOaFkyaGxaRTF2WkhWc1pTNWxlSEJ2Y25Sek8xeHVYSFI5WEc1Y2RDOHZJRU55WldGMFpTQmhJRzVsZHlCdGIyUjFiR1VnS0dGdVpDQndkWFFnYVhRZ2FXNTBieUIwYUdVZ1kyRmphR1VwWEc1Y2RIWmhjaUJ0YjJSMWJHVWdQU0JmWDNkbFluQmhZMnRmYlc5a2RXeGxYMk5oWTJobFgxOWJiVzlrZFd4bFNXUmRJRDBnZTF4dVhIUmNkR2xrT2lCdGIyUjFiR1ZKWkN4Y2JseDBYSFJzYjJGa1pXUTZJR1poYkhObExGeHVYSFJjZEdWNGNHOXlkSE02SUh0OVhHNWNkSDA3WEc1Y2JseDBMeThnUlhobFkzVjBaU0IwYUdVZ2JXOWtkV3hsSUdaMWJtTjBhVzl1WEc1Y2RGOWZkMlZpY0dGamExOXRiMlIxYkdWelgxOWJiVzlrZFd4bFNXUmRMbU5oYkd3b2JXOWtkV3hsTG1WNGNHOXlkSE1zSUcxdlpIVnNaU3dnYlc5a2RXeGxMbVY0Y0c5eWRITXNJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThwTzF4dVhHNWNkQzh2SUVac1lXY2dkR2hsSUcxdlpIVnNaU0JoY3lCc2IyRmtaV1JjYmx4MGJXOWtkV3hsTG14dllXUmxaQ0E5SUhSeWRXVTdYRzVjYmx4MEx5OGdVbVYwZFhKdUlIUm9aU0JsZUhCdmNuUnpJRzltSUhSb1pTQnRiMlIxYkdWY2JseDBjbVYwZFhKdUlHMXZaSFZzWlM1bGVIQnZjblJ6TzF4dWZWeHVYRzRpTENJdkx5QmtaV1pwYm1VZ1oyVjBkR1Z5SUdaMWJtTjBhVzl1Y3lCbWIzSWdhR0Z5Ylc5dWVTQmxlSEJ2Y25SelhHNWZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZMbVFnUFNBb1pYaHdiM0owY3l3Z1pHVm1hVzVwZEdsdmJpa2dQVDRnZTF4dVhIUm1iM0lvZG1GeUlHdGxlU0JwYmlCa1pXWnBibWwwYVc5dUtTQjdYRzVjZEZ4MGFXWW9YMTkzWldKd1lXTnJYM0psY1hWcGNtVmZYeTV2S0dSbFptbHVhWFJwYjI0c0lHdGxlU2tnSmlZZ0lWOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHVieWhsZUhCdmNuUnpMQ0JyWlhrcEtTQjdYRzVjZEZ4MFhIUlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvWlhod2IzSjBjeXdnYTJWNUxDQjdJR1Z1ZFcxbGNtRmliR1U2SUhSeWRXVXNJR2RsZERvZ1pHVm1hVzVwZEdsdmJsdHJaWGxkSUgwcE8xeHVYSFJjZEgxY2JseDBmVnh1ZlRzaUxDSmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZMbWNnUFNBb1puVnVZM1JwYjI0b0tTQjdYRzVjZEdsbUlDaDBlWEJsYjJZZ1oyeHZZbUZzVkdocGN5QTlQVDBnSjI5aWFtVmpkQ2NwSUhKbGRIVnliaUJuYkc5aVlXeFVhR2x6TzF4dVhIUjBjbmtnZTF4dVhIUmNkSEpsZEhWeWJpQjBhR2x6SUh4OElHNWxkeUJHZFc1amRHbHZiaWduY21WMGRYSnVJSFJvYVhNbktTZ3BPMXh1WEhSOUlHTmhkR05vSUNobEtTQjdYRzVjZEZ4MGFXWWdLSFI1Y0dWdlppQjNhVzVrYjNjZ1BUMDlJQ2R2WW1wbFkzUW5LU0J5WlhSMWNtNGdkMmx1Wkc5M08xeHVYSFI5WEc1OUtTZ3BPeUlzSWw5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4dWJ5QTlJQ2h2WW1vc0lIQnliM0FwSUQwK0lDaFBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1TG1OaGJHd29iMkpxTENCd2NtOXdLU2tpTENJdkx5QmtaV1pwYm1VZ1gxOWxjMDF2WkhWc1pTQnZiaUJsZUhCdmNuUnpYRzVmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmTG5JZ1BTQW9aWGh3YjNKMGN5a2dQVDRnZTF4dVhIUnBaaWgwZVhCbGIyWWdVM2x0WW05c0lDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUppQlRlVzFpYjJ3dWRHOVRkSEpwYm1kVVlXY3BJSHRjYmx4MFhIUlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvWlhod2IzSjBjeXdnVTNsdFltOXNMblJ2VTNSeWFXNW5WR0ZuTENCN0lIWmhiSFZsT2lBblRXOWtkV3hsSnlCOUtUdGNibHgwZlZ4dVhIUlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvWlhod2IzSjBjeXdnSjE5ZlpYTk5iMlIxYkdVbkxDQjdJSFpoYkhWbE9pQjBjblZsSUgwcE8xeHVmVHNpTENKZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxtNXRaQ0E5SUNodGIyUjFiR1VwSUQwK0lIdGNibHgwYlc5a2RXeGxMbkJoZEdoeklEMGdXMTA3WEc1Y2RHbG1JQ2doYlc5a2RXeGxMbU5vYVd4a2NtVnVLU0J0YjJSMWJHVXVZMmhwYkdSeVpXNGdQU0JiWFR0Y2JseDBjbVYwZFhKdUlHMXZaSFZzWlR0Y2JuMDdJaXdpWlhod2IzSjBJSHNnU1cxbmRYSkRiR2xsYm5RZ2ZTQm1jbTl0SUNjdUwyTnNhV1Z1ZENjN1hHNGlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSjlcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImV4cG9ydCB7IEJpa2VUYWdDbGllbnQgfSBmcm9tICcuL2NsaWVudCc7XG4iXSwic291cmNlUm9vdCI6IiJ9