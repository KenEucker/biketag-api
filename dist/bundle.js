(function webpackUniversalModuleDefinition(root, factory) {
	//CommonJS2 Comment
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	//AMD Comment
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	//CommonJS Comment
	else if(typeof exports === 'object')
		exports["biketag"] = factory();
	//Root Comment
	else
		root["biketag"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@rexxars/eventsource-polyfill/src/eventsource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rexxars/eventsource-polyfill/src/eventsource.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * EventSource polyfill
 * Originally published by sc AmvTek srl (https://github.com/amvtek/EventSource) - devel@amvtek.com
 * Forked by Espen Hovlandsdal to fix a few issues + publish latest version
 */

;(function (root, factory) {
  /* global define */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else { var evsImportName; }
})(typeof self === 'undefined' ? this : self, function () {
  var EventSource = function (url, options) {
    if (!url || typeof url != 'string') {
      throw new SyntaxError('Not enough arguments')
    }

    this.URL = url
    this.setOptions(options)
    var evs = this
    setTimeout(function () {
      evs.poll()
    }, 0)
  }

  EventSource.prototype = {
    CONNECTING: 0,

    OPEN: 1,

    CLOSED: 2,

    defaultOptions: {
      loggingEnabled: false,

      loggingPrefix: 'eventsource',

      interval: 500, // milliseconds

      bufferSizeLimit: 256 * 1024, // bytes

      silentTimeout: 300000, // milliseconds

      getArgs: {
        evs_buffer_size_limit: 256 * 1024,
      },

      xhrHeaders: {
        Accept: 'text/event-stream',
        'Cache-Control': 'no-cache',
        'X-Requested-With': 'XMLHttpRequest',
      },
    },

    setOptions: function (options) {
      var defaults = this.defaultOptions
      var option

      // set all default options...
      for (option in defaults) {
        if (defaults.hasOwnProperty(option)) {
          this[option] = defaults[option]
        }
      }

      // override with what is in options
      for (option in options) {
        if (option in defaults && options.hasOwnProperty(option)) {
          this[option] = options[option]
        }
      }

      // if getArgs option is enabled
      // ensure evs_buffer_size_limit corresponds to bufferSizeLimit
      if (this.getArgs && this.bufferSizeLimit) {
        this.getArgs.evs_buffer_size_limit = this.bufferSizeLimit
      }

      // if console is not available, force loggingEnabled to false
      // eslint-disable-next-line no-console
      if (typeof console === 'undefined' || typeof console.log === 'undefined') {
        this.loggingEnabled = false
      }
    },

    log: function (message) {
      if (this.loggingEnabled) {
        // eslint-disable-next-line no-console
        console.log('[' + this.loggingPrefix + ']:' + message)
      }
    },

    poll: function () {
      try {
        if (this.readyState == this.CLOSED) {
          return
        }

        this.cleanup()
        this.readyState = this.CONNECTING
        this.cursor = 0
        this.cache = ''
        this._xhr = new this.XHR(this)
        this.resetNoActivityTimer()
      } catch (err) {
        // in an attempt to silence the errors
        this.log('There were errors inside the pool try-catch')
        this.dispatchEvent('error', {type: 'error', data: err.message})
      }
    },

    pollAgain: function (interval) {
      // schedule poll to be called after interval milliseconds
      var evs = this
      evs.readyState = evs.CONNECTING
      evs.dispatchEvent('error', {
        type: 'error',
        data: 'Reconnecting ',
      })
      this._pollTimer = setTimeout(function () {
        evs.poll()
      }, interval || 0)
    },

    cleanup: function () {
      this.log('evs cleaning up')

      if (this._pollTimer) {
        clearInterval(this._pollTimer)
        this._pollTimer = null
      }

      if (this._noActivityTimer) {
        clearInterval(this._noActivityTimer)
        this._noActivityTimer = null
      }

      if (this._xhr) {
        this._xhr.abort()
        this._xhr = null
      }
    },

    resetNoActivityTimer: function () {
      if (this.silentTimeout) {
        if (this._noActivityTimer) {
          clearInterval(this._noActivityTimer)
        }
        var evs = this
        this._noActivityTimer = setTimeout(function () {
          evs.log('Timeout! silentTImeout:' + evs.silentTimeout)
          evs.pollAgain()
        }, this.silentTimeout)
      }
    },

    close: function () {
      this.readyState = this.CLOSED
      this.log('Closing connection. readyState: ' + this.readyState)
      this.cleanup()
    },

    _onxhrdata: function () {
      var request = this._xhr

      if (request.isReady() && !request.hasError()) {
        // reset the timer, as we have activity
        this.resetNoActivityTimer()

        // move this EventSource to OPEN state...
        if (this.readyState == this.CONNECTING) {
          this.readyState = this.OPEN
          this.dispatchEvent('open', {type: 'open'})
        }

        var buffer = request.getBuffer()

        if (buffer.length > this.bufferSizeLimit) {
          this.log('buffer.length > this.bufferSizeLimit')
          this.pollAgain()
        }

        if (this.cursor == 0 && buffer.length > 0) {
          // skip byte order mark \uFEFF character if it starts the stream
          if (buffer.substring(0, 1) == '\uFEFF') {
            this.cursor = 1
          }
        }

        var lastMessageIndex = this.lastMessageIndex(buffer)
        if (lastMessageIndex[0] >= this.cursor) {
          var newcursor = lastMessageIndex[1]
          var toparse = buffer.substring(this.cursor, newcursor)
          this.parseStream(toparse)
          this.cursor = newcursor
        }

        // if request is finished, reopen the connection
        if (request.isDone()) {
          this.log('request.isDone(). reopening the connection')
          this.pollAgain(this.interval)
        }
      } else if (this.readyState !== this.CLOSED) {
        this.log('this.readyState !== this.CLOSED')
        this.pollAgain(this.interval)

        //MV: Unsure why an error was previously dispatched
      }
    },

    parseStream: function (chunk) {
      // normalize line separators (\r\n,\r,\n) to \n
      // remove white spaces that may precede \n
      chunk = this.cache + this.normalizeToLF(chunk)

      var events = chunk.split('\n\n')

      var i, j, eventType, datas, line, retry

      for (i = 0; i < events.length - 1; i++) {
        eventType = 'message'
        datas = []
        var parts = events[i].split('\n')

        for (j = 0; j < parts.length; j++) {
          line = this.trimWhiteSpace(parts[j])

          if (line.indexOf('event') == 0) {
            eventType = line.replace(/event:?\s*/, '')
          } else if (line.indexOf('retry') == 0) {
            retry = parseInt(line.replace(/retry:?\s*/, ''), 10)
            if (!isNaN(retry)) {
              this.interval = retry
            }
          } else if (line.indexOf('data') == 0) {
            datas.push(line.replace(/data:?\s*/, ''))
          } else if (line.indexOf('id:') == 0) {
            this.lastEventId = line.replace(/id:?\s*/, '')
          } else if (line.indexOf('id') == 0) {
            // this resets the id

            this.lastEventId = null
          }
        }

        if (datas.length && this.readyState != this.CLOSED) {
          // dispatch a new event
          var event = new MessageEvent(
            eventType,
            datas.join('\n'),
            typeof window !== 'undefined' && typeof window.location !== 'undefined'
              ? window.location.origin
              : null,
            this.lastEventId
          )
          this.dispatchEvent(eventType, event)
        }
      }

      this.cache = events[events.length - 1]
    },

    dispatchEvent: function (type, event) {
      var handlers = this['_' + type + 'Handlers']

      if (handlers) {
        for (var i = 0; i < handlers.length; i++) {
          handlers[i].call(this, event)
        }
      }

      if (this['on' + type]) {
        this['on' + type].call(this, event)
      }
    },

    addEventListener: function (type, handler) {
      if (!this['_' + type + 'Handlers']) {
        this['_' + type + 'Handlers'] = []
      }

      this['_' + type + 'Handlers'].push(handler)
    },

    removeEventListener: function (type, handler) {
      var handlers = this['_' + type + 'Handlers']
      if (!handlers) {
        return
      }
      for (var i = handlers.length - 1; i >= 0; --i) {
        if (handlers[i] === handler) {
          handlers.splice(i, 1)
          break
        }
      }
    },

    _pollTimer: null,

    _noactivityTimer: null,

    _xhr: null,

    lastEventId: null,

    cache: '',

    cursor: 0,

    onerror: null,

    onmessage: null,

    onopen: null,

    readyState: 0,

    // ===================================================================
    // helpers functions
    // those are attached to prototype to ease reuse and testing...

    urlWithParams: function (baseURL, params) {
      var encodedArgs = []

      if (params) {
        var key, urlarg
        var urlize = encodeURIComponent

        for (key in params) {
          if (params.hasOwnProperty(key)) {
            urlarg = urlize(key) + '=' + urlize(params[key])
            encodedArgs.push(urlarg)
          }
        }
      }

      if (encodedArgs.length > 0) {
        if (baseURL.indexOf('?') == -1) return baseURL + '?' + encodedArgs.join('&')
        return baseURL + '&' + encodedArgs.join('&')
      }
      return baseURL
    },

    lastMessageIndex: function (text) {
      var ln2 = text.lastIndexOf('\n\n')
      var lr2 = text.lastIndexOf('\r\r')
      var lrln2 = text.lastIndexOf('\r\n\r\n')

      if (lrln2 > Math.max(ln2, lr2)) {
        return [lrln2, lrln2 + 4]
      }
      return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]
    },

    trimWhiteSpace: function (str) {
      // to remove whitespaces left and right of string

      var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g
      return str.replace(reTrim, '')
    },

    normalizeToLF: function (str) {
      // replace \r and \r\n with \n
      return str.replace(/\r\n|\r/g, '\n')
    },
  }

  if (isOldIE()) {
    EventSource.isPolyfill = 'IE_8-9'

    // patch EventSource defaultOptions
    var defaults = EventSource.prototype.defaultOptions
    defaults.xhrHeaders = null // no headers will be sent
    defaults.getArgs.evs_preamble = 2048 + 8

    // EventSource will send request using Internet Explorer XDomainRequest
    EventSource.prototype.XHR = function (evs) {
      /* global XDomainRequest */
      var request = new XDomainRequest()
      this._request = request

      // set handlers
      request.onprogress = function () {
        request._ready = true
        evs._onxhrdata()
      }

      request.onload = function () {
        this._loaded = true
        evs._onxhrdata()
      }

      request.onerror = function () {
        this._failed = true
        evs.readyState = evs.CLOSED
        evs.dispatchEvent('error', {
          type: 'error',
          data: 'XDomainRequest error',
        })
      }

      request.ontimeout = function () {
        this._failed = true
        evs.readyState = evs.CLOSED
        evs.dispatchEvent('error', {
          type: 'error',
          data: 'XDomainRequest timed out',
        })
      }

      // XDomainRequest does not allow setting custom headers
      // If EventSource has enabled the use of GET arguments
      // we add parameters to URL so that server can adapt the stream...
      var reqGetArgs = {}
      if (evs.getArgs) {
        // copy evs.getArgs in reqGetArgs
        var defaultArgs = evs.getArgs
        for (var key in defaultArgs) {
          if (defaultArgs.hasOwnProperty(key)) {
            reqGetArgs[key] = defaultArgs[key]
          }
        }
        if (evs.lastEventId) {
          reqGetArgs.evs_last_event_id = evs.lastEventId
        }
      }
      // send the request

      request.open('GET', evs.urlWithParams(evs.URL, reqGetArgs))
      request.send()
    }

    EventSource.prototype.XHR.prototype = {
      useXDomainRequest: true,

      _request: null,

      _ready: false, // true when progress events are dispatched

      _loaded: false, // true when request has been loaded

      _failed: false, // true if when request is in error

      isReady: function () {
        return this._request._ready
      },

      isDone: function () {
        return this._request._loaded
      },

      hasError: function () {
        return this._request._failed
      },

      getBuffer: function () {
        var rv = ''
        try {
          rv = this._request.responseText || ''
        } catch (err) {
          // intentional noop
        }
        return rv
      },

      abort: function () {
        if (this._request) {
          this._request.abort()
        }
      },
    }
  } else {
    EventSource.isPolyfill = 'XHR'

    // EventSource will send request using XMLHttpRequest
    EventSource.prototype.XHR = function (evs) {
      var request = new XMLHttpRequest()
      this._request = request
      evs._xhr = this

      // set handlers
      request.onreadystatechange = function () {
        if (request.readyState > 1 && evs.readyState != evs.CLOSED) {
          if (request.status == 200 || (request.status >= 300 && request.status < 400)) {
            evs._onxhrdata()
          } else {
            request._failed = true
            evs.readyState = evs.CLOSED
            evs.dispatchEvent('error', {
              type: 'error',
              data: 'The server responded with ' + request.status,
            })
            evs.close()
          }
        }
      }

      request.onprogress = function () {
        // intentional noop
      }

      request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true)

      var headers = evs.xhrHeaders // maybe null
      for (var header in headers) {
        if (headers.hasOwnProperty(header)) {
          request.setRequestHeader(header, headers[header])
        }
      }
      if (evs.lastEventId) {
        request.setRequestHeader('Last-Event-Id', evs.lastEventId)
      }

      request.send()
    }

    EventSource.prototype.XHR.prototype = {
      useXDomainRequest: false,

      _request: null,

      _failed: false, // true if we have had errors...

      isReady: function () {
        return this._request.readyState >= 2
      },

      isDone: function () {
        return this._request.readyState == 4
      },

      hasError: function () {
        return this._failed || this._request.status >= 400
      },

      getBuffer: function () {
        var rv = ''
        try {
          rv = this._request.responseText || ''
        } catch (err) {
          // intentional noop
        }
        return rv
      },

      abort: function () {
        if (this._request) {
          this._request.abort()
        }
      },
    }
  }

  function MessageEvent(type, data, origin, lastEventId) {
    this.bubbles = false
    this.cancelBubble = false
    this.cancelable = false
    this.data = data || null
    this.origin = origin || ''
    this.lastEventId = lastEventId || ''
    this.type = type || 'message'
  }

  function isOldIE() {
    //return true if we are in IE8 or IE9
    return Boolean(
      typeof window !== 'undefined' &&
        window.XDomainRequest &&
        window.XMLHttpRequest &&
        new XMLHttpRequest().responseType === undefined
    )
  }

  return EventSource
})


/***/ }),

/***/ "./node_modules/@sanity/client/lib/assets/assetsClient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/assets/assetsClient.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require = __webpack_require__(/*! @sanity/observable/operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require.map;

var _require2 = __webpack_require__(/*! @sanity/observable/operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require2.filter;

var queryString = __webpack_require__(/*! ../http/queryString */ "./node_modules/@sanity/client/lib/http/queryString.js");

var validators = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

function AssetsClient(client) {
  this.client = client;
}

function toDocument(body) {
  // todo: rewrite to just return body.document in a while
  var document = body.document;
  Object.defineProperty(document, 'document', {
    enumerable: false,
    get: function get() {
      // eslint-disable-next-line no-console
      console.warn('The promise returned from client.asset.upload(...) now resolves with the asset document');
      return document;
    }
  });
  return document;
}

function optionsFromFile(opts, file) {
  if (typeof window === 'undefined' || !(file instanceof window.File)) {
    return opts;
  }

  return assign({
    filename: opts.preserveFilename === false ? undefined : file.name,
    contentType: file.type
  }, opts);
}

assign(AssetsClient.prototype, {
  /**
   * Upload an asset
   *
   * @param  {String} assetType `image` or `file`
   * @param  {File|Blob|Buffer|ReadableStream} body File to upload
   * @param  {Object}  opts Options for the upload
   * @param  {Boolean} opts.preserveFilename Whether or not to preserve the original filename (default: true)
   * @param  {String}  opts.filename Filename for this file (optional)
   * @param  {Number}  opts.timeout  Milliseconds to wait before timing the request out (default: 0)
   * @param  {String}  opts.contentType Mime type of the file
   * @param  {Array}   opts.extract Array of metadata parts to extract from image.
   *                                 Possible values: `location`, `exif`, `image`, `palette`
   * @param  {String}  opts.label Label
   * @param  {String}  opts.title Title
   * @param  {String}  opts.description Description
   * @param  {String}  opts.creditLine The credit to person(s) and/or organization(s) required by the supplier of the image to be used when published
   * @param  {Object}  opts.source Source data (when the asset is from an external service)
   * @param  {String}  opts.source.id The (u)id of the asset within the source, i.e. 'i-f323r1E'
   *                                  Required if source is defined
   * @param  {String}  opts.source.name The name of the source, i.e. 'unsplash'
   *                                  Required if source is defined
   * @param  {String}  opts.source.url A url to where to find the asset, or get more info about it in the source
   *                                  Optional
   * @return {Promise} Resolves with the created asset document
   */
  upload: function upload(assetType, body) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    validators.validateAssetType(assetType); // If an empty array is given, explicitly set `none` to override API defaults

    var meta = opts.extract || undefined;

    if (meta && !meta.length) {
      meta = ['none'];
    }

    var dataset = validators.hasDataset(this.client.clientConfig);
    var assetEndpoint = assetType === 'image' ? 'images' : 'files';
    var options = optionsFromFile(opts, body);
    var label = options.label,
        title = options.title,
        description = options.description,
        creditLine = options.creditLine,
        filename = options.filename,
        source = options.source;
    var query = {
      label: label,
      title: title,
      description: description,
      filename: filename,
      meta: meta,
      creditLine: creditLine
    };

    if (source) {
      query.sourceId = source.id;
      query.sourceName = source.name;
      query.sourceUrl = source.url;
    }

    var observable = this.client._requestObservable({
      method: 'POST',
      timeout: options.timeout || 0,
      uri: "/assets/".concat(assetEndpoint, "/").concat(dataset),
      headers: options.contentType ? {
        'Content-Type': options.contentType
      } : {},
      query: query,
      body: body
    });

    return this.client.isPromiseAPI() ? observable.pipe(filter(function (event) {
      return event.type === 'response';
    }), map(function (event) {
      return toDocument(event.body);
    })).toPromise() : observable;
  },
  delete: function _delete(type, id) {
    // eslint-disable-next-line no-console
    console.warn('client.assets.delete() is deprecated, please use client.delete(<document-id>)');
    var docId = id || '';

    if (!/^(image|file)-/.test(docId)) {
      docId = "".concat(type, "-").concat(docId);
    } else if (type._id) {
      // We could be passing an entire asset document instead of an ID
      docId = type._id;
    }

    validators.hasDataset(this.client.clientConfig);
    return this.client.delete(docId);
  },
  getImageUrl: function getImageUrl(ref, query) {
    var id = ref._ref || ref;

    if (typeof id !== 'string') {
      throw new Error('getImageUrl() needs either an object with a _ref, or a string with an asset document ID');
    }

    if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(id)) {
      throw new Error("Unsupported asset ID \"".concat(id, "\". URL generation only works for auto-generated IDs."));
    }

    var _id$split = id.split('-'),
        _id$split2 = _slicedToArray(_id$split, 4),
        assetId = _id$split2[1],
        size = _id$split2[2],
        format = _id$split2[3];

    validators.hasDataset(this.client.clientConfig);
    var _this$client$clientCo = this.client.clientConfig,
        projectId = _this$client$clientCo.projectId,
        dataset = _this$client$clientCo.dataset;
    var qs = query ? queryString(query) : '';
    return "https://cdn.sanity.io/images/".concat(projectId, "/").concat(dataset, "/").concat(assetId, "-").concat(size, ".").concat(format).concat(qs);
  }
});
module.exports = AssetsClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/auth/authClient.js":
/*!************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/auth/authClient.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function AuthClient(client) {
  this.client = client;
}

assign(AuthClient.prototype, {
  getLoginProviders: function getLoginProviders() {
    return this.client.request({
      uri: '/auth/providers'
    });
  },
  logout: function logout() {
    return this.client.request({
      uri: '/auth/logout',
      method: 'POST'
    });
  }
});
module.exports = AuthClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@sanity/client/lib/config.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var generateHelpUrl = __webpack_require__(/*! @sanity/generate-help-url */ "./node_modules/@sanity/generate-help-url/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var validate = __webpack_require__(/*! ./validators */ "./node_modules/@sanity/client/lib/validators.js");

var warnings = __webpack_require__(/*! ./warnings */ "./node_modules/@sanity/client/lib/warnings.js");

var defaultCdnHost = 'apicdn.sanity.io';
var defaultConfig = {
  apiHost: 'https://api.sanity.io',
  apiVersion: '1',
  useProjectHostname: true,
  gradientMode: false,
  isPromiseAPI: true
};
var LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0'];

var isLocal = function isLocal(host) {
  return LOCALHOSTS.indexOf(host) !== -1;
};

exports.defaultConfig = defaultConfig; // eslint-disable-next-line complexity

exports.initConfig = function (config, prevConfig) {
  var specifiedConfig = assign({}, prevConfig, config);

  if (!specifiedConfig.apiVersion) {
    warnings.printNoApiVersionSpecifiedWarning();
  }

  var newConfig = assign({}, defaultConfig, specifiedConfig);
  var gradientMode = newConfig.gradientMode;
  var projectBased = !gradientMode && newConfig.useProjectHostname;

  if (typeof Promise === 'undefined') {
    var helpUrl = generateHelpUrl('js-client-promise-polyfill');
    throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(helpUrl));
  }

  if (gradientMode && !newConfig.namespace) {
    throw new Error('Configuration must contain `namespace` when running in gradient mode');
  }

  if (projectBased && !newConfig.projectId) {
    throw new Error('Configuration must contain `projectId`');
  }

  var isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname;
  var isLocalhost = isBrowser && isLocal(window.location.hostname);

  if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
    warnings.printBrowserTokenWarning();
  } else if ((!isBrowser || isLocalhost) && newConfig.useCdn && newConfig.token) {
    warnings.printCdnTokenWarning();
  } else if (typeof newConfig.useCdn === 'undefined') {
    warnings.printCdnWarning();
  }

  if (projectBased) {
    validate.projectId(newConfig.projectId);
  }

  if (!gradientMode && newConfig.dataset) {
    validate.dataset(newConfig.dataset, newConfig.gradientMode);
  }

  newConfig.apiVersion = "".concat(newConfig.apiVersion).replace(/^v/, '');
  newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;
  newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.token && !newConfig.withCredentials;
  exports.validateApiVersion(newConfig.apiVersion);

  if (newConfig.gradientMode) {
    newConfig.url = newConfig.apiHost;
    newConfig.cdnUrl = newConfig.apiHost;
  } else {
    var hostParts = newConfig.apiHost.split('://', 2);
    var protocol = hostParts[0];
    var host = hostParts[1];
    var cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;

    if (newConfig.useProjectHostname) {
      newConfig.url = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(host, "/v").concat(newConfig.apiVersion);
      newConfig.cdnUrl = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(cdnHost, "/v").concat(newConfig.apiVersion);
    } else {
      newConfig.url = "".concat(newConfig.apiHost, "/v").concat(newConfig.apiVersion);
      newConfig.cdnUrl = newConfig.url;
    }
  }

  return newConfig;
};

exports.validateApiVersion = function validateApiVersion(apiVersion) {
  if (apiVersion === '1' || apiVersion === 'X') {
    return;
  }

  var apiDate = new Date(apiVersion);
  var apiVersionValid = /^\d{4}-\d{2}-\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;

  if (!apiVersionValid) {
    throw new Error('Invalid API version string, expected `1` or date in format `YYYY-MM-DD`');
  }
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/dataMethods.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/dataMethods.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require = __webpack_require__(/*! @sanity/observable/operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require.filter;

var _require2 = __webpack_require__(/*! @sanity/observable/operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require2.map;

var validators = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

var getSelection = __webpack_require__(/*! ../util/getSelection */ "./node_modules/@sanity/client/lib/util/getSelection.js");

var encodeQueryString = __webpack_require__(/*! ./encodeQueryString */ "./node_modules/@sanity/client/lib/data/encodeQueryString.js");

var Transaction = __webpack_require__(/*! ./transaction */ "./node_modules/@sanity/client/lib/data/transaction.js");

var Patch = __webpack_require__(/*! ./patch */ "./node_modules/@sanity/client/lib/data/patch.js");

var listen = __webpack_require__(/*! ./listen */ "./node_modules/@sanity/client/lib/data/listen.js");

var excludeFalsey = function excludeFalsey(param, defValue) {
  var value = typeof param === 'undefined' ? defValue : param;
  return param === false ? undefined : value;
};

var getMutationQuery = function getMutationQuery() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    returnIds: true,
    returnDocuments: excludeFalsey(options.returnDocuments, true),
    visibility: options.visibility || 'sync'
  };
};

var isResponse = function isResponse(event) {
  return event.type === 'response';
};

var getBody = function getBody(event) {
  return event.body;
};

var indexBy = function indexBy(docs, attr) {
  return docs.reduce(function (indexed, doc) {
    indexed[attr(doc)] = doc;
    return indexed;
  }, Object.create(null));
};

var toPromise = function toPromise(observable) {
  return observable.toPromise();
};

var getQuerySizeLimit = 11264;
module.exports = {
  listen: listen,
  getDataUrl: function getDataUrl(operation, path) {
    var config = this.clientConfig;
    var catalog = config.gradientMode ? config.namespace : validators.hasDataset(config);
    var baseUri = "/".concat(operation, "/").concat(catalog);
    var uri = path ? "".concat(baseUri, "/").concat(path) : baseUri;
    return (this.clientConfig.gradientMode ? uri : "/data".concat(uri)).replace(/\/($|\?)/, '$1');
  },
  fetch: function fetch(query, params) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var mapResponse = options.filterResponse === false ? function (res) {
      return res;
    } : function (res) {
      return res.result;
    };

    var observable = this._dataRequest('query', {
      query: query,
      params: params
    }, options).pipe(map(mapResponse));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  },
  getDocument: function getDocument(id) {
    var options = {
      uri: this.getDataUrl('doc', id),
      json: true
    };

    var observable = this._requestObservable(options).pipe(filter(isResponse), map(function (event) {
      return event.body.documents && event.body.documents[0];
    }));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  },
  getDocuments: function getDocuments(ids) {
    var options = {
      uri: this.getDataUrl('doc', ids.join(',')),
      json: true
    };

    var observable = this._requestObservable(options).pipe(filter(isResponse), map(function (event) {
      var indexed = indexBy(event.body.documents || [], function (doc) {
        return doc._id;
      });
      return ids.map(function (id) {
        return indexed[id] || null;
      });
    }));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  },
  create: function create(doc, options) {
    return this._create(doc, 'create', options);
  },
  createIfNotExists: function createIfNotExists(doc, options) {
    validators.requireDocumentId('createIfNotExists', doc);
    return this._create(doc, 'createIfNotExists', options);
  },
  createOrReplace: function createOrReplace(doc, options) {
    validators.requireDocumentId('createOrReplace', doc);
    return this._create(doc, 'createOrReplace', options);
  },
  patch: function patch(selector, operations) {
    return new Patch(selector, operations, this);
  },
  delete: function _delete(selection, options) {
    return this.dataRequest('mutate', {
      mutations: [{
        delete: getSelection(selection)
      }]
    }, options);
  },
  mutate: function mutate(mutations, options) {
    var mut = mutations instanceof Patch || mutations instanceof Transaction ? mutations.serialize() : mutations;
    var muts = Array.isArray(mut) ? mut : [mut];
    var transactionId = options && options.transactionId;
    return this.dataRequest('mutate', {
      mutations: muts,
      transactionId: transactionId
    }, options);
  },
  transaction: function transaction(operations) {
    return new Transaction(operations, this);
  },
  dataRequest: function dataRequest(endpoint, body) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var request = this._dataRequest(endpoint, body, options);

    return this.isPromiseAPI() ? toPromise(request) : request;
  },
  _dataRequest: function _dataRequest(endpoint, body) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var isMutation = endpoint === 'mutate'; // Check if the query string is within a configured threshold,
    // in which case we can use GET. Otherwise, use POST.

    var strQuery = !isMutation && encodeQueryString(body);
    var useGet = !isMutation && strQuery.length < getQuerySizeLimit;
    var stringQuery = useGet ? strQuery : '';
    var returnFirst = options.returnFirst;
    var timeout = options.timeout,
        token = options.token;
    var uri = this.getDataUrl(endpoint, stringQuery);
    var reqOptions = {
      method: useGet ? 'GET' : 'POST',
      uri: uri,
      json: true,
      body: useGet ? undefined : body,
      query: isMutation && getMutationQuery(options),
      timeout: timeout,
      token: token
    };
    return this._requestObservable(reqOptions).pipe(filter(isResponse), map(getBody), map(function (res) {
      if (!isMutation) {
        return res;
      } // Should we return documents?


      var results = res.results || [];

      if (options.returnDocuments) {
        return returnFirst ? results[0] && results[0].document : results.map(function (mut) {
          return mut.document;
        });
      } // Return a reduced subset


      var key = returnFirst ? 'documentId' : 'documentIds';
      var ids = returnFirst ? results[0] && results[0].id : results.map(function (mut) {
        return mut.id;
      });
      return _defineProperty({
        transactionId: res.transactionId,
        results: results
      }, key, ids);
    }));
  },
  _create: function _create(doc, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var mutation = _defineProperty({}, op, doc);

    var opts = assign({
      returnFirst: true,
      returnDocuments: true
    }, options);
    return this.dataRequest('mutate', {
      mutations: [mutation]
    }, opts);
  }
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/encodeQueryString.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/encodeQueryString.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";


var enc = encodeURIComponent;

module.exports = function (_ref) {
  var query = _ref.query,
      _ref$params = _ref.params,
      params = _ref$params === void 0 ? {} : _ref$params,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options;
  var base = "?query=".concat(enc(query));
  var qString = Object.keys(params).reduce(function (qs, param) {
    return "".concat(qs, "&").concat(enc("$".concat(param)), "=").concat(enc(JSON.stringify(params[param])));
  }, base);
  return Object.keys(options).reduce(function (qs, option) {
    // Only include the option if it is truthy
    return options[option] ? "".concat(qs, "&").concat(enc(option), "=").concat(enc(options[option])) : qs;
  }, qString);
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/listen.js":
/*!********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/listen.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var Observable = __webpack_require__(/*! @sanity/observable/minimal */ "./node_modules/@sanity/observable/minimal.js");

var polyfilledEventSource = __webpack_require__(/*! @sanity/eventsource */ "./node_modules/@sanity/eventsource/browser.js");

var pick = __webpack_require__(/*! ../util/pick */ "./node_modules/@sanity/client/lib/util/pick.js");

var defaults = __webpack_require__(/*! ../util/defaults */ "./node_modules/@sanity/client/lib/util/defaults.js");

var encodeQueryString = __webpack_require__(/*! ./encodeQueryString */ "./node_modules/@sanity/client/lib/data/encodeQueryString.js");

var generateHelpUrl = __webpack_require__(/*! @sanity/generate-help-url */ "./node_modules/@sanity/generate-help-url/index.js");

var once = __webpack_require__(/*! ../util/once */ "./node_modules/@sanity/client/lib/util/once.js");

var tokenWarning = ['Using token with listeners is not supported in browsers. ', "For more info, see ".concat(generateHelpUrl('js-client-listener-tokens-browser'), ".")]; // eslint-disable-next-line no-console

var printTokenWarning = once(function () {
  return console.warn(tokenWarning.join(' '));
});
var isWindowEventSource = Boolean(typeof window !== 'undefined' && window.EventSource);
var EventSource = isWindowEventSource ? window.EventSource // Native browser EventSource
: polyfilledEventSource; // Node.js, IE etc

var possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat'];
var defaultOptions = {
  includeResult: true
};

module.exports = function listen(query, params) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var options = defaults(opts, defaultOptions);
  var listenOpts = pick(options, possibleOptions);
  var qs = encodeQueryString({
    query: query,
    params: params,
    options: listenOpts
  });
  var _this$clientConfig = this.clientConfig,
      url = _this$clientConfig.url,
      token = _this$clientConfig.token,
      withCredentials = _this$clientConfig.withCredentials;
  var uri = "".concat(url).concat(this.getDataUrl('listen', qs));
  var listenFor = options.events ? options.events : ['mutation'];
  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;

  if (token && isWindowEventSource) {
    printTokenWarning();
  }

  var esOptions = {};

  if (token || withCredentials) {
    esOptions.withCredentials = true;
  }

  if (token) {
    esOptions.headers = {
      Authorization: "Bearer ".concat(token)
    };
  }

  return new Observable(function (observer) {
    var es = getEventSource();
    var reconnectTimer;
    var stopped = false;

    function onError() {
      if (stopped) {
        return;
      }

      emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt

      if (stopped) {
        return;
      } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),
      // we should never be in a disconnected state. By default, EventSource will reconnect
      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases
      // (like when a laptop lid is closed), it closes the connection. In these cases we need
      // to explicitly reconnect.


      if (es.readyState === EventSource.CLOSED) {
        unsubscribe();
        clearTimeout(reconnectTimer);
        reconnectTimer = setTimeout(open, 100);
      }
    }

    function onChannelError(err) {
      observer.error(cooerceError(err));
    }

    function onMessage(evt) {
      var event = parseEvent(evt);
      return event instanceof Error ? observer.error(event) : observer.next(event);
    }

    function onDisconnect(evt) {
      stopped = true;
      unsubscribe();
      observer.complete();
    }

    function unsubscribe() {
      es.removeEventListener('error', onError, false);
      es.removeEventListener('channelError', onChannelError, false);
      es.removeEventListener('disconnect', onDisconnect, false);
      listenFor.forEach(function (type) {
        return es.removeEventListener(type, onMessage, false);
      });
      es.close();
    }

    function emitReconnect() {
      if (shouldEmitReconnect) {
        observer.next({
          type: 'reconnect'
        });
      }
    }

    function getEventSource() {
      var evs = new EventSource(uri, esOptions);
      evs.addEventListener('error', onError, false);
      evs.addEventListener('channelError', onChannelError, false);
      evs.addEventListener('disconnect', onDisconnect, false);
      listenFor.forEach(function (type) {
        return evs.addEventListener(type, onMessage, false);
      });
      return evs;
    }

    function open() {
      es = getEventSource();
    }

    function stop() {
      stopped = true;
      unsubscribe();
    }

    return stop;
  });
};

function parseEvent(event) {
  try {
    var data = event.data && JSON.parse(event.data) || {};
    return assign({
      type: event.type
    }, data);
  } catch (err) {
    return err;
  }
}

function cooerceError(err) {
  if (err instanceof Error) {
    return err;
  }

  var evt = parseEvent(err);
  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
}

function extractErrorMessage(err) {
  if (!err.error) {
    return err.message || 'Unknown listener error';
  }

  if (err.error.description) {
    return err.error.description;
  }

  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);
}

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/patch.js":
/*!*******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/patch.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var deepAssign = __webpack_require__(/*! deep-assign */ "./node_modules/deep-assign/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var getSelection = __webpack_require__(/*! ../util/getSelection */ "./node_modules/@sanity/client/lib/util/getSelection.js");

var validate = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

var validateObject = validate.validateObject;
var validateInsert = validate.validateInsert;

function Patch(selection) {
  var operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var client = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  this.selection = selection;
  this.operations = assign({}, operations);
  this.client = client;
}

assign(Patch.prototype, {
  clone: function clone() {
    return new Patch(this.selection, assign({}, this.operations), this.client);
  },
  merge: function merge(props) {
    validateObject('merge', props);
    var stack = new Error().stack.toString().split('\n').filter(function (str) {
      return str.trim();
    }).slice(2);
    console.warn("The \"merge\" patch has been deprecated and will be removed in the future\n".concat(stack.join('\n')));
    return this._assign('merge', deepAssign(this.operations.merge || {}, props));
  },
  set: function set(props) {
    return this._assign('set', props);
  },
  diffMatchPatch: function diffMatchPatch(props) {
    validateObject('diffMatchPatch', props);
    return this._assign('diffMatchPatch', props);
  },
  unset: function unset(attrs) {
    if (!Array.isArray(attrs)) {
      throw new Error('unset(attrs) takes an array of attributes to unset, non-array given');
    }

    this.operations = assign({}, this.operations, {
      unset: attrs
    });
    return this;
  },
  setIfMissing: function setIfMissing(props) {
    return this._assign('setIfMissing', props);
  },
  replace: function replace(props) {
    validateObject('replace', props);
    return this._set('set', {
      $: props
    }); // eslint-disable-line id-length
  },
  inc: function inc(props) {
    return this._assign('inc', props);
  },
  dec: function dec(props) {
    return this._assign('dec', props);
  },
  insert: function insert(at, selector, items) {
    var _this$_assign;

    validateInsert(at, selector, items);
    return this._assign('insert', (_this$_assign = {}, _defineProperty(_this$_assign, at, selector), _defineProperty(_this$_assign, "items", items), _this$_assign));
  },
  append: function append(selector, items) {
    return this.insert('after', "".concat(selector, "[-1]"), items);
  },
  prepend: function prepend(selector, items) {
    return this.insert('before', "".concat(selector, "[0]"), items);
  },
  splice: function splice(selector, start, deleteCount, items) {
    // Negative indexes doesn't mean the same in Sanity as they do in JS;
    // -1 means "actually at the end of the array", which allows inserting
    // at the end of the array without knowing its length. We therefore have
    // to substract negative indexes by one to match JS. If you want Sanity-
    // behaviour, just use `insert('replace', selector, items)` directly
    var delAll = typeof deleteCount === 'undefined' || deleteCount === -1;
    var startIndex = start < 0 ? start - 1 : start;
    var delCount = delAll ? -1 : Math.max(0, start + deleteCount);
    var delRange = startIndex < 0 && delCount >= 0 ? '' : delCount;
    var rangeSelector = "".concat(selector, "[").concat(startIndex, ":").concat(delRange, "]");
    return this.insert('replace', rangeSelector, items || []);
  },
  ifRevisionId: function ifRevisionId(rev) {
    this.operations.ifRevisionID = rev;
    return this;
  },
  serialize: function serialize() {
    return assign(getSelection(this.selection), this.operations);
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!this.client) {
      throw new Error('No `client` passed to patch, either provide one or pass the ' + 'patch to a clients `mutate()` method');
    }

    var returnFirst = typeof this.selection === 'string';
    var opts = assign({
      returnFirst: returnFirst,
      returnDocuments: true
    }, options);
    return this.client.mutate({
      patch: this.serialize()
    }, opts);
  },
  reset: function reset() {
    this.operations = {};
    return this;
  },
  _set: function _set(op, props) {
    return this._assign(op, props, false);
  },
  _assign: function _assign(op, props) {
    var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    validateObject(op, props);
    this.operations = assign({}, this.operations, _defineProperty({}, op, assign({}, merge && this.operations[op] || {}, props)));
    return this;
  }
});
module.exports = Patch;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/data/transaction.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/data/transaction.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var validators = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

var Patch = __webpack_require__(/*! ./patch */ "./node_modules/@sanity/client/lib/data/patch.js");

var defaultMutateOptions = {
  returnDocuments: false
};

function Transaction() {
  var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var client = arguments.length > 1 ? arguments[1] : undefined;
  var transactionId = arguments.length > 2 ? arguments[2] : undefined;
  this.trxId = transactionId;
  this.operations = operations;
  this.client = client;
}

assign(Transaction.prototype, {
  clone: function clone() {
    return new Transaction(this.operations.slice(0), this.client, this.trxId);
  },
  create: function create(doc) {
    validators.validateObject('create', doc);
    return this._add({
      create: doc
    });
  },
  createIfNotExists: function createIfNotExists(doc) {
    var op = 'createIfNotExists';
    validators.validateObject(op, doc);
    validators.requireDocumentId(op, doc);
    return this._add(_defineProperty({}, op, doc));
  },
  createOrReplace: function createOrReplace(doc) {
    var op = 'createOrReplace';
    validators.validateObject(op, doc);
    validators.requireDocumentId(op, doc);
    return this._add(_defineProperty({}, op, doc));
  },
  delete: function _delete(documentId) {
    validators.validateDocumentId('delete', documentId);
    return this._add({
      delete: {
        id: documentId
      }
    });
  },
  patch: function patch(documentId, patchOps) {
    var isBuilder = typeof patchOps === 'function';
    var isPatch = documentId instanceof Patch; // transaction.patch(client.patch('documentId').inc({visits: 1}))

    if (isPatch) {
      return this._add({
        patch: documentId.serialize()
      });
    } // patch => patch.inc({visits: 1}).set({foo: 'bar'})


    if (isBuilder) {
      var patch = patchOps(new Patch(documentId, {}, this.client));

      if (!(patch instanceof Patch)) {
        throw new Error('function passed to `patch()` must return the patch');
      }

      return this._add({
        patch: patch.serialize()
      });
    }

    return this._add({
      patch: assign({
        id: documentId
      }, patchOps)
    });
  },
  transactionId: function transactionId(id) {
    if (!id) {
      return this.trxId;
    }

    this.trxId = id;
    return this;
  },
  serialize: function serialize() {
    return this.operations.slice();
  },
  toJSON: function toJSON() {
    return this.serialize();
  },
  commit: function commit(options) {
    if (!this.client) {
      throw new Error('No `client` passed to transaction, either provide one or pass the ' + 'transaction to a clients `mutate()` method');
    }

    return this.client.mutate(this.serialize(), assign({
      transactionId: this.trxId
    }, defaultMutateOptions, options || {}));
  },
  reset: function reset() {
    this.operations = [];
    return this;
  },
  _add: function _add(mut) {
    this.operations.push(mut);
    return this;
  }
});
module.exports = Transaction;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/datasets/datasetsClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/datasets/datasetsClient.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var validate = __webpack_require__(/*! ../validators */ "./node_modules/@sanity/client/lib/validators.js");

function DatasetsClient(client) {
  this.request = client.request.bind(client);
}

assign(DatasetsClient.prototype, {
  create: function create(name, options) {
    return this._modify('PUT', name, options);
  },
  edit: function edit(name, options) {
    return this._modify('PATCH', name, options);
  },
  delete: function _delete(name) {
    return this._modify('DELETE', name);
  },
  list: function list() {
    return this.request({
      uri: '/datasets'
    });
  },
  _modify: function _modify(method, name, body) {
    validate.dataset(name);
    return this.request({
      method: method,
      uri: "/datasets/".concat(name),
      body: body
    });
  }
});
module.exports = DatasetsClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/browserMiddleware.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/browserMiddleware.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = [];

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/errors.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var makeError = __webpack_require__(/*! make-error */ "./node_modules/make-error/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function ClientError(res) {
  var props = extractErrorProps(res);
  ClientError.super.call(this, props.message);
  assign(this, props);
}

function ServerError(res) {
  var props = extractErrorProps(res);
  ServerError.super.call(this, props.message);
  assign(this, props);
}

function extractErrorProps(res) {
  var body = res.body;
  var props = {
    response: res,
    statusCode: res.statusCode,
    responseBody: stringifyBody(body, res)
  }; // API/Boom style errors ({statusCode, error, message})

  if (body.error && body.message) {
    props.message = "".concat(body.error, " - ").concat(body.message);
    return props;
  } // Query/database errors ({error: {description, other, arb, props}})


  if (body.error && body.error.description) {
    props.message = body.error.description;
    props.details = body.error;
    return props;
  } // Other, more arbitrary errors


  props.message = body.error || body.message || httpErrorMessage(res);
  return props;
}

function httpErrorMessage(res) {
  var statusMessage = res.statusMessage ? " ".concat(res.statusMessage) : '';
  return "".concat(res.method, "-request to ").concat(res.url, " resulted in HTTP ").concat(res.statusCode).concat(statusMessage);
}

function stringifyBody(body, res) {
  var contentType = (res.headers['content-type'] || '').toLowerCase();
  var isJson = contentType.indexOf('application/json') !== -1;
  return isJson ? JSON.stringify(body, null, 2) : body;
}

makeError(ClientError);
makeError(ServerError);
exports.ClientError = ClientError;
exports.ServerError = ServerError;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/queryString.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/queryString.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (params) {
  var qs = [];

  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(params[key])));
    }
  }

  return qs.length > 0 ? "?".concat(qs.join('&')) : '';
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/request.js":
/*!*********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/request.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


/* eslint-disable no-empty-function, no-process-env */
var getIt = __webpack_require__(/*! get-it */ "./node_modules/get-it/index.js");

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var observable = __webpack_require__(/*! get-it/lib/middleware/observable */ "./node_modules/get-it/lib/middleware/observable.js");

var jsonRequest = __webpack_require__(/*! get-it/lib/middleware/jsonRequest */ "./node_modules/get-it/lib/middleware/jsonRequest.js");

var jsonResponse = __webpack_require__(/*! get-it/lib/middleware/jsonResponse */ "./node_modules/get-it/lib/middleware/jsonResponse.js");

var progress = __webpack_require__(/*! get-it/lib/middleware/progress */ "./node_modules/get-it/lib/middleware/progress/index.js");

var Observable = __webpack_require__(/*! @sanity/observable/minimal */ "./node_modules/@sanity/observable/minimal.js");

var _require = __webpack_require__(/*! ./errors */ "./node_modules/@sanity/client/lib/http/errors.js"),
    ClientError = _require.ClientError,
    ServerError = _require.ServerError;

var httpError = {
  onResponse: function onResponse(res) {
    if (res.statusCode >= 500) {
      throw new ServerError(res);
    } else if (res.statusCode >= 400) {
      throw new ClientError(res);
    }

    return res;
  }
};
var printWarnings = {
  onResponse: function onResponse(res) {
    var warn = res.headers['x-sanity-warning'];
    var warnings = Array.isArray(warn) ? warn : [warn];
    warnings.filter(Boolean).forEach(function (msg) {
      return console.warn(msg);
    }); // eslint-disable-line no-console

    return res;
  }
}; // Environment-specific middleware.

var envSpecific = __webpack_require__(/*! ./nodeMiddleware */ "./node_modules/@sanity/client/lib/http/browserMiddleware.js");

var middleware = envSpecific.concat([printWarnings, jsonRequest(), jsonResponse(), progress(), httpError, observable({
  implementation: Observable
})]);
var request = getIt(middleware);

function httpRequest(options) {
  var requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : request;
  return requester(assign({
    maxRedirects: 0
  }, options));
}

httpRequest.defaultRequester = request;
httpRequest.ClientError = ClientError;
httpRequest.ServerError = ServerError;
module.exports = httpRequest;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/http/requestOptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/http/requestOptions.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var projectHeader = 'X-Sanity-Project-ID';

module.exports = function (config) {
  var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var headers = {};
  var token = overrides.token || config.token;

  if (token) {
    headers.Authorization = "Bearer ".concat(token);
  }

  if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
    headers[projectHeader] = config.projectId;
  }

  var withCredentials = Boolean(typeof overrides.withCredentials === 'undefined' ? config.token || config.withCredentials : overrides.withCredentials);
  var timeout = typeof overrides.timeout === 'undefined' ? config.timeout : overrides.timeout;
  return assign({}, overrides, {
    headers: assign({}, headers, overrides.headers || {}),
    timeout: typeof timeout === 'undefined' ? 5 * 60 * 1000 : timeout,
    json: true,
    withCredentials: withCredentials
  });
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/projects/projectsClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/projects/projectsClient.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function ProjectsClient(client) {
  this.client = client;
}

assign(ProjectsClient.prototype, {
  list: function list() {
    return this.client.request({
      uri: '/projects'
    });
  },
  getById: function getById(id) {
    return this.client.request({
      uri: "/projects/".concat(id)
    });
  }
});
module.exports = ProjectsClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/sanityClient.js":
/*!*********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/sanityClient.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require = __webpack_require__(/*! @sanity/observable/operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require.filter;

var _require2 = __webpack_require__(/*! @sanity/observable/operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require2.map;

var Patch = __webpack_require__(/*! ./data/patch */ "./node_modules/@sanity/client/lib/data/patch.js");

var Transaction = __webpack_require__(/*! ./data/transaction */ "./node_modules/@sanity/client/lib/data/transaction.js");

var dataMethods = __webpack_require__(/*! ./data/dataMethods */ "./node_modules/@sanity/client/lib/data/dataMethods.js");

var DatasetsClient = __webpack_require__(/*! ./datasets/datasetsClient */ "./node_modules/@sanity/client/lib/datasets/datasetsClient.js");

var ProjectsClient = __webpack_require__(/*! ./projects/projectsClient */ "./node_modules/@sanity/client/lib/projects/projectsClient.js");

var AssetsClient = __webpack_require__(/*! ./assets/assetsClient */ "./node_modules/@sanity/client/lib/assets/assetsClient.js");

var UsersClient = __webpack_require__(/*! ./users/usersClient */ "./node_modules/@sanity/client/lib/users/usersClient.js");

var AuthClient = __webpack_require__(/*! ./auth/authClient */ "./node_modules/@sanity/client/lib/auth/authClient.js");

var httpRequest = __webpack_require__(/*! ./http/request */ "./node_modules/@sanity/client/lib/http/request.js");

var getRequestOptions = __webpack_require__(/*! ./http/requestOptions */ "./node_modules/@sanity/client/lib/http/requestOptions.js");

var _require3 = __webpack_require__(/*! ./config */ "./node_modules/@sanity/client/lib/config.js"),
    defaultConfig = _require3.defaultConfig,
    initConfig = _require3.initConfig;

var toPromise = function toPromise(observable) {
  return observable.toPromise();
};

function SanityClient() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;

  if (!(this instanceof SanityClient)) {
    return new SanityClient(config);
  }

  this.config(config);
  this.assets = new AssetsClient(this);
  this.datasets = new DatasetsClient(this);
  this.projects = new ProjectsClient(this);
  this.users = new UsersClient(this);
  this.auth = new AuthClient(this);

  if (this.clientConfig.isPromiseAPI) {
    var observableConfig = assign({}, this.clientConfig, {
      isPromiseAPI: false
    });
    this.observable = new SanityClient(observableConfig);
  }
}

assign(SanityClient.prototype, dataMethods);
assign(SanityClient.prototype, {
  clone: function clone() {
    return new SanityClient(this.config());
  },
  config: function config(newConfig) {
    if (typeof newConfig === 'undefined') {
      return assign({}, this.clientConfig);
    }

    if (this.observable) {
      var observableConfig = assign({}, newConfig, {
        isPromiseAPI: false
      });
      this.observable.config(observableConfig);
    }

    this.clientConfig = initConfig(newConfig, this.clientConfig || {});
    return this;
  },
  withConfig: function withConfig(newConfig) {
    return this.clone().config(newConfig);
  },
  getUrl: function getUrl(uri) {
    var canUseCdn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var base = canUseCdn ? this.clientConfig.cdnUrl : this.clientConfig.url;
    return "".concat(base, "/").concat(uri.replace(/^\//, ''));
  },
  isPromiseAPI: function isPromiseAPI() {
    return this.clientConfig.isPromiseAPI;
  },
  _requestObservable: function _requestObservable(options) {
    var uri = options.url || options.uri;
    var canUseCdn = this.clientConfig.useCdn && ['GET', 'HEAD'].indexOf(options.method || 'GET') >= 0 && uri.indexOf('/data/') === 0;
    var reqOptions = getRequestOptions(this.clientConfig, assign({}, options, {
      url: this.getUrl(uri, canUseCdn)
    }));
    return httpRequest(reqOptions, this.clientConfig.requester);
  },
  request: function request(options) {
    var observable = this._requestObservable(options).pipe(filter(function (event) {
      return event.type === 'response';
    }), map(function (event) {
      return event.body;
    }));

    return this.isPromiseAPI() ? toPromise(observable) : observable;
  }
});
SanityClient.Patch = Patch;
SanityClient.Transaction = Transaction;
SanityClient.ClientError = httpRequest.ClientError;
SanityClient.ServerError = httpRequest.ServerError;
SanityClient.requester = httpRequest.defaultRequester;
module.exports = SanityClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/users/usersClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/users/usersClient.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

function UsersClient(client) {
  this.client = client;
}

assign(UsersClient.prototype, {
  getById: function getById(id) {
    return this.client.request({
      uri: "/users/".concat(id)
    });
  }
});
module.exports = UsersClient;

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/defaults.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/defaults.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (obj, defaults) {
  return Object.keys(defaults).concat(Object.keys(obj)).reduce(function (target, prop) {
    target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop];
    return target;
  }, {});
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/getSelection.js":
/*!**************************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/getSelection.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function getSelection(sel) {
  if (typeof sel === 'string' || Array.isArray(sel)) {
    return {
      id: sel
    };
  }

  if (sel && sel.query) {
    return {
      query: sel.query
    };
  }

  var selectionOpts = ['* Document ID (<docId>)', '* Array of document IDs', '* Object containing `query`'].join('\n');
  throw new Error("Unknown selection - must be one of:\n\n".concat(selectionOpts));
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/once.js":
/*!******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/once.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (fn) {
  var didCall = false;
  var returnValue;
  return function () {
    if (didCall) {
      return returnValue;
    }

    returnValue = fn.apply(void 0, arguments);
    didCall = true;
    return returnValue;
  };
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/util/pick.js":
/*!******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/util/pick.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (obj, props) {
  return props.reduce(function (selection, prop) {
    if (typeof obj[prop] === 'undefined') {
      return selection;
    }

    selection[prop] = obj[prop];
    return selection;
  }, {});
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/validators.js":
/*!*******************************************************!*\
  !*** ./node_modules/@sanity/client/lib/validators.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var VALID_ASSET_TYPES = ['image', 'file'];
var VALID_INSERT_LOCATIONS = ['before', 'after', 'replace'];

exports.dataset = function (name) {
  if (!/^(~[a-z0-9]{1}[-\w]{0,25}|[a-z0-9]{1}[-\w]{0,19})$/.test(name)) {
    throw new Error('Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 20 characters');
  }
};

exports.projectId = function (id) {
  if (!/^[-a-z0-9]+$/i.test(id)) {
    throw new Error('`projectId` can only contain only a-z, 0-9 and dashes');
  }
};

exports.validateAssetType = function (type) {
  if (VALID_ASSET_TYPES.indexOf(type) === -1) {
    throw new Error("Invalid asset type: ".concat(type, ". Must be one of ").concat(VALID_ASSET_TYPES.join(', ')));
  }
};

exports.validateObject = function (op, val) {
  if (val === null || _typeof(val) !== 'object' || Array.isArray(val)) {
    throw new Error("".concat(op, "() takes an object of properties"));
  }
};

exports.requireDocumentId = function (op, doc) {
  if (!doc._id) {
    throw new Error("".concat(op, "() requires that the document contains an ID (\"_id\" property)"));
  }

  exports.validateDocumentId(op, doc._id);
};

exports.validateDocumentId = function (op, id) {
  if (typeof id !== 'string' || !/^[a-z0-9_.-]+$/i.test(id)) {
    throw new Error("".concat(op, "(): \"").concat(id, "\" is not a valid document ID"));
  }
};

exports.validateInsert = function (at, selector, items) {
  var signature = 'insert(at, selector, items)';

  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
    var valid = VALID_INSERT_LOCATIONS.map(function (loc) {
      return "\"".concat(loc, "\"");
    }).join(', ');
    throw new Error("".concat(signature, " takes an \"at\"-argument which is one of: ").concat(valid));
  }

  if (typeof selector !== 'string') {
    throw new Error("".concat(signature, " takes a \"selector\"-argument which must be a string"));
  }

  if (!Array.isArray(items)) {
    throw new Error("".concat(signature, " takes an \"items\"-argument which must be an array"));
  }
};

exports.hasDataset = function (config) {
  if (!config.gradientMode && !config.dataset) {
    throw new Error('`dataset` must be provided to perform queries');
  }

  return config.dataset || '';
};

/***/ }),

/***/ "./node_modules/@sanity/client/lib/warnings.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sanity/client/lib/warnings.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


var generateHelpUrl = __webpack_require__(/*! @sanity/generate-help-url */ "./node_modules/@sanity/generate-help-url/index.js");

var once = __webpack_require__(/*! ./util/once */ "./node_modules/@sanity/client/lib/util/once.js");

var createWarningPrinter = function createWarningPrinter(message) {
  return (// eslint-disable-next-line no-console
    once(function () {
      var _console;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_console = console).warn.apply(_console, [message.join(' ')].concat(args));
    })
  );
};

exports.printCdnWarning = createWarningPrinter(['You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and', "cheaper. Think about it! For more info, see ".concat(generateHelpUrl('js-client-cdn-configuration'), "."), 'To hide this warning, please set the `useCdn` option to either `true` or `false` when creating', 'the client.']);
exports.printBrowserTokenWarning = createWarningPrinter(['You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.', "See ".concat(generateHelpUrl('js-client-browser-token'), " for more information and how to hide this warning.")]);
exports.printCdnTokenWarning = createWarningPrinter(['You have set `useCdn` to `true` while also specifying a token. This is usually not what you', 'want. The CDN cannot be used with an authorization token, since private data cannot be cached.', "See ".concat(generateHelpUrl('js-client-usecdn-token'), " for more information.")]);
exports.printNoApiVersionSpecifiedWarning = createWarningPrinter(['Using the Sanity client without specifying an API version is deprecated.', "See ".concat(generateHelpUrl('js-client-api-version'))]);

/***/ }),

/***/ "./node_modules/@sanity/eventsource/browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sanity/eventsource/browser.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-var */
var evs = __webpack_require__(/*! @rexxars/eventsource-polyfill */ "./node_modules/@rexxars/eventsource-polyfill/src/eventsource.js")

module.exports = window.EventSource || evs.EventSource


/***/ }),

/***/ "./node_modules/@sanity/generate-help-url/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@sanity/generate-help-url/index.js ***!
  \*********************************************************/
/***/ ((module) => {

var baseUrl = 'https://docs.sanity.io/help/'

module.exports = function generateHelpUrl(slug) {
  return baseUrl + slug
}


/***/ }),

/***/ "./node_modules/@sanity/observable/lib/SanityObservableMinimal.js":
/*!************************************************************************!*\
  !*** ./node_modules/@sanity/observable/lib/SanityObservableMinimal.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");


var _require = __webpack_require__(/*! rxjs/internal/Observable */ "./node_modules/rxjs/internal/Observable.js"),
    Observable = _require.Observable;

var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var _require2 = __webpack_require__(/*! ../operators/map */ "./node_modules/@sanity/observable/operators/map.js"),
    map = _require2.map;

var _require3 = __webpack_require__(/*! ../operators/filter */ "./node_modules/@sanity/observable/operators/filter.js"),
    filter = _require3.filter;

var _require4 = __webpack_require__(/*! ../operators/reduce */ "./node_modules/@sanity/observable/operators/reduce.js"),
    reduce = _require4.reduce;
/*
 A minimal rxjs based observable that align as closely as possible with the current es-observable spec,
 without the static factory methods
 */


function SanityObservableMinimal() {
  Observable.apply(this, arguments); // eslint-disable-line prefer-rest-params
}

SanityObservableMinimal.prototype = Object.create(assign(Object.create(null), Observable.prototype));
Object.defineProperty(SanityObservableMinimal.prototype, 'constructor', {
  value: SanityObservableMinimal,
  enumerable: false,
  writable: true,
  configurable: true
});

SanityObservableMinimal.prototype.lift = function lift(operator) {
  var observable = new SanityObservableMinimal();
  observable.source = this;
  observable.operator = operator;
  return observable;
};

function createDeprecatedMemberOp(name, op) {
  var hasWarned = false;
  return function deprecatedOperator() {
    if (!hasWarned) {
      hasWarned = true;
      console.warn(new Error("Calling observable.".concat(name, "(...) is deprecated. Please use observable.pipe(").concat(name, "(...)) instead")));
    }

    return this.pipe(op.apply(this, arguments));
  };
}

SanityObservableMinimal.prototype.map = createDeprecatedMemberOp('map', map);
SanityObservableMinimal.prototype.filter = createDeprecatedMemberOp('filter', filter);
SanityObservableMinimal.prototype.reduce = createDeprecatedMemberOp('filter', reduce);
module.exports = SanityObservableMinimal;

/***/ }),

/***/ "./node_modules/@sanity/observable/minimal.js":
/*!****************************************************!*\
  !*** ./node_modules/@sanity/observable/minimal.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/SanityObservableMinimal */ "./node_modules/@sanity/observable/lib/SanityObservableMinimal.js")


/***/ }),

/***/ "./node_modules/@sanity/observable/operators/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/observable/operators/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.filter = __webpack_require__(/*! rxjs/internal/operators/filter */ "./node_modules/rxjs/internal/operators/filter.js").filter


/***/ }),

/***/ "./node_modules/@sanity/observable/operators/map.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sanity/observable/operators/map.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.map = __webpack_require__(/*! rxjs/internal/operators/map */ "./node_modules/rxjs/internal/operators/map.js").map


/***/ }),

/***/ "./node_modules/@sanity/observable/operators/reduce.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sanity/observable/operators/reduce.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.reduce = __webpack_require__(/*! rxjs/internal/operators/reduce */ "./node_modules/rxjs/internal/operators/reduce.js").reduce


/***/ }),

/***/ "./node_modules/array-filter/index.js":
/*!********************************************!*\
  !*** ./node_modules/array-filter/index.js ***!
  \********************************************/
/***/ ((module) => {


/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;


/***/ }),

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/assert/build/internal/errors.js"),
    _require$codes = _require.codes,
    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;

var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/assert/build/internal/assert/assertion_error.js");

var _require2 = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require2.inspect;

var _require$types = __webpack_require__(/*! util/ */ "./node_modules/util/util.js").types,
    isPromise = _require$types.isPromise,
    isRegExp = _require$types.isRegExp;

var objectAssign = Object.assign ? Object.assign : __webpack_require__(/*! es6-object-assign */ "./node_modules/es6-object-assign/index.js").assign;
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;

function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/assert/build/internal/util/comparisons.js");

  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex


var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];

var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};

var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}

function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }

    if (argsLen === 2) operator = '!=';
  }

  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };

  if (message !== undefined) {
    errArgs.message = message;
  }

  var err = new AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
}

assert.fail = fail; // The AssertionError is defined in internal/error.

assert.AssertionError = AssertionError;

function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.


function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  innerOk.apply(void 0, [ok, args.length].concat(args));
}

assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.

/* eslint-disable no-restricted-properties */

assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.


assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
}; // The equivalence assertion tests a deep equality relation.


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
}; // The non-equivalence assertion tests for any deep inequality.


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */


assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

var Comparison = function Comparison(obj, keys, actual) {
  var _this = this;

  _classCallCheck(this, Comparison);

  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }

    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.


    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }

    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }

    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }

      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.


  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}

function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;

    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }

    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }

    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }

    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }

    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }

  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};

assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};

assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};

assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};

assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';

    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    }); // Make sure we actually have a stack trace!

    var origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift(); // Filter all frames existing in err.stack.

      var tmp1 = newErr.stack.split('\n');

      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);

        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }

      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }

    throw newErr;
  }
}; // Expose a strict only variant of assert


function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  innerOk.apply(void 0, [strict, args.length].concat(args));
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require.inspect;

var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/assert/build/internal/errors.js"),
    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat


function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));

  while (count) {
    str += str;
    count--;
  }

  str += str.substring(0, maxCount - str.length);
  return str;
}

var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

var kMaxShortLength = 10;

function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}

function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}

function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.


  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;

      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.


        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).


  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];

  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }

    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.


    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);

      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }

    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }

  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }

  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }

  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");

  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;

    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the expected line to the cache.

      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the actual line to the result.

      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }

      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }

          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.


        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)


    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }

  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}

var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    _classCallCheck(this, AssertionError);

    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    var message = options.message,
        operator = options.operator,
        stackStartFn = options.stackStartFn;
    var actual = options.actual,
        expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;

    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.


      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.


        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);

          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.


        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = inspectValue(actual);

        var other = '';
        var knownOperators = kReadableOperator[operator];

        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);

          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));

          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }

          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }

          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }

    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;

    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.


    _this.stack; // Reset the name.

    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }

  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);

  return AssertionError;
}(_wrapNativeSuper(Error));

module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */

/* eslint node-core/alphabetize-errors: "error" */

/* eslint node-core/prefer-util-format-errors: "error" */
 // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var codes = {}; // Lazy loaded

var assert;
var util;

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inherits(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }

    return NodeError;
  }(Base);

  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
  var inspected = util.inspect(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;

  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }

  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });

  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;

    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }

  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var regexFlagsSupported = /a/g.flags !== undefined;

var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};

var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};

var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/is-nan/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);

var _require$types = __webpack_require__(/*! util/ */ "./node_modules/util/util.js").types,
    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
    isArrayBufferView = _require$types.isArrayBufferView,
    isDate = _require$types.isDate,
    isMap = _require$types.isMap,
    isRegExp = _require$types.isRegExp,
    isSet = _require$types.isSet,
    isNativeError = _require$types.isNativeError,
    isBoxedPrimitive = _require$types.isBoxedPrimitive,
    isNumberObject = _require$types.isNumberObject,
    isStringObject = _require$types.isStringObject,
    isBooleanObject = _require$types.isBooleanObject,
    isBigIntObject = _require$types.isBigIntObject,
    isSymbolObject = _require$types.isSymbolObject,
    isFloat32Array = _require$types.isFloat32Array,
    isFloat64Array = _require$types.isFloat64Array;

function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;

  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.


  return key.length === 10 && key >= Math.pow(2, 32);
}

function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags

function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}

function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }

  return true;
}

function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}

function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}

function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }

  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }

  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }

  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }

  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.


function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.


  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }

    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }

    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }

  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);

  if (val1Tag !== val2Tag) {
    return false;
  }

  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }

    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (keys1.length !== keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.


  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }

  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.


    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);

    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (_keys.length !== _keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return keyCheck(val1, val2, strict, memos, kNoIterator);
}

function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}

function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test


  var i = 0;

  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);

    if (symbolKeysA.length !== 0) {
      var count = 0;

      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];

        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }

          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      var symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.


  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}

function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];

    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }

  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').


function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;

    case 'object':
      // Only pass in null as object!
      return undefined;

    case 'symbol':
      return false;

    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }

  }

  return true;
}

function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}

function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = b.get(altValue);

  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}

function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);

  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.


      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }

      set.add(val);
    }
  }

  if (set !== null) {
    var bValues = arrayFromSet(b);

    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];

    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);

  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
        key = _aEntries$i[0],
        item1 = _aEntries$i[1];

    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }

      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);

      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;

        if (set === null) {
          set = new Set();
        }

        set.add(key);
      }
    }
  }

  if (set !== null) {
    var bEntries = arrayFromMap(b);

    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
          key = _bEntries$_i[0],
          item = _bEntries$_i[1];

      if (_typeof(key) === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;

  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);

        for (; i < keysA.length; i++) {
          var key = keysA[i];

          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== Object.keys(b).length) {
          return false;
        }

        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:


  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }

  return true;
}

function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}

function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var filter = __webpack_require__(/*! array-filter */ "./node_modules/array-filter/index.js");

module.exports = function availableTypedArrays() {
	return filter([
		'BigInt64Array',
		'BigUint64Array',
		'Float32Array',
		'Float64Array',
		'Int16Array',
		'Int32Array',
		'Int8Array',
		'Uint16Array',
		'Uint32Array',
		'Uint8Array',
		'Uint8ClampedArray'
	], function (typedArray) {
		return typeof __webpack_require__.g[typedArray] === 'function';
	});
};


/***/ }),

/***/ "./node_modules/axios-cache-adapter/dist/cache.js":
/*!********************************************************!*\
  !*** ./node_modules/axios-cache-adapter/dist/cache.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
	else {}
})(window, function(__WEBPACK_EXTERNAL_MODULE_axios__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_646__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_646__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_646__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_646__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_646__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_646__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_646__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_646__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_646__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_646__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_646__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_646__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_646__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_646__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_646__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_646__(__nested_webpack_require_646__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/cache-control-esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/cache-control-esm/index.js ***!
  \*************************************************/
/*! exports provided: CacheControl, parse, format, default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_4407__) {

"use strict";
__nested_webpack_require_4407__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_4407__.d(__webpack_exports__, "CacheControl", function() { return CacheControl; });
/* harmony export (binding) */ __nested_webpack_require_4407__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __nested_webpack_require_4407__.d(__webpack_exports__, "format", function() { return format; });
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4407__(/*! core-js/modules/es6.array.from */ "./node_modules/core-js/modules/es6.array.from.js");
/* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_4407__(/*! core-js/modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");
/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_4407__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_4407__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_4407__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_4407__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_4407__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es6_number_is_finite__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_4407__(/*! core-js/modules/es6.number.is-finite */ "./node_modules/core-js/modules/es6.number.is-finite.js");
/* harmony import */ var core_js_modules_es6_number_is_finite__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__nested_webpack_require_4407__.n(core_js_modules_es6_number_is_finite__WEBPACK_IMPORTED_MODULE_7__);









function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var HEADER_REGEXP = /([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:"([^"]*)"|([^ \t",;]*)))?/g;
var STRINGS = {
  maxAge: 'max-age',
  sharedMaxAge: 's-maxage',
  maxStale: 'max-stale',
  minFresh: 'min-fresh',
  immutable: 'immutable',
  mustRevalidate: 'must-revalidate',
  noCache: 'no-cache',
  noStore: 'no-store',
  noTransform: 'no-transform',
  onlyIfCached: 'only-if-cached',
  "private": 'private',
  proxyRevalidate: 'proxy-revalidate',
  "public": 'public'
};

function parseBooleanOnly(value) {
  return value === null;
}

function parseDuration(value) {
  if (!value) {
    return null;
  }

  var duration = parseInt(value, 10);

  if (!Number.isFinite(duration) || duration < 0) {
    return null;
  }

  return duration;
}

var CacheControl = /*#__PURE__*/function () {
  function CacheControl() {
    _classCallCheck(this, CacheControl);

    this.maxAge = null;
    this.sharedMaxAge = null;
    this.maxStale = null;
    this.maxStaleDuration = null;
    this.minFresh = null;
    this.immutable = null;
    this.mustRevalidate = null;
    this.noCache = null;
    this.noStore = null;
    this.noTransform = null;
    this.onlyIfCached = null;
    this["private"] = null;
    this.proxyRevalidate = null;
    this["public"] = null;
  }

  _createClass(CacheControl, [{
    key: "parse",
    value: function parse(header) {
      if (!header || header.length === 0) {
        return this;
      }

      var values = {};
      var matches = header.match(HEADER_REGEXP) || [];
      Array.prototype.forEach.call(matches, function (match) {
        var tokens = match.split('=', 2);

        var _tokens = _slicedToArray(tokens, 1),
            key = _tokens[0];

        var value = null;

        if (tokens.length > 1) {
          value = tokens[1].trim();
        }

        values[key.toLowerCase()] = value;
      });
      this.maxAge = parseDuration(values[STRINGS.maxAge]);
      this.sharedMaxAge = parseDuration(values[STRINGS.sharedMaxAge]);
      this.maxStale = parseBooleanOnly(values[STRINGS.maxStale]);
      this.maxStaleDuration = parseDuration(values[STRINGS.maxStale]);

      if (this.maxStaleDuration) {
        this.maxStale = true;
      }

      this.minFresh = parseDuration(values[STRINGS.minFresh]);
      this.immutable = parseBooleanOnly(values[STRINGS.immutable]);
      this.mustRevalidate = parseBooleanOnly(values[STRINGS.mustRevalidate]);
      this.noCache = parseBooleanOnly(values[STRINGS.noCache]);
      this.noStore = parseBooleanOnly(values[STRINGS.noStore]);
      this.noTransform = parseBooleanOnly(values[STRINGS.noTransform]);
      this.onlyIfCached = parseBooleanOnly(values[STRINGS.onlyIfCached]);
      this["private"] = parseBooleanOnly(values[STRINGS["private"]]);
      this.proxyRevalidate = parseBooleanOnly(values[STRINGS.proxyRevalidate]);
      this["public"] = parseBooleanOnly(values[STRINGS["public"]]);
      return this;
    }
  }, {
    key: "format",
    value: function format() {
      var tokens = [];

      if (this.maxAge) {
        tokens.push("".concat(STRINGS.maxAge, "=").concat(this.maxAge));
      }

      if (this.sharedMaxAge) {
        tokens.push("".concat(STRINGS.sharedMaxAge, "=").concat(this.sharedMaxAge));
      }

      if (this.maxStale) {
        if (this.maxStaleDuration) {
          tokens.push("".concat(STRINGS.maxStale, "=").concat(this.maxStaleDuration));
        } else {
          tokens.push(STRINGS.maxStale);
        }
      }

      if (this.minFresh) {
        tokens.push("".concat(STRINGS.minFresh, "=").concat(this.minFresh));
      }

      if (this.immutable) {
        tokens.push(STRINGS.immutable);
      }

      if (this.mustRevalidate) {
        tokens.push(STRINGS.mustRevalidate);
      }

      if (this.noCache) {
        tokens.push(STRINGS.noCache);
      }

      if (this.noStore) {
        tokens.push(STRINGS.noStore);
      }

      if (this.noTransform) {
        tokens.push(STRINGS.noTransform);
      }

      if (this.onlyIfCached) {
        tokens.push(STRINGS.onlyIfCached);
      }

      if (this["private"]) {
        tokens.push(STRINGS["private"]);
      }

      if (this.proxyRevalidate) {
        tokens.push(STRINGS.proxyRevalidate);
      }

      if (this["public"]) {
        tokens.push(STRINGS["public"]);
      }

      return tokens.join(', ');
    }
  }]);

  return CacheControl;
}();

function parse(header) {
  var cc = new CacheControl();
  return cc.parse(header);
}

function format(cc) {
  if (!(cc instanceof CacheControl)) {
    return CacheControl.prototype.format.call(cc);
  }

  return cc.format();
}


/* harmony default export */ __webpack_exports__["default"] = ({
  CacheControl: CacheControl,
  parse: parse,
  format: format
});

/***/ }),

/***/ "./node_modules/charenc/charenc.js":
/*!*****************************************!*\
  !*** ./node_modules/charenc/charenc.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_16909__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __nested_webpack_require_16909__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __nested_webpack_require_16909__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_17695__) {

"use strict";

var at = __nested_webpack_require_17695__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_18350__) {

var isObject = __nested_webpack_require_18350__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_18916__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __nested_webpack_require_18916__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toLength = __nested_webpack_require_18916__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toAbsoluteIndex = __nested_webpack_require_18916__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_20361__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __nested_webpack_require_20361__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var TAG = __nested_webpack_require_20361__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_22346__) {

"use strict";

var $defineProperty = __nested_webpack_require_22346__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __nested_webpack_require_22346__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_23054__) {

// optional / simple context binding
var aFunction = __nested_webpack_require_23054__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_24436__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__nested_webpack_require_24436__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_25012__) {

var isObject = __nested_webpack_require_25012__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var document = __nested_webpack_require_25012__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_26237__) {

// all enumerable object keys, includes symbols
var getKeys = __nested_webpack_require_26237__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPS = __nested_webpack_require_26237__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var pIE = __nested_webpack_require_26237__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_27219__) {

var global = __nested_webpack_require_27219__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __nested_webpack_require_27219__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var hide = __nested_webpack_require_27219__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefine = __nested_webpack_require_27219__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var ctx = __nested_webpack_require_27219__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/modules/_fails-is-regexp.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_fails-is-regexp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_29472__) {

var MATCH = __nested_webpack_require_29472__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_30508__) {

"use strict";

__nested_webpack_require_30508__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");
var redefine = __nested_webpack_require_30508__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __nested_webpack_require_30508__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var fails = __nested_webpack_require_30508__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var defined = __nested_webpack_require_30508__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
var wks = __nested_webpack_require_30508__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var regexpExec = __nested_webpack_require_30508__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_34591__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __nested_webpack_require_34591__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_function-to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_function-to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_35390__) {

module.exports = __nested_webpack_require_35390__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);


/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_36913__) {

var dP = __nested_webpack_require_36913__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __nested_webpack_require_36913__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
module.exports = __nested_webpack_require_36913__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_37705__) {

var document = __nested_webpack_require_37705__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_38215__) {

module.exports = !__nested_webpack_require_38215__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__nested_webpack_require_38215__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__nested_webpack_require_38215__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_38925__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __nested_webpack_require_38925__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_39616__) {

// check on default Array iterator
var Iterators = __nested_webpack_require_39616__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var ITERATOR = __nested_webpack_require_39616__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_40341__) {

// 7.2.2 IsArray(argument)
var cof = __nested_webpack_require_40341__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_41291__) {

// 7.2.8 IsRegExp(argument)
var isObject = __nested_webpack_require_41291__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var cof = __nested_webpack_require_41291__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var MATCH = __nested_webpack_require_41291__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_42088__) {

// call something on iterator step with safe closing on error
var anObject = __nested_webpack_require_42088__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_42898__) {

"use strict";

var create = __nested_webpack_require_42898__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var descriptor = __nested_webpack_require_42898__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var setToStringTag = __nested_webpack_require_42898__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__nested_webpack_require_42898__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __nested_webpack_require_42898__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_44086__) {

"use strict";

var LIBRARY = __nested_webpack_require_44086__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $export = __nested_webpack_require_44086__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __nested_webpack_require_44086__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __nested_webpack_require_44086__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __nested_webpack_require_44086__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var $iterCreate = __nested_webpack_require_44086__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");
var setToStringTag = __nested_webpack_require_44086__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var getPrototypeOf = __nested_webpack_require_44086__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var ITERATOR = __nested_webpack_require_44086__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_47772__) {

var ITERATOR = __nested_webpack_require_47772__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_49827__) {

var META = __nested_webpack_require_49827__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');
var isObject = __nested_webpack_require_49827__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var has = __nested_webpack_require_49827__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var setDesc = __nested_webpack_require_49827__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__nested_webpack_require_49827__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_52033__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __nested_webpack_require_52033__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var dPs = __nested_webpack_require_52033__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");
var enumBugKeys = __nested_webpack_require_52033__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");
var IE_PROTO = __nested_webpack_require_52033__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __nested_webpack_require_52033__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __nested_webpack_require_52033__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_54252__) {

var anObject = __nested_webpack_require_54252__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __nested_webpack_require_54252__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __nested_webpack_require_54252__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __nested_webpack_require_54252__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_55450__) {

var dP = __nested_webpack_require_55450__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var anObject = __nested_webpack_require_55450__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var getKeys = __nested_webpack_require_55450__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __nested_webpack_require_55450__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_56450__) {

var pIE = __nested_webpack_require_56450__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");
var createDesc = __nested_webpack_require_56450__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var toIObject = __nested_webpack_require_56450__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __nested_webpack_require_56450__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var has = __nested_webpack_require_56450__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var IE8_DOM_DEFINE = __nested_webpack_require_56450__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __nested_webpack_require_56450__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_57837__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __nested_webpack_require_57837__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var gOPN = __nested_webpack_require_57837__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_58908__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __nested_webpack_require_58908__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var hiddenKeys = __nested_webpack_require_58908__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_60028__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __nested_webpack_require_60028__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toObject = __nested_webpack_require_60028__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IE_PROTO = __nested_webpack_require_60028__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_61080__) {

var has = __nested_webpack_require_61080__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toIObject = __nested_webpack_require_61080__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var arrayIndexOf = __nested_webpack_require_61080__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var IE_PROTO = __nested_webpack_require_61080__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_62210__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __nested_webpack_require_62210__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var enumBugKeys = __nested_webpack_require_62210__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_own-keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_63247__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __nested_webpack_require_63247__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js");
var gOPS = __nested_webpack_require_63247__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var anObject = __nested_webpack_require_63247__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var Reflect = __nested_webpack_require_63247__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_64733__) {

var global = __nested_webpack_require_64733__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __nested_webpack_require_64733__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var has = __nested_webpack_require_64733__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var SRC = __nested_webpack_require_64733__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');
var $toString = __nested_webpack_require_64733__(/*! ./_function-to-string */ "./node_modules/core-js/modules/_function-to-string.js");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__nested_webpack_require_64733__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_66523__) {

"use strict";


var classof = __nested_webpack_require_66523__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_67537__) {

"use strict";


var regexpFlags = __nested_webpack_require_67537__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_69698__) {

var def = __nested_webpack_require_69698__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var has = __nested_webpack_require_69698__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var TAG = __nested_webpack_require_69698__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_70472__) {

var shared = __nested_webpack_require_70472__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');
var uid = __nested_webpack_require_70472__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_71066__) {

var core = __nested_webpack_require_71066__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var global = __nested_webpack_require_71066__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __nested_webpack_require_71066__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_72043__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __nested_webpack_require_72043__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var aFunction = __nested_webpack_require_72043__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
var SPECIES = __nested_webpack_require_72043__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_72906__) {

var toInteger = __nested_webpack_require_72906__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var defined = __nested_webpack_require_72906__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_string-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-context.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_74001__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __nested_webpack_require_74001__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var defined = __nested_webpack_require_74001__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_74801__) {

var toInteger = __nested_webpack_require_74801__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_75893__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __nested_webpack_require_75893__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var defined = __nested_webpack_require_75893__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_76562__) {

// 7.1.15 ToLength
var toInteger = __nested_webpack_require_76562__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_77170__) {

// 7.1.13 ToObject(argument)
var defined = __nested_webpack_require_77170__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_77704__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __nested_webpack_require_77704__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_79200__) {

var global = __nested_webpack_require_79200__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __nested_webpack_require_79200__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var LIBRARY = __nested_webpack_require_79200__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var wksExt = __nested_webpack_require_79200__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var defineProperty = __nested_webpack_require_79200__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_80245__) {

exports.f = __nested_webpack_require_80245__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_80638__) {

var store = __nested_webpack_require_80638__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');
var uid = __nested_webpack_require_80638__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var Symbol = __nested_webpack_require_80638__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_81560__) {

var classof = __nested_webpack_require_81560__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var ITERATOR = __nested_webpack_require_81560__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var Iterators = __nested_webpack_require_81560__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
module.exports = __nested_webpack_require_81560__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.from.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_82444__) {

"use strict";

var ctx = __nested_webpack_require_82444__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var $export = __nested_webpack_require_82444__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toObject = __nested_webpack_require_82444__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var call = __nested_webpack_require_82444__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __nested_webpack_require_82444__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
var toLength = __nested_webpack_require_82444__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var createProperty = __nested_webpack_require_82444__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");
var getIterFn = __nested_webpack_require_82444__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__nested_webpack_require_82444__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_85033__) {

"use strict";

var addToUnscopables = __nested_webpack_require_85033__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");
var step = __nested_webpack_require_85033__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");
var Iterators = __nested_webpack_require_85033__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var toIObject = __nested_webpack_require_85033__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __nested_webpack_require_85033__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_86838__) {

var dP = __nested_webpack_require_86838__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __nested_webpack_require_86838__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_87691__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __nested_webpack_require_87691__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var _isFinite = __nested_webpack_require_87691__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_88427__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __nested_webpack_require_88427__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var test = {};
test[__nested_webpack_require_88427__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __nested_webpack_require_88427__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_89280__) {

"use strict";

var regexpExec = __nested_webpack_require_89280__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
__nested_webpack_require_89280__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_89938__) {

"use strict";


var isRegExp = __nested_webpack_require_89938__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");
var anObject = __nested_webpack_require_89938__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var speciesConstructor = __nested_webpack_require_89938__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
var advanceStringIndex = __nested_webpack_require_89938__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");
var toLength = __nested_webpack_require_89938__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var callRegExpExec = __nested_webpack_require_89938__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");
var regexpExec = __nested_webpack_require_89938__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");
var fails = __nested_webpack_require_89938__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__nested_webpack_require_89938__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_96137__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __nested_webpack_require_96137__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var context = __nested_webpack_require_96137__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");
var INCLUDES = 'includes';

$export($export.P + $export.F * __nested_webpack_require_96137__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_97145__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __nested_webpack_require_97145__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var has = __nested_webpack_require_97145__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var DESCRIPTORS = __nested_webpack_require_97145__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var $export = __nested_webpack_require_97145__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __nested_webpack_require_97145__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var META = __nested_webpack_require_97145__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;
var $fails = __nested_webpack_require_97145__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var shared = __nested_webpack_require_97145__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");
var setToStringTag = __nested_webpack_require_97145__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var uid = __nested_webpack_require_97145__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var wks = __nested_webpack_require_97145__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var wksExt = __nested_webpack_require_97145__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");
var wksDefine = __nested_webpack_require_97145__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");
var enumKeys = __nested_webpack_require_97145__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");
var isArray = __nested_webpack_require_97145__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");
var anObject = __nested_webpack_require_97145__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var isObject = __nested_webpack_require_97145__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var toObject = __nested_webpack_require_97145__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toIObject = __nested_webpack_require_97145__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __nested_webpack_require_97145__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var createDesc = __nested_webpack_require_97145__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var _create = __nested_webpack_require_97145__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var gOPNExt = __nested_webpack_require_97145__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");
var $GOPD = __nested_webpack_require_97145__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var $GOPS = __nested_webpack_require_97145__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");
var $DP = __nested_webpack_require_97145__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var $keys = __nested_webpack_require_97145__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __nested_webpack_require_97145__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __nested_webpack_require_97145__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__nested_webpack_require_97145__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __nested_webpack_require_97145__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.includes.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_108765__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __nested_webpack_require_108765__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var $includes = __nested_webpack_require_108765__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__nested_webpack_require_108765__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('includes');


/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_109792__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __nested_webpack_require_109792__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var ownKeys = __nested_webpack_require_109792__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js");
var toIObject = __nested_webpack_require_109792__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var gOPD = __nested_webpack_require_109792__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
var createProperty = __nested_webpack_require_109792__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_111195__) {

__nested_webpack_require_111195__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_111655__) {

var $iterators = __nested_webpack_require_111655__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
var getKeys = __nested_webpack_require_111655__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");
var redefine = __nested_webpack_require_111655__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var global = __nested_webpack_require_111655__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __nested_webpack_require_111655__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __nested_webpack_require_111655__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var wks = __nested_webpack_require_111655__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "./node_modules/crypt/crypt.js":
/*!*************************************!*\
  !*** ./node_modules/crypt/crypt.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/md5/md5.js":
/*!*********************************!*\
  !*** ./node_modules/md5/md5.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_118336__) {

(function(){
  var crypt = __nested_webpack_require_118336__(/*! crypt */ "./node_modules/crypt/crypt.js"),
      utf8 = __nested_webpack_require_118336__(/*! charenc */ "./node_modules/charenc/charenc.js").utf8,
      isBuffer = __nested_webpack_require_118336__(/*! is-buffer */ "./node_modules/is-buffer/index.js"),
      bin = __nested_webpack_require_118336__(/*! charenc */ "./node_modules/charenc/charenc.js").bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
    true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./src/api.js":
/*!********************!*\
  !*** ./src/api.js ***!
  \********************/
/*! exports provided: setup, setupCache, serializeQuery, default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_149728__) {

"use strict";
__nested_webpack_require_149728__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_149728__.d(__webpack_exports__, "setup", function() { return setup; });
/* harmony export (binding) */ __nested_webpack_require_149728__.d(__webpack_exports__, "setupCache", function() { return setupCache; });
/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_149728__(/*! core-js/modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");
/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_149728__.n(core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_149728__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_149728__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_149728__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_149728__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_149728__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_149728__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_149728__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_149728__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_149728__(/*! axios */ "axios");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__nested_webpack_require_149728__.n(axios__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_149728__(/*! ./request */ "./src/request.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_149728__(/*! ./cache */ "./src/cache.js");
/* harmony reexport (safe) */ __nested_webpack_require_149728__.d(__webpack_exports__, "serializeQuery", function() { return _cache__WEBPACK_IMPORTED_MODULE_7__["serializeQuery"]; });

/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_149728__(/*! ./config */ "./src/config.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_149728__(/*! ./utilities */ "./src/utilities.js");






function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }






/**
 * Configure cache adapter
 *
 * @param   {object} [config={}] Cache adapter options
 * @returns {object} Object containing cache `adapter` and `store`
 */

function setupCache() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Extend default configuration
  config = Object(_config__WEBPACK_IMPORTED_MODULE_8__["makeConfig"])(config); // Axios adapter. Receives the axios request configuration as only parameter

  function adapter(_x) {
    return _adapter.apply(this, arguments);
  } // Return adapter and store instance


  function _adapter() {
    _adapter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(req) {
      var reqConfig, res, next, networkError, readOnError;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Merge the per-request config with the instance config.
              reqConfig = Object(_config__WEBPACK_IMPORTED_MODULE_8__["mergeRequestConfig"])(config, req); // Execute request against local cache

              _context.next = 3;
              return Object(_request__WEBPACK_IMPORTED_MODULE_6__["default"])(reqConfig, req);

            case 3:
              res = _context.sent;
              next = res.next; // Response is not function, something was in cache, return it

              if (Object(_utilities__WEBPACK_IMPORTED_MODULE_9__["isFunction"])(next)) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", next);

            case 7:
              _context.prev = 7;
              _context.next = 10;
              return reqConfig.adapter(req);

            case 10:
              res = _context.sent;
              _context.next = 16;
              break;

            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](7);
              networkError = _context.t0;

            case 16:
              if (!networkError) {
                _context.next = 31;
                break;
              }

              // Check if we should attempt reading stale cache data
              readOnError = Object(_utilities__WEBPACK_IMPORTED_MODULE_9__["isFunction"])(reqConfig.readOnError) ? reqConfig.readOnError(networkError, req) : reqConfig.readOnError;

              if (!readOnError) {
                _context.next = 30;
                break;
              }

              _context.prev = 19;
              // Force cache tu return stale data
              reqConfig.acceptStale = true; // Try to read from cache again

              _context.next = 23;
              return Object(_request__WEBPACK_IMPORTED_MODULE_6__["default"])(reqConfig, req);

            case 23:
              res = _context.sent;
              // Signal that data is from stale cache
              res.next.request.stale = true; // No need to check if `next` is a function just return cache data

              return _context.abrupt("return", res.next);

            case 28:
              _context.prev = 28;
              _context.t1 = _context["catch"](19);

            case 30:
              throw networkError;

            case 31:
              return _context.abrupt("return", next(res));

            case 32:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[7, 13], [19, 28]]);
    }));
    return _adapter.apply(this, arguments);
  }

  return {
    adapter: adapter,
    config: config,
    store: config.store
  };
} // ---------------------
// Easy API Setup
// ---------------------

/**
 * Setup an axios instance with the cache adapter pre-configured
 *
 * @param {object} [options={}] Axios and cache adapter options
 * @returns {object} Instance of Axios
 */


function setup() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var instanceConfig = _objectSpread(_objectSpread(_objectSpread({}, _config__WEBPACK_IMPORTED_MODULE_8__["defaults"].axios), config), {}, {
    cache: _objectSpread(_objectSpread({}, _config__WEBPACK_IMPORTED_MODULE_8__["defaults"].axios.cache), config.cache)
  });

  var cache = setupCache(instanceConfig.cache);

  var _ = instanceConfig.cache,
      axiosConfig = _objectWithoutProperties(instanceConfig, ["cache"]);

  var api = axios__WEBPACK_IMPORTED_MODULE_5___default.a.create(_objectSpread(_objectSpread({}, axiosConfig), {}, {
    adapter: cache.adapter
  }));
  api.cache = cache.store;
  return api;
}


/* harmony default export */ __webpack_exports__["default"] = ({
  setup: setup,
  setupCache: setupCache,
  serializeQuery: _cache__WEBPACK_IMPORTED_MODULE_7__["serializeQuery"]
});

/***/ }),

/***/ "./src/cache.js":
/*!**********************!*\
  !*** ./src/cache.js ***!
  \**********************/
/*! exports provided: read, write, key, invalidate, serializeQuery, default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_160632__) {

"use strict";
__nested_webpack_require_160632__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_160632__.d(__webpack_exports__, "read", function() { return read; });
/* harmony export (binding) */ __nested_webpack_require_160632__.d(__webpack_exports__, "write", function() { return write; });
/* harmony export (binding) */ __nested_webpack_require_160632__.d(__webpack_exports__, "key", function() { return key; });
/* harmony export (binding) */ __nested_webpack_require_160632__.d(__webpack_exports__, "invalidate", function() { return invalidate; });
/* harmony export (binding) */ __nested_webpack_require_160632__.d(__webpack_exports__, "serializeQuery", function() { return serializeQuery; });
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_160632__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_160632__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_160632__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_160632__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_160632__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_160632__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_160632__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_160632__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_160632__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_160632__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_160632__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_160632__(/*! md5 */ "./node_modules/md5/md5.js");
/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__nested_webpack_require_160632__.n(md5__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _serialize__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_160632__(/*! ./serialize */ "./src/serialize.js");






function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





function write(_x, _x2, _x3) {
  return _write.apply(this, arguments);
}

function _write() {
  _write = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config, req, res) {
    var entry;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            entry = {
              expires: config.expires,
              data: Object(_serialize__WEBPACK_IMPORTED_MODULE_7__["default"])(config, req, res)
            };
            _context.next = 4;
            return config.store.setItem(config.uuid, entry);

          case 4:
            _context.next = 19;
            break;

          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](0);
            config.debug('Could not store response', _context.t0);

            if (!config.clearOnError) {
              _context.next = 18;
              break;
            }

            _context.prev = 10;
            _context.next = 13;
            return config.store.clear();

          case 13:
            _context.next = 18;
            break;

          case 15:
            _context.prev = 15;
            _context.t1 = _context["catch"](10);
            config.debug('Could not clear store', _context.t1);

          case 18:
            return _context.abrupt("return", false);

          case 19:
            return _context.abrupt("return", true);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 6], [10, 15]]);
  }));
  return _write.apply(this, arguments);
}

function read(_x4, _x5) {
  return _read.apply(this, arguments);
}

function _read() {
  _read = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(config, req) {
    var uuid, ignoreCache, entry, error, expires, data, offline, _error;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            uuid = config.uuid, ignoreCache = config.ignoreCache;
            _context2.next = 3;
            return config.store.getItem(uuid);

          case 3:
            entry = _context2.sent;

            if (!(ignoreCache || !entry || !entry.data)) {
              _context2.next = 10;
              break;
            }

            config.debug('cache-miss', req.url);
            error = new Error();
            error.reason = 'cache-miss';
            error.message = 'Entry not found from cache';
            throw error;

          case 10:
            expires = entry.expires, data = entry.data; // Do not check for stale cache if offline on client-side

            offline = typeof navigator !== 'undefined' && 'onLine' in navigator && !navigator.onLine;

            if (!(!offline && !config.acceptStale && expires !== 0 && expires < Date.now())) {
              _context2.next = 18;
              break;
            }

            config.debug('cache-stale', req.url);
            _error = new Error();
            _error.reason = 'cache-stale';
            _error.message = 'Entry is stale';
            throw _error;

          case 18:
            config.debug(config.acceptStale ? 'cache-hit-stale' : 'cache-hit', req.url);
            return _context2.abrupt("return", data);

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _read.apply(this, arguments);
}

function key(config) {
  if (Object(_utilities__WEBPACK_IMPORTED_MODULE_5__["isFunction"])(config.key)) return config.key;
  var cacheKey;

  if (Object(_utilities__WEBPACK_IMPORTED_MODULE_5__["isString"])(config.key)) {
    cacheKey = function cacheKey(req) {
      var url = "".concat(req.baseURL ? req.baseURL : '').concat(req.url);
      var key = "".concat(config.key, "/").concat(url).concat(serializeQuery(req));
      return req.data ? key + md5__WEBPACK_IMPORTED_MODULE_6___default()(req.data) : key;
    };
  } else {
    cacheKey = function cacheKey(req) {
      var url = "".concat(req.baseURL ? req.baseURL : '').concat(req.url);
      var key = url + serializeQuery(req);
      return req.data ? key + md5__WEBPACK_IMPORTED_MODULE_6___default()(req.data) : key;
    };
  }

  return cacheKey;
}

function defaultInvalidate(_x6, _x7) {
  return _defaultInvalidate.apply(this, arguments);
}

function _defaultInvalidate() {
  _defaultInvalidate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(config, req) {
    var method;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            method = req.method.toLowerCase();

            if (!config.exclude.methods.includes(method)) {
              _context3.next = 4;
              break;
            }

            _context3.next = 4;
            return config.store.removeItem(config.uuid);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _defaultInvalidate.apply(this, arguments);
}

function invalidate() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (Object(_utilities__WEBPACK_IMPORTED_MODULE_5__["isFunction"])(config.invalidate)) return config.invalidate;
  return defaultInvalidate;
}

function serializeQuery(req) {
  if (!req.params) return ''; // Probably server-side, just stringify the object

  if (typeof URLSearchParams === 'undefined') return JSON.stringify(req.params);
  var params = req.params;
  var isInstanceOfURLSearchParams = req.params instanceof URLSearchParams; // Convert to an instance of URLSearchParams so it get serialized the same way

  if (!isInstanceOfURLSearchParams) {
    params = new URLSearchParams();
    Object.keys(req.params).forEach(function (key) {
      return params.append(key, req.params[key]);
    });
  }

  return "?".concat(params.toString());
}


/* harmony default export */ __webpack_exports__["default"] = ({
  read: read,
  write: write,
  key: key,
  invalidate: invalidate,
  serializeQuery: serializeQuery
});

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: defaults, makeConfig, mergeRequestConfig, default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_171022__) {

"use strict";
__nested_webpack_require_171022__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_171022__.d(__webpack_exports__, "defaults", function() { return defaults; });
/* harmony export (binding) */ __nested_webpack_require_171022__.d(__webpack_exports__, "makeConfig", function() { return makeConfig; });
/* harmony export (binding) */ __nested_webpack_require_171022__.d(__webpack_exports__, "mergeRequestConfig", function() { return mergeRequestConfig; });
/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_171022__(/*! core-js/modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");
/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_171022__.n(core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_171022__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_171022__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_171022__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_171022__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_171022__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_171022__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_171022__(/*! axios */ "axios");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_171022__.n(axios__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_171022__(/*! ./memory */ "./src/memory.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_171022__(/*! ./cache */ "./src/cache.js");





function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var noop = function noop() {};

var debug = function debug() {
  var _console;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (_console = console).log.apply(_console, ['[axios-cache-adapter]'].concat(args));
};

var defaults = {
  // Default settings when solely creating the cache adapter with setupCache.
  cache: {
    maxAge: 0,
    limit: false,
    store: null,
    key: null,
    invalidate: null,
    exclude: {
      paths: [],
      query: true,
      filter: null,
      methods: ['post', 'patch', 'put', 'delete']
    },
    adapter: axios__WEBPACK_IMPORTED_MODULE_4___default.a.defaults.adapter,
    clearOnStale: true,
    clearOnError: true,
    readOnError: false,
    readHeaders: false,
    debug: false,
    ignoreCache: false
  },
  // Additional defaults when creating the axios instance with the cache adapter.
  axios: {
    cache: {
      maxAge: 15 * 60 * 1000
    }
  }
}; // List of disallowed in the per-request config.

var disallowedPerRequestKeys = ['limit', 'store', 'adapter', 'uuid', 'acceptStale'];
/**
 * Make a global config object.
 *
 * @param {Object} [override={}] Optional config override.
 * @return {Object}
 */

var makeConfig = function makeConfig() {
  var override = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var config = _objectSpread(_objectSpread(_objectSpread({}, defaults.cache), override), {}, {
    exclude: _objectSpread(_objectSpread({}, defaults.cache.exclude), override.exclude)
  }); // Create a cache key method


  config.key = Object(_cache__WEBPACK_IMPORTED_MODULE_6__["key"])(config);
  config.invalidate = Object(_cache__WEBPACK_IMPORTED_MODULE_6__["invalidate"])(config); // If debug mode is on, create a simple logger method

  if (config.debug !== false) {
    config.debug = typeof config.debug === 'function' ? config.debug : debug;
  } else {
    config.debug = noop;
  } // Create an in memory store if none was given


  if (!config.store) config.store = new _memory__WEBPACK_IMPORTED_MODULE_5__["default"]();
  config.debug('Global cache config', config);
  return config;
};
/**
 * Merge the per-request config in another config.
 *
 * This method exists because not all keys should be allowed as it
 * may lead to unexpected behaviours. For instance, setting another
 * store or adapter per request is wrong, instead another instance
 * axios, or the adapter, should be used.
 *
 * @param {Object} config Config object.
 * @param {Object} req    The current axios request
 * @return {Object}
 */


var mergeRequestConfig = function mergeRequestConfig(config, req) {
  var requestConfig = req.cache || {};

  if (requestConfig) {
    disallowedPerRequestKeys.forEach(function (key) {
      return requestConfig[key] ? delete requestConfig[key] : undefined;
    });
  }

  var mergedConfig = _objectSpread(_objectSpread(_objectSpread({}, config), requestConfig), {}, {
    exclude: _objectSpread(_objectSpread({}, config.exclude), requestConfig.exclude)
  });

  if (mergedConfig.debug === true) {
    mergedConfig.debug = debug;
  } // Create a cache key method


  if (requestConfig.key) {
    mergedConfig.key = Object(_cache__WEBPACK_IMPORTED_MODULE_6__["key"])(requestConfig);
  } // Generate request UUID


  mergedConfig.uuid = mergedConfig.key(req);
  config.debug("Request config for ".concat(req.url), mergedConfig);
  return mergedConfig;
};


/* harmony default export */ __webpack_exports__["default"] = ({
  defaults: defaults,
  makeConfig: makeConfig,
  mergeRequestConfig: mergeRequestConfig
});

/***/ }),

/***/ "./src/exclude.js":
/*!************************!*\
  !*** ./src/exclude.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_178607__) {

"use strict";
__nested_webpack_require_178607__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_178607__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_178607__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_178607__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_178607__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_178607__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_178607__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_178607__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_178607__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_178607__(/*! ./utilities */ "./src/utilities.js");






function exclude() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var req = arguments.length > 1 ? arguments[1] : undefined;
  var _config$exclude = config.exclude,
      exclude = _config$exclude === void 0 ? {} : _config$exclude,
      debug = config.debug;
  var method = req.method.toLowerCase();

  if (method === 'head' || exclude.methods.includes(method)) {
    debug("Excluding request by HTTP method ".concat(req.url));
    return true;
  }

  if (typeof exclude.filter === 'function' && exclude.filter(req)) {
    debug("Excluding request by filter ".concat(req.url));
    return true;
  } // do not cache request with query


  var hasQueryParams = /\?.*$/.test(req.url) || Object(_utilities__WEBPACK_IMPORTED_MODULE_4__["isObject"])(req.params) && Object.keys(req.params).length !== 0 || typeof URLSearchParams !== 'undefined' && req.params instanceof URLSearchParams;

  if (exclude.query && hasQueryParams) {
    debug("Excluding request by query ".concat(req.url));
    return true;
  }

  var paths = exclude.paths || [];
  var found = paths.some(function (regexp) {
    return req.url.match(regexp);
  });

  if (found) {
    debug("Excluding request by url match ".concat(req.url));
    return true;
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (exclude);

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: setup, setupCache, serializeQuery, default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_182070__) {

"use strict";
__nested_webpack_require_182070__.r(__webpack_exports__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_182070__(/*! ./api */ "./src/api.js");
/* harmony reexport (safe) */ __nested_webpack_require_182070__.d(__webpack_exports__, "setup", function() { return _api__WEBPACK_IMPORTED_MODULE_0__["setup"]; });

/* harmony reexport (safe) */ __nested_webpack_require_182070__.d(__webpack_exports__, "setupCache", function() { return _api__WEBPACK_IMPORTED_MODULE_0__["setupCache"]; });

/* harmony reexport (safe) */ __nested_webpack_require_182070__.d(__webpack_exports__, "serializeQuery", function() { return _api__WEBPACK_IMPORTED_MODULE_0__["serializeQuery"]; });

/* harmony reexport (safe) */ __nested_webpack_require_182070__.d(__webpack_exports__, "default", function() { return _api__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./src/limit.js":
/*!**********************!*\
  !*** ./src/limit.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_183098__) {

"use strict";
__nested_webpack_require_183098__.r(__webpack_exports__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_183098__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_183098__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_183098__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_183098__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);



function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function limit(_x) {
  return _limit.apply(this, arguments);
}

function _limit() {
  _limit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config) {
    var length, firstItem;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return config.store.length();

          case 2:
            length = _context.sent;

            if (!(length < config.limit)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return");

          case 5:
            config.debug("Current store size: ".concat(length));
            _context.next = 8;
            return config.store.iterate(function (value, key) {
              if (!firstItem) firstItem = {
                value: value,
                key: key
              };
              if (value.expires < firstItem.value.expires) firstItem = {
                value: value,
                key: key
              };
            });

          case 8:
            if (!firstItem) {
              _context.next = 12;
              break;
            }

            config.debug("Removing item: ".concat(firstItem.key));
            _context.next = 12;
            return config.store.removeItem(firstItem.key);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _limit.apply(this, arguments);
}

/* harmony default export */ __webpack_exports__["default"] = (limit);

/***/ }),

/***/ "./src/memory.js":
/*!***********************!*\
  !*** ./src/memory.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_186447__) {

"use strict";
__nested_webpack_require_186447__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_186447__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_186447__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_186447__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_186447__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_186447__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_186447__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_186447__(/*! ./utilities */ "./src/utilities.js");




function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var MemoryStore = /*#__PURE__*/function () {
  function MemoryStore() {
    _classCallCheck(this, MemoryStore);

    this.store = {};
  }

  _createClass(MemoryStore, [{
    key: "getItem",
    value: function () {
      var _getItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key) {
        var item;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                item = this.store[key] || null;
                return _context.abrupt("return", JSON.parse(item));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getItem(_x) {
        return _getItem.apply(this, arguments);
      }

      return getItem;
    }()
  }, {
    key: "setItem",
    value: function () {
      var _setItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key, value) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.store[key] = JSON.stringify(value);
                return _context2.abrupt("return", value);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setItem(_x2, _x3) {
        return _setItem.apply(this, arguments);
      }

      return setItem;
    }()
  }, {
    key: "removeItem",
    value: function () {
      var _removeItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                delete this.store[key];

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function removeItem(_x4) {
        return _removeItem.apply(this, arguments);
      }

      return removeItem;
    }()
  }, {
    key: "clear",
    value: function () {
      var _clear = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.store = {};

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function clear() {
        return _clear.apply(this, arguments);
      }

      return clear;
    }()
  }, {
    key: "length",
    value: function () {
      var _length = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", Object.keys(this.store).length);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function length() {
        return _length.apply(this, arguments);
      }

      return length;
    }()
  }, {
    key: "iterate",
    value: function iterate(fn) {
      return Promise.all(Object(_utilities__WEBPACK_IMPORTED_MODULE_3__["mapObject"])(this.store, fn));
    }
  }]);

  return MemoryStore;
}();

/* harmony default export */ __webpack_exports__["default"] = (MemoryStore);

/***/ }),

/***/ "./src/request.js":
/*!************************!*\
  !*** ./src/request.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_193252__) {

"use strict";
__nested_webpack_require_193252__.r(__webpack_exports__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_193252__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_193252__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_193252__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_193252__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _response__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_193252__(/*! ./response */ "./src/response.js");
/* harmony import */ var _exclude__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_193252__(/*! ./exclude */ "./src/exclude.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_193252__(/*! ./cache */ "./src/cache.js");



function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





function request(_x, _x2) {
  return _request.apply(this, arguments);
}

function _request() {
  _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config, req) {
    var next, res, excludeFromCache;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            excludeFromCache = function _excludeFromCache() {
              config.excludeFromCache = true;
              return {
                config: config,
                next: next
              };
            };

            config.debug('uuid', config.uuid);

            next = function next() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              return _response__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, [config, req].concat(args));
            }; // run invalidate function to check if any cache items need to be invalidated.


            _context.next = 5;
            return config.invalidate(config, req);

          case 5:
            if (!Object(_exclude__WEBPACK_IMPORTED_MODULE_3__["default"])(config, req)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return", excludeFromCache());

          case 7:
            _context.prev = 7;
            _context.next = 10;
            return Object(_cache__WEBPACK_IMPORTED_MODULE_4__["read"])(config, req);

          case 10:
            res = _context.sent;
            res.config = req;
            res.request = {
              fromCache: true
            };
            return _context.abrupt("return", {
              config: config,
              next: res
            });

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](7);

            if (!(config.clearOnStale && _context.t0.reason === 'cache-stale')) {
              _context.next = 21;
              break;
            }

            _context.next = 21;
            return config.store.removeItem(config.uuid);

          case 21:
            return _context.abrupt("return", {
              config: config,
              next: next
            });

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 16]]);
  }));
  return _request.apply(this, arguments);
}

/* harmony default export */ __webpack_exports__["default"] = (request);

/***/ }),

/***/ "./src/response.js":
/*!*************************!*\
  !*** ./src/response.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_197939__) {

"use strict";
__nested_webpack_require_197939__.r(__webpack_exports__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_197939__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_197939__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_197939__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_197939__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _limit__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_197939__(/*! ./limit */ "./src/limit.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_197939__(/*! ./cache */ "./src/cache.js");
/* harmony import */ var cache_control_esm__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_197939__(/*! cache-control-esm */ "./node_modules/cache-control-esm/index.js");



function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





function response(_x, _x2, _x3) {
  return _response.apply(this, arguments);
}

function _response() {
  _response = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config, req, res) {
    var _res$request, request, _res$headers, headers, cacheControl;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _res$request = res.request, request = _res$request === void 0 ? {} : _res$request, _res$headers = res.headers, headers = _res$headers === void 0 ? {} : _res$headers; // exclude binary response from cache

            if (!(['arraybuffer', 'blob'].indexOf(request.responseType) > -1)) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", res);

          case 3:
            cacheControl = {}; // Should we try to determine request cache expiration from headers or not

            if (config.readHeaders) {
              if (headers['cache-control']) {
                // Try parsing `cache-control` header from response
                cacheControl = Object(cache_control_esm__WEBPACK_IMPORTED_MODULE_4__["parse"])(headers['cache-control']); // Force cache exlcusion for `cache-control: no-cache` and `cache-control: no-store`

                if (cacheControl.noCache || cacheControl.noStore) {
                  config.excludeFromCache = true;
                }
              } else if (headers.expires) {
                // Else try reading `expires` header
                config.expires = new Date(headers.expires).getTime();
              } else {
                config.expires = new Date().getTime();
              }
            }

            if (config.excludeFromCache) {
              _context.next = 15;
              break;
            }

            if (cacheControl.maxAge || cacheControl.maxAge === 0) {
              // Use `cache-control` header `max-age` value and convert to milliseconds
              config.expires = Date.now() + cacheControl.maxAge * 1000;
            } else if (!config.readHeaders) {
              // Use fixed `maxAge` defined in the global or per-request config
              config.expires = config.maxAge === 0 ? Date.now() : Date.now() + config.maxAge;
            } // Check if a cache limit has been configured


            if (!config.limit) {
              _context.next = 11;
              break;
            }

            config.debug("Detected limit: ".concat(config.limit));
            _context.next = 11;
            return Object(_limit__WEBPACK_IMPORTED_MODULE_2__["default"])(config);

          case 11:
            _context.next = 13;
            return Object(_cache__WEBPACK_IMPORTED_MODULE_3__["write"])(config, req, res);

          case 13:
            _context.next = 16;
            break;

          case 15:
            // Mark request as excluded from cache
            res.request.excludedFromCache = true;

          case 16:
            return _context.abrupt("return", res);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _response.apply(this, arguments);
}

/* harmony default export */ __webpack_exports__["default"] = (response);

/***/ }),

/***/ "./src/serialize.js":
/*!**************************!*\
  !*** ./src/serialize.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_203392__) {

"use strict";
__nested_webpack_require_203392__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_203392__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_203392__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_203392__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_203392__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_203392__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_203392__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__);




function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function serialize(config, req, res) {
  if (res.data) {
    // FIXME: May be useless as localForage and axios already parse automatically
    try {
      res.data = JSON.parse(res.data);
    } catch (err) {
      config.debug('Could not parse data as JSON', err);
    }
  }

  var request = res.request,
      _ = res.config,
      serialized = _objectWithoutProperties(res, ["request", "config"]);

  return serialized;
}

/* harmony default export */ __webpack_exports__["default"] = (serialize);

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: isObject, getTag, isFunction, isString, mapObject */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_206236__) {

"use strict";
__nested_webpack_require_206236__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_206236__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __nested_webpack_require_206236__.d(__webpack_exports__, "getTag", function() { return getTag; });
/* harmony export (binding) */ __nested_webpack_require_206236__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/* harmony export (binding) */ __nested_webpack_require_206236__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __nested_webpack_require_206236__.d(__webpack_exports__, "mapObject", function() { return mapObject; });
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_206236__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_206236__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_206236__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_206236__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_206236__(/*! core-js/modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_206236__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_206236__(/*! core-js/modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_206236__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);





function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// https://github.com/lodash/lodash/blob/master/isObject.js
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type === 'object' || type === 'function');
} // https://github.com/lodash/lodash/blob/master/.internal/getTag.js

function getTag(value) {
  if (value === null) {
    return value === undefined ? '[object Undefined]' : '[object Null]';
  }

  return Object.prototype.toString.call(value);
} // https://github.com/lodash/lodash/blob/master/isFunction.js

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }

  var tag = getTag(value);
  return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object Proxy]';
} // https://github.com/lodash/lodash/blob/master/isString.js

function isString(value) {
  var type = _typeof(value);

  return type === 'string' || type === 'object' && value != null && !Array.isArray(value) && getTag(value) === '[object String]';
}
function mapObject(value, fn) {
  if (!isObject(value)) {
    return [];
  }

  return Object.keys(value).map(function (key) {
    return fn(value[key], key);
  });
}

/***/ }),

/***/ "axios":
/*!*************************************************************************************!*\
  !*** external {"umd":"axios","amd":"axios","commonjs":"axios","commonjs2":"axios"} ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_axios__;

/***/ })

/******/ });
});
//# sourceMappingURL=cache.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global window, global*/
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


/***/ }),

/***/ "./node_modules/deep-assign/index.js":
/*!*******************************************!*\
  !*** ./node_modules/deep-assign/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObj = __webpack_require__(/*! is-obj */ "./node_modules/is-obj/index.js");
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Sources cannot be null or undefined');
	}

	return Object(val);
}

function assignKey(to, from, key) {
	var val = from[key];

	if (val === undefined || val === null) {
		return;
	}

	if (hasOwnProperty.call(to, key)) {
		if (to[key] === undefined || to[key] === null) {
			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
		}
	}

	if (!hasOwnProperty.call(to, key) || !isObj(val)) {
		to[key] = val;
	} else {
		to[key] = assign(Object(to[key]), from[key]);
	}
}

function assign(to, from) {
	if (to === from) {
		return to;
	}

	from = Object(from);

	for (var key in from) {
		if (hasOwnProperty.call(from, key)) {
			assignKey(to, from, key);
		}
	}

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(from);

		for (var i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(from, symbols[i])) {
				assignKey(to, from, symbols[i]);
			}
		}
	}

	return to;
}

module.exports = function deepAssign(target) {
	target = toObject(target);

	for (var s = 1; s < arguments.length; s++) {
		assign(target, arguments[s]);
	}

	return target;
};


/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/foreach/index.js":
/*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
/***/ ((module) => {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};



/***/ }),

/***/ "./node_modules/form-data/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
/***/ ((module) => {

/* eslint-env browser */
module.exports = typeof self == 'object' ? self.FormData : window.FormData;


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/get-it/index.js":
/*!**************************************!*\
  !*** ./node_modules/get-it/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib-node */ "./node_modules/get-it/lib/index.js")


/***/ }),

/***/ "./node_modules/get-it/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/get-it/lib/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pubsub = __webpack_require__(/*! nano-pubsub */ "./node_modules/nano-pubsub/index.js");
var middlewareReducer = __webpack_require__(/*! ./util/middlewareReducer */ "./node_modules/get-it/lib/util/middlewareReducer.js");
var processOptions = __webpack_require__(/*! ./middleware/defaultOptionsProcessor */ "./node_modules/get-it/lib/middleware/defaultOptionsProcessor.js");
var validateOptions = __webpack_require__(/*! ./middleware/defaultOptionsValidator */ "./node_modules/get-it/lib/middleware/defaultOptionsValidator.js");
var httpRequest = __webpack_require__(/*! ./request */ "./node_modules/get-it/lib/request/index.js"); // node-request in node, browser-request in browsers

var channelNames = ['request', 'response', 'progress', 'error', 'abort'];
var middlehooks = ['processOptions', 'validateOptions', 'interceptRequest', 'finalizeOptions', 'onRequest', 'onResponse', 'onError', 'onReturn', 'onHeaders'];

module.exports = function createRequester() {
  var initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var loadedMiddleware = [];
  var middleware = middlehooks.reduce(function (ware, name) {
    ware[name] = ware[name] || [];
    return ware;
  }, {
    processOptions: [processOptions],
    validateOptions: [validateOptions]
  });

  function request(opts) {
    var channels = channelNames.reduce(function (target, name) {
      target[name] = pubsub();
      return target;
    }, {});

    // Prepare a middleware reducer that can be reused throughout the lifecycle
    var applyMiddleware = middlewareReducer(middleware);

    // Parse the passed options
    var options = applyMiddleware('processOptions', opts);

    // Validate the options
    applyMiddleware('validateOptions', options);

    // Build a context object we can pass to child handlers
    var context = { options: options, channels: channels, applyMiddleware: applyMiddleware

      // We need to hold a reference to the current, ongoing request,
      // in order to allow cancellation. In the case of the retry middleware,
      // a new request might be triggered
    };var ongoingRequest = null;
    var unsubscribe = channels.request.subscribe(function (ctx) {
      // Let request adapters (node/browser) perform the actual request
      ongoingRequest = httpRequest(ctx, function (err, res) {
        return onResponse(err, res, ctx);
      });
    });

    // If we abort the request, prevent further requests from happening,
    // and be sure to cancel any ongoing request (obviously)
    channels.abort.subscribe(function () {
      unsubscribe();
      if (ongoingRequest) {
        ongoingRequest.abort();
      }
    });

    // See if any middleware wants to modify the return value - for instance
    // the promise or observable middlewares
    var returnValue = applyMiddleware('onReturn', channels, context);

    // If return value has been modified by a middleware, we expect the middleware
    // to publish on the 'request' channel. If it hasn't been modified, we want to
    // trigger it right away
    if (returnValue === channels) {
      channels.request.publish(context);
    }

    return returnValue;

    function onResponse(reqErr, res, ctx) {
      var error = reqErr;
      var response = res;

      // We're processing non-errors first, in case a middleware converts the
      // response into an error (for instance, status >= 400 == HttpError)
      if (!error) {
        try {
          response = applyMiddleware('onResponse', res, ctx);
        } catch (err) {
          response = null;
          error = err;
        }
      }

      // Apply error middleware - if middleware return the same (or a different) error,
      // publish as an error event. If we *don't* return an error, assume it has been handled
      error = error && applyMiddleware('onError', error, ctx);

      // Figure out if we should publish on error/response channels
      if (error) {
        channels.error.publish(error);
      } else if (response) {
        channels.response.publish(response);
      }
    }
  }

  request.use = function use(newMiddleware) {
    if (!newMiddleware) {
      throw new Error('Tried to add middleware that resolved to falsey value');
    }

    if (typeof newMiddleware === 'function') {
      throw new Error('Tried to add middleware that was a function. It probably expects you to pass options to it.');
    }

    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {
      throw new Error('Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event');
    }

    middlehooks.forEach(function (key) {
      if (newMiddleware[key]) {
        middleware[key].push(newMiddleware[key]);
      }
    });

    loadedMiddleware.push(newMiddleware);
    return request;
  };

  request.clone = function clone() {
    return createRequester(loadedMiddleware);
  };

  initMiddleware.forEach(request.use);

  return request;
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/defaultOptionsProcessor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/defaultOptionsProcessor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var urlParse = __webpack_require__(/*! url-parse */ "./node_modules/url-parse/index.js");

var isReactNative = typeof navigator === 'undefined' ? false : navigator.product === 'ReactNative';

var has = Object.prototype.hasOwnProperty;
var defaultOptions = { timeout: isReactNative ? 60000 : 120000 };

module.exports = function (opts) {
  var options = typeof opts === 'string' ? objectAssign({ url: opts }, defaultOptions) : objectAssign({}, defaultOptions, opts);

  // Parse URL into parts
  var url = urlParse(options.url, {}, // Don't use current browser location
  true // Parse query strings
  );

  // Normalize timeouts
  options.timeout = normalizeTimeout(options.timeout);

  // Shallow-merge (override) existing query params
  if (options.query) {
    url.query = objectAssign({}, url.query, removeUndefined(options.query));
  }

  // Implicit POST if we have not specified a method but have a body
  options.method = options.body && !options.method ? 'POST' : (options.method || 'GET').toUpperCase();

  // Stringify URL
  options.url = url.toString(stringifyQueryString);

  return options;
};

function stringifyQueryString(obj) {
  var pairs = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      push(key, obj[key]);
    }
  }

  return pairs.length ? pairs.join('&') : '';

  function push(key, val) {
    if (Array.isArray(val)) {
      val.forEach(function (item) {
        return push(key, item);
      });
    } else {
      pairs.push([key, val].map(encodeURIComponent).join('='));
    }
  }
}

function normalizeTimeout(time) {
  if (time === false || time === 0) {
    return false;
  }

  if (time.connect || time.socket) {
    return time;
  }

  var delay = Number(time);
  if (isNaN(delay)) {
    return normalizeTimeout(defaultOptions.timeout);
  }

  return { connect: delay, socket: delay };
}

function removeUndefined(obj) {
  var target = {};
  for (var key in obj) {
    if (obj[key] !== undefined) {
      target[key] = obj[key];
    }
  }
  return target;
}
//# sourceMappingURL=defaultOptionsProcessor.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/defaultOptionsValidator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/defaultOptionsValidator.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";


var validUrl = /^https?:\/\//i;

module.exports = function (options) {
  if (!validUrl.test(options.url)) {
    throw new Error("\"" + options.url + "\" is not a valid URL");
  }
};
//# sourceMappingURL=defaultOptionsValidator.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/jsonRequest.js":
/*!***********************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/jsonRequest.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var isPlainObject = __webpack_require__(/*! is-plain-object */ "./node_modules/is-plain-object/index.js");

var serializeTypes = ['boolean', 'string', 'number'];
var isBuffer = function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
};

module.exports = function () {
  return {
    processOptions: function processOptions(options) {
      var body = options.body;
      if (!body) {
        return options;
      }

      var isStream = typeof body.pipe === 'function';
      var shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body === 'undefined' ? 'undefined' : _typeof(body)) !== -1 || Array.isArray(body) || isPlainObject(body));

      if (!shouldSerialize) {
        return options;
      }

      return objectAssign({}, options, {
        body: JSON.stringify(options.body),
        headers: objectAssign({}, options.headers, {
          'Content-Type': 'application/json'
        })
      });
    }
  };
};
//# sourceMappingURL=jsonRequest.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/jsonResponse.js":
/*!************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/jsonResponse.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

module.exports = function (opts) {
  return {
    onResponse: function onResponse(response) {
      var contentType = response.headers['content-type'] || '';
      var shouldDecode = opts && opts.force || contentType.indexOf('application/json') !== -1;
      if (!response.body || !contentType || !shouldDecode) {
        return response;
      }

      return objectAssign({}, response, { body: tryParse(response.body) });
    },

    processOptions: function processOptions(options) {
      return objectAssign({}, options, {
        headers: objectAssign({ Accept: 'application/json' }, options.headers)
      });
    }
  };
};

function tryParse(body) {
  try {
    return JSON.parse(body);
  } catch (err) {
    err.message = 'Failed to parsed response body as JSON: ' + err.message;
    throw err;
  }
}
//# sourceMappingURL=jsonResponse.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/observable.js":
/*!**********************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/observable.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(/*! ../util/global */ "./node_modules/get-it/lib/util/global.js");
var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

module.exports = function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var Observable = opts.implementation || global.Observable;
  if (!Observable) {
    throw new Error('`Observable` is not available in global scope, and no implementation was passed');
  }

  return {
    onReturn: function onReturn(channels, context) {
      return new Observable(function (observer) {
        channels.error.subscribe(function (err) {
          return observer.error(err);
        });
        channels.progress.subscribe(function (event) {
          return observer.next(objectAssign({ type: 'progress' }, event));
        });
        channels.response.subscribe(function (response) {
          observer.next(objectAssign({ type: 'response' }, response));
          observer.complete();
        });

        channels.request.publish(context);
        return function () {
          return channels.abort.publish();
        };
      });
    }
  };
};
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/progress/browser-progress.js":
/*!*************************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/progress/browser-progress.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  return {
    onRequest: function onRequest(evt) {
      if (evt.adapter !== 'xhr') {
        return;
      }

      var xhr = evt.request;
      var context = evt.context;

      if ('upload' in xhr && 'onprogress' in xhr.upload) {
        xhr.upload.onprogress = handleProgress('upload');
      }

      if ('onprogress' in xhr) {
        xhr.onprogress = handleProgress('download');
      }

      function handleProgress(stage) {
        return function (event) {
          var percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;
          context.channels.progress.publish({
            stage: stage,
            percent: percent,
            total: event.total,
            loaded: event.loaded,
            lengthComputable: event.lengthComputable
          });
        };
      }
    }
  };
};
//# sourceMappingURL=browser-progress.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/middleware/progress/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/get-it/lib/middleware/progress/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./node-progress */ "./node_modules/get-it/lib/middleware/progress/browser-progress.js");
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/request/browser-request.js":
/*!************************************************************!*\
  !*** ./node_modules/get-it/lib/request/browser-request.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint max-depth: ["error", 4] */
var sameOrigin = __webpack_require__(/*! same-origin */ "./node_modules/same-origin/index.js");
var parseHeaders = __webpack_require__(/*! parse-headers */ "./node_modules/parse-headers/parse-headers.js");
var noop = function noop() {
  /* intentional noop */
};

var win = window;
var XmlHttpRequest = win.XMLHttpRequest || noop;
var hasXhr2 = 'withCredentials' in new XmlHttpRequest();
var XDomainRequest = hasXhr2 ? XmlHttpRequest : win.XDomainRequest;
var adapter = 'xhr';

module.exports = function (context, callback) {
  var opts = context.options;
  var options = context.applyMiddleware('finalizeOptions', opts);
  var timers = {};

  // Deep-checking window.location because of react native, where `location` doesn't exist
  var cors = win && win.location && !sameOrigin(win.location.href, options.url);

  // Allow middleware to inject a response, for instance in the case of caching or mocking
  var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {
    adapter: adapter,
    context: context
  });

  // If middleware injected a response, treat it as we normally would and return it
  // Do note that the injected response has to be reduced to a cross-environment friendly response
  if (injectedResponse) {
    var cbTimer = setTimeout(callback, 0, null, injectedResponse);
    var cancel = function cancel() {
      return clearTimeout(cbTimer);
    };
    return { abort: cancel };
  }

  // We'll want to null out the request on success/failure
  var xhr = cors ? new XDomainRequest() : new XmlHttpRequest();

  var isXdr = win.XDomainRequest && xhr instanceof win.XDomainRequest;
  var headers = options.headers;

  // Request state
  var aborted = false;
  var loaded = false;
  var timedOut = false;

  // Apply event handlers
  xhr.onerror = onError;
  xhr.ontimeout = onError;
  xhr.onabort = function () {
    aborted = true;
  };

  // IE9 must have onprogress be set to a unique function
  xhr.onprogress = function () {
    /* intentional noop */
  };

  var loadEvent = isXdr ? 'onload' : 'onreadystatechange';
  xhr[loadEvent] = function () {
    // Prevent request from timing out
    resetTimers();

    if (aborted || xhr.readyState !== 4 && !isXdr) {
      return;
    }

    // Will be handled by onError
    if (xhr.status === 0) {
      return;
    }

    onLoad();
  };

  // @todo two last options to open() is username/password
  xhr.open(options.method, options.url, true // Always async
  );

  // Some options need to be applied after open
  xhr.withCredentials = !!options.withCredentials;

  // Set headers
  if (headers && xhr.setRequestHeader) {
    for (var key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  } else if (headers && isXdr) {
    throw new Error('Headers cannot be set on an XDomainRequest object');
  }

  if (options.rawBody) {
    xhr.responseType = 'arraybuffer';
  }

  // Let middleware know we're about to do a request
  context.applyMiddleware('onRequest', { options: options, adapter: adapter, request: xhr, context: context });

  xhr.send(options.body || null);

  // Figure out which timeouts to use (if any)
  var delays = options.timeout;
  if (delays) {
    timers.connect = setTimeout(function () {
      return timeoutRequest('ETIMEDOUT');
    }, delays.connect);
  }

  return { abort: abort };

  function abort() {
    aborted = true;

    if (xhr) {
      xhr.abort();
    }
  }

  function timeoutRequest(code) {
    timedOut = true;
    xhr.abort();
    var error = new Error(code === 'ESOCKETTIMEDOUT' ? 'Socket timed out on request to ' + options.url : 'Connection timed out on request to ' + options.url);
    error.code = code;
    context.channels.error.publish(error);
  }

  function resetTimers() {
    if (!delays) {
      return;
    }

    stopTimers();
    timers.socket = setTimeout(function () {
      return timeoutRequest('ESOCKETTIMEDOUT');
    }, delays.socket);
  }

  function stopTimers() {
    // Only clear the connect timeout if we've got a connection
    if (aborted || xhr.readyState >= 2 && timers.connect) {
      clearTimeout(timers.connect);
    }

    if (timers.socket) {
      clearTimeout(timers.socket);
    }
  }

  function onError() {
    if (loaded) {
      return;
    }

    // Clean up
    stopTimers();
    loaded = true;
    xhr = null;

    // Annoyingly, details are extremely scarce and hidden from us.
    // We only really know that it is a network error
    var err = new Error('Network error while attempting to reach ' + options.url);
    err.isNetworkError = true;
    err.request = options;
    callback(err);
  }

  function reduceResponse() {
    var statusCode = xhr.status;
    var statusMessage = xhr.statusText;

    if (isXdr && statusCode === undefined) {
      // IE8 CORS GET successful response doesn't have a status field, but body is fine
      statusCode = 200;
    } else if (statusCode > 12000 && statusCode < 12156) {
      // Yet another IE quirk where it emits weird status codes on network errors
      // https://support.microsoft.com/en-us/kb/193625
      return onError();
    } else {
      // Another IE bug where HTTP 204 somehow ends up as 1223
      statusCode = xhr.status === 1223 ? 204 : xhr.status;
      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;
    }

    return {
      body: xhr.response || xhr.responseText,
      url: options.url,
      method: options.method,
      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),
      statusCode: statusCode,
      statusMessage: statusMessage
    };
  }

  function onLoad() {
    if (aborted || loaded || timedOut) {
      return;
    }

    if (xhr.status === 0) {
      onError(new Error('Unknown XHR error'));
      return;
    }

    // Prevent being called twice
    stopTimers();
    loaded = true;
    callback(null, reduceResponse());
  }
};
//# sourceMappingURL=browser-request.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/request/index.js":
/*!**************************************************!*\
  !*** ./node_modules/get-it/lib/request/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ./node-request */ "./node_modules/get-it/lib/request/browser-request.js");
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/util/global.js":
/*!************************************************!*\
  !*** ./node_modules/get-it/lib/util/global.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable no-negated-condition */
if (typeof window !== 'undefined') {
  module.exports = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  module.exports = __webpack_require__.g;
} else if (typeof self !== 'undefined') {
  module.exports = self;
} else {
  module.exports = {};
}
//# sourceMappingURL=global.js.map

/***/ }),

/***/ "./node_modules/get-it/lib/util/middlewareReducer.js":
/*!***********************************************************!*\
  !*** ./node_modules/get-it/lib/util/middlewareReducer.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (middleware) {
  var applyMiddleware = function applyMiddleware(hook, defaultValue) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var bailEarly = hook === 'onError';

    var value = defaultValue;
    for (var i = 0; i < middleware[hook].length; i++) {
      var handler = middleware[hook][i];
      value = handler.apply(undefined, [value].concat(args));

      if (bailEarly && !value) {
        break;
      }
    }

    return value;
  };

  return applyMiddleware;
};
//# sourceMappingURL=middlewareReducer.js.map

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var generatorFunc = getGeneratorFunc();
var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	return getProto && getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/is-obj/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-obj/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";

module.exports = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};


/***/ }),

/***/ "./node_modules/is-plain-object/index.js":
/*!***********************************************!*\
  !*** ./node_modules/is-plain-object/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



var isObject = __webpack_require__(/*! isobject */ "./node_modules/isobject/index.js");

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};


/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! foreach */ "./node_modules/foreach/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js");
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new __webpack_require__.g[typedArray]();
		if (!(Symbol.toStringTag in arr)) {
			throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
		}
		var proto = getPrototypeOf(arr);
		var descriptor = gOPD(proto, Symbol.toStringTag);
		if (!descriptor) {
			var superProto = getPrototypeOf(proto);
			descriptor = gOPD(superProto, Symbol.toStringTag);
		}
		toStrTags[typedArray] = descriptor.get;
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./node_modules/isobject/index.js":
/*!****************************************!*\
  !*** ./node_modules/isobject/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};


/***/ }),

/***/ "./node_modules/make-error/index.js":
/*!******************************************!*\
  !*** ./node_modules/make-error/index.js ***!
  \******************************************/
/***/ ((module, exports) => {

"use strict";
// ISC @ Julien Fontanet



// ===================================================================

var construct = typeof Reflect !== "undefined" ? Reflect.construct : undefined;
var defineProperty = Object.defineProperty;

// -------------------------------------------------------------------

var captureStackTrace = Error.captureStackTrace;
if (captureStackTrace === undefined) {
  captureStackTrace = function captureStackTrace(error) {
    var container = new Error();

    defineProperty(error, "stack", {
      configurable: true,
      get: function getStack() {
        var stack = container.stack;

        // Replace property with value for faster future accesses.
        defineProperty(this, "stack", {
          configurable: true,
          value: stack,
          writable: true,
        });

        return stack;
      },
      set: function setStack(stack) {
        defineProperty(error, "stack", {
          configurable: true,
          value: stack,
          writable: true,
        });
      },
    });
  };
}

// -------------------------------------------------------------------

function BaseError(message) {
  if (message !== undefined) {
    defineProperty(this, "message", {
      configurable: true,
      value: message,
      writable: true,
    });
  }

  var cname = this.constructor.name;
  if (cname !== undefined && cname !== this.name) {
    defineProperty(this, "name", {
      configurable: true,
      value: cname,
      writable: true,
    });
  }

  captureStackTrace(this, this.constructor);
}

BaseError.prototype = Object.create(Error.prototype, {
  // See: https://github.com/JsCommunity/make-error/issues/4
  constructor: {
    configurable: true,
    value: BaseError,
    writable: true,
  },
});

// -------------------------------------------------------------------

// Sets the name of a function if possible (depends of the JS engine).
var setFunctionName = (function() {
  function setFunctionName(fn, name) {
    return defineProperty(fn, "name", {
      configurable: true,
      value: name,
    });
  }
  try {
    var f = function() {};
    setFunctionName(f, "foo");
    if (f.name === "foo") {
      return setFunctionName;
    }
  } catch (_) {}
})();

// -------------------------------------------------------------------

function makeError(constructor, super_) {
  if (super_ == null || super_ === Error) {
    super_ = BaseError;
  } else if (typeof super_ !== "function") {
    throw new TypeError("super_ should be a function");
  }

  var name;
  if (typeof constructor === "string") {
    name = constructor;
    constructor =
      construct !== undefined
        ? function() {
            return construct(super_, arguments, this.constructor);
          }
        : function() {
            super_.apply(this, arguments);
          };

    // If the name can be set, do it once and for all.
    if (setFunctionName !== undefined) {
      setFunctionName(constructor, name);
      name = undefined;
    }
  } else if (typeof constructor !== "function") {
    throw new TypeError("constructor should be either a string or a function");
  }

  // Also register the super constructor also as `constructor.super_` just
  // like Node's `util.inherits()`.
  //
  // eslint-disable-next-line dot-notation
  constructor.super_ = constructor["super"] = super_;

  var properties = {
    constructor: {
      configurable: true,
      value: constructor,
      writable: true,
    },
  };

  // If the name could not be set on the constructor, set it on the
  // prototype.
  if (name !== undefined) {
    properties.name = {
      configurable: true,
      value: name,
      writable: true,
    };
  }
  constructor.prototype = Object.create(super_.prototype, properties);

  return constructor;
}
exports = module.exports = makeError;
exports.BaseError = BaseError;


/***/ }),

/***/ "./node_modules/nano-pubsub/index.js":
/*!*******************************************!*\
  !*** ./node_modules/nano-pubsub/index.js ***!
  \*******************************************/
/***/ ((module) => {

module.exports = function Pubsub() {
  var subscribers = []
  return {
    subscribe: subscribe,
    publish: publish
  }
  function subscribe(subscriber) {
    subscribers.push(subscriber)
    return function unsubscribe() {
      var idx = subscribers.indexOf(subscriber)
      if (idx > -1) {
        subscribers.splice(idx, 1)
      }
    }
  }
  function publish() {
    for (var i = 0; i < subscribers.length; i++) {
      subscribers[i].apply(null, arguments)
    }
  }
}

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/***/ ((module) => {

var trim = function(string) {
  return string.replace(/^\s+|\s+$/g, '');
}
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  var headersArr = trim(headers).split('\n')

  for (var i = 0; i < headersArr.length; i++) {
    var row = headersArr[i]
    var index = row.indexOf(':')
    , key = trim(row.slice(0, index)).toLowerCase()
    , value = trim(row.slice(index + 1))

    if (typeof(result[key]) === 'undefined') {
      result[key] = value
    } else if (isArray(result[key])) {
      result[key].push(value)
    } else {
      result[key] = [ result[key], value ]
    }
  }

  return result
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./node_modules/rxjs/internal/Observable.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/internal/Observable.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");

Object.defineProperty(exports, "__esModule", ({ value: true }));
var canReportError_1 = __webpack_require__(/*! ./util/canReportError */ "./node_modules/rxjs/internal/util/canReportError.js");
var toSubscriber_1 = __webpack_require__(/*! ./util/toSubscriber */ "./node_modules/rxjs/internal/util/toSubscriber.js");
var observable_1 = __webpack_require__(/*! ./symbol/observable */ "./node_modules/rxjs/internal/symbol/observable.js");
var pipe_1 = __webpack_require__(/*! ./util/pipe */ "./node_modules/rxjs/internal/util/pipe.js");
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Observer.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/internal/Observer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var hostReportError_1 = __webpack_require__(/*! ./util/hostReportError */ "./node_modules/rxjs/internal/util/hostReportError.js");
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Subscriber.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/internal/Subscriber.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
var Observer_1 = __webpack_require__(/*! ./Observer */ "./node_modules/rxjs/internal/Observer.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/internal/Subscription.js");
var rxSubscriber_1 = __webpack_require__(/*! ../internal/symbol/rxSubscriber */ "./node_modules/rxjs/internal/symbol/rxSubscriber.js");
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/rxjs/internal/config.js");
var hostReportError_1 = __webpack_require__(/*! ./util/hostReportError */ "./node_modules/rxjs/internal/util/hostReportError.js");
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/Subscription.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/internal/Subscription.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var isArray_1 = __webpack_require__(/*! ./util/isArray */ "./node_modules/rxjs/internal/util/isArray.js");
var isObject_1 = __webpack_require__(/*! ./util/isObject */ "./node_modules/rxjs/internal/util/isObject.js");
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/internal/util/isFunction.js");
var UnsubscriptionError_1 = __webpack_require__(/*! ./util/UnsubscriptionError */ "./node_modules/rxjs/internal/util/UnsubscriptionError.js");
var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/config.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/internal/config.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/observable/empty.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/observable/empty.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/internal/Observable.js");
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/defaultIfEmpty.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/filter.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/map.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/map.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/reduce.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var scan_1 = __webpack_require__(/*! ./scan */ "./node_modules/rxjs/internal/operators/scan.js");
var takeLast_1 = __webpack_require__(/*! ./takeLast */ "./node_modules/rxjs/internal/operators/takeLast.js");
var defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ "./node_modules/rxjs/internal/operators/defaultIfEmpty.js");
var pipe_1 = __webpack_require__(/*! ../util/pipe */ "./node_modules/rxjs/internal/util/pipe.js");
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;
//# sourceMappingURL=reduce.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/scan.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/scan.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=scan.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/operators/takeLast.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/internal/operators/takeLast.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js");
var empty_1 = __webpack_require__(/*! ../observable/empty */ "./node_modules/rxjs/internal/observable/empty.js");
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeLast.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/symbol/observable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/symbol/observable.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/symbol/rxSubscriber.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/symbol/rxSubscriber.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/ArgumentOutOfRangeError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/UnsubscriptionError.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/UnsubscriptionError.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/canReportError.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/canReportError.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;
//# sourceMappingURL=canReportError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/hostReportError.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/internal/util/hostReportError.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;
//# sourceMappingURL=hostReportError.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/identity.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/identity.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function identity(x) {
    return x;
}
exports.identity = identity;
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isArray.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isArray.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
//# sourceMappingURL=isArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isFunction.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isFunction.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/isObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/internal/util/isObject.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/pipe.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/internal/util/pipe.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var identity_1 = __webpack_require__(/*! ./identity */ "./node_modules/rxjs/internal/util/identity.js");
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity_1.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;
//# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "./node_modules/rxjs/internal/util/toSubscriber.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/internal/util/toSubscriber.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/internal/Subscriber.js");
var rxSubscriber_1 = __webpack_require__(/*! ../symbol/rxSubscriber */ "./node_modules/rxjs/internal/symbol/rxSubscriber.js");
var Observer_1 = __webpack_require__(/*! ../Observer */ "./node_modules/rxjs/internal/Observer.js");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),

/***/ "./node_modules/same-origin/index.js":
/*!*******************************************!*\
  !*** ./node_modules/same-origin/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var url = __webpack_require__(/*! url */ "./node_modules/same-origin/url-parser.js");

module.exports = function(uri1, uri2, ieMode) {
    if (uri1 === uri2) {
        return true;
    }

    var url1 = url.parse(uri1, false, true);
    var url2 = url.parse(uri2, false, true);

    var url1Port = url1.port|0 || (url1.protocol === 'https' ? 443 : 80);
    var url2Port = url2.port|0 || (url2.protocol === 'https' ? 443 : 80);

    var match = {
        proto: url1.protocol === url2.protocol,
        hostname: url1.hostname === url2.hostname,
        port: url1Port === url2Port
    };

    return ((match.proto && match.hostname) && (match.port || ieMode));
};

/***/ }),

/***/ "./node_modules/same-origin/url-parser.js":
/*!************************************************!*\
  !*** ./node_modules/same-origin/url-parser.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
/**
 * This file is only used for the browser version of `same-origin`.
 * Used to bring down the size of the browser bundle.
 */


var regex = /^(?:(?:(?:([^:\/#\?]+:)?(?:(?:\/\/)((?:((?:[^:@\/#\?]+)(?:\:(?:[^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((?:\/?(?:[^\/\?#]+\/+)*)(?:[^\?#]*)))?(\?[^#]+)?)(#.*)?/;

module.exports = {
    regex: regex,
    parse: function(url) {
        var match = regex.exec(url);
        if (!match) {
            return {};
        }

        return {
            protocol: (match[1] || '').toLowerCase() || undefined,
            hostname: (match[5] || '').toLowerCase() || undefined,
            port: match[6] || undefined
        };
    }
};

/***/ }),

/***/ "./src/biketag/deleteTag.ts":
/*!**********************************!*\
  !*** ./src/biketag/deleteTag.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* binding */ deleteTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function deleteTag(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}`;
        return (yield client.request({ url, method: 'DELETE' }))
            .data;
    });
}


/***/ }),

/***/ "./src/biketag/favoriteImage.ts":
/*!**************************************!*\
  !*** ./src/biketag/favoriteImage.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "favoriteImage": () => (/* binding */ favoriteImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function favoriteImage(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}/favorite`;
        return (yield client.request({ url, method: 'POST' }))
            .data;
    });
}


/***/ }),

/***/ "./src/biketag/getTag.ts":
/*!*******************************!*\
  !*** ./src/biketag/getTag.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTag": () => (/* binding */ getTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function getTag(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}`;
        return (yield client.request({ url }))
            .data;
    });
}


/***/ }),

/***/ "./src/biketag/index.ts":
/*!******************************!*\
  !*** ./src/biketag/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* reexport safe */ _deleteTag__WEBPACK_IMPORTED_MODULE_0__.deleteTag),
/* harmony export */   "getTag": () => (/* reexport safe */ _getTag__WEBPACK_IMPORTED_MODULE_1__.getTag),
/* harmony export */   "updateTag": () => (/* reexport safe */ _updateTag__WEBPACK_IMPORTED_MODULE_2__.updateTag),
/* harmony export */   "updateTagImage": () => (/* reexport safe */ _updateTagImage__WEBPACK_IMPORTED_MODULE_3__.updateTagImage),
/* harmony export */   "queueTagImage": () => (/* reexport safe */ _queueTagImage__WEBPACK_IMPORTED_MODULE_4__.queueTagImage),
/* harmony export */   "favoriteImage": () => (/* reexport safe */ _favoriteImage__WEBPACK_IMPORTED_MODULE_5__.favoriteImage)
/* harmony export */ });
/* harmony import */ var _deleteTag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deleteTag */ "./src/biketag/deleteTag.ts");
/* harmony import */ var _getTag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTag */ "./src/biketag/getTag.ts");
/* harmony import */ var _updateTag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateTag */ "./src/biketag/updateTag.ts");
/* harmony import */ var _updateTagImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./updateTagImage */ "./src/biketag/updateTagImage.ts");
/* harmony import */ var _queueTagImage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./queueTagImage */ "./src/biketag/queueTagImage.ts");
/* harmony import */ var _favoriteImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./favoriteImage */ "./src/biketag/favoriteImage.ts");








/***/ }),

/***/ "./src/biketag/queueTagImage.ts":
/*!**************************************!*\
  !*** ./src/biketag/queueTagImage.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "queueTagImage": () => (/* binding */ queueTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

// import { UPLOAD_ENDPOINT } from '../common/endpoints';
function queueTagImage(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        if (Array.isArray(payload)) {
            const promises = payload.map((p) => {
                // const form = createForm(p);
                // const req = client.request(UPLOAD_ENDPOINT, {
                //   method: 'POST',
                //   body: form,
                //   resolveBodyOnly: true,
                // });
                // const id = ;
                // req.on('uploadProgress', (progress: Progress) => {
                //   client.emit('uploadProgress', { ...progress, id });
                // });
                return p;
            });
            return yield Promise.all(promises);
        }
        // const form = createForm(payload);
        // const req = client.request(UPLOAD_ENDPOINT, {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // });
        // req.on('uploadProgress', (progress: Progress) => {
        //   client.emit('uploadProgress', { ...progress, id });
        // });
        return client;
    });
}


/***/ }),

/***/ "./src/biketag/updateTag.ts":
/*!**********************************!*\
  !*** ./src/biketag/updateTag.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTag": () => (/* binding */ updateTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function isValidUpdatePayload(p) {
    return typeof p.title === 'string' || typeof p.description === 'string';
}
function updateTag(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        // if (Array.isArray(payload)) {
        //   const promises = payload.map((p: UpdateTagPayload) => {
        //     if (!isValidUpdatePayload(p)) {
        //       throw new Error('Update requires a title and/or description');
        //     }
        //     const url = `${IMAGE_ENDPOINT}/${p.imageHash}`;
        //     const form = createForm(p);
        //     return (client.request(url, {
        //       method: 'POST',
        //       body: form,
        //       resolveBodyOnly: true,
        //     }) as unknown) as Promise<BikeTagApiResponse<boolean>>;
        //   });
        //   return await Promise.all(promises);
        // }
        if (!isValidUpdatePayload(payload)) {
            throw new Error('Update requires a title and/or description');
        }
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${payload.slug}`;
        return (yield client.request({ url, method: 'DELETE' }))
            .data;
    });
}


/***/ }),

/***/ "./src/biketag/updateTagImage.ts":
/*!***************************************!*\
  !*** ./src/biketag/updateTagImage.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTagImage": () => (/* binding */ updateTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


// function isValidUpdatePayload(p: UpdateTagImagePayload) {
//   return typeof p.title === 'string' || typeof p.description === 'string';
// }
function updateTagImage(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        // if (Array.isArray(payload)) {
        //   const promises = payload.map((p: UpdateTagImagePayload) => {
        //     if (!isValidUpdatePayload(p)) {
        //       throw new Error('Update requires a title and/or description');
        //     }
        //     const url = `${IMAGE_ENDPOINT}/${p.imageHash}`;
        //     const form = createForm(p);
        //     return (client.request(url, {
        //       method: 'POST',
        //       body: form,
        //       resolveBodyOnly: true,
        //     }) as unknown) as Promise<BikeTagApiResponse<boolean>>;
        //   });
        //   return await Promise.all(promises);
        // }
        // if (!isValidUpdatePayload(payload)) {
        //   throw new Error('Update requires a title and/or description');
        // }
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${payload.slug}`;
        return (yield client.request({ url, method: 'DELETE' }))
            .data;
        // // const form = createForm(payload);
        // return ((await client.request(url, {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // })) as unknown) as BikeTagApiResponse<boolean>;
    });
}


/***/ }),

/***/ "./src/client.ts":
/*!***********************!*\
  !*** ./src/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BikeTagClient": () => (/* binding */ BikeTagClient)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/endpoints */ "./src/common/endpoints.ts");
/* harmony import */ var _common_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/data */ "./src/common/data.ts");
/* harmony import */ var _common_methods__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common/methods */ "./src/common/methods.ts");
/* harmony import */ var axios_cache_adapter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios-cache-adapter */ "./node_modules/axios-cache-adapter/dist/cache.js");
/* harmony import */ var axios_cache_adapter__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(axios_cache_adapter__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _sanity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sanity */ "./src/sanity/index.ts");
/* harmony import */ var _imgur__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./imgur */ "./src/imgur/index.ts");
/* harmony import */ var _biketag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./biketag */ "./src/biketag/index.ts");
/* harmony import */ var _imgurClient__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./imgurClient */ "./src/imgurClient/index.js");
/* harmony import */ var _imgurClient__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_imgurClient__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sanity/client */ "./node_modules/@sanity/client/lib/sanityClient.js");
/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_sanity_client__WEBPACK_IMPORTED_MODULE_10__);


// import { getAuthorizationHeader } from './getAuthorizationHeader'







// @ts-ignore


const USERAGENT = 'biketag-api (https://github.com/keneucker/biketag-api)';
class BikeTagClient extends events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
    constructor(credentials) {
        super();
        this.credentials = credentials;
        this.mostAvailableApi = '';
        this.biketagConfig = (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.assignBikeTagCredentials)(credentials);
        this.imgurConfig = (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.assignImgurCredentials)(credentials);
        this.sanityConfig = (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.assignSanityCredentials)(credentials);
        if (this.imgurConfig) {
            this.imgurClient = new _imgurClient__WEBPACK_IMPORTED_MODULE_9__.ImgurClient(this.imgurConfig);
        }
        if (this.sanityConfig) {
            this.sanityClient = _sanity_client__WEBPACK_IMPORTED_MODULE_10___default()(this.sanityConfig);
        }
        /// Configure separate fetching strategies: plain, authed (default), cached (authed)
        this.plainFetcher = axios__WEBPACK_IMPORTED_MODULE_0___default().create({
            headers: {
                'user-agent': USERAGENT,
            },
            responseType: 'json',
        });
        this.fetcher = axios__WEBPACK_IMPORTED_MODULE_0___default().create({
            baseURL: _common_endpoints__WEBPACK_IMPORTED_MODULE_2__.BIKETAG_API_PREFIX,
            headers: {
                'user-agent': USERAGENT,
            },
            responseType: 'json',
        });
        this.cachedFetcher = (0,axios_cache_adapter__WEBPACK_IMPORTED_MODULE_5__.setup)({
            baseURL: _common_endpoints__WEBPACK_IMPORTED_MODULE_2__.BIKETAG_API_PREFIX,
            cache: {
                maxAge: 15 * 60 * 1000,
                exclude: {
                    // Only exclude PUT, PATCH and DELETE methods from cache
                    methods: ['put', 'patch', 'delete'],
                },
            },
            headers: {
                'user-agent': USERAGENT,
            },
            responseType: 'json',
        });
    }
    getDefaultAPI(options) {
        const availableAPI = options.forceAPI
            ? options.forceAPI
            : this.getMostAvailableAPI();
        let client = null;
        let api = null;
        options = typeof options === 'string' ? { slug: options } : options;
        options =
            typeof options === 'number'
                ? {
                    slug: (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.constructTagNumberSlug)(options, this.credentials.game),
                }
                : options;
        options.game = options.game ? options.game : this.credentials.game;
        options.slug = options.slug
            ? options.slug
            : (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.constructTagNumberSlug)(options.tagnumber, options.game);
        options.fields = options.fields ? options.fields : _common_data__WEBPACK_IMPORTED_MODULE_3__.tagDataFields;
        switch (availableAPI) {
            case 'sanity':
                client = this.sanityClient;
                api = _sanity__WEBPACK_IMPORTED_MODULE_6__;
                break;
            case 'imgur':
                client = this.imgurClient;
                api = _imgur__WEBPACK_IMPORTED_MODULE_7__;
                break;
            default:
            case 'biketag':
                client = api = _biketag__WEBPACK_IMPORTED_MODULE_8__;
                break;
        }
        return {
            client,
            api,
            options,
        };
    }
    getMostAvailableAPI() {
        if (this.mostAvailableApi.length) {
            return this.mostAvailableApi;
        }
        if (this.biketagConfig && (0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isBikeTagCredentials)(this.biketagConfig)) {
            return (this.mostAvailableApi = 'biketag');
        }
        else if (this.imgurConfig) {
            return (this.mostAvailableApi = 'imgur');
        }
        else if (this.sanityConfig) {
            return (this.mostAvailableApi = 'sanity');
        }
        return '';
    }
    getConfiguration() {
        return {
            sanity: this.sanityConfig,
            imgur: this.imgurConfig,
            biketag: this.biketagConfig,
        };
    }
    plainRequest(options = {}) {
        return this.plainFetcher(options);
    }
    cachedRequest(options = {}) {
        return this.cachedFetcher(options);
    }
    request(options = {}) {
        return this.fetcher(options);
    }
    // deleteImage(imageHash: string): Promise<BikeTagApiResponse<boolean>> {
    //   switch (this.getMostAvailableAPI()) {
    //     case "imgur":
    //       return imgur.deleteImage(this, imageHash)
    //     break
    //   }
    // }
    // /// TODO: this should be for getting an album
    // getArchive(options: ArchiveOptions): Promise<BikeTagApiResponse<ArchiveData>> {
    //   return getArchive(this, options)
    // }
    getTag(opts) {
        const { client, options, api } = this.getDefaultAPI(opts);
        return api.getTag(client, options);
    }
    // updateImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return updateImage(this, payload)
    // }
    // upload(
    //   payload: string | string[] | Payload | Payload[]
    // ): Promise<BikeTagApiResponse<TagData> | BikeTagApiResponse<TagData>[]> {
    //   return upload(this, payload)
    // }
    // getBikeTag(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   switch (this.getMostAvailableAPI()) {
    //     case "imgur":
    //       return getBikeTag(this, payload)
    //       break
    //     case "sanity":
    //       return
    //   }
    // }
    // getBikeTagMysteryImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getBikeTagMysteryImage(this, payload)
    // }
    // getBikeTagFoundImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getBikeTagFoundImage(this, payload)
    // }
    // queueBikeTagFoundImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return queueBikeTagFoundImage(this, payload)
    // }
    // queueBikeTagMysteryImage(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return queueBikeTagMysteryImage(this, payload)
    // }
    // getQueuedImages(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getQueuedImages(this, payload)
    // }
    // getQueue(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getQueue(this, payload)
    // }
    // completeBikeTagRound(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return completeBikeTagRound(this, payload)
    // }
    // getBikeTagRound(
    //   payload: UpdateImagePayload | UpdateImagePayload[]
    // ): Promise<BikeTagApiResponse<boolean> | BikeTagApiResponse<boolean>[]> {
    //   return getBikeTagRound(this, payload)
    // }
    content(options = {}) {
        if ((0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isSanityCredentials)(options)) {
            return _sanity_client__WEBPACK_IMPORTED_MODULE_10___default()(options);
        }
        throw new Error('options are invalid for creating a sanity client');
    }
    images(options = {}) {
        if ((0,_common_methods__WEBPACK_IMPORTED_MODULE_4__.isImgurCredentials)(options)) {
            return new _imgurClient__WEBPACK_IMPORTED_MODULE_9__.ImgurClient(options);
        }
        throw new Error('options are invalid for creating an imgur client');
    }
    data() {
        return this;
    }
}


/***/ }),

/***/ "./src/common/data.ts":
/*!****************************!*\
  !*** ./src/common/data.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tagDataFields": () => (/* binding */ tagDataFields),
/* harmony export */   "tagDataReferenceFields": () => (/* binding */ tagDataReferenceFields)
/* harmony export */ });
const tagDataFields = [
    'slug',
    'tagnumber',
    'mysteryImage',
    'mysteryImageUrl',
    'game',
    'player',
    'hint',
    'discussionUrl',
    'foundLocation',
    'gps',
    'foundImage',
    'foundImageUrl',
];
const tagDataReferenceFields = ['game', 'player'];


/***/ }),

/***/ "./src/common/endpoints.ts":
/*!*********************************!*\
  !*** ./src/common/endpoints.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BIKETAG_API_PREFIX": () => (/* binding */ BIKETAG_API_PREFIX),
/* harmony export */   "API_VERSION": () => (/* binding */ API_VERSION),
/* harmony export */   "AUTHORIZE_ENDPOINT": () => (/* binding */ AUTHORIZE_ENDPOINT),
/* harmony export */   "IMAGE_ENDPOINT": () => (/* binding */ IMAGE_ENDPOINT),
/* harmony export */   "TAG_ENDPOINT": () => (/* binding */ TAG_ENDPOINT),
/* harmony export */   "UPLOAD_ENDPOINT": () => (/* binding */ UPLOAD_ENDPOINT),
/* harmony export */   "ALBUM_ENDPOINT": () => (/* binding */ ALBUM_ENDPOINT),
/* harmony export */   "CONFIG_ENDPOINT": () => (/* binding */ CONFIG_ENDPOINT)
/* harmony export */ });
const BIKETAG_API_PREFIX = 'https://api.biketag.org';
const API_VERSION = '2';
const AUTHORIZE_ENDPOINT = 'oauth2/authorize';
const IMAGE_ENDPOINT = `${API_VERSION}/image`;
const TAG_ENDPOINT = `${API_VERSION}/tag`;
const UPLOAD_ENDPOINT = `${API_VERSION}/upload`;
const ALBUM_ENDPOINT = `${API_VERSION}/archive`;
const CONFIG_ENDPOINT = `${API_VERSION}/config`;


/***/ }),

/***/ "./src/common/methods.ts":
/*!*******************************!*\
  !*** ./src/common/methods.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isBase64": () => (/* binding */ isBase64),
/* harmony export */   "isImageUrl": () => (/* binding */ isImageUrl),
/* harmony export */   "isStream": () => (/* binding */ isStream),
/* harmony export */   "createForm": () => (/* binding */ createForm),
/* harmony export */   "isAccessToken": () => (/* binding */ isAccessToken),
/* harmony export */   "isClientKey": () => (/* binding */ isClientKey),
/* harmony export */   "isSanityAccessToken": () => (/* binding */ isSanityAccessToken),
/* harmony export */   "isSanityClientId": () => (/* binding */ isSanityClientId),
/* harmony export */   "isImgurAccessToken": () => (/* binding */ isImgurAccessToken),
/* harmony export */   "isImgurClientId": () => (/* binding */ isImgurClientId),
/* harmony export */   "constructTagDataObject": () => (/* binding */ constructTagDataObject),
/* harmony export */   "constructTagNumberSlug": () => (/* binding */ constructTagNumberSlug),
/* harmony export */   "isImgurCredentials": () => (/* binding */ isImgurCredentials),
/* harmony export */   "isSanityCredentials": () => (/* binding */ isSanityCredentials),
/* harmony export */   "isBikeTagCredentials": () => (/* binding */ isBikeTagCredentials),
/* harmony export */   "assignImgurCredentials": () => (/* binding */ assignImgurCredentials),
/* harmony export */   "assignSanityCredentials": () => (/* binding */ assignSanityCredentials),
/* harmony export */   "assignBikeTagCredentials": () => (/* binding */ assignBikeTagCredentials),
/* harmony export */   "getImgurPictures": () => (/* binding */ getImgurPictures)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ "./src/common/data.ts");
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! form-data */ "./node_modules/form-data/lib/browser.js");
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_1__);


function isBase64(payload) {
    if (typeof payload === 'string') {
        return false;
    }
    return typeof payload.base64 !== 'undefined';
}
function isImageUrl(payload) {
    if (typeof payload === 'string') {
        return true;
    }
    return typeof payload.image !== 'undefined' && typeof payload === 'string';
}
function isStream(payload) {
    if (typeof payload === 'string') {
        return false;
    }
    return typeof payload.stream !== 'undefined';
}
function createForm(payload) {
    const form = new (form_data__WEBPACK_IMPORTED_MODULE_1___default())();
    if (typeof payload === 'string') {
        form.append('image', payload);
        return form;
    }
    for (const [key, value] of Object.entries(payload)) {
        const supportedUploadObjectTypes = ['base64', 'stream'];
        if (supportedUploadObjectTypes.indexOf(key) !== -1) {
            if (supportedUploadObjectTypes.indexOf(payload.type) !== -1) {
                form.append(key, payload);
            }
        }
        else {
            form.append(key, value);
        }
    }
    return form;
}
function isAccessToken(arg) {
    return arg.clientToken !== undefined;
}
function isClientKey(arg) {
    return arg.clientKey !== undefined;
}
function isSanityAccessToken(arg) {
    return arg.accessToken !== undefined;
}
function isSanityClientId(arg) {
    return arg.projectId !== undefined;
}
function isImgurAccessToken(arg) {
    return arg.accessToken !== undefined;
}
function isImgurClientId(arg) {
    return arg.clientId !== undefined;
}
function constructTagDataObject(data, fields = []) {
    const tagData = fields.length
        ? fields.reduce((o, f) => {
            o[f] = data[f];
            return o;
        }, {})
        : data;
    _data__WEBPACK_IMPORTED_MODULE_0__.tagDataReferenceFields.forEach((f) => {
        if (typeof tagData[f] !== 'undefined') {
            tagData[f] = tagData[f].name;
        }
    });
    // tagData.slug = tagData.slug?.current ? tagData.slug.current : undefined // Undefined would be a problem
    tagData.slug = tagData.slug.current;
    return tagData;
}
function constructTagNumberSlug(number, game = '') {
    return `${game}-tag-${number}`;
}
function isImgurCredentials(credentials) {
    return !!(credentials.clientId !== undefined || credentials.clientSecret !== undefined);
}
function isSanityCredentials(credentials) {
    return !!(credentials.projectId !== undefined && credentials.accessToken !== undefined);
}
function isBikeTagCredentials(credentials) {
    return !!(credentials.clientToken !== undefined &&
        credentials.clientKey !== undefined);
}
function assignImgurCredentials(credentials) {
    const imgurCredentials = isImgurCredentials(credentials)
        ? {
            clientId: credentials.clientId,
            clientSecret: credentials.clientSecret,
        }
        : undefined;
    return imgurCredentials;
}
function assignSanityCredentials(credentials) {
    const sanityCredentials = isSanityCredentials(credentials)
        ? {
            projectId: credentials.projectId,
            useCdn: credentials.useCdn || true,
            dataset: credentials.dataset || 'development',
            accessToken: credentials.accessToken || '',
            password: credentials.password,
            username: credentials.username,
            apiVersion: credentials.apiVersion || '2021-03-25',
        }
        : undefined;
    return sanityCredentials;
}
function assignBikeTagCredentials(credentials) {
    const biketagCredentials = isBikeTagCredentials(credentials)
        ? credentials
        : { game: credentials.game };
    return biketagCredentials;
}
function getImgurPictures() {
    return [];
}


/***/ }),

/***/ "./src/imgur/deleteTag.ts":
/*!********************************!*\
  !*** ./src/imgur/deleteTag.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* binding */ deleteTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_endpoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/endpoints */ "./src/common/endpoints.ts");


function deleteTag(client, imageHash) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
        const url = `${_common_endpoints__WEBPACK_IMPORTED_MODULE_0__.IMAGE_ENDPOINT}/${imageHash}`;
        return (yield client.request({ url, method: 'DELETE' }))
            .data;
        // return (await client
        //   .request(url, { method: 'DELETE' })
        //   .json()) as BikeTagApiResponse<boolean>;
    });
}


/***/ }),

/***/ "./src/imgur/getTag.ts":
/*!*****************************!*\
  !*** ./src/imgur/getTag.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTag": () => (/* binding */ getTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function getTag(client, options) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        /// TODO: Get the tag image hash for Reddit from the tagnumber provided
        /// TODO: Get the images associated with the tagnumber
        /// TODO: Implement data translation for Imgur image to TagData
        /// TODO: Wrap the response in a BikeTagApiResponse
        return (yield client.getImage(options.slug));
    });
}


/***/ }),

/***/ "./src/imgur/index.ts":
/*!****************************!*\
  !*** ./src/imgur/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* reexport safe */ _deleteTag__WEBPACK_IMPORTED_MODULE_0__.deleteTag),
/* harmony export */   "getTag": () => (/* reexport safe */ _getTag__WEBPACK_IMPORTED_MODULE_1__.getTag),
/* harmony export */   "updateTag": () => (/* reexport safe */ _updateTag__WEBPACK_IMPORTED_MODULE_2__.updateTag),
/* harmony export */   "uploadTagImage": () => (/* reexport safe */ _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__.uploadTagImage)
/* harmony export */ });
/* harmony import */ var _deleteTag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deleteTag */ "./src/imgur/deleteTag.ts");
/* harmony import */ var _getTag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTag */ "./src/imgur/getTag.ts");
/* harmony import */ var _updateTag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateTag */ "./src/imgur/updateTag.ts");
/* harmony import */ var _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uploadTagImage */ "./src/imgur/uploadTagImage.ts");






/***/ }),

/***/ "./src/imgur/updateTag.ts":
/*!********************************!*\
  !*** ./src/imgur/updateTag.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTag": () => (/* binding */ updateTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

// function isValidUpdatePayload(p: UpdateTagPayload) {
//   return typeof p.title === 'string' || typeof p.description === 'string';
// }
function updateTag(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        // if (Array.isArray(payload)) {
        //   const promises = payload.map((p: UpdateTagPayload) => {
        //     if (!isValidUpdatePayload(p)) {
        //       throw new Error('Update requires a title and/or description');
        //     }
        //     const form = createForm(p);
        //     return (client.request('url', {
        //       method: 'POST',
        //       body: form,
        //       resolveBodyOnly: true,
        //     }) as unknown) as Promise<BikeTagApiResponse<boolean>>;
        //   });
        //   return await Promise.all(promises);
        // }
        // if (!isValidUpdatePayload(payload)) {
        //   throw new Error('Update requires a title and/or description');
        // }
        // const form = createForm(payload);
        // return ((await client.request('url', {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // })) as unknown) as BikeTagApiResponse<boolean>;
        return (yield client.request({ url: payload, method: 'POST' }))
            .data;
    });
}


/***/ }),

/***/ "./src/imgur/uploadTagImage.ts":
/*!*************************************!*\
  !*** ./src/imgur/uploadTagImage.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uploadTagImage": () => (/* binding */ uploadTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

// import { Progress } from 'axios';
function uploadTagImage(
// client: ImgurClient,
payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        if (Array.isArray(payload)) {
            const promises = payload.map((p) => {
                // const form = createForm(p);
                // const req = client.request('UPLOAD_ENDPOINT', {
                //   method: 'POST',
                //   body: form,
                //   resolveBodyOnly: true,
                // });
                const id = 'a' + p;
                // req.on('uploadProgress', (progress: Progress) => {
                //   client.emit('uploadProgress', { ...progress, id });
                // });
                return id;
            });
            return yield Promise.all(promises);
        }
        // const form = createForm(payload);
        // const req = client.request('UPLOAD_ENDPOINT', {
        //   method: 'POST',
        //   body: form,
        //   resolveBodyOnly: true,
        // });
        const id = 'Ads';
        // req.on('uploadProgress', (progress: Progress) => {
        //   client.emit('uploadProgress', { ...progress, id });
        // });
        return id;
    });
}


/***/ }),

/***/ "./src/sanity/deleteTag.ts":
/*!*********************************!*\
  !*** ./src/sanity/deleteTag.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* binding */ deleteTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function deleteTag(client
// slug?: string,
// tagnumber?: number,
) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        return { client };
    });
}


/***/ }),

/***/ "./src/sanity/getTag.ts":
/*!******************************!*\
  !*** ./src/sanity/getTag.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTag": () => (/* binding */ getTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _common_methods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/methods */ "./src/common/methods.ts");
/* harmony import */ var _common_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/data */ "./src/common/data.ts");



function getTag(client, options) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function* () {
        if (!options) {
            throw new Error('no options');
        }
        if (!options.slug.length) {
            throw new Error('no slug');
        }
        const fields = options.fields
            .reduce((o, f) => {
            o += `${f}${_common_data__WEBPACK_IMPORTED_MODULE_1__.tagDataReferenceFields.indexOf(f) != -1 ? '->{name}' : ''},`;
            return o;
        }, '')
            .slice(0, -1);
        const query = `*[_type == "tag" && slug.current == "${options.slug}"][0]{${fields}}`;
        const params = {};
        return client.fetch(query, params).then((tag) => {
            // construct tagData object from tag
            const tagData = (0,_common_methods__WEBPACK_IMPORTED_MODULE_0__.constructTagDataObject)(tag, options.fields);
            // wrap tag in BikeTagApiResponse
            const response = {
                data: tagData,
                status: 1,
                success: true,
                source: 'sanity',
            };
            // return BikeTagApiResponse
            return response;
        });
    });
}


/***/ }),

/***/ "./src/sanity/index.ts":
/*!*****************************!*\
  !*** ./src/sanity/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteTag": () => (/* reexport safe */ _deleteTag__WEBPACK_IMPORTED_MODULE_0__.deleteTag),
/* harmony export */   "getTag": () => (/* reexport safe */ _getTag__WEBPACK_IMPORTED_MODULE_1__.getTag),
/* harmony export */   "updateTag": () => (/* reexport safe */ _updateTag__WEBPACK_IMPORTED_MODULE_2__.updateTag),
/* harmony export */   "uploadTagImage": () => (/* reexport safe */ _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__.uploadTagImage)
/* harmony export */ });
/* harmony import */ var _deleteTag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deleteTag */ "./src/sanity/deleteTag.ts");
/* harmony import */ var _getTag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTag */ "./src/sanity/getTag.ts");
/* harmony import */ var _updateTag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateTag */ "./src/sanity/updateTag.ts");
/* harmony import */ var _uploadTagImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uploadTagImage */ "./src/sanity/uploadTagImage.ts");






/***/ }),

/***/ "./src/sanity/updateTag.ts":
/*!*********************************!*\
  !*** ./src/sanity/updateTag.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateTag": () => (/* binding */ updateTag)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function updateTag(client
// payload: UpdateTagPayload | UpdateTagPayload[]
) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        return { client };
    });
}


/***/ }),

/***/ "./src/sanity/uploadTagImage.ts":
/*!**************************************!*\
  !*** ./src/sanity/uploadTagImage.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uploadTagImage": () => (/* binding */ uploadTagImage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function uploadTagImage(client, payload) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        const req = null;
        if (Array.isArray(payload)) {
            const promises = payload.map((p) => {
                return p;
            });
            return yield Promise.all(promises);
        }
        return (yield {
            client,
            req,
        });
    });
}


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__values": () => (/* binding */ __values),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(/*! requires-port */ "./node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/querystringify/index.js")
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);

  var match = protocolre.exec(address)
    , protocol = match[1] ? match[1].toLowerCase() : ''
    , slashes = !!(match[2] && match[2].length >= 2)
    , rest =  match[2] && match[2].length === 1 ? '/' + match[3] : match[3];

  return {
    protocol: protocol,
    slashes: slashes,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && url.hostname) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
isSharedArrayBufferToString.working = (
  typeof SharedArrayBuffer !== 'undefined' &&
  isSharedArrayBufferToString(new SharedArrayBuffer())
);
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBuffer === 'undefined') {
    return false;
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBuffer;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! console-browserify */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! foreach */ "./node_modules/foreach/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js");
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof __webpack_require__.g[typedArray] === 'function') {
			var arr = new __webpack_require__.g[typedArray]();
			if (!(Symbol.toStringTag in arr)) {
				throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
			}
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "./src/imgurClient/index.js":
/*!**********************************!*\
  !*** ./src/imgurClient/index.js ***!
  \**********************************/
/***/ (function(module) {

;(function webpackUniversalModuleDefinition(root, factory) {
  //CommonJS2 Comment
  if (true)
    module.exports = factory()
  //AMD Comment
  else {}
})(typeof self !== 'undefined' ? self : this, function () {
  return /******/ (() => {
    // webpackBootstrap
    /******/ var __webpack_modules__ = {
      /***/ './node_modules/array-filter/index.js':
        /*!********************************************!*\
  !*** ./node_modules/array-filter/index.js ***!
  \********************************************/
        /***/ (module) => {
          /**
           * Array#filter.
           *
           * @param {Array} arr
           * @param {Function} fn
           * @param {Object=} self
           * @return {Array}
           * @throw TypeError
           */

          module.exports = function (arr, fn, self) {
            if (arr.filter) return arr.filter(fn, self)
            if (void 0 === arr || null === arr) throw new TypeError()
            if ('function' != typeof fn) throw new TypeError()
            var ret = []
            for (var i = 0; i < arr.length; i++) {
              if (!hasOwn.call(arr, i)) continue
              var val = arr[i]
              if (fn.call(self, val, i, arr)) ret.push(val)
            }
            return ret
          }

          var hasOwn = Object.prototype.hasOwnProperty

          /***/
        },

      /***/ './node_modules/assert/build/assert.js':
        /*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_1883__) => {
          'use strict'
          /* provided dependency */ var process = __nested_webpack_require_1883__(
            /*! process/browser */ './node_modules/process/browser.js'
          )
          /* provided dependency */ var console = __nested_webpack_require_1883__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )
          // Currently in sync with Node.js lib/assert.js
          // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
          // Originally from narwhal.js (http://narwhaljs.org)
          // Copyright (c) 2009 Thomas Robinson <280north.com>
          //
          // Permission is hereby granted, free of charge, to any person obtaining a copy
          // of this software and associated documentation files (the 'Software'), to
          // deal in the Software without restriction, including without limitation the
          // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          // sell copies of the Software, and to permit persons to whom the Software is
          // furnished to do so, subject to the following conditions:
          //
          // The above copyright notice and this permission notice shall be included in
          // all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
          // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
          // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          var _require = __nested_webpack_require_1883__(
              /*! ./internal/errors */ './node_modules/assert/build/internal/errors.js'
            ),
            _require$codes = _require.codes,
            ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
            ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
            ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
            ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
            ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS

          var AssertionError = __nested_webpack_require_1883__(
            /*! ./internal/assert/assertion_error */ './node_modules/assert/build/internal/assert/assertion_error.js'
          )

          var _require2 = __nested_webpack_require_1883__(
              /*! util/ */ './node_modules/util/util.js'
            ),
            inspect = _require2.inspect

          var _require$types = __nested_webpack_require_1883__(
              /*! util/ */ './node_modules/util/util.js'
            ).types,
            isPromise = _require$types.isPromise,
            isRegExp = _require$types.isRegExp

          var objectAssign = Object.assign
            ? Object.assign
            : __nested_webpack_require_1883__(
                /*! es6-object-assign */ './node_modules/es6-object-assign/index.js'
              ).assign
          var objectIs = Object.is
            ? Object.is
            : __nested_webpack_require_1883__(
                /*! object-is */ './node_modules/object-is/index.js'
              )
          var errorCache = new Map()
          var isDeepEqual
          var isDeepStrictEqual
          var parseExpressionAt
          var findNodeAround
          var decoder

          function lazyLoadComparison() {
            var comparison = __nested_webpack_require_1883__(
              /*! ./internal/util/comparisons */ './node_modules/assert/build/internal/util/comparisons.js'
            )

            isDeepEqual = comparison.isDeepEqual
            isDeepStrictEqual = comparison.isDeepStrictEqual
          } // Escape control characters but not \n and \t to keep the line breaks and
          // indentation intact.
          // eslint-disable-next-line no-control-regex

          var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g
          var meta = [
            '\\u0000',
            '\\u0001',
            '\\u0002',
            '\\u0003',
            '\\u0004',
            '\\u0005',
            '\\u0006',
            '\\u0007',
            '\\b',
            '',
            '',
            '\\u000b',
            '\\f',
            '',
            '\\u000e',
            '\\u000f',
            '\\u0010',
            '\\u0011',
            '\\u0012',
            '\\u0013',
            '\\u0014',
            '\\u0015',
            '\\u0016',
            '\\u0017',
            '\\u0018',
            '\\u0019',
            '\\u001a',
            '\\u001b',
            '\\u001c',
            '\\u001d',
            '\\u001e',
            '\\u001f',
          ]

          var escapeFn = function escapeFn(str) {
            return meta[str.charCodeAt(0)]
          }

          var warned = false // The assert module provides functions that throw
          // AssertionError's when particular conditions are not met. The
          // assert module must conform to the following interface.

          var assert = (module.exports = ok)
          var NO_EXCEPTION_SENTINEL = {} // All of the following functions must throw an AssertionError
          // when a corresponding condition is not met, with a message that
          // may be undefined if not provided. All assertion methods provide
          // both the actual and expected values to the assertion error for
          // display purposes.

          function innerFail(obj) {
            if (obj.message instanceof Error) throw obj.message
            throw new AssertionError(obj)
          }

          function fail(actual, expected, message, operator, stackStartFn) {
            var argsLen = arguments.length
            var internalMessage

            if (argsLen === 0) {
              internalMessage = 'Failed'
            } else if (argsLen === 1) {
              message = actual
              actual = undefined
            } else {
              if (warned === false) {
                warned = true
                var warn = process.emitWarning
                  ? process.emitWarning
                  : console.warn.bind(console)
                warn(
                  'assert.fail() with more than one argument is deprecated. ' +
                    'Please use assert.strictEqual() instead or only pass a message.',
                  'DeprecationWarning',
                  'DEP0094'
                )
              }

              if (argsLen === 2) operator = '!='
            }

            if (message instanceof Error) throw message
            var errArgs = {
              actual: actual,
              expected: expected,
              operator: operator === undefined ? 'fail' : operator,
              stackStartFn: stackStartFn || fail,
            }

            if (message !== undefined) {
              errArgs.message = message
            }

            var err = new AssertionError(errArgs)

            if (internalMessage) {
              err.message = internalMessage
              err.generatedMessage = true
            }

            throw err
          }

          assert.fail = fail // The AssertionError is defined in internal/error.

          assert.AssertionError = AssertionError

          function innerOk(fn, argLen, value, message) {
            if (!value) {
              var generatedMessage = false

              if (argLen === 0) {
                generatedMessage = true
                message = 'No value argument passed to `assert.ok()`'
              } else if (message instanceof Error) {
                throw message
              }

              var err = new AssertionError({
                actual: value,
                expected: true,
                message: message,
                operator: '==',
                stackStartFn: fn,
              })
              err.generatedMessage = generatedMessage
              throw err
            }
          } // Pure assertion tests whether a value is truthy, as determined
          // by !!value.

          function ok() {
            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key]
            }

            innerOk.apply(void 0, [ok, args.length].concat(args))
          }

          assert.ok = ok // The equality assertion tests shallow, coercive equality with ==.

          /* eslint-disable no-restricted-properties */

          assert.equal = function equal(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            } // eslint-disable-next-line eqeqeq

            if (actual != expected) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: '==',
                stackStartFn: equal,
              })
            }
          } // The non-equality assertion tests for whether two objects are not
          // equal with !=.

          assert.notEqual = function notEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            } // eslint-disable-next-line eqeqeq

            if (actual == expected) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: '!=',
                stackStartFn: notEqual,
              })
            }
          } // The equivalence assertion tests a deep equality relation.

          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (!isDeepEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'deepEqual',
                stackStartFn: deepEqual,
              })
            }
          } // The non-equivalence assertion tests for any deep inequality.

          assert.notDeepEqual = function notDeepEqual(
            actual,
            expected,
            message
          ) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (isDeepEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'notDeepEqual',
                stackStartFn: notDeepEqual,
              })
            }
          }
          /* eslint-enable */

          assert.deepStrictEqual = function deepStrictEqual(
            actual,
            expected,
            message
          ) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (!isDeepStrictEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'deepStrictEqual',
                stackStartFn: deepStrictEqual,
              })
            }
          }

          assert.notDeepStrictEqual = notDeepStrictEqual

          function notDeepStrictEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (isDeepEqual === undefined) lazyLoadComparison()

            if (isDeepStrictEqual(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'notDeepStrictEqual',
                stackStartFn: notDeepStrictEqual,
              })
            }
          }

          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (!objectIs(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'strictEqual',
                stackStartFn: strictEqual,
              })
            }
          }

          assert.notStrictEqual = function notStrictEqual(
            actual,
            expected,
            message
          ) {
            if (arguments.length < 2) {
              throw new ERR_MISSING_ARGS('actual', 'expected')
            }

            if (objectIs(actual, expected)) {
              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: 'notStrictEqual',
                stackStartFn: notStrictEqual,
              })
            }
          }

          var Comparison = function Comparison(obj, keys, actual) {
            var _this = this

            _classCallCheck(this, Comparison)

            keys.forEach(function (key) {
              if (key in obj) {
                if (
                  actual !== undefined &&
                  typeof actual[key] === 'string' &&
                  isRegExp(obj[key]) &&
                  obj[key].test(actual[key])
                ) {
                  _this[key] = actual[key]
                } else {
                  _this[key] = obj[key]
                }
              }
            })
          }

          function compareExceptionKey(
            actual,
            expected,
            key,
            message,
            keys,
            fn
          ) {
            if (
              !(key in actual) ||
              !isDeepStrictEqual(actual[key], expected[key])
            ) {
              if (!message) {
                // Create placeholder objects to create a nice output.
                var a = new Comparison(actual, keys)
                var b = new Comparison(expected, keys, actual)
                var err = new AssertionError({
                  actual: a,
                  expected: b,
                  operator: 'deepStrictEqual',
                  stackStartFn: fn,
                })
                err.actual = actual
                err.expected = expected
                err.operator = fn.name
                throw err
              }

              innerFail({
                actual: actual,
                expected: expected,
                message: message,
                operator: fn.name,
                stackStartFn: fn,
              })
            }
          }

          function expectedException(actual, expected, msg, fn) {
            if (typeof expected !== 'function') {
              if (isRegExp(expected)) return expected.test(actual) // assert.doesNotThrow does not accept objects.

              if (arguments.length === 2) {
                throw new ERR_INVALID_ARG_TYPE(
                  'expected',
                  ['Function', 'RegExp'],
                  expected
                )
              } // Handle primitives properly.

              if (_typeof(actual) !== 'object' || actual === null) {
                var err = new AssertionError({
                  actual: actual,
                  expected: expected,
                  message: msg,
                  operator: 'deepStrictEqual',
                  stackStartFn: fn,
                })
                err.operator = fn.name
                throw err
              }

              var keys = Object.keys(expected) // Special handle errors to make sure the name and the message are compared
              // as well.

              if (expected instanceof Error) {
                keys.push('name', 'message')
              } else if (keys.length === 0) {
                throw new ERR_INVALID_ARG_VALUE(
                  'error',
                  expected,
                  'may not be an empty object'
                )
              }

              if (isDeepEqual === undefined) lazyLoadComparison()
              keys.forEach(function (key) {
                if (
                  typeof actual[key] === 'string' &&
                  isRegExp(expected[key]) &&
                  expected[key].test(actual[key])
                ) {
                  return
                }

                compareExceptionKey(actual, expected, key, msg, keys, fn)
              })
              return true
            } // Guard instanceof against arrow functions as they don't have a prototype.

            if (
              expected.prototype !== undefined &&
              actual instanceof expected
            ) {
              return true
            }

            if (Error.isPrototypeOf(expected)) {
              return false
            }

            return expected.call({}, actual) === true
          }

          function getActual(fn) {
            if (typeof fn !== 'function') {
              throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn)
            }

            try {
              fn()
            } catch (e) {
              return e
            }

            return NO_EXCEPTION_SENTINEL
          }

          function checkIsPromise(obj) {
            // Accept native ES6 promises and promises that are implemented in a similar
            // way. Do not accept thenables that use a function as `obj` and that have no
            // `catch` handler.
            // TODO: thenables are checked up until they have the correct methods,
            // but according to documentation, the `then` method should receive
            // the `fulfill` and `reject` arguments as well or it may be never resolved.
            return (
              isPromise(obj) ||
              (obj !== null &&
                _typeof(obj) === 'object' &&
                typeof obj.then === 'function' &&
                typeof obj.catch === 'function')
            )
          }

          function waitForActual(promiseFn) {
            return Promise.resolve().then(function () {
              var resultPromise

              if (typeof promiseFn === 'function') {
                // Return a rejected promise if `promiseFn` throws synchronously.
                resultPromise = promiseFn() // Fail in case no promise is returned.

                if (!checkIsPromise(resultPromise)) {
                  throw new ERR_INVALID_RETURN_VALUE(
                    'instance of Promise',
                    'promiseFn',
                    resultPromise
                  )
                }
              } else if (checkIsPromise(promiseFn)) {
                resultPromise = promiseFn
              } else {
                throw new ERR_INVALID_ARG_TYPE(
                  'promiseFn',
                  ['Function', 'Promise'],
                  promiseFn
                )
              }

              return Promise.resolve()
                .then(function () {
                  return resultPromise
                })
                .then(function () {
                  return NO_EXCEPTION_SENTINEL
                })
                .catch(function (e) {
                  return e
                })
            })
          }

          function expectsError(stackStartFn, actual, error, message) {
            if (typeof error === 'string') {
              if (arguments.length === 4) {
                throw new ERR_INVALID_ARG_TYPE(
                  'error',
                  ['Object', 'Error', 'Function', 'RegExp'],
                  error
                )
              }

              if (_typeof(actual) === 'object' && actual !== null) {
                if (actual.message === error) {
                  throw new ERR_AMBIGUOUS_ARGUMENT(
                    'error/message',
                    'The error message "'.concat(
                      actual.message,
                      '" is identical to the message.'
                    )
                  )
                }
              } else if (actual === error) {
                throw new ERR_AMBIGUOUS_ARGUMENT(
                  'error/message',
                  'The error "'.concat(actual, '" is identical to the message.')
                )
              }

              message = error
              error = undefined
            } else if (
              error != null &&
              _typeof(error) !== 'object' &&
              typeof error !== 'function'
            ) {
              throw new ERR_INVALID_ARG_TYPE(
                'error',
                ['Object', 'Error', 'Function', 'RegExp'],
                error
              )
            }

            if (actual === NO_EXCEPTION_SENTINEL) {
              var details = ''

              if (error && error.name) {
                details += ' ('.concat(error.name, ')')
              }

              details += message ? ': '.concat(message) : '.'
              var fnType =
                stackStartFn.name === 'rejects' ? 'rejection' : 'exception'
              innerFail({
                actual: undefined,
                expected: error,
                operator: stackStartFn.name,
                message: 'Missing expected '.concat(fnType).concat(details),
                stackStartFn: stackStartFn,
              })
            }

            if (
              error &&
              !expectedException(actual, error, message, stackStartFn)
            ) {
              throw actual
            }
          }

          function expectsNoError(stackStartFn, actual, error, message) {
            if (actual === NO_EXCEPTION_SENTINEL) return

            if (typeof error === 'string') {
              message = error
              error = undefined
            }

            if (!error || expectedException(actual, error)) {
              var details = message ? ': '.concat(message) : '.'
              var fnType =
                stackStartFn.name === 'doesNotReject'
                  ? 'rejection'
                  : 'exception'
              innerFail({
                actual: actual,
                expected: error,
                operator: stackStartFn.name,
                message:
                  'Got unwanted '.concat(fnType).concat(details, '\n') +
                  'Actual message: "'.concat(actual && actual.message, '"'),
                stackStartFn: stackStartFn,
              })
            }

            throw actual
          }

          assert.throws = function throws(promiseFn) {
            for (
              var _len2 = arguments.length,
                args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                _key2 = 1;
              _key2 < _len2;
              _key2++
            ) {
              args[_key2 - 1] = arguments[_key2]
            }

            expectsError.apply(
              void 0,
              [throws, getActual(promiseFn)].concat(args)
            )
          }

          assert.rejects = function rejects(promiseFn) {
            for (
              var _len3 = arguments.length,
                args = new Array(_len3 > 1 ? _len3 - 1 : 0),
                _key3 = 1;
              _key3 < _len3;
              _key3++
            ) {
              args[_key3 - 1] = arguments[_key3]
            }

            return waitForActual(promiseFn).then(function (result) {
              return expectsError.apply(void 0, [rejects, result].concat(args))
            })
          }

          assert.doesNotThrow = function doesNotThrow(fn) {
            for (
              var _len4 = arguments.length,
                args = new Array(_len4 > 1 ? _len4 - 1 : 0),
                _key4 = 1;
              _key4 < _len4;
              _key4++
            ) {
              args[_key4 - 1] = arguments[_key4]
            }

            expectsNoError.apply(
              void 0,
              [doesNotThrow, getActual(fn)].concat(args)
            )
          }

          assert.doesNotReject = function doesNotReject(fn) {
            for (
              var _len5 = arguments.length,
                args = new Array(_len5 > 1 ? _len5 - 1 : 0),
                _key5 = 1;
              _key5 < _len5;
              _key5++
            ) {
              args[_key5 - 1] = arguments[_key5]
            }

            return waitForActual(fn).then(function (result) {
              return expectsNoError.apply(
                void 0,
                [doesNotReject, result].concat(args)
              )
            })
          }

          assert.ifError = function ifError(err) {
            if (err !== null && err !== undefined) {
              var message = 'ifError got unwanted exception: '

              if (
                _typeof(err) === 'object' &&
                typeof err.message === 'string'
              ) {
                if (err.message.length === 0 && err.constructor) {
                  message += err.constructor.name
                } else {
                  message += err.message
                }
              } else {
                message += inspect(err)
              }

              var newErr = new AssertionError({
                actual: err,
                expected: null,
                operator: 'ifError',
                message: message,
                stackStartFn: ifError,
              }) // Make sure we actually have a stack trace!

              var origStack = err.stack

              if (typeof origStack === 'string') {
                // This will remove any duplicated frames from the error frames taken
                // from within `ifError` and add the original error frames to the newly
                // created ones.
                var tmp2 = origStack.split('\n')
                tmp2.shift() // Filter all frames existing in err.stack.

                var tmp1 = newErr.stack.split('\n')

                for (var i = 0; i < tmp2.length; i++) {
                  // Find the first occurrence of the frame.
                  var pos = tmp1.indexOf(tmp2[i])

                  if (pos !== -1) {
                    // Only keep new frames.
                    tmp1 = tmp1.slice(0, pos)
                    break
                  }
                }

                newErr.stack = ''
                  .concat(tmp1.join('\n'), '\n')
                  .concat(tmp2.join('\n'))
              }

              throw newErr
            }
          } // Expose a strict only variant of assert

          function strict() {
            for (
              var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;
              _key6 < _len6;
              _key6++
            ) {
              args[_key6] = arguments[_key6]
            }

            innerOk.apply(void 0, [strict, args.length].concat(args))
          }

          assert.strict = objectAssign(strict, assert, {
            equal: assert.strictEqual,
            deepEqual: assert.deepStrictEqual,
            notEqual: assert.notStrictEqual,
            notDeepEqual: assert.notDeepStrictEqual,
          })
          assert.strict.strict = assert.strict

          /***/
        },

      /***/ './node_modules/assert/build/internal/assert/assertion_error.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_30709__) => {
          'use strict'
          /* provided dependency */ var process = __nested_webpack_require_30709__(
            /*! process/browser */ './node_modules/process/browser.js'
          )
          // Currently in sync with Node.js lib/internal/assert/assertion_error.js
          // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {}
              var ownKeys = Object.keys(source)
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(
                  Object.getOwnPropertySymbols(source).filter(function (sym) {
                    return Object.getOwnPropertyDescriptor(
                      source,
                      sym
                    ).enumerable
                  })
                )
              }
              ownKeys.forEach(function (key) {
                _defineProperty(target, key, source[key])
              })
            }
            return target
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i]
              descriptor.enumerable = descriptor.enumerable || false
              descriptor.configurable = true
              if ('value' in descriptor) descriptor.writable = true
              Object.defineProperty(target, descriptor.key, descriptor)
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps)
            if (staticProps) _defineProperties(Constructor, staticProps)
            return Constructor
          }

          function _possibleConstructorReturn(self, call) {
            if (
              call &&
              (_typeof(call) === 'object' || typeof call === 'function')
            ) {
              return call
            }
            return _assertThisInitialized(self)
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function'
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass) _setPrototypeOf(subClass, superClass)
          }

          function _wrapNativeSuper(Class) {
            var _cache = typeof Map === 'function' ? new Map() : undefined
            _wrapNativeSuper = function _wrapNativeSuper(Class) {
              if (Class === null || !_isNativeFunction(Class)) return Class
              if (typeof Class !== 'function') {
                throw new TypeError(
                  'Super expression must either be null or a function'
                )
              }
              if (typeof _cache !== 'undefined') {
                if (_cache.has(Class)) return _cache.get(Class)
                _cache.set(Class, Wrapper)
              }
              function Wrapper() {
                return _construct(
                  Class,
                  arguments,
                  _getPrototypeOf(this).constructor
                )
              }
              Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                  value: Wrapper,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              })
              return _setPrototypeOf(Wrapper, Class)
            }
            return _wrapNativeSuper(Class)
          }

          function isNativeReflectConstruct() {
            if (typeof Reflect === 'undefined' || !Reflect.construct)
              return false
            if (Reflect.construct.sham) return false
            if (typeof Proxy === 'function') return true
            try {
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              )
              return true
            } catch (e) {
              return false
            }
          }

          function _construct(Parent, args, Class) {
            if (isNativeReflectConstruct()) {
              _construct = Reflect.construct
            } else {
              _construct = function _construct(Parent, args, Class) {
                var a = [null]
                a.push.apply(a, args)
                var Constructor = Function.bind.apply(Parent, a)
                var instance = new Constructor()
                if (Class) _setPrototypeOf(instance, Class.prototype)
                return instance
              }
            }
            return _construct.apply(null, arguments)
          }

          function _isNativeFunction(fn) {
            return Function.toString.call(fn).indexOf('[native code]') !== -1
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                o.__proto__ = p
                return o
              }
            return _setPrototypeOf(o, p)
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o)
                }
            return _getPrototypeOf(o)
          }

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          var _require = __nested_webpack_require_30709__(
              /*! util/ */ './node_modules/util/util.js'
            ),
            inspect = _require.inspect

          var _require2 = __nested_webpack_require_30709__(
              /*! ../errors */ './node_modules/assert/build/internal/errors.js'
            ),
            ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

          function endsWith(str, search, this_len) {
            if (this_len === undefined || this_len > str.length) {
              this_len = str.length
            }

            return str.substring(this_len - search.length, this_len) === search
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

          function repeat(str, count) {
            count = Math.floor(count)
            if (str.length == 0 || count == 0) return ''
            var maxCount = str.length * count
            count = Math.floor(Math.log(count) / Math.log(2))

            while (count) {
              str += str
              count--
            }

            str += str.substring(0, maxCount - str.length)
            return str
          }

          var blue = ''
          var green = ''
          var red = ''
          var white = ''
          var kReadableOperator = {
            deepStrictEqual: 'Expected values to be strictly deep-equal:',
            strictEqual: 'Expected values to be strictly equal:',
            strictEqualObject:
              'Expected "actual" to be reference-equal to "expected":',
            deepEqual: 'Expected values to be loosely deep-equal:',
            equal: 'Expected values to be loosely equal:',
            notDeepStrictEqual:
              'Expected "actual" not to be strictly deep-equal to:',
            notStrictEqual: 'Expected "actual" to be strictly unequal to:',
            notStrictEqualObject:
              'Expected "actual" not to be reference-equal to "expected":',
            notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
            notEqual: 'Expected "actual" to be loosely unequal to:',
            notIdentical: 'Values identical but not reference-equal:',
          } // Comparing short primitives should just show === / !== instead of using the
          // diff.

          var kMaxShortLength = 10

          function copyError(source) {
            var keys = Object.keys(source)
            var target = Object.create(Object.getPrototypeOf(source))
            keys.forEach(function (key) {
              target[key] = source[key]
            })
            Object.defineProperty(target, 'message', {
              value: source.message,
            })
            return target
          }

          function inspectValue(val) {
            // The util.inspect default values could be changed. This makes sure the
            // error messages contain the necessary information nevertheless.
            return inspect(val, {
              compact: false,
              customInspect: false,
              depth: 1000,
              maxArrayLength: Infinity,
              // Assert compares only enumerable properties (with a few exceptions).
              showHidden: false,
              // Having a long line as error is better than wrapping the line for
              // comparison for now.
              // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
              // have meta information about the inspected properties (i.e., know where
              // in what line the property starts and ends).
              breakLength: Infinity,
              // Assert does not detect proxies currently.
              showProxy: false,
              sorted: true,
              // Inspect getters as we also check them when comparing entries.
              getters: true,
            })
          }

          function createErrDiff(actual, expected, operator) {
            var other = ''
            var res = ''
            var lastPos = 0
            var end = ''
            var skipped = false
            var actualInspected = inspectValue(actual)
            var actualLines = actualInspected.split('\n')
            var expectedLines = inspectValue(expected).split('\n')
            var i = 0
            var indicator = '' // In case both values are objects explicitly mark them as not reference equal
            // for the `strictEqual` operator.

            if (
              operator === 'strictEqual' &&
              _typeof(actual) === 'object' &&
              _typeof(expected) === 'object' &&
              actual !== null &&
              expected !== null
            ) {
              operator = 'strictEqualObject'
            } // If "actual" and "expected" fit on a single line and they are not strictly
            // equal, check further special handling.

            if (
              actualLines.length === 1 &&
              expectedLines.length === 1 &&
              actualLines[0] !== expectedLines[0]
            ) {
              var inputLength = actualLines[0].length + expectedLines[0].length // If the character length of "actual" and "expected" together is less than
              // kMaxShortLength and if neither is an object and at least one of them is
              // not `zero`, use the strict equal comparison to visualize the output.

              if (inputLength <= kMaxShortLength) {
                if (
                  (_typeof(actual) !== 'object' || actual === null) &&
                  (_typeof(expected) !== 'object' || expected === null) &&
                  (actual !== 0 || expected !== 0)
                ) {
                  // -0 === +0
                  return (
                    ''.concat(kReadableOperator[operator], '\n\n') +
                    ''
                      .concat(actualLines[0], ' !== ')
                      .concat(expectedLines[0], '\n')
                  )
                }
              } else if (operator !== 'strictEqualObject') {
                // If the stderr is a tty and the input length is lower than the current
                // columns per line, add a mismatch indicator below the output. If it is
                // not a tty, use a default value of 80 characters.
                var maxLength =
                  process.stderr && process.stderr.isTTY
                    ? process.stderr.columns
                    : 80

                if (inputLength < maxLength) {
                  while (actualLines[0][i] === expectedLines[0][i]) {
                    i++
                  } // Ignore the first characters.

                  if (i > 2) {
                    // Add position indicator for the first mismatch in case it is a
                    // single line and the input length is less than the column length.
                    indicator = '\n  '.concat(repeat(' ', i), '^')
                    i = 0
                  }
                }
              }
            } // Remove all ending lines that match (this optimizes the output for
            // readability by reducing the number of total changed lines).

            var a = actualLines[actualLines.length - 1]
            var b = expectedLines[expectedLines.length - 1]

            while (a === b) {
              if (i++ < 2) {
                end = '\n  '.concat(a).concat(end)
              } else {
                other = a
              }

              actualLines.pop()
              expectedLines.pop()
              if (actualLines.length === 0 || expectedLines.length === 0) break
              a = actualLines[actualLines.length - 1]
              b = expectedLines[expectedLines.length - 1]
            }

            var maxLines = Math.max(actualLines.length, expectedLines.length) // Strict equal with identical objects that are not identical by reference.
            // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

            if (maxLines === 0) {
              // We have to get the result again. The lines were all removed before.
              var _actualLines = actualInspected.split('\n') // Only remove lines in case it makes sense to collapse those.
              // TODO: Accept env to always show the full error.

              if (_actualLines.length > 30) {
                _actualLines[26] = ''.concat(blue, '...').concat(white)

                while (_actualLines.length > 27) {
                  _actualLines.pop()
                }
              }

              return ''
                .concat(kReadableOperator.notIdentical, '\n\n')
                .concat(_actualLines.join('\n'), '\n')
            }

            if (i > 3) {
              end = '\n'.concat(blue, '...').concat(white).concat(end)
              skipped = true
            }

            if (other !== '') {
              end = '\n  '.concat(other).concat(end)
              other = ''
            }

            var printedLines = 0
            var msg =
              kReadableOperator[operator] +
              '\n'
                .concat(green, '+ actual')
                .concat(white, ' ')
                .concat(red, '- expected')
                .concat(white)
            var skippedMsg = ' '
              .concat(blue, '...')
              .concat(white, ' Lines skipped')

            for (i = 0; i < maxLines; i++) {
              // Only extra expected lines exist
              var cur = i - lastPos

              if (actualLines.length < i + 1) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                  if (cur > 4) {
                    res += '\n'.concat(blue, '...').concat(white)
                    skipped = true
                  } else if (cur > 3) {
                    res += '\n  '.concat(expectedLines[i - 2])
                    printedLines++
                  }

                  res += '\n  '.concat(expectedLines[i - 1])
                  printedLines++
                } // Mark the current line as the last diverging one.

                lastPos = i // Add the expected line to the cache.

                other += '\n'
                  .concat(red, '-')
                  .concat(white, ' ')
                  .concat(expectedLines[i])
                printedLines++ // Only extra actual lines exist
              } else if (expectedLines.length < i + 1) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                  if (cur > 4) {
                    res += '\n'.concat(blue, '...').concat(white)
                    skipped = true
                  } else if (cur > 3) {
                    res += '\n  '.concat(actualLines[i - 2])
                    printedLines++
                  }

                  res += '\n  '.concat(actualLines[i - 1])
                  printedLines++
                } // Mark the current line as the last diverging one.

                lastPos = i // Add the actual line to the result.

                res += '\n'
                  .concat(green, '+')
                  .concat(white, ' ')
                  .concat(actualLines[i])
                printedLines++ // Lines diverge
              } else {
                var expectedLine = expectedLines[i]
                var actualLine = actualLines[i] // If the lines diverge, specifically check for lines that only diverge by
                // a trailing comma. In that case it is actually identical and we should
                // mark it as such.

                var divergingLines =
                  actualLine !== expectedLine &&
                  (!endsWith(actualLine, ',') ||
                    actualLine.slice(0, -1) !== expectedLine) // If the expected line has a trailing comma but is otherwise identical,
                // add a comma at the end of the actual line. Otherwise the output could
                // look weird as in:
                //
                //   [
                //     1         // No comma at the end!
                // +   2
                //   ]
                //

                if (
                  divergingLines &&
                  endsWith(expectedLine, ',') &&
                  expectedLine.slice(0, -1) === actualLine
                ) {
                  divergingLines = false
                  actualLine += ','
                }

                if (divergingLines) {
                  // If the last diverging line is more than one line above and the
                  // current line is at least line three, add some of the former lines and
                  // also add dots to indicate skipped entries.
                  if (cur > 1 && i > 2) {
                    if (cur > 4) {
                      res += '\n'.concat(blue, '...').concat(white)
                      skipped = true
                    } else if (cur > 3) {
                      res += '\n  '.concat(actualLines[i - 2])
                      printedLines++
                    }

                    res += '\n  '.concat(actualLines[i - 1])
                    printedLines++
                  } // Mark the current line as the last diverging one.

                  lastPos = i // Add the actual line to the result and cache the expected diverging
                  // line so consecutive diverging lines show up as +++--- and not +-+-+-.

                  res += '\n'
                    .concat(green, '+')
                    .concat(white, ' ')
                    .concat(actualLine)
                  other += '\n'
                    .concat(red, '-')
                    .concat(white, ' ')
                    .concat(expectedLine)
                  printedLines += 2 // Lines are identical
                } else {
                  // Add all cached information to the result before adding other things
                  // and reset the cache.
                  res += other
                  other = '' // If the last diverging line is exactly one line above or if it is the
                  // very first line, add the line to the result.

                  if (cur === 1 || i === 0) {
                    res += '\n  '.concat(actualLine)
                    printedLines++
                  }
                }
              } // Inspected object to big (Show ~20 rows max)

              if (printedLines > 20 && i < maxLines - 2) {
                return (
                  ''
                    .concat(msg)
                    .concat(skippedMsg, '\n')
                    .concat(res, '\n')
                    .concat(blue, '...')
                    .concat(white)
                    .concat(other, '\n') + ''.concat(blue, '...').concat(white)
                )
              }
            }

            return ''
              .concat(msg)
              .concat(skipped ? skippedMsg : '', '\n')
              .concat(res)
              .concat(other)
              .concat(end)
              .concat(indicator)
          }

          var AssertionError =
            /*#__PURE__*/
            (function (_Error) {
              _inherits(AssertionError, _Error)

              function AssertionError(options) {
                var _this

                _classCallCheck(this, AssertionError)

                if (_typeof(options) !== 'object' || options === null) {
                  throw new ERR_INVALID_ARG_TYPE('options', 'Object', options)
                }

                var message = options.message,
                  operator = options.operator,
                  stackStartFn = options.stackStartFn
                var actual = options.actual,
                  expected = options.expected
                var limit = Error.stackTraceLimit
                Error.stackTraceLimit = 0

                if (message != null) {
                  _this = _possibleConstructorReturn(
                    this,
                    _getPrototypeOf(AssertionError).call(this, String(message))
                  )
                } else {
                  if (process.stderr && process.stderr.isTTY) {
                    // Reset on each call to make sure we handle dynamically set environment
                    // variables correct.
                    if (
                      process.stderr &&
                      process.stderr.getColorDepth &&
                      process.stderr.getColorDepth() !== 1
                    ) {
                      blue = '\x1B[34m'
                      green = '\x1B[32m'
                      white = '\x1B[39m'
                      red = '\x1B[31m'
                    } else {
                      blue = ''
                      green = ''
                      white = ''
                      red = ''
                    }
                  } // Prevent the error stack from being visible by duplicating the error
                  // in a very close way to the original in case both sides are actually
                  // instances of Error.

                  if (
                    _typeof(actual) === 'object' &&
                    actual !== null &&
                    _typeof(expected) === 'object' &&
                    expected !== null &&
                    'stack' in actual &&
                    actual instanceof Error &&
                    'stack' in expected &&
                    expected instanceof Error
                  ) {
                    actual = copyError(actual)
                    expected = copyError(expected)
                  }

                  if (
                    operator === 'deepStrictEqual' ||
                    operator === 'strictEqual'
                  ) {
                    _this = _possibleConstructorReturn(
                      this,
                      _getPrototypeOf(AssertionError).call(
                        this,
                        createErrDiff(actual, expected, operator)
                      )
                    )
                  } else if (
                    operator === 'notDeepStrictEqual' ||
                    operator === 'notStrictEqual'
                  ) {
                    // In case the objects are equal but the operator requires unequal, show
                    // the first object and say A equals B
                    var base = kReadableOperator[operator]
                    var res = inspectValue(actual).split('\n') // In case "actual" is an object, it should not be reference equal.

                    if (
                      operator === 'notStrictEqual' &&
                      _typeof(actual) === 'object' &&
                      actual !== null
                    ) {
                      base = kReadableOperator.notStrictEqualObject
                    } // Only remove lines in case it makes sense to collapse those.
                    // TODO: Accept env to always show the full error.

                    if (res.length > 30) {
                      res[26] = ''.concat(blue, '...').concat(white)

                      while (res.length > 27) {
                        res.pop()
                      }
                    } // Only print a single input.

                    if (res.length === 1) {
                      _this = _possibleConstructorReturn(
                        this,
                        _getPrototypeOf(AssertionError).call(
                          this,
                          ''.concat(base, ' ').concat(res[0])
                        )
                      )
                    } else {
                      _this = _possibleConstructorReturn(
                        this,
                        _getPrototypeOf(AssertionError).call(
                          this,
                          ''.concat(base, '\n\n').concat(res.join('\n'), '\n')
                        )
                      )
                    }
                  } else {
                    var _res = inspectValue(actual)

                    var other = ''
                    var knownOperators = kReadableOperator[operator]

                    if (
                      operator === 'notDeepEqual' ||
                      operator === 'notEqual'
                    ) {
                      _res = ''
                        .concat(kReadableOperator[operator], '\n\n')
                        .concat(_res)

                      if (_res.length > 1024) {
                        _res = ''.concat(_res.slice(0, 1021), '...')
                      }
                    } else {
                      other = ''.concat(inspectValue(expected))

                      if (_res.length > 512) {
                        _res = ''.concat(_res.slice(0, 509), '...')
                      }

                      if (other.length > 512) {
                        other = ''.concat(other.slice(0, 509), '...')
                      }

                      if (operator === 'deepEqual' || operator === 'equal') {
                        _res = ''
                          .concat(knownOperators, '\n\n')
                          .concat(_res, '\n\nshould equal\n\n')
                      } else {
                        other = ' '.concat(operator, ' ').concat(other)
                      }
                    }

                    _this = _possibleConstructorReturn(
                      this,
                      _getPrototypeOf(AssertionError).call(
                        this,
                        ''.concat(_res).concat(other)
                      )
                    )
                  }
                }

                Error.stackTraceLimit = limit
                _this.generatedMessage = !message
                Object.defineProperty(_assertThisInitialized(_this), 'name', {
                  value: 'AssertionError [ERR_ASSERTION]',
                  enumerable: false,
                  writable: true,
                  configurable: true,
                })
                _this.code = 'ERR_ASSERTION'
                _this.actual = actual
                _this.expected = expected
                _this.operator = operator

                if (Error.captureStackTrace) {
                  // eslint-disable-next-line no-restricted-syntax
                  Error.captureStackTrace(
                    _assertThisInitialized(_this),
                    stackStartFn
                  )
                } // Create error message including the error code in the name.

                _this.stack // Reset the name.

                _this.name = 'AssertionError'
                return _possibleConstructorReturn(_this)
              }

              _createClass(AssertionError, [
                {
                  key: 'toString',
                  value: function toString() {
                    return ''
                      .concat(this.name, ' [')
                      .concat(this.code, ']: ')
                      .concat(this.message)
                  },
                },
                {
                  key: inspect.custom,
                  value: function value(recurseTimes, ctx) {
                    // This limits the `actual` and `expected` property default inspection to
                    // the minimum depth. Otherwise those values would be too verbose compared
                    // to the actual error message which contains a combined view of these two
                    // input values.
                    return inspect(
                      this,
                      _objectSpread({}, ctx, {
                        customInspect: false,
                        depth: 0,
                      })
                    )
                  },
                },
              ])

              return AssertionError
            })(_wrapNativeSuper(Error))

          module.exports = AssertionError

          /***/
        },

      /***/ './node_modules/assert/build/internal/errors.js':
        /*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_62541__) => {
          'use strict'
          // Currently in sync with Node.js lib/internal/errors.js
          // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

          /* eslint node-core/documented-errors: "error" */

          /* eslint node-core/alphabetize-errors: "error" */

          /* eslint node-core/prefer-util-format-errors: "error" */
          // The whole point behind this internal module is to allow Node.js to no
          // longer be forced to treat every error message change as a semver-major
          // change. The NodeError classes here all expose a `code` property whose
          // value statically and permanently identifies the error. While the error
          // message may change, the code should not.

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (
              call &&
              (_typeof(call) === 'object' || typeof call === 'function')
            ) {
              return call
            }
            return _assertThisInitialized(self)
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return self
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o)
                }
            return _getPrototypeOf(o)
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function'
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass) _setPrototypeOf(subClass, superClass)
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf =
              Object.setPrototypeOf ||
              function _setPrototypeOf(o, p) {
                o.__proto__ = p
                return o
              }
            return _setPrototypeOf(o, p)
          }

          var codes = {} // Lazy loaded

          var assert
          var util

          function createErrorType(code, message, Base) {
            if (!Base) {
              Base = Error
            }

            function getMessage(arg1, arg2, arg3) {
              if (typeof message === 'string') {
                return message
              } else {
                return message(arg1, arg2, arg3)
              }
            }

            var NodeError =
              /*#__PURE__*/
              (function (_Base) {
                _inherits(NodeError, _Base)

                function NodeError(arg1, arg2, arg3) {
                  var _this

                  _classCallCheck(this, NodeError)

                  _this = _possibleConstructorReturn(
                    this,
                    _getPrototypeOf(NodeError).call(
                      this,
                      getMessage(arg1, arg2, arg3)
                    )
                  )
                  _this.code = code
                  return _this
                }

                return NodeError
              })(Base)

            codes[code] = NodeError
          } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

          function oneOf(expected, thing) {
            if (Array.isArray(expected)) {
              var len = expected.length
              expected = expected.map(function (i) {
                return String(i)
              })

              if (len > 2) {
                return (
                  'one of '
                    .concat(thing, ' ')
                    .concat(expected.slice(0, len - 1).join(', '), ', or ') +
                  expected[len - 1]
                )
              } else if (len === 2) {
                return 'one of '
                  .concat(thing, ' ')
                  .concat(expected[0], ' or ')
                  .concat(expected[1])
              } else {
                return 'of '.concat(thing, ' ').concat(expected[0])
              }
            } else {
              return 'of '.concat(thing, ' ').concat(String(expected))
            }
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

          function startsWith(str, search, pos) {
            return (
              str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search
            )
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

          function endsWith(str, search, this_len) {
            if (this_len === undefined || this_len > str.length) {
              this_len = str.length
            }

            return str.substring(this_len - search.length, this_len) === search
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

          function includes(str, search, start) {
            if (typeof start !== 'number') {
              start = 0
            }

            if (start + search.length > str.length) {
              return false
            } else {
              return str.indexOf(search, start) !== -1
            }
          }

          createErrorType(
            'ERR_AMBIGUOUS_ARGUMENT',
            'The "%s" argument is ambiguous. %s',
            TypeError
          )
          createErrorType(
            'ERR_INVALID_ARG_TYPE',
            function (name, expected, actual) {
              if (assert === undefined)
                assert = __nested_webpack_require_62541__(
                  /*! ../assert */ './node_modules/assert/build/assert.js'
                )
              assert(typeof name === 'string', "'name' must be a string") // determiner: 'must be' or 'must not be'

              var determiner

              if (
                typeof expected === 'string' &&
                startsWith(expected, 'not ')
              ) {
                determiner = 'must not be'
                expected = expected.replace(/^not /, '')
              } else {
                determiner = 'must be'
              }

              var msg

              if (endsWith(name, ' argument')) {
                // For cases like 'first argument'
                msg = 'The '
                  .concat(name, ' ')
                  .concat(determiner, ' ')
                  .concat(oneOf(expected, 'type'))
              } else {
                var type = includes(name, '.') ? 'property' : 'argument'
                msg = 'The "'
                  .concat(name, '" ')
                  .concat(type, ' ')
                  .concat(determiner, ' ')
                  .concat(oneOf(expected, 'type'))
              } // TODO(BridgeAR): Improve the output by showing `null` and similar.

              msg += '. Received type '.concat(_typeof(actual))
              return msg
            },
            TypeError
          )
          createErrorType(
            'ERR_INVALID_ARG_VALUE',
            function (name, value) {
              var reason =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : 'is invalid'
              if (util === undefined)
                util = __nested_webpack_require_62541__(
                  /*! util/ */ './node_modules/util/util.js'
                )
              var inspected = util.inspect(value)

              if (inspected.length > 128) {
                inspected = ''.concat(inspected.slice(0, 128), '...')
              }

              return "The argument '"
                .concat(name, "' ")
                .concat(reason, '. Received ')
                .concat(inspected)
            },
            TypeError,
            RangeError
          )
          createErrorType(
            'ERR_INVALID_RETURN_VALUE',
            function (input, name, value) {
              var type

              if (value && value.constructor && value.constructor.name) {
                type = 'instance of '.concat(value.constructor.name)
              } else {
                type = 'type '.concat(_typeof(value))
              }

              return (
                'Expected '
                  .concat(input, ' to be returned from the "')
                  .concat(name, '"') + ' function but got '.concat(type, '.')
              )
            },
            TypeError
          )
          createErrorType(
            'ERR_MISSING_ARGS',
            function () {
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key]
              }

              if (assert === undefined)
                assert = __nested_webpack_require_62541__(
                  /*! ../assert */ './node_modules/assert/build/assert.js'
                )
              assert(args.length > 0, 'At least one arg needs to be specified')
              var msg = 'The '
              var len = args.length
              args = args.map(function (a) {
                return '"'.concat(a, '"')
              })

              switch (len) {
                case 1:
                  msg += ''.concat(args[0], ' argument')
                  break

                case 2:
                  msg += ''
                    .concat(args[0], ' and ')
                    .concat(args[1], ' arguments')
                  break

                default:
                  msg += args.slice(0, len - 1).join(', ')
                  msg += ', and '.concat(args[len - 1], ' arguments')
                  break
              }

              return ''.concat(msg, ' must be specified')
            },
            TypeError
          )
          module.exports.codes = codes

          /***/
        },

      /***/ './node_modules/assert/build/internal/util/comparisons.js':
        /*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_74092__) => {
          'use strict'
          // Currently in sync with Node.js lib/internal/util/comparisons.js
          // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

          function _slicedToArray(arr, i) {
            return (
              _arrayWithHoles(arr) ||
              _iterableToArrayLimit(arr, i) ||
              _nonIterableRest()
            )
          }

          function _nonIterableRest() {
            throw new TypeError(
              'Invalid attempt to destructure non-iterable instance'
            )
          }

          function _iterableToArrayLimit(arr, i) {
            var _arr = []
            var _n = true
            var _d = false
            var _e = undefined
            try {
              for (
                var _i = arr[Symbol.iterator](), _s;
                !(_n = (_s = _i.next()).done);
                _n = true
              ) {
                _arr.push(_s.value)
                if (i && _arr.length === i) break
              }
            } catch (err) {
              _d = true
              _e = err
            } finally {
              try {
                if (!_n && _i['return'] != null) _i['return']()
              } finally {
                if (_d) throw _e
              }
            }
            return _arr
          }

          function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr
          }

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          var regexFlagsSupported = /a/g.flags !== undefined

          var arrayFromSet = function arrayFromSet(set) {
            var array = []
            set.forEach(function (value) {
              return array.push(value)
            })
            return array
          }

          var arrayFromMap = function arrayFromMap(map) {
            var array = []
            map.forEach(function (value, key) {
              return array.push([key, value])
            })
            return array
          }

          var objectIs = Object.is
            ? Object.is
            : __nested_webpack_require_74092__(
                /*! object-is */ './node_modules/object-is/index.js'
              )
          var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols
            ? Object.getOwnPropertySymbols
            : function () {
                return []
              }
          var numberIsNaN = Number.isNaN
            ? Number.isNaN
            : __nested_webpack_require_74092__(
                /*! is-nan */ './node_modules/is-nan/index.js'
              )

          function uncurryThis(f) {
            return f.call.bind(f)
          }

          var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty)
          var propertyIsEnumerable = uncurryThis(
            Object.prototype.propertyIsEnumerable
          )
          var objectToString = uncurryThis(Object.prototype.toString)

          var _require$types = __nested_webpack_require_74092__(
              /*! util/ */ './node_modules/util/util.js'
            ).types,
            isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
            isArrayBufferView = _require$types.isArrayBufferView,
            isDate = _require$types.isDate,
            isMap = _require$types.isMap,
            isRegExp = _require$types.isRegExp,
            isSet = _require$types.isSet,
            isNativeError = _require$types.isNativeError,
            isBoxedPrimitive = _require$types.isBoxedPrimitive,
            isNumberObject = _require$types.isNumberObject,
            isStringObject = _require$types.isStringObject,
            isBooleanObject = _require$types.isBooleanObject,
            isBigIntObject = _require$types.isBigIntObject,
            isSymbolObject = _require$types.isSymbolObject,
            isFloat32Array = _require$types.isFloat32Array,
            isFloat64Array = _require$types.isFloat64Array

          function isNonIndex(key) {
            if (key.length === 0 || key.length > 10) return true

            for (var i = 0; i < key.length; i++) {
              var code = key.charCodeAt(i)
              if (code < 48 || code > 57) return true
            } // The maximum size for an array is 2 ** 32 -1.

            return key.length === 10 && key >= Math.pow(2, 32)
          }

          function getOwnNonIndexProperties(value) {
            return Object.keys(value)
              .filter(isNonIndex)
              .concat(
                objectGetOwnPropertySymbols(value).filter(
                  Object.prototype.propertyIsEnumerable.bind(value)
                )
              )
          } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
          // original notice:

          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */

          function compare(a, b) {
            if (a === b) {
              return 0
            }

            var x = a.length
            var y = b.length

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i]
                y = b[i]
                break
              }
            }

            if (x < y) {
              return -1
            }

            if (y < x) {
              return 1
            }

            return 0
          }

          var ONLY_ENUMERABLE = undefined
          var kStrict = true
          var kLoose = false
          var kNoIterator = 0
          var kIsArray = 1
          var kIsSet = 2
          var kIsMap = 3 // Check if they have the same source and flags

          function areSimilarRegExps(a, b) {
            return regexFlagsSupported
              ? a.source === b.source && a.flags === b.flags
              : RegExp.prototype.toString.call(a) ===
                  RegExp.prototype.toString.call(b)
          }

          function areSimilarFloatArrays(a, b) {
            if (a.byteLength !== b.byteLength) {
              return false
            }

            for (var offset = 0; offset < a.byteLength; offset++) {
              if (a[offset] !== b[offset]) {
                return false
              }
            }

            return true
          }

          function areSimilarTypedArrays(a, b) {
            if (a.byteLength !== b.byteLength) {
              return false
            }

            return (
              compare(
                new Uint8Array(a.buffer, a.byteOffset, a.byteLength),
                new Uint8Array(b.buffer, b.byteOffset, b.byteLength)
              ) === 0
            )
          }

          function areEqualArrayBuffers(buf1, buf2) {
            return (
              buf1.byteLength === buf2.byteLength &&
              compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0
            )
          }

          function isEqualBoxedPrimitive(val1, val2) {
            if (isNumberObject(val1)) {
              return (
                isNumberObject(val2) &&
                objectIs(
                  Number.prototype.valueOf.call(val1),
                  Number.prototype.valueOf.call(val2)
                )
              )
            }

            if (isStringObject(val1)) {
              return (
                isStringObject(val2) &&
                String.prototype.valueOf.call(val1) ===
                  String.prototype.valueOf.call(val2)
              )
            }

            if (isBooleanObject(val1)) {
              return (
                isBooleanObject(val2) &&
                Boolean.prototype.valueOf.call(val1) ===
                  Boolean.prototype.valueOf.call(val2)
              )
            }

            if (isBigIntObject(val1)) {
              return (
                isBigIntObject(val2) &&
                BigInt.prototype.valueOf.call(val1) ===
                  BigInt.prototype.valueOf.call(val2)
              )
            }

            return (
              isSymbolObject(val2) &&
              Symbol.prototype.valueOf.call(val1) ===
                Symbol.prototype.valueOf.call(val2)
            )
          } // Notes: Type tags are historical [[Class]] properties that can be set by
          // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
          // and retrieved using Object.prototype.toString.call(obj) in JS
          // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
          // for a list of tags pre-defined in the spec.
          // There are some unspecified tags in the wild too (e.g. typed array tags).
          // Since tags can be altered, they only serve fast failures
          //
          // Typed arrays and buffers are checked by comparing the content in their
          // underlying ArrayBuffer. This optimization requires that it's
          // reasonable to interpret their underlying memory in the same way,
          // which is checked by comparing their type tags.
          // (e.g. a Uint8Array and a Uint16Array with the same memory content
          // could still be different because they will be interpreted differently).
          //
          // For strict comparison, objects should have
          // a) The same built-in type tags
          // b) The same prototypes.

          function innerDeepEqual(val1, val2, strict, memos) {
            // All identical values are equivalent, as determined by ===.
            if (val1 === val2) {
              if (val1 !== 0) return true
              return strict ? objectIs(val1, val2) : true
            } // Check more closely if val1 and val2 are equal.

            if (strict) {
              if (_typeof(val1) !== 'object') {
                return (
                  typeof val1 === 'number' &&
                  numberIsNaN(val1) &&
                  numberIsNaN(val2)
                )
              }

              if (
                _typeof(val2) !== 'object' ||
                val1 === null ||
                val2 === null
              ) {
                return false
              }

              if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                return false
              }
            } else {
              if (val1 === null || _typeof(val1) !== 'object') {
                if (val2 === null || _typeof(val2) !== 'object') {
                  // eslint-disable-next-line eqeqeq
                  return val1 == val2
                }

                return false
              }

              if (val2 === null || _typeof(val2) !== 'object') {
                return false
              }
            }

            var val1Tag = objectToString(val1)
            var val2Tag = objectToString(val2)

            if (val1Tag !== val2Tag) {
              return false
            }

            if (Array.isArray(val1)) {
              // Check for sparse arrays and general fast path
              if (val1.length !== val2.length) {
                return false
              }

              var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE)
              var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE)

              if (keys1.length !== keys2.length) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kIsArray, keys1)
            } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
            // wan't to early return out of the rest of the checks. However we can check
            // if the second value is one of these values and the first isn't.

            if (val1Tag === '[object Object]') {
              // return keyCheck(val1, val2, strict, memos, kNoIterator);
              if (
                (!isMap(val1) && isMap(val2)) ||
                (!isSet(val1) && isSet(val2))
              ) {
                return false
              }
            }

            if (isDate(val1)) {
              if (
                !isDate(val2) ||
                Date.prototype.getTime.call(val1) !==
                  Date.prototype.getTime.call(val2)
              ) {
                return false
              }
            } else if (isRegExp(val1)) {
              if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                return false
              }
            } else if (isNativeError(val1) || val1 instanceof Error) {
              // Do not compare the stack as it might differ even though the error itself
              // is otherwise identical.
              if (val1.message !== val2.message || val1.name !== val2.name) {
                return false
              }
            } else if (isArrayBufferView(val1)) {
              if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                if (!areSimilarFloatArrays(val1, val2)) {
                  return false
                }
              } else if (!areSimilarTypedArrays(val1, val2)) {
                return false
              } // Buffer.compare returns true, so val1.length === val2.length. If they both
              // only contain numeric keys, we don't need to exam further than checking
              // the symbols.

              var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE)

              var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE)

              if (_keys.length !== _keys2.length) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kNoIterator, _keys)
            } else if (isSet(val1)) {
              if (!isSet(val2) || val1.size !== val2.size) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kIsSet)
            } else if (isMap(val1)) {
              if (!isMap(val2) || val1.size !== val2.size) {
                return false
              }

              return keyCheck(val1, val2, strict, memos, kIsMap)
            } else if (isAnyArrayBuffer(val1)) {
              if (!areEqualArrayBuffers(val1, val2)) {
                return false
              }
            } else if (
              isBoxedPrimitive(val1) &&
              !isEqualBoxedPrimitive(val1, val2)
            ) {
              return false
            }

            return keyCheck(val1, val2, strict, memos, kNoIterator)
          }

          function getEnumerables(val, keys) {
            return keys.filter(function (k) {
              return propertyIsEnumerable(val, k)
            })
          }

          function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
            // For all remaining Object pairs, including Array, objects and Maps,
            // equivalence is determined by having:
            // a) The same number of owned enumerable properties
            // b) The same set of keys/indexes (although not necessarily the same order)
            // c) Equivalent values for every corresponding key/index
            // d) For Sets and Maps, equal contents
            // Note: this accounts for both named and indexed properties on Arrays.
            if (arguments.length === 5) {
              aKeys = Object.keys(val1)
              var bKeys = Object.keys(val2) // The pair must have the same number of owned properties.

              if (aKeys.length !== bKeys.length) {
                return false
              }
            } // Cheap key test

            var i = 0

            for (; i < aKeys.length; i++) {
              if (!hasOwnProperty(val2, aKeys[i])) {
                return false
              }
            }

            if (strict && arguments.length === 5) {
              var symbolKeysA = objectGetOwnPropertySymbols(val1)

              if (symbolKeysA.length !== 0) {
                var count = 0

                for (i = 0; i < symbolKeysA.length; i++) {
                  var key = symbolKeysA[i]

                  if (propertyIsEnumerable(val1, key)) {
                    if (!propertyIsEnumerable(val2, key)) {
                      return false
                    }

                    aKeys.push(key)
                    count++
                  } else if (propertyIsEnumerable(val2, key)) {
                    return false
                  }
                }

                var symbolKeysB = objectGetOwnPropertySymbols(val2)

                if (
                  symbolKeysA.length !== symbolKeysB.length &&
                  getEnumerables(val2, symbolKeysB).length !== count
                ) {
                  return false
                }
              } else {
                var _symbolKeysB = objectGetOwnPropertySymbols(val2)

                if (
                  _symbolKeysB.length !== 0 &&
                  getEnumerables(val2, _symbolKeysB).length !== 0
                ) {
                  return false
                }
              }
            }

            if (
              aKeys.length === 0 &&
              (iterationType === kNoIterator ||
                (iterationType === kIsArray && val1.length === 0) ||
                val1.size === 0)
            ) {
              return true
            } // Use memos to handle cycles.

            if (memos === undefined) {
              memos = {
                val1: new Map(),
                val2: new Map(),
                position: 0,
              }
            } else {
              // We prevent up to two map.has(x) calls by directly retrieving the value
              // and checking for undefined. The map can only contain numbers, so it is
              // safe to check for undefined only.
              var val2MemoA = memos.val1.get(val1)

              if (val2MemoA !== undefined) {
                var val2MemoB = memos.val2.get(val2)

                if (val2MemoB !== undefined) {
                  return val2MemoA === val2MemoB
                }
              }

              memos.position++
            }

            memos.val1.set(val1, memos.position)
            memos.val2.set(val2, memos.position)
            var areEq = objEquiv(
              val1,
              val2,
              strict,
              aKeys,
              memos,
              iterationType
            )
            memos.val1.delete(val1)
            memos.val2.delete(val2)
            return areEq
          }

          function setHasEqualElement(set, val1, strict, memo) {
            // Go looking.
            var setValues = arrayFromSet(set)

            for (var i = 0; i < setValues.length; i++) {
              var val2 = setValues[i]

              if (innerDeepEqual(val1, val2, strict, memo)) {
                // Remove the matching element to make sure we do not check that again.
                set.delete(val2)
                return true
              }
            }

            return false
          } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
          // Sadly it is not possible to detect corresponding values properly in case the
          // type is a string, number, bigint or boolean. The reason is that those values
          // can match lots of different string values (e.g., 1n == '+00001').

          function findLooseMatchingPrimitives(prim) {
            switch (_typeof(prim)) {
              case 'undefined':
                return null

              case 'object':
                // Only pass in null as object!
                return undefined

              case 'symbol':
                return false

              case 'string':
                prim = +prim
              // Loose equal entries exist only if the string is possible to convert to
              // a regular number and not NaN.
              // Fall through

              case 'number':
                if (numberIsNaN(prim)) {
                  return false
                }
            }

            return true
          }

          function setMightHaveLoosePrim(a, b, prim) {
            var altValue = findLooseMatchingPrimitives(prim)
            if (altValue != null) return altValue
            return b.has(altValue) && !a.has(altValue)
          }

          function mapMightHaveLoosePrim(a, b, prim, item, memo) {
            var altValue = findLooseMatchingPrimitives(prim)

            if (altValue != null) {
              return altValue
            }

            var curB = b.get(altValue)

            if (
              (curB === undefined && !b.has(altValue)) ||
              !innerDeepEqual(item, curB, false, memo)
            ) {
              return false
            }

            return !a.has(altValue) && innerDeepEqual(item, curB, false, memo)
          }

          function setEquiv(a, b, strict, memo) {
            // This is a lazily initiated Set of entries which have to be compared
            // pairwise.
            var set = null
            var aValues = arrayFromSet(a)

            for (var i = 0; i < aValues.length; i++) {
              var val = aValues[i] // Note: Checking for the objects first improves the performance for object
              // heavy sets but it is a minor slow down for primitives. As they are fast
              // to check this improves the worst case scenario instead.

              if (_typeof(val) === 'object' && val !== null) {
                if (set === null) {
                  set = new Set()
                } // If the specified value doesn't exist in the second set its an not null
                // object (or non strict only: a not matching primitive) we'll need to go
                // hunting for something thats deep-(strict-)equal to it. To make this
                // O(n log n) complexity we have to copy these values in a new set first.

                set.add(val)
              } else if (!b.has(val)) {
                if (strict) return false // Fast path to detect missing string, symbol, undefined and null values.

                if (!setMightHaveLoosePrim(a, b, val)) {
                  return false
                }

                if (set === null) {
                  set = new Set()
                }

                set.add(val)
              }
            }

            if (set !== null) {
              var bValues = arrayFromSet(b)

              for (var _i = 0; _i < bValues.length; _i++) {
                var _val = bValues[_i] // We have to check if a primitive value is already
                // matching and only if it's not, go hunting for it.

                if (_typeof(_val) === 'object' && _val !== null) {
                  if (!setHasEqualElement(set, _val, strict, memo)) return false
                } else if (
                  !strict &&
                  !a.has(_val) &&
                  !setHasEqualElement(set, _val, strict, memo)
                ) {
                  return false
                }
              }

              return set.size === 0
            }

            return true
          }

          function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
            // To be able to handle cases like:
            //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
            // ... we need to consider *all* matching keys, not just the first we find.
            var setValues = arrayFromSet(set)

            for (var i = 0; i < setValues.length; i++) {
              var key2 = setValues[i]

              if (
                innerDeepEqual(key1, key2, strict, memo) &&
                innerDeepEqual(item1, map.get(key2), strict, memo)
              ) {
                set.delete(key2)
                return true
              }
            }

            return false
          }

          function mapEquiv(a, b, strict, memo) {
            var set = null
            var aEntries = arrayFromMap(a)

            for (var i = 0; i < aEntries.length; i++) {
              var _aEntries$i = _slicedToArray(aEntries[i], 2),
                key = _aEntries$i[0],
                item1 = _aEntries$i[1]

              if (_typeof(key) === 'object' && key !== null) {
                if (set === null) {
                  set = new Set()
                }

                set.add(key)
              } else {
                // By directly retrieving the value we prevent another b.has(key) check in
                // almost all possible cases.
                var item2 = b.get(key)

                if (
                  (item2 === undefined && !b.has(key)) ||
                  !innerDeepEqual(item1, item2, strict, memo)
                ) {
                  if (strict) return false // Fast path to detect missing string, symbol, undefined and null
                  // keys.

                  if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
                    return false

                  if (set === null) {
                    set = new Set()
                  }

                  set.add(key)
                }
              }
            }

            if (set !== null) {
              var bEntries = arrayFromMap(b)

              for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
                var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
                  key = _bEntries$_i[0],
                  item = _bEntries$_i[1]

                if (_typeof(key) === 'object' && key !== null) {
                  if (!mapHasEqualEntry(set, a, key, item, strict, memo))
                    return false
                } else if (
                  !strict &&
                  (!a.has(key) ||
                    !innerDeepEqual(a.get(key), item, false, memo)) &&
                  !mapHasEqualEntry(set, a, key, item, false, memo)
                ) {
                  return false
                }
              }

              return set.size === 0
            }

            return true
          }

          function objEquiv(a, b, strict, keys, memos, iterationType) {
            // Sets and maps don't have their entries accessible via normal object
            // properties.
            var i = 0

            if (iterationType === kIsSet) {
              if (!setEquiv(a, b, strict, memos)) {
                return false
              }
            } else if (iterationType === kIsMap) {
              if (!mapEquiv(a, b, strict, memos)) {
                return false
              }
            } else if (iterationType === kIsArray) {
              for (; i < a.length; i++) {
                if (hasOwnProperty(a, i)) {
                  if (
                    !hasOwnProperty(b, i) ||
                    !innerDeepEqual(a[i], b[i], strict, memos)
                  ) {
                    return false
                  }
                } else if (hasOwnProperty(b, i)) {
                  return false
                } else {
                  // Array is sparse.
                  var keysA = Object.keys(a)

                  for (; i < keysA.length; i++) {
                    var key = keysA[i]

                    if (
                      !hasOwnProperty(b, key) ||
                      !innerDeepEqual(a[key], b[key], strict, memos)
                    ) {
                      return false
                    }
                  }

                  if (keysA.length !== Object.keys(b).length) {
                    return false
                  }

                  return true
                }
              }
            } // The pair must have equivalent values for every corresponding key.
            // Possibly expensive deep test:

            for (i = 0; i < keys.length; i++) {
              var _key = keys[i]

              if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                return false
              }
            }

            return true
          }

          function isDeepEqual(val1, val2) {
            return innerDeepEqual(val1, val2, kLoose)
          }

          function isDeepStrictEqual(val1, val2) {
            return innerDeepEqual(val1, val2, kStrict)
          }

          module.exports = {
            isDeepEqual: isDeepEqual,
            isDeepStrictEqual: isDeepStrictEqual,
          }

          /***/
        },

      /***/ './node_modules/available-typed-arrays/index.js':
        /*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_103145__) => {
          'use strict'

          var filter = __nested_webpack_require_103145__(
            /*! array-filter */ './node_modules/array-filter/index.js'
          )

          module.exports = function availableTypedArrays() {
            return filter(
              [
                'BigInt64Array',
                'BigUint64Array',
                'Float32Array',
                'Float64Array',
                'Int16Array',
                'Int32Array',
                'Int8Array',
                'Uint16Array',
                'Uint32Array',
                'Uint8Array',
                'Uint8ClampedArray',
              ],
              function (typedArray) {
                return typeof __nested_webpack_require_103145__.g[typedArray] === 'function'
              }
            )
          }

          /***/
        },

      /***/ './node_modules/axios/index.js':
        /*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_104211__) => {
          module.exports = __nested_webpack_require_104211__(
            /*! ./lib/axios */ './node_modules/axios/lib/axios.js'
          )

          /***/
        },

      /***/ './node_modules/axios/lib/adapters/xhr.js':
        /*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_104667__) => {
          'use strict'

          var utils = __nested_webpack_require_104667__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )
          var settle = __nested_webpack_require_104667__(
            /*! ./../core/settle */ './node_modules/axios/lib/core/settle.js'
          )
          var cookies = __nested_webpack_require_104667__(
            /*! ./../helpers/cookies */ './node_modules/axios/lib/helpers/cookies.js'
          )
          var buildURL = __nested_webpack_require_104667__(
            /*! ./../helpers/buildURL */ './node_modules/axios/lib/helpers/buildURL.js'
          )
          var buildFullPath = __nested_webpack_require_104667__(
            /*! ../core/buildFullPath */ './node_modules/axios/lib/core/buildFullPath.js'
          )
          var parseHeaders = __nested_webpack_require_104667__(
            /*! ./../helpers/parseHeaders */ './node_modules/axios/lib/helpers/parseHeaders.js'
          )
          var isURLSameOrigin = __nested_webpack_require_104667__(
            /*! ./../helpers/isURLSameOrigin */ './node_modules/axios/lib/helpers/isURLSameOrigin.js'
          )
          var createError = __nested_webpack_require_104667__(
            /*! ../core/createError */ './node_modules/axios/lib/core/createError.js'
          )

          module.exports = function xhrAdapter(config) {
            return new Promise(function dispatchXhrRequest(resolve, reject) {
              var requestData = config.data
              var requestHeaders = config.headers

              if (utils.isFormData(requestData)) {
                delete requestHeaders['Content-Type'] // Let the browser set it
              }

              var request = new XMLHttpRequest()

              // HTTP basic authentication
              if (config.auth) {
                var username = config.auth.username || ''
                var password = config.auth.password
                  ? unescape(encodeURIComponent(config.auth.password))
                  : ''
                requestHeaders.Authorization =
                  'Basic ' + btoa(username + ':' + password)
              }

              var fullPath = buildFullPath(config.baseURL, config.url)
              request.open(
                config.method.toUpperCase(),
                buildURL(fullPath, config.params, config.paramsSerializer),
                true
              )

              // Set the request timeout in MS
              request.timeout = config.timeout

              // Listen for ready state
              request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                  return
                }

                // The request errored out and we didn't get a response, this will be
                // handled by onerror instead
                // With one exception: request that using file: protocol, most browsers
                // will return status as 0 even though it's a successful request
                if (
                  request.status === 0 &&
                  !(
                    request.responseURL &&
                    request.responseURL.indexOf('file:') === 0
                  )
                ) {
                  return
                }

                // Prepare the response
                var responseHeaders =
                  'getAllResponseHeaders' in request
                    ? parseHeaders(request.getAllResponseHeaders())
                    : null
                var responseData =
                  !config.responseType || config.responseType === 'text'
                    ? request.responseText
                    : request.response
                var response = {
                  data: responseData,
                  status: request.status,
                  statusText: request.statusText,
                  headers: responseHeaders,
                  config: config,
                  request: request,
                }

                settle(resolve, reject, response)

                // Clean up request
                request = null
              }

              // Handle browser request cancellation (as opposed to a manual cancellation)
              request.onabort = function handleAbort() {
                if (!request) {
                  return
                }

                reject(
                  createError(
                    'Request aborted',
                    config,
                    'ECONNABORTED',
                    request
                  )
                )

                // Clean up request
                request = null
              }

              // Handle low level network errors
              request.onerror = function handleError() {
                // Real errors are hidden from us by the browser
                // onerror should only fire if it's a network error
                reject(createError('Network Error', config, null, request))

                // Clean up request
                request = null
              }

              // Handle timeout
              request.ontimeout = function handleTimeout() {
                var timeoutErrorMessage =
                  'timeout of ' + config.timeout + 'ms exceeded'
                if (config.timeoutErrorMessage) {
                  timeoutErrorMessage = config.timeoutErrorMessage
                }
                reject(
                  createError(
                    timeoutErrorMessage,
                    config,
                    'ECONNABORTED',
                    request
                  )
                )

                // Clean up request
                request = null
              }

              // Add xsrf header
              // This is only done if running in a standard browser environment.
              // Specifically not if we're in a web worker, or react-native.
              if (utils.isStandardBrowserEnv()) {
                // Add xsrf header
                var xsrfValue =
                  (config.withCredentials || isURLSameOrigin(fullPath)) &&
                  config.xsrfCookieName
                    ? cookies.read(config.xsrfCookieName)
                    : undefined

                if (xsrfValue) {
                  requestHeaders[config.xsrfHeaderName] = xsrfValue
                }
              }

              // Add headers to the request
              if ('setRequestHeader' in request) {
                utils.forEach(
                  requestHeaders,
                  function setRequestHeader(val, key) {
                    if (
                      typeof requestData === 'undefined' &&
                      key.toLowerCase() === 'content-type'
                    ) {
                      // Remove Content-Type if data is undefined
                      delete requestHeaders[key]
                    } else {
                      // Otherwise add header to the request
                      request.setRequestHeader(key, val)
                    }
                  }
                )
              }

              // Add withCredentials to request if needed
              if (!utils.isUndefined(config.withCredentials)) {
                request.withCredentials = !!config.withCredentials
              }

              // Add responseType to request if needed
              if (config.responseType) {
                try {
                  request.responseType = config.responseType
                } catch (e) {
                  // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
                  // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
                  if (config.responseType !== 'json') {
                    throw e
                  }
                }
              }

              // Handle progress if needed
              if (typeof config.onDownloadProgress === 'function') {
                request.addEventListener('progress', config.onDownloadProgress)
              }

              // Not all browsers support upload events
              if (
                typeof config.onUploadProgress === 'function' &&
                request.upload
              ) {
                request.upload.addEventListener(
                  'progress',
                  config.onUploadProgress
                )
              }

              if (config.cancelToken) {
                // Handle cancellation
                config.cancelToken.promise.then(function onCanceled(cancel) {
                  if (!request) {
                    return
                  }

                  request.abort()
                  reject(cancel)
                  // Clean up request
                  request = null
                })
              }

              if (!requestData) {
                requestData = null
              }

              // Send the request
              request.send(requestData)
            })
          }

          /***/
        },

      /***/ './node_modules/axios/lib/axios.js':
        /*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_113868__) => {
          'use strict'

          var utils = __nested_webpack_require_113868__(
            /*! ./utils */ './node_modules/axios/lib/utils.js'
          )
          var bind = __nested_webpack_require_113868__(
            /*! ./helpers/bind */ './node_modules/axios/lib/helpers/bind.js'
          )
          var Axios = __nested_webpack_require_113868__(
            /*! ./core/Axios */ './node_modules/axios/lib/core/Axios.js'
          )
          var mergeConfig = __nested_webpack_require_113868__(
            /*! ./core/mergeConfig */ './node_modules/axios/lib/core/mergeConfig.js'
          )
          var defaults = __nested_webpack_require_113868__(
            /*! ./defaults */ './node_modules/axios/lib/defaults.js'
          )

          /**
           * Create an instance of Axios
           *
           * @param {Object} defaultConfig The default config for the instance
           * @return {Axios} A new instance of Axios
           */
          function createInstance(defaultConfig) {
            var context = new Axios(defaultConfig)
            var instance = bind(Axios.prototype.request, context)

            // Copy axios.prototype to instance
            utils.extend(instance, Axios.prototype, context)

            // Copy context to instance
            utils.extend(instance, context)

            return instance
          }

          // Create the default instance to be exported
          var axios = createInstance(defaults)

          // Expose Axios class to allow class inheritance
          axios.Axios = Axios

          // Factory for creating new instances
          axios.create = function create(instanceConfig) {
            return createInstance(mergeConfig(axios.defaults, instanceConfig))
          }

          // Expose Cancel & CancelToken
          axios.Cancel = __nested_webpack_require_113868__(
            /*! ./cancel/Cancel */ './node_modules/axios/lib/cancel/Cancel.js'
          )
          axios.CancelToken = __nested_webpack_require_113868__(
            /*! ./cancel/CancelToken */ './node_modules/axios/lib/cancel/CancelToken.js'
          )
          axios.isCancel = __nested_webpack_require_113868__(
            /*! ./cancel/isCancel */ './node_modules/axios/lib/cancel/isCancel.js'
          )

          // Expose all/spread
          axios.all = function all(promises) {
            return Promise.all(promises)
          }
          axios.spread = __nested_webpack_require_113868__(
            /*! ./helpers/spread */ './node_modules/axios/lib/helpers/spread.js'
          )

          // Expose isAxiosError
          axios.isAxiosError = __nested_webpack_require_113868__(
            /*! ./helpers/isAxiosError */ './node_modules/axios/lib/helpers/isAxiosError.js'
          )

          module.exports = axios

          // Allow use of default import syntax in TypeScript
          module.exports.default = axios

          /***/
        },

      /***/ './node_modules/axios/lib/cancel/Cancel.js':
        /*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * A `Cancel` is an object that is thrown when an operation is canceled.
           *
           * @class
           * @param {string=} message The message.
           */
          function Cancel(message) {
            this.message = message
          }

          Cancel.prototype.toString = function toString() {
            return 'Cancel' + (this.message ? ': ' + this.message : '')
          }

          Cancel.prototype.__CANCEL__ = true

          module.exports = Cancel

          /***/
        },

      /***/ './node_modules/axios/lib/cancel/CancelToken.js':
        /*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_117796__) => {
          'use strict'

          var Cancel = __nested_webpack_require_117796__(
            /*! ./Cancel */ './node_modules/axios/lib/cancel/Cancel.js'
          )

          /**
           * A `CancelToken` is an object that can be used to request cancellation of an operation.
           *
           * @class
           * @param {Function} executor The executor function.
           */
          function CancelToken(executor) {
            if (typeof executor !== 'function') {
              throw new TypeError('executor must be a function.')
            }

            var resolvePromise
            this.promise = new Promise(function promiseExecutor(resolve) {
              resolvePromise = resolve
            })

            var token = this
            executor(function cancel(message) {
              if (token.reason) {
                // Cancellation has already been requested
                return
              }

              token.reason = new Cancel(message)
              resolvePromise(token.reason)
            })
          }

          /**
           * Throws a `Cancel` if cancellation has been requested.
           */
          CancelToken.prototype.throwIfRequested = function throwIfRequested() {
            if (this.reason) {
              throw this.reason
            }
          }

          /**
           * Returns an object that contains a new `CancelToken` and a function that, when called,
           * cancels the `CancelToken`.
           */
          CancelToken.source = function source() {
            var cancel
            var token = new CancelToken(function executor(c) {
              cancel = c
            })
            return {
              token: token,
              cancel: cancel,
            }
          }

          module.exports = CancelToken

          /***/
        },

      /***/ './node_modules/axios/lib/cancel/isCancel.js':
        /*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
        /***/ (module) => {
          'use strict'

          module.exports = function isCancel(value) {
            return !!(value && value.__CANCEL__)
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/Axios.js':
        /*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_120347__) => {
          'use strict'

          var utils = __nested_webpack_require_120347__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )
          var buildURL = __nested_webpack_require_120347__(
            /*! ../helpers/buildURL */ './node_modules/axios/lib/helpers/buildURL.js'
          )
          var InterceptorManager = __nested_webpack_require_120347__(
            /*! ./InterceptorManager */ './node_modules/axios/lib/core/InterceptorManager.js'
          )
          var dispatchRequest = __nested_webpack_require_120347__(
            /*! ./dispatchRequest */ './node_modules/axios/lib/core/dispatchRequest.js'
          )
          var mergeConfig = __nested_webpack_require_120347__(
            /*! ./mergeConfig */ './node_modules/axios/lib/core/mergeConfig.js'
          )

          /**
           * Create a new instance of Axios
           *
           * @param {Object} instanceConfig The default config for the instance
           */
          function Axios(instanceConfig) {
            this.defaults = instanceConfig
            this.interceptors = {
              request: new InterceptorManager(),
              response: new InterceptorManager(),
            }
          }

          /**
           * Dispatch a request
           *
           * @param {Object} config The config specific for this request (merged with this.defaults)
           */
          Axios.prototype.request = function request(config) {
            /*eslint no-param-reassign:0*/
            // Allow for axios('example/url'[, config]) a la fetch API
            if (typeof config === 'string') {
              config = arguments[1] || {}
              config.url = arguments[0]
            } else {
              config = config || {}
            }

            config = mergeConfig(this.defaults, config)

            // Set config.method
            if (config.method) {
              config.method = config.method.toLowerCase()
            } else if (this.defaults.method) {
              config.method = this.defaults.method.toLowerCase()
            } else {
              config.method = 'get'
            }

            // Hook up interceptors middleware
            var chain = [dispatchRequest, undefined]
            var promise = Promise.resolve(config)

            this.interceptors.request.forEach(
              function unshiftRequestInterceptors(interceptor) {
                chain.unshift(interceptor.fulfilled, interceptor.rejected)
              }
            )

            this.interceptors.response.forEach(
              function pushResponseInterceptors(interceptor) {
                chain.push(interceptor.fulfilled, interceptor.rejected)
              }
            )

            while (chain.length) {
              promise = promise.then(chain.shift(), chain.shift())
            }

            return promise
          }

          Axios.prototype.getUri = function getUri(config) {
            config = mergeConfig(this.defaults, config)
            return buildURL(
              config.url,
              config.params,
              config.paramsSerializer
            ).replace(/^\?/, '')
          }

          // Provide aliases for supported request methods
          utils.forEach(
            ['delete', 'get', 'head', 'options'],
            function forEachMethodNoData(method) {
              /*eslint func-names:0*/
              Axios.prototype[method] = function (url, config) {
                return this.request(
                  mergeConfig(config || {}, {
                    method: method,
                    url: url,
                    data: (config || {}).data,
                  })
                )
              }
            }
          )

          utils.forEach(
            ['post', 'put', 'patch'],
            function forEachMethodWithData(method) {
              /*eslint func-names:0*/
              Axios.prototype[method] = function (url, data, config) {
                return this.request(
                  mergeConfig(config || {}, {
                    method: method,
                    url: url,
                    data: data,
                  })
                )
              }
            }
          )

          module.exports = Axios

          /***/
        },

      /***/ './node_modules/axios/lib/core/InterceptorManager.js':
        /*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_124905__) => {
          'use strict'

          var utils = __nested_webpack_require_124905__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          function InterceptorManager() {
            this.handlers = []
          }

          /**
           * Add a new interceptor to the stack
           *
           * @param {Function} fulfilled The function to handle `then` for a `Promise`
           * @param {Function} rejected The function to handle `reject` for a `Promise`
           *
           * @return {Number} An ID used to remove interceptor later
           */
          InterceptorManager.prototype.use = function use(fulfilled, rejected) {
            this.handlers.push({
              fulfilled: fulfilled,
              rejected: rejected,
            })
            return this.handlers.length - 1
          }

          /**
           * Remove an interceptor from the stack
           *
           * @param {Number} id The ID that was returned by `use`
           */
          InterceptorManager.prototype.eject = function eject(id) {
            if (this.handlers[id]) {
              this.handlers[id] = null
            }
          }

          /**
           * Iterate over all the registered interceptors
           *
           * This method is particularly useful for skipping over any
           * interceptors that may have become `null` calling `eject`.
           *
           * @param {Function} fn The function to call for each interceptor
           */
          InterceptorManager.prototype.forEach = function forEach(fn) {
            utils.forEach(this.handlers, function forEachHandler(h) {
              if (h !== null) {
                fn(h)
              }
            })
          }

          module.exports = InterceptorManager

          /***/
        },

      /***/ './node_modules/axios/lib/core/buildFullPath.js':
        /*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_127035__) => {
          'use strict'

          var isAbsoluteURL = __nested_webpack_require_127035__(
            /*! ../helpers/isAbsoluteURL */ './node_modules/axios/lib/helpers/isAbsoluteURL.js'
          )
          var combineURLs = __nested_webpack_require_127035__(
            /*! ../helpers/combineURLs */ './node_modules/axios/lib/helpers/combineURLs.js'
          )

          /**
           * Creates a new URL by combining the baseURL with the requestedURL,
           * only when the requestedURL is not already an absolute URL.
           * If the requestURL is absolute, this function returns the requestedURL untouched.
           *
           * @param {string} baseURL The base URL
           * @param {string} requestedURL Absolute or relative URL to combine
           * @returns {string} The combined full path
           */
          module.exports = function buildFullPath(baseURL, requestedURL) {
            if (baseURL && !isAbsoluteURL(requestedURL)) {
              return combineURLs(baseURL, requestedURL)
            }
            return requestedURL
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/createError.js':
        /*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_128433__) => {
          'use strict'

          var enhanceError = __nested_webpack_require_128433__(
            /*! ./enhanceError */ './node_modules/axios/lib/core/enhanceError.js'
          )

          /**
           * Create an Error with the specified message, config, error code, request and response.
           *
           * @param {string} message The error message.
           * @param {Object} config The config.
           * @param {string} [code] The error code (for example, 'ECONNABORTED').
           * @param {Object} [request] The request.
           * @param {Object} [response] The response.
           * @returns {Error} The created error.
           */
          module.exports = function createError(
            message,
            config,
            code,
            request,
            response
          ) {
            var error = new Error(message)
            return enhanceError(error, config, code, request, response)
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/dispatchRequest.js':
        /*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_129735__) => {
          'use strict'

          var utils = __nested_webpack_require_129735__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )
          var transformData = __nested_webpack_require_129735__(
            /*! ./transformData */ './node_modules/axios/lib/core/transformData.js'
          )
          var isCancel = __nested_webpack_require_129735__(
            /*! ../cancel/isCancel */ './node_modules/axios/lib/cancel/isCancel.js'
          )
          var defaults = __nested_webpack_require_129735__(
            /*! ../defaults */ './node_modules/axios/lib/defaults.js'
          )

          /**
           * Throws a `Cancel` if cancellation has been requested.
           */
          function throwIfCancellationRequested(config) {
            if (config.cancelToken) {
              config.cancelToken.throwIfRequested()
            }
          }

          /**
           * Dispatch a request to the server using the configured adapter.
           *
           * @param {object} config The config that is to be used for the request
           * @returns {Promise} The Promise to be fulfilled
           */
          module.exports = function dispatchRequest(config) {
            throwIfCancellationRequested(config)

            // Ensure headers exist
            config.headers = config.headers || {}

            // Transform request data
            config.data = transformData(
              config.data,
              config.headers,
              config.transformRequest
            )

            // Flatten headers
            config.headers = utils.merge(
              config.headers.common || {},
              config.headers[config.method] || {},
              config.headers
            )

            utils.forEach(
              ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
              function cleanHeaderConfig(method) {
                delete config.headers[method]
              }
            )

            var adapter = config.adapter || defaults.adapter

            return adapter(config).then(
              function onAdapterResolution(response) {
                throwIfCancellationRequested(config)

                // Transform response data
                response.data = transformData(
                  response.data,
                  response.headers,
                  config.transformResponse
                )

                return response
              },
              function onAdapterRejection(reason) {
                if (!isCancel(reason)) {
                  throwIfCancellationRequested(config)

                  // Transform response data
                  if (reason && reason.response) {
                    reason.response.data = transformData(
                      reason.response.data,
                      reason.response.headers,
                      config.transformResponse
                    )
                  }
                }

                return Promise.reject(reason)
              }
            )
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/enhanceError.js':
        /*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Update an Error with the specified config, error code, and response.
           *
           * @param {Error} error The error to update.
           * @param {Object} config The config.
           * @param {string} [code] The error code (for example, 'ECONNABORTED').
           * @param {Object} [request] The request.
           * @param {Object} [response] The response.
           * @returns {Error} The error.
           */
          module.exports = function enhanceError(
            error,
            config,
            code,
            request,
            response
          ) {
            error.config = config
            if (code) {
              error.code = code
            }

            error.request = request
            error.response = response
            error.isAxiosError = true

            error.toJSON = function toJSON() {
              return {
                // Standard
                message: this.message,
                name: this.name,
                // Microsoft
                description: this.description,
                number: this.number,
                // Mozilla
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                // Axios
                config: this.config,
                code: this.code,
              }
            }
            return error
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/mergeConfig.js':
        /*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_134877__) => {
          'use strict'

          var utils = __nested_webpack_require_134877__(
            /*! ../utils */ './node_modules/axios/lib/utils.js'
          )

          /**
           * Config-specific merge-function which creates a new config-object
           * by merging two configuration objects together.
           *
           * @param {Object} config1
           * @param {Object} config2
           * @returns {Object} New object resulting from merging config2 to config1
           */
          module.exports = function mergeConfig(config1, config2) {
            // eslint-disable-next-line no-param-reassign
            config2 = config2 || {}
            var config = {}

            var valueFromConfig2Keys = ['url', 'method', 'data']
            var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params']
            var defaultToConfig2Keys = [
              'baseURL',
              'transformRequest',
              'transformResponse',
              'paramsSerializer',
              'timeout',
              'timeoutMessage',
              'withCredentials',
              'adapter',
              'responseType',
              'xsrfCookieName',
              'xsrfHeaderName',
              'onUploadProgress',
              'onDownloadProgress',
              'decompress',
              'maxContentLength',
              'maxBodyLength',
              'maxRedirects',
              'transport',
              'httpAgent',
              'httpsAgent',
              'cancelToken',
              'socketPath',
              'responseEncoding',
            ]
            var directMergeKeys = ['validateStatus']

            function getMergedValue(target, source) {
              if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
                return utils.merge(target, source)
              } else if (utils.isPlainObject(source)) {
                return utils.merge({}, source)
              } else if (utils.isArray(source)) {
                return source.slice()
              }
              return source
            }

            function mergeDeepProperties(prop) {
              if (!utils.isUndefined(config2[prop])) {
                config[prop] = getMergedValue(config1[prop], config2[prop])
              } else if (!utils.isUndefined(config1[prop])) {
                config[prop] = getMergedValue(undefined, config1[prop])
              }
            }

            utils.forEach(
              valueFromConfig2Keys,
              function valueFromConfig2(prop) {
                if (!utils.isUndefined(config2[prop])) {
                  config[prop] = getMergedValue(undefined, config2[prop])
                }
              }
            )

            utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties)

            utils.forEach(
              defaultToConfig2Keys,
              function defaultToConfig2(prop) {
                if (!utils.isUndefined(config2[prop])) {
                  config[prop] = getMergedValue(undefined, config2[prop])
                } else if (!utils.isUndefined(config1[prop])) {
                  config[prop] = getMergedValue(undefined, config1[prop])
                }
              }
            )

            utils.forEach(directMergeKeys, function merge(prop) {
              if (prop in config2) {
                config[prop] = getMergedValue(config1[prop], config2[prop])
              } else if (prop in config1) {
                config[prop] = getMergedValue(undefined, config1[prop])
              }
            })

            var axiosKeys = valueFromConfig2Keys
              .concat(mergeDeepPropertiesKeys)
              .concat(defaultToConfig2Keys)
              .concat(directMergeKeys)

            var otherKeys = Object.keys(config1)
              .concat(Object.keys(config2))
              .filter(function filterAxiosKeys(key) {
                return axiosKeys.indexOf(key) === -1
              })

            utils.forEach(otherKeys, mergeDeepProperties)

            return config
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/settle.js':
        /*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_139227__) => {
          'use strict'

          var createError = __nested_webpack_require_139227__(
            /*! ./createError */ './node_modules/axios/lib/core/createError.js'
          )

          /**
           * Resolve or reject a Promise based on response status.
           *
           * @param {Function} resolve A function that resolves the promise.
           * @param {Function} reject A function that rejects the promise.
           * @param {object} response The response.
           */
          module.exports = function settle(resolve, reject, response) {
            var validateStatus = response.config.validateStatus
            if (
              !response.status ||
              !validateStatus ||
              validateStatus(response.status)
            ) {
              resolve(response)
            } else {
              reject(
                createError(
                  'Request failed with status code ' + response.status,
                  response.config,
                  null,
                  response.request,
                  response
                )
              )
            }
          }

          /***/
        },

      /***/ './node_modules/axios/lib/core/transformData.js':
        /*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_140698__) => {
          'use strict'

          var utils = __nested_webpack_require_140698__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          /**
           * Transform the data for a request or a response
           *
           * @param {Object|String} data The data to be transformed
           * @param {Array} headers The headers for the request or response
           * @param {Array|Function} fns A single function or Array of functions
           * @returns {*} The resulting transformed data
           */
          module.exports = function transformData(data, headers, fns) {
            /*eslint no-param-reassign:0*/
            utils.forEach(fns, function transform(fn) {
              data = fn(data, headers)
            })

            return data
          }

          /***/
        },

      /***/ './node_modules/axios/lib/defaults.js':
        /*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_141802__) => {
          'use strict'
          /* provided dependency */ var process = __nested_webpack_require_141802__(
            /*! process/browser */ './node_modules/process/browser.js'
          )

          var utils = __nested_webpack_require_141802__(
            /*! ./utils */ './node_modules/axios/lib/utils.js'
          )
          var normalizeHeaderName = __nested_webpack_require_141802__(
            /*! ./helpers/normalizeHeaderName */ './node_modules/axios/lib/helpers/normalizeHeaderName.js'
          )

          var DEFAULT_CONTENT_TYPE = {
            'Content-Type': 'application/x-www-form-urlencoded',
          }

          function setContentTypeIfUnset(headers, value) {
            if (
              !utils.isUndefined(headers) &&
              utils.isUndefined(headers['Content-Type'])
            ) {
              headers['Content-Type'] = value
            }
          }

          function getDefaultAdapter() {
            var adapter
            if (typeof XMLHttpRequest !== 'undefined') {
              // For browsers use XHR adapter
              adapter = __nested_webpack_require_141802__(
                /*! ./adapters/xhr */ './node_modules/axios/lib/adapters/xhr.js'
              )
            } else if (
              typeof process !== 'undefined' &&
              Object.prototype.toString.call(process) === '[object process]'
            ) {
              // For node use HTTP adapter
              adapter = __nested_webpack_require_141802__(
                /*! ./adapters/http */ './node_modules/axios/lib/adapters/xhr.js'
              )
            }
            return adapter
          }

          var defaults = {
            adapter: getDefaultAdapter(),

            transformRequest: [
              function transformRequest(data, headers) {
                normalizeHeaderName(headers, 'Accept')
                normalizeHeaderName(headers, 'Content-Type')
                if (
                  utils.isFormData(data) ||
                  utils.isArrayBuffer(data) ||
                  utils.isBuffer(data) ||
                  utils.isStream(data) ||
                  utils.isFile(data) ||
                  utils.isBlob(data)
                ) {
                  return data
                }
                if (utils.isArrayBufferView(data)) {
                  return data.buffer
                }
                if (utils.isURLSearchParams(data)) {
                  setContentTypeIfUnset(
                    headers,
                    'application/x-www-form-urlencoded;charset=utf-8'
                  )
                  return data.toString()
                }
                if (utils.isObject(data)) {
                  setContentTypeIfUnset(
                    headers,
                    'application/json;charset=utf-8'
                  )
                  return JSON.stringify(data)
                }
                return data
              },
            ],

            transformResponse: [
              function transformResponse(data) {
                /*eslint no-param-reassign:0*/
                if (typeof data === 'string') {
                  try {
                    data = JSON.parse(data)
                  } catch (e) {
                    /* Ignore */
                  }
                }
                return data
              },
            ],

            /**
             * A timeout in milliseconds to abort a request. If set to 0 (default) a
             * timeout is not created.
             */
            timeout: 0,

            xsrfCookieName: 'XSRF-TOKEN',
            xsrfHeaderName: 'X-XSRF-TOKEN',

            maxContentLength: -1,
            maxBodyLength: -1,

            validateStatus: function validateStatus(status) {
              return status >= 200 && status < 300
            },
          }

          defaults.headers = {
            common: {
              Accept: 'application/json, text/plain, */*',
            },
          }

          utils.forEach(
            ['delete', 'get', 'head'],
            function forEachMethodNoData(method) {
              defaults.headers[method] = {}
            }
          )

          utils.forEach(
            ['post', 'put', 'patch'],
            function forEachMethodWithData(method) {
              defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE)
            }
          )

          module.exports = defaults

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/bind.js':
        /*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
        /***/ (module) => {
          'use strict'

          module.exports = function bind(fn, thisArg) {
            return function wrap() {
              var args = new Array(arguments.length)
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i]
              }
              return fn.apply(thisArg, args)
            }
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/buildURL.js':
        /*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_147123__) => {
          'use strict'

          var utils = __nested_webpack_require_147123__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          function encode(val) {
            return encodeURIComponent(val)
              .replace(/%3A/gi, ':')
              .replace(/%24/g, '$')
              .replace(/%2C/gi, ',')
              .replace(/%20/g, '+')
              .replace(/%5B/gi, '[')
              .replace(/%5D/gi, ']')
          }

          /**
           * Build a URL by appending params to the end
           *
           * @param {string} url The base of the url (e.g., http://www.google.com)
           * @param {object} [params] The params to be appended
           * @returns {string} The formatted url
           */
          module.exports = function buildURL(url, params, paramsSerializer) {
            /*eslint no-param-reassign:0*/
            if (!params) {
              return url
            }

            var serializedParams
            if (paramsSerializer) {
              serializedParams = paramsSerializer(params)
            } else if (utils.isURLSearchParams(params)) {
              serializedParams = params.toString()
            } else {
              var parts = []

              utils.forEach(params, function serialize(val, key) {
                if (val === null || typeof val === 'undefined') {
                  return
                }

                if (utils.isArray(val)) {
                  key = key + '[]'
                } else {
                  val = [val]
                }

                utils.forEach(val, function parseValue(v) {
                  if (utils.isDate(v)) {
                    v = v.toISOString()
                  } else if (utils.isObject(v)) {
                    v = JSON.stringify(v)
                  }
                  parts.push(encode(key) + '=' + encode(v))
                })
              })

              serializedParams = parts.join('&')
            }

            if (serializedParams) {
              var hashmarkIndex = url.indexOf('#')
              if (hashmarkIndex !== -1) {
                url = url.slice(0, hashmarkIndex)
              }

              url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams
            }

            return url
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/combineURLs.js':
        /*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Creates a new URL by combining the specified URLs
           *
           * @param {string} baseURL The base URL
           * @param {string} relativeURL The relative URL
           * @returns {string} The combined URL
           */
          module.exports = function combineURLs(baseURL, relativeURL) {
            return relativeURL
              ? baseURL.replace(/\/+$/, '') +
                  '/' +
                  relativeURL.replace(/^\/+/, '')
              : baseURL
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/cookies.js':
        /*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_150606__) => {
          'use strict'

          var utils = __nested_webpack_require_150606__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          module.exports = utils.isStandardBrowserEnv()
            ? // Standard browser envs support document.cookie
              (function standardBrowserEnv() {
                return {
                  write: function write(
                    name,
                    value,
                    expires,
                    path,
                    domain,
                    secure
                  ) {
                    var cookie = []
                    cookie.push(name + '=' + encodeURIComponent(value))

                    if (utils.isNumber(expires)) {
                      cookie.push('expires=' + new Date(expires).toGMTString())
                    }

                    if (utils.isString(path)) {
                      cookie.push('path=' + path)
                    }

                    if (utils.isString(domain)) {
                      cookie.push('domain=' + domain)
                    }

                    if (secure === true) {
                      cookie.push('secure')
                    }

                    document.cookie = cookie.join('; ')
                  },

                  read: function read(name) {
                    var match = document.cookie.match(
                      new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')
                    )
                    return match ? decodeURIComponent(match[3]) : null
                  },

                  remove: function remove(name) {
                    this.write(name, '', Date.now() - 86400000)
                  },
                }
              })()
            : // Non standard browser env (web workers, react-native) lack needed support.
              (function nonStandardBrowserEnv() {
                return {
                  write: function write() {},
                  read: function read() {
                    return null
                  },
                  remove: function remove() {},
                }
              })()

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/isAbsoluteURL.js':
        /*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Determines whether the specified URL is absolute
           *
           * @param {string} url The URL to test
           * @returns {boolean} True if the specified URL is absolute, otherwise false
           */
          module.exports = function isAbsoluteURL(url) {
            // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
            // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
            // by any combination of letters, digits, plus, period, or hyphen.
            return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/isAxiosError.js':
        /*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Determines whether the payload is an error thrown by Axios
           *
           * @param {*} payload The value to test
           * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
           */
          module.exports = function isAxiosError(payload) {
            return typeof payload === 'object' && payload.isAxiosError === true
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/isURLSameOrigin.js':
        /*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_154847__) => {
          'use strict'

          var utils = __nested_webpack_require_154847__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          module.exports = utils.isStandardBrowserEnv()
            ? // Standard browser envs have full support of the APIs needed to test
              // whether the request URL is of the same origin as current location.
              (function standardBrowserEnv() {
                var msie = /(msie|trident)/i.test(navigator.userAgent)
                var urlParsingNode = document.createElement('a')
                var originURL

                /**
                 * Parse a URL to discover it's components
                 *
                 * @param {String} url The URL to be parsed
                 * @returns {Object}
                 */
                function resolveURL(url) {
                  var href = url

                  if (msie) {
                    // IE needs attribute set twice to normalize properties
                    urlParsingNode.setAttribute('href', href)
                    href = urlParsingNode.href
                  }

                  urlParsingNode.setAttribute('href', href)

                  // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
                  return {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol
                      ? urlParsingNode.protocol.replace(/:$/, '')
                      : '',
                    host: urlParsingNode.host,
                    search: urlParsingNode.search
                      ? urlParsingNode.search.replace(/^\?/, '')
                      : '',
                    hash: urlParsingNode.hash
                      ? urlParsingNode.hash.replace(/^#/, '')
                      : '',
                    hostname: urlParsingNode.hostname,
                    port: urlParsingNode.port,
                    pathname:
                      urlParsingNode.pathname.charAt(0) === '/'
                        ? urlParsingNode.pathname
                        : '/' + urlParsingNode.pathname,
                  }
                }

                originURL = resolveURL(window.location.href)

                /**
                 * Determine if a URL shares the same origin as the current location
                 *
                 * @param {String} requestURL The URL to test
                 * @returns {boolean} True if URL shares the same origin, otherwise false
                 */
                return function isURLSameOrigin(requestURL) {
                  var parsed = utils.isString(requestURL)
                    ? resolveURL(requestURL)
                    : requestURL
                  return (
                    parsed.protocol === originURL.protocol &&
                    parsed.host === originURL.host
                  )
                }
              })()
            : // Non standard browser envs (web workers, react-native) lack needed support.
              (function nonStandardBrowserEnv() {
                return function isURLSameOrigin() {
                  return true
                }
              })()

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/normalizeHeaderName.js':
        /*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_158420__) => {
          'use strict'

          var utils = __nested_webpack_require_158420__(
            /*! ../utils */ './node_modules/axios/lib/utils.js'
          )

          module.exports = function normalizeHeaderName(
            headers,
            normalizedName
          ) {
            utils.forEach(headers, function processHeader(value, name) {
              if (
                name !== normalizedName &&
                name.toUpperCase() === normalizedName.toUpperCase()
              ) {
                headers[normalizedName] = value
                delete headers[name]
              }
            })
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/parseHeaders.js':
        /*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_159393__) => {
          'use strict'

          var utils = __nested_webpack_require_159393__(
            /*! ./../utils */ './node_modules/axios/lib/utils.js'
          )

          // Headers whose duplicates are ignored by node
          // c.f. https://nodejs.org/api/http.html#http_message_headers
          var ignoreDuplicateOf = [
            'age',
            'authorization',
            'content-length',
            'content-type',
            'etag',
            'expires',
            'from',
            'host',
            'if-modified-since',
            'if-unmodified-since',
            'last-modified',
            'location',
            'max-forwards',
            'proxy-authorization',
            'referer',
            'retry-after',
            'user-agent',
          ]

          /**
           * Parse headers into an object
           *
           * ```
           * Date: Wed, 27 Aug 2014 08:58:49 GMT
           * Content-Type: application/json
           * Connection: keep-alive
           * Transfer-Encoding: chunked
           * ```
           *
           * @param {String} headers Headers needing to be parsed
           * @returns {Object} Headers parsed into an object
           */
          module.exports = function parseHeaders(headers) {
            var parsed = {}
            var key
            var val
            var i

            if (!headers) {
              return parsed
            }

            utils.forEach(headers.split('\n'), function parser(line) {
              i = line.indexOf(':')
              key = utils.trim(line.substr(0, i)).toLowerCase()
              val = utils.trim(line.substr(i + 1))

              if (key) {
                if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                  return
                }
                if (key === 'set-cookie') {
                  parsed[key] = (parsed[key] ? parsed[key] : []).concat([val])
                } else {
                  parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val
                }
              }
            })

            return parsed
          }

          /***/
        },

      /***/ './node_modules/axios/lib/helpers/spread.js':
        /*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
        /***/ (module) => {
          'use strict'

          /**
           * Syntactic sugar for invoking a function and expanding an array for arguments.
           *
           * Common use case would be to use `Function.prototype.apply`.
           *
           *  ```js
           *  function f(x, y, z) {}
           *  var args = [1, 2, 3];
           *  f.apply(null, args);
           *  ```
           *
           * With `spread` this example can be re-written.
           *
           *  ```js
           *  spread(function(x, y, z) {})([1, 2, 3]);
           *  ```
           *
           * @param {Function} callback
           * @returns {Function}
           */
          module.exports = function spread(callback) {
            return function wrap(arr) {
              return callback.apply(null, arr)
            }
          }

          /***/
        },

      /***/ './node_modules/axios/lib/utils.js':
        /*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_162900__) => {
          'use strict'

          var bind = __nested_webpack_require_162900__(
            /*! ./helpers/bind */ './node_modules/axios/lib/helpers/bind.js'
          )

          /*global toString:true*/

          // utils is a library of generic helper functions non-specific to axios

          var toString = Object.prototype.toString

          /**
           * Determine if a value is an Array
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an Array, otherwise false
           */
          function isArray(val) {
            return toString.call(val) === '[object Array]'
          }

          /**
           * Determine if a value is undefined
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if the value is undefined, otherwise false
           */
          function isUndefined(val) {
            return typeof val === 'undefined'
          }

          /**
           * Determine if a value is a Buffer
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Buffer, otherwise false
           */
          function isBuffer(val) {
            return (
              val !== null &&
              !isUndefined(val) &&
              val.constructor !== null &&
              !isUndefined(val.constructor) &&
              typeof val.constructor.isBuffer === 'function' &&
              val.constructor.isBuffer(val)
            )
          }

          /**
           * Determine if a value is an ArrayBuffer
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an ArrayBuffer, otherwise false
           */
          function isArrayBuffer(val) {
            return toString.call(val) === '[object ArrayBuffer]'
          }

          /**
           * Determine if a value is a FormData
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an FormData, otherwise false
           */
          function isFormData(val) {
            return typeof FormData !== 'undefined' && val instanceof FormData
          }

          /**
           * Determine if a value is a view on an ArrayBuffer
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
           */
          function isArrayBufferView(val) {
            var result
            if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
              result = ArrayBuffer.isView(val)
            } else {
              result = val && val.buffer && val.buffer instanceof ArrayBuffer
            }
            return result
          }

          /**
           * Determine if a value is a String
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a String, otherwise false
           */
          function isString(val) {
            return typeof val === 'string'
          }

          /**
           * Determine if a value is a Number
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Number, otherwise false
           */
          function isNumber(val) {
            return typeof val === 'number'
          }

          /**
           * Determine if a value is an Object
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is an Object, otherwise false
           */
          function isObject(val) {
            return val !== null && typeof val === 'object'
          }

          /**
           * Determine if a value is a plain Object
           *
           * @param {Object} val The value to test
           * @return {boolean} True if value is a plain Object, otherwise false
           */
          function isPlainObject(val) {
            if (toString.call(val) !== '[object Object]') {
              return false
            }

            var prototype = Object.getPrototypeOf(val)
            return prototype === null || prototype === Object.prototype
          }

          /**
           * Determine if a value is a Date
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Date, otherwise false
           */
          function isDate(val) {
            return toString.call(val) === '[object Date]'
          }

          /**
           * Determine if a value is a File
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a File, otherwise false
           */
          function isFile(val) {
            return toString.call(val) === '[object File]'
          }

          /**
           * Determine if a value is a Blob
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Blob, otherwise false
           */
          function isBlob(val) {
            return toString.call(val) === '[object Blob]'
          }

          /**
           * Determine if a value is a Function
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Function, otherwise false
           */
          function isFunction(val) {
            return toString.call(val) === '[object Function]'
          }

          /**
           * Determine if a value is a Stream
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a Stream, otherwise false
           */
          function isStream(val) {
            return isObject(val) && isFunction(val.pipe)
          }

          /**
           * Determine if a value is a URLSearchParams object
           *
           * @param {Object} val The value to test
           * @returns {boolean} True if value is a URLSearchParams object, otherwise false
           */
          function isURLSearchParams(val) {
            return (
              typeof URLSearchParams !== 'undefined' &&
              val instanceof URLSearchParams
            )
          }

          /**
           * Trim excess whitespace off the beginning and end of a string
           *
           * @param {String} str The String to trim
           * @returns {String} The String freed of excess whitespace
           */
          function trim(str) {
            return str.replace(/^\s*/, '').replace(/\s*$/, '')
          }

          /**
           * Determine if we're running in a standard browser environment
           *
           * This allows axios to run in a web worker, and react-native.
           * Both environments support XMLHttpRequest, but not fully standard globals.
           *
           * web workers:
           *  typeof window -> undefined
           *  typeof document -> undefined
           *
           * react-native:
           *  navigator.product -> 'ReactNative'
           * nativescript
           *  navigator.product -> 'NativeScript' or 'NS'
           */
          function isStandardBrowserEnv() {
            if (
              typeof navigator !== 'undefined' &&
              (navigator.product === 'ReactNative' ||
                navigator.product === 'NativeScript' ||
                navigator.product === 'NS')
            ) {
              return false
            }
            return (
              typeof window !== 'undefined' && typeof document !== 'undefined'
            )
          }

          /**
           * Iterate over an Array or an Object invoking a function for each item.
           *
           * If `obj` is an Array callback will be called passing
           * the value, index, and complete array for each item.
           *
           * If 'obj' is an Object callback will be called passing
           * the value, key, and complete object for each property.
           *
           * @param {Object|Array} obj The object to iterate
           * @param {Function} fn The callback to invoke for each item
           */
          function forEach(obj, fn) {
            // Don't bother if no value provided
            if (obj === null || typeof obj === 'undefined') {
              return
            }

            // Force an array if not already something iterable
            if (typeof obj !== 'object') {
              /*eslint no-param-reassign:0*/
              obj = [obj]
            }

            if (isArray(obj)) {
              // Iterate over array values
              for (var i = 0, l = obj.length; i < l; i++) {
                fn.call(null, obj[i], i, obj)
              }
            } else {
              // Iterate over object keys
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  fn.call(null, obj[key], key, obj)
                }
              }
            }
          }

          /**
           * Accepts varargs expecting each argument to be an object, then
           * immutably merges the properties of each object and returns result.
           *
           * When multiple objects contain the same key the later object in
           * the arguments list will take precedence.
           *
           * Example:
           *
           * ```js
           * var result = merge({foo: 123}, {foo: 456});
           * console.log(result.foo); // outputs 456
           * ```
           *
           * @param {Object} obj1 Object to merge
           * @returns {Object} Result of all merge properties
           */
          function merge(/* obj1, obj2, obj3, ... */) {
            var result = {}
            function assignValue(val, key) {
              if (isPlainObject(result[key]) && isPlainObject(val)) {
                result[key] = merge(result[key], val)
              } else if (isPlainObject(val)) {
                result[key] = merge({}, val)
              } else if (isArray(val)) {
                result[key] = val.slice()
              } else {
                result[key] = val
              }
            }

            for (var i = 0, l = arguments.length; i < l; i++) {
              forEach(arguments[i], assignValue)
            }
            return result
          }

          /**
           * Extends object a by mutably adding to it the properties of object b.
           *
           * @param {Object} a The object to be extended
           * @param {Object} b The object to copy properties from
           * @param {Object} thisArg The object to bind function to
           * @return {Object} The resulting value of object a
           */
          function extend(a, b, thisArg) {
            forEach(b, function assignValue(val, key) {
              if (thisArg && typeof val === 'function') {
                a[key] = bind(val, thisArg)
              } else {
                a[key] = val
              }
            })
            return a
          }

          /**
           * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
           *
           * @param {string} content with BOM
           * @return {string} content value without BOM
           */
          function stripBOM(content) {
            if (content.charCodeAt(0) === 0xfeff) {
              content = content.slice(1)
            }
            return content
          }

          module.exports = {
            isArray: isArray,
            isArrayBuffer: isArrayBuffer,
            isBuffer: isBuffer,
            isFormData: isFormData,
            isArrayBufferView: isArrayBufferView,
            isString: isString,
            isNumber: isNumber,
            isObject: isObject,
            isPlainObject: isPlainObject,
            isUndefined: isUndefined,
            isDate: isDate,
            isFile: isFile,
            isBlob: isBlob,
            isFunction: isFunction,
            isStream: isStream,
            isURLSearchParams: isURLSearchParams,
            isStandardBrowserEnv: isStandardBrowserEnv,
            forEach: forEach,
            merge: merge,
            extend: extend,
            trim: trim,
            stripBOM: stripBOM,
          }

          /***/
        },

      /***/ './node_modules/call-bind/callBound.js':
        /*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_175474__) => {
          'use strict'

          var GetIntrinsic = __nested_webpack_require_175474__(
            /*! get-intrinsic */ './node_modules/get-intrinsic/index.js'
          )

          var callBind = __nested_webpack_require_175474__(
            /*! ./ */ './node_modules/call-bind/index.js'
          )

          var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'))

          module.exports = function callBoundIntrinsic(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing)
            if (
              typeof intrinsic === 'function' &&
              $indexOf(name, '.prototype.') > -1
            ) {
              return callBind(intrinsic)
            }
            return intrinsic
          }

          /***/
        },

      /***/ './node_modules/call-bind/index.js':
        /*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_176496__) => {
          'use strict'

          var bind = __nested_webpack_require_176496__(
            /*! function-bind */ './node_modules/function-bind/index.js'
          )
          var GetIntrinsic = __nested_webpack_require_176496__(
            /*! get-intrinsic */ './node_modules/get-intrinsic/index.js'
          )

          var $apply = GetIntrinsic('%Function.prototype.apply%')
          var $call = GetIntrinsic('%Function.prototype.call%')
          var $reflectApply =
            GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply)

          var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true)
          var $defineProperty = GetIntrinsic('%Object.defineProperty%', true)
          var $max = GetIntrinsic('%Math.max%')

          if ($defineProperty) {
            try {
              $defineProperty({}, 'a', { value: 1 })
            } catch (e) {
              // IE 8 has a broken defineProperty
              $defineProperty = null
            }
          }

          module.exports = function callBind(originalFunction) {
            var func = $reflectApply(bind, $call, arguments)
            if ($gOPD && $defineProperty) {
              var desc = $gOPD(func, 'length')
              if (desc.configurable) {
                // original length, plus the receiver, minus any additional arguments (after the receiver)
                $defineProperty(func, 'length', {
                  value:
                    1 +
                    $max(0, originalFunction.length - (arguments.length - 1)),
                })
              }
            }
            return func
          }

          var applyBind = function applyBind() {
            return $reflectApply(bind, $apply, arguments)
          }

          if ($defineProperty) {
            $defineProperty(module.exports, 'apply', { value: applyBind })
          } else {
            module.exports.apply = applyBind
          }

          /***/
        },

      /***/ './node_modules/console-browserify/index.js':
        /*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_178739__) => {
          /*global window, global*/
          var util = __nested_webpack_require_178739__(
            /*! util */ './node_modules/util/util.js'
          )
          var assert = __nested_webpack_require_178739__(
            /*! assert */ './node_modules/assert/build/assert.js'
          )
          function now() {
            return new Date().getTime()
          }

          var slice = Array.prototype.slice
          var console
          var times = {}

          if (
            typeof __nested_webpack_require_178739__.g !== 'undefined' &&
            __nested_webpack_require_178739__.g.console
          ) {
            console = __nested_webpack_require_178739__.g.console
          } else if (typeof window !== 'undefined' && window.console) {
            console = window.console
          } else {
            console = {}
          }

          var functions = [
            [log, 'log'],
            [info, 'info'],
            [warn, 'warn'],
            [error, 'error'],
            [time, 'time'],
            [timeEnd, 'timeEnd'],
            [trace, 'trace'],
            [dir, 'dir'],
            [consoleAssert, 'assert'],
          ]

          for (var i = 0; i < functions.length; i++) {
            var tuple = functions[i]
            var f = tuple[0]
            var name = tuple[1]

            if (!console[name]) {
              console[name] = f
            }
          }

          module.exports = console

          function log() {}

          function info() {
            console.log.apply(console, arguments)
          }

          function warn() {
            console.log.apply(console, arguments)
          }

          function error() {
            console.warn.apply(console, arguments)
          }

          function time(label) {
            times[label] = now()
          }

          function timeEnd(label) {
            var time = times[label]
            if (!time) {
              throw new Error('No such label: ' + label)
            }

            delete times[label]
            var duration = now() - time
            console.log(label + ': ' + duration + 'ms')
          }

          function trace() {
            var err = new Error()
            err.name = 'Trace'
            err.message = util.format.apply(null, arguments)
            console.error(err.stack)
          }

          function dir(object) {
            console.log(util.inspect(object) + '\n')
          }

          function consoleAssert(expression) {
            if (!expression) {
              var arr = slice.call(arguments, 1)
              assert.ok(false, util.format.apply(null, arr))
            }
          }

          /***/
        },

      /***/ './node_modules/define-properties/index.js':
        /*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_181663__) => {
          'use strict'

          var keys = __nested_webpack_require_181663__(
            /*! object-keys */ './node_modules/object-keys/index.js'
          )
          var hasSymbols =
            typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol'

          var toStr = Object.prototype.toString
          var concat = Array.prototype.concat
          var origDefineProperty = Object.defineProperty

          var isFunction = function (fn) {
            return (
              typeof fn === 'function' && toStr.call(fn) === '[object Function]'
            )
          }

          var arePropertyDescriptorsSupported = function () {
            var obj = {}
            try {
              origDefineProperty(obj, 'x', { enumerable: false, value: obj })
              // eslint-disable-next-line no-unused-vars, no-restricted-syntax
              for (var _ in obj) {
                // jscs:ignore disallowUnusedVariables
                return false
              }
              return obj.x === obj
            } catch (e) {
              /* this is IE 8. */
              return false
            }
          }
          var supportsDescriptors =
            origDefineProperty && arePropertyDescriptorsSupported()

          var defineProperty = function (object, name, value, predicate) {
            if (name in object && (!isFunction(predicate) || !predicate())) {
              return
            }
            if (supportsDescriptors) {
              origDefineProperty(object, name, {
                configurable: true,
                enumerable: false,
                value: value,
                writable: true,
              })
            } else {
              object[name] = value
            }
          }

          var defineProperties = function (object, map) {
            var predicates = arguments.length > 2 ? arguments[2] : {}
            var props = keys(map)
            if (hasSymbols) {
              props = concat.call(props, Object.getOwnPropertySymbols(map))
            }
            for (var i = 0; i < props.length; i += 1) {
              defineProperty(
                object,
                props[i],
                map[props[i]],
                predicates[props[i]]
              )
            }
          }

          defineProperties.supportsDescriptors = !!supportsDescriptors

          module.exports = defineProperties

          /***/
        },

      /***/ './node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js':
        /*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_184461__) => {
          'use strict'

          var GetIntrinsic = __nested_webpack_require_184461__(
            /*! get-intrinsic */ './node_modules/get-intrinsic/index.js'
          )

          var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%')
          if ($gOPD) {
            try {
              $gOPD([], 'length')
            } catch (e) {
              // IE 8 has a broken gOPD
              $gOPD = null
            }
          }

          module.exports = $gOPD

          /***/
        },

      /***/ './node_modules/es6-object-assign/index.js':
        /*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
        /***/ (module) => {
          'use strict'
          /**
           * Code refactored from Mozilla Developer Network:
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
           */

          function assign(target, firstSource) {
            if (target === undefined || target === null) {
              throw new TypeError('Cannot convert first argument to object')
            }

            var to = Object(target)
            for (var i = 1; i < arguments.length; i++) {
              var nextSource = arguments[i]
              if (nextSource === undefined || nextSource === null) {
                continue
              }

              var keysArray = Object.keys(Object(nextSource))
              for (
                var nextIndex = 0, len = keysArray.length;
                nextIndex < len;
                nextIndex++
              ) {
                var nextKey = keysArray[nextIndex]
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey)
                if (desc !== undefined && desc.enumerable) {
                  to[nextKey] = nextSource[nextKey]
                }
              }
            }
            return to
          }

          function polyfill() {
            if (!Object.assign) {
              Object.defineProperty(Object, 'assign', {
                enumerable: false,
                configurable: true,
                writable: true,
                value: assign,
              })
            }
          }

          module.exports = {
            assign: assign,
            polyfill: polyfill,
          }

          /***/
        },

      /***/ './node_modules/events/events.js':
        /*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_187117__) => {
          'use strict'
          /* provided dependency */ var console = __nested_webpack_require_187117__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var R = typeof Reflect === 'object' ? Reflect : null
          var ReflectApply =
            R && typeof R.apply === 'function'
              ? R.apply
              : function ReflectApply(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args)
                }

          var ReflectOwnKeys
          if (R && typeof R.ownKeys === 'function') {
            ReflectOwnKeys = R.ownKeys
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target).concat(
                Object.getOwnPropertySymbols(target)
              )
            }
          } else {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target)
            }
          }

          function ProcessEmitWarning(warning) {
            if (console && console.warn) console.warn(warning)
          }

          var NumberIsNaN =
            Number.isNaN ||
            function NumberIsNaN(value) {
              return value !== value
            }

          function EventEmitter() {
            EventEmitter.init.call(this)
          }
          module.exports = EventEmitter
          module.exports.once = once

          // Backwards-compat with node 0.10.x
          EventEmitter.EventEmitter = EventEmitter

          EventEmitter.prototype._events = undefined
          EventEmitter.prototype._eventsCount = 0
          EventEmitter.prototype._maxListeners = undefined

          // By default EventEmitters will print a warning if more than 10 listeners are
          // added to it. This is a useful default which helps finding memory leaks.
          var defaultMaxListeners = 10

          function checkListener(listener) {
            if (typeof listener !== 'function') {
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof listener
              )
            }
          }

          Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
            enumerable: true,
            get: function () {
              return defaultMaxListeners
            },
            set: function (arg) {
              if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError(
                  'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                    arg +
                    '.'
                )
              }
              defaultMaxListeners = arg
            },
          })

          EventEmitter.init = function () {
            if (
              this._events === undefined ||
              this._events === Object.getPrototypeOf(this)._events
            ) {
              this._events = Object.create(null)
              this._eventsCount = 0
            }

            this._maxListeners = this._maxListeners || undefined
          }

          // Obviously not all Emitters should be limited to 10. This function allows
          // that to be increased. Set to zero for unlimited.
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
              throw new RangeError(
                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                  n +
                  '.'
              )
            }
            this._maxListeners = n
            return this
          }

          function _getMaxListeners(that) {
            if (that._maxListeners === undefined)
              return EventEmitter.defaultMaxListeners
            return that._maxListeners
          }

          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this)
          }

          EventEmitter.prototype.emit = function emit(type) {
            var args = []
            for (var i = 1; i < arguments.length; i++) args.push(arguments[i])
            var doError = type === 'error'

            var events = this._events
            if (events !== undefined)
              doError = doError && events.error === undefined
            else if (!doError) return false

            // If there is no 'error' event listener then throw.
            if (doError) {
              var er
              if (args.length > 0) er = args[0]
              if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er // Unhandled 'error' event
              }
              // At least give some kind of context to the user
              var err = new Error(
                'Unhandled error.' + (er ? ' (' + er.message + ')' : '')
              )
              err.context = er
              throw err // Unhandled 'error' event
            }

            var handler = events[type]

            if (handler === undefined) return false

            if (typeof handler === 'function') {
              ReflectApply(handler, this, args)
            } else {
              var len = handler.length
              var listeners = arrayClone(handler, len)
              for (var i = 0; i < len; ++i)
                ReflectApply(listeners[i], this, args)
            }

            return true
          }

          function _addListener(target, type, listener, prepend) {
            var m
            var events
            var existing

            checkListener(listener)

            events = target._events
            if (events === undefined) {
              events = target._events = Object.create(null)
              target._eventsCount = 0
            } else {
              // To avoid recursion in the case that type === "newListener"! Before
              // adding it to the listeners, first emit "newListener".
              if (events.newListener !== undefined) {
                target.emit(
                  'newListener',
                  type,
                  listener.listener ? listener.listener : listener
                )

                // Re-assign `events` because a newListener handler could have caused the
                // this._events to be assigned to a new object
                events = target._events
              }
              existing = events[type]
            }

            if (existing === undefined) {
              // Optimize the case of one listener. Don't need the extra array object.
              existing = events[type] = listener
              ++target._eventsCount
            } else {
              if (typeof existing === 'function') {
                // Adding the second element, need to change to array.
                existing = events[type] = prepend
                  ? [listener, existing]
                  : [existing, listener]
                // If we've already got an array, just append.
              } else if (prepend) {
                existing.unshift(listener)
              } else {
                existing.push(listener)
              }

              // Check for listener leak
              m = _getMaxListeners(target)
              if (m > 0 && existing.length > m && !existing.warned) {
                existing.warned = true
                // No error code for this since it is a Warning
                // eslint-disable-next-line no-restricted-syntax
                var w = new Error(
                  'Possible EventEmitter memory leak detected. ' +
                    existing.length +
                    ' ' +
                    String(type) +
                    ' listeners ' +
                    'added. Use emitter.setMaxListeners() to ' +
                    'increase limit'
                )
                w.name = 'MaxListenersExceededWarning'
                w.emitter = target
                w.type = type
                w.count = existing.length
                ProcessEmitWarning(w)
              }
            }

            return target
          }

          EventEmitter.prototype.addListener = function addListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, false)
          }

          EventEmitter.prototype.on = EventEmitter.prototype.addListener

          EventEmitter.prototype.prependListener = function prependListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, true)
          }

          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn)
              this.fired = true
              if (arguments.length === 0) return this.listener.call(this.target)
              return this.listener.apply(this.target, arguments)
            }
          }

          function _onceWrap(target, type, listener) {
            var state = {
              fired: false,
              wrapFn: undefined,
              target: target,
              type: type,
              listener: listener,
            }
            var wrapped = onceWrapper.bind(state)
            wrapped.listener = listener
            state.wrapFn = wrapped
            return wrapped
          }

          EventEmitter.prototype.once = function once(type, listener) {
            checkListener(listener)
            this.on(type, _onceWrap(this, type, listener))
            return this
          }

          EventEmitter.prototype.prependOnceListener = function prependOnceListener(
            type,
            listener
          ) {
            checkListener(listener)
            this.prependListener(type, _onceWrap(this, type, listener))
            return this
          }

          // Emits a 'removeListener' event if and only if the listener was removed.
          EventEmitter.prototype.removeListener = function removeListener(
            type,
            listener
          ) {
            var list, events, position, i, originalListener

            checkListener(listener)

            events = this._events
            if (events === undefined) return this

            list = events[type]
            if (list === undefined) return this

            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0) this._events = Object.create(null)
              else {
                delete events[type]
                if (events.removeListener)
                  this.emit('removeListener', type, list.listener || listener)
              }
            } else if (typeof list !== 'function') {
              position = -1

              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener
                  position = i
                  break
                }
              }

              if (position < 0) return this

              if (position === 0) list.shift()
              else {
                spliceOne(list, position)
              }

              if (list.length === 1) events[type] = list[0]

              if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener)
            }

            return this
          }

          EventEmitter.prototype.off = EventEmitter.prototype.removeListener

          EventEmitter.prototype.removeAllListeners = function removeAllListeners(
            type
          ) {
            var listeners, events, i

            events = this._events
            if (events === undefined) return this

            // not listening for removeListener, no need to emit
            if (events.removeListener === undefined) {
              if (arguments.length === 0) {
                this._events = Object.create(null)
                this._eventsCount = 0
              } else if (events[type] !== undefined) {
                if (--this._eventsCount === 0)
                  this._events = Object.create(null)
                else delete events[type]
              }
              return this
            }

            // emit removeListener for all listeners on all events
            if (arguments.length === 0) {
              var keys = Object.keys(events)
              var key
              for (i = 0; i < keys.length; ++i) {
                key = keys[i]
                if (key === 'removeListener') continue
                this.removeAllListeners(key)
              }
              this.removeAllListeners('removeListener')
              this._events = Object.create(null)
              this._eventsCount = 0
              return this
            }

            listeners = events[type]

            if (typeof listeners === 'function') {
              this.removeListener(type, listeners)
            } else if (listeners !== undefined) {
              // LIFO order
              for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i])
              }
            }

            return this
          }

          function _listeners(target, type, unwrap) {
            var events = target._events

            if (events === undefined) return []

            var evlistener = events[type]
            if (evlistener === undefined) return []

            if (typeof evlistener === 'function')
              return unwrap ? [evlistener.listener || evlistener] : [evlistener]

            return unwrap
              ? unwrapListeners(evlistener)
              : arrayClone(evlistener, evlistener.length)
          }

          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true)
          }

          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false)
          }

          EventEmitter.listenerCount = function (emitter, type) {
            if (typeof emitter.listenerCount === 'function') {
              return emitter.listenerCount(type)
            } else {
              return listenerCount.call(emitter, type)
            }
          }

          EventEmitter.prototype.listenerCount = listenerCount
          function listenerCount(type) {
            var events = this._events

            if (events !== undefined) {
              var evlistener = events[type]

              if (typeof evlistener === 'function') {
                return 1
              } else if (evlistener !== undefined) {
                return evlistener.length
              }
            }

            return 0
          }

          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
          }

          function arrayClone(arr, n) {
            var copy = new Array(n)
            for (var i = 0; i < n; ++i) copy[i] = arr[i]
            return copy
          }

          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++)
              list[index] = list[index + 1]
            list.pop()
          }

          function unwrapListeners(arr) {
            var ret = new Array(arr.length)
            for (var i = 0; i < ret.length; ++i) {
              ret[i] = arr[i].listener || arr[i]
            }
            return ret
          }

          function once(emitter, name) {
            return new Promise(function (resolve, reject) {
              function errorListener(err) {
                emitter.removeListener(name, resolver)
                reject(err)
              }

              function resolver() {
                if (typeof emitter.removeListener === 'function') {
                  emitter.removeListener('error', errorListener)
                }
                resolve([].slice.call(arguments))
              }

              eventTargetAgnosticAddListener(emitter, name, resolver, {
                once: true,
              })
              if (name !== 'error') {
                addErrorHandlerIfEventEmitter(emitter, errorListener, {
                  once: true,
                })
              }
            })
          }

          function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
            if (typeof emitter.on === 'function') {
              eventTargetAgnosticAddListener(emitter, 'error', handler, flags)
            }
          }

          function eventTargetAgnosticAddListener(
            emitter,
            name,
            listener,
            flags
          ) {
            if (typeof emitter.on === 'function') {
              if (flags.once) {
                emitter.once(name, listener)
              } else {
                emitter.on(name, listener)
              }
            } else if (typeof emitter.addEventListener === 'function') {
              // EventTarget does not have `error` event semantics like Node
              // EventEmitters, we do not listen for `error` events here.
              emitter.addEventListener(name, function wrapListener(arg) {
                // IE does not have builtin `{ once: true }` support so we
                // have to do it manually.
                if (flags.once) {
                  emitter.removeEventListener(name, wrapListener)
                }
                listener(arg)
              })
            } else {
              throw new TypeError(
                'The "emitter" argument must be of type EventEmitter. Received type ' +
                  typeof emitter
              )
            }
          }

          /***/
        },

      /***/ './node_modules/foreach/index.js':
        /*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
        /***/ (module) => {
          var hasOwn = Object.prototype.hasOwnProperty
          var toString = Object.prototype.toString

          module.exports = function forEach(obj, fn, ctx) {
            if (toString.call(fn) !== '[object Function]') {
              throw new TypeError('iterator must be a function')
            }
            var l = obj.length
            if (l === +l) {
              for (var i = 0; i < l; i++) {
                fn.call(ctx, obj[i], i, obj)
              }
            } else {
              for (var k in obj) {
                if (hasOwn.call(obj, k)) {
                  fn.call(ctx, obj[k], k, obj)
                }
              }
            }
          }

          /***/
        },

      /***/ './node_modules/form-data/lib/browser.js':
        /*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
        /***/ (module) => {
          /* eslint-env browser */
          module.exports =
            typeof self == 'object' ? self.FormData : window.FormData

          /***/
        },

      /***/ './node_modules/function-bind/implementation.js':
        /*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
        /***/ (module) => {
          'use strict'

          /* eslint no-invalid-this: 1 */

          var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible '
          var slice = Array.prototype.slice
          var toStr = Object.prototype.toString
          var funcType = '[object Function]'

          module.exports = function bind(that) {
            var target = this
            if (
              typeof target !== 'function' ||
              toStr.call(target) !== funcType
            ) {
              throw new TypeError(ERROR_MESSAGE + target)
            }
            var args = slice.call(arguments, 1)

            var bound
            var binder = function () {
              if (this instanceof bound) {
                var result = target.apply(
                  this,
                  args.concat(slice.call(arguments))
                )
                if (Object(result) === result) {
                  return result
                }
                return this
              } else {
                return target.apply(that, args.concat(slice.call(arguments)))
              }
            }

            var boundLength = Math.max(0, target.length - args.length)
            var boundArgs = []
            for (var i = 0; i < boundLength; i++) {
              boundArgs.push('$' + i)
            }

            bound = Function(
              'binder',
              'return function (' +
                boundArgs.join(',') +
                '){ return binder.apply(this,arguments); }'
            )(binder)

            if (target.prototype) {
              var Empty = function Empty() {}
              Empty.prototype = target.prototype
              bound.prototype = new Empty()
              Empty.prototype = null
            }

            return bound
          }

          /***/
        },

      /***/ './node_modules/function-bind/index.js':
        /*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_210165__) => {
          'use strict'

          var implementation = __nested_webpack_require_210165__(
            /*! ./implementation */ './node_modules/function-bind/implementation.js'
          )

          module.exports = Function.prototype.bind || implementation

          /***/
        },

      /***/ './node_modules/get-intrinsic/index.js':
        /*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_210725__) => {
          'use strict'

          var undefined

          var $SyntaxError = SyntaxError
          var $Function = Function
          var $TypeError = TypeError

          // eslint-disable-next-line consistent-return
          var getEvalledConstructor = function (expressionSyntax) {
            try {
              return $Function(
                '"use strict"; return (' + expressionSyntax + ').constructor;'
              )()
            } catch (e) {}
          }

          var $gOPD = Object.getOwnPropertyDescriptor
          if ($gOPD) {
            try {
              $gOPD({}, '')
            } catch (e) {
              $gOPD = null // this is IE 8, which has a broken gOPD
            }
          }

          var throwTypeError = function () {
            throw new $TypeError()
          }
          var ThrowTypeError = $gOPD
            ? (function () {
                try {
                  // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                  arguments.callee // IE 8 does not throw here
                  return throwTypeError
                } catch (calleeThrows) {
                  try {
                    // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                    return $gOPD(arguments, 'callee').get
                  } catch (gOPDthrows) {
                    return throwTypeError
                  }
                }
              })()
            : throwTypeError

          var hasSymbols = __nested_webpack_require_210725__(
            /*! has-symbols */ './node_modules/has-symbols/index.js'
          )()

          var getProto =
            Object.getPrototypeOf ||
            function (x) {
              return x.__proto__
            } // eslint-disable-line no-proto

          var needsEval = {}

          var TypedArray =
            typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array)

          var INTRINSICS = {
            '%AggregateError%':
              typeof AggregateError === 'undefined'
                ? undefined
                : AggregateError,
            '%Array%': Array,
            '%ArrayBuffer%':
              typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
            '%ArrayIteratorPrototype%': hasSymbols
              ? getProto([][Symbol.iterator]())
              : undefined,
            '%AsyncFromSyncIteratorPrototype%': undefined,
            '%AsyncFunction%': needsEval,
            '%AsyncGenerator%': needsEval,
            '%AsyncGeneratorFunction%': needsEval,
            '%AsyncIteratorPrototype%': needsEval,
            '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
            '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
            '%Boolean%': Boolean,
            '%DataView%':
              typeof DataView === 'undefined' ? undefined : DataView,
            '%Date%': Date,
            '%decodeURI%': decodeURI,
            '%decodeURIComponent%': decodeURIComponent,
            '%encodeURI%': encodeURI,
            '%encodeURIComponent%': encodeURIComponent,
            '%Error%': Error,
            '%eval%': eval, // eslint-disable-line no-eval
            '%EvalError%': EvalError,
            '%Float32Array%':
              typeof Float32Array === 'undefined' ? undefined : Float32Array,
            '%Float64Array%':
              typeof Float64Array === 'undefined' ? undefined : Float64Array,
            '%FinalizationRegistry%':
              typeof FinalizationRegistry === 'undefined'
                ? undefined
                : FinalizationRegistry,
            '%Function%': $Function,
            '%GeneratorFunction%': needsEval,
            '%Int8Array%':
              typeof Int8Array === 'undefined' ? undefined : Int8Array,
            '%Int16Array%':
              typeof Int16Array === 'undefined' ? undefined : Int16Array,
            '%Int32Array%':
              typeof Int32Array === 'undefined' ? undefined : Int32Array,
            '%isFinite%': isFinite,
            '%isNaN%': isNaN,
            '%IteratorPrototype%': hasSymbols
              ? getProto(getProto([][Symbol.iterator]()))
              : undefined,
            '%JSON%': typeof JSON === 'object' ? JSON : undefined,
            '%Map%': typeof Map === 'undefined' ? undefined : Map,
            '%MapIteratorPrototype%':
              typeof Map === 'undefined' || !hasSymbols
                ? undefined
                : getProto(new Map()[Symbol.iterator]()),
            '%Math%': Math,
            '%Number%': Number,
            '%Object%': Object,
            '%parseFloat%': parseFloat,
            '%parseInt%': parseInt,
            '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
            '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
            '%RangeError%': RangeError,
            '%ReferenceError%': ReferenceError,
            '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
            '%RegExp%': RegExp,
            '%Set%': typeof Set === 'undefined' ? undefined : Set,
            '%SetIteratorPrototype%':
              typeof Set === 'undefined' || !hasSymbols
                ? undefined
                : getProto(new Set()[Symbol.iterator]()),
            '%SharedArrayBuffer%':
              typeof SharedArrayBuffer === 'undefined'
                ? undefined
                : SharedArrayBuffer,
            '%String%': String,
            '%StringIteratorPrototype%': hasSymbols
              ? getProto(''[Symbol.iterator]())
              : undefined,
            '%Symbol%': hasSymbols ? Symbol : undefined,
            '%SyntaxError%': $SyntaxError,
            '%ThrowTypeError%': ThrowTypeError,
            '%TypedArray%': TypedArray,
            '%TypeError%': $TypeError,
            '%Uint8Array%':
              typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
            '%Uint8ClampedArray%':
              typeof Uint8ClampedArray === 'undefined'
                ? undefined
                : Uint8ClampedArray,
            '%Uint16Array%':
              typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
            '%Uint32Array%':
              typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
            '%URIError%': URIError,
            '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
            '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
            '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
          }

          var doEval = function doEval(name) {
            var value
            if (name === '%AsyncFunction%') {
              value = getEvalledConstructor('async function () {}')
            } else if (name === '%GeneratorFunction%') {
              value = getEvalledConstructor('function* () {}')
            } else if (name === '%AsyncGeneratorFunction%') {
              value = getEvalledConstructor('async function* () {}')
            } else if (name === '%AsyncGenerator%') {
              var fn = doEval('%AsyncGeneratorFunction%')
              if (fn) {
                value = fn.prototype
              }
            } else if (name === '%AsyncIteratorPrototype%') {
              var gen = doEval('%AsyncGenerator%')
              if (gen) {
                value = getProto(gen.prototype)
              }
            }

            INTRINSICS[name] = value

            return value
          }

          var LEGACY_ALIASES = {
            '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
            '%ArrayPrototype%': ['Array', 'prototype'],
            '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
            '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
            '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
            '%ArrayProto_values%': ['Array', 'prototype', 'values'],
            '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
            '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
            '%AsyncGeneratorPrototype%': [
              'AsyncGeneratorFunction',
              'prototype',
              'prototype',
            ],
            '%BooleanPrototype%': ['Boolean', 'prototype'],
            '%DataViewPrototype%': ['DataView', 'prototype'],
            '%DatePrototype%': ['Date', 'prototype'],
            '%ErrorPrototype%': ['Error', 'prototype'],
            '%EvalErrorPrototype%': ['EvalError', 'prototype'],
            '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
            '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
            '%FunctionPrototype%': ['Function', 'prototype'],
            '%Generator%': ['GeneratorFunction', 'prototype'],
            '%GeneratorPrototype%': [
              'GeneratorFunction',
              'prototype',
              'prototype',
            ],
            '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
            '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
            '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
            '%JSONParse%': ['JSON', 'parse'],
            '%JSONStringify%': ['JSON', 'stringify'],
            '%MapPrototype%': ['Map', 'prototype'],
            '%NumberPrototype%': ['Number', 'prototype'],
            '%ObjectPrototype%': ['Object', 'prototype'],
            '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
            '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
            '%PromisePrototype%': ['Promise', 'prototype'],
            '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
            '%Promise_all%': ['Promise', 'all'],
            '%Promise_reject%': ['Promise', 'reject'],
            '%Promise_resolve%': ['Promise', 'resolve'],
            '%RangeErrorPrototype%': ['RangeError', 'prototype'],
            '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
            '%RegExpPrototype%': ['RegExp', 'prototype'],
            '%SetPrototype%': ['Set', 'prototype'],
            '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
            '%StringPrototype%': ['String', 'prototype'],
            '%SymbolPrototype%': ['Symbol', 'prototype'],
            '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
            '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
            '%TypeErrorPrototype%': ['TypeError', 'prototype'],
            '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
            '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
            '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
            '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
            '%URIErrorPrototype%': ['URIError', 'prototype'],
            '%WeakMapPrototype%': ['WeakMap', 'prototype'],
            '%WeakSetPrototype%': ['WeakSet', 'prototype'],
          }

          var bind = __nested_webpack_require_210725__(
            /*! function-bind */ './node_modules/function-bind/index.js'
          )
          var hasOwn = __nested_webpack_require_210725__(
            /*! has */ './node_modules/has/src/index.js'
          )
          var $concat = bind.call(Function.call, Array.prototype.concat)
          var $spliceApply = bind.call(Function.apply, Array.prototype.splice)
          var $replace = bind.call(Function.call, String.prototype.replace)
          var $strSlice = bind.call(Function.call, String.prototype.slice)

          /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
          var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
          var reEscapeChar = /\\(\\)?/g /** Used to match backslashes in property paths. */
          var stringToPath = function stringToPath(string) {
            var first = $strSlice(string, 0, 1)
            var last = $strSlice(string, -1)
            if (first === '%' && last !== '%') {
              throw new $SyntaxError(
                'invalid intrinsic syntax, expected closing `%`'
              )
            } else if (last === '%' && first !== '%') {
              throw new $SyntaxError(
                'invalid intrinsic syntax, expected opening `%`'
              )
            }
            var result = []
            $replace(
              string,
              rePropName,
              function (match, number, quote, subString) {
                result[result.length] = quote
                  ? $replace(subString, reEscapeChar, '$1')
                  : number || match
              }
            )
            return result
          }
          /* end adaptation */

          var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
            var intrinsicName = name
            var alias
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
              alias = LEGACY_ALIASES[intrinsicName]
              intrinsicName = '%' + alias[0] + '%'
            }

            if (hasOwn(INTRINSICS, intrinsicName)) {
              var value = INTRINSICS[intrinsicName]
              if (value === needsEval) {
                value = doEval(intrinsicName)
              }
              if (typeof value === 'undefined' && !allowMissing) {
                throw new $TypeError(
                  'intrinsic ' +
                    name +
                    ' exists, but is not available. Please file an issue!'
                )
              }

              return {
                alias: alias,
                name: intrinsicName,
                value: value,
              }
            }

            throw new $SyntaxError('intrinsic ' + name + ' does not exist!')
          }

          module.exports = function GetIntrinsic(name, allowMissing) {
            if (typeof name !== 'string' || name.length === 0) {
              throw new $TypeError('intrinsic name must be a non-empty string')
            }
            if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
              throw new $TypeError('"allowMissing" argument must be a boolean')
            }

            var parts = stringToPath(name)
            var intrinsicBaseName = parts.length > 0 ? parts[0] : ''

            var intrinsic = getBaseIntrinsic(
              '%' + intrinsicBaseName + '%',
              allowMissing
            )
            var intrinsicRealName = intrinsic.name
            var value = intrinsic.value
            var skipFurtherCaching = false

            var alias = intrinsic.alias
            if (alias) {
              intrinsicBaseName = alias[0]
              $spliceApply(parts, $concat([0, 1], alias))
            }

            for (var i = 1, isOwn = true; i < parts.length; i += 1) {
              var part = parts[i]
              var first = $strSlice(part, 0, 1)
              var last = $strSlice(part, -1)
              if (
                (first === '"' ||
                  first === "'" ||
                  first === '`' ||
                  last === '"' ||
                  last === "'" ||
                  last === '`') &&
                first !== last
              ) {
                throw new $SyntaxError(
                  'property names with quotes must have matching quotes'
                )
              }
              if (part === 'constructor' || !isOwn) {
                skipFurtherCaching = true
              }

              intrinsicBaseName += '.' + part
              intrinsicRealName = '%' + intrinsicBaseName + '%'

              if (hasOwn(INTRINSICS, intrinsicRealName)) {
                value = INTRINSICS[intrinsicRealName]
              } else if (value != null) {
                if (!(part in value)) {
                  if (!allowMissing) {
                    throw new $TypeError(
                      'base intrinsic for ' +
                        name +
                        ' exists, but the property is not available.'
                    )
                  }
                  return void undefined
                }
                if ($gOPD && i + 1 >= parts.length) {
                  var desc = $gOPD(value, part)
                  isOwn = !!desc

                  // By convention, when a data property is converted to an accessor
                  // property to emulate a data property that does not suffer from
                  // the override mistake, that accessor's getter is marked with
                  // an `originalValue` property. Here, when we detect this, we
                  // uphold the illusion by pretending to see that original data
                  // property, i.e., returning the value rather than the getter
                  // itself.
                  if (
                    isOwn &&
                    'get' in desc &&
                    !('originalValue' in desc.get)
                  ) {
                    value = desc.get
                  } else {
                    value = value[part]
                  }
                } else {
                  isOwn = hasOwn(value, part)
                  value = value[part]
                }

                if (isOwn && !skipFurtherCaching) {
                  INTRINSICS[intrinsicRealName] = value
                }
              }
            }
            return value
          }

          /***/
        },

      /***/ './node_modules/has-symbols/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_228377__) => {
          'use strict'

          var origSymbol = typeof Symbol !== 'undefined' && Symbol
          var hasSymbolSham = __nested_webpack_require_228377__(
            /*! ./shams */ './node_modules/has-symbols/shams.js'
          )

          module.exports = function hasNativeSymbols() {
            if (typeof origSymbol !== 'function') {
              return false
            }
            if (typeof Symbol !== 'function') {
              return false
            }
            if (typeof origSymbol('foo') !== 'symbol') {
              return false
            }
            if (typeof Symbol('bar') !== 'symbol') {
              return false
            }

            return hasSymbolSham()
          }

          /***/
        },

      /***/ './node_modules/has-symbols/shams.js':
        /*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
        /***/ (module) => {
          'use strict'

          /* eslint complexity: [2, 18], max-statements: [2, 33] */
          module.exports = function hasSymbols() {
            if (
              typeof Symbol !== 'function' ||
              typeof Object.getOwnPropertySymbols !== 'function'
            ) {
              return false
            }
            if (typeof Symbol.iterator === 'symbol') {
              return true
            }

            var obj = {}
            var sym = Symbol('test')
            var symObj = Object(sym)
            if (typeof sym === 'string') {
              return false
            }

            if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
              return false
            }
            if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
              return false
            }

            // temp disabled per https://github.com/ljharb/object.assign/issues/17
            // if (sym instanceof Symbol) { return false; }
            // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
            // if (!(symObj instanceof Symbol)) { return false; }

            // if (typeof Symbol.prototype.toString !== 'function') { return false; }
            // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

            var symVal = 42
            obj[sym] = symVal
            for (sym in obj) {
              return false
            } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
            if (
              typeof Object.keys === 'function' &&
              Object.keys(obj).length !== 0
            ) {
              return false
            }

            if (
              typeof Object.getOwnPropertyNames === 'function' &&
              Object.getOwnPropertyNames(obj).length !== 0
            ) {
              return false
            }

            var syms = Object.getOwnPropertySymbols(obj)
            if (syms.length !== 1 || syms[0] !== sym) {
              return false
            }

            if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
              return false
            }

            if (typeof Object.getOwnPropertyDescriptor === 'function') {
              var descriptor = Object.getOwnPropertyDescriptor(obj, sym)
              if (
                descriptor.value !== symVal ||
                descriptor.enumerable !== true
              ) {
                return false
              }
            }

            return true
          }

          /***/
        },

      /***/ './node_modules/has/src/index.js':
        /*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_232174__) => {
          'use strict'

          var bind = __nested_webpack_require_232174__(
            /*! function-bind */ './node_modules/function-bind/index.js'
          )

          module.exports = bind.call(
            Function.call,
            Object.prototype.hasOwnProperty
          )

          /***/
        },

      /***/ './node_modules/inherits/inherits_browser.js':
        /*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
        /***/ (module) => {
          if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                  },
                })
              }
            }
          } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () {}
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
              }
            }
          }

          /***/
        },

      /***/ './node_modules/is-arguments/index.js':
        /*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_234078__) => {
          'use strict'

          var hasToStringTag =
            typeof Symbol === 'function' &&
            typeof Symbol.toStringTag === 'symbol'
          var callBound = __nested_webpack_require_234078__(
            /*! call-bind/callBound */ './node_modules/call-bind/callBound.js'
          )

          var $toString = callBound('Object.prototype.toString')

          var isStandardArguments = function isArguments(value) {
            if (
              hasToStringTag &&
              value &&
              typeof value === 'object' &&
              Symbol.toStringTag in value
            ) {
              return false
            }
            return $toString(value) === '[object Arguments]'
          }

          var isLegacyArguments = function isArguments(value) {
            if (isStandardArguments(value)) {
              return true
            }
            return (
              value !== null &&
              typeof value === 'object' &&
              typeof value.length === 'number' &&
              value.length >= 0 &&
              $toString(value) !== '[object Array]' &&
              $toString(value.callee) === '[object Function]'
            )
          }

          var supportsStandardArguments = (function () {
            return isStandardArguments(arguments)
          })()

          isStandardArguments.isLegacyArguments = isLegacyArguments // for tests

          module.exports = supportsStandardArguments
            ? isStandardArguments
            : isLegacyArguments

          /***/
        },

      /***/ './node_modules/is-generator-function/index.js':
        /*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
        /***/ (module) => {
          'use strict'

          var toStr = Object.prototype.toString
          var fnToStr = Function.prototype.toString
          var isFnRegex = /^\s*(?:function)?\*/
          var hasToStringTag =
            typeof Symbol === 'function' &&
            typeof Symbol.toStringTag === 'symbol'
          var getProto = Object.getPrototypeOf
          var getGeneratorFunc = function () {
            // eslint-disable-line consistent-return
            if (!hasToStringTag) {
              return false
            }
            try {
              return Function('return function*() {}')()
            } catch (e) {}
          }
          var generatorFunc = getGeneratorFunc()
          var GeneratorFunction =
            getProto && generatorFunc ? getProto(generatorFunc) : false

          module.exports = function isGeneratorFunction(fn) {
            if (typeof fn !== 'function') {
              return false
            }
            if (isFnRegex.test(fnToStr.call(fn))) {
              return true
            }
            if (!hasToStringTag) {
              var str = toStr.call(fn)
              return str === '[object GeneratorFunction]'
            }
            return getProto && getProto(fn) === GeneratorFunction
          }

          /***/
        },

      /***/ './node_modules/is-nan/implementation.js':
        /*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
        /***/ (module) => {
          'use strict'

          /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

          module.exports = function isNaN(value) {
            return value !== value
          }

          /***/
        },

      /***/ './node_modules/is-nan/index.js':
        /*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_237913__) => {
          'use strict'

          var callBind = __nested_webpack_require_237913__(
            /*! call-bind */ './node_modules/call-bind/index.js'
          )
          var define = __nested_webpack_require_237913__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )

          var implementation = __nested_webpack_require_237913__(
            /*! ./implementation */ './node_modules/is-nan/implementation.js'
          )
          var getPolyfill = __nested_webpack_require_237913__(
            /*! ./polyfill */ './node_modules/is-nan/polyfill.js'
          )
          var shim = __nested_webpack_require_237913__(
            /*! ./shim */ './node_modules/is-nan/shim.js'
          )

          var polyfill = callBind(getPolyfill(), Number)

          /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

          define(polyfill, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim,
          })

          module.exports = polyfill

          /***/
        },

      /***/ './node_modules/is-nan/polyfill.js':
        /*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_239206__) => {
          'use strict'

          var implementation = __nested_webpack_require_239206__(
            /*! ./implementation */ './node_modules/is-nan/implementation.js'
          )

          module.exports = function getPolyfill() {
            if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
              return Number.isNaN
            }
            return implementation
          }

          /***/
        },

      /***/ './node_modules/is-nan/shim.js':
        /*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_239879__) => {
          'use strict'

          var define = __nested_webpack_require_239879__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )
          var getPolyfill = __nested_webpack_require_239879__(
            /*! ./polyfill */ './node_modules/is-nan/polyfill.js'
          )

          /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

          module.exports = function shimNumberIsNaN() {
            var polyfill = getPolyfill()
            define(Number, { isNaN: polyfill }, {
              isNaN: function testIsNaN() {
                return Number.isNaN !== polyfill
              },
            })
            return polyfill
          }

          /***/
        },

      /***/ './node_modules/is-typed-array/index.js':
        /*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_240883__) => {
          'use strict'

          var forEach = __nested_webpack_require_240883__(
            /*! foreach */ './node_modules/foreach/index.js'
          )
          var availableTypedArrays = __nested_webpack_require_240883__(
            /*! available-typed-arrays */ './node_modules/available-typed-arrays/index.js'
          )
          var callBound = __nested_webpack_require_240883__(
            /*! call-bind/callBound */ './node_modules/call-bind/callBound.js'
          )

          var $toString = callBound('Object.prototype.toString')
          var hasSymbols = __nested_webpack_require_240883__(
            /*! has-symbols */ './node_modules/has-symbols/index.js'
          )()
          var hasToStringTag =
            hasSymbols && typeof Symbol.toStringTag === 'symbol'

          var typedArrays = availableTypedArrays()

          var $indexOf =
            callBound('Array.prototype.indexOf', true) ||
            function indexOf(array, value) {
              for (var i = 0; i < array.length; i += 1) {
                if (array[i] === value) {
                  return i
                }
              }
              return -1
            }
          var $slice = callBound('String.prototype.slice')
          var toStrTags = {}
          var gOPD = __nested_webpack_require_240883__(
            /*! es-abstract/helpers/getOwnPropertyDescriptor */ './node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js'
          )
          var getPrototypeOf = Object.getPrototypeOf // require('getprototypeof');
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function (typedArray) {
              var arr = new __nested_webpack_require_240883__.g[typedArray]()
              if (!(Symbol.toStringTag in arr)) {
                throw new EvalError(
                  'this engine has support for Symbol.toStringTag, but ' +
                    typedArray +
                    ' does not have the property! Please report this.'
                )
              }
              var proto = getPrototypeOf(arr)
              var descriptor = gOPD(proto, Symbol.toStringTag)
              if (!descriptor) {
                var superProto = getPrototypeOf(proto)
                descriptor = gOPD(superProto, Symbol.toStringTag)
              }
              toStrTags[typedArray] = descriptor.get
            })
          }

          var tryTypedArrays = function tryAllTypedArrays(value) {
            var anyTrue = false
            forEach(toStrTags, function (getter, typedArray) {
              if (!anyTrue) {
                try {
                  anyTrue = getter.call(value) === typedArray
                } catch (e) {
                  /**/
                }
              }
            })
            return anyTrue
          }

          module.exports = function isTypedArray(value) {
            if (!value || typeof value !== 'object') {
              return false
            }
            if (!hasToStringTag) {
              var tag = $slice($toString(value), 8, -1)
              return $indexOf(typedArrays, tag) > -1
            }
            if (!gOPD) {
              return false
            }
            return tryTypedArrays(value)
          }

          /***/
        },

      /***/ './node_modules/object-is/implementation.js':
        /*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
        /***/ (module) => {
          'use strict'

          var numberIsNaN = function (value) {
            return value !== value
          }

          module.exports = function is(a, b) {
            if (a === 0 && b === 0) {
              return 1 / a === 1 / b
            }
            if (a === b) {
              return true
            }
            if (numberIsNaN(a) && numberIsNaN(b)) {
              return true
            }
            return false
          }

          /***/
        },

      /***/ './node_modules/object-is/index.js':
        /*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_245081__) => {
          'use strict'

          var define = __nested_webpack_require_245081__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )
          var callBind = __nested_webpack_require_245081__(
            /*! call-bind */ './node_modules/call-bind/index.js'
          )

          var implementation = __nested_webpack_require_245081__(
            /*! ./implementation */ './node_modules/object-is/implementation.js'
          )
          var getPolyfill = __nested_webpack_require_245081__(
            /*! ./polyfill */ './node_modules/object-is/polyfill.js'
          )
          var shim = __nested_webpack_require_245081__(
            /*! ./shim */ './node_modules/object-is/shim.js'
          )

          var polyfill = callBind(getPolyfill(), Object)

          define(polyfill, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim,
          })

          module.exports = polyfill

          /***/
        },

      /***/ './node_modules/object-is/polyfill.js':
        /*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_246313__) => {
          'use strict'

          var implementation = __nested_webpack_require_246313__(
            /*! ./implementation */ './node_modules/object-is/implementation.js'
          )

          module.exports = function getPolyfill() {
            return typeof Object.is === 'function' ? Object.is : implementation
          }

          /***/
        },

      /***/ './node_modules/object-is/shim.js':
        /*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_246924__) => {
          'use strict'

          var getPolyfill = __nested_webpack_require_246924__(
            /*! ./polyfill */ './node_modules/object-is/polyfill.js'
          )
          var define = __nested_webpack_require_246924__(
            /*! define-properties */ './node_modules/define-properties/index.js'
          )

          module.exports = function shimObjectIs() {
            var polyfill = getPolyfill()
            define(Object, { is: polyfill }, {
              is: function testObjectIs() {
                return Object.is !== polyfill
              },
            })
            return polyfill
          }

          /***/
        },

      /***/ './node_modules/object-keys/implementation.js':
        /*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_247864__) => {
          'use strict'

          var keysShim
          if (!Object.keys) {
            // modified from https://github.com/es-shims/es5-shim
            var has = Object.prototype.hasOwnProperty
            var toStr = Object.prototype.toString
            var isArgs = __nested_webpack_require_247864__(
              /*! ./isArguments */ './node_modules/object-keys/isArguments.js'
            ) // eslint-disable-line global-require
            var isEnumerable = Object.prototype.propertyIsEnumerable
            var hasDontEnumBug = !isEnumerable.call(
              { toString: null },
              'toString'
            )
            var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype')
            var dontEnums = [
              'toString',
              'toLocaleString',
              'valueOf',
              'hasOwnProperty',
              'isPrototypeOf',
              'propertyIsEnumerable',
              'constructor',
            ]
            var equalsConstructorPrototype = function (o) {
              var ctor = o.constructor
              return ctor && ctor.prototype === o
            }
            var excludedKeys = {
              $applicationCache: true,
              $console: true,
              $external: true,
              $frame: true,
              $frameElement: true,
              $frames: true,
              $innerHeight: true,
              $innerWidth: true,
              $onmozfullscreenchange: true,
              $onmozfullscreenerror: true,
              $outerHeight: true,
              $outerWidth: true,
              $pageXOffset: true,
              $pageYOffset: true,
              $parent: true,
              $scrollLeft: true,
              $scrollTop: true,
              $scrollX: true,
              $scrollY: true,
              $self: true,
              $webkitIndexedDB: true,
              $webkitStorageInfo: true,
              $window: true,
            }
            var hasAutomationEqualityBug = (function () {
              /* global window */
              if (typeof window === 'undefined') {
                return false
              }
              for (var k in window) {
                try {
                  if (
                    !excludedKeys['$' + k] &&
                    has.call(window, k) &&
                    window[k] !== null &&
                    typeof window[k] === 'object'
                  ) {
                    try {
                      equalsConstructorPrototype(window[k])
                    } catch (e) {
                      return true
                    }
                  }
                } catch (e) {
                  return true
                }
              }
              return false
            })()
            var equalsConstructorPrototypeIfNotBuggy = function (o) {
              /* global window */
              if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                return equalsConstructorPrototype(o)
              }
              try {
                return equalsConstructorPrototype(o)
              } catch (e) {
                return false
              }
            }

            keysShim = function keys(object) {
              var isObject = object !== null && typeof object === 'object'
              var isFunction = toStr.call(object) === '[object Function]'
              var isArguments = isArgs(object)
              var isString =
                isObject && toStr.call(object) === '[object String]'
              var theKeys = []

              if (!isObject && !isFunction && !isArguments) {
                throw new TypeError('Object.keys called on a non-object')
              }

              var skipProto = hasProtoEnumBug && isFunction
              if (isString && object.length > 0 && !has.call(object, 0)) {
                for (var i = 0; i < object.length; ++i) {
                  theKeys.push(String(i))
                }
              }

              if (isArguments && object.length > 0) {
                for (var j = 0; j < object.length; ++j) {
                  theKeys.push(String(j))
                }
              } else {
                for (var name in object) {
                  if (
                    !(skipProto && name === 'prototype') &&
                    has.call(object, name)
                  ) {
                    theKeys.push(String(name))
                  }
                }
              }

              if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(
                  object
                )

                for (var k = 0; k < dontEnums.length; ++k) {
                  if (
                    !(skipConstructor && dontEnums[k] === 'constructor') &&
                    has.call(object, dontEnums[k])
                  ) {
                    theKeys.push(dontEnums[k])
                  }
                }
              }
              return theKeys
            }
          }
          module.exports = keysShim

          /***/
        },

      /***/ './node_modules/object-keys/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_253196__) => {
          'use strict'

          var slice = Array.prototype.slice
          var isArgs = __nested_webpack_require_253196__(
            /*! ./isArguments */ './node_modules/object-keys/isArguments.js'
          )

          var origKeys = Object.keys
          var keysShim = origKeys
            ? function keys(o) {
                return origKeys(o)
              }
            : __nested_webpack_require_253196__(
                /*! ./implementation */ './node_modules/object-keys/implementation.js'
              )

          var originalKeys = Object.keys

          keysShim.shim = function shimObjectKeys() {
            if (Object.keys) {
              var keysWorksWithArguments = (function () {
                // Safari 5.0 bug
                var args = Object.keys(arguments)
                return args && args.length === arguments.length
              })(1, 2)
              if (!keysWorksWithArguments) {
                Object.keys = function keys(object) {
                  // eslint-disable-line func-name-matching
                  if (isArgs(object)) {
                    return originalKeys(slice.call(object))
                  }
                  return originalKeys(object)
                }
              }
            } else {
              Object.keys = keysShim
            }
            return Object.keys || keysShim
          }

          module.exports = keysShim

          /***/
        },

      /***/ './node_modules/object-keys/isArguments.js':
        /*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
        /***/ (module) => {
          'use strict'

          var toStr = Object.prototype.toString

          module.exports = function isArguments(value) {
            var str = toStr.call(value)
            var isArgs = str === '[object Arguments]'
            if (!isArgs) {
              isArgs =
                str !== '[object Array]' &&
                value !== null &&
                typeof value === 'object' &&
                typeof value.length === 'number' &&
                value.length >= 0 &&
                toStr.call(value.callee) === '[object Function]'
            }
            return isArgs
          }

          /***/
        },

      /***/ './node_modules/process/browser.js':
        /*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
        /***/ (module) => {
          // shim for using process in browser
          var process = (module.exports = {})

          // cached from whatever global is present so that test runners that stub it
          // don't break things.  But we need to wrap it in a try catch in case it is
          // wrapped in strict mode code which doesn't define any globals.  It's inside a
          // function because try/catches deoptimize in certain engines.

          var cachedSetTimeout
          var cachedClearTimeout

          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined')
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined')
          }
          ;(function () {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout
              } else {
                cachedSetTimeout = defaultSetTimout
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout
              } else {
                cachedClearTimeout = defaultClearTimeout
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout
            }
          })()
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              //normal enviroments in sane situations
              return setTimeout(fun, 0)
            }
            // if setTimeout wasn't available but was latter defined
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout
              return setTimeout(fun, 0)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedSetTimeout(fun, 0)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0)
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              //normal enviroments in sane situations
              return clearTimeout(marker)
            }
            // if clearTimeout wasn't available but was latter defined
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout
              return clearTimeout(marker)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedClearTimeout(marker)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker)
              }
            }
          }
          var queue = []
          var draining = false
          var currentQueue
          var queueIndex = -1

          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return
            }
            draining = false
            if (currentQueue.length) {
              queue = currentQueue.concat(queue)
            } else {
              queueIndex = -1
            }
            if (queue.length) {
              drainQueue()
            }
          }

          function drainQueue() {
            if (draining) {
              return
            }
            var timeout = runTimeout(cleanUpNextTick)
            draining = true

            var len = queue.length
            while (len) {
              currentQueue = queue
              queue = []
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run()
                }
              }
              queueIndex = -1
              len = queue.length
            }
            currentQueue = null
            draining = false
            runClearTimeout(timeout)
          }

          process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1)
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i]
              }
            }
            queue.push(new Item(fun, args))
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue)
            }
          }

          // v8 likes predictible objects
          function Item(fun, array) {
            this.fun = fun
            this.array = array
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array)
          }
          process.title = 'browser'
          process.browser = true
          process.env = {}
          process.argv = []
          process.version = '' // empty string to avoid regexp issues
          process.versions = {}

          function noop() {}

          process.on = noop
          process.addListener = noop
          process.once = noop
          process.off = noop
          process.removeListener = noop
          process.removeAllListeners = noop
          process.emit = noop
          process.prependListener = noop
          process.prependOnceListener = noop

          process.listeners = function (name) {
            return []
          }

          process.binding = function (name) {
            throw new Error('process.binding is not supported')
          }

          process.cwd = function () {
            return '/'
          }
          process.chdir = function (dir) {
            throw new Error('process.chdir is not supported')
          }
          process.umask = function () {
            return 0
          }

          /***/
        },

      /***/ './node_modules/querystring/decode.js':
        /*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
        /***/ (module) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          // If obj.hasOwnProperty has been overridden, then calling
          // obj.hasOwnProperty(prop) will break.
          // See: https://github.com/joyent/node/issues/1707
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop)
          }

          module.exports = function (qs, sep, eq, options) {
            sep = sep || '&'
            eq = eq || '='
            var obj = {}

            if (typeof qs !== 'string' || qs.length === 0) {
              return obj
            }

            var regexp = /\+/g
            qs = qs.split(sep)

            var maxKeys = 1000
            if (options && typeof options.maxKeys === 'number') {
              maxKeys = options.maxKeys
            }

            var len = qs.length
            // maxKeys <= 0 means that we should not limit keys count
            if (maxKeys > 0 && len > maxKeys) {
              len = maxKeys
            }

            for (var i = 0; i < len; ++i) {
              var x = qs[i].replace(regexp, '%20'),
                idx = x.indexOf(eq),
                kstr,
                vstr,
                k,
                v

              if (idx >= 0) {
                kstr = x.substr(0, idx)
                vstr = x.substr(idx + 1)
              } else {
                kstr = x
                vstr = ''
              }

              k = decodeURIComponent(kstr)
              v = decodeURIComponent(vstr)

              if (!hasOwnProperty(obj, k)) {
                obj[k] = v
              } else if (Array.isArray(obj[k])) {
                obj[k].push(v)
              } else {
                obj[k] = [obj[k], v]
              }
            }

            return obj
          }

          /***/
        },

      /***/ './node_modules/querystring/encode.js':
        /*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
        /***/ (module) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var stringifyPrimitive = function (v) {
            switch (typeof v) {
              case 'string':
                return v

              case 'boolean':
                return v ? 'true' : 'false'

              case 'number':
                return isFinite(v) ? v : ''

              default:
                return ''
            }
          }

          module.exports = function (obj, sep, eq, name) {
            sep = sep || '&'
            eq = eq || '='
            if (obj === null) {
              obj = undefined
            }

            if (typeof obj === 'object') {
              return Object.keys(obj)
                .map(function (k) {
                  var ks = encodeURIComponent(stringifyPrimitive(k)) + eq
                  if (Array.isArray(obj[k])) {
                    return obj[k]
                      .map(function (v) {
                        return ks + encodeURIComponent(stringifyPrimitive(v))
                      })
                      .join(sep)
                  } else {
                    return ks + encodeURIComponent(stringifyPrimitive(obj[k]))
                  }
                })
                .join(sep)
            }

            if (!name) return ''
            return (
              encodeURIComponent(stringifyPrimitive(name)) +
              eq +
              encodeURIComponent(stringifyPrimitive(obj))
            )
          }

          /***/
        },

      /***/ './node_modules/querystring/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_269223__) => {
          'use strict'

          exports.decode = exports.parse = __nested_webpack_require_269223__(
            /*! ./decode */ './node_modules/querystring/decode.js'
          )
          exports.encode = exports.stringify = __nested_webpack_require_269223__(
            /*! ./encode */ './node_modules/querystring/encode.js'
          )

          /***/
        },

      /***/ './src/album/getAlbum.ts':
        /*!*******************************!*\
  !*** ./src/album/getAlbum.ts ***!
  \*******************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_269798__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getAlbum = void 0
          const endpoints_1 = __nested_webpack_require_269798__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_269798__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function getAlbum(client, albumHash) {
            const url = `${endpoints_1.ALBUM_ENDPOINT}/${albumHash}`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url })
            )
          }
          exports.getAlbum = getAlbum

          /***/
        },

      /***/ './src/album/index.ts':
        /*!****************************!*\
  !*** ./src/album/index.ts ***!
  \****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_270719__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          const tslib_1 = __nested_webpack_require_270719__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          tslib_1.__exportStar(
            __nested_webpack_require_270719__(/*! ./getAlbum */ './src/album/getAlbum.ts'),
            exports
          )

          /***/
        },

      /***/ './src/client.ts':
        /*!***********************!*\
  !*** ./src/client.ts ***!
  \***********************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_271306__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ImgurClient = void 0
          const tslib_1 = __nested_webpack_require_271306__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          const events_1 = __nested_webpack_require_271306__(
            /*! events */ './node_modules/events/events.js'
          )
          const getAuthorizationHeader_1 = __nested_webpack_require_271306__(
            /*! ./getAuthorizationHeader */ './src/getAuthorizationHeader.ts'
          )
          const image_1 = __nested_webpack_require_271306__(
            /*! ./image */ './src/image/index.ts'
          )
          const gallery_1 = __nested_webpack_require_271306__(
            /*! ./gallery */ './src/gallery/index.ts'
          )
          const album_1 = __nested_webpack_require_271306__(
            /*! ./album */ './src/album/index.ts'
          )
          const endpoints_1 = __nested_webpack_require_271306__(
            /*! ./common/endpoints */ './src/common/endpoints.ts'
          )
          const USERAGENT =
            'imgur/next (https://github.com/kaimallea/node-imgur)'
          const axios_1 = tslib_1.__importDefault(
            __nested_webpack_require_271306__(/*! axios */ './node_modules/axios/index.js')
          )
          class ImgurClient extends events_1.EventEmitter {
            constructor(credentials) {
              super()
              this.credentials = credentials
              this.plainFetcher = axios_1.default.create({
                baseURL: endpoints_1.IMGUR_API_PREFIX,
                headers: {
                  'User-Agent': USERAGENT,
                },
                responseType: 'json',
              })
              this.fetcher = axios_1.default.create({
                baseURL: endpoints_1.IMGUR_API_PREFIX,
                headers: {
                  'User-Agent': USERAGENT,
                },
                responseType: 'json',
              })
              this.fetcher.interceptors.request.use(
                async (config) => {
                  config.headers = config.headers ? config.headers : {}
                  config.headers.authorization = await getAuthorizationHeader_1.getAuthorizationHeader(
                    this
                  )
                  return config
                },
                (e) => Promise.reject(e)
              )
            }
            plainRequest(options) {
              return this.plainFetcher(options)
            }
            request(options = {}) {
              return this.fetcher(options)
            }
            deleteImage(imageHash) {
              return image_1.deleteImage(this, imageHash)
            }
            favoriteImage(imageHash) {
              return image_1.favoriteImage(this, imageHash)
            }
            getAlbum(albumHash) {
              return album_1.getAlbum(this, albumHash)
            }
            getGallery(options) {
              return gallery_1.getGallery(this, options)
            }
            getSubredditGallery(options) {
              return gallery_1.getSubredditGallery(this, options)
            }
            searchGallery(options) {
              return gallery_1.searchGallery(this, options)
            }
            getImage(imageHash) {
              return image_1.getImage(this, imageHash)
            }
            updateImage(payload) {
              return image_1.updateImage(this, payload)
            }
            upload(payload) {
              return image_1.upload(this, payload)
            }
          }
          exports.ImgurClient = ImgurClient

          /***/
        },

      /***/ './src/common/endpoints.ts':
        /*!*********************************!*\
  !*** ./src/common/endpoints.ts ***!
  \*********************************/
        /***/ (__unused_webpack_module, exports) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.SEARCH_GALLERY_ENDPOINT = exports.SUBREDDIT_GALLERY_ENDPOINT = exports.GALLERY_ENDPOINT = exports.UPLOAD_ENDPOINT = exports.IMAGE_ENDPOINT = exports.ALBUM_ENDPOINT = exports.AUTHORIZE_ENDPOINT = exports.API_VERSION = exports.IMGUR_API_PREFIX = void 0
          exports.IMGUR_API_PREFIX = 'https://api.imgur.com'
          exports.API_VERSION = '3'
          exports.AUTHORIZE_ENDPOINT = 'oauth2/authorize'
          exports.ALBUM_ENDPOINT = `${exports.API_VERSION}/album`
          exports.IMAGE_ENDPOINT = `${exports.API_VERSION}/image`
          exports.UPLOAD_ENDPOINT = `${exports.API_VERSION}/upload`
          exports.GALLERY_ENDPOINT = `${exports.API_VERSION}/gallery`
          exports.SUBREDDIT_GALLERY_ENDPOINT = `${exports.API_VERSION}/gallery/r`
          exports.SEARCH_GALLERY_ENDPOINT = `${exports.API_VERSION}/gallery/search`

          /***/
        },

      /***/ './src/common/types.ts':
        /*!*****************************!*\
  !*** ./src/common/types.ts ***!
  \*****************************/
        /***/ (__unused_webpack_module, exports) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.isLogin = exports.isClientId = exports.isAccessToken = void 0
          function isAccessToken(arg) {
            return arg.accessToken !== undefined
          }
          exports.isAccessToken = isAccessToken
          function isClientId(arg) {
            return arg.clientId !== undefined
          }
          exports.isClientId = isClientId
          function isLogin(arg) {
            return (
              arg.clientId !== undefined &&
              arg.username !== undefined &&
              arg.password !== undefined
            )
          }
          exports.isLogin = isLogin

          /***/
        },

      /***/ './src/common/utils.ts':
        /*!*****************************!*\
  !*** ./src/common/utils.ts ***!
  \*****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_277253__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getImgurApiResponseFromResponse = exports.createForm = exports.getSource = exports.isStream = exports.isImageUrl = exports.isBase64 = void 0
          const tslib_1 = __nested_webpack_require_277253__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          const form_data_1 = tslib_1.__importDefault(
            __nested_webpack_require_277253__(
              /*! form-data */ './node_modules/form-data/lib/browser.js'
            )
          )
          function isBase64(payload) {
            if (typeof payload === 'string') {
              return false
            }
            return (
              typeof payload.base64 !== 'undefined' && payload.type === 'base64'
            )
          }
          exports.isBase64 = isBase64
          function isImageUrl(payload) {
            if (typeof payload === 'string') {
              return true
            }
            return (
              typeof payload.image !== 'undefined' && payload.type === 'url'
            )
          }
          exports.isImageUrl = isImageUrl
          function isStream(payload) {
            if (typeof payload === 'string') {
              return false
            }
            return typeof payload.stream !== 'undefined'
          }
          exports.isStream = isStream
          // TODO: Refactor this to be a unique name of some kind (a hash?)
          function getSource(payload) {
            if (typeof payload === 'string') {
              return payload
            }
            if (isBase64(payload)) {
              return 'payload.base64'
            } else if (isStream(payload)) {
              return 'payload.stream'
            } else {
              return payload.image
            }
          }
          exports.getSource = getSource
          function createForm(payload) {
            const form = new form_data_1.default()
            if (typeof payload === 'string') {
              form.append('image', payload)
              return form
            }
            for (const [key, value] of Object.entries(payload)) {
              const supportedUploadObjectTypes = ['base64', 'stream']
              if (supportedUploadObjectTypes.indexOf(key) !== -1) {
                if (supportedUploadObjectTypes.indexOf(payload.type) !== -1) {
                  form.append(key, payload)
                }
              } else {
                form.append(key, value)
              }
            }
            return form
          }
          exports.createForm = createForm
          function getImgurApiResponseFromResponse(response) {
            var _a, _b
            if (
              typeof ((_a = response.data) === null || _a === void 0
                ? void 0
                : _a.status) !== 'undefined' &&
              typeof ((_b = response.data) === null || _b === void 0
                ? void 0
                : _b.success) !== 'undefined'
            ) {
              return response.data
            }
            return {
              data: response.data,
              status: response.status,
              // TODO: determine the success of the call?
              success: true,
            }
          }
          exports.getImgurApiResponseFromResponse = getImgurApiResponseFromResponse

          /***/
        },

      /***/ './src/gallery/getGallery.ts':
        /*!***********************************!*\
  !*** ./src/gallery/getGallery.ts ***!
  \***********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_280879__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getGallery = exports.constructGalleryUrl = void 0
          const endpoints_1 = __nested_webpack_require_280879__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const url_1 = __nested_webpack_require_280879__(
            /*! url */ './node_modules/url/url.js'
          )
          const utils_1 = __nested_webpack_require_280879__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          const defaultOptions = {
            section: 'hot',
            sort: 'viral',
          }
          function constructGalleryUrl(options) {
            const mergedOptions = Object.assign({}, defaultOptions, options)
            let uri = `${mergedOptions.section}`
            if (mergedOptions.sort) {
              uri += `/${mergedOptions.sort}`
            }
            if (mergedOptions.section === 'top' && mergedOptions.window) {
              uri += `/${mergedOptions.window}`
            }
            if (mergedOptions.page) {
              uri += `/${mergedOptions.page}`
            }
            const url = new url_1.URL(
              `${endpoints_1.IMGUR_API_PREFIX}/${endpoints_1.GALLERY_ENDPOINT}/${uri}`
            )
            if (mergedOptions.showViral !== undefined) {
              url.searchParams.append(
                'showViral',
                mergedOptions.showViral.toString()
              )
            }
            if (mergedOptions.mature !== undefined) {
              url.searchParams.append('mature', mergedOptions.mature.toString())
            }
            if (mergedOptions.album_previews !== undefined) {
              url.searchParams.append(
                'album_previews',
                mergedOptions.album_previews.toString()
              )
            }
            return url
          }
          exports.constructGalleryUrl = constructGalleryUrl
          async function getGallery(client, options = defaultOptions) {
            const { pathname } = constructGalleryUrl(options)
            // since we're using prefixUrl with got, we have to remove the starting slash or it'll throw
            const finalPathname = pathname.slice(1)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url: finalPathname })
            )
          }
          exports.getGallery = getGallery

          /***/
        },

      /***/ './src/gallery/getSubredditGallery.ts':
        /*!********************************************!*\
  !*** ./src/gallery/getSubredditGallery.ts ***!
  \********************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_283612__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getSubredditGallery = exports.constructSubredditGalleryUrl = void 0
          const endpoints_1 = __nested_webpack_require_283612__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const url_1 = __nested_webpack_require_283612__(
            /*! url */ './node_modules/url/url.js'
          )
          const utils_1 = __nested_webpack_require_283612__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          function constructSubredditGalleryUrl(options) {
            let uri = `${options.subreddit}`
            if (options.sort) {
              uri += `/${options.sort}`
            }
            if (options.sort === 'top' && options.window) {
              uri += `/${options.window}`
            }
            if (options.page) {
              uri += `/${options.page}`
            }
            const url = new url_1.URL(
              `${endpoints_1.IMGUR_API_PREFIX}/${endpoints_1.SUBREDDIT_GALLERY_ENDPOINT}/${uri}`
            )
            return url
          }
          exports.constructSubredditGalleryUrl = constructSubredditGalleryUrl
          async function getSubredditGallery(client, options) {
            const { pathname } = constructSubredditGalleryUrl(options)
            // since we're using prefixUrl with got, we have to remove the starting slash or it'll throw
            const finalPathname = pathname.slice(1)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url: finalPathname })
            )
          }
          exports.getSubredditGallery = getSubredditGallery

          /***/
        },

      /***/ './src/gallery/index.ts':
        /*!******************************!*\
  !*** ./src/gallery/index.ts ***!
  \******************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_285559__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          const tslib_1 = __nested_webpack_require_285559__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          tslib_1.__exportStar(
            __nested_webpack_require_285559__(
              /*! ./getGallery */ './src/gallery/getGallery.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_285559__(
              /*! ./getSubredditGallery */ './src/gallery/getSubredditGallery.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_285559__(
              /*! ./searchGallery */ './src/gallery/searchGallery.ts'
            ),
            exports
          )

          /***/
        },

      /***/ './src/gallery/searchGallery.ts':
        /*!**************************************!*\
  !*** ./src/gallery/searchGallery.ts ***!
  \**************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_286616__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.searchGallery = exports.constructSearchGalleryUrl = void 0
          const endpoints_1 = __nested_webpack_require_286616__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_286616__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          const url_1 = __nested_webpack_require_286616__(
            /*! url */ './node_modules/url/url.js'
          )
          const advancedParameters = [
            'q_all',
            'q_any',
            'q_exactly',
            'q_not',
            'q_type',
            'q_size_px',
          ]
          function constructSearchGalleryUrl(options) {
            let uri = ''
            if (options.sort) {
              uri += `/${options.sort}`
            }
            if (options.sort === 'top' && options.window) {
              uri += `/${options.window}`
            }
            if (options.page) {
              uri += `/${options.page}`
            }
            const url = new url_1.URL(
              `${endpoints_1.IMGUR_API_PREFIX}/${endpoints_1.SEARCH_GALLERY_ENDPOINT}${uri}`
            )
            advancedParameters.forEach((param) => {
              var _a
              if (
                (_a = options[param]) === null || _a === void 0
                  ? void 0
                  : _a.length
              ) {
                url.searchParams.append(param, options[param])
              }
            })
            if (!url.search) {
              const query = options.q || options.query
              if (!query) {
                throw new Error('No query was provided')
              }
              url.searchParams.append('q', query)
            }
            return url
          }
          exports.constructSearchGalleryUrl = constructSearchGalleryUrl
          async function searchGallery(client, options) {
            const { pathname } = constructSearchGalleryUrl(options)
            // since we're using prefixUrl with got, we have to remove the starting slash or it'll throw
            const finalPathname = pathname.slice(1)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url: finalPathname })
            )
          }
          exports.searchGallery = searchGallery

          /***/
        },

      /***/ './src/getAuthorizationHeader.ts':
        /*!***************************************!*\
  !*** ./src/getAuthorizationHeader.ts ***!
  \***************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_289298__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getAuthorizationHeader = void 0
          const types_1 = __nested_webpack_require_289298__(
            /*! ./common/types */ './src/common/types.ts'
          )
          const endpoints_1 = __nested_webpack_require_289298__(
            /*! ./common/endpoints */ './src/common/endpoints.ts'
          )
          async function getAuthorizationHeader(client) {
            if (types_1.isAccessToken(client.credentials)) {
              return `Bearer ${client.credentials.accessToken}`
            }
            if (
              types_1.isClientId(client.credentials) &&
              !types_1.isLogin(client.credentials)
            ) {
              return `Client-ID ${client.credentials.clientId}`
            }
            const { clientId, username, password } = client.credentials
            const options = {
              url: endpoints_1.AUTHORIZE_ENDPOINT,
              baseURL: endpoints_1.IMGUR_API_PREFIX,
              params: {
                client_id: clientId,
                response_type: 'token',
              },
            }
            let response = await client.plainRequest(options)
            const cookies = Array.isArray(response.headers['set-cookie'])
              ? response.headers['set-cookie'][0]
              : response.headers['set-cookie']
            if (!cookies) {
              throw new Error('No cookies were set during authorization')
            }
            const matches = cookies.match('(^|;)[s]*authorize_token=([^;]*)')
            if (!matches || matches.length < 3) {
              throw new Error('Unable to find authorize_token cookie')
            }
            const authorizeToken = matches[2]
            options.method = 'POST'
            options.data = {
              username,
              password,
              allow: authorizeToken,
            }
            options.followRedirect = false
            options.headers = {
              cookie: `authorize_token=${authorizeToken}`,
            }
            response = await client.plainRequest(options)
            const location = response.headers.location
            if (!location) {
              throw new Error('Unable to parse location')
            }
            const token = JSON.parse(
              '{"' +
                decodeURI(location.slice(location.indexOf('#') + 1))
                  .replace(/"/g, '\\"')
                  .replace(/&/g, '","')
                  .replace(/=/g, '":"') +
                '"}'
            )
            const accessToken = token.access_token
            client.credentials.accessToken = accessToken
            return `Bearer ${accessToken}`
          }
          exports.getAuthorizationHeader = getAuthorizationHeader

          /***/
        },

      /***/ './src/image/deleteImage.ts':
        /*!**********************************!*\
  !*** ./src/image/deleteImage.ts ***!
  \**********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_292364__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.deleteImage = void 0
          const endpoints_1 = __nested_webpack_require_292364__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_292364__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function deleteImage(client, imageHash) {
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${imageHash}`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url, method: 'DELETE' })
            )
          }
          exports.deleteImage = deleteImage

          /***/
        },

      /***/ './src/image/favoriteImage.ts':
        /*!************************************!*\
  !*** ./src/image/favoriteImage.ts ***!
  \************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_293347__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.favoriteImage = void 0
          const endpoints_1 = __nested_webpack_require_293347__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_293347__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function favoriteImage(client, imageHash) {
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${imageHash}/favorite`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url, method: 'POST' })
            )
          }
          exports.favoriteImage = favoriteImage

          /***/
        },

      /***/ './src/image/getImage.ts':
        /*!*******************************!*\
  !*** ./src/image/getImage.ts ***!
  \*******************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_294325__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getImage = void 0
          const endpoints_1 = __nested_webpack_require_294325__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_294325__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          async function getImage(client, imageHash) {
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${imageHash}`
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({ url })
            )
          }
          exports.getImage = getImage

          /***/
        },

      /***/ './src/image/index.ts':
        /*!****************************!*\
  !*** ./src/image/index.ts ***!
  \****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_295246__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          const tslib_1 = __nested_webpack_require_295246__(
            /*! tslib */ './node_modules/tslib/tslib.es6.js'
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(
              /*! ./deleteImage */ './src/image/deleteImage.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(
              /*! ./favoriteImage */ './src/image/favoriteImage.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(/*! ./getImage */ './src/image/getImage.ts'),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(
              /*! ./updateImage */ './src/image/updateImage.ts'
            ),
            exports
          )
          tslib_1.__exportStar(
            __nested_webpack_require_295246__(/*! ./upload */ './src/image/upload.ts'),
            exports
          )

          /***/
        },

      /***/ './src/image/updateImage.ts':
        /*!**********************************!*\
  !*** ./src/image/updateImage.ts ***!
  \**********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_296547__) => {
          'use strict'

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.updateImage = void 0
          const endpoints_1 = __nested_webpack_require_296547__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          const utils_1 = __nested_webpack_require_296547__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          function isValidUpdatePayload(p) {
            return (
              typeof p.title === 'string' || typeof p.description === 'string'
            )
          }
          async function updateImage(client, payload) {
            if (Array.isArray(payload)) {
              const promises = payload.map((p) => {
                if (!isValidUpdatePayload(p)) {
                  throw new Error('Update requires a title and/or description')
                }
                const url = `${endpoints_1.IMAGE_ENDPOINT}/${p.imageHash}`
                const form = utils_1.createForm(p)
                /* eslint no-async-promise-executor: 0 */
                return new Promise(async function (resolve) {
                  return resolve(
                    utils_1.getImgurApiResponseFromResponse(
                      await client.request({
                        url,
                        method: 'POST',
                        data: form,
                        // resolveBodyOnly: true,
                      })
                    )
                  )
                })
              })
              return await Promise.all(promises)
            }
            if (!isValidUpdatePayload(payload)) {
              throw new Error('Update requires a title and/or description')
            }
            const url = `${endpoints_1.IMAGE_ENDPOINT}/${payload.imageHash}`
            const form = utils_1.createForm(payload)
            return utils_1.getImgurApiResponseFromResponse(
              await client.request({
                url,
                method: 'POST',
                data: form,
                // resolveBodyOnly: true,
              })
            )
          }
          exports.updateImage = updateImage

          /***/
        },

      /***/ './src/image/upload.ts':
        /*!*****************************!*\
  !*** ./src/image/upload.ts ***!
  \*****************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_298934__) => {
          'use strict'
          /* provided dependency */ var console = __nested_webpack_require_298934__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )

          Object.defineProperty(exports, '__esModule', { value: true })
          exports.upload = void 0
          const utils_1 = __nested_webpack_require_298934__(
            /*! ../common/utils */ './src/common/utils.ts'
          )
          const endpoints_1 = __nested_webpack_require_298934__(
            /*! ../common/endpoints */ './src/common/endpoints.ts'
          )
          async function upload(client, payload) {
            if (Array.isArray(payload)) {
              const promises = payload.map((p) => {
                const form = utils_1.createForm(p)
                /* eslint no-async-promise-executor: 0 */
                return new Promise(async (resolve) => {
                  resolve(
                    utils_1.getImgurApiResponseFromResponse(
                      await client.request({
                        url: endpoints_1.UPLOAD_ENDPOINT,
                        method: 'POST',
                        data: form,
                        onUploadProgress: (progressEvent) => {
                          console.log({ progressEvent })
                          client.emit('uploadProgress', { ...progressEvent })
                        },
                      })
                    )
                  )
                })
              })
              return await Promise.all(promises)
            }
            const form = utils_1.createForm(payload)
            // const id = Date.now.toString();
            const request = await client.request({
              url: endpoints_1.UPLOAD_ENDPOINT,
              method: 'POST',
              data: form,
              onUploadProgress: (progressEvent) => {
                console.log({ progressEvent })
                client.emit('uploadProgress', { ...progressEvent })
              },
            })
            return Promise.resolve(
              utils_1.getImgurApiResponseFromResponse(request)
            )
          }
          exports.upload = upload

          /***/
        },

      /***/ './node_modules/tslib/tslib.es6.js':
        /*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
        /***/ (
          __unused_webpack_module,
          __webpack_exports__,
          __nested_webpack_require_301404__
        ) => {
          'use strict'
          __nested_webpack_require_301404__.r(__webpack_exports__)
          /* harmony export */ __nested_webpack_require_301404__.d(__webpack_exports__, {
            /* harmony export */ __extends: () => /* binding */ __extends,
            /* harmony export */ __assign: () => /* binding */ __assign,
            /* harmony export */ __rest: () => /* binding */ __rest,
            /* harmony export */ __decorate: () => /* binding */ __decorate,
            /* harmony export */ __param: () => /* binding */ __param,
            /* harmony export */ __metadata: () => /* binding */ __metadata,
            /* harmony export */ __awaiter: () => /* binding */ __awaiter,
            /* harmony export */ __generator: () => /* binding */ __generator,
            /* harmony export */ __createBinding: () =>
              /* binding */ __createBinding,
            /* harmony export */ __exportStar: () => /* binding */ __exportStar,
            /* harmony export */ __values: () => /* binding */ __values,
            /* harmony export */ __read: () => /* binding */ __read,
            /* harmony export */ __spread: () => /* binding */ __spread,
            /* harmony export */ __spreadArrays: () =>
              /* binding */ __spreadArrays,
            /* harmony export */ __await: () => /* binding */ __await,
            /* harmony export */ __asyncGenerator: () =>
              /* binding */ __asyncGenerator,
            /* harmony export */ __asyncDelegator: () =>
              /* binding */ __asyncDelegator,
            /* harmony export */ __asyncValues: () =>
              /* binding */ __asyncValues,
            /* harmony export */ __makeTemplateObject: () =>
              /* binding */ __makeTemplateObject,
            /* harmony export */ __importStar: () => /* binding */ __importStar,
            /* harmony export */ __importDefault: () =>
              /* binding */ __importDefault,
            /* harmony export */ __classPrivateFieldGet: () =>
              /* binding */ __classPrivateFieldGet,
            /* harmony export */ __classPrivateFieldSet: () =>
              /* binding */ __classPrivateFieldSet,
            /* harmony export */
          })
          /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
          /* global Reflect, Promise */

          var extendStatics = function (d, b) {
            extendStatics =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (d, b) {
                  d.__proto__ = b
                }) ||
              function (d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
              }
            return extendStatics(d, b)
          }

          function __extends(d, b) {
            extendStatics(d, b)
            function __() {
              this.constructor = d
            }
            d.prototype =
              b === null
                ? Object.create(b)
                : ((__.prototype = b.prototype), new __())
          }

          var __assign = function () {
            __assign =
              Object.assign ||
              function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i]
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
              }
            return __assign.apply(this, arguments)
          }

          function __rest(s, e) {
            var t = {}
            for (var p in s)
              if (
                Object.prototype.hasOwnProperty.call(s, p) &&
                e.indexOf(p) < 0
              )
                t[p] = s[p]
            if (s != null && typeof Object.getOwnPropertySymbols === 'function')
              for (
                var i = 0, p = Object.getOwnPropertySymbols(s);
                i < p.length;
                i++
              ) {
                if (
                  e.indexOf(p[i]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(s, p[i])
                )
                  t[p[i]] = s[p[i]]
              }
            return t
          }

          function __decorate(decorators, target, key, desc) {
            var c = arguments.length,
              r =
                c < 3
                  ? target
                  : desc === null
                  ? (desc = Object.getOwnPropertyDescriptor(target, key))
                  : desc,
              d
            if (
              typeof Reflect === 'object' &&
              typeof Reflect.decorate === 'function'
            )
              r = Reflect.decorate(decorators, target, key, desc)
            else
              for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i]))
                  r =
                    (c < 3
                      ? d(r)
                      : c > 3
                      ? d(target, key, r)
                      : d(target, key)) || r
            return c > 3 && r && Object.defineProperty(target, key, r), r
          }

          function __param(paramIndex, decorator) {
            return function (target, key) {
              decorator(target, key, paramIndex)
            }
          }

          function __metadata(metadataKey, metadataValue) {
            if (
              typeof Reflect === 'object' &&
              typeof Reflect.metadata === 'function'
            )
              return Reflect.metadata(metadataKey, metadataValue)
          }

          function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P
                ? value
                : new P(function (resolve) {
                    resolve(value)
                  })
            }
            return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value))
                } catch (e) {
                  reject(e)
                }
              }
              function rejected(value) {
                try {
                  step(generator['throw'](value))
                } catch (e) {
                  reject(e)
                }
              }
              function step(result) {
                result.done
                  ? resolve(result.value)
                  : adopt(result.value).then(fulfilled, rejected)
              }
              step(
                (generator = generator.apply(thisArg, _arguments || [])).next()
              )
            })
          }

          function __generator(thisArg, body) {
            var _ = {
                label: 0,
                sent: function () {
                  if (t[0] & 1) throw t[1]
                  return t[1]
                },
                trys: [],
                ops: [],
              },
              f,
              y,
              t,
              g
            return (
              (g = { next: verb(0), throw: verb(1), return: verb(2) }),
              typeof Symbol === 'function' &&
                (g[Symbol.iterator] = function () {
                  return this
                }),
              g
            )
            function verb(n) {
              return function (v) {
                return step([n, v])
              }
            }
            function step(op) {
              if (f) throw new TypeError('Generator is already executing.')
              while (_)
                try {
                  if (
                    ((f = 1),
                    y &&
                      (t =
                        op[0] & 2
                          ? y['return']
                          : op[0]
                          ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                          : y.next) &&
                      !(t = t.call(y, op[1])).done)
                  )
                    return t
                  if (((y = 0), t)) op = [op[0] & 2, t.value]
                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op
                      break
                    case 4:
                      _.label++
                      return { value: op[1], done: false }
                    case 5:
                      _.label++
                      y = op[1]
                      op = [0]
                      continue
                    case 7:
                      op = _.ops.pop()
                      _.trys.pop()
                      continue
                    default:
                      if (
                        !((t = _.trys),
                        (t = t.length > 0 && t[t.length - 1])) &&
                        (op[0] === 6 || op[0] === 2)
                      ) {
                        _ = 0
                        continue
                      }
                      if (
                        op[0] === 3 &&
                        (!t || (op[1] > t[0] && op[1] < t[3]))
                      ) {
                        _.label = op[1]
                        break
                      }
                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1]
                        t = op
                        break
                      }
                      if (t && _.label < t[2]) {
                        _.label = t[2]
                        _.ops.push(op)
                        break
                      }
                      if (t[2]) _.ops.pop()
                      _.trys.pop()
                      continue
                  }
                  op = body.call(thisArg, _)
                } catch (e) {
                  op = [6, e]
                  y = 0
                } finally {
                  f = t = 0
                }
              if (op[0] & 5) throw op[1]
              return { value: op[0] ? op[1] : void 0, done: true }
            }
          }

          function __createBinding(o, m, k, k2) {
            if (k2 === undefined) k2 = k
            o[k2] = m[k]
          }

          function __exportStar(m, exports) {
            for (var p in m)
              if (p !== 'default' && !exports.hasOwnProperty(p))
                exports[p] = m[p]
          }

          function __values(o) {
            var s = typeof Symbol === 'function' && Symbol.iterator,
              m = s && o[s],
              i = 0
            if (m) return m.call(o)
            if (o && typeof o.length === 'number')
              return {
                next: function () {
                  if (o && i >= o.length) o = void 0
                  return { value: o && o[i++], done: !o }
                },
              }
            throw new TypeError(
              s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.'
            )
          }

          function __read(o, n) {
            var m = typeof Symbol === 'function' && o[Symbol.iterator]
            if (!m) return o
            var i = m.call(o),
              r,
              ar = [],
              e
            try {
              while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value)
            } catch (error) {
              e = { error: error }
            } finally {
              try {
                if (r && !r.done && (m = i['return'])) m.call(i)
              } finally {
                if (e) throw e.error
              }
            }
            return ar
          }

          function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++)
              ar = ar.concat(__read(arguments[i]))
            return ar
          }

          function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++)
              s += arguments[i].length
            for (var r = Array(s), k = 0, i = 0; i < il; i++)
              for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j]
            return r
          }

          function __await(v) {
            return this instanceof __await
              ? ((this.v = v), this)
              : new __await(v)
          }

          function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator)
              throw new TypeError('Symbol.asyncIterator is not defined.')
            var g = generator.apply(thisArg, _arguments || []),
              i,
              q = []
            return (
              (i = {}),
              verb('next'),
              verb('throw'),
              verb('return'),
              (i[Symbol.asyncIterator] = function () {
                return this
              }),
              i
            )
            function verb(n) {
              if (g[n])
                i[n] = function (v) {
                  return new Promise(function (a, b) {
                    q.push([n, v, a, b]) > 1 || resume(n, v)
                  })
                }
            }
            function resume(n, v) {
              try {
                step(g[n](v))
              } catch (e) {
                settle(q[0][3], e)
              }
            }
            function step(r) {
              r.value instanceof __await
                ? Promise.resolve(r.value.v).then(fulfill, reject)
                : settle(q[0][2], r)
            }
            function fulfill(value) {
              resume('next', value)
            }
            function reject(value) {
              resume('throw', value)
            }
            function settle(f, v) {
              if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1])
            }
          }

          function __asyncDelegator(o) {
            var i, p
            return (
              (i = {}),
              verb('next'),
              verb('throw', function (e) {
                throw e
              }),
              verb('return'),
              (i[Symbol.iterator] = function () {
                return this
              }),
              i
            )
            function verb(n, f) {
              i[n] = o[n]
                ? function (v) {
                    return (p = !p)
                      ? { value: __await(o[n](v)), done: n === 'return' }
                      : f
                      ? f(v)
                      : v
                  }
                : f
            }
          }

          function __asyncValues(o) {
            if (!Symbol.asyncIterator)
              throw new TypeError('Symbol.asyncIterator is not defined.')
            var m = o[Symbol.asyncIterator],
              i
            return m
              ? m.call(o)
              : ((o =
                  typeof __values === 'function'
                    ? __values(o)
                    : o[Symbol.iterator]()),
                (i = {}),
                verb('next'),
                verb('throw'),
                verb('return'),
                (i[Symbol.asyncIterator] = function () {
                  return this
                }),
                i)
            function verb(n) {
              i[n] =
                o[n] &&
                function (v) {
                  return new Promise(function (resolve, reject) {
                    ;(v = o[n](v)), settle(resolve, reject, v.done, v.value)
                  })
                }
            }
            function settle(resolve, reject, d, v) {
              Promise.resolve(v).then(function (v) {
                resolve({ value: v, done: d })
              }, reject)
            }
          }

          function __makeTemplateObject(cooked, raw) {
            if (Object.defineProperty) {
              Object.defineProperty(cooked, 'raw', { value: raw })
            } else {
              cooked.raw = raw
            }
            return cooked
          }

          function __importStar(mod) {
            if (mod && mod.__esModule) return mod
            var result = {}
            if (mod != null)
              for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k]
            result.default = mod
            return result
          }

          function __importDefault(mod) {
            return mod && mod.__esModule ? mod : { default: mod }
          }

          function __classPrivateFieldGet(receiver, privateMap) {
            if (!privateMap.has(receiver)) {
              throw new TypeError(
                'attempted to get private field on non-instance'
              )
            }
            return privateMap.get(receiver)
          }

          function __classPrivateFieldSet(receiver, privateMap, value) {
            if (!privateMap.has(receiver)) {
              throw new TypeError(
                'attempted to set private field on non-instance'
              )
            }
            privateMap.set(receiver, value)
            return value
          }

          /***/
        },

      /***/ './node_modules/url/node_modules/punycode/punycode.js':
        /*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
        /***/ function (module, exports, __nested_webpack_require_319528__) {
          /* module decorator */ module = __nested_webpack_require_319528__.nmd(module)
          var __WEBPACK_AMD_DEFINE_RESULT__ /*! https://mths.be/punycode v1.3.2 by @mathias */
          ;(function (root) {
            /** Detect free variables */
            var freeExports =  true && exports && !exports.nodeType && exports
            var freeModule =  true && module && !module.nodeType && module
            var freeGlobal =
              typeof __nested_webpack_require_319528__.g == 'object' && __nested_webpack_require_319528__.g
            if (
              freeGlobal.global === freeGlobal ||
              freeGlobal.window === freeGlobal ||
              freeGlobal.self === freeGlobal
            ) {
              root = freeGlobal
            }

            /**
             * The `punycode` object.
             * @name punycode
             * @type Object
             */
            var punycode,
              /** Highest positive signed 32-bit float value */
              maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
              /** Bootstring parameters */
              base = 36,
              tMin = 1,
              tMax = 26,
              skew = 38,
              damp = 700,
              initialBias = 72,
              initialN = 128, // 0x80
              delimiter = '-', // '\x2D'
              /** Regular expressions */
              regexPunycode = /^xn--/,
              regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
              regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
              /** Error messages */
              errors = {
                overflow: 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input',
              },
              /** Convenience shortcuts */
              baseMinusTMin = base - tMin,
              floor = Math.floor,
              stringFromCharCode = String.fromCharCode,
              /** Temporary variable */
              key

            /*--------------------------------------------------------------------------*/

            /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */
            function error(type) {
              throw RangeError(errors[type])
            }

            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */
            function map(array, fn) {
              var length = array.length
              var result = []
              while (length--) {
                result[length] = fn(array[length])
              }
              return result
            }

            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */
            function mapDomain(string, fn) {
              var parts = string.split('@')
              var result = ''
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@'
                string = parts[1]
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '\x2E')
              var labels = string.split('.')
              var encoded = map(labels, fn).join('.')
              return result + encoded
            }

            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */
            function ucs2decode(string) {
              var output = [],
                counter = 0,
                length = string.length,
                value,
                extra
              while (counter < length) {
                value = string.charCodeAt(counter++)
                if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++)
                  if ((extra & 0xfc00) == 0xdc00) {
                    // low surrogate
                    output.push(
                      ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                    )
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value)
                    counter--
                  }
                } else {
                  output.push(value)
                }
              }
              return output
            }

            /**
             * Creates a string based on an array of numeric code points.
             * @see `punycode.ucs2.decode`
             * @memberOf punycode.ucs2
             * @name encode
             * @param {Array} codePoints The array of numeric code points.
             * @returns {String} The new Unicode string (UCS-2).
             */
            function ucs2encode(array) {
              return map(array, function (value) {
                var output = ''
                if (value > 0xffff) {
                  value -= 0x10000
                  output += stringFromCharCode(
                    ((value >>> 10) & 0x3ff) | 0xd800
                  )
                  value = 0xdc00 | (value & 0x3ff)
                }
                output += stringFromCharCode(value)
                return output
              }).join('')
            }

            /**
             * Converts a basic code point into a digit/integer.
             * @see `digitToBasic()`
             * @private
             * @param {Number} codePoint The basic numeric code point value.
             * @returns {Number} The numeric value of a basic code point (for use in
             * representing integers) in the range `0` to `base - 1`, or `base` if
             * the code point does not represent a value.
             */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97
              }
              return base
            }

            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
            }

            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * http://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */
            function adapt(delta, numPoints, firstTime) {
              var k = 0
              delta = firstTime ? floor(delta / damp) : delta >> 1
              delta += floor(delta / numPoints)
              for (
                ;
                /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
                k += base
              ) {
                delta = floor(delta / baseMinusTMin)
              }
              return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew))
            }

            /**
             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
             * symbols.
             * @memberOf punycode
             * @param {String} input The Punycode string of ASCII-only symbols.
             * @returns {String} The resulting string of Unicode symbols.
             */
            function decode(input) {
              // Don't use UCS-2
              var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,
                /** Cached calculation results */
                baseMinusT

              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.

              basic = input.lastIndexOf(delimiter)
              if (basic < 0) {
                basic = 0
              }

              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                  error('not-basic')
                }
                output.push(input.charCodeAt(j))
              }

              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.

              for (
                index = basic > 0 ? basic + 1 : 0;
                index < inputLength /* no final expression */;

              ) {
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (
                  oldi = i, w = 1, k = base /* no condition */;
                  ;
                  k += base
                ) {
                  if (index >= inputLength) {
                    error('invalid-input')
                  }

                  digit = basicToDigit(input.charCodeAt(index++))

                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow')
                  }

                  i += digit * w
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias

                  if (digit < t) {
                    break
                  }

                  baseMinusT = base - t
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow')
                  }

                  w *= baseMinusT
                }

                out = output.length + 1
                bias = adapt(i - oldi, out, oldi == 0)

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error('overflow')
                }

                n += floor(i / out)
                i %= out

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n)
              }

              return ucs2encode(output)
            }

            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */
            function encode(input) {
              var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne,
                baseMinusT,
                qMinusT

              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input)

              // Cache the length
              inputLength = input.length

              // Initialize the state
              n = initialN
              delta = 0
              bias = initialBias

              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j]
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue))
                }
              }

              handledCPCount = basicLength = output.length

              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.

              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter)
              }

              // Main encoding loop:
              while (handledCPCount < inputLength) {
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j]
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow')
                }

                delta += (m - n) * handledCPCountPlusOne
                n = m

                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j]

                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow')
                  }

                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base /* no condition */; ; k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
                      if (q < t) {
                        break
                      }
                      qMinusT = q - t
                      baseMinusT = base - t
                      output.push(
                        stringFromCharCode(
                          digitToBasic(t + (qMinusT % baseMinusT), 0)
                        )
                      )
                      q = floor(qMinusT / baseMinusT)
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)))
                    bias = adapt(
                      delta,
                      handledCPCountPlusOne,
                      handledCPCount == basicLength
                    )
                    delta = 0
                    ++handledCPCount
                  }
                }

                ++delta
                ++n
              }
              return output.join('')
            }

            /**
             * Converts a Punycode string representing a domain name or an email address
             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
             * it doesn't matter if you call it on a string that has already been
             * converted to Unicode.
             * @memberOf punycode
             * @param {String} input The Punycoded domain name or email address to
             * convert to Unicode.
             * @returns {String} The Unicode representation of the given Punycode
             * string.
             */
            function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string)
                  ? decode(string.slice(4).toLowerCase())
                  : string
              })
            }

            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */
            function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string)
                  ? 'xn--' + encode(string)
                  : string
              })
            }

            /*--------------------------------------------------------------------------*/

            /** Define the public API */
            punycode = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              version: '1.3.2',
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              ucs2: {
                decode: ucs2decode,
                encode: ucs2encode,
              },
              decode: decode,
              encode: encode,
              toASCII: toASCII,
              toUnicode: toUnicode,
            }

            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (true) {
              !((__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                return punycode
              }.call(exports, __nested_webpack_require_319528__, exports, module)),
              __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
            } else {}
          })(this)

          /***/
        },

      /***/ './node_modules/url/url.js':
        /*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_340092__) => {
          'use strict'
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var punycode = __nested_webpack_require_340092__(
            /*! punycode */ './node_modules/url/node_modules/punycode/punycode.js'
          )
          var util = __nested_webpack_require_340092__(
            /*! ./util */ './node_modules/url/util.js'
          )

          exports.parse = urlParse
          exports.resolve = urlResolve
          exports.resolveObject = urlResolveObject
          exports.format = urlFormat

          exports.Url = Url

          function Url() {
            this.protocol = null
            this.slashes = null
            this.auth = null
            this.host = null
            this.port = null
            this.hostname = null
            this.hash = null
            this.search = null
            this.query = null
            this.pathname = null
            this.path = null
            this.href = null
          }

          // Reference: RFC 3986, RFC 1808, RFC 2396

          // define these here so at least they only have to be
          // compiled once on the first module load.
          var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,
            // Special case for a simple path URL
            simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
            // RFC 2396: characters reserved for delimiting URLs.
            // We actually just auto-escape these.
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
            // RFC 2396: characters not allowed for various reasons.
            unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
            autoEscape = ["'"].concat(unwise),
            // Characters that are never ever allowed in a hostname.
            // Note that any invalid chars are also handled, but these
            // are the ones that are *expected* to be seen, so we fast-path
            // them.
            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
            hostEndingChars = ['/', '?', '#'],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
            // protocols that can allow "unsafe" and "unwise" chars.
            unsafeProtocol = {
              javascript: true,
              'javascript:': true,
            },
            // protocols that never have a hostname.
            hostlessProtocol = {
              javascript: true,
              'javascript:': true,
            },
            // protocols that always contain a // bit.
            slashedProtocol = {
              http: true,
              https: true,
              ftp: true,
              gopher: true,
              file: true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true,
            },
            querystring = __nested_webpack_require_340092__(
              /*! querystring */ './node_modules/querystring/index.js'
            )

          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url) return url

            var u = new Url()
            u.parse(url, parseQueryString, slashesDenoteHost)
            return u
          }

          Url.prototype.parse = function (
            url,
            parseQueryString,
            slashesDenoteHost
          ) {
            if (!util.isString(url)) {
              throw new TypeError(
                "Parameter 'url' must be a string, not " + typeof url
              )
            }

            // Copy chrome, IE, opera backslash-handling behavior.
            // Back slashes before the query string get converted to forward slashes
            // See: https://code.google.com/p/chromium/issues/detail?id=25916
            var queryIndex = url.indexOf('?'),
              splitter =
                queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
              uSplit = url.split(splitter),
              slashRegex = /\\/g
            uSplit[0] = uSplit[0].replace(slashRegex, '/')
            url = uSplit.join(splitter)

            var rest = url

            // trim before proceeding.
            // This is to support parse stuff like "  http://foo.com  \n"
            rest = rest.trim()

            if (!slashesDenoteHost && url.split('#').length === 1) {
              // Try fast path regexp
              var simplePath = simplePathPattern.exec(rest)
              if (simplePath) {
                this.path = rest
                this.href = rest
                this.pathname = simplePath[1]
                if (simplePath[2]) {
                  this.search = simplePath[2]
                  if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1))
                  } else {
                    this.query = this.search.substr(1)
                  }
                } else if (parseQueryString) {
                  this.search = ''
                  this.query = {}
                }
                return this
              }
            }

            var proto = protocolPattern.exec(rest)
            if (proto) {
              proto = proto[0]
              var lowerProto = proto.toLowerCase()
              this.protocol = lowerProto
              rest = rest.substr(proto.length)
            }

            // figure out if it's got a host
            // user@server is *always* interpreted as a hostname, and url
            // resolution will treat //foo/bar as host=foo,path=bar because that's
            // how the browser resolves relative URLs.
            if (
              slashesDenoteHost ||
              proto ||
              rest.match(/^\/\/[^@\/]+@[^@\/]+/)
            ) {
              var slashes = rest.substr(0, 2) === '//'
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2)
                this.slashes = true
              }
            }

            if (
              !hostlessProtocol[proto] &&
              (slashes || (proto && !slashedProtocol[proto]))
            ) {
              // there's a hostname.
              // the first instance of /, ?, ;, or # ends the host.
              //
              // If there is an @ in the hostname, then non-host chars *are* allowed
              // to the left of the last @ sign, unless some host-ending character
              // comes *before* the @-sign.
              // URLs are obnoxious.
              //
              // ex:
              // http://a@b@c/ => user:a@b host:c
              // http://a@b?@c => user:a host:c path:/?@c

              // v0.12 TODO(isaacs): This is not quite how Chrome does things.
              // Review our test case against browsers more comprehensively.

              // find the first instance of any hostEndingChars
              var hostEnd = -1
              for (var i = 0; i < hostEndingChars.length; i++) {
                var hec = rest.indexOf(hostEndingChars[i])
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec
              }

              // at this point, either we have an explicit point where the
              // auth portion cannot go past, or the last @ char is the decider.
              var auth, atSign
              if (hostEnd === -1) {
                // atSign can be anywhere.
                atSign = rest.lastIndexOf('@')
              } else {
                // atSign must be in auth portion.
                // http://a@b/c@d => host:b auth:a path:/c@d
                atSign = rest.lastIndexOf('@', hostEnd)
              }

              // Now we have a portion which is definitely the auth.
              // Pull that off.
              if (atSign !== -1) {
                auth = rest.slice(0, atSign)
                rest = rest.slice(atSign + 1)
                this.auth = decodeURIComponent(auth)
              }

              // the host is the remaining to the left of the first non-host char
              hostEnd = -1
              for (var i = 0; i < nonHostChars.length; i++) {
                var hec = rest.indexOf(nonHostChars[i])
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec
              }
              // if we still have not hit it, then the entire thing is a host.
              if (hostEnd === -1) hostEnd = rest.length

              this.host = rest.slice(0, hostEnd)
              rest = rest.slice(hostEnd)

              // pull out port.
              this.parseHost()

              // we've indicated that there is a hostname,
              // so even if it's empty, it has to be present.
              this.hostname = this.hostname || ''

              // if hostname begins with [ and ends with ]
              // assume that it's an IPv6 address.
              var ipv6Hostname =
                this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']'

              // validate a little.
              if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./)
                for (var i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i]
                  if (!part) continue
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = ''
                    for (var j = 0, k = part.length; j < k; j++) {
                      if (part.charCodeAt(j) > 127) {
                        // we replace non-ASCII char with a temporary placeholder
                        // we need this to make sure size of hostname is not
                        // broken by replacing non-ASCII by nothing
                        newpart += 'x'
                      } else {
                        newpart += part[j]
                      }
                    }
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i)
                      var notHost = hostparts.slice(i + 1)
                      var bit = part.match(hostnamePartStart)
                      if (bit) {
                        validParts.push(bit[1])
                        notHost.unshift(bit[2])
                      }
                      if (notHost.length) {
                        rest = '/' + notHost.join('.') + rest
                      }
                      this.hostname = validParts.join('.')
                      break
                    }
                  }
                }
              }

              if (this.hostname.length > hostnameMaxLen) {
                this.hostname = ''
              } else {
                // hostnames are always lower case.
                this.hostname = this.hostname.toLowerCase()
              }

              if (!ipv6Hostname) {
                // IDNA Support: Returns a punycoded representation of "domain".
                // It only converts parts of the domain name that
                // have non-ASCII characters, i.e. it doesn't matter if
                // you call it with a domain that already is ASCII-only.
                this.hostname = punycode.toASCII(this.hostname)
              }

              var p = this.port ? ':' + this.port : ''
              var h = this.hostname || ''
              this.host = h + p
              this.href += this.host

              // strip [ and ] from the hostname
              // the host field still retains them, though
              if (ipv6Hostname) {
                this.hostname = this.hostname.substr(
                  1,
                  this.hostname.length - 2
                )
                if (rest[0] !== '/') {
                  rest = '/' + rest
                }
              }
            }

            // now rest is set to the post-host stuff.
            // chop off any delim chars.
            if (!unsafeProtocol[lowerProto]) {
              // First, make 100% sure that any "autoEscape" chars get
              // escaped, even if encodeURIComponent doesn't think they
              // need to be.
              for (var i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i]
                if (rest.indexOf(ae) === -1) continue
                var esc = encodeURIComponent(ae)
                if (esc === ae) {
                  esc = escape(ae)
                }
                rest = rest.split(ae).join(esc)
              }
            }

            // chop off from the tail first.
            var hash = rest.indexOf('#')
            if (hash !== -1) {
              // got a fragment string.
              this.hash = rest.substr(hash)
              rest = rest.slice(0, hash)
            }
            var qm = rest.indexOf('?')
            if (qm !== -1) {
              this.search = rest.substr(qm)
              this.query = rest.substr(qm + 1)
              if (parseQueryString) {
                this.query = querystring.parse(this.query)
              }
              rest = rest.slice(0, qm)
            } else if (parseQueryString) {
              // no query string, but parseQueryString still requested
              this.search = ''
              this.query = {}
            }
            if (rest) this.pathname = rest
            if (
              slashedProtocol[lowerProto] &&
              this.hostname &&
              !this.pathname
            ) {
              this.pathname = '/'
            }

            //to support http.request
            if (this.pathname || this.search) {
              var p = this.pathname || ''
              var s = this.search || ''
              this.path = p + s
            }

            // finally, reconstruct the href based on what has been validated.
            this.href = this.format()
            return this
          }

          // format a parsed object into a url string
          function urlFormat(obj) {
            // ensure it's an object, and not a string url.
            // If it's an obj, this is a no-op.
            // this way, you can call url_format() on strings
            // to clean up potentially wonky urls.
            if (util.isString(obj)) obj = urlParse(obj)
            if (!(obj instanceof Url)) return Url.prototype.format.call(obj)
            return obj.format()
          }

          Url.prototype.format = function () {
            var auth = this.auth || ''
            if (auth) {
              auth = encodeURIComponent(auth)
              auth = auth.replace(/%3A/i, ':')
              auth += '@'
            }

            var protocol = this.protocol || '',
              pathname = this.pathname || '',
              hash = this.hash || '',
              host = false,
              query = ''

            if (this.host) {
              host = auth + this.host
            } else if (this.hostname) {
              host =
                auth +
                (this.hostname.indexOf(':') === -1
                  ? this.hostname
                  : '[' + this.hostname + ']')
              if (this.port) {
                host += ':' + this.port
              }
            }

            if (
              this.query &&
              util.isObject(this.query) &&
              Object.keys(this.query).length
            ) {
              query = querystring.stringify(this.query)
            }

            var search = this.search || (query && '?' + query) || ''

            if (protocol && protocol.substr(-1) !== ':') protocol += ':'

            // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
            // unless they had them to begin with.
            if (
              this.slashes ||
              ((!protocol || slashedProtocol[protocol]) && host !== false)
            ) {
              host = '//' + (host || '')
              if (pathname && pathname.charAt(0) !== '/')
                pathname = '/' + pathname
            } else if (!host) {
              host = ''
            }

            if (hash && hash.charAt(0) !== '#') hash = '#' + hash
            if (search && search.charAt(0) !== '?') search = '?' + search

            pathname = pathname.replace(/[?#]/g, function (match) {
              return encodeURIComponent(match)
            })
            search = search.replace('#', '%23')

            return protocol + host + pathname + search + hash
          }

          function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative)
          }

          Url.prototype.resolve = function (relative) {
            return this.resolveObject(urlParse(relative, false, true)).format()
          }

          function urlResolveObject(source, relative) {
            if (!source) return relative
            return urlParse(source, false, true).resolveObject(relative)
          }

          Url.prototype.resolveObject = function (relative) {
            if (util.isString(relative)) {
              var rel = new Url()
              rel.parse(relative, false, true)
              relative = rel
            }

            var result = new Url()
            var tkeys = Object.keys(this)
            for (var tk = 0; tk < tkeys.length; tk++) {
              var tkey = tkeys[tk]
              result[tkey] = this[tkey]
            }

            // hash is always overridden, no matter what.
            // even href="" will remove it.
            result.hash = relative.hash

            // if the relative url is empty, then there's nothing left to do here.
            if (relative.href === '') {
              result.href = result.format()
              return result
            }

            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative.protocol) {
              // take everything except the protocol from relative
              var rkeys = Object.keys(relative)
              for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk]
                if (rkey !== 'protocol') result[rkey] = relative[rkey]
              }

              //urlParse appends trailing / to urls like http://www.example.com
              if (
                slashedProtocol[result.protocol] &&
                result.hostname &&
                !result.pathname
              ) {
                result.path = result.pathname = '/'
              }

              result.href = result.format()
              return result
            }

            if (relative.protocol && relative.protocol !== result.protocol) {
              // if it's a known url protocol, then changing
              // the protocol does weird things
              // first, if it's not file:, then we MUST have a host,
              // and if there was a path
              // to begin with, then we MUST have a path.
              // if it is file:, then the host is dropped,
              // because that's known to be hostless.
              // anything else is assumed to be absolute.
              if (!slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative)
                for (var v = 0; v < keys.length; v++) {
                  var k = keys[v]
                  result[k] = relative[k]
                }
                result.href = result.format()
                return result
              }

              result.protocol = relative.protocol
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/')
                while (relPath.length && !(relative.host = relPath.shift()));
                if (!relative.host) relative.host = ''
                if (!relative.hostname) relative.hostname = ''
                if (relPath[0] !== '') relPath.unshift('')
                if (relPath.length < 2) relPath.unshift('')
                result.pathname = relPath.join('/')
              } else {
                result.pathname = relative.pathname
              }
              result.search = relative.search
              result.query = relative.query
              result.host = relative.host || ''
              result.auth = relative.auth
              result.hostname = relative.hostname || relative.host
              result.port = relative.port
              // to support http.request
              if (result.pathname || result.search) {
                var p = result.pathname || ''
                var s = result.search || ''
                result.path = p + s
              }
              result.slashes = result.slashes || relative.slashes
              result.href = result.format()
              return result
            }

            var isSourceAbs =
                result.pathname && result.pathname.charAt(0) === '/',
              isRelAbs =
                relative.host ||
                (relative.pathname && relative.pathname.charAt(0) === '/'),
              mustEndAbs =
                isRelAbs || isSourceAbs || (result.host && relative.pathname),
              removeAllDots = mustEndAbs,
              srcPath = (result.pathname && result.pathname.split('/')) || [],
              relPath =
                (relative.pathname && relative.pathname.split('/')) || [],
              psychotic = result.protocol && !slashedProtocol[result.protocol]

            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // result.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {
              result.hostname = ''
              result.port = null
              if (result.host) {
                if (srcPath[0] === '') srcPath[0] = result.host
                else srcPath.unshift(result.host)
              }
              result.host = ''
              if (relative.protocol) {
                relative.hostname = null
                relative.port = null
                if (relative.host) {
                  if (relPath[0] === '') relPath[0] = relative.host
                  else relPath.unshift(relative.host)
                }
                relative.host = null
              }
              mustEndAbs =
                mustEndAbs && (relPath[0] === '' || srcPath[0] === '')
            }

            if (isRelAbs) {
              // it's absolute.
              result.host =
                relative.host || relative.host === ''
                  ? relative.host
                  : result.host
              result.hostname =
                relative.hostname || relative.hostname === ''
                  ? relative.hostname
                  : result.hostname
              result.search = relative.search
              result.query = relative.query
              srcPath = relPath
              // fall through to the dot-handling below.
            } else if (relPath.length) {
              // it's relative
              // throw away the existing file, and take the new path instead.
              if (!srcPath) srcPath = []
              srcPath.pop()
              srcPath = srcPath.concat(relPath)
              result.search = relative.search
              result.query = relative.query
            } else if (!util.isNullOrUndefined(relative.search)) {
              // just pull out the search.
              // like href='?foo'.
              // Put this after the other two cases because it simplifies the booleans
              if (psychotic) {
                result.hostname = result.host = srcPath.shift()
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost =
                  result.host && result.host.indexOf('@') > 0
                    ? result.host.split('@')
                    : false
                if (authInHost) {
                  result.auth = authInHost.shift()
                  result.host = result.hostname = authInHost.shift()
                }
              }
              result.search = relative.search
              result.query = relative.query
              //to support http.request
              if (
                !util.isNull(result.pathname) ||
                !util.isNull(result.search)
              ) {
                result.path =
                  (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '')
              }
              result.href = result.format()
              return result
            }

            if (!srcPath.length) {
              // no path at all.  easy.
              // we've already handled the other stuff above.
              result.pathname = null
              //to support http.request
              if (result.search) {
                result.path = '/' + result.search
              } else {
                result.path = null
              }
              result.href = result.format()
              return result
            }

            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0]
            var hasTrailingSlash =
              ((result.host || relative.host || srcPath.length > 1) &&
                (last === '.' || last === '..')) ||
              last === ''

            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0
            for (var i = srcPath.length; i >= 0; i--) {
              last = srcPath[i]
              if (last === '.') {
                srcPath.splice(i, 1)
              } else if (last === '..') {
                srcPath.splice(i, 1)
                up++
              } else if (up) {
                srcPath.splice(i, 1)
                up--
              }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift('..')
              }
            }

            if (
              mustEndAbs &&
              srcPath[0] !== '' &&
              (!srcPath[0] || srcPath[0].charAt(0) !== '/')
            ) {
              srcPath.unshift('')
            }

            if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
              srcPath.push('')
            }

            var isAbsolute =
              srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/')

            // put the host back
            if (psychotic) {
              result.hostname = result.host = isAbsolute
                ? ''
                : srcPath.length
                ? srcPath.shift()
                : ''
              //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost =
                result.host && result.host.indexOf('@') > 0
                  ? result.host.split('@')
                  : false
              if (authInHost) {
                result.auth = authInHost.shift()
                result.host = result.hostname = authInHost.shift()
              }
            }

            mustEndAbs = mustEndAbs || (result.host && srcPath.length)

            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift('')
            }

            if (!srcPath.length) {
              result.pathname = null
              result.path = null
            } else {
              result.pathname = srcPath.join('/')
            }

            //to support request.http
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path =
                (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '')
            }
            result.auth = relative.auth || result.auth
            result.slashes = result.slashes || relative.slashes
            result.href = result.format()
            return result
          }

          Url.prototype.parseHost = function () {
            var host = this.host
            var port = portPattern.exec(host)
            if (port) {
              port = port[0]
              if (port !== ':') {
                this.port = port.substr(1)
              }
              host = host.substr(0, host.length - port.length)
            }
            if (host) this.hostname = host
          }

          /***/
        },

      /***/ './node_modules/url/util.js':
        /*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
        /***/ (module) => {
          'use strict'

          module.exports = {
            isString: function (arg) {
              return typeof arg === 'string'
            },
            isObject: function (arg) {
              return typeof arg === 'object' && arg !== null
            },
            isNull: function (arg) {
              return arg === null
            },
            isNullOrUndefined: function (arg) {
              return arg == null
            },
          }

          /***/
        },

      /***/ './node_modules/util/support/isBufferBrowser.js':
        /*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
        /***/ (module) => {
          module.exports = function isBuffer(arg) {
            return (
              arg &&
              typeof arg === 'object' &&
              typeof arg.copy === 'function' &&
              typeof arg.fill === 'function' &&
              typeof arg.readUInt8 === 'function'
            )
          }

          /***/
        },

      /***/ './node_modules/util/support/types.js':
        /*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_371976__) => {
          'use strict'
          // Currently in sync with Node.js lib/internal/util/types.js
          // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

          var isArgumentsObject = __nested_webpack_require_371976__(
            /*! is-arguments */ './node_modules/is-arguments/index.js'
          )
          var isGeneratorFunction = __nested_webpack_require_371976__(
            /*! is-generator-function */ './node_modules/is-generator-function/index.js'
          )
          var whichTypedArray = __nested_webpack_require_371976__(
            /*! which-typed-array */ './node_modules/which-typed-array/index.js'
          )
          var isTypedArray = __nested_webpack_require_371976__(
            /*! is-typed-array */ './node_modules/is-typed-array/index.js'
          )

          function uncurryThis(f) {
            return f.call.bind(f)
          }

          var BigIntSupported = typeof BigInt !== 'undefined'
          var SymbolSupported = typeof Symbol !== 'undefined'

          var ObjectToString = uncurryThis(Object.prototype.toString)

          var numberValue = uncurryThis(Number.prototype.valueOf)
          var stringValue = uncurryThis(String.prototype.valueOf)
          var booleanValue = uncurryThis(Boolean.prototype.valueOf)

          if (BigIntSupported) {
            var bigIntValue = uncurryThis(BigInt.prototype.valueOf)
          }

          if (SymbolSupported) {
            var symbolValue = uncurryThis(Symbol.prototype.valueOf)
          }

          function checkBoxedPrimitive(value, prototypeValueOf) {
            if (typeof value !== 'object') {
              return false
            }
            try {
              prototypeValueOf(value)
              return true
            } catch (e) {
              return false
            }
          }

          exports.isArgumentsObject = isArgumentsObject
          exports.isGeneratorFunction = isGeneratorFunction
          exports.isTypedArray = isTypedArray

          // Taken from here and modified for better browser support
          // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
          function isPromise(input) {
            return (
              (typeof Promise !== 'undefined' && input instanceof Promise) ||
              (input !== null &&
                typeof input === 'object' &&
                typeof input.then === 'function' &&
                typeof input.catch === 'function')
            )
          }
          exports.isPromise = isPromise

          function isArrayBufferView(value) {
            if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
              return ArrayBuffer.isView(value)
            }

            return isTypedArray(value) || isDataView(value)
          }
          exports.isArrayBufferView = isArrayBufferView

          function isUint8Array(value) {
            return whichTypedArray(value) === 'Uint8Array'
          }
          exports.isUint8Array = isUint8Array

          function isUint8ClampedArray(value) {
            return whichTypedArray(value) === 'Uint8ClampedArray'
          }
          exports.isUint8ClampedArray = isUint8ClampedArray

          function isUint16Array(value) {
            return whichTypedArray(value) === 'Uint16Array'
          }
          exports.isUint16Array = isUint16Array

          function isUint32Array(value) {
            return whichTypedArray(value) === 'Uint32Array'
          }
          exports.isUint32Array = isUint32Array

          function isInt8Array(value) {
            return whichTypedArray(value) === 'Int8Array'
          }
          exports.isInt8Array = isInt8Array

          function isInt16Array(value) {
            return whichTypedArray(value) === 'Int16Array'
          }
          exports.isInt16Array = isInt16Array

          function isInt32Array(value) {
            return whichTypedArray(value) === 'Int32Array'
          }
          exports.isInt32Array = isInt32Array

          function isFloat32Array(value) {
            return whichTypedArray(value) === 'Float32Array'
          }
          exports.isFloat32Array = isFloat32Array

          function isFloat64Array(value) {
            return whichTypedArray(value) === 'Float64Array'
          }
          exports.isFloat64Array = isFloat64Array

          function isBigInt64Array(value) {
            return whichTypedArray(value) === 'BigInt64Array'
          }
          exports.isBigInt64Array = isBigInt64Array

          function isBigUint64Array(value) {
            return whichTypedArray(value) === 'BigUint64Array'
          }
          exports.isBigUint64Array = isBigUint64Array

          function isMapToString(value) {
            return ObjectToString(value) === '[object Map]'
          }
          isMapToString.working =
            typeof Map !== 'undefined' && isMapToString(new Map())

          function isMap(value) {
            if (typeof Map === 'undefined') {
              return false
            }

            return isMapToString.working
              ? isMapToString(value)
              : value instanceof Map
          }
          exports.isMap = isMap

          function isSetToString(value) {
            return ObjectToString(value) === '[object Set]'
          }
          isSetToString.working =
            typeof Set !== 'undefined' && isSetToString(new Set())
          function isSet(value) {
            if (typeof Set === 'undefined') {
              return false
            }

            return isSetToString.working
              ? isSetToString(value)
              : value instanceof Set
          }
          exports.isSet = isSet

          function isWeakMapToString(value) {
            return ObjectToString(value) === '[object WeakMap]'
          }
          isWeakMapToString.working =
            typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap())
          function isWeakMap(value) {
            if (typeof WeakMap === 'undefined') {
              return false
            }

            return isWeakMapToString.working
              ? isWeakMapToString(value)
              : value instanceof WeakMap
          }
          exports.isWeakMap = isWeakMap

          function isWeakSetToString(value) {
            return ObjectToString(value) === '[object WeakSet]'
          }
          isWeakSetToString.working =
            typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet())
          function isWeakSet(value) {
            return isWeakSetToString(value)
          }
          exports.isWeakSet = isWeakSet

          function isArrayBufferToString(value) {
            return ObjectToString(value) === '[object ArrayBuffer]'
          }
          isArrayBufferToString.working =
            typeof ArrayBuffer !== 'undefined' &&
            isArrayBufferToString(new ArrayBuffer())
          function isArrayBuffer(value) {
            if (typeof ArrayBuffer === 'undefined') {
              return false
            }

            return isArrayBufferToString.working
              ? isArrayBufferToString(value)
              : value instanceof ArrayBuffer
          }
          exports.isArrayBuffer = isArrayBuffer

          function isDataViewToString(value) {
            return ObjectToString(value) === '[object DataView]'
          }
          isDataViewToString.working =
            typeof ArrayBuffer !== 'undefined' &&
            typeof DataView !== 'undefined' &&
            isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
          function isDataView(value) {
            if (typeof DataView === 'undefined') {
              return false
            }

            return isDataViewToString.working
              ? isDataViewToString(value)
              : value instanceof DataView
          }
          exports.isDataView = isDataView

          function isSharedArrayBufferToString(value) {
            return ObjectToString(value) === '[object SharedArrayBuffer]'
          }
          isSharedArrayBufferToString.working =
            typeof SharedArrayBuffer !== 'undefined' &&
            isSharedArrayBufferToString(new SharedArrayBuffer())
          function isSharedArrayBuffer(value) {
            if (typeof SharedArrayBuffer === 'undefined') {
              return false
            }

            return isSharedArrayBufferToString.working
              ? isSharedArrayBufferToString(value)
              : value instanceof SharedArrayBuffer
          }
          exports.isSharedArrayBuffer = isSharedArrayBuffer

          function isAsyncFunction(value) {
            return ObjectToString(value) === '[object AsyncFunction]'
          }
          exports.isAsyncFunction = isAsyncFunction

          function isMapIterator(value) {
            return ObjectToString(value) === '[object Map Iterator]'
          }
          exports.isMapIterator = isMapIterator

          function isSetIterator(value) {
            return ObjectToString(value) === '[object Set Iterator]'
          }
          exports.isSetIterator = isSetIterator

          function isGeneratorObject(value) {
            return ObjectToString(value) === '[object Generator]'
          }
          exports.isGeneratorObject = isGeneratorObject

          function isWebAssemblyCompiledModule(value) {
            return ObjectToString(value) === '[object WebAssembly.Module]'
          }
          exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule

          function isNumberObject(value) {
            return checkBoxedPrimitive(value, numberValue)
          }
          exports.isNumberObject = isNumberObject

          function isStringObject(value) {
            return checkBoxedPrimitive(value, stringValue)
          }
          exports.isStringObject = isStringObject

          function isBooleanObject(value) {
            return checkBoxedPrimitive(value, booleanValue)
          }
          exports.isBooleanObject = isBooleanObject

          function isBigIntObject(value) {
            return BigIntSupported && checkBoxedPrimitive(value, bigIntValue)
          }
          exports.isBigIntObject = isBigIntObject

          function isSymbolObject(value) {
            return SymbolSupported && checkBoxedPrimitive(value, symbolValue)
          }
          exports.isSymbolObject = isSymbolObject

          function isBoxedPrimitive(value) {
            return (
              isNumberObject(value) ||
              isStringObject(value) ||
              isBooleanObject(value) ||
              isBigIntObject(value) ||
              isSymbolObject(value)
            )
          }
          exports.isBoxedPrimitive = isBoxedPrimitive

          function isAnyArrayBuffer(value) {
            return (
              typeof Uint8Array !== 'undefined' &&
              (isArrayBuffer(value) || isSharedArrayBuffer(value))
            )
          }
          exports.isAnyArrayBuffer = isAnyArrayBuffer
          ;['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(
            function (method) {
              Object.defineProperty(exports, method, {
                enumerable: false,
                value: function () {
                  throw new Error(method + ' is not supported in userland')
                },
              })
            }
          )

          /***/
        },

      /***/ './node_modules/util/util.js':
        /*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
        /***/ (__unused_webpack_module, exports, __nested_webpack_require_383545__) => {
          /* provided dependency */ var process = __nested_webpack_require_383545__(
            /*! process/browser */ './node_modules/process/browser.js'
          )
          /* provided dependency */ var console = __nested_webpack_require_383545__(
            /*! console-browserify */ './node_modules/console-browserify/index.js'
          )
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var getOwnPropertyDescriptors =
            Object.getOwnPropertyDescriptors ||
            function getOwnPropertyDescriptors(obj) {
              var keys = Object.keys(obj)
              var descriptors = {}
              for (var i = 0; i < keys.length; i++) {
                descriptors[keys[i]] = Object.getOwnPropertyDescriptor(
                  obj,
                  keys[i]
                )
              }
              return descriptors
            }

          var formatRegExp = /%[sdj%]/g
          exports.format = function (f) {
            if (!isString(f)) {
              var objects = []
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]))
              }
              return objects.join(' ')
            }

            var i = 1
            var args = arguments
            var len = args.length
            var str = String(f).replace(formatRegExp, function (x) {
              if (x === '%%') return '%'
              if (i >= len) return x
              switch (x) {
                case '%s':
                  return String(args[i++])
                case '%d':
                  return Number(args[i++])
                case '%j':
                  try {
                    return JSON.stringify(args[i++])
                  } catch (_) {
                    return '[Circular]'
                  }
                default:
                  return x
              }
            })
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x
              } else {
                str += ' ' + inspect(x)
              }
            }
            return str
          }

          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function (fn, msg) {
            if (
              typeof process !== 'undefined' &&
              process.noDeprecation === true
            ) {
              return fn
            }

            // Allow for deprecating things in the process of starting up.
            if (typeof process === 'undefined') {
              return function () {
                return exports.deprecate(fn, msg).apply(this, arguments)
              }
            }

            var warned = false
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg)
                } else if (process.traceDeprecation) {
                  console.trace(msg)
                } else {
                  console.error(msg)
                }
                warned = true
              }
              return fn.apply(this, arguments)
            }

            return deprecated
          }

          var debugs = {}
          var debugEnvRegex = /^$/

          if (process.env.NODE_DEBUG) {
            var debugEnv = process.env.NODE_DEBUG
            debugEnv = debugEnv
              .replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
              .replace(/\*/g, '.*')
              .replace(/,/g, '$|^')
              .toUpperCase()
            debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i')
          }
          exports.debuglog = function (set) {
            set = set.toUpperCase()
            if (!debugs[set]) {
              if (debugEnvRegex.test(set)) {
                var pid = process.pid
                debugs[set] = function () {
                  var msg = exports.format.apply(exports, arguments)
                  console.error('%s %d: %s', set, pid, msg)
                }
              } else {
                debugs[set] = function () {}
              }
            }
            return debugs[set]
          }

          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Object} opts Optional options object that alters the output.
           */
          /* legacy: obj, showHidden, depth, colors*/
          function inspect(obj, opts) {
            // default options
            var ctx = {
              seen: [],
              stylize: stylizeNoColor,
            }
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2]
            if (arguments.length >= 4) ctx.colors = arguments[3]
            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts
            } else if (opts) {
              // got an "options" object
              exports._extend(ctx, opts)
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false
            if (isUndefined(ctx.depth)) ctx.depth = 2
            if (isUndefined(ctx.colors)) ctx.colors = false
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true
            if (ctx.colors) ctx.stylize = stylizeWithColor
            return formatValue(ctx, obj, ctx.depth)
          }
          exports.inspect = inspect

          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39],
          }

          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            special: 'cyan',
            number: 'yellow',
            boolean: 'yellow',
            undefined: 'grey',
            null: 'bold',
            string: 'green',
            date: 'magenta',
            // "name": intentionally not styling
            regexp: 'red',
          }

          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType]

            if (style) {
              return (
                '\u001b[' +
                inspect.colors[style][0] +
                'm' +
                str +
                '\u001b[' +
                inspect.colors[style][1] +
                'm'
              )
            } else {
              return str
            }
          }

          function stylizeNoColor(str, styleType) {
            return str
          }

          function arrayToHash(array) {
            var hash = {}

            array.forEach(function (val, idx) {
              hash[val] = true
            })

            return hash
          }

          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (
              ctx.customInspect &&
              value &&
              isFunction(value.inspect) &&
              // Filter out the util module, it's inspect function is special
              value.inspect !== exports.inspect &&
              // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)
            ) {
              var ret = value.inspect(recurseTimes, ctx)
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes)
              }
              return ret
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value)
            if (primitive) {
              return primitive
            }

            // Look up the keys of the object.
            var keys = Object.keys(value)
            var visibleKeys = arrayToHash(keys)

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value)
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (
              isError(value) &&
              (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)
            ) {
              return formatError(value)
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : ''
                return ctx.stylize('[Function' + name + ']', 'special')
              }
              if (isRegExp(value)) {
                return ctx.stylize(
                  RegExp.prototype.toString.call(value),
                  'regexp'
                )
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date')
              }
              if (isError(value)) {
                return formatError(value)
              }
            }

            var base = '',
              array = false,
              braces = ['{', '}']

            // Make Array say that they are Array
            if (isArray(value)) {
              array = true
              braces = ['[', ']']
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : ''
              base = ' [Function' + n + ']'
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value)
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value)
            }

            // Make error with message first say the error
            if (isError(value)) {
              base = ' ' + formatError(value)
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1]
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(
                  RegExp.prototype.toString.call(value),
                  'regexp'
                )
              } else {
                return ctx.stylize('[Object]', 'special')
              }
            }

            ctx.seen.push(value)

            var output
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys)
            } else {
              output = keys.map(function (key) {
                return formatProperty(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  key,
                  array
                )
              })
            }

            ctx.seen.pop()

            return reduceToSingleString(output, base, braces)
          }

          function formatPrimitive(ctx, value) {
            if (isUndefined(value)) return ctx.stylize('undefined', 'undefined')
            if (isString(value)) {
              var simple =
                "'" +
                JSON.stringify(value)
                  .replace(/^"|"$/g, '')
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"') +
                "'"
              return ctx.stylize(simple, 'string')
            }
            if (isNumber(value)) return ctx.stylize('' + value, 'number')
            if (isBoolean(value)) return ctx.stylize('' + value, 'boolean')
            // For some reason typeof null is "object", so special case here.
            if (isNull(value)) return ctx.stylize('null', 'null')
          }

          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']'
          }

          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = []
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(
                  formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    String(i),
                    true
                  )
                )
              } else {
                output.push('')
              }
            }
            keys.forEach(function (key) {
              if (!key.match(/^\d+$/)) {
                output.push(
                  formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    true
                  )
                )
              }
            })
            return output
          }

          function formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            array
          ) {
            var name, str, desc
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key],
            }
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special')
              } else {
                str = ctx.stylize('[Getter]', 'special')
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special')
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']'
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null)
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1)
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str
                      .split('\n')
                      .map(function (line) {
                        return '  ' + line
                      })
                      .join('\n')
                      .substr(2)
                  } else {
                    str =
                      '\n' +
                      str
                        .split('\n')
                        .map(function (line) {
                          return '   ' + line
                        })
                        .join('\n')
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special')
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str
              }
              name = JSON.stringify('' + key)
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2)
                name = ctx.stylize(name, 'name')
              } else {
                name = name
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"')
                  .replace(/(^"|"$)/g, "'")
                name = ctx.stylize(name, 'string')
              }
            }

            return name + ': ' + str
          }

          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0
            var length = output.reduce(function (prev, cur) {
              numLinesEst++
              if (cur.indexOf('\n') >= 0) numLinesEst++
              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1
            }, 0)

            if (length > 60) {
              return (
                braces[0] +
                (base === '' ? '' : base + '\n ') +
                ' ' +
                output.join(',\n  ') +
                ' ' +
                braces[1]
              )
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]
          }

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          exports.types = __nested_webpack_require_383545__(
            /*! ./support/types */ './node_modules/util/support/types.js'
          )

          function isArray(ar) {
            return Array.isArray(ar)
          }
          exports.isArray = isArray

          function isBoolean(arg) {
            return typeof arg === 'boolean'
          }
          exports.isBoolean = isBoolean

          function isNull(arg) {
            return arg === null
          }
          exports.isNull = isNull

          function isNullOrUndefined(arg) {
            return arg == null
          }
          exports.isNullOrUndefined = isNullOrUndefined

          function isNumber(arg) {
            return typeof arg === 'number'
          }
          exports.isNumber = isNumber

          function isString(arg) {
            return typeof arg === 'string'
          }
          exports.isString = isString

          function isSymbol(arg) {
            return typeof arg === 'symbol'
          }
          exports.isSymbol = isSymbol

          function isUndefined(arg) {
            return arg === void 0
          }
          exports.isUndefined = isUndefined

          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]'
          }
          exports.isRegExp = isRegExp
          exports.types.isRegExp = isRegExp

          function isObject(arg) {
            return typeof arg === 'object' && arg !== null
          }
          exports.isObject = isObject

          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]'
          }
          exports.isDate = isDate
          exports.types.isDate = isDate

          function isError(e) {
            return (
              isObject(e) &&
              (objectToString(e) === '[object Error]' || e instanceof Error)
            )
          }
          exports.isError = isError
          exports.types.isNativeError = isError

          function isFunction(arg) {
            return typeof arg === 'function'
          }
          exports.isFunction = isFunction

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === 'boolean' ||
              typeof arg === 'number' ||
              typeof arg === 'string' ||
              typeof arg === 'symbol' || // ES6 symbol
              typeof arg === 'undefined'
            )
          }
          exports.isPrimitive = isPrimitive

          exports.isBuffer = __nested_webpack_require_383545__(
            /*! ./support/isBuffer */ './node_modules/util/support/isBufferBrowser.js'
          )

          function objectToString(o) {
            return Object.prototype.toString.call(o)
          }

          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10)
          }

          var months = [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec',
          ]

          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date()
            var time = [
              pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds()),
            ].join(':')
            return [d.getDate(), months[d.getMonth()], time].join(' ')
          }

          // log is just a thin wrapper to console.log that prepends a timestamp
          exports.log = function () {
            console.log(
              '%s - %s',
              timestamp(),
              exports.format.apply(exports, arguments)
            )
          }

          /**
           * Inherit the prototype methods from one constructor into another.
           *
           * The Function.prototype.inherits from lang.js rewritten as a standalone
           * function (not on Function.prototype). NOTE: If this file is to be loaded
           * during bootstrapping this function needs to be rewritten using some native
           * functions as prototype setup using normal JavaScript does not work as
           * expected during bootstrapping (see mirror.js in r114903).
           *
           * @param {function} ctor Constructor function which needs to inherit the
           *     prototype.
           * @param {function} superCtor Constructor function to inherit prototype from.
           */
          exports.inherits = __nested_webpack_require_383545__(
            /*! inherits */ './node_modules/inherits/inherits_browser.js'
          )

          exports._extend = function (origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin

            var keys = Object.keys(add)
            var i = keys.length
            while (i--) {
              origin[keys[i]] = add[keys[i]]
            }
            return origin
          }

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop)
          }

          var kCustomPromisifiedSymbol =
            typeof Symbol !== 'undefined'
              ? Symbol('util.promisify.custom')
              : undefined

          exports.promisify = function promisify(original) {
            if (typeof original !== 'function')
              throw new TypeError(
                'The "original" argument must be of type Function'
              )

            if (
              kCustomPromisifiedSymbol &&
              original[kCustomPromisifiedSymbol]
            ) {
              var fn = original[kCustomPromisifiedSymbol]
              if (typeof fn !== 'function') {
                throw new TypeError(
                  'The "util.promisify.custom" argument must be of type Function'
                )
              }
              Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn,
                enumerable: false,
                writable: false,
                configurable: true,
              })
              return fn
            }

            function fn() {
              var promiseResolve, promiseReject
              var promise = new Promise(function (resolve, reject) {
                promiseResolve = resolve
                promiseReject = reject
              })

              var args = []
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i])
              }
              args.push(function (err, value) {
                if (err) {
                  promiseReject(err)
                } else {
                  promiseResolve(value)
                }
              })

              try {
                original.apply(this, args)
              } catch (err) {
                promiseReject(err)
              }

              return promise
            }

            Object.setPrototypeOf(fn, Object.getPrototypeOf(original))

            if (kCustomPromisifiedSymbol)
              Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn,
                enumerable: false,
                writable: false,
                configurable: true,
              })
            return Object.defineProperties(
              fn,
              getOwnPropertyDescriptors(original)
            )
          }

          exports.promisify.custom = kCustomPromisifiedSymbol

          function callbackifyOnRejected(reason, cb) {
            // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
            // Because `null` is a special error value in callbacks which means "no error
            // occurred", we error-wrap so the callback consumer can distinguish between
            // "the promise rejected with null" or "the promise fulfilled with undefined".
            if (!reason) {
              var newReason = new Error(
                'Promise was rejected with a falsy value'
              )
              newReason.reason = reason
              reason = newReason
            }
            return cb(reason)
          }

          function callbackify(original) {
            if (typeof original !== 'function') {
              throw new TypeError(
                'The "original" argument must be of type Function'
              )
            }

            // We DO NOT return the promise as it gives the user a false sense that
            // the promise is actually somehow related to the callback's execution
            // and that the callback throwing will reject the promise.
            function callbackified() {
              var args = []
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i])
              }

              var maybeCb = args.pop()
              if (typeof maybeCb !== 'function') {
                throw new TypeError(
                  'The last argument must be of type Function'
                )
              }
              var self = this
              var cb = function () {
                return maybeCb.apply(self, arguments)
              }
              // In true node style we process the callback on `nextTick` with all the
              // implications (stack, `uncaughtException`, `async_hooks`)
              original.apply(this, args).then(
                function (ret) {
                  process.nextTick(cb.bind(null, null, ret))
                },
                function (rej) {
                  process.nextTick(callbackifyOnRejected.bind(null, rej, cb))
                }
              )
            }

            Object.setPrototypeOf(
              callbackified,
              Object.getPrototypeOf(original)
            )
            Object.defineProperties(
              callbackified,
              getOwnPropertyDescriptors(original)
            )
            return callbackified
          }
          exports.callbackify = callbackify

          /***/
        },

      /***/ './node_modules/which-typed-array/index.js':
        /*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
        /***/ (module, __unused_webpack_exports, __nested_webpack_require_411900__) => {
          'use strict'

          var forEach = __nested_webpack_require_411900__(
            /*! foreach */ './node_modules/foreach/index.js'
          )
          var availableTypedArrays = __nested_webpack_require_411900__(
            /*! available-typed-arrays */ './node_modules/available-typed-arrays/index.js'
          )
          var callBound = __nested_webpack_require_411900__(
            /*! call-bind/callBound */ './node_modules/call-bind/callBound.js'
          )

          var $toString = callBound('Object.prototype.toString')
          var hasSymbols = __nested_webpack_require_411900__(
            /*! has-symbols */ './node_modules/has-symbols/index.js'
          )()
          var hasToStringTag =
            hasSymbols && typeof Symbol.toStringTag === 'symbol'

          var typedArrays = availableTypedArrays()

          var $slice = callBound('String.prototype.slice')
          var toStrTags = {}
          var gOPD = __nested_webpack_require_411900__(
            /*! es-abstract/helpers/getOwnPropertyDescriptor */ './node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js'
          )
          var getPrototypeOf = Object.getPrototypeOf // require('getprototypeof');
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function (typedArray) {
              if (typeof __nested_webpack_require_411900__.g[typedArray] === 'function') {
                var arr = new __nested_webpack_require_411900__.g[typedArray]()
                if (!(Symbol.toStringTag in arr)) {
                  throw new EvalError(
                    'this engine has support for Symbol.toStringTag, but ' +
                      typedArray +
                      ' does not have the property! Please report this.'
                  )
                }
                var proto = getPrototypeOf(arr)
                var descriptor = gOPD(proto, Symbol.toStringTag)
                if (!descriptor) {
                  var superProto = getPrototypeOf(proto)
                  descriptor = gOPD(superProto, Symbol.toStringTag)
                }
                toStrTags[typedArray] = descriptor.get
              }
            })
          }

          var tryTypedArrays = function tryAllTypedArrays(value) {
            var foundName = false
            forEach(toStrTags, function (getter, typedArray) {
              if (!foundName) {
                try {
                  var name = getter.call(value)
                  if (name === typedArray) {
                    foundName = name
                  }
                } catch (e) {}
              }
            })
            return foundName
          }

          var isTypedArray = __nested_webpack_require_411900__(
            /*! is-typed-array */ './node_modules/is-typed-array/index.js'
          )

          module.exports = function whichTypedArray(value) {
            if (!isTypedArray(value)) {
              return false
            }
            if (!hasToStringTag) {
              return $slice($toString(value), 8, -1)
            }
            return tryTypedArrays(value)
          }

          /***/
        },

      /******/
    } // The module cache
    /************************************************************************/
    /******/ /******/ var __webpack_module_cache__ = {} // The require function
    /******/
    /******/ /******/ function __nested_webpack_require_415200__(moduleId) {
      /******/ // Check if module is in cache
      /******/ var cachedModule = __webpack_module_cache__[moduleId]
      /******/ if (cachedModule !== undefined) {
        /******/ return cachedModule.exports
        /******/
      } // Create a new module (and put it into the cache)
      /******/ /******/ var module = (__webpack_module_cache__[moduleId] = {
        /******/ id: moduleId,
        /******/ loaded: false,
        /******/ exports: {},
        /******/
      }) // Execute the module function
      /******/
      /******/ /******/ __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nested_webpack_require_415200__
      ) // Flag the module as loaded
      /******/
      /******/ /******/ module.loaded = true // Return the exports of the module
      /******/
      /******/ /******/ return module.exports
      /******/
    } /* webpack/runtime/define property getters */ /******/
    /******/
    /************************************************************************/
    /******/ ;(() => {
      /******/ // define getter functions for harmony exports
      /******/ __nested_webpack_require_415200__.d = (exports, definition) => {
        /******/ for (var key in definition) {
          /******/ if (
            __nested_webpack_require_415200__.o(definition, key) &&
            !__nested_webpack_require_415200__.o(exports, key)
          ) {
            /******/ Object.defineProperty(exports, key, {
              enumerable: true,
              get: definition[key],
            })
            /******/
          }
          /******/
        }
        /******/
      }
      /******/
    })() /* webpack/runtime/global */ /******/
    /******/
    /******/
    ;(() => {
      /******/ __nested_webpack_require_415200__.g = (function () {
        /******/ if (typeof globalThis === 'object') return globalThis
        /******/ try {
          /******/ return this || new Function('return this')()
          /******/
        } catch (e) {
          /******/ if (typeof window === 'object') return window
          /******/
        }
        /******/
      })()
      /******/
    })() /* webpack/runtime/hasOwnProperty shorthand */ /******/
    /******/
    /******/
    ;(() => {
      /******/ __nested_webpack_require_415200__.o = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop)
      /******/
    })() /* webpack/runtime/make namespace object */ /******/
    /******/
    /******/
    ;(() => {
      /******/ // define __esModule on exports
      /******/ __nested_webpack_require_415200__.r = (exports) => {
        /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/ Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module',
          })
          /******/
        }
        /******/ Object.defineProperty(exports, '__esModule', { value: true })
        /******/
      }
      /******/
    })() /* webpack/runtime/node module decorator */ /******/
    /******/
    /******/
    ;(() => {
      /******/ __nested_webpack_require_415200__.nmd = (module) => {
        /******/ module.paths = []
        /******/ if (!module.children) module.children = []
        /******/ return module
        /******/
      }
      /******/
    })()
    /******/
    /************************************************************************/
    var __webpack_exports__ = {}
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    ;(() => {
      'use strict'
      var exports = __webpack_exports__
      /*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.ImgurClient = void 0
      var client_1 = __nested_webpack_require_415200__(/*! ./client */ './src/client.ts')
      Object.defineProperty(exports, 'ImgurClient', {
        enumerable: true,
        get: function () {
          return client_1.ImgurClient
        },
      })
    })()

    /******/ return __webpack_exports__
    /******/
  })()
})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWd1ci1hcGkvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9hcnJheS1maWx0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9lczYtb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaXMtbmFuL3BvbHlmaWxsLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvYWxidW0vZ2V0QWxidW0udHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2FsYnVtL2luZGV4LnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2NvbW1vbi90eXBlcy50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvY29tbW9uL3V0aWxzLnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9nYWxsZXJ5L2dldEdhbGxlcnkudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2dhbGxlcnkvZ2V0U3VicmVkZGl0R2FsbGVyeS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvZ2FsbGVyeS9pbmRleC50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvZ2FsbGVyeS9zZWFyY2hHYWxsZXJ5LnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9nZXRBdXRob3JpemF0aW9uSGVhZGVyLnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9pbWFnZS9kZWxldGVJbWFnZS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvaW1hZ2UvZmF2b3JpdGVJbWFnZS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvaW1hZ2UvZ2V0SW1hZ2UudHMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2ltYWdlL2luZGV4LnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL3NyYy9pbWFnZS91cGRhdGVJbWFnZS50cyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9zcmMvaW1hZ2UvdXBsb2FkLnRzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovL2ltZ3VyLWFwaS8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9pbWd1ci1hcGkvLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ltZ3VyLWFwaS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vaW1ndXItYXBpLy4vc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLHVCQUF1QiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRTdWLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGVBQWUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHlHQUFtQzs7QUFFaEUsZ0JBQWdCLG1CQUFPLENBQUMsMENBQU87QUFDL0I7O0FBRUEscUJBQXFCLHFFQUFzQjtBQUMzQztBQUNBOztBQUVBLG1EQUFtRCxnR0FBbUM7QUFDdEYsdUNBQXVDLG1CQUFPLENBQUMsb0RBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkZBQTZCOztBQUV4RDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQixPQUFPLGVBQWUsT0FBTyxlQUFlLE9BQU8sV0FBVyxPQUFPO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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ZDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEk7Ozs7O1dDUEQsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFOzs7Ozs7Ozs7Ozs7Ozs7QUNKQSxzRUFBdUM7QUFBOUIsaUhBQVciLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0Ly9Db21tb25KUzIgQ29tbWVudFxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdC8vQU1EIENvbW1lbnRcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0Ly9Db21tb25KUyBDb21tZW50XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbWd1clwiXSA9IGZhY3RvcnkoKTtcblx0Ly9Sb290IENvbW1lbnRcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbWd1clwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCJcbi8qKlxuICogQXJyYXkjZmlsdGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2VsZlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAdGhyb3cgVHlwZUVycm9yXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBmbiwgc2VsZikge1xuICBpZiAoYXJyLmZpbHRlcikgcmV0dXJuIGFyci5maWx0ZXIoZm4sIHNlbGYpO1xuICBpZiAodm9pZCAwID09PSBhcnIgfHwgbnVsbCA9PT0gYXJyKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKGFyciwgaSkpIGNvbnRpbnVlO1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGZuLmNhbGwoc2VsZiwgdmFsLCBpLCBhcnIpKSByZXQucHVzaCh2YWwpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lcnJvcnMnKSxcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUztcblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yJyk7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsLycpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogcmVxdWlyZSgnZXM2LW9iamVjdC1hc3NpZ24nKS5hc3NpZ247XG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSByZXF1aXJlKCcuL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMnKTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdO1xuXG52YXIgZXNjYXBlRm4gPSBmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xufTtcblxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuXG4gIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XG4gIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGlmICh3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nID8gcHJvY2Vzcy5lbWl0V2FybmluZyA6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgd2FybignYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwOTQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuXG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcblxuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblxuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufSAvLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuXG5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5vayA9IG9rOyAvLyBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGggPT0uXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuXG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cblxuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxuXG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBleHBlY3RlZFtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gIHJldHVybiBpc1Byb21pc2Uob2JqKSB8fCBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7IC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHBlY3RzRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgIHZhciBkZXRhaWxzID0gJyc7XG5cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlcnJvciAmJiAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWVycm9yIHx8IGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0JyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBhY3R1YWw7XG59XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcblxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxuICAgIH0pOyAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXG4gICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdG1wMi5zaGlmdCgpOyAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pO1xuXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3RXJyO1xuICB9XG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG5cbmZ1bmN0aW9uIHN0cmljdCgpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4ndXNlIHN0cmljdCc7IC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcblxuICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgIGluc3BlY3RlZCA9IFwiXCIuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCBcIi4uLlwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGlucHV0LCBcIiB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCJcIikgKyBcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlLCBcIi5cIik7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYW5kIFwiKS5jb25jYXQoYXJnc1sxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xuXG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZSgnaXMtbmFuJyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gICAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1NykgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cblxuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoaXNOb25JbmRleCkuY29uY2F0KG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkuZmlsdGVyKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSkpKTtcbn0gLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIE9OTFlfRU5VTUVSQUJMRSA9IHVuZGVmaW5lZDtcbnZhciBrU3RyaWN0ID0gdHJ1ZTtcbnZhciBrTG9vc2UgPSBmYWxzZTtcbnZhciBrTm9JdGVyYXRvciA9IDA7XG52YXIga0lzQXJyYXkgPSAxO1xudmFyIGtJc1NldCA9IDI7XG52YXIga0lzTWFwID0gMzsgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcbi8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbi8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG4vLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4vLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXG4vL1xuLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXG4vLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4vLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxuLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbi8vXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcbi8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cblxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcblxuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXG4gICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XG4gIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgLy8gd2FuJ3QgdG8gZWFybHkgcmV0dXJuIG91dCBvZiB0aGUgcmVzdCBvZiB0aGUgY2hlY2tzLiBIb3dldmVyIHdlIGNhbiBjaGVja1xuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEYXRlKHZhbDEpKSB7XG4gICAgaWYgKCFpc0RhdGUodmFsMikgfHwgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDEpICE9PSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgIC8vIGlzIG90aGVyd2lzZSBpZGVudGljYWwuXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XG4gICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cblxuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoX2tleXMubGVuZ3RoICE9PSBfa2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcCk7XG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgIGlmICghYXJlRXF1YWxBcnJheUJ1ZmZlcnModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWwxKSAmJiAhaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcbiAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcblxuICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBVc2UgbWVtb3MgdG8gaGFuZGxlIGN5Y2xlcy5cblxuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG5cbiAgICBpZiAodmFsMk1lbW9BICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcblxuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG5cbiAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pO1xuICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbik7XG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcbiAgbWVtb3MudmFsMS5kZWxldGUodmFsMSk7XG4gIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpO1xuICByZXR1cm4gYXJlRXE7XG59XG5cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG5cbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XG4gIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwcmltID0gK3ByaW07XG4gICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG5cbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYWx0VmFsdWU7XG4gIH1cblxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcblxuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXG4gICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuXG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAhYS5oYXMoX3ZhbCkgJiYgIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRvIGJlIGFibGUgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAga2V5ID0gX2FFbnRyaWVzJGlbMF0sXG4gICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG5cbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlIHdlIHByZXZlbnQgYW5vdGhlciBiLmhhcyhrZXkpIGNoZWNrIGluXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KTtcblxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KGtleSksIGl0ZW0sIGZhbHNlLCBtZW1vKSkgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG5cbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzQVtpXTtcblxuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gIGlzRGVlcFN0cmljdEVxdWFsOiBpc0RlZXBTdHJpY3RFcXVhbFxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmaWx0ZXIgPSByZXF1aXJlKCdhcnJheS1maWx0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0cmV0dXJuIGZpbHRlcihbXG5cdFx0J0JpZ0ludDY0QXJyYXknLFxuXHRcdCdCaWdVaW50NjRBcnJheScsXG5cdFx0J0Zsb2F0MzJBcnJheScsXG5cdFx0J0Zsb2F0NjRBcnJheScsXG5cdFx0J0ludDE2QXJyYXknLFxuXHRcdCdJbnQzMkFycmF5Jyxcblx0XHQnSW50OEFycmF5Jyxcblx0XHQnVWludDE2QXJyYXknLFxuXHRcdCdVaW50MzJBcnJheScsXG5cdFx0J1VpbnQ4QXJyYXknLFxuXHRcdCdVaW50OENsYW1wZWRBcnJheSdcblx0XSwgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGdsb2JhbFt0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJztcblx0fSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IodGltZW91dEVycm9yTWVzc2FnZSwgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvYmogPSB7fTtcblx0dHJ5IHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSk7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRcdGZvciAodmFyIF8gaW4gb2JqKSB7IC8vIGpzY3M6aWdub3JlIGRpc2FsbG93VW51c2VkVmFyaWFibGVzXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBvYmoueCA9PT0gb2JqO1xuXHR9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgSUUgOC4gKi9cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkKCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7XG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJyk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZmlyc3RTb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XG4gICAgICB2YXIgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhc3NpZ25cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ24sXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnID8gc2VsZi5Gb3JtRGF0YSA6IHdpbmRvdy5Gb3JtRGF0YTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbikge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG52YXIgR2VuZXJhdG9yRnVuY3Rpb24gPSBnZXRQcm90byAmJiBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byAmJiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdsb2JhbFt0eXBlZEFycmF5XSgpO1xuXHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXZhbEVycm9yKCd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArIHR5cGVkQXJyYXkgKyAnIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuJyk7XG5cdFx0fVxuXHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdH1cblx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBhbnlUcnVlID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFhbnlUcnVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhbnlUcnVlID0gZ2V0dGVyLmNhbGwodmFsdWUpID09PSB0eXBlZEFycmF5O1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gYW55VHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiaW1wb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuLi9jbGllbnQnO1xuaW1wb3J0IHsgQUxCVU1fRU5EUE9JTlQgfSBmcm9tICcuLi9jb21tb24vZW5kcG9pbnRzJztcbmltcG9ydCB7IEltZ3VyQXBpUmVzcG9uc2UsIEFsYnVtRGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsYnVtKFxuICBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBhbGJ1bUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPEFsYnVtRGF0YT4+IHtcbiAgY29uc3QgdXJsID0gYCR7QUxCVU1fRU5EUE9JTlR9LyR7YWxidW1IYXNofWA7XG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHt1cmx9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTxBbGJ1bURhdGE+O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9nZXRBbGJ1bSc7XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgZ2V0QXV0aG9yaXphdGlvbkhlYWRlciB9IGZyb20gJy4vZ2V0QXV0aG9yaXphdGlvbkhlYWRlcic7XG5pbXBvcnQge1xuICBkZWxldGVJbWFnZSxcbiAgZmF2b3JpdGVJbWFnZSxcbiAgZ2V0SW1hZ2UsXG4gIHVwbG9hZCxcbiAgdXBkYXRlSW1hZ2UsXG4gIFVwZGF0ZUltYWdlUGF5bG9hZCxcbn0gZnJvbSAnLi9pbWFnZSc7XG5pbXBvcnQge1xuICBHYWxsZXJ5T3B0aW9ucyxcbiAgZ2V0R2FsbGVyeSxcbiAgZ2V0U3VicmVkZGl0R2FsbGVyeSxcbiAgU3VicmVkZGl0R2FsbGVyeU9wdGlvbnMsXG4gIHNlYXJjaEdhbGxlcnksXG4gIFNlYXJjaEdhbGxlcnlPcHRpb25zLFxufSBmcm9tICcuL2dhbGxlcnknO1xuaW1wb3J0IHsgZ2V0QWxidW0gfSBmcm9tICcuL2FsYnVtJztcbmltcG9ydCB7IElNR1VSX0FQSV9QUkVGSVggfSBmcm9tICcuL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHtcbiAgQWxidW1EYXRhLFxuICBDcmVkZW50aWFscyxcbiAgR2FsbGVyeURhdGEsXG4gIEltYWdlRGF0YSxcbiAgSW1ndXJBcGlSZXNwb25zZSxcbiAgUGF5bG9hZCxcbn0gZnJvbSAnLi9jb21tb24vdHlwZXMnO1xuXG5jb25zdCBVU0VSQUdFTlQgPSAnaW1ndXIvbmV4dCAoaHR0cHM6Ly9naXRodWIuY29tL2thaW1hbGxlYS9ub2RlLWltZ3VyKSc7XG5cbmltcG9ydCBheGlvcywgeyBBeGlvc0luc3RhbmNlLCBBeGlvc1Jlc3BvbnNlLCBBeGlvc1JlcXVlc3RDb25maWcgfSBmcm9tICdheGlvcyc7XG5cbmV4cG9ydCBjbGFzcyBJbWd1ckNsaWVudCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgcGxhaW5GZXRjaGVyOiBBeGlvc0luc3RhbmNlO1xuICBwcml2YXRlIGZldGNoZXI6IEF4aW9zSW5zdGFuY2U7XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgY3JlZGVudGlhbHM6IENyZWRlbnRpYWxzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucGxhaW5GZXRjaGVyID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IElNR1VSX0FQSV9QUkVGSVgsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdVc2VyLUFnZW50JzogVVNFUkFHRU5ULFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH0pO1xuICAgIHRoaXMuZmV0Y2hlciA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICBiYXNlVVJMOiBJTUdVUl9BUElfUFJFRklYLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnVXNlci1BZ2VudCc6IFVTRVJBR0VOVCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KTtcbiAgICB0aGlzLmZldGNoZXIuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKFxuICAgICAgYXN5bmMgKGNvbmZpZzogQXhpb3NSZXF1ZXN0Q29uZmlnKSA9PiB7XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgPyBjb25maWcuaGVhZGVycyA6IHt9O1xuICAgICAgICBjb25maWcuaGVhZGVycy5hdXRob3JpemF0aW9uID0gYXdhaXQgZ2V0QXV0aG9yaXphdGlvbkhlYWRlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH0sXG4gICAgICAoZTogRXJyb3IpID0+IFByb21pc2UucmVqZWN0KGUpXG4gICAgKTtcbiAgfVxuXG4gIHBsYWluUmVxdWVzdChvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcpOiBQcm9taXNlPEF4aW9zUmVzcG9uc2U8dW5rbm93bj4+IHtcbiAgICByZXR1cm4gdGhpcy5wbGFpbkZldGNoZXIob3B0aW9ucyk7XG4gIH1cblxuICByZXF1ZXN0KG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9KTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPHVua25vd24+PiB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hlcihvcHRpb25zKTtcbiAgfVxuXG4gIGRlbGV0ZUltYWdlKGltYWdlSGFzaDogc3RyaW5nKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+PiB7XG4gICAgcmV0dXJuIGRlbGV0ZUltYWdlKHRoaXMsIGltYWdlSGFzaCk7XG4gIH1cblxuICBmYXZvcml0ZUltYWdlKGltYWdlSGFzaDogc3RyaW5nKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPHN0cmluZz4+IHtcbiAgICByZXR1cm4gZmF2b3JpdGVJbWFnZSh0aGlzLCBpbWFnZUhhc2gpO1xuICB9XG5cbiAgZ2V0QWxidW0oYWxidW1IYXNoOiBzdHJpbmcpOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8QWxidW1EYXRhPj4ge1xuICAgIHJldHVybiBnZXRBbGJ1bSh0aGlzLCBhbGJ1bUhhc2gpO1xuICB9XG5cbiAgZ2V0R2FsbGVyeShvcHRpb25zOiBHYWxsZXJ5T3B0aW9ucyk6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT4+IHtcbiAgICByZXR1cm4gZ2V0R2FsbGVyeSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGdldFN1YnJlZGRpdEdhbGxlcnkoXG4gICAgb3B0aW9uczogU3VicmVkZGl0R2FsbGVyeU9wdGlvbnNcbiAgKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPEdhbGxlcnlEYXRhPj4ge1xuICAgIHJldHVybiBnZXRTdWJyZWRkaXRHYWxsZXJ5KHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc2VhcmNoR2FsbGVyeShcbiAgICBvcHRpb25zOiBTZWFyY2hHYWxsZXJ5T3B0aW9uc1xuICApOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8R2FsbGVyeURhdGE+PiB7XG4gICAgcmV0dXJuIHNlYXJjaEdhbGxlcnkodGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBnZXRJbWFnZShpbWFnZUhhc2g6IHN0cmluZyk6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+PiB7XG4gICAgcmV0dXJuIGdldEltYWdlKHRoaXMsIGltYWdlSGFzaCk7XG4gIH1cblxuICB1cGRhdGVJbWFnZShcbiAgICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuICApOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgICByZXR1cm4gdXBkYXRlSW1hZ2UodGhpcywgcGF5bG9hZCk7XG4gIH1cblxuICB1cGxvYWQoXG4gICAgcGF5bG9hZDogc3RyaW5nIHwgc3RyaW5nW10gfCBQYXlsb2FkIHwgUGF5bG9hZFtdXG4gICk6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+IHwgSW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+W10+IHtcbiAgICByZXR1cm4gdXBsb2FkKHRoaXMsIHBheWxvYWQpO1xuICB9XG59XG4iLCJleHBvcnQgY29uc3QgSU1HVVJfQVBJX1BSRUZJWCA9ICdodHRwczovL2FwaS5pbWd1ci5jb20nO1xuXG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT04gPSAnMyc7XG5cbmV4cG9ydCBjb25zdCBBVVRIT1JJWkVfRU5EUE9JTlQgPSAnb2F1dGgyL2F1dGhvcml6ZSc7XG5cbmV4cG9ydCBjb25zdCBBTEJVTV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9hbGJ1bWA7XG5cbmV4cG9ydCBjb25zdCBJTUFHRV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9pbWFnZWA7XG5cbmV4cG9ydCBjb25zdCBVUExPQURfRU5EUE9JTlQgPSBgJHtBUElfVkVSU0lPTn0vdXBsb2FkYDtcblxuZXhwb3J0IGNvbnN0IEdBTExFUllfRU5EUE9JTlQgPSBgJHtBUElfVkVSU0lPTn0vZ2FsbGVyeWA7XG5cbmV4cG9ydCBjb25zdCBTVUJSRURESVRfR0FMTEVSWV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9nYWxsZXJ5L3JgO1xuXG5leHBvcnQgY29uc3QgU0VBUkNIX0dBTExFUllfRU5EUE9JTlQgPSBgJHtBUElfVkVSU0lPTn0vZ2FsbGVyeS9zZWFyY2hgO1xuIiwiaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tIFwic3RyZWFtXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzVG9rZW4ge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudElkIHtcbiAgY2xpZW50SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpbiBleHRlbmRzIENsaWVudElkIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgQ3JlZGVudGlhbHMgPSBBY2Nlc3NUb2tlbiB8IENsaWVudElkIHwgTG9naW47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FjY2Vzc1Rva2VuKGFyZzogdW5rbm93bik6IGFyZyBpcyBBY2Nlc3NUb2tlbiB7XG4gIHJldHVybiAoYXJnIGFzIEFjY2Vzc1Rva2VuKS5hY2Nlc3NUb2tlbiAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGllbnRJZChhcmc6IHVua25vd24pOiBhcmcgaXMgQ2xpZW50SWQge1xuICByZXR1cm4gKGFyZyBhcyBDbGllbnRJZCkuY2xpZW50SWQgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG9naW4oYXJnOiB1bmtub3duKTogYXJnIGlzIExvZ2luIHtcbiAgcmV0dXJuIChcbiAgICAoYXJnIGFzIExvZ2luKS5jbGllbnRJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGFyZyBhcyBMb2dpbikudXNlcm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgIChhcmcgYXMgTG9naW4pLnBhc3N3b3JkICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuaW50ZXJmYWNlIENvbW1vbkRhdGEge1xuICBpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nIHwgbnVsbDtcbiAgZGVzY3JpcHRpb246IHN0cmluZyB8IG51bGw7XG4gIGRhdGV0aW1lOiBudW1iZXI7XG4gIGxpbms6IHN0cmluZztcblxuICBhZF9jb25maWc/OiB7XG4gICAgc2FmZUZsYWdzOiBzdHJpbmdbXTtcbiAgICBoaWdoUmlza0ZsYWdzOiBzdHJpbmdbXTtcbiAgICB1bnNhZmVGbGFnczogc3RyaW5nW107XG4gICAgd2FsbFVuc2FmZUZsYWdzOiBzdHJpbmdbXTtcbiAgICBzaG93c0FkczogYm9vbGVhbjtcbiAgfTtcbiAgYWRfdHlwZTogbnVtYmVyO1xuICBhZF91cmw6IHN0cmluZztcblxuICBhY2NvdW50X3VybDogc3RyaW5nIHwgbnVsbDtcbiAgYWNjb3VudF9pZDogc3RyaW5nIHwgbnVsbDtcbiAgZmF2b3JpdGU6IGJvb2xlYW47XG4gIGlzX2FkOiBib29sZWFuO1xuICBpc19hbGJ1bTogYm9vbGVhbjtcbiAgaW5fZ2FsbGVyeTogYm9vbGVhbjtcbiAgaW5fbW9zdF92aXJhbDogYm9vbGVhbjtcbiAgbnNmdzogYm9vbGVhbiB8IG51bGw7XG4gIHNlY3Rpb246IHN0cmluZyB8IG51bGw7XG4gIHRhZ3M6IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gICAgZm9sbG93ZXJzOiBudW1iZXI7XG4gICAgdG90YWxfaXRlbXM6IG51bWJlcjtcbiAgICBmb2xsb3dpbmc6IGJvb2xlYW47XG4gICAgaXNfd2hpdGVsaXN0ZWQ6IGJvb2xlYW47XG4gICAgYmFja2dyb3VuZF9oYXNoOiBzdHJpbmc7XG4gICAgdGh1bWJuYWlsX2hhc2g6IHN0cmluZyB8IG51bGw7XG4gICAgYWNjZW50OiBzdHJpbmc7XG4gICAgYmFja2dyb3VuZF9pc19hbmltYXRlZDogYm9vbGVhbjtcbiAgICB0aHVtYm5haWxfaXNfYW5pbWF0ZWQ6IGJvb2xlYW47XG4gICAgaXNfcHJvbW90ZWQ6IGJvb2xlYW47XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBsb2dvX2hhc2g6IHN0cmluZyB8IG51bGw7XG4gICAgbG9nb19kZXN0aW5hdGlvbl91cmw6IHN0cmluZyB8IG51bGw7XG4gICAgZGVzY3JpcHRpb25fYW5ub3RhdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB9PjtcbiAgdG9waWM6IHN0cmluZyB8IG51bGw7XG4gIHRvcGljX2lkOiBzdHJpbmcgfCBudWxsO1xuICB2b3RlOiBudWxsO1xuXG4gIGNvbW1lbnRfY291bnQ6IG51bWJlciB8IG51bGw7XG4gIGZhdm9yaXRlX2NvdW50OiBudW1iZXIgfCBudWxsO1xuICB1cHM6IG51bWJlciB8IG51bGw7XG4gIGRvd25zOiBudW1iZXIgfCBudWxsO1xuICBzY29yZTogbnVtYmVyIHwgbnVsbDtcbiAgcG9pbnRzOiBudW1iZXIgfCBudWxsO1xuICB2aWV3czogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBJbWFnZURhdGEgZXh0ZW5kcyBDb21tb25EYXRhIHtcbiAgdHlwZTogc3RyaW5nO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICBkZWxldGVoYXNoPzogc3RyaW5nO1xuICBiYW5kd2lkdGg6IG51bWJlcjtcbiAgYW5pbWF0ZWQ6IGJvb2xlYW47XG4gIGhhc19zb3VuZDogYm9vbGVhbjtcbiAgZWRpdGVkOiBzdHJpbmc7XG4gIG1wNF9zaXplPzogbnVtYmVyO1xuICBtcDQ/OiBzdHJpbmc7XG4gIGdpZnY/OiBzdHJpbmc7XG4gIGhscz86IHN0cmluZztcbiAgbG9vcGluZz86IGJvb2xlYW47XG4gIHByb2Nlc3Npbmc/OiB7XG4gICAgc3RhdHVzOiAncGVuZGluZycgfCAnY29tcGxldGVkJztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbGJ1bURhdGEgZXh0ZW5kcyBDb21tb25EYXRhIHtcbiAgY292ZXI6IHN0cmluZyB8IG51bGw7XG4gIGNvdmVyX3dpZHRoOiBudW1iZXIgfCBudWxsO1xuICBjb3Zlcl9oZWlnaHQ6IG51bWJlciB8IG51bGw7XG4gIGxheW91dDogc3RyaW5nO1xuICBwcml2YWN5OiBzdHJpbmc7XG4gIGluY2x1ZGVfYWxidW1fYWRzOiBib29sZWFuO1xuICBpbWFnZXM6IEltYWdlRGF0YVtdO1xuICBpbWFnZXNfY291bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgR2FsbGVyeURhdGEgPSBBcnJheTxJbWFnZURhdGEgfCBBbGJ1bURhdGE+O1xuZXhwb3J0IGludGVyZmFjZSBQYXlsb2FkIHtcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGJhc2U2ND86IHN0cmluZztcbiAgdHlwZT86ICdzdHJlYW0nIHwgJ3VybCcgfCAnYmFzZTY0JztcbiAgbmFtZT86IHN0cmluZztcbiAgdGl0bGU/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBhbGJ1bT86IHN0cmluZztcbiAgc3RyZWFtPzogUmVhZGFibGU7XG4gIGRpc2FibGVfYXVkaW8/OiAnMScgfCAnMCc7XG59XG5leHBvcnQgaW50ZXJmYWNlIEltZ3VyQXBpUmVzcG9uc2U8XG4gIFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+W10gfCBzdHJpbmcgfCBib29sZWFuIHwgSW1hZ2VEYXRhIHwgR2FsbGVyeURhdGEgfCBBbGJ1bURhdGFcbj4ge1xuICBkYXRhOiBUO1xuICBzdGF0dXM6IG51bWJlcjtcbiAgc3VjY2VzczogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBBeGlvc1Jlc3BvbnNlIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJ2Zvcm0tZGF0YSc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlLCBQYXlsb2FkIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2U2NChwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHBheWxvYWQuYmFzZTY0ICE9PSAndW5kZWZpbmVkJyAmJiBwYXlsb2FkLnR5cGUgPT09ICdiYXNlNjQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbWFnZVVybChwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgcGF5bG9hZC5pbWFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGF5bG9hZC50eXBlID09PSAndXJsJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyZWFtKHBheWxvYWQ6IHN0cmluZyB8IFBheWxvYWQpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgcGF5bG9hZC5zdHJlYW0gIT09ICd1bmRlZmluZWQnO1xufVxuXG4vLyBUT0RPOiBSZWZhY3RvciB0aGlzIHRvIGJlIGEgdW5pcXVlIG5hbWUgb2Ygc29tZSBraW5kIChhIGhhc2g/KVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvdXJjZShwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogc3RyaW5nIHwgUmVhZGFibGUge1xuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH1cblxuICBpZiAoaXNCYXNlNjQocGF5bG9hZCkpIHtcbiAgICByZXR1cm4gXCJwYXlsb2FkLmJhc2U2NFwiIGFzIHN0cmluZztcbiAgfSBlbHNlIGlmIChpc1N0cmVhbShwYXlsb2FkKSkge1xuICAgIHJldHVybiBcInBheWxvYWQuc3RyZWFtXCIgYXMgc3RyaW5nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXlsb2FkLmltYWdlIGFzIHN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9ybShwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogRm9ybURhdGEge1xuICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgIGZvcm0uYXBwZW5kKCdpbWFnZScsIHBheWxvYWQpO1xuICAgIHJldHVybiBmb3JtO1xuICB9XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGF5bG9hZCkpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcyA9IFsnYmFzZTY0JywgJ3N0cmVhbSddXG4gICAgaWYgKHN1cHBvcnRlZFVwbG9hZE9iamVjdFR5cGVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIGlmIChzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcy5pbmRleE9mKHBheWxvYWQudHlwZSBhcyBzdHJpbmcpICE9PSAtMSkge1xuICAgICAgICBmb3JtLmFwcGVuZChrZXksIHBheWxvYWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICByZXNwb25zZTogQXhpb3NSZXNwb25zZVxuKTogSW1ndXJBcGlSZXNwb25zZSB7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2UuZGF0YT8uc3RhdHVzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcmVzcG9uc2UuZGF0YT8uc3VjY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiByZXNwb25zZS5kYXRhLFxuICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgIC8vIFRPRE86IGRldGVybWluZSB0aGUgc3VjY2VzcyBvZiB0aGUgY2FsbD9cbiAgICBzdWNjZXNzOiB0cnVlLFxuICB9XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBHQUxMRVJZX0VORFBPSU5ULCBJTUdVUl9BUElfUFJFRklYIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlLCBHYWxsZXJ5RGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscyc7XG5cbmV4cG9ydCB0eXBlIENvbW1vblNlY3Rpb25Qcm9wcyA9IHtcbiAgc29ydD86ICd2aXJhbCcgfCAndG9wJyB8ICd0aW1lJztcbiAgcGFnZT86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEhvdFNlY3Rpb24gPSBDb21tb25TZWN0aW9uUHJvcHMgJiB7XG4gIHNlY3Rpb246ICdob3QnO1xufTtcblxuZXhwb3J0IHR5cGUgVG9wU2VjdGlvbiA9IENvbW1vblNlY3Rpb25Qcm9wcyAmIHtcbiAgc2VjdGlvbjogJ3RvcCc7XG4gIHdpbmRvdz86ICdkYXknIHwgJ3dlZWsnIHwgJ21vbnRoJyB8ICd5ZWFyJyB8ICdhbGwnO1xufTtcblxuZXhwb3J0IHR5cGUgVXNlclNlY3Rpb24gPSBPbWl0PENvbW1vblNlY3Rpb25Qcm9wcywgJ3NvcnQnPiAmIHtcbiAgc2VjdGlvbjogJ3VzZXInO1xuICBzb3J0PzogJ3ZpcmFsJyB8ICd0b3AnIHwgJ3RpbWUnIHwgJ3Jpc2luZyc7XG59O1xuXG5leHBvcnQgdHlwZSBTZWN0aW9uT3B0aW9ucyA9IEhvdFNlY3Rpb24gfCBUb3BTZWN0aW9uIHwgVXNlclNlY3Rpb247XG5cbmV4cG9ydCB0eXBlIFByZXNlbnRhdGlvbk9wdGlvbnMgPSB7XG4gIHNob3dWaXJhbD86IGJvb2xlYW47XG4gIG1hdHVyZT86IGJvb2xlYW47XG4gIGFsYnVtX3ByZXZpZXdzPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIEdhbGxlcnlPcHRpb25zID0gU2VjdGlvbk9wdGlvbnMgJiBQcmVzZW50YXRpb25PcHRpb25zO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogR2FsbGVyeU9wdGlvbnMgPSB7XG4gIHNlY3Rpb246ICdob3QnLFxuICBzb3J0OiAndmlyYWwnLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEdhbGxlcnlVcmwob3B0aW9uczogR2FsbGVyeU9wdGlvbnMpOiBVUkwge1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGxldCB1cmkgPSBgJHttZXJnZWRPcHRpb25zLnNlY3Rpb259YDtcblxuICBpZiAobWVyZ2VkT3B0aW9ucy5zb3J0KSB7XG4gICAgdXJpICs9IGAvJHttZXJnZWRPcHRpb25zLnNvcnR9YDtcbiAgfVxuXG4gIGlmIChtZXJnZWRPcHRpb25zLnNlY3Rpb24gPT09ICd0b3AnICYmIG1lcmdlZE9wdGlvbnMud2luZG93KSB7XG4gICAgdXJpICs9IGAvJHttZXJnZWRPcHRpb25zLndpbmRvd31gO1xuICB9XG5cbiAgaWYgKG1lcmdlZE9wdGlvbnMucGFnZSkge1xuICAgIHVyaSArPSBgLyR7bWVyZ2VkT3B0aW9ucy5wYWdlfWA7XG4gIH1cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke0lNR1VSX0FQSV9QUkVGSVh9LyR7R0FMTEVSWV9FTkRQT0lOVH0vJHt1cml9YCk7XG5cbiAgaWYgKG1lcmdlZE9wdGlvbnMuc2hvd1ZpcmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc2hvd1ZpcmFsJywgbWVyZ2VkT3B0aW9ucy5zaG93VmlyYWwudG9TdHJpbmcoKSk7XG4gIH1cblxuICBpZiAobWVyZ2VkT3B0aW9ucy5tYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdtYXR1cmUnLCBtZXJnZWRPcHRpb25zLm1hdHVyZS50b1N0cmluZygpKTtcbiAgfVxuXG4gIGlmIChtZXJnZWRPcHRpb25zLmFsYnVtX3ByZXZpZXdzICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcbiAgICAgICdhbGJ1bV9wcmV2aWV3cycsXG4gICAgICBtZXJnZWRPcHRpb25zLmFsYnVtX3ByZXZpZXdzLnRvU3RyaW5nKClcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEdhbGxlcnkoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIG9wdGlvbnM6IEdhbGxlcnlPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNcbik6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT4+IHtcbiAgY29uc3QgeyBwYXRobmFtZSB9ID0gY29uc3RydWN0R2FsbGVyeVVybChvcHRpb25zKTtcbiAgLy8gc2luY2Ugd2UncmUgdXNpbmcgcHJlZml4VXJsIHdpdGggZ290LCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgc3RhcnRpbmcgc2xhc2ggb3IgaXQnbGwgdGhyb3dcbiAgY29uc3QgZmluYWxQYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDEpO1xuXG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsOiBmaW5hbFBhdGhuYW1lIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPEdhbGxlcnlEYXRhPjtcbn1cbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7XG4gIFNVQlJFRERJVF9HQUxMRVJZX0VORFBPSU5ULFxuICBJTUdVUl9BUElfUFJFRklYLFxufSBmcm9tICcuLi9jb21tb24vZW5kcG9pbnRzJztcbmltcG9ydCB7IEltZ3VyQXBpUmVzcG9uc2UsIEdhbGxlcnlEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuZXhwb3J0IHR5cGUgVGltZU9wdGlvbnMgPSB7XG4gIHN1YnJlZGRpdDogc3RyaW5nO1xuICBzb3J0PzogJ3RpbWUnO1xuICBwYWdlPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgVG9wT3B0aW9ucyA9IE9taXQ8VGltZU9wdGlvbnMsICdzb3J0Jz4gJiB7XG4gIHNvcnQ/OiAndG9wJztcbiAgd2luZG93PzogJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3llYXInIHwgJ2FsbCc7XG59O1xuXG5leHBvcnQgdHlwZSBTdWJyZWRkaXRHYWxsZXJ5T3B0aW9ucyA9IFRpbWVPcHRpb25zIHwgVG9wT3B0aW9ucztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFN1YnJlZGRpdEdhbGxlcnlVcmwoXG4gIG9wdGlvbnM6IFN1YnJlZGRpdEdhbGxlcnlPcHRpb25zXG4pOiBVUkwge1xuICBsZXQgdXJpID0gYCR7b3B0aW9ucy5zdWJyZWRkaXR9YDtcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLnNvcnR9YDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNvcnQgPT09ICd0b3AnICYmIG9wdGlvbnMud2luZG93KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLndpbmRvd31gO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucGFnZSkge1xuICAgIHVyaSArPSBgLyR7b3B0aW9ucy5wYWdlfWA7XG4gIH1cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgIGAke0lNR1VSX0FQSV9QUkVGSVh9LyR7U1VCUkVERElUX0dBTExFUllfRU5EUE9JTlR9LyR7dXJpfWBcbiAgKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3VicmVkZGl0R2FsbGVyeShcbiAgY2xpZW50OiBJbWd1ckNsaWVudCxcbiAgb3B0aW9uczogU3VicmVkZGl0R2FsbGVyeU9wdGlvbnNcbik6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT4+IHtcbiAgY29uc3QgeyBwYXRobmFtZSB9ID0gY29uc3RydWN0U3VicmVkZGl0R2FsbGVyeVVybChvcHRpb25zKTtcbiAgLy8gc2luY2Ugd2UncmUgdXNpbmcgcHJlZml4VXJsIHdpdGggZ290LCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgc3RhcnRpbmcgc2xhc2ggb3IgaXQnbGwgdGhyb3dcbiAgY29uc3QgZmluYWxQYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDEpO1xuXG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsOiBmaW5hbFBhdGhuYW1lIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPEdhbGxlcnlEYXRhPjtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vZ2V0R2FsbGVyeSc7XG5leHBvcnQgKiBmcm9tICcuL2dldFN1YnJlZGRpdEdhbGxlcnknO1xuZXhwb3J0ICogZnJvbSAnLi9zZWFyY2hHYWxsZXJ5JztcbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IFNFQVJDSF9HQUxMRVJZX0VORFBPSU5ULCBJTUdVUl9BUElfUFJFRklYIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlLCBHYWxsZXJ5RGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5cbmV4cG9ydCB0eXBlIFNlYXJjaE9wdGlvbnMgPSB7XG4gIHE/OiBzdHJpbmc7XG4gIHF1ZXJ5Pzogc3RyaW5nO1xuICBzb3J0PzogJ3RpbWUnIHwgJ3ZpcmFsJztcbiAgcGFnZT86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFRvcFNlYXJjaE9wdGlvbnMgPSBPbWl0PFNlYXJjaE9wdGlvbnMsICdzb3J0Jz4gJiB7XG4gIHNvcnQ/OiAndG9wJztcbiAgd2luZG93PzogJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3llYXInIHwgJ2FsbCc7XG59O1xuXG5leHBvcnQgdHlwZSBBZHZhbmNlZFNlYXJjaFF1ZXJ5UGFyYW1ldGVycyA9IHtcbiAgcV9hbGw/OiBzdHJpbmc7XG4gIHFfYW55Pzogc3RyaW5nO1xuICBxX2V4YWN0bHk/OiBzdHJpbmc7XG4gIHFfbm90Pzogc3RyaW5nO1xuICBxX3R5cGU/OiAnanBnJyB8ICdwbmcnIHwgJ2dpZicgfCAnYW5pZ2lmJyB8ICdhbGJ1bSc7XG4gIHFfc2l6ZV9weD86ICdzbWFsbCcgfCAnbWVkJyB8ICdiaWcnIHwgJ2xyZycgfCAnaHVnZSc7XG59O1xuXG5jb25zdCBhZHZhbmNlZFBhcmFtZXRlcnM6IEFycmF5PGtleW9mIEFkdmFuY2VkU2VhcmNoUXVlcnlQYXJhbWV0ZXJzPiA9IFtcbiAgJ3FfYWxsJyxcbiAgJ3FfYW55JyxcbiAgJ3FfZXhhY3RseScsXG4gICdxX25vdCcsXG4gICdxX3R5cGUnLFxuICAncV9zaXplX3B4Jyxcbl07XG5cbmV4cG9ydCB0eXBlIFNlYXJjaEdhbGxlcnlPcHRpb25zID0gKFNlYXJjaE9wdGlvbnMgfCBUb3BTZWFyY2hPcHRpb25zKSAmXG4gIEFkdmFuY2VkU2VhcmNoUXVlcnlQYXJhbWV0ZXJzO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0U2VhcmNoR2FsbGVyeVVybChvcHRpb25zOiBTZWFyY2hHYWxsZXJ5T3B0aW9ucyk6IFVSTCB7XG4gIGxldCB1cmkgPSAnJztcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLnNvcnR9YDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNvcnQgPT09ICd0b3AnICYmIG9wdGlvbnMud2luZG93KSB7XG4gICAgdXJpICs9IGAvJHtvcHRpb25zLndpbmRvd31gO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucGFnZSkge1xuICAgIHVyaSArPSBgLyR7b3B0aW9ucy5wYWdlfWA7XG4gIH1cblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke0lNR1VSX0FQSV9QUkVGSVh9LyR7U0VBUkNIX0dBTExFUllfRU5EUE9JTlR9JHt1cml9YCk7XG5cbiAgYWR2YW5jZWRQYXJhbWV0ZXJzLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgaWYgKG9wdGlvbnNbcGFyYW1dPy5sZW5ndGgpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKHBhcmFtLCBvcHRpb25zW3BhcmFtXSBhcyBzdHJpbmcpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCF1cmwuc2VhcmNoKSB7XG4gICAgY29uc3QgcXVlcnkgPSBvcHRpb25zLnEgfHwgb3B0aW9ucy5xdWVyeTtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHF1ZXJ5IHdhcyBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdxJywgcXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaEdhbGxlcnkoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIG9wdGlvbnM6IFNlYXJjaEdhbGxlcnlPcHRpb25zXG4pOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8R2FsbGVyeURhdGE+PiB7XG4gIGNvbnN0IHsgcGF0aG5hbWUgfSA9IGNvbnN0cnVjdFNlYXJjaEdhbGxlcnlVcmwob3B0aW9ucyk7XG4gIC8vIHNpbmNlIHdlJ3JlIHVzaW5nIHByZWZpeFVybCB3aXRoIGdvdCwgd2UgaGF2ZSB0byByZW1vdmUgdGhlIHN0YXJ0aW5nIHNsYXNoIG9yIGl0J2xsIHRocm93XG4gIGNvbnN0IGZpbmFsUGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgxKTtcblxuICByZXR1cm4gZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybDogZmluYWxQYXRobmFtZSB9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTxHYWxsZXJ5RGF0YT47XG59XG4iLCJpbXBvcnQge1xuICBBY2Nlc3NUb2tlbixcbiAgaXNBY2Nlc3NUb2tlbixcbiAgaXNDbGllbnRJZCxcbiAgaXNMb2dpbixcbn0gZnJvbSAnLi9jb21tb24vdHlwZXMnO1xuaW1wb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuL2NsaWVudCc7XG5pbXBvcnQgeyBJTUdVUl9BUElfUFJFRklYLCBBVVRIT1JJWkVfRU5EUE9JTlQgfSBmcm9tICcuL2NvbW1vbi9lbmRwb2ludHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aG9yaXphdGlvbkhlYWRlcihcbiAgY2xpZW50OiBJbWd1ckNsaWVudFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgaWYgKGlzQWNjZXNzVG9rZW4oY2xpZW50LmNyZWRlbnRpYWxzKSkge1xuICAgIHJldHVybiBgQmVhcmVyICR7Y2xpZW50LmNyZWRlbnRpYWxzLmFjY2Vzc1Rva2VufWA7XG4gIH1cblxuICBpZiAoaXNDbGllbnRJZChjbGllbnQuY3JlZGVudGlhbHMpICYmICFpc0xvZ2luKGNsaWVudC5jcmVkZW50aWFscykpIHtcbiAgICByZXR1cm4gYENsaWVudC1JRCAke2NsaWVudC5jcmVkZW50aWFscy5jbGllbnRJZH1gO1xuICB9XG5cbiAgY29uc3QgeyBjbGllbnRJZCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjbGllbnQuY3JlZGVudGlhbHM7XG5cbiAgY29uc3Qgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7XG4gICAgdXJsOiBBVVRIT1JJWkVfRU5EUE9JTlQsXG4gICAgYmFzZVVSTDogSU1HVVJfQVBJX1BSRUZJWCxcbiAgICBwYXJhbXM6IHtcbiAgICAgIGNsaWVudF9pZDogY2xpZW50SWQsXG4gICAgICByZXNwb25zZV90eXBlOiAndG9rZW4nLFxuICAgIH0sXG4gIH07XG5cbiAgbGV0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBsYWluUmVxdWVzdChvcHRpb25zKTtcblxuICBjb25zdCBjb29raWVzID0gQXJyYXkuaXNBcnJheShyZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10pXG4gICAgPyByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ11bMF1cbiAgICA6IHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXTtcblxuICBpZiAoIWNvb2tpZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb2tpZXMgd2VyZSBzZXQgZHVyaW5nIGF1dGhvcml6YXRpb24nKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSBjb29raWVzLm1hdGNoKCcoXnw7KVtzXSphdXRob3JpemVfdG9rZW49KFteO10qKScpO1xuXG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGF1dGhvcml6ZV90b2tlbiBjb29raWUnKTtcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml6ZVRva2VuID0gbWF0Y2hlc1syXTtcblxuICBvcHRpb25zLm1ldGhvZCA9ICdQT1NUJztcbiAgb3B0aW9ucy5kYXRhID0ge1xuICAgIHVzZXJuYW1lLFxuICAgIHBhc3N3b3JkLFxuICAgIGFsbG93OiBhdXRob3JpemVUb2tlbixcbiAgfTtcblxuICBvcHRpb25zLmZvbGxvd1JlZGlyZWN0ID0gZmFsc2U7XG4gIG9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICBjb29raWU6IGBhdXRob3JpemVfdG9rZW49JHthdXRob3JpemVUb2tlbn1gLFxuICB9O1xuXG4gIHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBsYWluUmVxdWVzdChvcHRpb25zKTtcbiAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgbG9jYXRpb24nKTtcbiAgfVxuXG4gIGNvbnN0IHRva2VuID0gSlNPTi5wYXJzZShcbiAgICAne1wiJyArXG4gICAgICBkZWNvZGVVUkkobG9jYXRpb24uc2xpY2UobG9jYXRpb24uaW5kZXhPZignIycpICsgMSkpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgJ1wiLFwiJylcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJ1wiOlwiJykgK1xuICAgICAgJ1wifSdcbiAgKTtcblxuICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRva2VuLmFjY2Vzc190b2tlbjtcbiAgKChjbGllbnQuY3JlZGVudGlhbHMgYXMgdW5rbm93bikgYXMgQWNjZXNzVG9rZW4pLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gIFxuICByZXR1cm4gYEJlYXJlciAke2FjY2Vzc1Rva2VufWA7XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHsgSW1ndXJBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5pbXBvcnQgeyBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUltYWdlKFxuICBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+PiB7XG4gIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke2ltYWdlSGFzaH1gO1xuICByZXR1cm4gZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnREVMRVRFJyB9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTxib29sZWFuPjtcbn1cbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBJbWd1ckFwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7IGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmF2b3JpdGVJbWFnZShcbiAgY2xpZW50OiBJbWd1ckNsaWVudCxcbiAgaW1hZ2VIYXNoOiBzdHJpbmdcbik6IFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTwnZmF2b3JpdGVkJz4+IHtcbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofS9mYXZvcml0ZWA7XG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsLCBtZXRob2Q6ICdQT1NUJyB9KSkgYXMgSW1ndXJBcGlSZXNwb25zZTwnZmF2b3JpdGVkJz47XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuaW1wb3J0IHsgSW1ndXJBcGlSZXNwb25zZSwgSW1hZ2VEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCB7IGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2UoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIGltYWdlSGFzaDogc3RyaW5nXG4pOiBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8SW1hZ2VEYXRhPj4ge1xuICBjb25zdCB1cmwgPSBgJHtJTUFHRV9FTkRQT0lOVH0vJHtpbWFnZUhhc2h9YDtcbiAgcmV0dXJuIGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwgfSkpIGFzIEltZ3VyQXBpUmVzcG9uc2U8SW1hZ2VEYXRhPlxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9kZWxldGVJbWFnZSc7XG5leHBvcnQgKiBmcm9tICcuL2Zhdm9yaXRlSW1hZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi9nZXRJbWFnZSc7XG5leHBvcnQgKiBmcm9tICcuL3VwZGF0ZUltYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vdXBsb2FkJztcbiIsImltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50JztcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5pbXBvcnQgeyBjcmVhdGVGb3JtLCBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzJztcbmltcG9ydCB7IFBheWxvYWQsIEltZ3VyQXBpUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUltYWdlUGF5bG9hZFxuICBleHRlbmRzIFBpY2s8UGF5bG9hZCwgJ3RpdGxlJyB8ICdkZXNjcmlwdGlvbic+IHtcbiAgaW1hZ2VIYXNoOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRVcGRhdGVQYXlsb2FkKHA6IFVwZGF0ZUltYWdlUGF5bG9hZCkge1xuICByZXR1cm4gdHlwZW9mIHAudGl0bGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwLmRlc2NyaXB0aW9uID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUltYWdlKFxuICBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+IHwgSW1ndXJBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBwYXlsb2FkLm1hcCgocDogVXBkYXRlSW1hZ2VQYXlsb2FkKSA9PiB7XG4gICAgICBpZiAoIWlzVmFsaWRVcGRhdGVQYXlsb2FkKHApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIHJlcXVpcmVzIGEgdGl0bGUgYW5kL29yIGRlc2NyaXB0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke3AuaW1hZ2VIYXNofWA7XG4gICAgICBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgICAgIC8qIGVzbGludCBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yOiAwICovXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICAgICAgLy8gcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAgICAgICAgIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+KVxuICAgICAgICB9KSBhcyBQcm9taXNlPEltZ3VyQXBpUmVzcG9uc2U8Ym9vbGVhbj4+O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZFVwZGF0ZVBheWxvYWQocGF5bG9hZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpO1xuICB9XG5cbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7cGF5bG9hZC5pbWFnZUhhc2h9YDtcbiAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocGF5bG9hZCk7XG4gIHJldHVybiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICB1cmwsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgZGF0YTogZm9ybSxcbiAgICAvLyByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gIH0pKSBhcyBJbWd1ckFwaVJlc3BvbnNlPGJvb2xlYW4+XG59XG4iLCJpbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4uL2NsaWVudCc7XG5pbXBvcnQge1xuICBjcmVhdGVGb3JtLFxuICBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlLFxuICAvLyBnZXRTb3VyY2UsXG59IGZyb20gJy4uL2NvbW1vbi91dGlscyc7XG5pbXBvcnQgeyBQYXlsb2FkLCBJbWd1ckFwaVJlc3BvbnNlLCBJbWFnZURhdGEgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuaW1wb3J0IHsgVVBMT0FEX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWQoXG4gIGNsaWVudDogSW1ndXJDbGllbnQsXG4gIHBheWxvYWQ6IHN0cmluZyB8IHN0cmluZ1tdIHwgUGF5bG9hZCB8IFBheWxvYWRbXVxuKTogUHJvbWlzZTxJbWd1ckFwaVJlc3BvbnNlPEltYWdlRGF0YT4gfCBJbWd1ckFwaVJlc3BvbnNlPEltYWdlRGF0YT5bXT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHA6IHN0cmluZyB8IFBheWxvYWQpID0+IHtcbiAgICAgIGNvbnN0IGZvcm0gPSBjcmVhdGVGb3JtKHApO1xuXG4gICAgICAvKiBlc2xpbnQgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvcjogMCAqL1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmUoZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgdXJsOiBVUExPQURfRU5EUE9JTlQsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAocHJvZ3Jlc3NFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsgcHJvZ3Jlc3NFdmVudCB9KTtcbiAgICAgICAgICAgICAgICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzRXZlbnQgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkgYXMgSW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+KTtcbiAgICAgIH0pIGFzIFByb21pc2U8SW1ndXJBcGlSZXNwb25zZTxJbWFnZURhdGE+PjtcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocGF5bG9hZCk7XG4gIC8vIGNvbnN0IGlkID0gRGF0ZS5ub3cudG9TdHJpbmcoKTtcbiAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICB1cmw6IFVQTE9BRF9FTkRQT0lOVCxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBkYXRhOiBmb3JtLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyh7IHByb2dyZXNzRXZlbnQgfSk7XG4gICAgICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzRXZlbnQgfSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKHJlcXVlc3QpIGFzIEltZ3VyQXBpUmVzcG9uc2U8SW1hZ2VEYXRhPlxuICApO1xufVxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vc3VwcG9ydC90eXBlcycpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gaGFzU3ltYm9scyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdsb2JhbFt0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIGFyciA9IG5ldyBnbG9iYWxbdHlwZWRBcnJheV0oKTtcblx0XHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFdmFsRXJyb3IoJ3RoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCAnICsgdHlwZWRBcnJheSArICcgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy4nKTtcblx0XHRcdH1cblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmROYW1lID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0dGVyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kTmFtZSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kTmFtZTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiZXhwb3J0IHsgSW1ndXJDbGllbnQgfSBmcm9tICcuL2NsaWVudCc7XG4iXSwic291cmNlUm9vdCI6IiJ9


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BikeTagClient": () => (/* reexport safe */ _client__WEBPACK_IMPORTED_MODULE_0__.BikeTagClient)
/* harmony export */ });
/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client */ "./src/client.ts");


})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtldGFnLWFwaS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHJleHhhcnMvZXZlbnRzb3VyY2UtcG9seWZpbGwvc3JjL2V2ZW50c291cmNlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9hc3NldHMvYXNzZXRzQ2xpZW50LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9hdXRoL2F1dGhDbGllbnQuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvZGF0YS9kYXRhTWV0aG9kcy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvZGF0YS9lbmNvZGVRdWVyeVN0cmluZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvZGF0YS9saXN0ZW4uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2RhdGEvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2RhdGEvdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL2RhdGFzZXRzL2RhdGFzZXRzQ2xpZW50LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9odHRwL2Jyb3dzZXJNaWRkbGV3YXJlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9odHRwL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvaHR0cC9xdWVyeVN0cmluZy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvaHR0cC9yZXF1ZXN0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9odHRwL3JlcXVlc3RPcHRpb25zLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi9wcm9qZWN0cy9wcm9qZWN0c0NsaWVudC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvc2FuaXR5Q2xpZW50LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi91c2Vycy91c2Vyc0NsaWVudC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvdXRpbC9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvdXRpbC9nZXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvbGliL3V0aWwvb25jZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9saWIvdXRpbC9waWNrLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi92YWxpZGF0b3JzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2xpYi93YXJuaW5ncy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9nZW5lcmF0ZS1oZWxwLXVybC9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L29ic2VydmFibGUvbGliL1Nhbml0eU9ic2VydmFibGVNaW5pbWFsLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9taW5pbWFsLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvZmlsdGVyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvbWFwLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvcmVkdWNlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2FycmF5LWZpbHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvYXNzZXJ0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy1jYWNoZS1hZGFwdGVyL2Rpc3QvY2FjaGUuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZGVlcC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL21pZGRsZXdhcmUvZGVmYXVsdE9wdGlvbnNQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2xpYi9taWRkbGV3YXJlL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvbWlkZGxld2FyZS9qc29uUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL21pZGRsZXdhcmUvanNvblJlc3BvbnNlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvbWlkZGxld2FyZS9vYnNlcnZhYmxlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvbWlkZGxld2FyZS9wcm9ncmVzcy9icm93c2VyLXByb2dyZXNzLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvbWlkZGxld2FyZS9wcm9ncmVzcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL3JlcXVlc3QvYnJvd3Nlci1yZXF1ZXN0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvcmVxdWVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbGliL3V0aWwvZ2xvYmFsLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9saWIvdXRpbC9taWRkbGV3YXJlUmVkdWNlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9pcy1vYmovaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL2lzb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL21ha2UtZXJyb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvbmFuby1wdWJzdWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5naWZ5L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvT2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC9TdWJzY3JpYmVyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvY29uZmlnLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL29wZXJhdG9ycy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL29wZXJhdG9ycy9zY2FuLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VMYXN0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL3V0aWwvY2FuUmVwb3J0RXJyb3IuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC91dGlsL2hvc3RSZXBvcnRFcnJvci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy9yeGpzL2ludGVybmFsL3V0aWwvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC91dGlsL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvcnhqcy9pbnRlcm5hbC91dGlsL2lzT2JqZWN0LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvdXRpbC9waXBlLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3J4anMvaW50ZXJuYWwvdXRpbC90b1N1YnNjcmliZXIuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvc2FtZS1vcmlnaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvc2FtZS1vcmlnaW4vdXJsLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9iaWtldGFnL2RlbGV0ZVRhZy50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9iaWtldGFnL2Zhdm9yaXRlSW1hZ2UudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvYmlrZXRhZy9nZXRUYWcudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvYmlrZXRhZy9pbmRleC50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9iaWtldGFnL3F1ZXVlVGFnSW1hZ2UudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvYmlrZXRhZy91cGRhdGVUYWcudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvYmlrZXRhZy91cGRhdGVUYWdJbWFnZS50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvY29tbW9uL2RhdGEudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9jb21tb24vbWV0aG9kcy50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9pbWd1ci9kZWxldGVUYWcudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvaW1ndXIvZ2V0VGFnLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2ltZ3VyL2luZGV4LnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2ltZ3VyL3VwZGF0ZVRhZy50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9pbWd1ci91cGxvYWRUYWdJbWFnZS50cyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9zYW5pdHkvZGVsZXRlVGFnLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL3Nhbml0eS9nZXRUYWcudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvc2FuaXR5L2luZGV4LnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL3Nhbml0eS91cGRhdGVUYWcudHMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9zcmMvc2FuaXR5L3VwbG9hZFRhZ0ltYWdlLnRzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vbm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpLy4vc3JjL2ltZ3VyQ2xpZW50L2luZGV4LmpzIiwid2VicGFjazovL2Jpa2V0YWctYXBpL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jpa2V0YWctYXBpL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2Jpa2V0YWctYXBpL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2Jpa2V0YWctYXBpL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vYmlrZXRhZy1hcGkvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9iaWtldGFnLWFwaS8uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDdkIsR0FBRyxNQUFNLHNCQVdOO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sMkJBQTJCLE9BQU87QUFDMUQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDMWtCWTs7QUFFYixpQ0FBaUMsMkhBQTJIOztBQUU1Siw2QkFBNkIsa0tBQWtLOztBQUUvTCxpREFBaUQsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRCxrSEFBa0g7O0FBRTlaLHNDQUFzQyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxrQkFBa0IsRUFBRSxhQUFhOztBQUVyTCx3Q0FBd0MsZ0ZBQWdGLGVBQWUsZUFBZSxnQkFBZ0Isb0JBQW9CLE1BQU0sMENBQTBDLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLGlEQUFpRCxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhOztBQUV2ZSwrQkFBK0Isb0NBQW9DOztBQUVuRSxhQUFhLG1CQUFPLENBQUMsNERBQWU7O0FBRXBDLGVBQWUsbUJBQU8sQ0FBQyw0RkFBa0M7QUFDekQ7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQXFDO0FBQzdEOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFxQjs7QUFFL0MsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWU7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE1BQU07QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFLO0FBQ1o7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCOzs7Ozs7Ozs7OztBQzVLYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsNERBQWU7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsNEI7Ozs7Ozs7Ozs7O0FDckJhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG9GQUEyQjs7QUFFekQsYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQyxlQUFlLG1CQUFPLENBQUMscUVBQWM7O0FBRXJDLGVBQWUsbUJBQU8sQ0FBQyxpRUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCOztBQUV0QyxrQkFBa0I7QUFDbEIsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUMxR2E7O0FBRWIsMkNBQTJDLGtCQUFrQixrQ0FBa0MscUVBQXFFLEVBQUUsRUFBRSxPQUFPLGtCQUFrQixFQUFFLFlBQVk7O0FBRS9NLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEMsZUFBZSxtQkFBTyxDQUFDLGtHQUFxQztBQUM1RDs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBa0M7QUFDMUQ7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWU7O0FBRXhDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFzQjs7QUFFakQsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQXFCOztBQUVyRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBZTs7QUFFekMsWUFBWSxtQkFBTyxDQUFDLGdFQUFTOztBQUU3QixhQUFhLG1CQUFPLENBQUMsa0VBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUNsTmE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRTs7Ozs7Ozs7Ozs7O0FDbEJhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQTRCOztBQUVyRCw0QkFBNEIsbUJBQU8sQ0FBQywwRUFBcUI7O0FBRXpELFdBQVcsbUJBQU8sQ0FBQyxvRUFBYzs7QUFFakMsZUFBZSxtQkFBTyxDQUFDLDRFQUFrQjs7QUFFekMsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQXFCOztBQUVyRCxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBMkI7O0FBRXpELFdBQVcsbUJBQU8sQ0FBQyxvRUFBYzs7QUFFakMsMEtBQTBLOztBQUUxSztBQUNBLFNBQVMsT0FBTztBQUNoQixDQUFDO0FBQ0Q7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ3BMYTs7QUFFYiwyQ0FBMkMsa0JBQWtCLGtDQUFrQyxxRUFBcUUsRUFBRSxFQUFFLE9BQU8sa0JBQWtCLEVBQUUsWUFBWTs7QUFFL00saUJBQWlCLG1CQUFPLENBQUMsd0RBQWE7O0FBRXRDLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEMsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQXNCOztBQUVqRCxlQUFlLG1CQUFPLENBQUMsc0VBQWU7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLE9BQU87QUFDWCx1RUFBdUU7QUFDdkUsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1AsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JELEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFDQUFxQyxlQUFlLG9DQUFvQztBQUN2SDtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCOzs7Ozs7Ozs7OztBQ3BJYTs7QUFFYiwyQ0FBMkMsa0JBQWtCLGtDQUFrQyxxRUFBcUUsRUFBRSxFQUFFLE9BQU8sa0JBQWtCLEVBQUUsWUFBWTs7QUFFL00sYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBZTs7QUFFeEMsWUFBWSxtQkFBTyxDQUFDLGdFQUFTOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOENBQThDLHNEQUFzRCxVQUFVOztBQUU5RztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyx3QkFBd0IsVUFBVSxPQUFPLFdBQVc7OztBQUd6RDtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUsscUNBQXFDO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkI7Ozs7Ozs7Ozs7O0FDbEhhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEMsZUFBZSxtQkFBTyxDQUFDLHNFQUFlOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxnQzs7Ozs7Ozs7Ozs7QUNsQ2E7O0FBRWIsb0I7Ozs7Ozs7Ozs7O0FDRmE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQVk7O0FBRXBDLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCLDJCQUEyQjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0QkFBNEIsUUFBUSxnQ0FBZ0M7OztBQUd2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CLGU7Ozs7Ozs7Ozs7O0FDekROOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ1phOztBQUViO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLDhDQUFROztBQUU1QixhQUFhLG1CQUFPLENBQUMsNERBQWU7O0FBRXBDLGlCQUFpQixtQkFBTyxDQUFDLDRGQUFrQzs7QUFFM0Qsa0JBQWtCLG1CQUFPLENBQUMsOEZBQW1DOztBQUU3RCxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBb0M7O0FBRS9ELGVBQWUsbUJBQU8sQ0FBQyw4RkFBZ0M7O0FBRXZELGlCQUFpQixtQkFBTyxDQUFDLGdGQUE0Qjs7QUFFckQsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0EsRUFBRTs7QUFFRixrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBa0I7O0FBRTVDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkI7Ozs7Ozs7Ozs7O0FDN0RhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEU7Ozs7Ozs7Ozs7O0FDM0JhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsZ0M7Ozs7Ozs7Ozs7O0FDcEJhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEMsZUFBZSxtQkFBTyxDQUFDLGtHQUFxQztBQUM1RDs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBa0M7QUFDMUQ7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLHFFQUFjOztBQUVsQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBb0I7O0FBRTlDLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFvQjs7QUFFOUMscUJBQXFCLG1CQUFPLENBQUMsK0ZBQTJCOztBQUV4RCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBMkI7O0FBRXhELG1CQUFtQixtQkFBTyxDQUFDLHVGQUF1Qjs7QUFFbEQsa0JBQWtCLG1CQUFPLENBQUMsbUZBQXFCOztBQUUvQyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBbUI7O0FBRTVDLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFnQjs7QUFFMUMsd0JBQXdCLG1CQUFPLENBQUMsdUZBQXVCOztBQUV2RCxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxxRUFBcUU7QUFDckU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCOzs7Ozs7Ozs7OztBQ2xIYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsNERBQWU7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCw2Qjs7Ozs7Ozs7Ozs7QUNmYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQLEU7Ozs7Ozs7Ozs7O0FDUGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7O0FDakJhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7QUNkYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUCxFOzs7Ozs7Ozs7OztBQ1hhOztBQUViLHVCQUF1QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyxtQkFBbUIsR0FBRyxFQUFFLE9BQU8sa0NBQWtDLDhIQUE4SCxHQUFHLEVBQUUscUJBQXFCOztBQUV4WDtBQUNBOztBQUVBLGVBQWU7QUFDZixvQkFBb0IsRUFBRSxNQUFNLEtBQUssVUFBVSxFQUFFLE1BQU0sS0FBSztBQUN4RDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUN0RWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQTJCOztBQUV6RCxXQUFXLG1CQUFPLENBQUMsbUVBQWE7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEMsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIseUNBQXlDLCtKOzs7Ozs7Ozs7O0FDdkJ6QztBQUNBLFVBQVUsbUJBQU8sQ0FBQyxzR0FBK0I7O0FBRWpEOzs7Ozs7Ozs7OztBQ0hBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0phOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw0RUFBMEI7QUFDakQ7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDMUM7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzdDOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7O0FDdkRBLDZJQUF5RDs7Ozs7Ozs7Ozs7QUNBekQscUlBQWlFOzs7Ozs7Ozs7OztBQ0FqRSx5SEFBd0Q7Ozs7Ozs7Ozs7O0FDQXhELHFJQUFpRTs7Ozs7Ozs7Ozs7O0FDQ2pFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsdUJBQXVCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFN1YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosZUFBZSxtQkFBTyxDQUFDLHlFQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMseUdBQW1DOztBQUVoRSxnQkFBZ0IsbUJBQU8sQ0FBQywwQ0FBTztBQUMvQjs7QUFFQSxxQkFBcUIscUVBQXNCO0FBQzNDO0FBQ0E7O0FBRUEsbURBQW1ELGdHQUFtQztBQUN0Rix1Q0FBdUMsbUJBQU8sQ0FBQyxvREFBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBNkI7O0FBRXhEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sZUFBZSxPQUFPLGVBQWUsT0FBTyxXQUFXLE9BQU87QUFDdEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUEsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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O0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Ysc0RBQXNEO0FBQ3RELEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsNERBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDRDQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksWUFBWTtBQUNoQjtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1hBOztBQUVhOztBQUViOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQSxxQkFBcUIsT0FBTztBQUM1Qix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsYUFBYTtBQUNiLDREQUE0RDtBQUM1RCxhQUFhO0FBQ2Isa0VBQWtFO0FBQ2xFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGlDQUFtQjtBQUN4QztBQUNBO0FBQ0EsdUJBQXVCLGlDQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFD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aUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBaUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFh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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQW1CO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsaUNBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQW1CO0FBQ3ZEO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQW1CO0FBQ25EO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQW1CO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBbUI7QUFDcEUsa0RBQWtELGlDQUFtQjtBQUNyRTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFtQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixLQUFLOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBLEtBQUs7QUFDTCxlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsaUNBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0EscUJBQXFCLGlDQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCwyQ0FBMkMsY0FBYzs7Ozs7OztVQzkvV3pEO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxnQ0FBZ0MsWUFBWTtXQUM1QztXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQSxDQUFDLEk7Ozs7O1dDUEQsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOd0MiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0Ly9Db21tb25KUzIgQ29tbWVudFxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdC8vQU1EIENvbW1lbnRcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0Ly9Db21tb25KUyBDb21tZW50XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJiaWtldGFnXCJdID0gZmFjdG9yeSgpO1xuXHQvL1Jvb3QgQ29tbWVudFxuXHRlbHNlXG5cdFx0cm9vdFtcImJpa2V0YWdcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiLypcbiAqIEV2ZW50U291cmNlIHBvbHlmaWxsXG4gKiBPcmlnaW5hbGx5IHB1Ymxpc2hlZCBieSBzYyBBbXZUZWsgc3JsIChodHRwczovL2dpdGh1Yi5jb20vYW12dGVrL0V2ZW50U291cmNlKSAtIGRldmVsQGFtdnRlay5jb21cbiAqIEZvcmtlZCBieSBFc3BlbiBIb3ZsYW5kc2RhbCB0byBmaXggYSBmZXcgaXNzdWVzICsgcHVibGlzaCBsYXRlc3QgdmVyc2lvblxuICovXG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgLyogZ2xvYmFsIGRlZmluZSAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgaWYgKGdsb2JhbC5FdmVudFNvdXJjZSAmJiAhZ2xvYmFsLl9ldmVudFNvdXJjZUltcG9ydFByZWZpeCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGV2c0ltcG9ydE5hbWUgPSAocm9vdC5fZXZlbnRTb3VyY2VJbXBvcnRQcmVmaXggfHwgJycpICsgJ0V2ZW50U291cmNlJ1xuICAgIHJvb3RbZXZzSW1wb3J0TmFtZV0gPSBmYWN0b3J5KClcbiAgfVxufSkodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gdGhpcyA6IHNlbGYsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEV2ZW50U291cmNlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKVxuICAgIH1cblxuICAgIHRoaXMuVVJMID0gdXJsXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdmFyIGV2cyA9IHRoaXNcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGV2cy5wb2xsKClcbiAgICB9LCAwKVxuICB9XG5cbiAgRXZlbnRTb3VyY2UucHJvdG90eXBlID0ge1xuICAgIENPTk5FQ1RJTkc6IDAsXG5cbiAgICBPUEVOOiAxLFxuXG4gICAgQ0xPU0VEOiAyLFxuXG4gICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgIGxvZ2dpbmdFbmFibGVkOiBmYWxzZSxcblxuICAgICAgbG9nZ2luZ1ByZWZpeDogJ2V2ZW50c291cmNlJyxcblxuICAgICAgaW50ZXJ2YWw6IDUwMCwgLy8gbWlsbGlzZWNvbmRzXG5cbiAgICAgIGJ1ZmZlclNpemVMaW1pdDogMjU2ICogMTAyNCwgLy8gYnl0ZXNcblxuICAgICAgc2lsZW50VGltZW91dDogMzAwMDAwLCAvLyBtaWxsaXNlY29uZHNcblxuICAgICAgZ2V0QXJnczoge1xuICAgICAgICBldnNfYnVmZmVyX3NpemVfbGltaXQ6IDI1NiAqIDEwMjQsXG4gICAgICB9LFxuXG4gICAgICB4aHJIZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogJ3RleHQvZXZlbnQtc3RyZWFtJyxcbiAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0T3B0aW9uc1xuICAgICAgdmFyIG9wdGlvblxuXG4gICAgICAvLyBzZXQgYWxsIGRlZmF1bHQgb3B0aW9ucy4uLlxuICAgICAgZm9yIChvcHRpb24gaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICB0aGlzW29wdGlvbl0gPSBkZWZhdWx0c1tvcHRpb25dXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgd2l0aCB3aGF0IGlzIGluIG9wdGlvbnNcbiAgICAgIGZvciAob3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbiBpbiBkZWZhdWx0cyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICB0aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBnZXRBcmdzIG9wdGlvbiBpcyBlbmFibGVkXG4gICAgICAvLyBlbnN1cmUgZXZzX2J1ZmZlcl9zaXplX2xpbWl0IGNvcnJlc3BvbmRzIHRvIGJ1ZmZlclNpemVMaW1pdFxuICAgICAgaWYgKHRoaXMuZ2V0QXJncyAmJiB0aGlzLmJ1ZmZlclNpemVMaW1pdCkge1xuICAgICAgICB0aGlzLmdldEFyZ3MuZXZzX2J1ZmZlcl9zaXplX2xpbWl0ID0gdGhpcy5idWZmZXJTaXplTGltaXRcbiAgICAgIH1cblxuICAgICAgLy8gaWYgY29uc29sZSBpcyBub3QgYXZhaWxhYmxlLCBmb3JjZSBsb2dnaW5nRW5hYmxlZCB0byBmYWxzZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGNvbnNvbGUubG9nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmxvZ2dpbmdFbmFibGVkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9nOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMubG9nZ2luZ0VuYWJsZWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coJ1snICsgdGhpcy5sb2dnaW5nUHJlZml4ICsgJ106JyArIG1lc3NhZ2UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHBvbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gdGhpcy5DTE9TRUQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYW51cCgpXG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuQ09OTkVDVElOR1xuICAgICAgICB0aGlzLmN1cnNvciA9IDBcbiAgICAgICAgdGhpcy5jYWNoZSA9ICcnXG4gICAgICAgIHRoaXMuX3hociA9IG5ldyB0aGlzLlhIUih0aGlzKVxuICAgICAgICB0aGlzLnJlc2V0Tm9BY3Rpdml0eVRpbWVyKClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBpbiBhbiBhdHRlbXB0IHRvIHNpbGVuY2UgdGhlIGVycm9yc1xuICAgICAgICB0aGlzLmxvZygnVGhlcmUgd2VyZSBlcnJvcnMgaW5zaWRlIHRoZSBwb29sIHRyeS1jYXRjaCcpXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZXJyb3InLCB7dHlwZTogJ2Vycm9yJywgZGF0YTogZXJyLm1lc3NhZ2V9KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwb2xsQWdhaW46IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgLy8gc2NoZWR1bGUgcG9sbCB0byBiZSBjYWxsZWQgYWZ0ZXIgaW50ZXJ2YWwgbWlsbGlzZWNvbmRzXG4gICAgICB2YXIgZXZzID0gdGhpc1xuICAgICAgZXZzLnJlYWR5U3RhdGUgPSBldnMuQ09OTkVDVElOR1xuICAgICAgZXZzLmRpc3BhdGNoRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBkYXRhOiAnUmVjb25uZWN0aW5nICcsXG4gICAgICB9KVxuICAgICAgdGhpcy5fcG9sbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2cy5wb2xsKClcbiAgICAgIH0sIGludGVydmFsIHx8IDApXG4gICAgfSxcblxuICAgIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubG9nKCdldnMgY2xlYW5pbmcgdXAnKVxuXG4gICAgICBpZiAodGhpcy5fcG9sbFRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbFRpbWVyKVxuICAgICAgICB0aGlzLl9wb2xsVGltZXIgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ub0FjdGl2aXR5VGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9ub0FjdGl2aXR5VGltZXIpXG4gICAgICAgIHRoaXMuX25vQWN0aXZpdHlUaW1lciA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3hocikge1xuICAgICAgICB0aGlzLl94aHIuYWJvcnQoKVxuICAgICAgICB0aGlzLl94aHIgPSBudWxsXG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlc2V0Tm9BY3Rpdml0eVRpbWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zaWxlbnRUaW1lb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9ub0FjdGl2aXR5VGltZXIpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX25vQWN0aXZpdHlUaW1lcilcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZzID0gdGhpc1xuICAgICAgICB0aGlzLl9ub0FjdGl2aXR5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBldnMubG9nKCdUaW1lb3V0ISBzaWxlbnRUSW1lb3V0OicgKyBldnMuc2lsZW50VGltZW91dClcbiAgICAgICAgICBldnMucG9sbEFnYWluKClcbiAgICAgICAgfSwgdGhpcy5zaWxlbnRUaW1lb3V0KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5DTE9TRURcbiAgICAgIHRoaXMubG9nKCdDbG9zaW5nIGNvbm5lY3Rpb24uIHJlYWR5U3RhdGU6ICcgKyB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICB0aGlzLmNsZWFudXAoKVxuICAgIH0sXG5cbiAgICBfb254aHJkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuX3hoclxuXG4gICAgICBpZiAocmVxdWVzdC5pc1JlYWR5KCkgJiYgIXJlcXVlc3QuaGFzRXJyb3IoKSkge1xuICAgICAgICAvLyByZXNldCB0aGUgdGltZXIsIGFzIHdlIGhhdmUgYWN0aXZpdHlcbiAgICAgICAgdGhpcy5yZXNldE5vQWN0aXZpdHlUaW1lcigpXG5cbiAgICAgICAgLy8gbW92ZSB0aGlzIEV2ZW50U291cmNlIHRvIE9QRU4gc3RhdGUuLi5cbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSB0aGlzLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLk9QRU5cbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ29wZW4nLCB7dHlwZTogJ29wZW4nfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZmZXIgPSByZXF1ZXN0LmdldEJ1ZmZlcigpXG5cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiB0aGlzLmJ1ZmZlclNpemVMaW1pdCkge1xuICAgICAgICAgIHRoaXMubG9nKCdidWZmZXIubGVuZ3RoID4gdGhpcy5idWZmZXJTaXplTGltaXQnKVxuICAgICAgICAgIHRoaXMucG9sbEFnYWluKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnNvciA9PSAwICYmIGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gc2tpcCBieXRlIG9yZGVyIG1hcmsgXFx1RkVGRiBjaGFyYWN0ZXIgaWYgaXQgc3RhcnRzIHRoZSBzdHJlYW1cbiAgICAgICAgICBpZiAoYnVmZmVyLnN1YnN0cmluZygwLCAxKSA9PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0TWVzc2FnZUluZGV4ID0gdGhpcy5sYXN0TWVzc2FnZUluZGV4KGJ1ZmZlcilcbiAgICAgICAgaWYgKGxhc3RNZXNzYWdlSW5kZXhbMF0gPj0gdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICB2YXIgbmV3Y3Vyc29yID0gbGFzdE1lc3NhZ2VJbmRleFsxXVxuICAgICAgICAgIHZhciB0b3BhcnNlID0gYnVmZmVyLnN1YnN0cmluZyh0aGlzLmN1cnNvciwgbmV3Y3Vyc29yKVxuICAgICAgICAgIHRoaXMucGFyc2VTdHJlYW0odG9wYXJzZSlcbiAgICAgICAgICB0aGlzLmN1cnNvciA9IG5ld2N1cnNvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcmVxdWVzdCBpcyBmaW5pc2hlZCwgcmVvcGVuIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIGlmIChyZXF1ZXN0LmlzRG9uZSgpKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ3JlcXVlc3QuaXNEb25lKCkuIHJlb3BlbmluZyB0aGUgY29ubmVjdGlvbicpXG4gICAgICAgICAgdGhpcy5wb2xsQWdhaW4odGhpcy5pbnRlcnZhbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuQ0xPU0VEKSB7XG4gICAgICAgIHRoaXMubG9nKCd0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuQ0xPU0VEJylcbiAgICAgICAgdGhpcy5wb2xsQWdhaW4odGhpcy5pbnRlcnZhbClcblxuICAgICAgICAvL01WOiBVbnN1cmUgd2h5IGFuIGVycm9yIHdhcyBwcmV2aW91c2x5IGRpc3BhdGNoZWRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VTdHJlYW06IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgLy8gbm9ybWFsaXplIGxpbmUgc2VwYXJhdG9ycyAoXFxyXFxuLFxccixcXG4pIHRvIFxcblxuICAgICAgLy8gcmVtb3ZlIHdoaXRlIHNwYWNlcyB0aGF0IG1heSBwcmVjZWRlIFxcblxuICAgICAgY2h1bmsgPSB0aGlzLmNhY2hlICsgdGhpcy5ub3JtYWxpemVUb0xGKGNodW5rKVxuXG4gICAgICB2YXIgZXZlbnRzID0gY2h1bmsuc3BsaXQoJ1xcblxcbicpXG5cbiAgICAgIHZhciBpLCBqLCBldmVudFR5cGUsIGRhdGFzLCBsaW5lLCByZXRyeVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBldmVudFR5cGUgPSAnbWVzc2FnZSdcbiAgICAgICAgZGF0YXMgPSBbXVxuICAgICAgICB2YXIgcGFydHMgPSBldmVudHNbaV0uc3BsaXQoJ1xcbicpXG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGluZSA9IHRoaXMudHJpbVdoaXRlU3BhY2UocGFydHNbal0pXG5cbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCdldmVudCcpID09IDApIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IGxpbmUucmVwbGFjZSgvZXZlbnQ6P1xccyovLCAnJylcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUuaW5kZXhPZigncmV0cnknKSA9PSAwKSB7XG4gICAgICAgICAgICByZXRyeSA9IHBhcnNlSW50KGxpbmUucmVwbGFjZSgvcmV0cnk6P1xccyovLCAnJyksIDEwKVxuICAgICAgICAgICAgaWYgKCFpc05hTihyZXRyeSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHJldHJ5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluZGV4T2YoJ2RhdGEnKSA9PSAwKSB7XG4gICAgICAgICAgICBkYXRhcy5wdXNoKGxpbmUucmVwbGFjZSgvZGF0YTo/XFxzKi8sICcnKSlcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUuaW5kZXhPZignaWQ6JykgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RXZlbnRJZCA9IGxpbmUucmVwbGFjZSgvaWQ6P1xccyovLCAnJylcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUuaW5kZXhPZignaWQnKSA9PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHJlc2V0cyB0aGUgaWRcblxuICAgICAgICAgICAgdGhpcy5sYXN0RXZlbnRJZCA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YXMubGVuZ3RoICYmIHRoaXMucmVhZHlTdGF0ZSAhPSB0aGlzLkNMT1NFRCkge1xuICAgICAgICAgIC8vIGRpc3BhdGNoIGEgbmV3IGV2ZW50XG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChcbiAgICAgICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgICAgIGRhdGFzLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5sb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50SWRcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50VHlwZSwgZXZlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZSA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzWydfJyArIHR5cGUgKyAnSGFuZGxlcnMnXVxuXG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbJ29uJyArIHR5cGVdKSB7XG4gICAgICAgIHRoaXNbJ29uJyArIHR5cGVdLmNhbGwodGhpcywgZXZlbnQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXNbJ18nICsgdHlwZSArICdIYW5kbGVycyddKSB7XG4gICAgICAgIHRoaXNbJ18nICsgdHlwZSArICdIYW5kbGVycyddID0gW11cbiAgICAgIH1cblxuICAgICAgdGhpc1snXycgKyB0eXBlICsgJ0hhbmRsZXJzJ10ucHVzaChoYW5kbGVyKVxuICAgIH0sXG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpc1snXycgKyB0eXBlICsgJ0hhbmRsZXJzJ11cbiAgICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGksIDEpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcG9sbFRpbWVyOiBudWxsLFxuXG4gICAgX25vYWN0aXZpdHlUaW1lcjogbnVsbCxcblxuICAgIF94aHI6IG51bGwsXG5cbiAgICBsYXN0RXZlbnRJZDogbnVsbCxcblxuICAgIGNhY2hlOiAnJyxcblxuICAgIGN1cnNvcjogMCxcblxuICAgIG9uZXJyb3I6IG51bGwsXG5cbiAgICBvbm1lc3NhZ2U6IG51bGwsXG5cbiAgICBvbm9wZW46IG51bGwsXG5cbiAgICByZWFkeVN0YXRlOiAwLFxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIGhlbHBlcnMgZnVuY3Rpb25zXG4gICAgLy8gdGhvc2UgYXJlIGF0dGFjaGVkIHRvIHByb3RvdHlwZSB0byBlYXNlIHJldXNlIGFuZCB0ZXN0aW5nLi4uXG5cbiAgICB1cmxXaXRoUGFyYW1zOiBmdW5jdGlvbiAoYmFzZVVSTCwgcGFyYW1zKSB7XG4gICAgICB2YXIgZW5jb2RlZEFyZ3MgPSBbXVxuXG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBrZXksIHVybGFyZ1xuICAgICAgICB2YXIgdXJsaXplID0gZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB1cmxhcmcgPSB1cmxpemUoa2V5KSArICc9JyArIHVybGl6ZShwYXJhbXNba2V5XSlcbiAgICAgICAgICAgIGVuY29kZWRBcmdzLnB1c2godXJsYXJnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5jb2RlZEFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoYmFzZVVSTC5pbmRleE9mKCc/JykgPT0gLTEpIHJldHVybiBiYXNlVVJMICsgJz8nICsgZW5jb2RlZEFyZ3Muam9pbignJicpXG4gICAgICAgIHJldHVybiBiYXNlVVJMICsgJyYnICsgZW5jb2RlZEFyZ3Muam9pbignJicpXG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVSTFxuICAgIH0sXG5cbiAgICBsYXN0TWVzc2FnZUluZGV4OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgdmFyIGxuMiA9IHRleHQubGFzdEluZGV4T2YoJ1xcblxcbicpXG4gICAgICB2YXIgbHIyID0gdGV4dC5sYXN0SW5kZXhPZignXFxyXFxyJylcbiAgICAgIHZhciBscmxuMiA9IHRleHQubGFzdEluZGV4T2YoJ1xcclxcblxcclxcbicpXG5cbiAgICAgIGlmIChscmxuMiA+IE1hdGgubWF4KGxuMiwgbHIyKSkge1xuICAgICAgICByZXR1cm4gW2xybG4yLCBscmxuMiArIDRdXG4gICAgICB9XG4gICAgICByZXR1cm4gW01hdGgubWF4KGxuMiwgbHIyKSwgTWF0aC5tYXgobG4yLCBscjIpICsgMl1cbiAgICB9LFxuXG4gICAgdHJpbVdoaXRlU3BhY2U6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIC8vIHRvIHJlbW92ZSB3aGl0ZXNwYWNlcyBsZWZ0IGFuZCByaWdodCBvZiBzdHJpbmdcblxuICAgICAgdmFyIHJlVHJpbSA9IC9eKFxcc3xcXHUwMEEwKSt8KFxcc3xcXHUwMEEwKSskL2dcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZVRyaW0sICcnKVxuICAgIH0sXG5cbiAgICBub3JtYWxpemVUb0xGOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAvLyByZXBsYWNlIFxcciBhbmQgXFxyXFxuIHdpdGggXFxuXG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpXG4gICAgfSxcbiAgfVxuXG4gIGlmIChpc09sZElFKCkpIHtcbiAgICBFdmVudFNvdXJjZS5pc1BvbHlmaWxsID0gJ0lFXzgtOSdcblxuICAgIC8vIHBhdGNoIEV2ZW50U291cmNlIGRlZmF1bHRPcHRpb25zXG4gICAgdmFyIGRlZmF1bHRzID0gRXZlbnRTb3VyY2UucHJvdG90eXBlLmRlZmF1bHRPcHRpb25zXG4gICAgZGVmYXVsdHMueGhySGVhZGVycyA9IG51bGwgLy8gbm8gaGVhZGVycyB3aWxsIGJlIHNlbnRcbiAgICBkZWZhdWx0cy5nZXRBcmdzLmV2c19wcmVhbWJsZSA9IDIwNDggKyA4XG5cbiAgICAvLyBFdmVudFNvdXJjZSB3aWxsIHNlbmQgcmVxdWVzdCB1c2luZyBJbnRlcm5ldCBFeHBsb3JlciBYRG9tYWluUmVxdWVzdFxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5YSFIgPSBmdW5jdGlvbiAoZXZzKSB7XG4gICAgICAvKiBnbG9iYWwgWERvbWFpblJlcXVlc3QgKi9cbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KClcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0XG5cbiAgICAgIC8vIHNldCBoYW5kbGVyc1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXF1ZXN0Ll9yZWFkeSA9IHRydWVcbiAgICAgICAgZXZzLl9vbnhocmRhdGEoKVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZVxuICAgICAgICBldnMuX29ueGhyZGF0YSgpXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZmFpbGVkID0gdHJ1ZVxuICAgICAgICBldnMucmVhZHlTdGF0ZSA9IGV2cy5DTE9TRURcbiAgICAgICAgZXZzLmRpc3BhdGNoRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgZGF0YTogJ1hEb21haW5SZXF1ZXN0IGVycm9yJyxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZhaWxlZCA9IHRydWVcbiAgICAgICAgZXZzLnJlYWR5U3RhdGUgPSBldnMuQ0xPU0VEXG4gICAgICAgIGV2cy5kaXNwYXRjaEV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIGRhdGE6ICdYRG9tYWluUmVxdWVzdCB0aW1lZCBvdXQnLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBYRG9tYWluUmVxdWVzdCBkb2VzIG5vdCBhbGxvdyBzZXR0aW5nIGN1c3RvbSBoZWFkZXJzXG4gICAgICAvLyBJZiBFdmVudFNvdXJjZSBoYXMgZW5hYmxlZCB0aGUgdXNlIG9mIEdFVCBhcmd1bWVudHNcbiAgICAgIC8vIHdlIGFkZCBwYXJhbWV0ZXJzIHRvIFVSTCBzbyB0aGF0IHNlcnZlciBjYW4gYWRhcHQgdGhlIHN0cmVhbS4uLlxuICAgICAgdmFyIHJlcUdldEFyZ3MgPSB7fVxuICAgICAgaWYgKGV2cy5nZXRBcmdzKSB7XG4gICAgICAgIC8vIGNvcHkgZXZzLmdldEFyZ3MgaW4gcmVxR2V0QXJnc1xuICAgICAgICB2YXIgZGVmYXVsdEFyZ3MgPSBldnMuZ2V0QXJnc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdEFyZ3MpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEFyZ3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmVxR2V0QXJnc1trZXldID0gZGVmYXVsdEFyZ3Nba2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZzLmxhc3RFdmVudElkKSB7XG4gICAgICAgICAgcmVxR2V0QXJncy5ldnNfbGFzdF9ldmVudF9pZCA9IGV2cy5sYXN0RXZlbnRJZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBzZW5kIHRoZSByZXF1ZXN0XG5cbiAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgZXZzLnVybFdpdGhQYXJhbXMoZXZzLlVSTCwgcmVxR2V0QXJncykpXG4gICAgICByZXF1ZXN0LnNlbmQoKVxuICAgIH1cblxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5YSFIucHJvdG90eXBlID0ge1xuICAgICAgdXNlWERvbWFpblJlcXVlc3Q6IHRydWUsXG5cbiAgICAgIF9yZXF1ZXN0OiBudWxsLFxuXG4gICAgICBfcmVhZHk6IGZhbHNlLCAvLyB0cnVlIHdoZW4gcHJvZ3Jlc3MgZXZlbnRzIGFyZSBkaXNwYXRjaGVkXG5cbiAgICAgIF9sb2FkZWQ6IGZhbHNlLCAvLyB0cnVlIHdoZW4gcmVxdWVzdCBoYXMgYmVlbiBsb2FkZWRcblxuICAgICAgX2ZhaWxlZDogZmFsc2UsIC8vIHRydWUgaWYgd2hlbiByZXF1ZXN0IGlzIGluIGVycm9yXG5cbiAgICAgIGlzUmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QuX3JlYWR5XG4gICAgICB9LFxuXG4gICAgICBpc0RvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QuX2xvYWRlZFxuICAgICAgfSxcblxuICAgICAgaGFzRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QuX2ZhaWxlZFxuICAgICAgfSxcblxuICAgICAgZ2V0QnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydiA9ICcnXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnYgPSB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dCB8fCAnJ1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbCBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2XG4gICAgICB9LFxuXG4gICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBFdmVudFNvdXJjZS5pc1BvbHlmaWxsID0gJ1hIUidcblxuICAgIC8vIEV2ZW50U291cmNlIHdpbGwgc2VuZCByZXF1ZXN0IHVzaW5nIFhNTEh0dHBSZXF1ZXN0XG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLlhIUiA9IGZ1bmN0aW9uIChldnMpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0XG4gICAgICBldnMuX3hociA9IHRoaXNcblxuICAgICAgLy8gc2V0IGhhbmRsZXJzXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA+IDEgJiYgZXZzLnJlYWR5U3RhdGUgIT0gZXZzLkNMT1NFRCkge1xuICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PSAyMDAgfHwgKHJlcXVlc3Quc3RhdHVzID49IDMwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDQwMCkpIHtcbiAgICAgICAgICAgIGV2cy5fb254aHJkYXRhKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5fZmFpbGVkID0gdHJ1ZVxuICAgICAgICAgICAgZXZzLnJlYWR5U3RhdGUgPSBldnMuQ0xPU0VEXG4gICAgICAgICAgICBldnMuZGlzcGF0Y2hFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgIGRhdGE6ICdUaGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoICcgKyByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBldnMuY2xvc2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsIG5vb3BcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBldnMudXJsV2l0aFBhcmFtcyhldnMuVVJMLCBldnMuZ2V0QXJncyksIHRydWUpXG5cbiAgICAgIHZhciBoZWFkZXJzID0gZXZzLnhockhlYWRlcnMgLy8gbWF5YmUgbnVsbFxuICAgICAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGV2cy5sYXN0RXZlbnRJZCkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0xhc3QtRXZlbnQtSWQnLCBldnMubGFzdEV2ZW50SWQpXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3Quc2VuZCgpXG4gICAgfVxuXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLlhIUi5wcm90b3R5cGUgPSB7XG4gICAgICB1c2VYRG9tYWluUmVxdWVzdDogZmFsc2UsXG5cbiAgICAgIF9yZXF1ZXN0OiBudWxsLFxuXG4gICAgICBfZmFpbGVkOiBmYWxzZSwgLy8gdHJ1ZSBpZiB3ZSBoYXZlIGhhZCBlcnJvcnMuLi5cblxuICAgICAgaXNSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdC5yZWFkeVN0YXRlID49IDJcbiAgICAgIH0sXG5cbiAgICAgIGlzRG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdC5yZWFkeVN0YXRlID09IDRcbiAgICAgIH0sXG5cbiAgICAgIGhhc0Vycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsZWQgfHwgdGhpcy5fcmVxdWVzdC5zdGF0dXMgPj0gNDAwXG4gICAgICB9LFxuXG4gICAgICBnZXRCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJ2ID0gJydcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydiA9IHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0IHx8ICcnXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsIG5vb3BcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnZcbiAgICAgIH0sXG5cbiAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gTWVzc2FnZUV2ZW50KHR5cGUsIGRhdGEsIG9yaWdpbiwgbGFzdEV2ZW50SWQpIHtcbiAgICB0aGlzLmJ1YmJsZXMgPSBmYWxzZVxuICAgIHRoaXMuY2FuY2VsQnViYmxlID0gZmFsc2VcbiAgICB0aGlzLmNhbmNlbGFibGUgPSBmYWxzZVxuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbnVsbFxuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luIHx8ICcnXG4gICAgdGhpcy5sYXN0RXZlbnRJZCA9IGxhc3RFdmVudElkIHx8ICcnXG4gICAgdGhpcy50eXBlID0gdHlwZSB8fCAnbWVzc2FnZSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgLy9yZXR1cm4gdHJ1ZSBpZiB3ZSBhcmUgaW4gSUU4IG9yIElFOVxuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmXG4gICAgICAgIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJlxuICAgICAgICBuZXcgWE1MSHR0cFJlcXVlc3QoKS5yZXNwb25zZVR5cGUgPT09IHVuZGVmaW5lZFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBFdmVudFNvdXJjZVxufSlcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdAc2FuaXR5L29ic2VydmFibGUvb3BlcmF0b3JzL21hcCcpLFxuICAgIG1hcCA9IF9yZXF1aXJlLm1hcDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvZmlsdGVyJyksXG4gICAgZmlsdGVyID0gX3JlcXVpcmUyLmZpbHRlcjtcblxudmFyIHF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgnLi4vaHR0cC9xdWVyeVN0cmluZycpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKTtcblxuZnVuY3Rpb24gQXNzZXRzQ2xpZW50KGNsaWVudCkge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuZnVuY3Rpb24gdG9Eb2N1bWVudChib2R5KSB7XG4gIC8vIHRvZG86IHJld3JpdGUgdG8ganVzdCByZXR1cm4gYm9keS5kb2N1bWVudCBpbiBhIHdoaWxlXG4gIHZhciBkb2N1bWVudCA9IGJvZHkuZG9jdW1lbnQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgJ2RvY3VtZW50Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignVGhlIHByb21pc2UgcmV0dXJuZWQgZnJvbSBjbGllbnQuYXNzZXQudXBsb2FkKC4uLikgbm93IHJlc29sdmVzIHdpdGggdGhlIGFzc2V0IGRvY3VtZW50Jyk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBvcHRpb25zRnJvbUZpbGUob3B0cywgZmlsZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShmaWxlIGluc3RhbmNlb2Ygd2luZG93LkZpbGUpKSB7XG4gICAgcmV0dXJuIG9wdHM7XG4gIH1cblxuICByZXR1cm4gYXNzaWduKHtcbiAgICBmaWxlbmFtZTogb3B0cy5wcmVzZXJ2ZUZpbGVuYW1lID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IGZpbGUubmFtZSxcbiAgICBjb250ZW50VHlwZTogZmlsZS50eXBlXG4gIH0sIG9wdHMpO1xufVxuXG5hc3NpZ24oQXNzZXRzQ2xpZW50LnByb3RvdHlwZSwge1xuICAvKipcbiAgICogVXBsb2FkIGFuIGFzc2V0XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYXNzZXRUeXBlIGBpbWFnZWAgb3IgYGZpbGVgXG4gICAqIEBwYXJhbSAge0ZpbGV8QmxvYnxCdWZmZXJ8UmVhZGFibGVTdHJlYW19IGJvZHkgRmlsZSB0byB1cGxvYWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0cyBPcHRpb25zIGZvciB0aGUgdXBsb2FkXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdHMucHJlc2VydmVGaWxlbmFtZSBXaGV0aGVyIG9yIG5vdCB0byBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgZmlsZW5hbWUgKGRlZmF1bHQ6IHRydWUpXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIG9wdHMuZmlsZW5hbWUgRmlsZW5hbWUgZm9yIHRoaXMgZmlsZSAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSAge051bWJlcn0gIG9wdHMudGltZW91dCAgTWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHRpbWluZyB0aGUgcmVxdWVzdCBvdXQgKGRlZmF1bHQ6IDApXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIG9wdHMuY29udGVudFR5cGUgTWltZSB0eXBlIG9mIHRoZSBmaWxlXG4gICAqIEBwYXJhbSAge0FycmF5fSAgIG9wdHMuZXh0cmFjdCBBcnJheSBvZiBtZXRhZGF0YSBwYXJ0cyB0byBleHRyYWN0IGZyb20gaW1hZ2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgdmFsdWVzOiBgbG9jYXRpb25gLCBgZXhpZmAsIGBpbWFnZWAsIGBwYWxldHRlYFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRzLmxhYmVsIExhYmVsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIG9wdHMudGl0bGUgVGl0bGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgb3B0cy5kZXNjcmlwdGlvbiBEZXNjcmlwdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRzLmNyZWRpdExpbmUgVGhlIGNyZWRpdCB0byBwZXJzb24ocykgYW5kL29yIG9yZ2FuaXphdGlvbihzKSByZXF1aXJlZCBieSB0aGUgc3VwcGxpZXIgb2YgdGhlIGltYWdlIHRvIGJlIHVzZWQgd2hlbiBwdWJsaXNoZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0cy5zb3VyY2UgU291cmNlIGRhdGEgKHdoZW4gdGhlIGFzc2V0IGlzIGZyb20gYW4gZXh0ZXJuYWwgc2VydmljZSlcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgb3B0cy5zb3VyY2UuaWQgVGhlICh1KWlkIG9mIHRoZSBhc3NldCB3aXRoaW4gdGhlIHNvdXJjZSwgaS5lLiAnaS1mMzIzcjFFJ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXF1aXJlZCBpZiBzb3VyY2UgaXMgZGVmaW5lZFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRzLnNvdXJjZS5uYW1lIFRoZSBuYW1lIG9mIHRoZSBzb3VyY2UsIGkuZS4gJ3Vuc3BsYXNoJ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXF1aXJlZCBpZiBzb3VyY2UgaXMgZGVmaW5lZFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRzLnNvdXJjZS51cmwgQSB1cmwgdG8gd2hlcmUgdG8gZmluZCB0aGUgYXNzZXQsIG9yIGdldCBtb3JlIGluZm8gYWJvdXQgaXQgaW4gdGhlIHNvdXJjZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25hbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB3aXRoIHRoZSBjcmVhdGVkIGFzc2V0IGRvY3VtZW50XG4gICAqL1xuICB1cGxvYWQ6IGZ1bmN0aW9uIHVwbG9hZChhc3NldFR5cGUsIGJvZHkpIHtcbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFsaWRhdG9ycy52YWxpZGF0ZUFzc2V0VHlwZShhc3NldFR5cGUpOyAvLyBJZiBhbiBlbXB0eSBhcnJheSBpcyBnaXZlbiwgZXhwbGljaXRseSBzZXQgYG5vbmVgIHRvIG92ZXJyaWRlIEFQSSBkZWZhdWx0c1xuXG4gICAgdmFyIG1ldGEgPSBvcHRzLmV4dHJhY3QgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKG1ldGEgJiYgIW1ldGEubGVuZ3RoKSB7XG4gICAgICBtZXRhID0gWydub25lJ107XG4gICAgfVxuXG4gICAgdmFyIGRhdGFzZXQgPSB2YWxpZGF0b3JzLmhhc0RhdGFzZXQodGhpcy5jbGllbnQuY2xpZW50Q29uZmlnKTtcbiAgICB2YXIgYXNzZXRFbmRwb2ludCA9IGFzc2V0VHlwZSA9PT0gJ2ltYWdlJyA/ICdpbWFnZXMnIDogJ2ZpbGVzJztcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNGcm9tRmlsZShvcHRzLCBib2R5KTtcbiAgICB2YXIgbGFiZWwgPSBvcHRpb25zLmxhYmVsLFxuICAgICAgICB0aXRsZSA9IG9wdGlvbnMudGl0bGUsXG4gICAgICAgIGRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbixcbiAgICAgICAgY3JlZGl0TGluZSA9IG9wdGlvbnMuY3JlZGl0TGluZSxcbiAgICAgICAgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lLFxuICAgICAgICBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgcXVlcnkgPSB7XG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICBtZXRhOiBtZXRhLFxuICAgICAgY3JlZGl0TGluZTogY3JlZGl0TGluZVxuICAgIH07XG5cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBxdWVyeS5zb3VyY2VJZCA9IHNvdXJjZS5pZDtcbiAgICAgIHF1ZXJ5LnNvdXJjZU5hbWUgPSBzb3VyY2UubmFtZTtcbiAgICAgIHF1ZXJ5LnNvdXJjZVVybCA9IHNvdXJjZS51cmw7XG4gICAgfVxuXG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLmNsaWVudC5fcmVxdWVzdE9ic2VydmFibGUoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfHwgMCxcbiAgICAgIHVyaTogXCIvYXNzZXRzL1wiLmNvbmNhdChhc3NldEVuZHBvaW50LCBcIi9cIikuY29uY2F0KGRhdGFzZXQpLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5jb250ZW50VHlwZSA/IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IG9wdGlvbnMuY29udGVudFR5cGVcbiAgICAgIH0gOiB7fSxcbiAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmNsaWVudC5pc1Byb21pc2VBUEkoKSA/IG9ic2VydmFibGUucGlwZShmaWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ3Jlc3BvbnNlJztcbiAgICB9KSwgbWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIHRvRG9jdW1lbnQoZXZlbnQuYm9keSk7XG4gICAgfSkpLnRvUHJvbWlzZSgpIDogb2JzZXJ2YWJsZTtcbiAgfSxcbiAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKHR5cGUsIGlkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oJ2NsaWVudC5hc3NldHMuZGVsZXRlKCkgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBjbGllbnQuZGVsZXRlKDxkb2N1bWVudC1pZD4pJyk7XG4gICAgdmFyIGRvY0lkID0gaWQgfHwgJyc7XG5cbiAgICBpZiAoIS9eKGltYWdlfGZpbGUpLS8udGVzdChkb2NJZCkpIHtcbiAgICAgIGRvY0lkID0gXCJcIi5jb25jYXQodHlwZSwgXCItXCIpLmNvbmNhdChkb2NJZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLl9pZCkge1xuICAgICAgLy8gV2UgY291bGQgYmUgcGFzc2luZyBhbiBlbnRpcmUgYXNzZXQgZG9jdW1lbnQgaW5zdGVhZCBvZiBhbiBJRFxuICAgICAgZG9jSWQgPSB0eXBlLl9pZDtcbiAgICB9XG5cbiAgICB2YWxpZGF0b3JzLmhhc0RhdGFzZXQodGhpcy5jbGllbnQuY2xpZW50Q29uZmlnKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZGVsZXRlKGRvY0lkKTtcbiAgfSxcbiAgZ2V0SW1hZ2VVcmw6IGZ1bmN0aW9uIGdldEltYWdlVXJsKHJlZiwgcXVlcnkpIHtcbiAgICB2YXIgaWQgPSByZWYuX3JlZiB8fCByZWY7XG5cbiAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRJbWFnZVVybCgpIG5lZWRzIGVpdGhlciBhbiBvYmplY3Qgd2l0aCBhIF9yZWYsIG9yIGEgc3RyaW5nIHdpdGggYW4gYXNzZXQgZG9jdW1lbnQgSUQnKTtcbiAgICB9XG5cbiAgICBpZiAoIS9eaW1hZ2UtW0EtWmEtejAtOV9dKy1cXGQreFxcZCstW2Etel17MSw1fSQvLnRlc3QoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhc3NldCBJRCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCIuIFVSTCBnZW5lcmF0aW9uIG9ubHkgd29ya3MgZm9yIGF1dG8tZ2VuZXJhdGVkIElEcy5cIikpO1xuICAgIH1cblxuICAgIHZhciBfaWQkc3BsaXQgPSBpZC5zcGxpdCgnLScpLFxuICAgICAgICBfaWQkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX2lkJHNwbGl0LCA0KSxcbiAgICAgICAgYXNzZXRJZCA9IF9pZCRzcGxpdDJbMV0sXG4gICAgICAgIHNpemUgPSBfaWQkc3BsaXQyWzJdLFxuICAgICAgICBmb3JtYXQgPSBfaWQkc3BsaXQyWzNdO1xuXG4gICAgdmFsaWRhdG9ycy5oYXNEYXRhc2V0KHRoaXMuY2xpZW50LmNsaWVudENvbmZpZyk7XG4gICAgdmFyIF90aGlzJGNsaWVudCRjbGllbnRDbyA9IHRoaXMuY2xpZW50LmNsaWVudENvbmZpZyxcbiAgICAgICAgcHJvamVjdElkID0gX3RoaXMkY2xpZW50JGNsaWVudENvLnByb2plY3RJZCxcbiAgICAgICAgZGF0YXNldCA9IF90aGlzJGNsaWVudCRjbGllbnRDby5kYXRhc2V0O1xuICAgIHZhciBxcyA9IHF1ZXJ5ID8gcXVlcnlTdHJpbmcocXVlcnkpIDogJyc7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9jZG4uc2FuaXR5LmlvL2ltYWdlcy9cIi5jb25jYXQocHJvamVjdElkLCBcIi9cIikuY29uY2F0KGRhdGFzZXQsIFwiL1wiKS5jb25jYXQoYXNzZXRJZCwgXCItXCIpLmNvbmNhdChzaXplLCBcIi5cIikuY29uY2F0KGZvcm1hdCkuY29uY2F0KHFzKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEFzc2V0c0NsaWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gQXV0aENsaWVudChjbGllbnQpIHtcbiAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbmFzc2lnbihBdXRoQ2xpZW50LnByb3RvdHlwZSwge1xuICBnZXRMb2dpblByb3ZpZGVyczogZnVuY3Rpb24gZ2V0TG9naW5Qcm92aWRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgdXJpOiAnL2F1dGgvcHJvdmlkZXJzJ1xuICAgIH0pO1xuICB9LFxuICBsb2dvdXQ6IGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICB1cmk6ICcvYXV0aC9sb2dvdXQnLFxuICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICB9KTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhDbGllbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnZW5lcmF0ZUhlbHBVcmwgPSByZXF1aXJlKCdAc2FuaXR5L2dlbmVyYXRlLWhlbHAtdXJsJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdG9ycycpO1xuXG52YXIgd2FybmluZ3MgPSByZXF1aXJlKCcuL3dhcm5pbmdzJyk7XG5cbnZhciBkZWZhdWx0Q2RuSG9zdCA9ICdhcGljZG4uc2FuaXR5LmlvJztcbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICBhcGlIb3N0OiAnaHR0cHM6Ly9hcGkuc2FuaXR5LmlvJyxcbiAgYXBpVmVyc2lvbjogJzEnLFxuICB1c2VQcm9qZWN0SG9zdG5hbWU6IHRydWUsXG4gIGdyYWRpZW50TW9kZTogZmFsc2UsXG4gIGlzUHJvbWlzZUFQSTogdHJ1ZVxufTtcbnZhciBMT0NBTEhPU1RTID0gWydsb2NhbGhvc3QnLCAnMTI3LjAuMC4xJywgJzAuMC4wLjAnXTtcblxudmFyIGlzTG9jYWwgPSBmdW5jdGlvbiBpc0xvY2FsKGhvc3QpIHtcbiAgcmV0dXJuIExPQ0FMSE9TVFMuaW5kZXhPZihob3N0KSAhPT0gLTE7XG59O1xuXG5leHBvcnRzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5leHBvcnRzLmluaXRDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnLCBwcmV2Q29uZmlnKSB7XG4gIHZhciBzcGVjaWZpZWRDb25maWcgPSBhc3NpZ24oe30sIHByZXZDb25maWcsIGNvbmZpZyk7XG5cbiAgaWYgKCFzcGVjaWZpZWRDb25maWcuYXBpVmVyc2lvbikge1xuICAgIHdhcm5pbmdzLnByaW50Tm9BcGlWZXJzaW9uU3BlY2lmaWVkV2FybmluZygpO1xuICB9XG5cbiAgdmFyIG5ld0NvbmZpZyA9IGFzc2lnbih7fSwgZGVmYXVsdENvbmZpZywgc3BlY2lmaWVkQ29uZmlnKTtcbiAgdmFyIGdyYWRpZW50TW9kZSA9IG5ld0NvbmZpZy5ncmFkaWVudE1vZGU7XG4gIHZhciBwcm9qZWN0QmFzZWQgPSAhZ3JhZGllbnRNb2RlICYmIG5ld0NvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWU7XG5cbiAgaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBoZWxwVXJsID0gZ2VuZXJhdGVIZWxwVXJsKCdqcy1jbGllbnQtcHJvbWlzZS1wb2x5ZmlsbCcpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5hdGl2ZSBQcm9taXNlLWltcGxlbWVudGF0aW9uIGZvdW5kLCBwb2x5ZmlsbCBuZWVkZWQgLSBzZWUgXCIuY29uY2F0KGhlbHBVcmwpKTtcbiAgfVxuXG4gIGlmIChncmFkaWVudE1vZGUgJiYgIW5ld0NvbmZpZy5uYW1lc3BhY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZ3VyYXRpb24gbXVzdCBjb250YWluIGBuYW1lc3BhY2VgIHdoZW4gcnVubmluZyBpbiBncmFkaWVudCBtb2RlJyk7XG4gIH1cblxuICBpZiAocHJvamVjdEJhc2VkICYmICFuZXdDb25maWcucHJvamVjdElkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWd1cmF0aW9uIG11c3QgY29udGFpbiBgcHJvamVjdElkYCcpO1xuICB9XG5cbiAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gIHZhciBpc0xvY2FsaG9zdCA9IGlzQnJvd3NlciAmJiBpc0xvY2FsKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk7XG5cbiAgaWYgKGlzQnJvd3NlciAmJiBpc0xvY2FsaG9zdCAmJiBuZXdDb25maWcudG9rZW4gJiYgbmV3Q29uZmlnLmlnbm9yZUJyb3dzZXJUb2tlbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICB3YXJuaW5ncy5wcmludEJyb3dzZXJUb2tlbldhcm5pbmcoKTtcbiAgfSBlbHNlIGlmICgoIWlzQnJvd3NlciB8fCBpc0xvY2FsaG9zdCkgJiYgbmV3Q29uZmlnLnVzZUNkbiAmJiBuZXdDb25maWcudG9rZW4pIHtcbiAgICB3YXJuaW5ncy5wcmludENkblRva2VuV2FybmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDb25maWcudXNlQ2RuID09PSAndW5kZWZpbmVkJykge1xuICAgIHdhcm5pbmdzLnByaW50Q2RuV2FybmluZygpO1xuICB9XG5cbiAgaWYgKHByb2plY3RCYXNlZCkge1xuICAgIHZhbGlkYXRlLnByb2plY3RJZChuZXdDb25maWcucHJvamVjdElkKTtcbiAgfVxuXG4gIGlmICghZ3JhZGllbnRNb2RlICYmIG5ld0NvbmZpZy5kYXRhc2V0KSB7XG4gICAgdmFsaWRhdGUuZGF0YXNldChuZXdDb25maWcuZGF0YXNldCwgbmV3Q29uZmlnLmdyYWRpZW50TW9kZSk7XG4gIH1cblxuICBuZXdDb25maWcuYXBpVmVyc2lvbiA9IFwiXCIuY29uY2F0KG5ld0NvbmZpZy5hcGlWZXJzaW9uKS5yZXBsYWNlKC9edi8sICcnKTtcbiAgbmV3Q29uZmlnLmlzRGVmYXVsdEFwaSA9IG5ld0NvbmZpZy5hcGlIb3N0ID09PSBkZWZhdWx0Q29uZmlnLmFwaUhvc3Q7XG4gIG5ld0NvbmZpZy51c2VDZG4gPSBCb29sZWFuKG5ld0NvbmZpZy51c2VDZG4pICYmICFuZXdDb25maWcudG9rZW4gJiYgIW5ld0NvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gIGV4cG9ydHMudmFsaWRhdGVBcGlWZXJzaW9uKG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcblxuICBpZiAobmV3Q29uZmlnLmdyYWRpZW50TW9kZSkge1xuICAgIG5ld0NvbmZpZy51cmwgPSBuZXdDb25maWcuYXBpSG9zdDtcbiAgICBuZXdDb25maWcuY2RuVXJsID0gbmV3Q29uZmlnLmFwaUhvc3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGhvc3RQYXJ0cyA9IG5ld0NvbmZpZy5hcGlIb3N0LnNwbGl0KCc6Ly8nLCAyKTtcbiAgICB2YXIgcHJvdG9jb2wgPSBob3N0UGFydHNbMF07XG4gICAgdmFyIGhvc3QgPSBob3N0UGFydHNbMV07XG4gICAgdmFyIGNkbkhvc3QgPSBuZXdDb25maWcuaXNEZWZhdWx0QXBpID8gZGVmYXVsdENkbkhvc3QgOiBob3N0O1xuXG4gICAgaWYgKG5ld0NvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWUpIHtcbiAgICAgIG5ld0NvbmZpZy51cmwgPSBcIlwiLmNvbmNhdChwcm90b2NvbCwgXCI6Ly9cIikuY29uY2F0KG5ld0NvbmZpZy5wcm9qZWN0SWQsIFwiLlwiKS5jb25jYXQoaG9zdCwgXCIvdlwiKS5jb25jYXQobmV3Q29uZmlnLmFwaVZlcnNpb24pO1xuICAgICAgbmV3Q29uZmlnLmNkblVybCA9IFwiXCIuY29uY2F0KHByb3RvY29sLCBcIjovL1wiKS5jb25jYXQobmV3Q29uZmlnLnByb2plY3RJZCwgXCIuXCIpLmNvbmNhdChjZG5Ib3N0LCBcIi92XCIpLmNvbmNhdChuZXdDb25maWcuYXBpVmVyc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NvbmZpZy51cmwgPSBcIlwiLmNvbmNhdChuZXdDb25maWcuYXBpSG9zdCwgXCIvdlwiKS5jb25jYXQobmV3Q29uZmlnLmFwaVZlcnNpb24pO1xuICAgICAgbmV3Q29uZmlnLmNkblVybCA9IG5ld0NvbmZpZy51cmw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0NvbmZpZztcbn07XG5cbmV4cG9ydHMudmFsaWRhdGVBcGlWZXJzaW9uID0gZnVuY3Rpb24gdmFsaWRhdGVBcGlWZXJzaW9uKGFwaVZlcnNpb24pIHtcbiAgaWYgKGFwaVZlcnNpb24gPT09ICcxJyB8fCBhcGlWZXJzaW9uID09PSAnWCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXBpRGF0ZSA9IG5ldyBEYXRlKGFwaVZlcnNpb24pO1xuICB2YXIgYXBpVmVyc2lvblZhbGlkID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLnRlc3QoYXBpVmVyc2lvbikgJiYgYXBpRGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgYXBpRGF0ZS5nZXRUaW1lKCkgPiAwO1xuXG4gIGlmICghYXBpVmVyc2lvblZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFQSSB2ZXJzaW9uIHN0cmluZywgZXhwZWN0ZWQgYDFgIG9yIGRhdGUgaW4gZm9ybWF0IGBZWVlZLU1NLUREYCcpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdAc2FuaXR5L29ic2VydmFibGUvb3BlcmF0b3JzL2ZpbHRlcicpLFxuICAgIGZpbHRlciA9IF9yZXF1aXJlLmZpbHRlcjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ0BzYW5pdHkvb2JzZXJ2YWJsZS9vcGVyYXRvcnMvbWFwJyksXG4gICAgbWFwID0gX3JlcXVpcmUyLm1hcDtcblxudmFyIHZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XG5cbnZhciBnZXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi91dGlsL2dldFNlbGVjdGlvbicpO1xuXG52YXIgZW5jb2RlUXVlcnlTdHJpbmcgPSByZXF1aXJlKCcuL2VuY29kZVF1ZXJ5U3RyaW5nJyk7XG5cbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcblxudmFyIFBhdGNoID0gcmVxdWlyZSgnLi9wYXRjaCcpO1xuXG52YXIgbGlzdGVuID0gcmVxdWlyZSgnLi9saXN0ZW4nKTtcblxudmFyIGV4Y2x1ZGVGYWxzZXkgPSBmdW5jdGlvbiBleGNsdWRlRmFsc2V5KHBhcmFtLCBkZWZWYWx1ZSkge1xuICB2YXIgdmFsdWUgPSB0eXBlb2YgcGFyYW0gPT09ICd1bmRlZmluZWQnID8gZGVmVmFsdWUgOiBwYXJhbTtcbiAgcmV0dXJuIHBhcmFtID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufTtcblxudmFyIGdldE11dGF0aW9uUXVlcnkgPSBmdW5jdGlvbiBnZXRNdXRhdGlvblF1ZXJ5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiB7XG4gICAgcmV0dXJuSWRzOiB0cnVlLFxuICAgIHJldHVybkRvY3VtZW50czogZXhjbHVkZUZhbHNleShvcHRpb25zLnJldHVybkRvY3VtZW50cywgdHJ1ZSksXG4gICAgdmlzaWJpbGl0eTogb3B0aW9ucy52aXNpYmlsaXR5IHx8ICdzeW5jJ1xuICB9O1xufTtcblxudmFyIGlzUmVzcG9uc2UgPSBmdW5jdGlvbiBpc1Jlc3BvbnNlKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSAncmVzcG9uc2UnO1xufTtcblxudmFyIGdldEJvZHkgPSBmdW5jdGlvbiBnZXRCb2R5KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5ib2R5O1xufTtcblxudmFyIGluZGV4QnkgPSBmdW5jdGlvbiBpbmRleEJ5KGRvY3MsIGF0dHIpIHtcbiAgcmV0dXJuIGRvY3MucmVkdWNlKGZ1bmN0aW9uIChpbmRleGVkLCBkb2MpIHtcbiAgICBpbmRleGVkW2F0dHIoZG9jKV0gPSBkb2M7XG4gICAgcmV0dXJuIGluZGV4ZWQ7XG4gIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufTtcblxudmFyIHRvUHJvbWlzZSA9IGZ1bmN0aW9uIHRvUHJvbWlzZShvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLnRvUHJvbWlzZSgpO1xufTtcblxudmFyIGdldFF1ZXJ5U2l6ZUxpbWl0ID0gMTEyNjQ7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGlzdGVuOiBsaXN0ZW4sXG4gIGdldERhdGFVcmw6IGZ1bmN0aW9uIGdldERhdGFVcmwob3BlcmF0aW9uLCBwYXRoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY2xpZW50Q29uZmlnO1xuICAgIHZhciBjYXRhbG9nID0gY29uZmlnLmdyYWRpZW50TW9kZSA/IGNvbmZpZy5uYW1lc3BhY2UgOiB2YWxpZGF0b3JzLmhhc0RhdGFzZXQoY29uZmlnKTtcbiAgICB2YXIgYmFzZVVyaSA9IFwiL1wiLmNvbmNhdChvcGVyYXRpb24sIFwiL1wiKS5jb25jYXQoY2F0YWxvZyk7XG4gICAgdmFyIHVyaSA9IHBhdGggPyBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9cIikuY29uY2F0KHBhdGgpIDogYmFzZVVyaTtcbiAgICByZXR1cm4gKHRoaXMuY2xpZW50Q29uZmlnLmdyYWRpZW50TW9kZSA/IHVyaSA6IFwiL2RhdGFcIi5jb25jYXQodXJpKSkucmVwbGFjZSgvXFwvKCR8XFw/KS8sICckMScpO1xuICB9LFxuICBmZXRjaDogZnVuY3Rpb24gZmV0Y2gocXVlcnksIHBhcmFtcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgbWFwUmVzcG9uc2UgPSBvcHRpb25zLmZpbHRlclJlc3BvbnNlID09PSBmYWxzZSA/IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSA6IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH07XG5cbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMuX2RhdGFSZXF1ZXN0KCdxdWVyeScsIHtcbiAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfSwgb3B0aW9ucykucGlwZShtYXAobWFwUmVzcG9uc2UpKTtcblxuICAgIHJldHVybiB0aGlzLmlzUHJvbWlzZUFQSSgpID8gdG9Qcm9taXNlKG9ic2VydmFibGUpIDogb2JzZXJ2YWJsZTtcbiAgfSxcbiAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uIGdldERvY3VtZW50KGlkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuZ2V0RGF0YVVybCgnZG9jJywgaWQpLFxuICAgICAganNvbjogdHJ1ZVxuICAgIH07XG5cbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMuX3JlcXVlc3RPYnNlcnZhYmxlKG9wdGlvbnMpLnBpcGUoZmlsdGVyKGlzUmVzcG9uc2UpLCBtYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQuYm9keS5kb2N1bWVudHMgJiYgZXZlbnQuYm9keS5kb2N1bWVudHNbMF07XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNQcm9taXNlQVBJKCkgPyB0b1Byb21pc2Uob2JzZXJ2YWJsZSkgOiBvYnNlcnZhYmxlO1xuICB9LFxuICBnZXREb2N1bWVudHM6IGZ1bmN0aW9uIGdldERvY3VtZW50cyhpZHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5nZXREYXRhVXJsKCdkb2MnLCBpZHMuam9pbignLCcpKSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuXG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLl9yZXF1ZXN0T2JzZXJ2YWJsZShvcHRpb25zKS5waXBlKGZpbHRlcihpc1Jlc3BvbnNlKSwgbWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGluZGV4ZWQgPSBpbmRleEJ5KGV2ZW50LmJvZHkuZG9jdW1lbnRzIHx8IFtdLCBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MuX2lkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ZWRbaWRdIHx8IG51bGw7XG4gICAgICB9KTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gdGhpcy5pc1Byb21pc2VBUEkoKSA/IHRvUHJvbWlzZShvYnNlcnZhYmxlKSA6IG9ic2VydmFibGU7XG4gIH0sXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGRvYywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGUoZG9jLCAnY3JlYXRlJywgb3B0aW9ucyk7XG4gIH0sXG4gIGNyZWF0ZUlmTm90RXhpc3RzOiBmdW5jdGlvbiBjcmVhdGVJZk5vdEV4aXN0cyhkb2MsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0b3JzLnJlcXVpcmVEb2N1bWVudElkKCdjcmVhdGVJZk5vdEV4aXN0cycsIGRvYyk7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZShkb2MsICdjcmVhdGVJZk5vdEV4aXN0cycsIG9wdGlvbnMpO1xuICB9LFxuICBjcmVhdGVPclJlcGxhY2U6IGZ1bmN0aW9uIGNyZWF0ZU9yUmVwbGFjZShkb2MsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0b3JzLnJlcXVpcmVEb2N1bWVudElkKCdjcmVhdGVPclJlcGxhY2UnLCBkb2MpO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGUoZG9jLCAnY3JlYXRlT3JSZXBsYWNlJywgb3B0aW9ucyk7XG4gIH0sXG4gIHBhdGNoOiBmdW5jdGlvbiBwYXRjaChzZWxlY3Rvciwgb3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGF0Y2goc2VsZWN0b3IsIG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9LFxuICBkZWxldGU6IGZ1bmN0aW9uIF9kZWxldGUoc2VsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVJlcXVlc3QoJ211dGF0ZScsIHtcbiAgICAgIG11dGF0aW9uczogW3tcbiAgICAgICAgZGVsZXRlOiBnZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUobXV0YXRpb25zLCBvcHRpb25zKSB7XG4gICAgdmFyIG11dCA9IG11dGF0aW9ucyBpbnN0YW5jZW9mIFBhdGNoIHx8IG11dGF0aW9ucyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gbXV0YXRpb25zLnNlcmlhbGl6ZSgpIDogbXV0YXRpb25zO1xuICAgIHZhciBtdXRzID0gQXJyYXkuaXNBcnJheShtdXQpID8gbXV0IDogW211dF07XG4gICAgdmFyIHRyYW5zYWN0aW9uSWQgPSBvcHRpb25zICYmIG9wdGlvbnMudHJhbnNhY3Rpb25JZDtcbiAgICByZXR1cm4gdGhpcy5kYXRhUmVxdWVzdCgnbXV0YXRlJywge1xuICAgICAgbXV0YXRpb25zOiBtdXRzLFxuICAgICAgdHJhbnNhY3Rpb25JZDogdHJhbnNhY3Rpb25JZFxuICAgIH0sIG9wdGlvbnMpO1xuICB9LFxuICB0cmFuc2FjdGlvbjogZnVuY3Rpb24gdHJhbnNhY3Rpb24ob3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24ob3BlcmF0aW9ucywgdGhpcyk7XG4gIH0sXG4gIGRhdGFSZXF1ZXN0OiBmdW5jdGlvbiBkYXRhUmVxdWVzdChlbmRwb2ludCwgYm9keSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5fZGF0YVJlcXVlc3QoZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNQcm9taXNlQVBJKCkgPyB0b1Byb21pc2UocmVxdWVzdCkgOiByZXF1ZXN0O1xuICB9LFxuICBfZGF0YVJlcXVlc3Q6IGZ1bmN0aW9uIF9kYXRhUmVxdWVzdChlbmRwb2ludCwgYm9keSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgaXNNdXRhdGlvbiA9IGVuZHBvaW50ID09PSAnbXV0YXRlJzsgLy8gQ2hlY2sgaWYgdGhlIHF1ZXJ5IHN0cmluZyBpcyB3aXRoaW4gYSBjb25maWd1cmVkIHRocmVzaG9sZCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGNhbiB1c2UgR0VULiBPdGhlcndpc2UsIHVzZSBQT1NULlxuXG4gICAgdmFyIHN0clF1ZXJ5ID0gIWlzTXV0YXRpb24gJiYgZW5jb2RlUXVlcnlTdHJpbmcoYm9keSk7XG4gICAgdmFyIHVzZUdldCA9ICFpc011dGF0aW9uICYmIHN0clF1ZXJ5Lmxlbmd0aCA8IGdldFF1ZXJ5U2l6ZUxpbWl0O1xuICAgIHZhciBzdHJpbmdRdWVyeSA9IHVzZUdldCA/IHN0clF1ZXJ5IDogJyc7XG4gICAgdmFyIHJldHVybkZpcnN0ID0gb3B0aW9ucy5yZXR1cm5GaXJzdDtcbiAgICB2YXIgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCxcbiAgICAgICAgdG9rZW4gPSBvcHRpb25zLnRva2VuO1xuICAgIHZhciB1cmkgPSB0aGlzLmdldERhdGFVcmwoZW5kcG9pbnQsIHN0cmluZ1F1ZXJ5KTtcbiAgICB2YXIgcmVxT3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogdXNlR2V0ID8gJ0dFVCcgOiAnUE9TVCcsXG4gICAgICB1cmk6IHVyaSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBib2R5OiB1c2VHZXQgPyB1bmRlZmluZWQgOiBib2R5LFxuICAgICAgcXVlcnk6IGlzTXV0YXRpb24gJiYgZ2V0TXV0YXRpb25RdWVyeShvcHRpb25zKSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICB0b2tlbjogdG9rZW5cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0T2JzZXJ2YWJsZShyZXFPcHRpb25zKS5waXBlKGZpbHRlcihpc1Jlc3BvbnNlKSwgbWFwKGdldEJvZHkpLCBtYXAoZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKCFpc011dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IC8vIFNob3VsZCB3ZSByZXR1cm4gZG9jdW1lbnRzP1xuXG5cbiAgICAgIHZhciByZXN1bHRzID0gcmVzLnJlc3VsdHMgfHwgW107XG5cbiAgICAgIGlmIChvcHRpb25zLnJldHVybkRvY3VtZW50cykge1xuICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uZG9jdW1lbnQgOiByZXN1bHRzLm1hcChmdW5jdGlvbiAobXV0KSB7XG4gICAgICAgICAgcmV0dXJuIG11dC5kb2N1bWVudDtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFJldHVybiBhIHJlZHVjZWQgc3Vic2V0XG5cblxuICAgICAgdmFyIGtleSA9IHJldHVybkZpcnN0ID8gJ2RvY3VtZW50SWQnIDogJ2RvY3VtZW50SWRzJztcbiAgICAgIHZhciBpZHMgPSByZXR1cm5GaXJzdCA/IHJlc3VsdHNbMF0gJiYgcmVzdWx0c1swXS5pZCA6IHJlc3VsdHMubWFwKGZ1bmN0aW9uIChtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC5pZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlcy50cmFuc2FjdGlvbklkLFxuICAgICAgICByZXN1bHRzOiByZXN1bHRzXG4gICAgICB9LCBrZXksIGlkcyk7XG4gICAgfSkpO1xuICB9LFxuICBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKGRvYywgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB2YXIgbXV0YXRpb24gPSBfZGVmaW5lUHJvcGVydHkoe30sIG9wLCBkb2MpO1xuXG4gICAgdmFyIG9wdHMgPSBhc3NpZ24oe1xuICAgICAgcmV0dXJuRmlyc3Q6IHRydWUsXG4gICAgICByZXR1cm5Eb2N1bWVudHM6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhUmVxdWVzdCgnbXV0YXRlJywge1xuICAgICAgbXV0YXRpb25zOiBbbXV0YXRpb25dXG4gICAgfSwgb3B0cyk7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbmMgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeSxcbiAgICAgIF9yZWYkcGFyYW1zID0gX3JlZi5wYXJhbXMsXG4gICAgICBwYXJhbXMgPSBfcmVmJHBhcmFtcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHBhcmFtcyxcbiAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zO1xuICB2YXIgYmFzZSA9IFwiP3F1ZXJ5PVwiLmNvbmNhdChlbmMocXVlcnkpKTtcbiAgdmFyIHFTdHJpbmcgPSBPYmplY3Qua2V5cyhwYXJhbXMpLnJlZHVjZShmdW5jdGlvbiAocXMsIHBhcmFtKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHFzLCBcIiZcIikuY29uY2F0KGVuYyhcIiRcIi5jb25jYXQocGFyYW0pKSwgXCI9XCIpLmNvbmNhdChlbmMoSlNPTi5zdHJpbmdpZnkocGFyYW1zW3BhcmFtXSkpKTtcbiAgfSwgYmFzZSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKS5yZWR1Y2UoZnVuY3Rpb24gKHFzLCBvcHRpb24pIHtcbiAgICAvLyBPbmx5IGluY2x1ZGUgdGhlIG9wdGlvbiBpZiBpdCBpcyB0cnV0aHlcbiAgICByZXR1cm4gb3B0aW9uc1tvcHRpb25dID8gXCJcIi5jb25jYXQocXMsIFwiJlwiKS5jb25jYXQoZW5jKG9wdGlvbiksIFwiPVwiKS5jb25jYXQoZW5jKG9wdGlvbnNbb3B0aW9uXSkpIDogcXM7XG4gIH0sIHFTdHJpbmcpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIE9ic2VydmFibGUgPSByZXF1aXJlKCdAc2FuaXR5L29ic2VydmFibGUvbWluaW1hbCcpO1xuXG52YXIgcG9seWZpbGxlZEV2ZW50U291cmNlID0gcmVxdWlyZSgnQHNhbml0eS9ldmVudHNvdXJjZScpO1xuXG52YXIgcGljayA9IHJlcXVpcmUoJy4uL3V0aWwvcGljaycpO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG5cbnZhciBlbmNvZGVRdWVyeVN0cmluZyA9IHJlcXVpcmUoJy4vZW5jb2RlUXVlcnlTdHJpbmcnKTtcblxudmFyIGdlbmVyYXRlSGVscFVybCA9IHJlcXVpcmUoJ0BzYW5pdHkvZ2VuZXJhdGUtaGVscC11cmwnKTtcblxudmFyIG9uY2UgPSByZXF1aXJlKCcuLi91dGlsL29uY2UnKTtcblxudmFyIHRva2VuV2FybmluZyA9IFsnVXNpbmcgdG9rZW4gd2l0aCBsaXN0ZW5lcnMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2Vycy4gJywgXCJGb3IgbW9yZSBpbmZvLCBzZWUgXCIuY29uY2F0KGdlbmVyYXRlSGVscFVybCgnanMtY2xpZW50LWxpc3RlbmVyLXRva2Vucy1icm93c2VyJyksIFwiLlwiKV07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbnZhciBwcmludFRva2VuV2FybmluZyA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY29uc29sZS53YXJuKHRva2VuV2FybmluZy5qb2luKCcgJykpO1xufSk7XG52YXIgaXNXaW5kb3dFdmVudFNvdXJjZSA9IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkV2ZW50U291cmNlKTtcbnZhciBFdmVudFNvdXJjZSA9IGlzV2luZG93RXZlbnRTb3VyY2UgPyB3aW5kb3cuRXZlbnRTb3VyY2UgLy8gTmF0aXZlIGJyb3dzZXIgRXZlbnRTb3VyY2VcbjogcG9seWZpbGxlZEV2ZW50U291cmNlOyAvLyBOb2RlLmpzLCBJRSBldGNcblxudmFyIHBvc3NpYmxlT3B0aW9ucyA9IFsnaW5jbHVkZVByZXZpb3VzUmV2aXNpb24nLCAnaW5jbHVkZVJlc3VsdCcsICd2aXNpYmlsaXR5JywgJ2VmZmVjdEZvcm1hdCddO1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBpbmNsdWRlUmVzdWx0OiB0cnVlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RlbihxdWVyeSwgcGFyYW1zKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRzLCBkZWZhdWx0T3B0aW9ucyk7XG4gIHZhciBsaXN0ZW5PcHRzID0gcGljayhvcHRpb25zLCBwb3NzaWJsZU9wdGlvbnMpO1xuICB2YXIgcXMgPSBlbmNvZGVRdWVyeVN0cmluZyh7XG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHBhcmFtczogcGFyYW1zLFxuICAgIG9wdGlvbnM6IGxpc3Rlbk9wdHNcbiAgfSk7XG4gIHZhciBfdGhpcyRjbGllbnRDb25maWcgPSB0aGlzLmNsaWVudENvbmZpZyxcbiAgICAgIHVybCA9IF90aGlzJGNsaWVudENvbmZpZy51cmwsXG4gICAgICB0b2tlbiA9IF90aGlzJGNsaWVudENvbmZpZy50b2tlbixcbiAgICAgIHdpdGhDcmVkZW50aWFscyA9IF90aGlzJGNsaWVudENvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gIHZhciB1cmkgPSBcIlwiLmNvbmNhdCh1cmwpLmNvbmNhdCh0aGlzLmdldERhdGFVcmwoJ2xpc3RlbicsIHFzKSk7XG4gIHZhciBsaXN0ZW5Gb3IgPSBvcHRpb25zLmV2ZW50cyA/IG9wdGlvbnMuZXZlbnRzIDogWydtdXRhdGlvbiddO1xuICB2YXIgc2hvdWxkRW1pdFJlY29ubmVjdCA9IGxpc3RlbkZvci5pbmRleE9mKCdyZWNvbm5lY3QnKSAhPT0gLTE7XG5cbiAgaWYgKHRva2VuICYmIGlzV2luZG93RXZlbnRTb3VyY2UpIHtcbiAgICBwcmludFRva2VuV2FybmluZygpO1xuICB9XG5cbiAgdmFyIGVzT3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0b2tlbiB8fCB3aXRoQ3JlZGVudGlhbHMpIHtcbiAgICBlc09wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIGVzT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KHRva2VuKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgdmFyIGVzID0gZ2V0RXZlbnRTb3VyY2UoKTtcbiAgICB2YXIgcmVjb25uZWN0VGltZXI7XG4gICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG4gICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVtaXRSZWNvbm5lY3QoKTsgLy8gQWxsb3cgZXZlbnQgaGFuZGxlcnMgb2YgYGVtaXRSZWNvbm5lY3RgIHRvIGNhbmNlbC9jbG9zZSB0aGUgcmVjb25uZWN0IGF0dGVtcHRcblxuICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBVbmxlc3Mgd2UndmUgZXhwbGljaXRseSBzdG9wcGVkIHRoZSBFUyAoaW4gd2hpY2ggY2FzZSBgc3RvcHBlZGAgc2hvdWxkIGJlIHRydWUpLFxuICAgICAgLy8gd2Ugc2hvdWxkIG5ldmVyIGJlIGluIGEgZGlzY29ubmVjdGVkIHN0YXRlLiBCeSBkZWZhdWx0LCBFdmVudFNvdXJjZSB3aWxsIHJlY29ubmVjdFxuICAgICAgLy8gYXV0b21hdGljYWxseSwgaW4gd2hpY2ggY2FzZSBpdCBzZXRzIHJlYWR5U3RhdGUgdG8gYENPTk5FQ1RJTkdgLCBidXQgaW4gc29tZSBjYXNlc1xuICAgICAgLy8gKGxpa2Ugd2hlbiBhIGxhcHRvcCBsaWQgaXMgY2xvc2VkKSwgaXQgY2xvc2VzIHRoZSBjb25uZWN0aW9uLiBJbiB0aGVzZSBjYXNlcyB3ZSBuZWVkXG4gICAgICAvLyB0byBleHBsaWNpdGx5IHJlY29ubmVjdC5cblxuXG4gICAgICBpZiAoZXMucmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lcik7XG4gICAgICAgIHJlY29ubmVjdFRpbWVyID0gc2V0VGltZW91dChvcGVuLCAxMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2hhbm5lbEVycm9yKGVycikge1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IoY29vZXJjZUVycm9yKGVycikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShldnQpIHtcbiAgICAgIHZhciBldmVudCA9IHBhcnNlRXZlbnQoZXZ0KTtcbiAgICAgIHJldHVybiBldmVudCBpbnN0YW5jZW9mIEVycm9yID8gb2JzZXJ2ZXIuZXJyb3IoZXZlbnQpIDogb2JzZXJ2ZXIubmV4dChldmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EaXNjb25uZWN0KGV2dCkge1xuICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvciwgZmFsc2UpO1xuICAgICAgZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbm5lbEVycm9yJywgb25DaGFubmVsRXJyb3IsIGZhbHNlKTtcbiAgICAgIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc2Nvbm5lY3QnLCBvbkRpc2Nvbm5lY3QsIGZhbHNlKTtcbiAgICAgIGxpc3RlbkZvci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBlcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIG9uTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBlcy5jbG9zZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRSZWNvbm5lY3QoKSB7XG4gICAgICBpZiAoc2hvdWxkRW1pdFJlY29ubmVjdCkge1xuICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICB0eXBlOiAncmVjb25uZWN0J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudFNvdXJjZSgpIHtcbiAgICAgIHZhciBldnMgPSBuZXcgRXZlbnRTb3VyY2UodXJpLCBlc09wdGlvbnMpO1xuICAgICAgZXZzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvciwgZmFsc2UpO1xuICAgICAgZXZzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5uZWxFcnJvcicsIG9uQ2hhbm5lbEVycm9yLCBmYWxzZSk7XG4gICAgICBldnMuYWRkRXZlbnRMaXN0ZW5lcignZGlzY29ubmVjdCcsIG9uRGlzY29ubmVjdCwgZmFsc2UpO1xuICAgICAgbGlzdGVuRm9yLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGV2cy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9uTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXZzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICBlcyA9IGdldEV2ZW50U291cmNlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcDtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUV2ZW50KGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhICYmIEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgfHwge307XG4gICAgcmV0dXJuIGFzc2lnbih7XG4gICAgICB0eXBlOiBldmVudC50eXBlXG4gICAgfSwgZGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29vZXJjZUVycm9yKGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgdmFyIGV2dCA9IHBhcnNlRXZlbnQoZXJyKTtcbiAgcmV0dXJuIGV2dCBpbnN0YW5jZW9mIEVycm9yID8gZXZ0IDogbmV3IEVycm9yKGV4dHJhY3RFcnJvck1lc3NhZ2UoZXZ0KSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvck1lc3NhZ2UoZXJyKSB7XG4gIGlmICghZXJyLmVycm9yKSB7XG4gICAgcmV0dXJuIGVyci5tZXNzYWdlIHx8ICdVbmtub3duIGxpc3RlbmVyIGVycm9yJztcbiAgfVxuXG4gIGlmIChlcnIuZXJyb3IuZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZXJyLmVycm9yLmRlc2NyaXB0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBlcnIuZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyLmVycm9yIDogSlNPTi5zdHJpbmdpZnkoZXJyLmVycm9yLCBudWxsLCAyKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGRlZXBBc3NpZ24gPSByZXF1aXJlKCdkZWVwLWFzc2lnbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZ2V0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRTZWxlY3Rpb24nKTtcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xuXG52YXIgdmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZS52YWxpZGF0ZU9iamVjdDtcbnZhciB2YWxpZGF0ZUluc2VydCA9IHZhbGlkYXRlLnZhbGlkYXRlSW5zZXJ0O1xuXG5mdW5jdGlvbiBQYXRjaChzZWxlY3Rpb24pIHtcbiAgdmFyIG9wZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgY2xpZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgdGhpcy5vcGVyYXRpb25zID0gYXNzaWduKHt9LCBvcGVyYXRpb25zKTtcbiAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbmFzc2lnbihQYXRjaC5wcm90b3R5cGUsIHtcbiAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUGF0Y2godGhpcy5zZWxlY3Rpb24sIGFzc2lnbih7fSwgdGhpcy5vcGVyYXRpb25zKSwgdGhpcy5jbGllbnQpO1xuICB9LFxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UocHJvcHMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdCgnbWVyZ2UnLCBwcm9wcyk7XG4gICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH0pLnNsaWNlKDIpO1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBcXFwibWVyZ2VcXFwiIHBhdGNoIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXFxuXCIuY29uY2F0KHN0YWNrLmpvaW4oJ1xcbicpKSk7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbignbWVyZ2UnLCBkZWVwQXNzaWduKHRoaXMub3BlcmF0aW9ucy5tZXJnZSB8fCB7fSwgcHJvcHMpKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQocHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKCdzZXQnLCBwcm9wcyk7XG4gIH0sXG4gIGRpZmZNYXRjaFBhdGNoOiBmdW5jdGlvbiBkaWZmTWF0Y2hQYXRjaChwcm9wcykge1xuICAgIHZhbGlkYXRlT2JqZWN0KCdkaWZmTWF0Y2hQYXRjaCcsIHByb3BzKTtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKCdkaWZmTWF0Y2hQYXRjaCcsIHByb3BzKTtcbiAgfSxcbiAgdW5zZXQ6IGZ1bmN0aW9uIHVuc2V0KGF0dHJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNldChhdHRycykgdGFrZXMgYW4gYXJyYXkgb2YgYXR0cmlidXRlcyB0byB1bnNldCwgbm9uLWFycmF5IGdpdmVuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRpb25zID0gYXNzaWduKHt9LCB0aGlzLm9wZXJhdGlvbnMsIHtcbiAgICAgIHVuc2V0OiBhdHRyc1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRJZk1pc3Npbmc6IGZ1bmN0aW9uIHNldElmTWlzc2luZyhwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oJ3NldElmTWlzc2luZycsIHByb3BzKTtcbiAgfSxcbiAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShwcm9wcykge1xuICAgIHZhbGlkYXRlT2JqZWN0KCdyZXBsYWNlJywgcHJvcHMpO1xuICAgIHJldHVybiB0aGlzLl9zZXQoJ3NldCcsIHtcbiAgICAgICQ6IHByb3BzXG4gICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaWQtbGVuZ3RoXG4gIH0sXG4gIGluYzogZnVuY3Rpb24gaW5jKHByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbignaW5jJywgcHJvcHMpO1xuICB9LFxuICBkZWM6IGZ1bmN0aW9uIGRlYyhwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oJ2RlYycsIHByb3BzKTtcbiAgfSxcbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHZhciBfdGhpcyRfYXNzaWduO1xuXG4gICAgdmFsaWRhdGVJbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbignaW5zZXJ0JywgKF90aGlzJF9hc3NpZ24gPSB7fSwgX2RlZmluZVByb3BlcnR5KF90aGlzJF9hc3NpZ24sIGF0LCBzZWxlY3RvciksIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRfYXNzaWduLCBcIml0ZW1zXCIsIGl0ZW1zKSwgX3RoaXMkX2Fzc2lnbikpO1xuICB9LFxuICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChzZWxlY3RvciwgaXRlbXMpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoJ2FmdGVyJywgXCJcIi5jb25jYXQoc2VsZWN0b3IsIFwiWy0xXVwiKSwgaXRlbXMpO1xuICB9LFxuICBwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kKHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB0aGlzLmluc2VydCgnYmVmb3JlJywgXCJcIi5jb25jYXQoc2VsZWN0b3IsIFwiWzBdXCIpLCBpdGVtcyk7XG4gIH0sXG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHNlbGVjdG9yLCBzdGFydCwgZGVsZXRlQ291bnQsIGl0ZW1zKSB7XG4gICAgLy8gTmVnYXRpdmUgaW5kZXhlcyBkb2Vzbid0IG1lYW4gdGhlIHNhbWUgaW4gU2FuaXR5IGFzIHRoZXkgZG8gaW4gSlM7XG4gICAgLy8gLTEgbWVhbnMgXCJhY3R1YWxseSBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheVwiLCB3aGljaCBhbGxvd3MgaW5zZXJ0aW5nXG4gICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgd2l0aG91dCBrbm93aW5nIGl0cyBsZW5ndGguIFdlIHRoZXJlZm9yZSBoYXZlXG4gICAgLy8gdG8gc3Vic3RyYWN0IG5lZ2F0aXZlIGluZGV4ZXMgYnkgb25lIHRvIG1hdGNoIEpTLiBJZiB5b3Ugd2FudCBTYW5pdHktXG4gICAgLy8gYmVoYXZpb3VyLCBqdXN0IHVzZSBgaW5zZXJ0KCdyZXBsYWNlJywgc2VsZWN0b3IsIGl0ZW1zKWAgZGlyZWN0bHlcbiAgICB2YXIgZGVsQWxsID0gdHlwZW9mIGRlbGV0ZUNvdW50ID09PSAndW5kZWZpbmVkJyB8fCBkZWxldGVDb3VudCA9PT0gLTE7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBzdGFydCA8IDAgPyBzdGFydCAtIDEgOiBzdGFydDtcbiAgICB2YXIgZGVsQ291bnQgPSBkZWxBbGwgPyAtMSA6IE1hdGgubWF4KDAsIHN0YXJ0ICsgZGVsZXRlQ291bnQpO1xuICAgIHZhciBkZWxSYW5nZSA9IHN0YXJ0SW5kZXggPCAwICYmIGRlbENvdW50ID49IDAgPyAnJyA6IGRlbENvdW50O1xuICAgIHZhciByYW5nZVNlbGVjdG9yID0gXCJcIi5jb25jYXQoc2VsZWN0b3IsIFwiW1wiKS5jb25jYXQoc3RhcnRJbmRleCwgXCI6XCIpLmNvbmNhdChkZWxSYW5nZSwgXCJdXCIpO1xuICAgIHJldHVybiB0aGlzLmluc2VydCgncmVwbGFjZScsIHJhbmdlU2VsZWN0b3IsIGl0ZW1zIHx8IFtdKTtcbiAgfSxcbiAgaWZSZXZpc2lvbklkOiBmdW5jdGlvbiBpZlJldmlzaW9uSWQocmV2KSB7XG4gICAgdGhpcy5vcGVyYXRpb25zLmlmUmV2aXNpb25JRCA9IHJldjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIGFzc2lnbihnZXRTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb24pLCB0aGlzLm9wZXJhdGlvbnMpO1xuICB9LFxuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgfSxcbiAgY29tbWl0OiBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgaWYgKCF0aGlzLmNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBgY2xpZW50YCBwYXNzZWQgdG8gcGF0Y2gsIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSAnICsgJ3BhdGNoIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZCcpO1xuICAgIH1cblxuICAgIHZhciByZXR1cm5GaXJzdCA9IHR5cGVvZiB0aGlzLnNlbGVjdGlvbiA9PT0gJ3N0cmluZyc7XG4gICAgdmFyIG9wdHMgPSBhc3NpZ24oe1xuICAgICAgcmV0dXJuRmlyc3Q6IHJldHVybkZpcnN0LFxuICAgICAgcmV0dXJuRG9jdW1lbnRzOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lm11dGF0ZSh7XG4gICAgICBwYXRjaDogdGhpcy5zZXJpYWxpemUoKVxuICAgIH0sIG9wdHMpO1xuICB9LFxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9zZXQ6IGZ1bmN0aW9uIF9zZXQob3AsIHByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihvcCwgcHJvcHMsIGZhbHNlKTtcbiAgfSxcbiAgX2Fzc2lnbjogZnVuY3Rpb24gX2Fzc2lnbihvcCwgcHJvcHMpIHtcbiAgICB2YXIgbWVyZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgdmFsaWRhdGVPYmplY3Qob3AsIHByb3BzKTtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBhc3NpZ24oe30sIHRoaXMub3BlcmF0aW9ucywgX2RlZmluZVByb3BlcnR5KHt9LCBvcCwgYXNzaWduKHt9LCBtZXJnZSAmJiB0aGlzLm9wZXJhdGlvbnNbb3BdIHx8IHt9LCBwcm9wcykpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFBhdGNoOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKTtcblxudmFyIFBhdGNoID0gcmVxdWlyZSgnLi9wYXRjaCcpO1xuXG52YXIgZGVmYXVsdE11dGF0ZU9wdGlvbnMgPSB7XG4gIHJldHVybkRvY3VtZW50czogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIFRyYW5zYWN0aW9uKCkge1xuICB2YXIgb3BlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHZhciBjbGllbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRyYW5zYWN0aW9uSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdGhpcy50cnhJZCA9IHRyYW5zYWN0aW9uSWQ7XG4gIHRoaXMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnM7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG5hc3NpZ24oVHJhbnNhY3Rpb24ucHJvdG90eXBlLCB7XG4gIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMub3BlcmF0aW9ucy5zbGljZSgwKSwgdGhpcy5jbGllbnQsIHRoaXMudHJ4SWQpO1xuICB9LFxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShkb2MpIHtcbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlT2JqZWN0KCdjcmVhdGUnLCBkb2MpO1xuICAgIHJldHVybiB0aGlzLl9hZGQoe1xuICAgICAgY3JlYXRlOiBkb2NcbiAgICB9KTtcbiAgfSxcbiAgY3JlYXRlSWZOb3RFeGlzdHM6IGZ1bmN0aW9uIGNyZWF0ZUlmTm90RXhpc3RzKGRvYykge1xuICAgIHZhciBvcCA9ICdjcmVhdGVJZk5vdEV4aXN0cyc7XG4gICAgdmFsaWRhdG9ycy52YWxpZGF0ZU9iamVjdChvcCwgZG9jKTtcbiAgICB2YWxpZGF0b3JzLnJlcXVpcmVEb2N1bWVudElkKG9wLCBkb2MpO1xuICAgIHJldHVybiB0aGlzLl9hZGQoX2RlZmluZVByb3BlcnR5KHt9LCBvcCwgZG9jKSk7XG4gIH0sXG4gIGNyZWF0ZU9yUmVwbGFjZTogZnVuY3Rpb24gY3JlYXRlT3JSZXBsYWNlKGRvYykge1xuICAgIHZhciBvcCA9ICdjcmVhdGVPclJlcGxhY2UnO1xuICAgIHZhbGlkYXRvcnMudmFsaWRhdGVPYmplY3Qob3AsIGRvYyk7XG4gICAgdmFsaWRhdG9ycy5yZXF1aXJlRG9jdW1lbnRJZChvcCwgZG9jKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkKF9kZWZpbmVQcm9wZXJ0eSh7fSwgb3AsIGRvYykpO1xuICB9LFxuICBkZWxldGU6IGZ1bmN0aW9uIF9kZWxldGUoZG9jdW1lbnRJZCkge1xuICAgIHZhbGlkYXRvcnMudmFsaWRhdGVEb2N1bWVudElkKCdkZWxldGUnLCBkb2N1bWVudElkKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgIGRlbGV0ZToge1xuICAgICAgICBpZDogZG9jdW1lbnRJZFxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBwYXRjaDogZnVuY3Rpb24gcGF0Y2goZG9jdW1lbnRJZCwgcGF0Y2hPcHMpIHtcbiAgICB2YXIgaXNCdWlsZGVyID0gdHlwZW9mIHBhdGNoT3BzID09PSAnZnVuY3Rpb24nO1xuICAgIHZhciBpc1BhdGNoID0gZG9jdW1lbnRJZCBpbnN0YW5jZW9mIFBhdGNoOyAvLyB0cmFuc2FjdGlvbi5wYXRjaChjbGllbnQucGF0Y2goJ2RvY3VtZW50SWQnKS5pbmMoe3Zpc2l0czogMX0pKVxuXG4gICAgaWYgKGlzUGF0Y2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoe1xuICAgICAgICBwYXRjaDogZG9jdW1lbnRJZC5zZXJpYWxpemUoKVxuICAgICAgfSk7XG4gICAgfSAvLyBwYXRjaCA9PiBwYXRjaC5pbmMoe3Zpc2l0czogMX0pLnNldCh7Zm9vOiAnYmFyJ30pXG5cblxuICAgIGlmIChpc0J1aWxkZXIpIHtcbiAgICAgIHZhciBwYXRjaCA9IHBhdGNoT3BzKG5ldyBQYXRjaChkb2N1bWVudElkLCB7fSwgdGhpcy5jbGllbnQpKTtcblxuICAgICAgaWYgKCEocGF0Y2ggaW5zdGFuY2VvZiBQYXRjaCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBwYXNzZWQgdG8gYHBhdGNoKClgIG11c3QgcmV0dXJuIHRoZSBwYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgICAgcGF0Y2g6IHBhdGNoLnNlcmlhbGl6ZSgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgIHBhdGNoOiBhc3NpZ24oe1xuICAgICAgICBpZDogZG9jdW1lbnRJZFxuICAgICAgfSwgcGF0Y2hPcHMpXG4gICAgfSk7XG4gIH0sXG4gIHRyYW5zYWN0aW9uSWQ6IGZ1bmN0aW9uIHRyYW5zYWN0aW9uSWQoaWQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICByZXR1cm4gdGhpcy50cnhJZDtcbiAgICB9XG5cbiAgICB0aGlzLnRyeElkID0gaWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMuc2xpY2UoKTtcbiAgfSxcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gIH0sXG4gIGNvbW1pdDogZnVuY3Rpb24gY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGBjbGllbnRgIHBhc3NlZCB0byB0cmFuc2FjdGlvbiwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlICcgKyAndHJhbnNhY3Rpb24gdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lm11dGF0ZSh0aGlzLnNlcmlhbGl6ZSgpLCBhc3NpZ24oe1xuICAgICAgdHJhbnNhY3Rpb25JZDogdGhpcy50cnhJZFxuICAgIH0sIGRlZmF1bHRNdXRhdGVPcHRpb25zLCBvcHRpb25zIHx8IHt9KSk7XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2FkZDogZnVuY3Rpb24gX2FkZChtdXQpIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChtdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKTtcblxuZnVuY3Rpb24gRGF0YXNldHNDbGllbnQoY2xpZW50KSB7XG4gIHRoaXMucmVxdWVzdCA9IGNsaWVudC5yZXF1ZXN0LmJpbmQoY2xpZW50KTtcbn1cblxuYXNzaWduKERhdGFzZXRzQ2xpZW50LnByb3RvdHlwZSwge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGlmeSgnUFVUJywgbmFtZSwgb3B0aW9ucyk7XG4gIH0sXG4gIGVkaXQ6IGZ1bmN0aW9uIGVkaXQobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9tb2RpZnkoJ1BBVENIJywgbmFtZSwgb3B0aW9ucyk7XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGlmeSgnREVMRVRFJywgbmFtZSk7XG4gIH0sXG4gIGxpc3Q6IGZ1bmN0aW9uIGxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICB1cmk6ICcvZGF0YXNldHMnXG4gICAgfSk7XG4gIH0sXG4gIF9tb2RpZnk6IGZ1bmN0aW9uIF9tb2RpZnkobWV0aG9kLCBuYW1lLCBib2R5KSB7XG4gICAgdmFsaWRhdGUuZGF0YXNldChuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJpOiBcIi9kYXRhc2V0cy9cIi5jb25jYXQobmFtZSksXG4gICAgICBib2R5OiBib2R5XG4gICAgfSk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhc2V0c0NsaWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBbXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1ha2VFcnJvciA9IHJlcXVpcmUoJ21ha2UtZXJyb3InKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gQ2xpZW50RXJyb3IocmVzKSB7XG4gIHZhciBwcm9wcyA9IGV4dHJhY3RFcnJvclByb3BzKHJlcyk7XG4gIENsaWVudEVycm9yLnN1cGVyLmNhbGwodGhpcywgcHJvcHMubWVzc2FnZSk7XG4gIGFzc2lnbih0aGlzLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIFNlcnZlckVycm9yKHJlcykge1xuICB2YXIgcHJvcHMgPSBleHRyYWN0RXJyb3JQcm9wcyhyZXMpO1xuICBTZXJ2ZXJFcnJvci5zdXBlci5jYWxsKHRoaXMsIHByb3BzLm1lc3NhZ2UpO1xuICBhc3NpZ24odGhpcywgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3JQcm9wcyhyZXMpIHtcbiAgdmFyIGJvZHkgPSByZXMuYm9keTtcbiAgdmFyIHByb3BzID0ge1xuICAgIHJlc3BvbnNlOiByZXMsXG4gICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VCb2R5OiBzdHJpbmdpZnlCb2R5KGJvZHksIHJlcylcbiAgfTsgLy8gQVBJL0Jvb20gc3R5bGUgZXJyb3JzICh7c3RhdHVzQ29kZSwgZXJyb3IsIG1lc3NhZ2V9KVxuXG4gIGlmIChib2R5LmVycm9yICYmIGJvZHkubWVzc2FnZSkge1xuICAgIHByb3BzLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChib2R5LmVycm9yLCBcIiAtIFwiKS5jb25jYXQoYm9keS5tZXNzYWdlKTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0gLy8gUXVlcnkvZGF0YWJhc2UgZXJyb3JzICh7ZXJyb3I6IHtkZXNjcmlwdGlvbiwgb3RoZXIsIGFyYiwgcHJvcHN9fSlcblxuXG4gIGlmIChib2R5LmVycm9yICYmIGJvZHkuZXJyb3IuZGVzY3JpcHRpb24pIHtcbiAgICBwcm9wcy5tZXNzYWdlID0gYm9keS5lcnJvci5kZXNjcmlwdGlvbjtcbiAgICBwcm9wcy5kZXRhaWxzID0gYm9keS5lcnJvcjtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0gLy8gT3RoZXIsIG1vcmUgYXJiaXRyYXJ5IGVycm9yc1xuXG5cbiAgcHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IgfHwgYm9keS5tZXNzYWdlIHx8IGh0dHBFcnJvck1lc3NhZ2UocmVzKTtcbiAgcmV0dXJuIHByb3BzO1xufVxuXG5mdW5jdGlvbiBodHRwRXJyb3JNZXNzYWdlKHJlcykge1xuICB2YXIgc3RhdHVzTWVzc2FnZSA9IHJlcy5zdGF0dXNNZXNzYWdlID8gXCIgXCIuY29uY2F0KHJlcy5zdGF0dXNNZXNzYWdlKSA6ICcnO1xuICByZXR1cm4gXCJcIi5jb25jYXQocmVzLm1ldGhvZCwgXCItcmVxdWVzdCB0byBcIikuY29uY2F0KHJlcy51cmwsIFwiIHJlc3VsdGVkIGluIEhUVFAgXCIpLmNvbmNhdChyZXMuc3RhdHVzQ29kZSkuY29uY2F0KHN0YXR1c01lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlCb2R5KGJvZHksIHJlcykge1xuICB2YXIgY29udGVudFR5cGUgPSAocmVzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaXNKc29uID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpICE9PSAtMTtcbiAgcmV0dXJuIGlzSnNvbiA/IEpTT04uc3RyaW5naWZ5KGJvZHksIG51bGwsIDIpIDogYm9keTtcbn1cblxubWFrZUVycm9yKENsaWVudEVycm9yKTtcbm1ha2VFcnJvcihTZXJ2ZXJFcnJvcik7XG5leHBvcnRzLkNsaWVudEVycm9yID0gQ2xpZW50RXJyb3I7XG5leHBvcnRzLlNlcnZlckVycm9yID0gU2VydmVyRXJyb3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICB2YXIgcXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBxcy5wdXNoKFwiXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChrZXkpLCBcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXMubGVuZ3RoID4gMCA/IFwiP1wiLmNvbmNhdChxcy5qb2luKCcmJykpIDogJyc7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eS1mdW5jdGlvbiwgbm8tcHJvY2Vzcy1lbnYgKi9cbnZhciBnZXRJdCA9IHJlcXVpcmUoJ2dldC1pdCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgb2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ2dldC1pdC9saWIvbWlkZGxld2FyZS9vYnNlcnZhYmxlJyk7XG5cbnZhciBqc29uUmVxdWVzdCA9IHJlcXVpcmUoJ2dldC1pdC9saWIvbWlkZGxld2FyZS9qc29uUmVxdWVzdCcpO1xuXG52YXIganNvblJlc3BvbnNlID0gcmVxdWlyZSgnZ2V0LWl0L2xpYi9taWRkbGV3YXJlL2pzb25SZXNwb25zZScpO1xuXG52YXIgcHJvZ3Jlc3MgPSByZXF1aXJlKCdnZXQtaXQvbGliL21pZGRsZXdhcmUvcHJvZ3Jlc3MnKTtcblxudmFyIE9ic2VydmFibGUgPSByZXF1aXJlKCdAc2FuaXR5L29ic2VydmFibGUvbWluaW1hbCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2Vycm9ycycpLFxuICAgIENsaWVudEVycm9yID0gX3JlcXVpcmUuQ2xpZW50RXJyb3IsXG4gICAgU2VydmVyRXJyb3IgPSBfcmVxdWlyZS5TZXJ2ZXJFcnJvcjtcblxudmFyIGh0dHBFcnJvciA9IHtcbiAgb25SZXNwb25zZTogZnVuY3Rpb24gb25SZXNwb25zZShyZXMpIHtcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNTAwKSB7XG4gICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3IocmVzKTtcbiAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgdGhyb3cgbmV3IENsaWVudEVycm9yKHJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxufTtcbnZhciBwcmludFdhcm5pbmdzID0ge1xuICBvblJlc3BvbnNlOiBmdW5jdGlvbiBvblJlc3BvbnNlKHJlcykge1xuICAgIHZhciB3YXJuID0gcmVzLmhlYWRlcnNbJ3gtc2FuaXR5LXdhcm5pbmcnXTtcbiAgICB2YXIgd2FybmluZ3MgPSBBcnJheS5pc0FycmF5KHdhcm4pID8gd2FybiA6IFt3YXJuXTtcbiAgICB3YXJuaW5ncy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKG1zZyk7XG4gICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxufTsgLy8gRW52aXJvbm1lbnQtc3BlY2lmaWMgbWlkZGxld2FyZS5cblxudmFyIGVudlNwZWNpZmljID0gcmVxdWlyZSgnLi9ub2RlTWlkZGxld2FyZScpO1xuXG52YXIgbWlkZGxld2FyZSA9IGVudlNwZWNpZmljLmNvbmNhdChbcHJpbnRXYXJuaW5ncywganNvblJlcXVlc3QoKSwganNvblJlc3BvbnNlKCksIHByb2dyZXNzKCksIGh0dHBFcnJvciwgb2JzZXJ2YWJsZSh7XG4gIGltcGxlbWVudGF0aW9uOiBPYnNlcnZhYmxlXG59KV0pO1xudmFyIHJlcXVlc3QgPSBnZXRJdChtaWRkbGV3YXJlKTtcblxuZnVuY3Rpb24gaHR0cFJlcXVlc3Qob3B0aW9ucykge1xuICB2YXIgcmVxdWVzdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiByZXF1ZXN0O1xuICByZXR1cm4gcmVxdWVzdGVyKGFzc2lnbih7XG4gICAgbWF4UmVkaXJlY3RzOiAwXG4gIH0sIG9wdGlvbnMpKTtcbn1cblxuaHR0cFJlcXVlc3QuZGVmYXVsdFJlcXVlc3RlciA9IHJlcXVlc3Q7XG5odHRwUmVxdWVzdC5DbGllbnRFcnJvciA9IENsaWVudEVycm9yO1xuaHR0cFJlcXVlc3QuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gaHR0cFJlcXVlc3Q7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBwcm9qZWN0SGVhZGVyID0gJ1gtU2FuaXR5LVByb2plY3QtSUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIG92ZXJyaWRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBoZWFkZXJzID0ge307XG4gIHZhciB0b2tlbiA9IG92ZXJyaWRlcy50b2tlbiB8fCBjb25maWcudG9rZW47XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gXCJCZWFyZXIgXCIuY29uY2F0KHRva2VuKTtcbiAgfVxuXG4gIGlmICghb3ZlcnJpZGVzLnVzZUdsb2JhbEFwaSAmJiAhY29uZmlnLnVzZVByb2plY3RIb3N0bmFtZSAmJiBjb25maWcucHJvamVjdElkKSB7XG4gICAgaGVhZGVyc1twcm9qZWN0SGVhZGVyXSA9IGNvbmZpZy5wcm9qZWN0SWQ7XG4gIH1cblxuICB2YXIgd2l0aENyZWRlbnRpYWxzID0gQm9vbGVhbih0eXBlb2Ygb3ZlcnJpZGVzLndpdGhDcmVkZW50aWFscyA9PT0gJ3VuZGVmaW5lZCcgPyBjb25maWcudG9rZW4gfHwgY29uZmlnLndpdGhDcmVkZW50aWFscyA6IG92ZXJyaWRlcy53aXRoQ3JlZGVudGlhbHMpO1xuICB2YXIgdGltZW91dCA9IHR5cGVvZiBvdmVycmlkZXMudGltZW91dCA9PT0gJ3VuZGVmaW5lZCcgPyBjb25maWcudGltZW91dCA6IG92ZXJyaWRlcy50aW1lb3V0O1xuICByZXR1cm4gYXNzaWduKHt9LCBvdmVycmlkZXMsIHtcbiAgICBoZWFkZXJzOiBhc3NpZ24oe30sIGhlYWRlcnMsIG92ZXJyaWRlcy5oZWFkZXJzIHx8IHt9KSxcbiAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gJ3VuZGVmaW5lZCcgPyA1ICogNjAgKiAxMDAwIDogdGltZW91dCxcbiAgICBqc29uOiB0cnVlLFxuICAgIHdpdGhDcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzXG4gIH0pO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gUHJvamVjdHNDbGllbnQoY2xpZW50KSB7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG5hc3NpZ24oUHJvamVjdHNDbGllbnQucHJvdG90eXBlLCB7XG4gIGxpc3Q6IGZ1bmN0aW9uIGxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgdXJpOiAnL3Byb2plY3RzJ1xuICAgIH0pO1xuICB9LFxuICBnZXRCeUlkOiBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgdXJpOiBcIi9wcm9qZWN0cy9cIi5jb25jYXQoaWQpXG4gICAgfSk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0c0NsaWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnQHNhbml0eS9vYnNlcnZhYmxlL29wZXJhdG9ycy9maWx0ZXInKSxcbiAgICBmaWx0ZXIgPSBfcmVxdWlyZS5maWx0ZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCdAc2FuaXR5L29ic2VydmFibGUvb3BlcmF0b3JzL21hcCcpLFxuICAgIG1hcCA9IF9yZXF1aXJlMi5tYXA7XG5cbnZhciBQYXRjaCA9IHJlcXVpcmUoJy4vZGF0YS9wYXRjaCcpO1xuXG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL2RhdGEvdHJhbnNhY3Rpb24nKTtcblxudmFyIGRhdGFNZXRob2RzID0gcmVxdWlyZSgnLi9kYXRhL2RhdGFNZXRob2RzJyk7XG5cbnZhciBEYXRhc2V0c0NsaWVudCA9IHJlcXVpcmUoJy4vZGF0YXNldHMvZGF0YXNldHNDbGllbnQnKTtcblxudmFyIFByb2plY3RzQ2xpZW50ID0gcmVxdWlyZSgnLi9wcm9qZWN0cy9wcm9qZWN0c0NsaWVudCcpO1xuXG52YXIgQXNzZXRzQ2xpZW50ID0gcmVxdWlyZSgnLi9hc3NldHMvYXNzZXRzQ2xpZW50Jyk7XG5cbnZhciBVc2Vyc0NsaWVudCA9IHJlcXVpcmUoJy4vdXNlcnMvdXNlcnNDbGllbnQnKTtcblxudmFyIEF1dGhDbGllbnQgPSByZXF1aXJlKCcuL2F1dGgvYXV0aENsaWVudCcpO1xuXG52YXIgaHR0cFJlcXVlc3QgPSByZXF1aXJlKCcuL2h0dHAvcmVxdWVzdCcpO1xuXG52YXIgZ2V0UmVxdWVzdE9wdGlvbnMgPSByZXF1aXJlKCcuL2h0dHAvcmVxdWVzdE9wdGlvbnMnKTtcblxudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoJy4vY29uZmlnJyksXG4gICAgZGVmYXVsdENvbmZpZyA9IF9yZXF1aXJlMy5kZWZhdWx0Q29uZmlnLFxuICAgIGluaXRDb25maWcgPSBfcmVxdWlyZTMuaW5pdENvbmZpZztcblxudmFyIHRvUHJvbWlzZSA9IGZ1bmN0aW9uIHRvUHJvbWlzZShvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLnRvUHJvbWlzZSgpO1xufTtcblxuZnVuY3Rpb24gU2FuaXR5Q2xpZW50KCkge1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkZWZhdWx0Q29uZmlnO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTYW5pdHlDbGllbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBTYW5pdHlDbGllbnQoY29uZmlnKTtcbiAgfVxuXG4gIHRoaXMuY29uZmlnKGNvbmZpZyk7XG4gIHRoaXMuYXNzZXRzID0gbmV3IEFzc2V0c0NsaWVudCh0aGlzKTtcbiAgdGhpcy5kYXRhc2V0cyA9IG5ldyBEYXRhc2V0c0NsaWVudCh0aGlzKTtcbiAgdGhpcy5wcm9qZWN0cyA9IG5ldyBQcm9qZWN0c0NsaWVudCh0aGlzKTtcbiAgdGhpcy51c2VycyA9IG5ldyBVc2Vyc0NsaWVudCh0aGlzKTtcbiAgdGhpcy5hdXRoID0gbmV3IEF1dGhDbGllbnQodGhpcyk7XG5cbiAgaWYgKHRoaXMuY2xpZW50Q29uZmlnLmlzUHJvbWlzZUFQSSkge1xuICAgIHZhciBvYnNlcnZhYmxlQ29uZmlnID0gYXNzaWduKHt9LCB0aGlzLmNsaWVudENvbmZpZywge1xuICAgICAgaXNQcm9taXNlQVBJOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMub2JzZXJ2YWJsZSA9IG5ldyBTYW5pdHlDbGllbnQob2JzZXJ2YWJsZUNvbmZpZyk7XG4gIH1cbn1cblxuYXNzaWduKFNhbml0eUNsaWVudC5wcm90b3R5cGUsIGRhdGFNZXRob2RzKTtcbmFzc2lnbihTYW5pdHlDbGllbnQucHJvdG90eXBlLCB7XG4gIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFNhbml0eUNsaWVudCh0aGlzLmNvbmZpZygpKTtcbiAgfSxcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcobmV3Q29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDb25maWcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLmNsaWVudENvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub2JzZXJ2YWJsZSkge1xuICAgICAgdmFyIG9ic2VydmFibGVDb25maWcgPSBhc3NpZ24oe30sIG5ld0NvbmZpZywge1xuICAgICAgICBpc1Byb21pc2VBUEk6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZS5jb25maWcob2JzZXJ2YWJsZUNvbmZpZyk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnRDb25maWcgPSBpbml0Q29uZmlnKG5ld0NvbmZpZywgdGhpcy5jbGllbnRDb25maWcgfHwge30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB3aXRoQ29uZmlnOiBmdW5jdGlvbiB3aXRoQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuY29uZmlnKG5ld0NvbmZpZyk7XG4gIH0sXG4gIGdldFVybDogZnVuY3Rpb24gZ2V0VXJsKHVyaSkge1xuICAgIHZhciBjYW5Vc2VDZG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBiYXNlID0gY2FuVXNlQ2RuID8gdGhpcy5jbGllbnRDb25maWcuY2RuVXJsIDogdGhpcy5jbGllbnRDb25maWcudXJsO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChiYXNlLCBcIi9cIikuY29uY2F0KHVyaS5yZXBsYWNlKC9eXFwvLywgJycpKTtcbiAgfSxcbiAgaXNQcm9taXNlQVBJOiBmdW5jdGlvbiBpc1Byb21pc2VBUEkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Q29uZmlnLmlzUHJvbWlzZUFQSTtcbiAgfSxcbiAgX3JlcXVlc3RPYnNlcnZhYmxlOiBmdW5jdGlvbiBfcmVxdWVzdE9ic2VydmFibGUob3B0aW9ucykge1xuICAgIHZhciB1cmkgPSBvcHRpb25zLnVybCB8fCBvcHRpb25zLnVyaTtcbiAgICB2YXIgY2FuVXNlQ2RuID0gdGhpcy5jbGllbnRDb25maWcudXNlQ2RuICYmIFsnR0VUJywgJ0hFQUQnXS5pbmRleE9mKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnKSA+PSAwICYmIHVyaS5pbmRleE9mKCcvZGF0YS8nKSA9PT0gMDtcbiAgICB2YXIgcmVxT3B0aW9ucyA9IGdldFJlcXVlc3RPcHRpb25zKHRoaXMuY2xpZW50Q29uZmlnLCBhc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHVybDogdGhpcy5nZXRVcmwodXJpLCBjYW5Vc2VDZG4pXG4gICAgfSkpO1xuICAgIHJldHVybiBodHRwUmVxdWVzdChyZXFPcHRpb25zLCB0aGlzLmNsaWVudENvbmZpZy5yZXF1ZXN0ZXIpO1xuICB9LFxuICByZXF1ZXN0OiBmdW5jdGlvbiByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMuX3JlcXVlc3RPYnNlcnZhYmxlKG9wdGlvbnMpLnBpcGUoZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdyZXNwb25zZSc7XG4gICAgfSksIG1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5ib2R5O1xuICAgIH0pKTtcblxuICAgIHJldHVybiB0aGlzLmlzUHJvbWlzZUFQSSgpID8gdG9Qcm9taXNlKG9ic2VydmFibGUpIDogb2JzZXJ2YWJsZTtcbiAgfVxufSk7XG5TYW5pdHlDbGllbnQuUGF0Y2ggPSBQYXRjaDtcblNhbml0eUNsaWVudC5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuU2FuaXR5Q2xpZW50LkNsaWVudEVycm9yID0gaHR0cFJlcXVlc3QuQ2xpZW50RXJyb3I7XG5TYW5pdHlDbGllbnQuU2VydmVyRXJyb3IgPSBodHRwUmVxdWVzdC5TZXJ2ZXJFcnJvcjtcblNhbml0eUNsaWVudC5yZXF1ZXN0ZXIgPSBodHRwUmVxdWVzdC5kZWZhdWx0UmVxdWVzdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBTYW5pdHlDbGllbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbmZ1bmN0aW9uIFVzZXJzQ2xpZW50KGNsaWVudCkge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuYXNzaWduKFVzZXJzQ2xpZW50LnByb3RvdHlwZSwge1xuICBnZXRCeUlkOiBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgdXJpOiBcIi91c2Vycy9cIi5jb25jYXQoaWQpXG4gICAgfSk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBVc2Vyc0NsaWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBkZWZhdWx0cykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGVmYXVsdHMpLmNvbmNhdChPYmplY3Qua2V5cyhvYmopKS5yZWR1Y2UoZnVuY3Rpb24gKHRhcmdldCwgcHJvcCkge1xuICAgIHRhcmdldFtwcm9wXSA9IHR5cGVvZiBvYmpbcHJvcF0gPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHNbcHJvcF0gOiBvYmpbcHJvcF07XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSwge30pO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oc2VsKSB7XG4gIGlmICh0eXBlb2Ygc2VsID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHNlbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHNlbFxuICAgIH07XG4gIH1cblxuICBpZiAoc2VsICYmIHNlbC5xdWVyeSkge1xuICAgIHJldHVybiB7XG4gICAgICBxdWVyeTogc2VsLnF1ZXJ5XG4gICAgfTtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb25PcHRzID0gWycqIERvY3VtZW50IElEICg8ZG9jSWQ+KScsICcqIEFycmF5IG9mIGRvY3VtZW50IElEcycsICcqIE9iamVjdCBjb250YWluaW5nIGBxdWVyeWAnXS5qb2luKCdcXG4nKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzZWxlY3Rpb24gLSBtdXN0IGJlIG9uZSBvZjpcXG5cXG5cIi5jb25jYXQoc2VsZWN0aW9uT3B0cykpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGRpZENhbGwgPSBmYWxzZTtcbiAgdmFyIHJldHVyblZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkaWRDYWxsKSB7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuVmFsdWUgPSBmbi5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBwcm9wcykge1xuICByZXR1cm4gcHJvcHMucmVkdWNlKGZ1bmN0aW9uIChzZWxlY3Rpb24sIHByb3ApIHtcbiAgICBpZiAodHlwZW9mIG9ialtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH0sIHt9KTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIFZBTElEX0FTU0VUX1RZUEVTID0gWydpbWFnZScsICdmaWxlJ107XG52YXIgVkFMSURfSU5TRVJUX0xPQ0FUSU9OUyA9IFsnYmVmb3JlJywgJ2FmdGVyJywgJ3JlcGxhY2UnXTtcblxuZXhwb3J0cy5kYXRhc2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCEvXih+W2EtejAtOV17MX1bLVxcd117MCwyNX18W2EtejAtOV17MX1bLVxcd117MCwxOX0pJC8udGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YXNldHMgY2FuIG9ubHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycywgbnVtYmVycywgdW5kZXJzY29yZXMgYW5kIGRhc2hlcywgYW5kIHN0YXJ0IHdpdGggdGlsZGUsIGFuZCBiZSBtYXhpbXVtIDIwIGNoYXJhY3RlcnMnKTtcbiAgfVxufTtcblxuZXhwb3J0cy5wcm9qZWN0SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKCEvXlstYS16MC05XSskL2kudGVzdChpZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9qZWN0SWRgIGNhbiBvbmx5IGNvbnRhaW4gb25seSBhLXosIDAtOSBhbmQgZGFzaGVzJyk7XG4gIH1cbn07XG5cbmV4cG9ydHMudmFsaWRhdGVBc3NldFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAoVkFMSURfQVNTRVRfVFlQRVMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFzc2V0IHR5cGU6IFwiLmNvbmNhdCh0eXBlLCBcIi4gTXVzdCBiZSBvbmUgb2YgXCIpLmNvbmNhdChWQUxJRF9BU1NFVF9UWVBFUy5qb2luKCcsICcpKSk7XG4gIH1cbn07XG5cbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSBmdW5jdGlvbiAob3AsIHZhbCkge1xuICBpZiAodmFsID09PSBudWxsIHx8IF90eXBlb2YodmFsKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KG9wLCBcIigpIHRha2VzIGFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXCIpKTtcbiAgfVxufTtcblxuZXhwb3J0cy5yZXF1aXJlRG9jdW1lbnRJZCA9IGZ1bmN0aW9uIChvcCwgZG9jKSB7XG4gIGlmICghZG9jLl9pZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChvcCwgXCIoKSByZXF1aXJlcyB0aGF0IHRoZSBkb2N1bWVudCBjb250YWlucyBhbiBJRCAoXFxcIl9pZFxcXCIgcHJvcGVydHkpXCIpKTtcbiAgfVxuXG4gIGV4cG9ydHMudmFsaWRhdGVEb2N1bWVudElkKG9wLCBkb2MuX2lkKTtcbn07XG5cbmV4cG9ydHMudmFsaWRhdGVEb2N1bWVudElkID0gZnVuY3Rpb24gKG9wLCBpZCkge1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJyB8fCAhL15bYS16MC05Xy4tXSskL2kudGVzdChpZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQob3AsIFwiKCk6IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCIgaXMgbm90IGEgdmFsaWQgZG9jdW1lbnQgSURcIikpO1xuICB9XG59O1xuXG5leHBvcnRzLnZhbGlkYXRlSW5zZXJ0ID0gZnVuY3Rpb24gKGF0LCBzZWxlY3RvciwgaXRlbXMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9ICdpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcyknO1xuXG4gIGlmIChWQUxJRF9JTlNFUlRfTE9DQVRJT05TLmluZGV4T2YoYXQpID09PSAtMSkge1xuICAgIHZhciB2YWxpZCA9IFZBTElEX0lOU0VSVF9MT0NBVElPTlMubWFwKGZ1bmN0aW9uIChsb2MpIHtcbiAgICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQobG9jLCBcIlxcXCJcIik7XG4gICAgfSkuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoc2lnbmF0dXJlLCBcIiB0YWtlcyBhbiBcXFwiYXRcXFwiLWFyZ3VtZW50IHdoaWNoIGlzIG9uZSBvZjogXCIpLmNvbmNhdCh2YWxpZCkpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoc2lnbmF0dXJlLCBcIiB0YWtlcyBhIFxcXCJzZWxlY3RvclxcXCItYXJndW1lbnQgd2hpY2ggbXVzdCBiZSBhIHN0cmluZ1wiKSk7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHNpZ25hdHVyZSwgXCIgdGFrZXMgYW4gXFxcIml0ZW1zXFxcIi1hcmd1bWVudCB3aGljaCBtdXN0IGJlIGFuIGFycmF5XCIpKTtcbiAgfVxufTtcblxuZXhwb3J0cy5oYXNEYXRhc2V0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZy5ncmFkaWVudE1vZGUgJiYgIWNvbmZpZy5kYXRhc2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZGF0YXNldGAgbXVzdCBiZSBwcm92aWRlZCB0byBwZXJmb3JtIHF1ZXJpZXMnKTtcbiAgfVxuXG4gIHJldHVybiBjb25maWcuZGF0YXNldCB8fCAnJztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnZW5lcmF0ZUhlbHBVcmwgPSByZXF1aXJlKCdAc2FuaXR5L2dlbmVyYXRlLWhlbHAtdXJsJyk7XG5cbnZhciBvbmNlID0gcmVxdWlyZSgnLi91dGlsL29uY2UnKTtcblxudmFyIGNyZWF0ZVdhcm5pbmdQcmludGVyID0gZnVuY3Rpb24gY3JlYXRlV2FybmluZ1ByaW50ZXIobWVzc2FnZSkge1xuICByZXR1cm4gKC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF9jb25zb2xlID0gY29uc29sZSkud2Fybi5hcHBseShfY29uc29sZSwgW21lc3NhZ2Uuam9pbignICcpXS5jb25jYXQoYXJncykpO1xuICAgIH0pXG4gICk7XG59O1xuXG5leHBvcnRzLnByaW50Q2RuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFsnWW91IGFyZSBub3QgdXNpbmcgdGhlIFNhbml0eSBDRE4uIFRoYXQgbWVhbnMgeW91ciBkYXRhIGlzIGFsd2F5cyBmcmVzaCwgYnV0IHRoZSBDRE4gaXMgZmFzdGVyIGFuZCcsIFwiY2hlYXBlci4gVGhpbmsgYWJvdXQgaXQhIEZvciBtb3JlIGluZm8sIHNlZSBcIi5jb25jYXQoZ2VuZXJhdGVIZWxwVXJsKCdqcy1jbGllbnQtY2RuLWNvbmZpZ3VyYXRpb24nKSwgXCIuXCIpLCAnVG8gaGlkZSB0aGlzIHdhcm5pbmcsIHBsZWFzZSBzZXQgdGhlIGB1c2VDZG5gIG9wdGlvbiB0byBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgd2hlbiBjcmVhdGluZycsICd0aGUgY2xpZW50LiddKTtcbmV4cG9ydHMucHJpbnRCcm93c2VyVG9rZW5XYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoWydZb3UgaGF2ZSBjb25maWd1cmVkIFNhbml0eSBjbGllbnQgdG8gdXNlIGEgdG9rZW4gaW4gdGhlIGJyb3dzZXIuIFRoaXMgbWF5IGNhdXNlIHVuaW50ZW50aW9uYWwgc2VjdXJpdHkgaXNzdWVzLicsIFwiU2VlIFwiLmNvbmNhdChnZW5lcmF0ZUhlbHBVcmwoJ2pzLWNsaWVudC1icm93c2VyLXRva2VuJyksIFwiIGZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBob3cgdG8gaGlkZSB0aGlzIHdhcm5pbmcuXCIpXSk7XG5leHBvcnRzLnByaW50Q2RuVG9rZW5XYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoWydZb3UgaGF2ZSBzZXQgYHVzZUNkbmAgdG8gYHRydWVgIHdoaWxlIGFsc28gc3BlY2lmeWluZyBhIHRva2VuLiBUaGlzIGlzIHVzdWFsbHkgbm90IHdoYXQgeW91JywgJ3dhbnQuIFRoZSBDRE4gY2Fubm90IGJlIHVzZWQgd2l0aCBhbiBhdXRob3JpemF0aW9uIHRva2VuLCBzaW5jZSBwcml2YXRlIGRhdGEgY2Fubm90IGJlIGNhY2hlZC4nLCBcIlNlZSBcIi5jb25jYXQoZ2VuZXJhdGVIZWxwVXJsKCdqcy1jbGllbnQtdXNlY2RuLXRva2VuJyksIFwiIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKV0pO1xuZXhwb3J0cy5wcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbJ1VzaW5nIHRoZSBTYW5pdHkgY2xpZW50IHdpdGhvdXQgc3BlY2lmeWluZyBhbiBBUEkgdmVyc2lvbiBpcyBkZXByZWNhdGVkLicsIFwiU2VlIFwiLmNvbmNhdChnZW5lcmF0ZUhlbHBVcmwoJ2pzLWNsaWVudC1hcGktdmVyc2lvbicpKV0pOyIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xudmFyIGV2cyA9IHJlcXVpcmUoJ0ByZXh4YXJzL2V2ZW50c291cmNlLXBvbHlmaWxsJylcblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuRXZlbnRTb3VyY2UgfHwgZXZzLkV2ZW50U291cmNlXG4iLCJ2YXIgYmFzZVVybCA9ICdodHRwczovL2RvY3Muc2FuaXR5LmlvL2hlbHAvJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlSGVscFVybChzbHVnKSB7XG4gIHJldHVybiBiYXNlVXJsICsgc2x1Z1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ3J4anMvaW50ZXJuYWwvT2JzZXJ2YWJsZScpLFxuICAgIE9ic2VydmFibGUgPSBfcmVxdWlyZS5PYnNlcnZhYmxlO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzL21hcCcpLFxuICAgIG1hcCA9IF9yZXF1aXJlMi5tYXA7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMvZmlsdGVyJyksXG4gICAgZmlsdGVyID0gX3JlcXVpcmUzLmZpbHRlcjtcblxudmFyIF9yZXF1aXJlNCA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycy9yZWR1Y2UnKSxcbiAgICByZWR1Y2UgPSBfcmVxdWlyZTQucmVkdWNlO1xuLypcbiBBIG1pbmltYWwgcnhqcyBiYXNlZCBvYnNlcnZhYmxlIHRoYXQgYWxpZ24gYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGVzLW9ic2VydmFibGUgc3BlYyxcbiB3aXRob3V0IHRoZSBzdGF0aWMgZmFjdG9yeSBtZXRob2RzXG4gKi9cblxuXG5mdW5jdGlvbiBTYW5pdHlPYnNlcnZhYmxlTWluaW1hbCgpIHtcbiAgT2JzZXJ2YWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xufVxuXG5TYW5pdHlPYnNlcnZhYmxlTWluaW1hbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBPYnNlcnZhYmxlLnByb3RvdHlwZSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNhbml0eU9ic2VydmFibGVNaW5pbWFsLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywge1xuICB2YWx1ZTogU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWwsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWwucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiBsaWZ0KG9wZXJhdG9yKSB7XG4gIHZhciBvYnNlcnZhYmxlID0gbmV3IFNhbml0eU9ic2VydmFibGVNaW5pbWFsKCk7XG4gIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICByZXR1cm4gb2JzZXJ2YWJsZTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURlcHJlY2F0ZWRNZW1iZXJPcChuYW1lLCBvcCkge1xuICB2YXIgaGFzV2FybmVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiBkZXByZWNhdGVkT3BlcmF0b3IoKSB7XG4gICAgaWYgKCFoYXNXYXJuZWQpIHtcbiAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKFwiQ2FsbGluZyBvYnNlcnZhYmxlLlwiLmNvbmNhdChuYW1lLCBcIiguLi4pIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2Ugb2JzZXJ2YWJsZS5waXBlKFwiKS5jb25jYXQobmFtZSwgXCIoLi4uKSkgaW5zdGVhZFwiKSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBpcGUob3AuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cblNhbml0eU9ic2VydmFibGVNaW5pbWFsLnByb3RvdHlwZS5tYXAgPSBjcmVhdGVEZXByZWNhdGVkTWVtYmVyT3AoJ21hcCcsIG1hcCk7XG5TYW5pdHlPYnNlcnZhYmxlTWluaW1hbC5wcm90b3R5cGUuZmlsdGVyID0gY3JlYXRlRGVwcmVjYXRlZE1lbWJlck9wKCdmaWx0ZXInLCBmaWx0ZXIpO1xuU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWwucHJvdG90eXBlLnJlZHVjZSA9IGNyZWF0ZURlcHJlY2F0ZWRNZW1iZXJPcCgnZmlsdGVyJywgcmVkdWNlKTtcbm1vZHVsZS5leHBvcnRzID0gU2FuaXR5T2JzZXJ2YWJsZU1pbmltYWw7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9TYW5pdHlPYnNlcnZhYmxlTWluaW1hbCcpXG4iLCJleHBvcnRzLmZpbHRlciA9IHJlcXVpcmUoJ3J4anMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlcicpLmZpbHRlclxuIiwiZXhwb3J0cy5tYXAgPSByZXF1aXJlKCdyeGpzL2ludGVybmFsL29wZXJhdG9ycy9tYXAnKS5tYXBcbiIsImV4cG9ydHMucmVkdWNlID0gcmVxdWlyZSgncnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVkdWNlJykucmVkdWNlXG4iLCJcbi8qKlxuICogQXJyYXkjZmlsdGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2VsZlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAdGhyb3cgVHlwZUVycm9yXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBmbiwgc2VsZikge1xuICBpZiAoYXJyLmZpbHRlcikgcmV0dXJuIGFyci5maWx0ZXIoZm4sIHNlbGYpO1xuICBpZiAodm9pZCAwID09PSBhcnIgfHwgbnVsbCA9PT0gYXJyKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKGFyciwgaSkpIGNvbnRpbnVlO1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGZuLmNhbGwoc2VsZiwgdmFsLCBpLCBhcnIpKSByZXQucHVzaCh2YWwpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lcnJvcnMnKSxcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUztcblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yJyk7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsLycpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogcmVxdWlyZSgnZXM2LW9iamVjdC1hc3NpZ24nKS5hc3NpZ247XG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSByZXF1aXJlKCcuL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMnKTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdO1xuXG52YXIgZXNjYXBlRm4gPSBmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xufTtcblxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuXG4gIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XG4gIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGlmICh3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nID8gcHJvY2Vzcy5lbWl0V2FybmluZyA6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgd2FybignYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwOTQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuXG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcblxuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblxuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufSAvLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuXG5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5vayA9IG9rOyAvLyBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGggPT0uXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuXG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cblxuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxuXG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBleHBlY3RlZFtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gIHJldHVybiBpc1Byb21pc2Uob2JqKSB8fCBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7IC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHBlY3RzRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgIHZhciBkZXRhaWxzID0gJyc7XG5cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlcnJvciAmJiAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWVycm9yIHx8IGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0JyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBhY3R1YWw7XG59XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcblxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxuICAgIH0pOyAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXG4gICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdG1wMi5zaGlmdCgpOyAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pO1xuXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3RXJyO1xuICB9XG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG5cbmZ1bmN0aW9uIHN0cmljdCgpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4ndXNlIHN0cmljdCc7IC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcblxuICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgIGluc3BlY3RlZCA9IFwiXCIuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCBcIi4uLlwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGlucHV0LCBcIiB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCJcIikgKyBcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlLCBcIi5cIik7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYW5kIFwiKS5jb25jYXQoYXJnc1sxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xuXG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZSgnaXMtbmFuJyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gICAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1NykgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cblxuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoaXNOb25JbmRleCkuY29uY2F0KG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkuZmlsdGVyKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSkpKTtcbn0gLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIE9OTFlfRU5VTUVSQUJMRSA9IHVuZGVmaW5lZDtcbnZhciBrU3RyaWN0ID0gdHJ1ZTtcbnZhciBrTG9vc2UgPSBmYWxzZTtcbnZhciBrTm9JdGVyYXRvciA9IDA7XG52YXIga0lzQXJyYXkgPSAxO1xudmFyIGtJc1NldCA9IDI7XG52YXIga0lzTWFwID0gMzsgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcbi8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbi8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG4vLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4vLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXG4vL1xuLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXG4vLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4vLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxuLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbi8vXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcbi8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cblxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcblxuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXG4gICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XG4gIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgLy8gd2FuJ3QgdG8gZWFybHkgcmV0dXJuIG91dCBvZiB0aGUgcmVzdCBvZiB0aGUgY2hlY2tzLiBIb3dldmVyIHdlIGNhbiBjaGVja1xuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEYXRlKHZhbDEpKSB7XG4gICAgaWYgKCFpc0RhdGUodmFsMikgfHwgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDEpICE9PSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgIC8vIGlzIG90aGVyd2lzZSBpZGVudGljYWwuXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XG4gICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cblxuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoX2tleXMubGVuZ3RoICE9PSBfa2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcCk7XG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgIGlmICghYXJlRXF1YWxBcnJheUJ1ZmZlcnModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWwxKSAmJiAhaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcbiAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcblxuICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBVc2UgbWVtb3MgdG8gaGFuZGxlIGN5Y2xlcy5cblxuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG5cbiAgICBpZiAodmFsMk1lbW9BICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcblxuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG5cbiAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pO1xuICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbik7XG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcbiAgbWVtb3MudmFsMS5kZWxldGUodmFsMSk7XG4gIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpO1xuICByZXR1cm4gYXJlRXE7XG59XG5cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG5cbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XG4gIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwcmltID0gK3ByaW07XG4gICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG5cbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYWx0VmFsdWU7XG4gIH1cblxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcblxuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXG4gICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuXG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAhYS5oYXMoX3ZhbCkgJiYgIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRvIGJlIGFibGUgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAga2V5ID0gX2FFbnRyaWVzJGlbMF0sXG4gICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG5cbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlIHdlIHByZXZlbnQgYW5vdGhlciBiLmhhcyhrZXkpIGNoZWNrIGluXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KTtcblxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KGtleSksIGl0ZW0sIGZhbHNlLCBtZW1vKSkgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG5cbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzQVtpXTtcblxuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gIGlzRGVlcFN0cmljdEVxdWFsOiBpc0RlZXBTdHJpY3RFcXVhbFxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmaWx0ZXIgPSByZXF1aXJlKCdhcnJheS1maWx0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0cmV0dXJuIGZpbHRlcihbXG5cdFx0J0JpZ0ludDY0QXJyYXknLFxuXHRcdCdCaWdVaW50NjRBcnJheScsXG5cdFx0J0Zsb2F0MzJBcnJheScsXG5cdFx0J0Zsb2F0NjRBcnJheScsXG5cdFx0J0ludDE2QXJyYXknLFxuXHRcdCdJbnQzMkFycmF5Jyxcblx0XHQnSW50OEFycmF5Jyxcblx0XHQnVWludDE2QXJyYXknLFxuXHRcdCdVaW50MzJBcnJheScsXG5cdFx0J1VpbnQ4QXJyYXknLFxuXHRcdCdVaW50OENsYW1wZWRBcnJheSdcblx0XSwgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGdsb2JhbFt0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJztcblx0fSk7XG59O1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiYXhpb3NcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiYXhpb3NcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYXhpb3NDYWNoZUFkYXB0ZXJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiYXhpb3NDYWNoZUFkYXB0ZXJcIl0gPSBmYWN0b3J5KHJvb3RbdW5kZWZpbmVkXSk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfYXhpb3NfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jYWNoZS1jb250cm9sLWVzbS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jYWNoZS1jb250cm9sLWVzbS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBDYWNoZUNvbnRyb2wsIHBhcnNlLCBmb3JtYXQsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ2FjaGVDb250cm9sXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2FjaGVDb250cm9sOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmb3JtYXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmb3JtYXQ7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfZnJvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfZnJvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfZnJvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX3dlYl9kb21faXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19zeW1ib2xfYXN5bmNfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19zeW1ib2xfYXN5bmNfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM3X3N5bWJvbF9hc3luY19pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfcmVnZXhwX3NwbGl0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfcmVnZXhwX3NwbGl0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9yZWdleHBfc3BsaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9udW1iZXJfaXNfZmluaXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9udW1iZXJfaXNfZmluaXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9udW1iZXJfaXNfZmluaXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18pO1xuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgSEVBREVSX1JFR0VYUCA9IC8oW2EtekEtWl1bYS16QS1aXy1dKilcXHMqKD86PSg/OlwiKFteXCJdKilcInwoW14gXFx0XCIsO10qKSkpPy9nO1xudmFyIFNUUklOR1MgPSB7XG4gIG1heEFnZTogJ21heC1hZ2UnLFxuICBzaGFyZWRNYXhBZ2U6ICdzLW1heGFnZScsXG4gIG1heFN0YWxlOiAnbWF4LXN0YWxlJyxcbiAgbWluRnJlc2g6ICdtaW4tZnJlc2gnLFxuICBpbW11dGFibGU6ICdpbW11dGFibGUnLFxuICBtdXN0UmV2YWxpZGF0ZTogJ211c3QtcmV2YWxpZGF0ZScsXG4gIG5vQ2FjaGU6ICduby1jYWNoZScsXG4gIG5vU3RvcmU6ICduby1zdG9yZScsXG4gIG5vVHJhbnNmb3JtOiAnbm8tdHJhbnNmb3JtJyxcbiAgb25seUlmQ2FjaGVkOiAnb25seS1pZi1jYWNoZWQnLFxuICBcInByaXZhdGVcIjogJ3ByaXZhdGUnLFxuICBwcm94eVJldmFsaWRhdGU6ICdwcm94eS1yZXZhbGlkYXRlJyxcbiAgXCJwdWJsaWNcIjogJ3B1YmxpYydcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQm9vbGVhbk9ubHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUR1cmF0aW9uKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBkdXJhdGlvbiA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pIHx8IGR1cmF0aW9uIDwgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGR1cmF0aW9uO1xufVxuXG52YXIgQ2FjaGVDb250cm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FjaGVDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZUNvbnRyb2wpO1xuXG4gICAgdGhpcy5tYXhBZ2UgPSBudWxsO1xuICAgIHRoaXMuc2hhcmVkTWF4QWdlID0gbnVsbDtcbiAgICB0aGlzLm1heFN0YWxlID0gbnVsbDtcbiAgICB0aGlzLm1heFN0YWxlRHVyYXRpb24gPSBudWxsO1xuICAgIHRoaXMubWluRnJlc2ggPSBudWxsO1xuICAgIHRoaXMuaW1tdXRhYmxlID0gbnVsbDtcbiAgICB0aGlzLm11c3RSZXZhbGlkYXRlID0gbnVsbDtcbiAgICB0aGlzLm5vQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMubm9TdG9yZSA9IG51bGw7XG4gICAgdGhpcy5ub1RyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5vbmx5SWZDYWNoZWQgPSBudWxsO1xuICAgIHRoaXNbXCJwcml2YXRlXCJdID0gbnVsbDtcbiAgICB0aGlzLnByb3h5UmV2YWxpZGF0ZSA9IG51bGw7XG4gICAgdGhpc1tcInB1YmxpY1wiXSA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FjaGVDb250cm9sLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgICAgIGlmICghaGVhZGVyIHx8IGhlYWRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICAgIHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKEhFQURFUl9SRUdFWFApIHx8IFtdO1xuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChtYXRjaGVzLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IG1hdGNoLnNwbGl0KCc9JywgMik7XG5cbiAgICAgICAgdmFyIF90b2tlbnMgPSBfc2xpY2VkVG9BcnJheSh0b2tlbnMsIDEpLFxuICAgICAgICAgICAga2V5ID0gX3Rva2Vuc1swXTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhbHVlID0gdG9rZW5zWzFdLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXhBZ2UgPSBwYXJzZUR1cmF0aW9uKHZhbHVlc1tTVFJJTkdTLm1heEFnZV0pO1xuICAgICAgdGhpcy5zaGFyZWRNYXhBZ2UgPSBwYXJzZUR1cmF0aW9uKHZhbHVlc1tTVFJJTkdTLnNoYXJlZE1heEFnZV0pO1xuICAgICAgdGhpcy5tYXhTdGFsZSA9IHBhcnNlQm9vbGVhbk9ubHkodmFsdWVzW1NUUklOR1MubWF4U3RhbGVdKTtcbiAgICAgIHRoaXMubWF4U3RhbGVEdXJhdGlvbiA9IHBhcnNlRHVyYXRpb24odmFsdWVzW1NUUklOR1MubWF4U3RhbGVdKTtcblxuICAgICAgaWYgKHRoaXMubWF4U3RhbGVEdXJhdGlvbikge1xuICAgICAgICB0aGlzLm1heFN0YWxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5taW5GcmVzaCA9IHBhcnNlRHVyYXRpb24odmFsdWVzW1NUUklOR1MubWluRnJlc2hdKTtcbiAgICAgIHRoaXMuaW1tdXRhYmxlID0gcGFyc2VCb29sZWFuT25seSh2YWx1ZXNbU1RSSU5HUy5pbW11dGFibGVdKTtcbiAgICAgIHRoaXMubXVzdFJldmFsaWRhdGUgPSBwYXJzZUJvb2xlYW5Pbmx5KHZhbHVlc1tTVFJJTkdTLm11c3RSZXZhbGlkYXRlXSk7XG4gICAgICB0aGlzLm5vQ2FjaGUgPSBwYXJzZUJvb2xlYW5Pbmx5KHZhbHVlc1tTVFJJTkdTLm5vQ2FjaGVdKTtcbiAgICAgIHRoaXMubm9TdG9yZSA9IHBhcnNlQm9vbGVhbk9ubHkodmFsdWVzW1NUUklOR1Mubm9TdG9yZV0pO1xuICAgICAgdGhpcy5ub1RyYW5zZm9ybSA9IHBhcnNlQm9vbGVhbk9ubHkodmFsdWVzW1NUUklOR1Mubm9UcmFuc2Zvcm1dKTtcbiAgICAgIHRoaXMub25seUlmQ2FjaGVkID0gcGFyc2VCb29sZWFuT25seSh2YWx1ZXNbU1RSSU5HUy5vbmx5SWZDYWNoZWRdKTtcbiAgICAgIHRoaXNbXCJwcml2YXRlXCJdID0gcGFyc2VCb29sZWFuT25seSh2YWx1ZXNbU1RSSU5HU1tcInByaXZhdGVcIl1dKTtcbiAgICAgIHRoaXMucHJveHlSZXZhbGlkYXRlID0gcGFyc2VCb29sZWFuT25seSh2YWx1ZXNbU1RSSU5HUy5wcm94eVJldmFsaWRhdGVdKTtcbiAgICAgIHRoaXNbXCJwdWJsaWNcIl0gPSBwYXJzZUJvb2xlYW5Pbmx5KHZhbHVlc1tTVFJJTkdTW1wicHVibGljXCJdXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMubWF4QWdlKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFwiXCIuY29uY2F0KFNUUklOR1MubWF4QWdlLCBcIj1cIikuY29uY2F0KHRoaXMubWF4QWdlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYXJlZE1heEFnZSkge1xuICAgICAgICB0b2tlbnMucHVzaChcIlwiLmNvbmNhdChTVFJJTkdTLnNoYXJlZE1heEFnZSwgXCI9XCIpLmNvbmNhdCh0aGlzLnNoYXJlZE1heEFnZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXhTdGFsZSkge1xuICAgICAgICBpZiAodGhpcy5tYXhTdGFsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goXCJcIi5jb25jYXQoU1RSSU5HUy5tYXhTdGFsZSwgXCI9XCIpLmNvbmNhdCh0aGlzLm1heFN0YWxlRHVyYXRpb24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChTVFJJTkdTLm1heFN0YWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5taW5GcmVzaCkge1xuICAgICAgICB0b2tlbnMucHVzaChcIlwiLmNvbmNhdChTVFJJTkdTLm1pbkZyZXNoLCBcIj1cIikuY29uY2F0KHRoaXMubWluRnJlc2gpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFNUUklOR1MuaW1tdXRhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubXVzdFJldmFsaWRhdGUpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goU1RSSU5HUy5tdXN0UmV2YWxpZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5vQ2FjaGUpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goU1RSSU5HUy5ub0NhY2hlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubm9TdG9yZSkge1xuICAgICAgICB0b2tlbnMucHVzaChTVFJJTkdTLm5vU3RvcmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ub1RyYW5zZm9ybSkge1xuICAgICAgICB0b2tlbnMucHVzaChTVFJJTkdTLm5vVHJhbnNmb3JtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub25seUlmQ2FjaGVkKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFNUUklOR1Mub25seUlmQ2FjaGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbXCJwcml2YXRlXCJdKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFNUUklOR1NbXCJwcml2YXRlXCJdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJveHlSZXZhbGlkYXRlKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFNUUklOR1MucHJveHlSZXZhbGlkYXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbXCJwdWJsaWNcIl0pIHtcbiAgICAgICAgdG9rZW5zLnB1c2goU1RSSU5HU1tcInB1YmxpY1wiXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnMuam9pbignLCAnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FjaGVDb250cm9sO1xufSgpO1xuXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgdmFyIGNjID0gbmV3IENhY2hlQ29udHJvbCgpO1xuICByZXR1cm4gY2MucGFyc2UoaGVhZGVyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KGNjKSB7XG4gIGlmICghKGNjIGluc3RhbmNlb2YgQ2FjaGVDb250cm9sKSkge1xuICAgIHJldHVybiBDYWNoZUNvbnRyb2wucHJvdG90eXBlLmZvcm1hdC5jYWxsKGNjKTtcbiAgfVxuXG4gIHJldHVybiBjYy5mb3JtYXQoKTtcbn1cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgQ2FjaGVDb250cm9sOiBDYWNoZUNvbnRyb2wsXG4gIHBhcnNlOiBwYXJzZSxcbiAgZm9ybWF0OiBmb3JtYXRcbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jaGFyZW5jL2NoYXJlbmMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NoYXJlbmMvY2hhcmVuYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNoYXJlbmMgPSB7XG4gIC8vIFVURi04IGVuY29kaW5nXG4gIHV0Zjg6IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIGNoYXJlbmMuYmluLnN0cmluZ1RvQnl0ZXModW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY2hhcmVuYy5iaW4uYnl0ZXNUb1N0cmluZyhieXRlcykpKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQmluYXJ5IGVuY29kaW5nXG4gIGJpbjoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBzdHIgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkpO1xuICAgICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcmVuYztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCIpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWR2YW5jZS1zdHJpbmctaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3N0cmluZy1hdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXCIpKHRydWUpO1xuXG4gLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gYXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWlvYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1sZW5ndGggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qc1wiKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1hYnNvbHV0ZS1pbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1wiKTtcbnZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi4xMicgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZHAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcHJvcGVydHktZGVzYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYS1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1wiKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXCIpO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIikuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcIik7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1wiKTtcbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtcGllICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXCIpO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXCIpO1xudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2N0eCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzXCIpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTUFUQ0ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXM2LnJlZ2V4cC5leGVjICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1wiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGlkZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1wiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1wiKTtcbnZhciB3a3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKTtcbnZhciByZWdleHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVnZXhwLWV4ZWMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLmpzXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgfVxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgZm5zID0gZXhlYyhcbiAgICAgIGRlZmluZWQsXG4gICAgICBTWU1CT0wsXG4gICAgICAnJ1tLRVldLFxuICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgICB2YXIgcnhmbiA9IGZuc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcIikoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1kcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXCIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19wcm9wZXJ0eS1kZXNjICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcIikgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIikuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1wiKSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXCIpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kb20tY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXCIpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2l0ZXJhdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzXCIpO1xudmFyIElURVJBVE9SID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIikoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXCIpO1xudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXCIpO1xudmFyIE1BVENIID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIikoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcIik7XG52YXIgZGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Byb3BlcnR5LWRlc2MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXQtdG8tc3RyaW5nLXRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcIik7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hpZGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcIikoSXRlcmF0b3JQcm90b3R5cGUsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpYnJhcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcIik7XG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2l0ZXJhdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzXCIpO1xudmFyICRpdGVyQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXRlci1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2V0LXRvLXN0cmluZy10YWcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXCIpO1xudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWdwbyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1wiKTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIElURVJBVE9SID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIikoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTUVUQSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3VpZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXCIpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1wiKTtcbnZhciBzZXREZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWRwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcIikuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXCIpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1wiKTtcbnZhciBkUHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZHBzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzXCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZW51bS1idWcta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1wiKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcIikoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZG9tLWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1wiKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faHRtbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qc1wiKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pZTgtZG9tLWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1wcmltaXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1wiKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXCIpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1kcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIik7XG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcIikgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcElFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LXBpZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcHJvcGVydHktZGVzYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1wiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1pb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8tcHJpbWl0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanNcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pZTgtZG9tLWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcIik7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1wiKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWlvYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcIik7XG52YXIgZ09QTiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BuICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1wiKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3Qta2V5cy1pbnRlcm5hbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2VudW0tYnVnLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcIikuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXCIpO1xudmFyIElFX1BST1RPID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2hhcmVkLWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1wiKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWlvYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcIik7XG52YXIgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXktaW5jbHVkZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXCIpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcIikoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3Qta2V5cy1pbnRlcm5hbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lbnVtLWJ1Zy1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BuICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1wiKTtcbnZhciBnT1BTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWdvcHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIik7XG52YXIgUmVmbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXCIpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIik7XG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hpZGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanNcIik7XG52YXIgU1JDID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanNcIikoJ3NyYycpO1xudmFyICR0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Z1bmN0aW9uLXRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzXCIpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXCIpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NsYXNzb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcIik7XG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cbiAvLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciByZWdleHBGbGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZsYWdzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qc1wiKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvLFxuICAgICAgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTFbTEFTVF9JTkRFWF0gIT09IDAgfHwgcmUyW0xBU1RfSU5ERVhdICE9PSAwO1xufSkoKTtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQ7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4LCByZUNvcHksIG1hdGNoLCBpO1xuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgcmUuc291cmNlICsgJyQoPyFcXFxccyknLCByZWdleHBGbGFncy5jYWxsKHJlKSk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlW0xBU1RfSU5ERVhdO1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZVtMQVNUX0lOREVYXSA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZHAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1wiKS5mO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXCIpO1xudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcIikoJ2tleXMnKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL191aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIik7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpYnJhcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcIikgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXCIpO1xudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2EtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcIik7XG52YXIgU1BFQ0lFUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1pbnRlZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzXCIpO1xudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZWZpbmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzXCIpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pcy1yZWdleHAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qc1wiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1wiKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qc1wiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1wiKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXCIpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1wiKTtcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29yZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qc1wiKTtcbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbGlicmFyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qc1wiKTtcbnZhciB3a3NFeHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MtZXh0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWRwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcIikuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcIikoJ3drcycpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3VpZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXCIpO1xudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXCIpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbGFzc29mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzXCIpO1xudmFyIElURVJBVE9SID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIikoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXRlcmF0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcIikuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jdHggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qc1wiKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1wiKTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXRlci1jYWxsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanNcIik7XG52YXIgaXNBcnJheUl0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pcy1hcnJheS1pdGVyICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanNcIik7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jcmVhdGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBnZXRJdGVyRm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcIik7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIV9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2l0ZXItZGV0ZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1wiKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FkZC10by11bnNjb3BhYmxlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXCIpO1xudmFyIHN0ZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pdGVyLXN0ZXAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qc1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pdGVyYXRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1wiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1pb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXCIpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2l0ZXItZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1wiKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZHAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1wiKS5mO1xudmFyIEZQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXCIpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKCcnICsgdGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcIik7XG52YXIgX2lzRmluaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIikuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NsYXNzb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcIik7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcIikoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3JlZ2V4cC1leGVjICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qc1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXCIpKHtcbiAgdGFyZ2V0OiAnUmVnRXhwJyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogcmVnZXhwRXhlYyAhPT0gLy4vLmV4ZWNcbn0sIHtcbiAgZXhlYzogcmVnZXhwRXhlY1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtcmVnZXhwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanNcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1wiKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zcGVjaWVzLWNvbnN0cnVjdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXCIpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FkdmFuY2Utc3RyaW5nLWluZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZHZhbmNlLXN0cmluZy1pbmRleC5qc1wiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXCIpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLWFic3RyYWN0LmpzXCIpO1xudmFyIHJlZ2V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yZWdleHAtZXhlYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanNcIik7XG52YXIgJG1pbiA9IE1hdGgubWluO1xudmFyICRwdXNoID0gW10ucHVzaDtcbnZhciAkU1BMSVQgPSAnc3BsaXQnO1xudmFyIExFTkdUSCA9ICdsZW5ndGgnO1xudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbnZhciBNQVhfVUlOVDMyID0gMHhmZmZmZmZmZjtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHsgUmVnRXhwKE1BWF9VSU5UMzIsICd5Jyk7IH0pO1xuXG4vLyBAQHNwbGl0IGxvZ2ljXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19maXgtcmUtd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzXCIpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gJHNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogJHNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gJHNwbGl0O1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gU1VQUE9SVFNfWSA/IHEgOiAwO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9ICRtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXCIpO1xudmFyIGNvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdHJpbmctY29udGV4dCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanNcIik7XG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzLWlzLXJlZ2V4cCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzXCIpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1wiKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcIik7XG52YXIgTUVUQSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21ldGEgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanNcIikuS0VZO1xudmFyICRmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1wiKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zaGFyZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldC10by1zdHJpbmctdGFnICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1wiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL191aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1wiKTtcbnZhciB3a3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKTtcbnZhciB3a3NFeHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MtZXh0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzXCIpO1xudmFyIHdrc0RlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcy1kZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanNcIik7XG52YXIgZW51bUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lbnVtLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qc1wiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWlvYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1wcmltaXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcHJvcGVydHktZGVzYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1wiKTtcbnZhciBfY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1wiKTtcbnZhciBnT1BORXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWdvcG4tZXh0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcIik7XG52YXIgJEdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZ29wZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcIik7XG52YXIgJEdPUFMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZ29wcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcIik7XG52YXIgJERQID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWRwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcIik7XG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcIik7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICEhJEdPUFMuZjtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BuICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1wiKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1waWUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcIikuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgJEdPUFMuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19saWJyYXJ5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzXCIpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gJGZhaWxzKGZ1bmN0aW9uICgpIHsgJEdPUFMuZigxKTsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogRkFJTFNfT05fUFJJTUlUSVZFUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gJEdPUFMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCIpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1wiKTtcbnZhciAkaW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheS1pbmNsdWRlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcIikodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hZGQtdG8tdW5zY29wYWJsZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1wiKSgnaW5jbHVkZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXCIpO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vd24ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanNcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8taW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qc1wiKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWdvcGQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3JlYXRlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcIik7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MtZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzXCIpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICRpdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VzNi5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcIik7XG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1wiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1wiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGlkZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pdGVyYXRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1wiKTtcbnZhciB3a3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0L2NyeXB0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NyeXB0L2NyeXB0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIGJhc2U2NG1hcFxuICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsXG5cbiAgY3J5cHQgPSB7XG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gbGVmdFxuICAgIHJvdGw6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCBiKSB8IChuID4+PiAoMzIgLSBiKSk7XG4gICAgfSxcblxuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIHJpZ2h0XG4gICAgcm90cjogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8ICgzMiAtIGIpKSB8IChuID4+PiBiKTtcbiAgICB9LFxuXG4gICAgLy8gU3dhcCBiaWctZW5kaWFuIHRvIGxpdHRsZS1lbmRpYW4gYW5kIHZpY2UgdmVyc2FcbiAgICBlbmRpYW46IGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIElmIG51bWJlciBnaXZlbiwgc3dhcCBlbmRpYW5cbiAgICAgIGlmIChuLmNvbnN0cnVjdG9yID09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gY3J5cHQucm90bChuLCA4KSAmIDB4MDBGRjAwRkYgfCBjcnlwdC5yb3RsKG4sIDI0KSAmIDB4RkYwMEZGMDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEVsc2UsIGFzc3VtZSBhcnJheSBhbmQgc3dhcCBhbGwgaXRlbXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKylcbiAgICAgICAgbltpXSA9IGNyeXB0LmVuZGlhbihuW2ldKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiBhbnkgbGVuZ3RoIG9mIHJhbmRvbSBieXRlc1xuICAgIHJhbmRvbUJ5dGVzOiBmdW5jdGlvbihuKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdOyBuID4gMDsgbi0tKVxuICAgICAgICBieXRlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBiaWctZW5kaWFuIDMyLWJpdCB3b3Jkc1xuICAgIGJ5dGVzVG9Xb3JkczogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHdvcmRzID0gW10sIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpXG4gICAgICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMik7XG4gICAgICByZXR1cm4gd29yZHM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYmlnLWVuZGlhbiAzMi1iaXQgd29yZHMgdG8gYSBieXRlIGFycmF5XG4gICAgd29yZHNUb0J5dGVzOiBmdW5jdGlvbih3b3Jkcykge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KVxuICAgICAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBoZXggc3RyaW5nXG4gICAgYnl0ZXNUb0hleDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGhleCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldICYgMHhGKS50b1N0cmluZygxNikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhleC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgaGV4VG9CeXRlczogZnVuY3Rpb24oaGV4KSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBjID0gMDsgYyA8IGhleC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc3Vic3RyKGMsIDIpLCAxNikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGJhc2UtNjQgc3RyaW5nXG4gICAgYnl0ZXNUb0Jhc2U2NDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGJhc2U2NCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICAgIGlmIChpICogOCArIGogKiA2IDw9IGJ5dGVzLmxlbmd0aCAqIDgpXG4gICAgICAgICAgICBiYXNlNjQucHVzaChiYXNlNjRtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiA2ICogKDMgLSBqKSkgJiAweDNGKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goJz0nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlNjQuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBiYXNlLTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBiYXNlNjRUb0J5dGVzOiBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICAgIC8vIFJlbW92ZSBub24tYmFzZS02NCBjaGFyYWN0ZXJzXG4gICAgICBiYXNlNjQgPSBiYXNlNjQucmVwbGFjZSgvW15BLVowLTkrXFwvXS9pZywgJycpO1xuXG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMCwgaW1vZDQgPSAwOyBpIDwgYmFzZTY0Lmxlbmd0aDtcbiAgICAgICAgICBpbW9kNCA9ICsraSAlIDQpIHtcbiAgICAgICAgaWYgKGltb2Q0ID09IDApIGNvbnRpbnVlO1xuICAgICAgICBieXRlcy5wdXNoKCgoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpIC0gMSkpXG4gICAgICAgICAgICAmIChNYXRoLnBvdygyLCAtMiAqIGltb2Q0ICsgOCkgLSAxKSkgPDwgKGltb2Q0ICogMikpXG4gICAgICAgICAgICB8IChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkpKSA+Pj4gKDYgLSBpbW9kNCAqIDIpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gY3J5cHQ7XG59KSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9tZDUvbWQ1LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvbWQ1L21kNS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbihmdW5jdGlvbigpe1xyXG4gIHZhciBjcnlwdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNyeXB0ICovIFwiLi9ub2RlX21vZHVsZXMvY3J5cHQvY3J5cHQuanNcIiksXHJcbiAgICAgIHV0ZjggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjaGFyZW5jICovIFwiLi9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzXCIpLnV0ZjgsXHJcbiAgICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgaXMtYnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzXCIpLFxyXG4gICAgICBiaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjaGFyZW5jICovIFwiLi9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzXCIpLmJpbixcclxuXHJcbiAgLy8gVGhlIGNvcmVcclxuICBtZDUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgLy8gQ29udmVydCB0byBieXRlIGFycmF5XHJcbiAgICBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiaW5hcnknKVxyXG4gICAgICAgIG1lc3NhZ2UgPSBiaW4uc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1lc3NhZ2UgPSB1dGY4LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XHJcbiAgICBlbHNlIGlmIChpc0J1ZmZlcihtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UsIDApO1xyXG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciAhPT0gVWludDhBcnJheSlcclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudG9TdHJpbmcoKTtcclxuICAgIC8vIGVsc2UsIGFzc3VtZSBieXRlIGFycmF5IGFscmVhZHlcclxuXHJcbiAgICB2YXIgbSA9IGNyeXB0LmJ5dGVzVG9Xb3JkcyhtZXNzYWdlKSxcclxuICAgICAgICBsID0gbWVzc2FnZS5sZW5ndGggKiA4LFxyXG4gICAgICAgIGEgPSAgMTczMjU4NDE5MyxcclxuICAgICAgICBiID0gLTI3MTczMzg3OSxcclxuICAgICAgICBjID0gLTE3MzI1ODQxOTQsXHJcbiAgICAgICAgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gICAgLy8gU3dhcCBlbmRpYW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtW2ldID0gKChtW2ldIDw8ICA4KSB8IChtW2ldID4+PiAyNCkpICYgMHgwMEZGMDBGRiB8XHJcbiAgICAgICAgICAgICAoKG1baV0gPDwgMjQpIHwgKG1baV0gPj4+ICA4KSkgJiAweEZGMDBGRjAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhZGRpbmdcclxuICAgIG1bbCA+Pj4gNV0gfD0gMHg4MCA8PCAobCAlIDMyKTtcclxuICAgIG1bKCgobCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsO1xyXG5cclxuICAgIC8vIE1ldGhvZCBzaG9ydGN1dHNcclxuICAgIHZhciBGRiA9IG1kNS5fZmYsXHJcbiAgICAgICAgR0cgPSBtZDUuX2dnLFxyXG4gICAgICAgIEhIID0gbWQ1Ll9oaCxcclxuICAgICAgICBJSSA9IG1kNS5faWk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xyXG5cclxuICAgICAgdmFyIGFhID0gYSxcclxuICAgICAgICAgIGJiID0gYixcclxuICAgICAgICAgIGNjID0gYyxcclxuICAgICAgICAgIGRkID0gZDtcclxuXHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDBdLCAgNywgLTY4MDg3NjkzNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyA0XSwgIDcsIC0xNzY0MTg4OTcpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgOF0sICA3LCAgMTc3MDAzNTQxNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKzEyXSwgIDcsICAxODA0NjAzNjgyKTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyAxXSwgIDUsIC0xNjU3OTY1MTApO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyA2XSwgIDksIC0xMDY5NTAxNjMyKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgNV0sICA1LCAtNzAxNTU4NjkxKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxMF0sICA5LCAgMzgwMTYwODMpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyA5XSwgIDUsICA1Njg0NDY0MzgpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKzE0XSwgIDksIC0xMDE5ODAzNjkwKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krMTNdLCAgNSwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyAyXSwgIDksIC01MTQwMzc4NCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDVdLCAgNCwgLTM3ODU1OCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKzEzXSwgIDQsICA2ODEyNzkxNzQpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDldLCAgNCwgLTY0MDM2NDQ4Nyk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDYsIC0xOTg2MzA4NDQpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsxMl0sICA2LCAgMTcwMDQ4NTU3MSk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgNF0sICA2LCAtMTQ1NTIzMDcwKTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgICBhID0gKGEgKyBhYSkgPj4+IDA7XHJcbiAgICAgIGIgPSAoYiArIGJiKSA+Pj4gMDtcclxuICAgICAgYyA9IChjICsgY2MpID4+PiAwO1xyXG4gICAgICBkID0gKGQgKyBkZCkgPj4+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyeXB0LmVuZGlhbihbYSwgYiwgYywgZF0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEF1eGlsaWFyeSBmdW5jdGlvbnNcclxuICBtZDUuX2ZmICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGMgfCB+YiAmIGQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2dnICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGQgfCBjICYgfmQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2hoICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9paSAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG5cclxuICAvLyBQYWNrYWdlIHByaXZhdGUgYmxvY2tzaXplXHJcbiAgbWQ1Ll9ibG9ja3NpemUgPSAxNjtcclxuICBtZDUuX2RpZ2VzdHNpemUgPSAxNjtcclxuXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQgJyArIG1lc3NhZ2UpO1xyXG5cclxuICAgIHZhciBkaWdlc3RieXRlcyA9IGNyeXB0LndvcmRzVG9CeXRlcyhtZDUobWVzc2FnZSwgb3B0aW9ucykpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc0J5dGVzID8gZGlnZXN0Ynl0ZXMgOlxyXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA/IGJpbi5ieXRlc1RvU3RyaW5nKGRpZ2VzdGJ5dGVzKSA6XHJcbiAgICAgICAgY3J5cHQuYnl0ZXNUb0hleChkaWdlc3RieXRlcyk7XHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgOiB1bmRlZmluZWRcbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9hcGkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2FwaS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogc2V0dXAsIHNldHVwQ2FjaGUsIHNlcmlhbGl6ZVF1ZXJ5LCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNldHVwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0dXA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNldHVwQ2FjaGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXR1cENhY2hlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzN19vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSAqLyBcIi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihyZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgYXhpb3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGF4aW9zICovIFwiYXhpb3NcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgYXhpb3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihheGlvc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVxdWVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXF1ZXN0ICovIFwiLi9zcmMvcmVxdWVzdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2FjaGUgKi8gXCIuL3NyYy9jYWNoZS5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlcmlhbGl6ZVF1ZXJ5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJzZXJpYWxpemVRdWVyeVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbmZpZyAqLyBcIi4vc3JjL2NvbmZpZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxpdGllcyAqLyBcIi4vc3JjL3V0aWxpdGllcy5qc1wiKTtcblxuXG5cblxuXG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5cblxuXG5cblxuLyoqXG4gKiBDb25maWd1cmUgY2FjaGUgYWRhcHRlclxuICpcbiAqIEBwYXJhbSAgIHtvYmplY3R9IFtjb25maWc9e31dIENhY2hlIGFkYXB0ZXIgb3B0aW9uc1xuICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgY2FjaGUgYGFkYXB0ZXJgIGFuZCBgc3RvcmVgXG4gKi9cblxuZnVuY3Rpb24gc2V0dXBDYWNoZSgpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIC8vIEV4dGVuZCBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgY29uZmlnID0gT2JqZWN0KF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcIm1ha2VDb25maWdcIl0pKGNvbmZpZyk7IC8vIEF4aW9zIGFkYXB0ZXIuIFJlY2VpdmVzIHRoZSBheGlvcyByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gYXMgb25seSBwYXJhbWV0ZXJcblxuICBmdW5jdGlvbiBhZGFwdGVyKF94KSB7XG4gICAgcmV0dXJuIF9hZGFwdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gLy8gUmV0dXJuIGFkYXB0ZXIgYW5kIHN0b3JlIGluc3RhbmNlXG5cblxuICBmdW5jdGlvbiBfYWRhcHRlcigpIHtcbiAgICBfYWRhcHRlciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXEpIHtcbiAgICAgIHZhciByZXFDb25maWcsIHJlcywgbmV4dCwgbmV0d29ya0Vycm9yLCByZWFkT25FcnJvcjtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHBlci1yZXF1ZXN0IGNvbmZpZyB3aXRoIHRoZSBpbnN0YW5jZSBjb25maWcuXG4gICAgICAgICAgICAgIHJlcUNvbmZpZyA9IE9iamVjdChfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJtZXJnZVJlcXVlc3RDb25maWdcIl0pKGNvbmZpZywgcmVxKTsgLy8gRXhlY3V0ZSByZXF1ZXN0IGFnYWluc3QgbG9jYWwgY2FjaGVcblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfcmVxdWVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXSkocmVxQ29uZmlnLCByZXEpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIG5leHQgPSByZXMubmV4dDsgLy8gUmVzcG9uc2UgaXMgbm90IGZ1bmN0aW9uLCBzb21ldGhpbmcgd2FzIGluIGNhY2hlLCByZXR1cm4gaXRcblxuICAgICAgICAgICAgICBpZiAoT2JqZWN0KF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImlzRnVuY3Rpb25cIl0pKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5leHQpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIHJldHVybiByZXFDb25maWcuYWRhcHRlcihyZXEpO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTM7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg3KTtcbiAgICAgICAgICAgICAgbmV0d29ya0Vycm9yID0gX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGlmICghbmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGF0dGVtcHQgcmVhZGluZyBzdGFsZSBjYWNoZSBkYXRhXG4gICAgICAgICAgICAgIHJlYWRPbkVycm9yID0gT2JqZWN0KF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImlzRnVuY3Rpb25cIl0pKHJlcUNvbmZpZy5yZWFkT25FcnJvcikgPyByZXFDb25maWcucmVhZE9uRXJyb3IobmV0d29ya0Vycm9yLCByZXEpIDogcmVxQ29uZmlnLnJlYWRPbkVycm9yO1xuXG4gICAgICAgICAgICAgIGlmICghcmVhZE9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgIC8vIEZvcmNlIGNhY2hlIHR1IHJldHVybiBzdGFsZSBkYXRhXG4gICAgICAgICAgICAgIHJlcUNvbmZpZy5hY2NlcHRTdGFsZSA9IHRydWU7IC8vIFRyeSB0byByZWFkIGZyb20gY2FjaGUgYWdhaW5cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3JlcXVlc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0pKHJlcUNvbmZpZywgcmVxKTtcblxuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgLy8gU2lnbmFsIHRoYXQgZGF0YSBpcyBmcm9tIHN0YWxlIGNhY2hlXG4gICAgICAgICAgICAgIHJlcy5uZXh0LnJlcXVlc3Quc3RhbGUgPSB0cnVlOyAvLyBObyBuZWVkIHRvIGNoZWNrIGlmIGBuZXh0YCBpcyBhIGZ1bmN0aW9uIGp1c3QgcmV0dXJuIGNhY2hlIGRhdGFcblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5uZXh0KTtcblxuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI4O1xuICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTkpO1xuXG4gICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgICB0aHJvdyBuZXR3b3JrRXJyb3I7XG5cbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV4dChyZXMpKTtcblxuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbNywgMTNdLCBbMTksIDI4XV0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX2FkYXB0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRhcHRlcjogYWRhcHRlcixcbiAgICBjb25maWc6IGNvbmZpZyxcbiAgICBzdG9yZTogY29uZmlnLnN0b3JlXG4gIH07XG59IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRWFzeSBBUEkgU2V0dXBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNldHVwIGFuIGF4aW9zIGluc3RhbmNlIHdpdGggdGhlIGNhY2hlIGFkYXB0ZXIgcHJlLWNvbmZpZ3VyZWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIEF4aW9zIGFuZCBjYWNoZSBhZGFwdGVyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IEluc3RhbmNlIG9mIEF4aW9zXG4gKi9cblxuXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIGluc3RhbmNlQ29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRzXCJdLmF4aW9zKSwgY29uZmlnKSwge30sIHtcbiAgICBjYWNoZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0c1wiXS5heGlvcy5jYWNoZSksIGNvbmZpZy5jYWNoZSlcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gc2V0dXBDYWNoZShpbnN0YW5jZUNvbmZpZy5jYWNoZSk7XG5cbiAgdmFyIF8gPSBpbnN0YW5jZUNvbmZpZy5jYWNoZSxcbiAgICAgIGF4aW9zQ29uZmlnID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGluc3RhbmNlQ29uZmlnLCBbXCJjYWNoZVwiXSk7XG5cbiAgdmFyIGFwaSA9IGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19fZGVmYXVsdC5hLmNyZWF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aW9zQ29uZmlnKSwge30sIHtcbiAgICBhZGFwdGVyOiBjYWNoZS5hZGFwdGVyXG4gIH0pKTtcbiAgYXBpLmNhY2hlID0gY2FjaGUuc3RvcmU7XG4gIHJldHVybiBhcGk7XG59XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIHNldHVwOiBzZXR1cCxcbiAgc2V0dXBDYWNoZTogc2V0dXBDYWNoZSxcbiAgc2VyaWFsaXplUXVlcnk6IF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wic2VyaWFsaXplUXVlcnlcIl1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jYWNoZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jYWNoZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiByZWFkLCB3cml0ZSwga2V5LCBpbnZhbGlkYXRlLCBzZXJpYWxpemVRdWVyeSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZWFkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVhZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwid3JpdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwia2V5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4ga2V5OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbnZhbGlkYXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW52YWxpZGF0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VyaWFsaXplUXVlcnlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXJpYWxpemVRdWVyeTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19hcnJheV9pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19hcnJheV9pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczdfYXJyYXlfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zdHJpbmdfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zdHJpbmdfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X3N0cmluZ19pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSAqLyBcIi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihyZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbGl0aWVzICovIFwiLi9zcmMvdXRpbGl0aWVzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIG1kNV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbWQ1ICovIFwiLi9ub2RlX21vZHVsZXMvbWQ1L21kNS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBtZDVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtZDVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NlcmlhbGl6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZXJpYWxpemUgKi8gXCIuL3NyYy9zZXJpYWxpemUuanNcIik7XG5cblxuXG5cblxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5cblxuXG5cbmZ1bmN0aW9uIHdyaXRlKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX3dyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93cml0ZSgpIHtcbiAgX3dyaXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGNvbmZpZywgcmVxLCByZXMpIHtcbiAgICB2YXIgZW50cnk7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgZXhwaXJlczogY29uZmlnLmV4cGlyZXMsXG4gICAgICAgICAgICAgIGRhdGE6IE9iamVjdChfc2VyaWFsaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdKShjb25maWcsIHJlcSwgcmVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zdG9yZS5zZXRJdGVtKGNvbmZpZy51dWlkLCBlbnRyeSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA2O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29uZmlnLmRlYnVnKCdDb3VsZCBub3Qgc3RvcmUgcmVzcG9uc2UnLCBfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgIGlmICghY29uZmlnLmNsZWFyT25FcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTA7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnN0b3JlLmNsZWFyKCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE1O1xuICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDEwKTtcbiAgICAgICAgICAgIGNvbmZpZy5kZWJ1ZygnQ291bGQgbm90IGNsZWFyIHN0b3JlJywgX2NvbnRleHQudDEpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzAsIDZdLCBbMTAsIDE1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfd3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcmVhZChfeDQsIF94NSkge1xuICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3JlYWQoKSB7XG4gIF9yZWFkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihjb25maWcsIHJlcSkge1xuICAgIHZhciB1dWlkLCBpZ25vcmVDYWNoZSwgZW50cnksIGVycm9yLCBleHBpcmVzLCBkYXRhLCBvZmZsaW5lLCBfZXJyb3I7XG5cbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdXVpZCA9IGNvbmZpZy51dWlkLCBpZ25vcmVDYWNoZSA9IGNvbmZpZy5pZ25vcmVDYWNoZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc3RvcmUuZ2V0SXRlbSh1dWlkKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGVudHJ5ID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKGlnbm9yZUNhY2hlIHx8ICFlbnRyeSB8fCAhZW50cnkuZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5kZWJ1ZygnY2FjaGUtbWlzcycsIHJlcS51cmwpO1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGVycm9yLnJlYXNvbiA9ICdjYWNoZS1taXNzJztcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSAnRW50cnkgbm90IGZvdW5kIGZyb20gY2FjaGUnO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgZXhwaXJlcyA9IGVudHJ5LmV4cGlyZXMsIGRhdGEgPSBlbnRyeS5kYXRhOyAvLyBEbyBub3QgY2hlY2sgZm9yIHN0YWxlIGNhY2hlIGlmIG9mZmxpbmUgb24gY2xpZW50LXNpZGVcblxuICAgICAgICAgICAgb2ZmbGluZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmICdvbkxpbmUnIGluIG5hdmlnYXRvciAmJiAhbmF2aWdhdG9yLm9uTGluZTtcblxuICAgICAgICAgICAgaWYgKCEoIW9mZmxpbmUgJiYgIWNvbmZpZy5hY2NlcHRTdGFsZSAmJiBleHBpcmVzICE9PSAwICYmIGV4cGlyZXMgPCBEYXRlLm5vdygpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLmRlYnVnKCdjYWNoZS1zdGFsZScsIHJlcS51cmwpO1xuICAgICAgICAgICAgX2Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBfZXJyb3IucmVhc29uID0gJ2NhY2hlLXN0YWxlJztcbiAgICAgICAgICAgIF9lcnJvci5tZXNzYWdlID0gJ0VudHJ5IGlzIHN0YWxlJztcbiAgICAgICAgICAgIHRocm93IF9lcnJvcjtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBjb25maWcuZGVidWcoY29uZmlnLmFjY2VwdFN0YWxlID8gJ2NhY2hlLWhpdC1zdGFsZScgOiAnY2FjaGUtaGl0JywgcmVxLnVybCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGtleShjb25maWcpIHtcbiAgaWYgKE9iamVjdChfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJpc0Z1bmN0aW9uXCJdKShjb25maWcua2V5KSkgcmV0dXJuIGNvbmZpZy5rZXk7XG4gIHZhciBjYWNoZUtleTtcblxuICBpZiAoT2JqZWN0KF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImlzU3RyaW5nXCJdKShjb25maWcua2V5KSkge1xuICAgIGNhY2hlS2V5ID0gZnVuY3Rpb24gY2FjaGVLZXkocmVxKSB7XG4gICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQocmVxLmJhc2VVUkwgPyByZXEuYmFzZVVSTCA6ICcnKS5jb25jYXQocmVxLnVybCk7XG4gICAgICB2YXIga2V5ID0gXCJcIi5jb25jYXQoY29uZmlnLmtleSwgXCIvXCIpLmNvbmNhdCh1cmwpLmNvbmNhdChzZXJpYWxpemVRdWVyeShyZXEpKTtcbiAgICAgIHJldHVybiByZXEuZGF0YSA/IGtleSArIG1kNV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQoKShyZXEuZGF0YSkgOiBrZXk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZUtleSA9IGZ1bmN0aW9uIGNhY2hlS2V5KHJlcSkge1xuICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KHJlcS5iYXNlVVJMID8gcmVxLmJhc2VVUkwgOiAnJykuY29uY2F0KHJlcS51cmwpO1xuICAgICAgdmFyIGtleSA9IHVybCArIHNlcmlhbGl6ZVF1ZXJ5KHJlcSk7XG4gICAgICByZXR1cm4gcmVxLmRhdGEgPyBrZXkgKyBtZDVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0KCkocmVxLmRhdGEpIDoga2V5O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gY2FjaGVLZXk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRJbnZhbGlkYXRlKF94NiwgX3g3KSB7XG4gIHJldHVybiBfZGVmYXVsdEludmFsaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2RlZmF1bHRJbnZhbGlkYXRlKCkge1xuICBfZGVmYXVsdEludmFsaWRhdGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGNvbmZpZywgcmVxKSB7XG4gICAgdmFyIG1ldGhvZDtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbWV0aG9kID0gcmVxLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5leGNsdWRlLm1ldGhvZHMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnN0b3JlLnJlbW92ZUl0ZW0oY29uZmlnLnV1aWQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMpO1xuICB9KSk7XG4gIHJldHVybiBfZGVmYXVsdEludmFsaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGlmIChPYmplY3QoX3V0aWxpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiaXNGdW5jdGlvblwiXSkoY29uZmlnLmludmFsaWRhdGUpKSByZXR1cm4gY29uZmlnLmludmFsaWRhdGU7XG4gIHJldHVybiBkZWZhdWx0SW52YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplUXVlcnkocmVxKSB7XG4gIGlmICghcmVxLnBhcmFtcykgcmV0dXJuICcnOyAvLyBQcm9iYWJseSBzZXJ2ZXItc2lkZSwganVzdCBzdHJpbmdpZnkgdGhlIG9iamVjdFxuXG4gIGlmICh0eXBlb2YgVVJMU2VhcmNoUGFyYW1zID09PSAndW5kZWZpbmVkJykgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcS5wYXJhbXMpO1xuICB2YXIgcGFyYW1zID0gcmVxLnBhcmFtcztcbiAgdmFyIGlzSW5zdGFuY2VPZlVSTFNlYXJjaFBhcmFtcyA9IHJlcS5wYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7IC8vIENvbnZlcnQgdG8gYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zIHNvIGl0IGdldCBzZXJpYWxpemVkIHRoZSBzYW1lIHdheVxuXG4gIGlmICghaXNJbnN0YW5jZU9mVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIE9iamVjdC5rZXlzKHJlcS5wYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHBhcmFtcy5hcHBlbmQoa2V5LCByZXEucGFyYW1zW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFwiP1wiLmNvbmNhdChwYXJhbXMudG9TdHJpbmcoKSk7XG59XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIHJlYWQ6IHJlYWQsXG4gIHdyaXRlOiB3cml0ZSxcbiAga2V5OiBrZXksXG4gIGludmFsaWRhdGU6IGludmFsaWRhdGUsXG4gIHNlcmlhbGl6ZVF1ZXJ5OiBzZXJpYWxpemVRdWVyeVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbmZpZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29uZmlnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0cywgbWFrZUNvbmZpZywgbWVyZ2VSZXF1ZXN0Q29uZmlnLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmYXVsdHM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1ha2VDb25maWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYWtlQ29uZmlnOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtZXJnZVJlcXVlc3RDb25maWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXJnZVJlcXVlc3RDb25maWc7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczdfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczdfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM3X29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBheGlvcyAqLyBcImF4aW9zXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXhpb3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21lbW9yeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZW1vcnkgKi8gXCIuL3NyYy9tZW1vcnkuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NhY2hlICovIFwiLi9zcmMvY2FjaGUuanNcIik7XG5cblxuXG5cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxuXG5cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge1xuICB2YXIgX2NvbnNvbGU7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIFsnW2F4aW9zLWNhY2hlLWFkYXB0ZXJdJ10uY29uY2F0KGFyZ3MpKTtcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gRGVmYXVsdCBzZXR0aW5ncyB3aGVuIHNvbGVseSBjcmVhdGluZyB0aGUgY2FjaGUgYWRhcHRlciB3aXRoIHNldHVwQ2FjaGUuXG4gIGNhY2hlOiB7XG4gICAgbWF4QWdlOiAwLFxuICAgIGxpbWl0OiBmYWxzZSxcbiAgICBzdG9yZTogbnVsbCxcbiAgICBrZXk6IG51bGwsXG4gICAgaW52YWxpZGF0ZTogbnVsbCxcbiAgICBleGNsdWRlOiB7XG4gICAgICBwYXRoczogW10sXG4gICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgIGZpbHRlcjogbnVsbCxcbiAgICAgIG1ldGhvZHM6IFsncG9zdCcsICdwYXRjaCcsICdwdXQnLCAnZGVsZXRlJ11cbiAgICB9LFxuICAgIGFkYXB0ZXI6IGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdC5hLmRlZmF1bHRzLmFkYXB0ZXIsXG4gICAgY2xlYXJPblN0YWxlOiB0cnVlLFxuICAgIGNsZWFyT25FcnJvcjogdHJ1ZSxcbiAgICByZWFkT25FcnJvcjogZmFsc2UsXG4gICAgcmVhZEhlYWRlcnM6IGZhbHNlLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBpZ25vcmVDYWNoZTogZmFsc2VcbiAgfSxcbiAgLy8gQWRkaXRpb25hbCBkZWZhdWx0cyB3aGVuIGNyZWF0aW5nIHRoZSBheGlvcyBpbnN0YW5jZSB3aXRoIHRoZSBjYWNoZSBhZGFwdGVyLlxuICBheGlvczoge1xuICAgIGNhY2hlOiB7XG4gICAgICBtYXhBZ2U6IDE1ICogNjAgKiAxMDAwXG4gICAgfVxuICB9XG59OyAvLyBMaXN0IG9mIGRpc2FsbG93ZWQgaW4gdGhlIHBlci1yZXF1ZXN0IGNvbmZpZy5cblxudmFyIGRpc2FsbG93ZWRQZXJSZXF1ZXN0S2V5cyA9IFsnbGltaXQnLCAnc3RvcmUnLCAnYWRhcHRlcicsICd1dWlkJywgJ2FjY2VwdFN0YWxlJ107XG4vKipcbiAqIE1ha2UgYSBnbG9iYWwgY29uZmlnIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW292ZXJyaWRlPXt9XSBPcHRpb25hbCBjb25maWcgb3ZlcnJpZGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxudmFyIG1ha2VDb25maWcgPSBmdW5jdGlvbiBtYWtlQ29uZmlnKCkge1xuICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBjb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdHMuY2FjaGUpLCBvdmVycmlkZSksIHt9LCB7XG4gICAgZXhjbHVkZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0cy5jYWNoZS5leGNsdWRlKSwgb3ZlcnJpZGUuZXhjbHVkZSlcbiAgfSk7IC8vIENyZWF0ZSBhIGNhY2hlIGtleSBtZXRob2RcblxuXG4gIGNvbmZpZy5rZXkgPSBPYmplY3QoX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJrZXlcIl0pKGNvbmZpZyk7XG4gIGNvbmZpZy5pbnZhbGlkYXRlID0gT2JqZWN0KF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiaW52YWxpZGF0ZVwiXSkoY29uZmlnKTsgLy8gSWYgZGVidWcgbW9kZSBpcyBvbiwgY3JlYXRlIGEgc2ltcGxlIGxvZ2dlciBtZXRob2RcblxuICBpZiAoY29uZmlnLmRlYnVnICE9PSBmYWxzZSkge1xuICAgIGNvbmZpZy5kZWJ1ZyA9IHR5cGVvZiBjb25maWcuZGVidWcgPT09ICdmdW5jdGlvbicgPyBjb25maWcuZGVidWcgOiBkZWJ1ZztcbiAgfSBlbHNlIHtcbiAgICBjb25maWcuZGVidWcgPSBub29wO1xuICB9IC8vIENyZWF0ZSBhbiBpbiBtZW1vcnkgc3RvcmUgaWYgbm9uZSB3YXMgZ2l2ZW5cblxuXG4gIGlmICghY29uZmlnLnN0b3JlKSBjb25maWcuc3RvcmUgPSBuZXcgX21lbW9yeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSgpO1xuICBjb25maWcuZGVidWcoJ0dsb2JhbCBjYWNoZSBjb25maWcnLCBjb25maWcpO1xuICByZXR1cm4gY29uZmlnO1xufTtcbi8qKlxuICogTWVyZ2UgdGhlIHBlci1yZXF1ZXN0IGNvbmZpZyBpbiBhbm90aGVyIGNvbmZpZy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBleGlzdHMgYmVjYXVzZSBub3QgYWxsIGtleXMgc2hvdWxkIGJlIGFsbG93ZWQgYXMgaXRcbiAqIG1heSBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3Vycy4gRm9yIGluc3RhbmNlLCBzZXR0aW5nIGFub3RoZXJcbiAqIHN0b3JlIG9yIGFkYXB0ZXIgcGVyIHJlcXVlc3QgaXMgd3JvbmcsIGluc3RlYWQgYW5vdGhlciBpbnN0YW5jZVxuICogYXhpb3MsIG9yIHRoZSBhZGFwdGVyLCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxICAgIFRoZSBjdXJyZW50IGF4aW9zIHJlcXVlc3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cbnZhciBtZXJnZVJlcXVlc3RDb25maWcgPSBmdW5jdGlvbiBtZXJnZVJlcXVlc3RDb25maWcoY29uZmlnLCByZXEpIHtcbiAgdmFyIHJlcXVlc3RDb25maWcgPSByZXEuY2FjaGUgfHwge307XG5cbiAgaWYgKHJlcXVlc3RDb25maWcpIHtcbiAgICBkaXNhbGxvd2VkUGVyUmVxdWVzdEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gcmVxdWVzdENvbmZpZ1trZXldID8gZGVsZXRlIHJlcXVlc3RDb25maWdba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBtZXJnZWRDb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29uZmlnKSwgcmVxdWVzdENvbmZpZyksIHt9LCB7XG4gICAgZXhjbHVkZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb25maWcuZXhjbHVkZSksIHJlcXVlc3RDb25maWcuZXhjbHVkZSlcbiAgfSk7XG5cbiAgaWYgKG1lcmdlZENvbmZpZy5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgIG1lcmdlZENvbmZpZy5kZWJ1ZyA9IGRlYnVnO1xuICB9IC8vIENyZWF0ZSBhIGNhY2hlIGtleSBtZXRob2RcblxuXG4gIGlmIChyZXF1ZXN0Q29uZmlnLmtleSkge1xuICAgIG1lcmdlZENvbmZpZy5rZXkgPSBPYmplY3QoX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJrZXlcIl0pKHJlcXVlc3RDb25maWcpO1xuICB9IC8vIEdlbmVyYXRlIHJlcXVlc3QgVVVJRFxuXG5cbiAgbWVyZ2VkQ29uZmlnLnV1aWQgPSBtZXJnZWRDb25maWcua2V5KHJlcSk7XG4gIGNvbmZpZy5kZWJ1ZyhcIlJlcXVlc3QgY29uZmlnIGZvciBcIi5jb25jYXQocmVxLnVybCksIG1lcmdlZENvbmZpZyk7XG4gIHJldHVybiBtZXJnZWRDb25maWc7XG59O1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBkZWZhdWx0czogZGVmYXVsdHMsXG4gIG1ha2VDb25maWc6IG1ha2VDb25maWcsXG4gIG1lcmdlUmVxdWVzdENvbmZpZzogbWVyZ2VSZXF1ZXN0Q29uZmlnXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZXhjbHVkZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2V4Y2x1ZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X2FycmF5X2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X2FycmF5X2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzN19hcnJheV9pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N0cmluZ19pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N0cmluZ19pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfc3RyaW5nX2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbGl0aWVzICovIFwiLi9zcmMvdXRpbGl0aWVzLmpzXCIpO1xuXG5cblxuXG5cblxuZnVuY3Rpb24gZXhjbHVkZSgpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciByZXEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIF9jb25maWckZXhjbHVkZSA9IGNvbmZpZy5leGNsdWRlLFxuICAgICAgZXhjbHVkZSA9IF9jb25maWckZXhjbHVkZSA9PT0gdm9pZCAwID8ge30gOiBfY29uZmlnJGV4Y2x1ZGUsXG4gICAgICBkZWJ1ZyA9IGNvbmZpZy5kZWJ1ZztcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobWV0aG9kID09PSAnaGVhZCcgfHwgZXhjbHVkZS5tZXRob2RzLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICBkZWJ1ZyhcIkV4Y2x1ZGluZyByZXF1ZXN0IGJ5IEhUVFAgbWV0aG9kIFwiLmNvbmNhdChyZXEudXJsKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUuZmlsdGVyID09PSAnZnVuY3Rpb24nICYmIGV4Y2x1ZGUuZmlsdGVyKHJlcSkpIHtcbiAgICBkZWJ1ZyhcIkV4Y2x1ZGluZyByZXF1ZXN0IGJ5IGZpbHRlciBcIi5jb25jYXQocmVxLnVybCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGRvIG5vdCBjYWNoZSByZXF1ZXN0IHdpdGggcXVlcnlcblxuXG4gIHZhciBoYXNRdWVyeVBhcmFtcyA9IC9cXD8uKiQvLnRlc3QocmVxLnVybCkgfHwgT2JqZWN0KF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImlzT2JqZWN0XCJdKShyZXEucGFyYW1zKSAmJiBPYmplY3Qua2V5cyhyZXEucGFyYW1zKS5sZW5ndGggIT09IDAgfHwgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxLnBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcblxuICBpZiAoZXhjbHVkZS5xdWVyeSAmJiBoYXNRdWVyeVBhcmFtcykge1xuICAgIGRlYnVnKFwiRXhjbHVkaW5nIHJlcXVlc3QgYnkgcXVlcnkgXCIuY29uY2F0KHJlcS51cmwpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwYXRocyA9IGV4Y2x1ZGUucGF0aHMgfHwgW107XG4gIHZhciBmb3VuZCA9IHBhdGhzLnNvbWUoZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgIHJldHVybiByZXEudXJsLm1hdGNoKHJlZ2V4cCk7XG4gIH0pO1xuXG4gIGlmIChmb3VuZCkge1xuICAgIGRlYnVnKFwiRXhjbHVkaW5nIHJlcXVlc3QgYnkgdXJsIG1hdGNoIFwiLmNvbmNhdChyZXEudXJsKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoZXhjbHVkZSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNldHVwLCBzZXR1cENhY2hlLCBzZXJpYWxpemVRdWVyeSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXBpX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FwaSAqLyBcIi4vc3JjL2FwaS5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNldHVwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wic2V0dXBcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXR1cENhY2hlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wic2V0dXBDYWNoZVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlcmlhbGl6ZVF1ZXJ5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wic2VyaWFsaXplUXVlcnlcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xpbWl0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xpbWl0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcblxuXG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIGxpbWl0KF94KSB7XG4gIHJldHVybiBfbGltaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xpbWl0KCkge1xuICBfbGltaXQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoY29uZmlnKSB7XG4gICAgdmFyIGxlbmd0aCwgZmlyc3RJdGVtO1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zdG9yZS5sZW5ndGgoKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxlbmd0aCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKGxlbmd0aCA8IGNvbmZpZy5saW1pdCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgY29uZmlnLmRlYnVnKFwiQ3VycmVudCBzdG9yZSBzaXplOiBcIi5jb25jYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc3RvcmUuaXRlcmF0ZShmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0SXRlbSkgZmlyc3RJdGVtID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAodmFsdWUuZXhwaXJlcyA8IGZpcnN0SXRlbS52YWx1ZS5leHBpcmVzKSBmaXJzdEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghZmlyc3RJdGVtKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5kZWJ1ZyhcIlJlbW92aW5nIGl0ZW06IFwiLmNvbmNhdChmaXJzdEl0ZW0ua2V5KSk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnN0b3JlLnJlbW92ZUl0ZW0oZmlyc3RJdGVtLmtleSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2xpbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAobGltaXQpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9tZW1vcnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21lbW9yeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbGl0aWVzICovIFwiLi9zcmMvdXRpbGl0aWVzLmpzXCIpO1xuXG5cblxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG52YXIgTWVtb3J5U3RvcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZW1vcnlTdG9yZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtb3J5U3RvcmUpO1xuXG4gICAgdGhpcy5zdG9yZSA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lbW9yeVN0b3JlLCBbe1xuICAgIGtleTogXCJnZXRJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0SXRlbSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShrZXkpIHtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5zdG9yZVtrZXldIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBKU09OLnBhcnNlKGl0ZW0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEl0ZW0oX3gpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRJdGVtO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInNldEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZXRJdGVtID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZVtrZXldID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHZhbHVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2V0SXRlbShfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX3NldEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldEl0ZW07XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlbW92ZUl0ZW0gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGtleSkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2tleV07XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUl0ZW0oX3g0KSB7XG4gICAgICAgIHJldHVybiBfcmVtb3ZlSXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlSXRlbTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NsZWFyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlID0ge307XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICByZXR1cm4gX2NsZWFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGVhcjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJsZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sZW5ndGggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIF9sZW5ndGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJpdGVyYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZXJhdGUoZm4pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3QoX3V0aWxpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibWFwT2JqZWN0XCJdKSh0aGlzLnN0b3JlLCBmbikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZW1vcnlTdG9yZTtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChNZW1vcnlTdG9yZSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlcXVlc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9yZXF1ZXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSAqLyBcIi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihyZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZXNwb25zZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXNwb25zZSAqLyBcIi4vc3JjL3Jlc3BvbnNlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9leGNsdWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V4Y2x1ZGUgKi8gXCIuL3NyYy9leGNsdWRlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jYWNoZSAqLyBcIi4vc3JjL2NhY2hlLmpzXCIpO1xuXG5cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuXG5cblxuXG5mdW5jdGlvbiByZXF1ZXN0KF94LCBfeDIpIHtcbiAgcmV0dXJuIF9yZXF1ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9yZXF1ZXN0KCkge1xuICBfcmVxdWVzdCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjb25maWcsIHJlcSkge1xuICAgIHZhciBuZXh0LCByZXMsIGV4Y2x1ZGVGcm9tQ2FjaGU7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgZXhjbHVkZUZyb21DYWNoZSA9IGZ1bmN0aW9uIF9leGNsdWRlRnJvbUNhY2hlKCkge1xuICAgICAgICAgICAgICBjb25maWcuZXhjbHVkZUZyb21DYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uZmlnLmRlYnVnKCd1dWlkJywgY29uZmlnLnV1aWQpO1xuXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uYXBwbHkodm9pZCAwLCBbY29uZmlnLCByZXFdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICB9OyAvLyBydW4gaW52YWxpZGF0ZSBmdW5jdGlvbiB0byBjaGVjayBpZiBhbnkgY2FjaGUgaXRlbXMgbmVlZCB0byBiZSBpbnZhbGlkYXRlZC5cblxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuaW52YWxpZGF0ZShjb25maWcsIHJlcSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpZiAoIU9iamVjdChfZXhjbHVkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSkoY29uZmlnLCByZXEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBleGNsdWRlRnJvbUNhY2hlKCkpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wicmVhZFwiXSkoY29uZmlnLCByZXEpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXMuY29uZmlnID0gcmVxO1xuICAgICAgICAgICAgcmVzLnJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgIGZyb21DYWNoZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgbmV4dDogcmVzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oNyk7XG5cbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5jbGVhck9uU3RhbGUgJiYgX2NvbnRleHQudDAucmVhc29uID09PSAnY2FjaGUtc3RhbGUnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnN0b3JlLnJlbW92ZUl0ZW0oY29uZmlnLnV1aWQpO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgbmV4dDogbmV4dFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzcsIDE2XV0pO1xuICB9KSk7XG4gIHJldHVybiBfcmVxdWVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHJlcXVlc3QpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZXNwb25zZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9yZXNwb25zZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lICovIFwiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpbWl0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpbWl0ICovIFwiLi9zcmMvbGltaXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NhY2hlICovIFwiLi9zcmMvY2FjaGUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY2FjaGVfY29udHJvbF9lc21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNhY2hlLWNvbnRyb2wtZXNtICovIFwiLi9ub2RlX21vZHVsZXMvY2FjaGUtY29udHJvbC1lc20vaW5kZXguanNcIik7XG5cblxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5cblxuXG5cbmZ1bmN0aW9uIHJlc3BvbnNlKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX3Jlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9yZXNwb25zZSgpIHtcbiAgX3Jlc3BvbnNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGNvbmZpZywgcmVxLCByZXMpIHtcbiAgICB2YXIgX3JlcyRyZXF1ZXN0LCByZXF1ZXN0LCBfcmVzJGhlYWRlcnMsIGhlYWRlcnMsIGNhY2hlQ29udHJvbDtcblxuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9yZXMkcmVxdWVzdCA9IHJlcy5yZXF1ZXN0LCByZXF1ZXN0ID0gX3JlcyRyZXF1ZXN0ID09PSB2b2lkIDAgPyB7fSA6IF9yZXMkcmVxdWVzdCwgX3JlcyRoZWFkZXJzID0gcmVzLmhlYWRlcnMsIGhlYWRlcnMgPSBfcmVzJGhlYWRlcnMgPT09IHZvaWQgMCA/IHt9IDogX3JlcyRoZWFkZXJzOyAvLyBleGNsdWRlIGJpbmFyeSByZXNwb25zZSBmcm9tIGNhY2hlXG5cbiAgICAgICAgICAgIGlmICghKFsnYXJyYXlidWZmZXInLCAnYmxvYiddLmluZGV4T2YocmVxdWVzdC5yZXNwb25zZVR5cGUpID4gLTEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FjaGVDb250cm9sID0ge307IC8vIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZXJtaW5lIHJlcXVlc3QgY2FjaGUgZXhwaXJhdGlvbiBmcm9tIGhlYWRlcnMgb3Igbm90XG5cbiAgICAgICAgICAgIGlmIChjb25maWcucmVhZEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIGBjYWNoZS1jb250cm9sYCBoZWFkZXIgZnJvbSByZXNwb25zZVxuICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbCA9IE9iamVjdChjYWNoZV9jb250cm9sX2VzbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wicGFyc2VcIl0pKGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSk7IC8vIEZvcmNlIGNhY2hlIGV4bGN1c2lvbiBmb3IgYGNhY2hlLWNvbnRyb2w6IG5vLWNhY2hlYCBhbmQgYGNhY2hlLWNvbnRyb2w6IG5vLXN0b3JlYFxuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlQ29udHJvbC5ub0NhY2hlIHx8IGNhY2hlQ29udHJvbC5ub1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWcuZXhjbHVkZUZyb21DYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlcnMuZXhwaXJlcykge1xuICAgICAgICAgICAgICAgIC8vIEVsc2UgdHJ5IHJlYWRpbmcgYGV4cGlyZXNgIGhlYWRlclxuICAgICAgICAgICAgICAgIGNvbmZpZy5leHBpcmVzID0gbmV3IERhdGUoaGVhZGVycy5leHBpcmVzKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmV4cGlyZXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29uZmlnLmV4Y2x1ZGVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhY2hlQ29udHJvbC5tYXhBZ2UgfHwgY2FjaGVDb250cm9sLm1heEFnZSA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBVc2UgYGNhY2hlLWNvbnRyb2xgIGhlYWRlciBgbWF4LWFnZWAgdmFsdWUgYW5kIGNvbnZlcnQgdG8gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgIGNvbmZpZy5leHBpcmVzID0gRGF0ZS5ub3coKSArIGNhY2hlQ29udHJvbC5tYXhBZ2UgKiAxMDAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghY29uZmlnLnJlYWRIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSBmaXhlZCBgbWF4QWdlYCBkZWZpbmVkIGluIHRoZSBnbG9iYWwgb3IgcGVyLXJlcXVlc3QgY29uZmlnXG4gICAgICAgICAgICAgIGNvbmZpZy5leHBpcmVzID0gY29uZmlnLm1heEFnZSA9PT0gMCA/IERhdGUubm93KCkgOiBEYXRlLm5vdygpICsgY29uZmlnLm1heEFnZTtcbiAgICAgICAgICAgIH0gLy8gQ2hlY2sgaWYgYSBjYWNoZSBsaW1pdCBoYXMgYmVlbiBjb25maWd1cmVkXG5cblxuICAgICAgICAgICAgaWYgKCFjb25maWcubGltaXQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLmRlYnVnKFwiRGV0ZWN0ZWQgbGltaXQ6IFwiLmNvbmNhdChjb25maWcubGltaXQpKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX2xpbWl0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKShjb25maWcpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJ3cml0ZVwiXSkoY29uZmlnLCByZXEsIHJlcyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgLy8gTWFyayByZXF1ZXN0IGFzIGV4Y2x1ZGVkIGZyb20gY2FjaGVcbiAgICAgICAgICAgIHJlcy5yZXF1ZXN0LmV4Y2x1ZGVkRnJvbUNhY2hlID0gdHJ1ZTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3Jlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAocmVzcG9uc2UpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zZXJpYWxpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3NlcmlhbGl6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcblxuXG5cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gc2VyaWFsaXplKGNvbmZpZywgcmVxLCByZXMpIHtcbiAgaWYgKHJlcy5kYXRhKSB7XG4gICAgLy8gRklYTUU6IE1heSBiZSB1c2VsZXNzIGFzIGxvY2FsRm9yYWdlIGFuZCBheGlvcyBhbHJlYWR5IHBhcnNlIGF1dG9tYXRpY2FsbHlcbiAgICB0cnkge1xuICAgICAgcmVzLmRhdGEgPSBKU09OLnBhcnNlKHJlcy5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbmZpZy5kZWJ1ZygnQ291bGQgbm90IHBhcnNlIGRhdGEgYXMgSlNPTicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlcXVlc3QgPSByZXMucmVxdWVzdCxcbiAgICAgIF8gPSByZXMuY29uZmlnLFxuICAgICAgc2VyaWFsaXplZCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyZXMsIFtcInJlcXVlc3RcIiwgXCJjb25maWdcIl0pO1xuXG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHNlcmlhbGl6ZSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxpdGllcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbGl0aWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc09iamVjdCwgZ2V0VGFnLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgbWFwT2JqZWN0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNPYmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFRhZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNGdW5jdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRnVuY3Rpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTdHJpbmc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1hcE9iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1hcE9iamVjdDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19zeW1ib2xfYXN5bmNfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19zeW1ib2xfYXN5bmNfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM3X3N5bWJvbF9hc3luY19pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcblxuXG5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyL2lzT2JqZWN0LmpzXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YodmFsdWUpO1xuXG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2dldFRhZy5qc1xuXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAnW29iamVjdCBVbmRlZmluZWRdJyA6ICdbb2JqZWN0IE51bGxdJztcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Z1bmN0aW9uLmpzXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgfHwgdGFnID09PSAnW29iamVjdCBQcm94eV0nO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc1N0cmluZy5qc1xuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YodmFsdWUpO1xuXG4gIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdCh2YWx1ZSwgZm4pIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZuKHZhbHVlW2tleV0sIGtleSk7XG4gIH0pO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJheGlvc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBleHRlcm5hbCB7XCJ1bWRcIjpcImF4aW9zXCIsXCJhbWRcIjpcImF4aW9zXCIsXCJjb21tb25qc1wiOlwiYXhpb3NcIixcImNvbW1vbmpzMlwiOlwiYXhpb3NcIn0gKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2F4aW9zX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcih0aW1lb3V0RXJyb3JNZXNzYWdlLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhheGlvcy5kZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBmdWxsIHBhdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCIvKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKVxuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgfVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbnZhciBjb25zb2xlXG52YXIgdGltZXMgPSB7fVxuXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZVxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG59IGVsc2Uge1xuICAgIGNvbnNvbGUgPSB7fVxufVxuXG52YXIgZnVuY3Rpb25zID0gW1xuICAgIFtsb2csIFwibG9nXCJdLFxuICAgIFtpbmZvLCBcImluZm9cIl0sXG4gICAgW3dhcm4sIFwid2FyblwiXSxcbiAgICBbZXJyb3IsIFwiZXJyb3JcIl0sXG4gICAgW3RpbWUsIFwidGltZVwiXSxcbiAgICBbdGltZUVuZCwgXCJ0aW1lRW5kXCJdLFxuICAgIFt0cmFjZSwgXCJ0cmFjZVwiXSxcbiAgICBbZGlyLCBcImRpclwiXSxcbiAgICBbY29uc29sZUFzc2VydCwgXCJhc3NlcnRcIl1cbl1cblxuZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgdmFyIG5hbWUgPSB0dXBsZVsxXVxuXG4gICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVcblxuZnVuY3Rpb24gbG9nKCkge31cblxuZnVuY3Rpb24gaW5mbygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgdGltZXNbbGFiZWxdID0gbm93KClcbn1cblxuZnVuY3Rpb24gdGltZUVuZChsYWJlbCkge1xuICAgIHZhciB0aW1lID0gdGltZXNbbGFiZWxdXG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWw6IFwiICsgbGFiZWwpXG4gICAgfVxuXG4gICAgZGVsZXRlIHRpbWVzW2xhYmVsXVxuICAgIHZhciBkdXJhdGlvbiA9IG5vdygpIC0gdGltZVxuICAgIGNvbnNvbGUubG9nKGxhYmVsICsgXCI6IFwiICsgZHVyYXRpb24gKyBcIm1zXCIpXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgIGVyci5uYW1lID0gXCJUcmFjZVwiXG4gICAgZXJyLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG59XG5cbmZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqZWN0KSArIFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVBc3NlcnQoZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgYXJyID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJyKSlcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmogPSByZXF1aXJlKCdpcy1vYmonKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignU291cmNlcyBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gYXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpIHtcblx0dmFyIHZhbCA9IGZyb21ba2V5XTtcblxuXHRpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkpIHtcblx0XHRpZiAodG9ba2V5XSA9PT0gdW5kZWZpbmVkIHx8IHRvW2tleV0gPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCAoJyArIGtleSArICcpJyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrZXkpIHx8ICFpc09iaih2YWwpKSB7XG5cdFx0dG9ba2V5XSA9IHZhbDtcblx0fSBlbHNlIHtcblx0XHR0b1trZXldID0gYXNzaWduKE9iamVjdCh0b1trZXldKSwgZnJvbVtrZXldKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NpZ24odG8sIGZyb20pIHtcblx0aWYgKHRvID09PSBmcm9tKSB7XG5cdFx0cmV0dXJuIHRvO1xuXHR9XG5cblx0ZnJvbSA9IE9iamVjdChmcm9tKTtcblxuXHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdGFzc2lnbktleSh0bywgZnJvbSwga2V5KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRhc3NpZ25LZXkodG8sIGZyb20sIHN5bWJvbHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCkge1xuXHR0YXJnZXQgPSB0b09iamVjdCh0YXJnZXQpO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0YXNzaWduKHRhcmdldCwgYXJndW1lbnRzW3NdKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvYmogPSB7fTtcblx0dHJ5IHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSk7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRcdGZvciAodmFyIF8gaW4gb2JqKSB7IC8vIGpzY3M6aWdub3JlIGRpc2FsbG93VW51c2VkVmFyaWFibGVzXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBvYmoueCA9PT0gb2JqO1xuXHR9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgSUUgOC4gKi9cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkKCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7XG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJyk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZmlyc3RTb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XG4gICAgICB2YXIgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhc3NpZ25cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ24sXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnID8gc2VsZi5Gb3JtRGF0YSA6IHdpbmRvdy5Gb3JtRGF0YTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbikge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWItbm9kZScpXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwdWJzdWIgPSByZXF1aXJlKCduYW5vLXB1YnN1YicpO1xudmFyIG1pZGRsZXdhcmVSZWR1Y2VyID0gcmVxdWlyZSgnLi91dGlsL21pZGRsZXdhcmVSZWR1Y2VyJyk7XG52YXIgcHJvY2Vzc09wdGlvbnMgPSByZXF1aXJlKCcuL21pZGRsZXdhcmUvZGVmYXVsdE9wdGlvbnNQcm9jZXNzb3InKTtcbnZhciB2YWxpZGF0ZU9wdGlvbnMgPSByZXF1aXJlKCcuL21pZGRsZXdhcmUvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3InKTtcbnZhciBodHRwUmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpOyAvLyBub2RlLXJlcXVlc3QgaW4gbm9kZSwgYnJvd3Nlci1yZXF1ZXN0IGluIGJyb3dzZXJzXG5cbnZhciBjaGFubmVsTmFtZXMgPSBbJ3JlcXVlc3QnLCAncmVzcG9uc2UnLCAncHJvZ3Jlc3MnLCAnZXJyb3InLCAnYWJvcnQnXTtcbnZhciBtaWRkbGVob29rcyA9IFsncHJvY2Vzc09wdGlvbnMnLCAndmFsaWRhdGVPcHRpb25zJywgJ2ludGVyY2VwdFJlcXVlc3QnLCAnZmluYWxpemVPcHRpb25zJywgJ29uUmVxdWVzdCcsICdvblJlc3BvbnNlJywgJ29uRXJyb3InLCAnb25SZXR1cm4nLCAnb25IZWFkZXJzJ107XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlUmVxdWVzdGVyKCkge1xuICB2YXIgaW5pdE1pZGRsZXdhcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gIHZhciBsb2FkZWRNaWRkbGV3YXJlID0gW107XG4gIHZhciBtaWRkbGV3YXJlID0gbWlkZGxlaG9va3MucmVkdWNlKGZ1bmN0aW9uICh3YXJlLCBuYW1lKSB7XG4gICAgd2FyZVtuYW1lXSA9IHdhcmVbbmFtZV0gfHwgW107XG4gICAgcmV0dXJuIHdhcmU7XG4gIH0sIHtcbiAgICBwcm9jZXNzT3B0aW9uczogW3Byb2Nlc3NPcHRpb25zXSxcbiAgICB2YWxpZGF0ZU9wdGlvbnM6IFt2YWxpZGF0ZU9wdGlvbnNdXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlcXVlc3Qob3B0cykge1xuICAgIHZhciBjaGFubmVscyA9IGNoYW5uZWxOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHRhcmdldCwgbmFtZSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gcHVic3ViKCk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sIHt9KTtcblxuICAgIC8vIFByZXBhcmUgYSBtaWRkbGV3YXJlIHJlZHVjZXIgdGhhdCBjYW4gYmUgcmV1c2VkIHRocm91Z2hvdXQgdGhlIGxpZmVjeWNsZVxuICAgIHZhciBhcHBseU1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlUmVkdWNlcihtaWRkbGV3YXJlKTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXNzZWQgb3B0aW9uc1xuICAgIHZhciBvcHRpb25zID0gYXBwbHlNaWRkbGV3YXJlKCdwcm9jZXNzT3B0aW9ucycsIG9wdHMpO1xuXG4gICAgLy8gVmFsaWRhdGUgdGhlIG9wdGlvbnNcbiAgICBhcHBseU1pZGRsZXdhcmUoJ3ZhbGlkYXRlT3B0aW9ucycsIG9wdGlvbnMpO1xuXG4gICAgLy8gQnVpbGQgYSBjb250ZXh0IG9iamVjdCB3ZSBjYW4gcGFzcyB0byBjaGlsZCBoYW5kbGVyc1xuICAgIHZhciBjb250ZXh0ID0geyBvcHRpb25zOiBvcHRpb25zLCBjaGFubmVsczogY2hhbm5lbHMsIGFwcGx5TWlkZGxld2FyZTogYXBwbHlNaWRkbGV3YXJlXG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gaG9sZCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCwgb25nb2luZyByZXF1ZXN0LFxuICAgICAgLy8gaW4gb3JkZXIgdG8gYWxsb3cgY2FuY2VsbGF0aW9uLiBJbiB0aGUgY2FzZSBvZiB0aGUgcmV0cnkgbWlkZGxld2FyZSxcbiAgICAgIC8vIGEgbmV3IHJlcXVlc3QgbWlnaHQgYmUgdHJpZ2dlcmVkXG4gICAgfTt2YXIgb25nb2luZ1JlcXVlc3QgPSBudWxsO1xuICAgIHZhciB1bnN1YnNjcmliZSA9IGNoYW5uZWxzLnJlcXVlc3Quc3Vic2NyaWJlKGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIC8vIExldCByZXF1ZXN0IGFkYXB0ZXJzIChub2RlL2Jyb3dzZXIpIHBlcmZvcm0gdGhlIGFjdHVhbCByZXF1ZXN0XG4gICAgICBvbmdvaW5nUmVxdWVzdCA9IGh0dHBSZXF1ZXN0KGN0eCwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIHJldHVybiBvblJlc3BvbnNlKGVyciwgcmVzLCBjdHgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiB3ZSBhYm9ydCB0aGUgcmVxdWVzdCwgcHJldmVudCBmdXJ0aGVyIHJlcXVlc3RzIGZyb20gaGFwcGVuaW5nLFxuICAgIC8vIGFuZCBiZSBzdXJlIHRvIGNhbmNlbCBhbnkgb25nb2luZyByZXF1ZXN0IChvYnZpb3VzbHkpXG4gICAgY2hhbm5lbHMuYWJvcnQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob25nb2luZ1JlcXVlc3QpIHtcbiAgICAgICAgb25nb2luZ1JlcXVlc3QuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNlZSBpZiBhbnkgbWlkZGxld2FyZSB3YW50cyB0byBtb2RpZnkgdGhlIHJldHVybiB2YWx1ZSAtIGZvciBpbnN0YW5jZVxuICAgIC8vIHRoZSBwcm9taXNlIG9yIG9ic2VydmFibGUgbWlkZGxld2FyZXNcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBhcHBseU1pZGRsZXdhcmUoJ29uUmV0dXJuJywgY2hhbm5lbHMsIGNvbnRleHQpO1xuXG4gICAgLy8gSWYgcmV0dXJuIHZhbHVlIGhhcyBiZWVuIG1vZGlmaWVkIGJ5IGEgbWlkZGxld2FyZSwgd2UgZXhwZWN0IHRoZSBtaWRkbGV3YXJlXG4gICAgLy8gdG8gcHVibGlzaCBvbiB0aGUgJ3JlcXVlc3QnIGNoYW5uZWwuIElmIGl0IGhhc24ndCBiZWVuIG1vZGlmaWVkLCB3ZSB3YW50IHRvXG4gICAgLy8gdHJpZ2dlciBpdCByaWdodCBhd2F5XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcblxuICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2UocmVxRXJyLCByZXMsIGN0eCkge1xuICAgICAgdmFyIGVycm9yID0gcmVxRXJyO1xuICAgICAgdmFyIHJlc3BvbnNlID0gcmVzO1xuXG4gICAgICAvLyBXZSdyZSBwcm9jZXNzaW5nIG5vbi1lcnJvcnMgZmlyc3QsIGluIGNhc2UgYSBtaWRkbGV3YXJlIGNvbnZlcnRzIHRoZVxuICAgICAgLy8gcmVzcG9uc2UgaW50byBhbiBlcnJvciAoZm9yIGluc3RhbmNlLCBzdGF0dXMgPj0gNDAwID09IEh0dHBFcnJvcilcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IGFwcGx5TWlkZGxld2FyZSgnb25SZXNwb25zZScsIHJlcywgY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGVycm9yIG1pZGRsZXdhcmUgLSBpZiBtaWRkbGV3YXJlIHJldHVybiB0aGUgc2FtZSAob3IgYSBkaWZmZXJlbnQpIGVycm9yLFxuICAgICAgLy8gcHVibGlzaCBhcyBhbiBlcnJvciBldmVudC4gSWYgd2UgKmRvbid0KiByZXR1cm4gYW4gZXJyb3IsIGFzc3VtZSBpdCBoYXMgYmVlbiBoYW5kbGVkXG4gICAgICBlcnJvciA9IGVycm9yICYmIGFwcGx5TWlkZGxld2FyZSgnb25FcnJvcicsIGVycm9yLCBjdHgpO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBwdWJsaXNoIG9uIGVycm9yL3Jlc3BvbnNlIGNoYW5uZWxzXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hhbm5lbHMuZXJyb3IucHVibGlzaChlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnB1Ymxpc2gocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3QudXNlID0gZnVuY3Rpb24gdXNlKG5ld01pZGRsZXdhcmUpIHtcbiAgICBpZiAoIW5ld01pZGRsZXdhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCByZXNvbHZlZCB0byBmYWxzZXkgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld01pZGRsZXdhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCB3YXMgYSBmdW5jdGlvbi4gSXQgcHJvYmFibHkgZXhwZWN0cyB5b3UgdG8gcGFzcyBvcHRpb25zIHRvIGl0LicpO1xuICAgIH1cblxuICAgIGlmIChuZXdNaWRkbGV3YXJlLm9uUmV0dXJuICYmIG1pZGRsZXdhcmUub25SZXR1cm4ubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBhZGQgbmV3IG1pZGRsZXdhcmUgd2l0aCBgb25SZXR1cm5gIGhhbmRsZXIsIGJ1dCBhbm90aGVyIGhhbmRsZXIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50Jyk7XG4gICAgfVxuXG4gICAgbWlkZGxlaG9va3MuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAobmV3TWlkZGxld2FyZVtrZXldKSB7XG4gICAgICAgIG1pZGRsZXdhcmVba2V5XS5wdXNoKG5ld01pZGRsZXdhcmVba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsb2FkZWRNaWRkbGV3YXJlLnB1c2gobmV3TWlkZGxld2FyZSk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH07XG5cbiAgcmVxdWVzdC5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0ZXIobG9hZGVkTWlkZGxld2FyZSk7XG4gIH07XG5cbiAgaW5pdE1pZGRsZXdhcmUuZm9yRWFjaChyZXF1ZXN0LnVzZSk7XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIHVybFBhcnNlID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG5cbnZhciBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHsgdGltZW91dDogaXNSZWFjdE5hdGl2ZSA/IDYwMDAwIDogMTIwMDAwIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycgPyBvYmplY3RBc3NpZ24oeyB1cmw6IG9wdHMgfSwgZGVmYXVsdE9wdGlvbnMpIDogb2JqZWN0QXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0cyk7XG5cbiAgLy8gUGFyc2UgVVJMIGludG8gcGFydHNcbiAgdmFyIHVybCA9IHVybFBhcnNlKG9wdGlvbnMudXJsLCB7fSwgLy8gRG9uJ3QgdXNlIGN1cnJlbnQgYnJvd3NlciBsb2NhdGlvblxuICB0cnVlIC8vIFBhcnNlIHF1ZXJ5IHN0cmluZ3NcbiAgKTtcblxuICAvLyBOb3JtYWxpemUgdGltZW91dHNcbiAgb3B0aW9ucy50aW1lb3V0ID0gbm9ybWFsaXplVGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuXG4gIC8vIFNoYWxsb3ctbWVyZ2UgKG92ZXJyaWRlKSBleGlzdGluZyBxdWVyeSBwYXJhbXNcbiAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICB1cmwucXVlcnkgPSBvYmplY3RBc3NpZ24oe30sIHVybC5xdWVyeSwgcmVtb3ZlVW5kZWZpbmVkKG9wdGlvbnMucXVlcnkpKTtcbiAgfVxuXG4gIC8vIEltcGxpY2l0IFBPU1QgaWYgd2UgaGF2ZSBub3Qgc3BlY2lmaWVkIGEgbWV0aG9kIGJ1dCBoYXZlIGEgYm9keVxuICBvcHRpb25zLm1ldGhvZCA9IG9wdGlvbnMuYm9keSAmJiAhb3B0aW9ucy5tZXRob2QgPyAnUE9TVCcgOiAob3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgLy8gU3RyaW5naWZ5IFVSTFxuICBvcHRpb25zLnVybCA9IHVybC50b1N0cmluZyhzdHJpbmdpZnlRdWVyeVN0cmluZyk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeVN0cmluZyhvYmopIHtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwdXNoKGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwYWlycy5qb2luKCcmJykgOiAnJztcblxuICBmdW5jdGlvbiBwdXNoKGtleSwgdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHB1c2goa2V5LCBpdGVtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbF0ubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbignPScpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVGltZW91dCh0aW1lKSB7XG4gIGlmICh0aW1lID09PSBmYWxzZSB8fCB0aW1lID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRpbWUuY29ubmVjdCB8fCB0aW1lLnNvY2tldCkge1xuICAgIHJldHVybiB0aW1lO1xuICB9XG5cbiAgdmFyIGRlbGF5ID0gTnVtYmVyKHRpbWUpO1xuICBpZiAoaXNOYU4oZGVsYXkpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVRpbWVvdXQoZGVmYXVsdE9wdGlvbnMudGltZW91dCk7XG4gIH1cblxuICByZXR1cm4geyBjb25uZWN0OiBkZWxheSwgc29ja2V0OiBkZWxheSB9O1xufVxuXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWQob2JqKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdE9wdGlvbnNQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXFwiXCIgKyBvcHRpb25zLnVybCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBVUkxcIik7XG4gIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG5cbnZhciBzZXJpYWxpemVUeXBlcyA9IFsnYm9vbGVhbicsICdzdHJpbmcnLCAnbnVtYmVyJ107XG52YXIgaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1N0cmVhbSA9IHR5cGVvZiBib2R5LnBpcGUgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkU2VyaWFsaXplID0gIWlzU3RyZWFtICYmICFpc0J1ZmZlcihib2R5KSAmJiAoc2VyaWFsaXplVHlwZXMuaW5kZXhPZih0eXBlb2YgYm9keSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYm9keSkpICE9PSAtMSB8fCBBcnJheS5pc0FycmF5KGJvZHkpIHx8IGlzUGxhaW5PYmplY3QoYm9keSkpO1xuXG4gICAgICBpZiAoIXNob3VsZFNlcmlhbGl6ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdEFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiBvYmplY3RBc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uUmVxdWVzdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiBmdW5jdGlvbiBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgICAgIHZhciBzaG91bGREZWNvZGUgPSBvcHRzICYmIG9wdHMuZm9yY2UgfHwgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpICE9PSAtMTtcbiAgICAgIGlmICghcmVzcG9uc2UuYm9keSB8fCAhY29udGVudFR5cGUgfHwgIXNob3VsZERlY29kZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3RBc3NpZ24oe30sIHJlc3BvbnNlLCB7IGJvZHk6IHRyeVBhcnNlKHJlc3BvbnNlLmJvZHkpIH0pO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzT3B0aW9uczogZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9iamVjdEFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBoZWFkZXJzOiBvYmplY3RBc3NpZ24oeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCBvcHRpb25zLmhlYWRlcnMpXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiB0cnlQYXJzZShib2R5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gJ0ZhaWxlZCB0byBwYXJzZWQgcmVzcG9uc2UgYm9keSBhcyBKU09OOiAnICsgZXJyLm1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uUmVzcG9uc2UuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vdXRpbC9nbG9iYWwnKTtcbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIE9ic2VydmFibGUgPSBvcHRzLmltcGxlbWVudGF0aW9uIHx8IGdsb2JhbC5PYnNlcnZhYmxlO1xuICBpZiAoIU9ic2VydmFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BPYnNlcnZhYmxlYCBpcyBub3QgYXZhaWxhYmxlIGluIGdsb2JhbCBzY29wZSwgYW5kIG5vIGltcGxlbWVudGF0aW9uIHdhcyBwYXNzZWQnKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25SZXR1cm46IGZ1bmN0aW9uIG9uUmV0dXJuKGNoYW5uZWxzLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFubmVscy5wcm9ncmVzcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQob2JqZWN0QXNzaWduKHsgdHlwZTogJ3Byb2dyZXNzJyB9LCBldmVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hhbm5lbHMucmVzcG9uc2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQob2JqZWN0QXNzaWduKHsgdHlwZTogJ3Jlc3BvbnNlJyB9LCByZXNwb25zZSkpO1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2hhbm5lbHMuYWJvcnQucHVibGlzaCgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlcXVlc3Q6IGZ1bmN0aW9uIG9uUmVxdWVzdChldnQpIHtcbiAgICAgIGlmIChldnQuYWRhcHRlciAhPT0gJ3hocicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gZXZ0LnJlcXVlc3Q7XG4gICAgICB2YXIgY29udGV4dCA9IGV2dC5jb250ZXh0O1xuXG4gICAgICBpZiAoJ3VwbG9hZCcgaW4geGhyICYmICdvbnByb2dyZXNzJyBpbiB4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzKCd1cGxvYWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdvbnByb2dyZXNzJyBpbiB4aHIpIHtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcygnZG93bmxvYWQnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3Moc3RhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHZhciBwZXJjZW50ID0gZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA/IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsICogMTAwIDogLTE7XG4gICAgICAgICAgY29udGV4dC5jaGFubmVscy5wcm9ncmVzcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHN0YWdlOiBzdGFnZSxcbiAgICAgICAgICAgIHBlcmNlbnQ6IHBlcmNlbnQsXG4gICAgICAgICAgICB0b3RhbDogZXZlbnQudG90YWwsXG4gICAgICAgICAgICBsb2FkZWQ6IGV2ZW50LmxvYWRlZCxcbiAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IGV2ZW50Lmxlbmd0aENvbXB1dGFibGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci1wcm9ncmVzcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLXByb2dyZXNzJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBtYXgtZGVwdGg6IFtcImVycm9yXCIsIDRdICovXG52YXIgc2FtZU9yaWdpbiA9IHJlcXVpcmUoJ3NhbWUtb3JpZ2luJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgncGFyc2UtaGVhZGVycycpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge1xuICAvKiBpbnRlbnRpb25hbCBub29wICovXG59O1xuXG52YXIgd2luID0gd2luZG93O1xudmFyIFhtbEh0dHBSZXF1ZXN0ID0gd2luLlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3A7XG52YXIgaGFzWGhyMiA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYbWxIdHRwUmVxdWVzdCgpO1xudmFyIFhEb21haW5SZXF1ZXN0ID0gaGFzWGhyMiA/IFhtbEh0dHBSZXF1ZXN0IDogd2luLlhEb21haW5SZXF1ZXN0O1xudmFyIGFkYXB0ZXIgPSAneGhyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCwgY2FsbGJhY2spIHtcbiAgdmFyIG9wdHMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoJ2ZpbmFsaXplT3B0aW9ucycsIG9wdHMpO1xuICB2YXIgdGltZXJzID0ge307XG5cbiAgLy8gRGVlcC1jaGVja2luZyB3aW5kb3cubG9jYXRpb24gYmVjYXVzZSBvZiByZWFjdCBuYXRpdmUsIHdoZXJlIGBsb2NhdGlvbmAgZG9lc24ndCBleGlzdFxuICB2YXIgY29ycyA9IHdpbiAmJiB3aW4ubG9jYXRpb24gJiYgIXNhbWVPcmlnaW4od2luLmxvY2F0aW9uLmhyZWYsIG9wdGlvbnMudXJsKTtcblxuICAvLyBBbGxvdyBtaWRkbGV3YXJlIHRvIGluamVjdCBhIHJlc3BvbnNlLCBmb3IgaW5zdGFuY2UgaW4gdGhlIGNhc2Ugb2YgY2FjaGluZyBvciBtb2NraW5nXG4gIHZhciBpbmplY3RlZFJlc3BvbnNlID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoJ2ludGVyY2VwdFJlcXVlc3QnLCB1bmRlZmluZWQsIHtcbiAgICBhZGFwdGVyOiBhZGFwdGVyLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgLy8gSWYgbWlkZGxld2FyZSBpbmplY3RlZCBhIHJlc3BvbnNlLCB0cmVhdCBpdCBhcyB3ZSBub3JtYWxseSB3b3VsZCBhbmQgcmV0dXJuIGl0XG4gIC8vIERvIG5vdGUgdGhhdCB0aGUgaW5qZWN0ZWQgcmVzcG9uc2UgaGFzIHRvIGJlIHJlZHVjZWQgdG8gYSBjcm9zcy1lbnZpcm9ubWVudCBmcmllbmRseSByZXNwb25zZVxuICBpZiAoaW5qZWN0ZWRSZXNwb25zZSkge1xuICAgIHZhciBjYlRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgMCwgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZSk7XG4gICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQoY2JUaW1lcik7XG4gICAgfTtcbiAgICByZXR1cm4geyBhYm9ydDogY2FuY2VsIH07XG4gIH1cblxuICAvLyBXZSdsbCB3YW50IHRvIG51bGwgb3V0IHRoZSByZXF1ZXN0IG9uIHN1Y2Nlc3MvZmFpbHVyZVxuICB2YXIgeGhyID0gY29ycyA/IG5ldyBYRG9tYWluUmVxdWVzdCgpIDogbmV3IFhtbEh0dHBSZXF1ZXN0KCk7XG5cbiAgdmFyIGlzWGRyID0gd2luLlhEb21haW5SZXF1ZXN0ICYmIHhociBpbnN0YW5jZW9mIHdpbi5YRG9tYWluUmVxdWVzdDtcbiAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG5cbiAgLy8gUmVxdWVzdCBzdGF0ZVxuICB2YXIgYWJvcnRlZCA9IGZhbHNlO1xuICB2YXIgbG9hZGVkID0gZmFsc2U7XG4gIHZhciB0aW1lZE91dCA9IGZhbHNlO1xuXG4gIC8vIEFwcGx5IGV2ZW50IGhhbmRsZXJzXG4gIHhoci5vbmVycm9yID0gb25FcnJvcjtcbiAgeGhyLm9udGltZW91dCA9IG9uRXJyb3I7XG4gIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9O1xuXG4gIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb25cbiAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaW50ZW50aW9uYWwgbm9vcCAqL1xuICB9O1xuXG4gIHZhciBsb2FkRXZlbnQgPSBpc1hkciA/ICdvbmxvYWQnIDogJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gIHhocltsb2FkRXZlbnRdID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFByZXZlbnQgcmVxdWVzdCBmcm9tIHRpbWluZyBvdXRcbiAgICByZXNldFRpbWVycygpO1xuXG4gICAgaWYgKGFib3J0ZWQgfHwgeGhyLnJlYWR5U3RhdGUgIT09IDQgJiYgIWlzWGRyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2lsbCBiZSBoYW5kbGVkIGJ5IG9uRXJyb3JcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uTG9hZCgpO1xuICB9O1xuXG4gIC8vIEB0b2RvIHR3byBsYXN0IG9wdGlvbnMgdG8gb3BlbigpIGlzIHVzZXJuYW1lL3Bhc3N3b3JkXG4gIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCwgdHJ1ZSAvLyBBbHdheXMgYXN5bmNcbiAgKTtcblxuICAvLyBTb21lIG9wdGlvbnMgbmVlZCB0byBiZSBhcHBsaWVkIGFmdGVyIG9wZW5cbiAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgLy8gU2V0IGhlYWRlcnNcbiAgaWYgKGhlYWRlcnMgJiYgeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGVhZGVycykge1xuICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgaXNYZHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3QnKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJhd0JvZHkpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIC8vIExldCBtaWRkbGV3YXJlIGtub3cgd2UncmUgYWJvdXQgdG8gZG8gYSByZXF1ZXN0XG4gIGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKCdvblJlcXVlc3QnLCB7IG9wdGlvbnM6IG9wdGlvbnMsIGFkYXB0ZXI6IGFkYXB0ZXIsIHJlcXVlc3Q6IHhociwgY29udGV4dDogY29udGV4dCB9KTtcblxuICB4aHIuc2VuZChvcHRpb25zLmJvZHkgfHwgbnVsbCk7XG5cbiAgLy8gRmlndXJlIG91dCB3aGljaCB0aW1lb3V0cyB0byB1c2UgKGlmIGFueSlcbiAgdmFyIGRlbGF5cyA9IG9wdGlvbnMudGltZW91dDtcbiAgaWYgKGRlbGF5cykge1xuICAgIHRpbWVycy5jb25uZWN0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGltZW91dFJlcXVlc3QoJ0VUSU1FRE9VVCcpO1xuICAgIH0sIGRlbGF5cy5jb25uZWN0KTtcbiAgfVxuXG4gIHJldHVybiB7IGFib3J0OiBhYm9ydCB9O1xuXG4gIGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHhocikge1xuICAgICAgeGhyLmFib3J0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGltZW91dFJlcXVlc3QoY29kZSkge1xuICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoY29kZSA9PT0gJ0VTT0NLRVRUSU1FRE9VVCcgPyAnU29ja2V0IHRpbWVkIG91dCBvbiByZXF1ZXN0IHRvICcgKyBvcHRpb25zLnVybCA6ICdDb25uZWN0aW9uIHRpbWVkIG91dCBvbiByZXF1ZXN0IHRvICcgKyBvcHRpb25zLnVybCk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgY29udGV4dC5jaGFubmVscy5lcnJvci5wdWJsaXNoKGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VGltZXJzKCkge1xuICAgIGlmICghZGVsYXlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RvcFRpbWVycygpO1xuICAgIHRpbWVycy5zb2NrZXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aW1lb3V0UmVxdWVzdCgnRVNPQ0tFVFRJTUVET1VUJyk7XG4gICAgfSwgZGVsYXlzLnNvY2tldCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wVGltZXJzKCkge1xuICAgIC8vIE9ubHkgY2xlYXIgdGhlIGNvbm5lY3QgdGltZW91dCBpZiB3ZSd2ZSBnb3QgYSBjb25uZWN0aW9uXG4gICAgaWYgKGFib3J0ZWQgfHwgeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiB0aW1lcnMuY29ubmVjdCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVycy5jb25uZWN0KTtcbiAgICB9XG5cbiAgICBpZiAodGltZXJzLnNvY2tldCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVycy5zb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG4gICAgaWYgKGxvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwXG4gICAgc3RvcFRpbWVycygpO1xuICAgIGxvYWRlZCA9IHRydWU7XG4gICAgeGhyID0gbnVsbDtcblxuICAgIC8vIEFubm95aW5nbHksIGRldGFpbHMgYXJlIGV4dHJlbWVseSBzY2FyY2UgYW5kIGhpZGRlbiBmcm9tIHVzLlxuICAgIC8vIFdlIG9ubHkgcmVhbGx5IGtub3cgdGhhdCBpdCBpcyBhIG5ldHdvcmsgZXJyb3JcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gcmVhY2ggJyArIG9wdGlvbnMudXJsKTtcbiAgICBlcnIuaXNOZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgIGVyci5yZXF1ZXN0ID0gb3B0aW9ucztcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVkdWNlUmVzcG9uc2UoKSB7XG4gICAgdmFyIHN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzO1xuICAgIHZhciBzdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1c1RleHQ7XG5cbiAgICBpZiAoaXNYZHIgJiYgc3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJRTggQ09SUyBHRVQgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMgZmllbGQsIGJ1dCBib2R5IGlzIGZpbmVcbiAgICAgIHN0YXR1c0NvZGUgPSAyMDA7XG4gICAgfSBlbHNlIGlmIChzdGF0dXNDb2RlID4gMTIwMDAgJiYgc3RhdHVzQ29kZSA8IDEyMTU2KSB7XG4gICAgICAvLyBZZXQgYW5vdGhlciBJRSBxdWlyayB3aGVyZSBpdCBlbWl0cyB3ZWlyZCBzdGF0dXMgY29kZXMgb24gbmV0d29yayBlcnJvcnNcbiAgICAgIC8vIGh0dHBzOi8vc3VwcG9ydC5taWNyb3NvZnQuY29tL2VuLXVzL2tiLzE5MzYyNVxuICAgICAgcmV0dXJuIG9uRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQW5vdGhlciBJRSBidWcgd2hlcmUgSFRUUCAyMDQgc29tZWhvdyBlbmRzIHVwIGFzIDEyMjNcbiAgICAgIHN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cztcbiAgICAgIHN0YXR1c01lc3NhZ2UgPSB4aHIuc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogc3RhdHVzTWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYm9keTogeGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQsXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGlzWGRyID8ge30gOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSxcbiAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsXG4gICAgICBzdGF0dXNNZXNzYWdlOiBzdGF0dXNNZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICBpZiAoYWJvcnRlZCB8fCBsb2FkZWQgfHwgdGltZWRPdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgb25FcnJvcihuZXcgRXJyb3IoJ1Vua25vd24gWEhSIGVycm9yJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgYmVpbmcgY2FsbGVkIHR3aWNlXG4gICAgc3RvcFRpbWVycygpO1xuICAgIGxvYWRlZCA9IHRydWU7XG4gICAgY2FsbGJhY2sobnVsbCwgcmVkdWNlUmVzcG9uc2UoKSk7XG4gIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXJlcXVlc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS1yZXF1ZXN0Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5lZ2F0ZWQtY29uZGl0aW9uICovXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgdmFyIGFwcGx5TWlkZGxld2FyZSA9IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZShob29rLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBiYWlsRWFybHkgPSBob29rID09PSAnb25FcnJvcic7XG5cbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaWRkbGV3YXJlW2hvb2tdLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG1pZGRsZXdhcmVbaG9va11baV07XG4gICAgICB2YWx1ZSA9IGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBbdmFsdWVdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgIGlmIChiYWlsRWFybHkgJiYgIXZhbHVlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gYXBwbHlNaWRkbGV3YXJlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pZGRsZXdhcmVSZWR1Y2VyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG52YXIgR2VuZXJhdG9yRnVuY3Rpb24gPSBnZXRQcm90byAmJiBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byAmJiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHZhciB0eXBlID0gdHlwZW9mIHg7XG5cdHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG4iLCIvKiFcbiAqIGlzLXBsYWluLW9iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcGxhaW4tb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0T2JqZWN0KG8pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG8pID09PSB0cnVlXG4gICAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgdmFyIGN0b3IscHJvdDtcblxuICBpZiAoaXNPYmplY3RPYmplY3QobykgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAodHlwZW9mIGN0b3IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBoYXMgbW9kaWZpZWQgcHJvdG90eXBlXG4gIHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgaWYgKGlzT2JqZWN0T2JqZWN0KHByb3QpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGNvbnN0cnVjdG9yIGRvZXMgbm90IGhhdmUgYW4gT2JqZWN0LXNwZWNpZmljIG1ldGhvZFxuICBpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1vc3QgbGlrZWx5IGEgcGxhaW4gT2JqZWN0XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IGhhc1N5bWJvbHMgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ2xvYmFsW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikpIHtcblx0XHRcdHRocm93IG5ldyBFdmFsRXJyb3IoJ3RoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCAnICsgdHlwZWRBcnJheSArICcgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy4nKTtcblx0XHR9XG5cdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0fVxuXHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0cmV0dXJuICRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTE7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIi8qIVxuICogaXNvYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHZhbCkgPT09IGZhbHNlO1xufTtcbiIsIi8vIElTQyBAIEp1bGllbiBGb250YW5ldFxuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgY29uc3RydWN0ID0gdHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgPyBSZWZsZWN0LmNvbnN0cnVjdCA6IHVuZGVmaW5lZDtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcbmlmIChjYXB0dXJlU3RhY2tUcmFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gIGNhcHR1cmVTdGFja1RyYWNlID0gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IpIHtcbiAgICB2YXIgY29udGFpbmVyID0gbmV3IEVycm9yKCk7XG5cbiAgICBkZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJzdGFja1wiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldFN0YWNrKCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBjb250YWluZXIuc3RhY2s7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBwcm9wZXJ0eSB3aXRoIHZhbHVlIGZvciBmYXN0ZXIgZnV0dXJlIGFjY2Vzc2VzLlxuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHN0YWNrLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXRTdGFjayhzdGFjaykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBzdGFjayxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEJhc2VFcnJvcihtZXNzYWdlKSB7XG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG1lc3NhZ2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBjbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKGNuYW1lICE9PSB1bmRlZmluZWQgJiYgY25hbWUgIT09IHRoaXMubmFtZSkge1xuICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogY25hbWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xufVxuXG5CYXNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vSnNDb21tdW5pdHkvbWFrZS1lcnJvci9pc3N1ZXMvNFxuICBjb25zdHJ1Y3Rvcjoge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogQmFzZUVycm9yLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICB9LFxufSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gU2V0cyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGlmIHBvc3NpYmxlIChkZXBlbmRzIG9mIHRoZSBKUyBlbmdpbmUpLlxudmFyIHNldEZ1bmN0aW9uTmFtZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2V0RnVuY3Rpb25OYW1lKGZuLCBuYW1lKSB7XG4gICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZuLCBcIm5hbWVcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZiA9IGZ1bmN0aW9uKCkge307XG4gICAgc2V0RnVuY3Rpb25OYW1lKGYsIFwiZm9vXCIpO1xuICAgIGlmIChmLm5hbWUgPT09IFwiZm9vXCIpIHtcbiAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWU7XG4gICAgfVxuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBtYWtlRXJyb3IoY29uc3RydWN0b3IsIHN1cGVyXykge1xuICBpZiAoc3VwZXJfID09IG51bGwgfHwgc3VwZXJfID09PSBFcnJvcikge1xuICAgIHN1cGVyXyA9IEJhc2VFcnJvcjtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3VwZXJfICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic3VwZXJfIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgdmFyIG5hbWU7XG4gIGlmICh0eXBlb2YgY29uc3RydWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBuYW1lID0gY29uc3RydWN0b3I7XG4gICAgY29uc3RydWN0b3IgPVxuICAgICAgY29uc3RydWN0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Qoc3VwZXJfLCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN1cGVyXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAvLyBJZiB0aGUgbmFtZSBjYW4gYmUgc2V0LCBkbyBpdCBvbmNlIGFuZCBmb3IgYWxsLlxuICAgIGlmIChzZXRGdW5jdGlvbk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0RnVuY3Rpb25OYW1lKGNvbnN0cnVjdG9yLCBuYW1lKTtcbiAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbnN0cnVjdG9yIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIEFsc28gcmVnaXN0ZXIgdGhlIHN1cGVyIGNvbnN0cnVjdG9yIGFsc28gYXMgYGNvbnN0cnVjdG9yLnN1cGVyX2AganVzdFxuICAvLyBsaWtlIE5vZGUncyBgdXRpbC5pbmhlcml0cygpYC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRvdC1ub3RhdGlvblxuICBjb25zdHJ1Y3Rvci5zdXBlcl8gPSBjb25zdHJ1Y3RvcltcInN1cGVyXCJdID0gc3VwZXJfO1xuXG4gIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogY29uc3RydWN0b3IsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9LFxuICB9O1xuXG4gIC8vIElmIHRoZSBuYW1lIGNvdWxkIG5vdCBiZSBzZXQgb24gdGhlIGNvbnN0cnVjdG9yLCBzZXQgaXQgb24gdGhlXG4gIC8vIHByb3RvdHlwZS5cbiAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHByb3BlcnRpZXMubmFtZSA9IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyXy5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn1cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG1ha2VFcnJvcjtcbmV4cG9ydHMuQmFzZUVycm9yID0gQmFzZUVycm9yO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBQdWJzdWIoKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IFtdXG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgcHVibGlzaDogcHVibGlzaFxuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpYmVyKVxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIHZhciBpZHggPSBzdWJzY3JpYmVycy5pbmRleE9mKHN1YnNjcmliZXIpXG4gICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGlkeCwgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHVibGlzaCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdWJzY3JpYmVyc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuXHRcdHJldHVybiAxIC8gYSA9PT0gMSAvIGI7XG5cdH1cblx0aWYgKGEgPT09IGIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAobnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYikpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE9iamVjdCk7XG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0dmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcbiIsInZhciB0cmltID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuICAsIGlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiB7fVxuXG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIHZhciBoZWFkZXJzQXJyID0gdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm93ID0gaGVhZGVyc0FycltpXVxuICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCB1bmRlZjtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5jb2RlIGEgZ2l2ZW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8jJl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgY2FzZSBpZiBmYWlsZWQgZGVjb2RpbmcsIHdlIHdhbnQgdG8gb21pdCB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgLy8gZnJvbSB0aGUgcmVzdWx0LlxuICAgIC8vXG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdXG4gICAgLCB2YWx1ZVxuICAgICwga2V5O1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIC8vXG4gICAgICAvLyBFZGdlIGNhc2VzIHdoZXJlIHdlIGFjdHVhbGx5IHdhbnQgdG8gZW5jb2RlIHRoZSB2YWx1ZSB0byBhbiBlbXB0eVxuICAgICAgLy8gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIGlmICghdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZiB8fCBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGVuY29kZShrZXkpO1xuICAgICAgdmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcGFpcnMucHVzaChrZXkgKyc9JysgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhblJlcG9ydEVycm9yXzEgPSByZXF1aXJlKFwiLi91dGlsL2NhblJlcG9ydEVycm9yXCIpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4vdXRpbC90b1N1YnNjcmliZXJcIik7XG52YXIgb2JzZXJ2YWJsZV8xID0gcmVxdWlyZShcIi4vc3ltYm9sL29ic2VydmFibGVcIik7XG52YXIgcGlwZV8xID0gcmVxdWlyZShcIi4vdXRpbC9waXBlXCIpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgdmFyIHNpbmsgPSB0b1N1YnNjcmliZXJfMS50b1N1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgICAgc2luay5hZGQob3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzLnNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luay5hZGQodGhpcy5zb3VyY2UgfHwgKGNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nICYmICFzaW5rLnN5bmNFcnJvclRocm93YWJsZSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShzaW5rKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5U3Vic2NyaWJlKHNpbmspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHNpbmsuc3luY0Vycm9yVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHNpbmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChjb25maWdfMS5jb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhblJlcG9ydEVycm9yXzEuY2FuUmVwb3J0RXJyb3Ioc2luaykpIHtcbiAgICAgICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBwcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwcm9taXNlQ3RvciA9IGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZV8xLnBpcGVGcm9tQXJyYXkob3BlcmF0aW9ucykodGhpcyk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS50b1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcHJvbWlzZUN0b3IgPSBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcik7XG4gICAgICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB2YWx1ZSA9IHg7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbmZ1bmN0aW9uIGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKSB7XG4gICAgaWYgKCFwcm9taXNlQ3Rvcikge1xuICAgICAgICBwcm9taXNlQ3RvciA9IGNvbmZpZ18xLmNvbmZpZy5Qcm9taXNlIHx8IFByb21pc2U7XG4gICAgfVxuICAgIGlmICghcHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2VDdG9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25maWdfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbnZhciBob3N0UmVwb3J0RXJyb3JfMSA9IHJlcXVpcmUoXCIuL3V0aWwvaG9zdFJlcG9ydEVycm9yXCIpO1xuZXhwb3J0cy5lbXB0eSA9IHtcbiAgICBjbG9zZWQ6IHRydWUsXG4gICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7IH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3N0UmVwb3J0RXJyb3JfMS5ob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlsL2lzRnVuY3Rpb25cIik7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL09ic2VydmVyXCIpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uXCIpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4uL2ludGVybmFsL3N5bWJvbC9yeFN1YnNjcmliZXJcIik7XG52YXIgY29uZmlnXzEgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG52YXIgaG9zdFJlcG9ydEVycm9yXzEgPSByZXF1aXJlKFwiLi91dGlsL2hvc3RSZXBvcnRFcnJvclwiKTtcbnZhciBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck5leHQgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBkZXN0aW5hdGlvbk9yTmV4dC5zeW5jRXJyb3JUaHJvd2FibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25Pck5leHQuYWRkKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcihfdGhpcywgZGVzdGluYXRpb25Pck5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcihfdGhpcywgZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRPclBhcmVudHMgPSB0aGlzLl9wYXJlbnRPclBhcmVudHM7XG4gICAgICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50T3JQYXJlbnRzID0gX3BhcmVudE9yUGFyZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gX3RoaXM7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICAgICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlck9yTmV4dCAhPT0gT2JzZXJ2ZXJfMS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG9ic2VydmVyT3JOZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkKGNvbnRleHQudW5zdWJzY3JpYmUuYmluZChjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSBfdGhpcy51bnN1YnNjcmliZS5iaW5kKF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIF90aGlzLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgX3RoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIF90aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQgJiYgdGhpcy5fbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICghY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHZhciB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nID0gY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmc7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcl8xLmhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBob3N0UmVwb3J0RXJyb3JfMS5ob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZENvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NvbXBsZXRlLmNhbGwoX3RoaXMuX2NvbnRleHQpOyB9O1xuICAgICAgICAgICAgICAgIGlmICghY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih3cmFwcGVkQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgd3JhcHBlZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JVbnN1YiA9IGZ1bmN0aW9uIChmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGlmIChjb25maWdfMS5jb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcl8xLmhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgICAgIGlmICghY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwnKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlcG9ydEVycm9yXzEuaG9zdFJlcG9ydEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG5leHBvcnRzLlNhZmVTdWJzY3JpYmVyID0gU2FmZVN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoXCIuL3V0aWwvaXNBcnJheVwiKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZShcIi4vdXRpbC9pc09iamVjdFwiKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlsL2lzRnVuY3Rpb25cIik7XG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gcmVxdWlyZShcIi4vdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yXCIpO1xudmFyIFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0b3JVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnRPclBhcmVudHMgPSBfYS5fcGFyZW50T3JQYXJlbnRzLCBfY3RvclVuc3Vic2NyaWJlID0gX2EuX2N0b3JVbnN1YnNjcmliZSwgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAoX3BhcmVudE9yUGFyZW50cyBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgX3BhcmVudE9yUGFyZW50cy5yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9wYXJlbnRPclBhcmVudHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gX3BhcmVudE9yUGFyZW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgcGFyZW50XzEucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICBpZiAoX2N0b3JVbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yID8gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGUuZXJyb3JzKSA6IFtlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfc3Vic2NyaXB0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0XzEuaXNPYmplY3Qoc3ViKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlLmVycm9ycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0ZWFyZG93bjtcbiAgICAgICAgaWYgKCF0ZWFyZG93bikge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB0aGlzIHx8IHN1YnNjcmlwdGlvbi5jbG9zZWQgfHwgdHlwZW9mIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIShzdWJzY3JpcHRpb24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLl9zdWJzY3JpcHRpb25zID0gW3RtcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHRlYXJkb3duICcgKyB0ZWFyZG93biArICcgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfcGFyZW50T3JQYXJlbnRzID0gc3Vic2NyaXB0aW9uLl9wYXJlbnRPclBhcmVudHM7XG4gICAgICAgIGlmIChfcGFyZW50T3JQYXJlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uX3BhcmVudE9yUGFyZW50cyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cyBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaWYgKF9wYXJlbnRPclBhcmVudHMgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLl9wYXJlbnRPclBhcmVudHMgPSBbX3BhcmVudE9yUGFyZW50cywgdGhpc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICAgICAgICAgICAgX3BhcmVudE9yUGFyZW50cy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW3N1YnNjcmlwdGlvbl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25JbmRleCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbkluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLkVNUFRZID0gKGZ1bmN0aW9uIChlbXB0eSkge1xuICAgICAgICBlbXB0eS5jbG9zZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfShuZXcgU3Vic2NyaXB0aW9uKCkpKTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBlcnIpIHsgcmV0dXJuIGVycnMuY29uY2F0KChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikgPyBlcnIuZXJyb3JzIDogZXJyKTsgfSwgW10pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9lbmFibGVfc3VwZXJfZ3Jvc3NfbW9kZV90aGF0X3dpbGxfY2F1c2VfYmFkX3RoaW5ncyA9IGZhbHNlO1xuZXhwb3J0cy5jb25maWcgPSB7XG4gICAgUHJvbWlzZTogdW5kZWZpbmVkLFxuICAgIHNldCB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FURUQhIFJ4SlMgd2FzIHNldCB0byB1c2UgZGVwcmVjYXRlZCBzeW5jaHJvbm91cyBlcnJvciBoYW5kbGluZyBiZWhhdmlvciBieSBjb2RlIGF0OiBcXG4nICsgZXJyb3Iuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9lbmFibGVfc3VwZXJfZ3Jvc3NfbW9kZV90aGF0X3dpbGxfY2F1c2VfYmFkX3RoaW5ncykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1J4SlM6IEJhY2sgdG8gYSBiZXR0ZXIgZXJyb3IgYmVoYXZpb3IuIFRoYW5rIHlvdS4gPDMnKTtcbiAgICAgICAgfVxuICAgICAgICBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3MgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKCkge1xuICAgICAgICByZXR1cm4gX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoXCIuLi9PYnNlcnZhYmxlXCIpO1xuZXhwb3J0cy5FTVBUWSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KTtcbmZ1bmN0aW9uIGVtcHR5KHNjaGVkdWxlcikge1xuICAgIHJldHVybiBzY2hlZHVsZXIgPyBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIDogZXhwb3J0cy5FTVBUWTtcbn1cbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbmZ1bmN0aW9uIGVtcHR5U2NoZWR1bGVkKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHsgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0pOyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi4vU3Vic2NyaWJlclwiKTtcbmZ1bmN0aW9uIGRlZmF1bHRJZkVtcHR5KGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VmFsdWUgPSBudWxsOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yKGRlZmF1bHRWYWx1ZSkpOyB9O1xufVxuZXhwb3J0cy5kZWZhdWx0SWZFbXB0eSA9IGRlZmF1bHRJZkVtcHR5O1xudmFyIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlPcGVyYXRvcjtcbn0oKSk7XG52YXIgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIF90aGlzLmlzRW1wdHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdElmRW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoXCIuLi9TdWJzY3JpYmVyXCIpO1xuZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiBmaWx0ZXJPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykpO1xuICAgIH07XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbnZhciBGaWx0ZXJPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBGaWx0ZXJPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbHRlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlck9wZXJhdG9yO1xufSgpKTtcbnZhciBGaWx0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgX3RoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaWx0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4uL1N1YnNjcmliZXJcIik7XG5mdW5jdGlvbiBtYXAocHJvamVjdCwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiBtYXBPcGVyYXRpb24oc291cmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24uIEFyZSB5b3UgbG9va2luZyBmb3IgYG1hcFRvKClgPycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykpO1xuICAgIH07XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbnZhciBNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1hcE9wZXJhdG9yID0gTWFwT3BlcmF0b3I7XG52YXIgTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgX3RoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2Nhbl8xID0gcmVxdWlyZShcIi4vc2NhblwiKTtcbnZhciB0YWtlTGFzdF8xID0gcmVxdWlyZShcIi4vdGFrZUxhc3RcIik7XG52YXIgZGVmYXVsdElmRW1wdHlfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRJZkVtcHR5XCIpO1xudmFyIHBpcGVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL3BpcGVcIik7XG5mdW5jdGlvbiByZWR1Y2UoYWNjdW11bGF0b3IsIHNlZWQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWR1Y2VPcGVyYXRvckZ1bmN0aW9uV2l0aFNlZWQoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGlwZV8xLnBpcGUoc2Nhbl8xLnNjYW4oYWNjdW11bGF0b3IsIHNlZWQpLCB0YWtlTGFzdF8xLnRha2VMYXN0KDEpLCBkZWZhdWx0SWZFbXB0eV8xLmRlZmF1bHRJZkVtcHR5KHNlZWQpKShzb3VyY2UpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gcmVkdWNlT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVfMS5waXBlKHNjYW5fMS5zY2FuKGZ1bmN0aW9uIChhY2MsIHZhbHVlLCBpbmRleCkgeyByZXR1cm4gYWNjdW11bGF0b3IoYWNjLCB2YWx1ZSwgaW5kZXggKyAxKTsgfSksIHRha2VMYXN0XzEudGFrZUxhc3QoMSkpKHNvdXJjZSk7XG4gICAgfTtcbn1cbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi4vU3Vic2NyaWJlclwiKTtcbmZ1bmN0aW9uIHNjYW4oYWNjdW11bGF0b3IsIHNlZWQpIHtcbiAgICB2YXIgaGFzU2VlZCA9IGZhbHNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgaGFzU2VlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBzY2FuT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTY2FuT3BlcmF0b3IoYWNjdW11bGF0b3IsIHNlZWQsIGhhc1NlZWQpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5zY2FuID0gc2NhbjtcbnZhciBTY2FuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjYW5PcGVyYXRvcihhY2N1bXVsYXRvciwgc2VlZCwgaGFzU2VlZCkge1xuICAgICAgICBpZiAoaGFzU2VlZCA9PT0gdm9pZCAwKSB7IGhhc1NlZWQgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMuaGFzU2VlZCA9IGhhc1NlZWQ7XG4gICAgfVxuICAgIFNjYW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNjYW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYWNjdW11bGF0b3IsIHRoaXMuc2VlZCwgdGhpcy5oYXNTZWVkKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nhbk9wZXJhdG9yO1xufSgpKTtcbnZhciBTY2FuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhY2N1bXVsYXRvciwgX3NlZWQsIGhhc1NlZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIF90aGlzLl9zZWVkID0gX3NlZWQ7XG4gICAgICAgIF90aGlzLmhhc1NlZWQgPSBoYXNTZWVkO1xuICAgICAgICBfdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZSwgXCJzZWVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzU2VlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zZWVkID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2VlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWVkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyeU5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hY2N1bXVsYXRvcih0aGlzLnNlZWQsIHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlZCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2NhblN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi4vU3Vic2NyaWJlclwiKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZShcIi4uL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JcIik7XG52YXIgZW1wdHlfMSA9IHJlcXVpcmUoXCIuLi9vYnNlcnZhYmxlL2VtcHR5XCIpO1xuZnVuY3Rpb24gdGFrZUxhc3QoY291bnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGFrZUxhc3RPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eV8xLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRha2VMYXN0T3BlcmF0b3IoY291bnQpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLnRha2VMYXN0ID0gdGFrZUxhc3Q7XG52YXIgVGFrZUxhc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGFrZUxhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VMYXN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnRvdGFsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZUxhc3RPcGVyYXRvcjtcbn0oKSk7XG52YXIgVGFrZUxhc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZUxhc3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdG90YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIF90aGlzLnJpbmcgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgX3RoaXMuY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRha2VMYXN0U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJpbmcgPSB0aGlzLnJpbmc7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQrKztcbiAgICAgICAgaWYgKHJpbmcubGVuZ3RoIDwgdG90YWwpIHtcbiAgICAgICAgICAgIHJpbmcucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjb3VudCAlIHRvdGFsO1xuICAgICAgICAgICAgcmluZ1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFrZUxhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHRoaXMuY291bnQgPj0gdGhpcy50b3RhbCA/IHRoaXMudG90YWwgOiB0aGlzLmNvdW50O1xuICAgICAgICAgICAgdmFyIHJpbmcgPSB0aGlzLnJpbmc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gKGNvdW50KyspICUgdG90YWw7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyaW5nW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZUxhc3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZUxhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCAnQEBvYnNlcnZhYmxlJzsgfSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJ4U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBTeW1ib2woJ3J4U3Vic2NyaWJlcicpXG4gICAgICAgIDogJ0BAcnhTdWJzY3JpYmVyXycgKyBNYXRoLnJhbmRvbSgpO1xufSkoKTtcbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSBleHBvcnRzLnJ4U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbCgpIHtcbiAgICAgICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJ2FyZ3VtZW50IG91dCBvZiByYW5nZSc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBcmd1bWVudE91dE9mUmFuZ2VFcnJvcic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIHJldHVybiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGw7XG59KSgpO1xuZXhwb3J0cy5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbChlcnJvcnMpIHtcbiAgICAgICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JzID9cbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcblwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiBpICsgMSArIFwiKSBcIiArIGVyci50b1N0cmluZygpOyB9KS5qb2luKCdcXG4gICcpIDogJyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsO1xufSkoKTtcbmV4cG9ydHMuVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi4vU3Vic2NyaWJlclwiKTtcbmZ1bmN0aW9uIGNhblJlcG9ydEVycm9yKG9ic2VydmVyKSB7XG4gICAgd2hpbGUgKG9ic2VydmVyKSB7XG4gICAgICAgIHZhciBfYSA9IG9ic2VydmVyLCBjbG9zZWRfMSA9IF9hLmNsb3NlZCwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbiwgaXNTdG9wcGVkID0gX2EuaXNTdG9wcGVkO1xuICAgICAgICBpZiAoY2xvc2VkXzEgfHwgaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24gaW5zdGFuY2VvZiBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2FuUmVwb3J0RXJyb3IgPSBjYW5SZXBvcnRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhblJlcG9ydEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaG9zdFJlcG9ydEVycm9yKGVycikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH0sIDApO1xufVxuZXhwb3J0cy5ob3N0UmVwb3J0RXJyb3IgPSBob3N0UmVwb3J0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3N0UmVwb3J0RXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGVudGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNBcnJheSA9IChmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTsgfSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc09iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpZGVudGl0eV8xID0gcmVxdWlyZShcIi4vaWRlbnRpdHlcIik7XG5mdW5jdGlvbiBwaXBlKCkge1xuICAgIHZhciBmbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHBpcGVGcm9tQXJyYXkoZm5zKTtcbn1cbmV4cG9ydHMucGlwZSA9IHBpcGU7XG5mdW5jdGlvbiBwaXBlRnJvbUFycmF5KGZucykge1xuICAgIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eV8xLmlkZW50aXR5O1xuICAgIH1cbiAgICBpZiAoZm5zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZm5zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gcGlwZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGZuKSB7IHJldHVybiBmbihwcmV2KTsgfSwgaW5wdXQpO1xuICAgIH07XG59XG5leHBvcnRzLnBpcGVGcm9tQXJyYXkgPSBwaXBlRnJvbUFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi4vU3Vic2NyaWJlclwiKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoXCIuLi9zeW1ib2wvcnhTdWJzY3JpYmVyXCIpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKFwiLi4vT2JzZXJ2ZXJcIik7XG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIGlmIChuZXh0T3JPYnNlcnZlcikge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbmV4dE9yT2JzZXJ2ZXIgJiYgIWVycm9yICYmICFjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKE9ic2VydmVyXzEuZW1wdHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuZXhwb3J0cy50b1N1YnNjcmliZXIgPSB0b1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1N1YnNjcmliZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJpMSwgdXJpMiwgaWVNb2RlKSB7XG4gICAgaWYgKHVyaTEgPT09IHVyaTIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHVybDEgPSB1cmwucGFyc2UodXJpMSwgZmFsc2UsIHRydWUpO1xuICAgIHZhciB1cmwyID0gdXJsLnBhcnNlKHVyaTIsIGZhbHNlLCB0cnVlKTtcblxuICAgIHZhciB1cmwxUG9ydCA9IHVybDEucG9ydHwwIHx8ICh1cmwxLnByb3RvY29sID09PSAnaHR0cHMnID8gNDQzIDogODApO1xuICAgIHZhciB1cmwyUG9ydCA9IHVybDIucG9ydHwwIHx8ICh1cmwyLnByb3RvY29sID09PSAnaHR0cHMnID8gNDQzIDogODApO1xuXG4gICAgdmFyIG1hdGNoID0ge1xuICAgICAgICBwcm90bzogdXJsMS5wcm90b2NvbCA9PT0gdXJsMi5wcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWU6IHVybDEuaG9zdG5hbWUgPT09IHVybDIuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybDFQb3J0ID09PSB1cmwyUG9ydFxuICAgIH07XG5cbiAgICByZXR1cm4gKChtYXRjaC5wcm90byAmJiBtYXRjaC5ob3N0bmFtZSkgJiYgKG1hdGNoLnBvcnQgfHwgaWVNb2RlKSk7XG59OyIsIi8qKlxuICogVGhpcyBmaWxlIGlzIG9ubHkgdXNlZCBmb3IgdGhlIGJyb3dzZXIgdmVyc2lvbiBvZiBgc2FtZS1vcmlnaW5gLlxuICogVXNlZCB0byBicmluZyBkb3duIHRoZSBzaXplIG9mIHRoZSBicm93c2VyIGJ1bmRsZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXggPSAvXig/Oig/Oig/OihbXjpcXC8jXFw/XSs6KT8oPzooPzpcXC9cXC8pKCg/OigoPzpbXjpAXFwvI1xcP10rKSg/OlxcOig/OlteOkBcXC8jXFw/XSspKT8pQCk/KChbXjpcXC8jXFw/XFxdXFxbXSt8XFxbW15cXC9cXF1AIz9dK1xcXSkoPzpcXDooWzAtOV0rKSk/KSk/KT8pPygoPzpcXC8/KD86W15cXC9cXD8jXStcXC8rKSopKD86W15cXD8jXSopKSk/KFxcP1teI10rKT8pKCMuKik/LztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVnZXg6IHJlZ2V4LFxuICAgIHBhcnNlOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXguZXhlYyh1cmwpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdG9jb2w6IChtYXRjaFsxXSB8fCAnJykudG9Mb3dlckNhc2UoKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBob3N0bmFtZTogKG1hdGNoWzVdIHx8ICcnKS50b0xvd2VyQ2FzZSgpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvcnQ6IG1hdGNoWzZdIHx8IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbn07IiwiaW1wb3J0IHsgQmlrZVRhZ0NsaWVudCB9IGZyb20gJy4uL2NsaWVudCdcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cydcbmltcG9ydCB7IEJpa2VUYWdBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcydcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRhZyhcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4+IHtcbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofWBcbiAgcmV0dXJuICgoYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwsIG1ldGhvZDogJ0RFTEVURScgfSkpXG4gICAgLmRhdGEgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+XG59XG4iLCJpbXBvcnQgeyBCaWtlVGFnQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50J1xuaW1wb3J0IHsgSU1BR0VfRU5EUE9JTlQgfSBmcm9tICcuLi9jb21tb24vZW5kcG9pbnRzJ1xuaW1wb3J0IHsgQmlrZVRhZ0FwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmF2b3JpdGVJbWFnZShcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8J2Zhdm9yaXRlZCc+PiB7XG4gIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke2ltYWdlSGFzaH0vZmF2b3JpdGVgXG4gIHJldHVybiAoKGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsLCBtZXRob2Q6ICdQT1NUJyB9KSlcbiAgICAuZGF0YSBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8J2Zhdm9yaXRlZCc+XG59XG4iLCJpbXBvcnQgeyBCaWtlVGFnQ2xpZW50IH0gZnJvbSAnLi4vY2xpZW50J1xuaW1wb3J0IHsgSU1BR0VfRU5EUE9JTlQgfSBmcm9tICcuLi9jb21tb24vZW5kcG9pbnRzJ1xuaW1wb3J0IHsgQmlrZVRhZ0FwaVJlc3BvbnNlLCBUYWdEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGFnKFxuICBjbGllbnQ6IEJpa2VUYWdDbGllbnQsXG4gIGltYWdlSGFzaDogc3RyaW5nXG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxUYWdEYXRhPj4ge1xuICBjb25zdCB1cmwgPSBgJHtJTUFHRV9FTkRQT0lOVH0vJHtpbWFnZUhhc2h9YFxuICByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCB9KSlcbiAgICAuZGF0YSBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT5cbn1cbiIsImV4cG9ydCB7IGRlbGV0ZVRhZyB9IGZyb20gJy4vZGVsZXRlVGFnJ1xuZXhwb3J0IHsgZ2V0VGFnIH0gZnJvbSAnLi9nZXRUYWcnXG5leHBvcnQgeyB1cGRhdGVUYWcgfSBmcm9tICcuL3VwZGF0ZVRhZydcbmV4cG9ydCB7IHVwZGF0ZVRhZ0ltYWdlIH0gZnJvbSAnLi91cGRhdGVUYWdJbWFnZSdcbmV4cG9ydCB7IHF1ZXVlVGFnSW1hZ2UgfSBmcm9tICcuL3F1ZXVlVGFnSW1hZ2UnXG5leHBvcnQgeyBmYXZvcml0ZUltYWdlIH0gZnJvbSAnLi9mYXZvcml0ZUltYWdlJ1xuIiwiaW1wb3J0IHsgQmlrZVRhZ0NsaWVudCB9IGZyb20gJy4uL2NsaWVudCdcbmltcG9ydCB7IFBheWxvYWQsIEJpa2VUYWdBcGlSZXNwb25zZSwgVGFnRGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcydcbi8vIGltcG9ydCB7IFVQTE9BRF9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcXVldWVUYWdJbWFnZShcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBwYXlsb2FkOiBzdHJpbmcgfCBzdHJpbmdbXSB8IFBheWxvYWQgfCBQYXlsb2FkW11cbik6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+W10+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHBheWxvYWQubWFwKChwOiBzdHJpbmcgfCBQYXlsb2FkKSA9PiB7XG4gICAgICAvLyBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgICAgIC8vIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KFVQTE9BRF9FTkRQT0lOVCwge1xuICAgICAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIC8vICAgYm9keTogZm9ybSxcbiAgICAgIC8vICAgcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAgICAgLy8gfSk7XG5cbiAgICAgIC8vIGNvbnN0IGlkID0gO1xuICAgICAgLy8gcmVxLm9uKCd1cGxvYWRQcm9ncmVzcycsIChwcm9ncmVzczogUHJvZ3Jlc3MpID0+IHtcbiAgICAgIC8vICAgY2xpZW50LmVtaXQoJ3VwbG9hZFByb2dyZXNzJywgeyAuLi5wcm9ncmVzcywgaWQgfSk7XG4gICAgICAvLyB9KTtcblxuICAgICAgcmV0dXJuIChwIGFzIHVua25vd24pIGFzIFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+PlxuICAgIH0pXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICB9XG5cbiAgLy8gY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocGF5bG9hZCk7XG4gIC8vIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KFVQTE9BRF9FTkRQT0lOVCwge1xuICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAvLyAgIGJvZHk6IGZvcm0sXG4gIC8vICAgcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAvLyB9KTtcblxuICAvLyByZXEub24oJ3VwbG9hZFByb2dyZXNzJywgKHByb2dyZXNzOiBQcm9ncmVzcykgPT4ge1xuICAvLyAgIGNsaWVudC5lbWl0KCd1cGxvYWRQcm9ncmVzcycsIHsgLi4ucHJvZ3Jlc3MsIGlkIH0pO1xuICAvLyB9KTtcblxuICByZXR1cm4gKGNsaWVudCBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT5cbn1cbiIsImltcG9ydCB7IEJpa2VUYWdDbGllbnQgfSBmcm9tICcuLi9jbGllbnQnXG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnXG5pbXBvcnQgeyBQYXlsb2FkLCBCaWtlVGFnQXBpUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlVGFnUGF5bG9hZFxuICBleHRlbmRzIFBpY2s8UGF5bG9hZCwgJ3RpdGxlJyB8ICdkZXNjcmlwdGlvbic+IHtcbiAgc2x1Zzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRVcGRhdGVQYXlsb2FkKHA6IFVwZGF0ZVRhZ1BheWxvYWQpIHtcbiAgcmV0dXJuIHR5cGVvZiBwLnRpdGxlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcC5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZydcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRhZyhcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBwYXlsb2FkOiBVcGRhdGVUYWdQYXlsb2FkXG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gIC8vICAgY29uc3QgcHJvbWlzZXMgPSBwYXlsb2FkLm1hcCgocDogVXBkYXRlVGFnUGF5bG9hZCkgPT4ge1xuICAvLyAgICAgaWYgKCFpc1ZhbGlkVXBkYXRlUGF5bG9hZChwKSkge1xuICAvLyAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpO1xuICAvLyAgICAgfVxuXG4gIC8vICAgICBjb25zdCB1cmwgPSBgJHtJTUFHRV9FTkRQT0lOVH0vJHtwLmltYWdlSGFzaH1gO1xuICAvLyAgICAgY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocCk7XG4gIC8vICAgICByZXR1cm4gKGNsaWVudC5yZXF1ZXN0KHVybCwge1xuICAvLyAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgLy8gICAgICAgYm9keTogZm9ybSxcbiAgLy8gICAgICAgcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAvLyAgICAgfSkgYXMgdW5rbm93bikgYXMgUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4+O1xuICAvLyAgIH0pO1xuXG4gIC8vICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgLy8gfVxuXG4gIGlmICghaXNWYWxpZFVwZGF0ZVBheWxvYWQocGF5bG9hZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpXG4gIH1cblxuICBjb25zdCB1cmwgPSBgJHtJTUFHRV9FTkRQT0lOVH0vJHtwYXlsb2FkLnNsdWd9YFxuICByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnREVMRVRFJyB9KSlcbiAgICAuZGF0YSBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5cbn1cbiIsImltcG9ydCB7IEJpa2VUYWdDbGllbnQgfSBmcm9tICcuLi9jbGllbnQnXG5pbXBvcnQgeyBJTUFHRV9FTkRQT0lOVCB9IGZyb20gJy4uL2NvbW1vbi9lbmRwb2ludHMnXG5pbXBvcnQgeyBQYXlsb2FkLCBCaWtlVGFnQXBpUmVzcG9uc2UgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlVGFnSW1hZ2VQYXlsb2FkXG4gIGV4dGVuZHMgUGljazxQYXlsb2FkLCAndGl0bGUnIHwgJ2Rlc2NyaXB0aW9uJz4ge1xuICBzbHVnOiBzdHJpbmdcbn1cblxuLy8gZnVuY3Rpb24gaXNWYWxpZFVwZGF0ZVBheWxvYWQocDogVXBkYXRlVGFnSW1hZ2VQYXlsb2FkKSB7XG4vLyAgIHJldHVybiB0eXBlb2YgcC50aXRsZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHAuZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnO1xuLy8gfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVGFnSW1hZ2UoXG4gIGNsaWVudDogQmlrZVRhZ0NsaWVudCxcbiAgcGF5bG9hZDogVXBkYXRlVGFnSW1hZ2VQYXlsb2FkXG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gIC8vICAgY29uc3QgcHJvbWlzZXMgPSBwYXlsb2FkLm1hcCgocDogVXBkYXRlVGFnSW1hZ2VQYXlsb2FkKSA9PiB7XG4gIC8vICAgICBpZiAoIWlzVmFsaWRVcGRhdGVQYXlsb2FkKHApKSB7XG4gIC8vICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIHJlcXVpcmVzIGEgdGl0bGUgYW5kL29yIGRlc2NyaXB0aW9uJyk7XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIGNvbnN0IHVybCA9IGAke0lNQUdFX0VORFBPSU5UfS8ke3AuaW1hZ2VIYXNofWA7XG4gIC8vICAgICBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgLy8gICAgIHJldHVybiAoY2xpZW50LnJlcXVlc3QodXJsLCB7XG4gIC8vICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAvLyAgICAgICBib2R5OiBmb3JtLFxuICAvLyAgICAgICByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gIC8vICAgICB9KSBhcyB1bmtub3duKSBhcyBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPj47XG4gIC8vICAgfSk7XG5cbiAgLy8gICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAvLyB9XG5cbiAgLy8gaWYgKCFpc1ZhbGlkVXBkYXRlUGF5bG9hZChwYXlsb2FkKSkge1xuICAvLyAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIHJlcXVpcmVzIGEgdGl0bGUgYW5kL29yIGRlc2NyaXB0aW9uJyk7XG4gIC8vIH1cblxuICBjb25zdCB1cmwgPSBgJHtJTUFHRV9FTkRQT0lOVH0vJHtwYXlsb2FkLnNsdWd9YFxuICByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnREVMRVRFJyB9KSlcbiAgICAuZGF0YSBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5cblxuICAvLyAvLyBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwYXlsb2FkKTtcbiAgLy8gcmV0dXJuICgoYXdhaXQgY2xpZW50LnJlcXVlc3QodXJsLCB7XG4gIC8vICAgbWV0aG9kOiAnUE9TVCcsXG4gIC8vICAgYm9keTogZm9ybSxcbiAgLy8gICByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gIC8vIH0pKSBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj47XG59XG4iLCJpbXBvcnQgYXhpb3MsIHsgQXhpb3NJbnN0YW5jZSwgQXhpb3NSZXNwb25zZSwgQXhpb3NSZXF1ZXN0Q29uZmlnIH0gZnJvbSAnYXhpb3MnXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnXG4vLyBpbXBvcnQgeyBnZXRBdXRob3JpemF0aW9uSGVhZGVyIH0gZnJvbSAnLi9nZXRBdXRob3JpemF0aW9uSGVhZGVyJ1xuaW1wb3J0IHsgQklLRVRBR19BUElfUFJFRklYIH0gZnJvbSAnLi9jb21tb24vZW5kcG9pbnRzJ1xuaW1wb3J0IHtcbiAgQ3JlZGVudGlhbHMsXG4gIFRhZ0RhdGEsXG4gIEJpa2VUYWdBcGlSZXNwb25zZSxcbiAgSW1ndXJDcmVkZW50aWFscyxcbiAgQmlrZVRhZ0NyZWRlbnRpYWxzLFxufSBmcm9tICcuL2NvbW1vbi90eXBlcydcbmltcG9ydCB7IHRhZ0RhdGFGaWVsZHMgfSBmcm9tICcuL2NvbW1vbi9kYXRhJ1xuaW1wb3J0IHtcbiAgY29uc3RydWN0VGFnTnVtYmVyU2x1ZyxcbiAgYXNzaWduSW1ndXJDcmVkZW50aWFscyxcbiAgYXNzaWduU2FuaXR5Q3JlZGVudGlhbHMsXG4gIGFzc2lnbkJpa2VUYWdDcmVkZW50aWFscyxcbiAgaXNJbWd1ckNyZWRlbnRpYWxzLFxuICBpc1Nhbml0eUNyZWRlbnRpYWxzLFxuICBpc0Jpa2VUYWdDcmVkZW50aWFscyxcbn0gZnJvbSAnLi9jb21tb24vbWV0aG9kcydcbmltcG9ydCB7IHNldHVwIH0gZnJvbSAnYXhpb3MtY2FjaGUtYWRhcHRlcidcblxuaW1wb3J0ICogYXMgc2FuaXR5QXBpIGZyb20gJy4vc2FuaXR5J1xuaW1wb3J0ICogYXMgaW1ndXJBcGkgZnJvbSAnLi9pbWd1cidcbmltcG9ydCAqIGFzIGJpa2V0YWdBcGkgZnJvbSAnLi9iaWtldGFnJ1xuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4vaW1ndXJDbGllbnQnXG5pbXBvcnQgc2FuaXR5Q2xpZW50LCB7XG4gIFNhbml0eUNsaWVudCxcbiAgQ2xpZW50Q29uZmlnIGFzIFNhbml0eUNvbmZpZyxcbn0gZnJvbSAnQHNhbml0eS9jbGllbnQnXG5cbmNvbnN0IFVTRVJBR0VOVCA9ICdiaWtldGFnLWFwaSAoaHR0cHM6Ly9naXRodWIuY29tL2tlbmV1Y2tlci9iaWtldGFnLWFwaSknXG5cbmV4cG9ydCBjbGFzcyBCaWtlVGFnQ2xpZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBmZXRjaGVyOiBBeGlvc0luc3RhbmNlXG4gIHByaXZhdGUgcGxhaW5GZXRjaGVyOiBBeGlvc0luc3RhbmNlXG4gIHByaXZhdGUgY2FjaGVkRmV0Y2hlcjogQXhpb3NJbnN0YW5jZVxuICBwcml2YXRlIG1vc3RBdmFpbGFibGVBcGk6IHN0cmluZ1xuICBwcml2YXRlIGltZ3VyQ2xpZW50PzogdHlwZW9mIEltZ3VyQ2xpZW50XG4gIHByaXZhdGUgc2FuaXR5Q2xpZW50PzogU2FuaXR5Q2xpZW50XG4gIHByaXZhdGUgc2FuaXR5Q29uZmlnPzogU2FuaXR5Q29uZmlnIHwgdm9pZFxuICBwcml2YXRlIGltZ3VyQ29uZmlnPzogSW1ndXJDcmVkZW50aWFscyB8IHZvaWRcbiAgcHJpdmF0ZSBiaWtldGFnQ29uZmlnPzogQmlrZVRhZ0NyZWRlbnRpYWxzIHwgdm9pZFxuXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNyZWRlbnRpYWxzOiBDcmVkZW50aWFscykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMubW9zdEF2YWlsYWJsZUFwaSA9ICcnXG4gICAgdGhpcy5iaWtldGFnQ29uZmlnID0gYXNzaWduQmlrZVRhZ0NyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKVxuICAgIHRoaXMuaW1ndXJDb25maWcgPSBhc3NpZ25JbWd1ckNyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKVxuICAgIHRoaXMuc2FuaXR5Q29uZmlnID0gYXNzaWduU2FuaXR5Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpXG5cbiAgICBpZiAodGhpcy5pbWd1ckNvbmZpZykge1xuICAgICAgdGhpcy5pbWd1ckNsaWVudCA9IG5ldyBJbWd1ckNsaWVudCh0aGlzLmltZ3VyQ29uZmlnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNhbml0eUNvbmZpZykge1xuICAgICAgdGhpcy5zYW5pdHlDbGllbnQgPSBzYW5pdHlDbGllbnQodGhpcy5zYW5pdHlDb25maWcpXG4gICAgfVxuXG4gICAgLy8vIENvbmZpZ3VyZSBzZXBhcmF0ZSBmZXRjaGluZyBzdHJhdGVnaWVzOiBwbGFpbiwgYXV0aGVkIChkZWZhdWx0KSwgY2FjaGVkIChhdXRoZWQpXG4gICAgdGhpcy5wbGFpbkZldGNoZXIgPSBheGlvcy5jcmVhdGUoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAndXNlci1hZ2VudCc6IFVTRVJBR0VOVCxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9KVxuXG4gICAgdGhpcy5mZXRjaGVyID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IEJJS0VUQUdfQVBJX1BSRUZJWCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ3VzZXItYWdlbnQnOiBVU0VSQUdFTlQsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcblxuICAgIHRoaXMuY2FjaGVkRmV0Y2hlciA9IHNldHVwKHtcbiAgICAgIGJhc2VVUkw6IEJJS0VUQUdfQVBJX1BSRUZJWCxcbiAgICAgIGNhY2hlOiB7XG4gICAgICAgIG1heEFnZTogMTUgKiA2MCAqIDEwMDAsXG4gICAgICAgIGV4Y2x1ZGU6IHtcbiAgICAgICAgICAvLyBPbmx5IGV4Y2x1ZGUgUFVULCBQQVRDSCBhbmQgREVMRVRFIG1ldGhvZHMgZnJvbSBjYWNoZVxuICAgICAgICAgIG1ldGhvZHM6IFsncHV0JywgJ3BhdGNoJywgJ2RlbGV0ZSddLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ3VzZXItYWdlbnQnOiBVU0VSQUdFTlQsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdEFQSShvcHRpb25zOiBhbnkpOiBhbnkge1xuICAgIGNvbnN0IGF2YWlsYWJsZUFQSSA9IG9wdGlvbnMuZm9yY2VBUElcbiAgICAgID8gb3B0aW9ucy5mb3JjZUFQSVxuICAgICAgOiB0aGlzLmdldE1vc3RBdmFpbGFibGVBUEkoKVxuICAgIGxldCBjbGllbnQ6IGFueSA9IG51bGxcbiAgICBsZXQgYXBpOiBhbnkgPSBudWxsXG5cbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnID8geyBzbHVnOiBvcHRpb25zIH0gOiBvcHRpb25zXG4gICAgb3B0aW9ucyA9XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcidcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBzbHVnOiBjb25zdHJ1Y3RUYWdOdW1iZXJTbHVnKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAodGhpcy5jcmVkZW50aWFscyBhcyBCaWtlVGFnQ3JlZGVudGlhbHMpLmdhbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfVxuICAgICAgICA6IG9wdGlvbnNcblxuICAgIG9wdGlvbnMuZ2FtZSA9IG9wdGlvbnMuZ2FtZSA/IG9wdGlvbnMuZ2FtZSA6IHRoaXMuY3JlZGVudGlhbHMuZ2FtZVxuICAgIG9wdGlvbnMuc2x1ZyA9IG9wdGlvbnMuc2x1Z1xuICAgICAgPyBvcHRpb25zLnNsdWdcbiAgICAgIDogY29uc3RydWN0VGFnTnVtYmVyU2x1ZyhvcHRpb25zLnRhZ251bWJlciwgb3B0aW9ucy5nYW1lKVxuICAgIG9wdGlvbnMuZmllbGRzID0gb3B0aW9ucy5maWVsZHMgPyBvcHRpb25zLmZpZWxkcyA6IHRhZ0RhdGFGaWVsZHNcblxuICAgIHN3aXRjaCAoYXZhaWxhYmxlQVBJKSB7XG4gICAgICBjYXNlICdzYW5pdHknOlxuICAgICAgICBjbGllbnQgPSB0aGlzLnNhbml0eUNsaWVudFxuICAgICAgICBhcGkgPSBzYW5pdHlBcGlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2ltZ3VyJzpcbiAgICAgICAgY2xpZW50ID0gdGhpcy5pbWd1ckNsaWVudFxuICAgICAgICBhcGkgPSBpbWd1ckFwaVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgJ2Jpa2V0YWcnOlxuICAgICAgICBjbGllbnQgPSBhcGkgPSBiaWtldGFnQXBpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudCxcbiAgICAgIGFwaSxcbiAgICAgIG9wdGlvbnMsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNb3N0QXZhaWxhYmxlQVBJKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMubW9zdEF2YWlsYWJsZUFwaS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vc3RBdmFpbGFibGVBcGlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaWtldGFnQ29uZmlnICYmIGlzQmlrZVRhZ0NyZWRlbnRpYWxzKHRoaXMuYmlrZXRhZ0NvbmZpZykpIHtcbiAgICAgIHJldHVybiAodGhpcy5tb3N0QXZhaWxhYmxlQXBpID0gJ2Jpa2V0YWcnKVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbWd1ckNvbmZpZykge1xuICAgICAgcmV0dXJuICh0aGlzLm1vc3RBdmFpbGFibGVBcGkgPSAnaW1ndXInKVxuICAgIH0gZWxzZSBpZiAodGhpcy5zYW5pdHlDb25maWcpIHtcbiAgICAgIHJldHVybiAodGhpcy5tb3N0QXZhaWxhYmxlQXBpID0gJ3Nhbml0eScpXG4gICAgfVxuXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBnZXRDb25maWd1cmF0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzYW5pdHk6IHRoaXMuc2FuaXR5Q29uZmlnLFxuICAgICAgaW1ndXI6IHRoaXMuaW1ndXJDb25maWcsXG4gICAgICBiaWtldGFnOiB0aGlzLmJpa2V0YWdDb25maWcsXG4gICAgfVxuICB9XG5cbiAgcGxhaW5SZXF1ZXN0KG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9KTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPGFueT4+IHtcbiAgICByZXR1cm4gdGhpcy5wbGFpbkZldGNoZXIob3B0aW9ucylcbiAgfVxuXG4gIGNhY2hlZFJlcXVlc3Qob3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge30pOiBQcm9taXNlPEF4aW9zUmVzcG9uc2U8YW55Pj4ge1xuICAgIHJldHVybiB0aGlzLmNhY2hlZEZldGNoZXIob3B0aW9ucylcbiAgfVxuXG4gIHJlcXVlc3Qob3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge30pOiBQcm9taXNlPEF4aW9zUmVzcG9uc2U8c3RyaW5nPj4ge1xuICAgIHJldHVybiB0aGlzLmZldGNoZXIob3B0aW9ucylcbiAgfVxuXG4gIC8vIGRlbGV0ZUltYWdlKGltYWdlSGFzaDogc3RyaW5nKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4+IHtcbiAgLy8gICBzd2l0Y2ggKHRoaXMuZ2V0TW9zdEF2YWlsYWJsZUFQSSgpKSB7XG4gIC8vICAgICBjYXNlIFwiaW1ndXJcIjpcbiAgLy8gICAgICAgcmV0dXJuIGltZ3VyLmRlbGV0ZUltYWdlKHRoaXMsIGltYWdlSGFzaClcbiAgLy8gICAgIGJyZWFrXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLy8gLy8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGZvciBnZXR0aW5nIGFuIGFsYnVtXG4gIC8vIGdldEFyY2hpdmUob3B0aW9uczogQXJjaGl2ZU9wdGlvbnMpOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxBcmNoaXZlRGF0YT4+IHtcbiAgLy8gICByZXR1cm4gZ2V0QXJjaGl2ZSh0aGlzLCBvcHRpb25zKVxuICAvLyB9XG5cbiAgZ2V0VGFnKG9wdHM6IG51bWJlciB8IHN0cmluZyB8IGFueSk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+PiB7XG4gICAgY29uc3QgeyBjbGllbnQsIG9wdGlvbnMsIGFwaSB9ID0gdGhpcy5nZXREZWZhdWx0QVBJKG9wdHMpXG5cbiAgICByZXR1cm4gYXBpLmdldFRhZyhjbGllbnQsIG9wdGlvbnMpXG4gIH1cblxuICAvLyB1cGRhdGVJbWFnZShcbiAgLy8gICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuICAvLyApOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vICAgcmV0dXJuIHVwZGF0ZUltYWdlKHRoaXMsIHBheWxvYWQpXG4gIC8vIH1cblxuICAvLyB1cGxvYWQoXG4gIC8vICAgcGF5bG9hZDogc3RyaW5nIHwgc3RyaW5nW10gfCBQYXlsb2FkIHwgUGF5bG9hZFtdXG4gIC8vICk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+W10+IHtcbiAgLy8gICByZXR1cm4gdXBsb2FkKHRoaXMsIHBheWxvYWQpXG4gIC8vIH1cblxuICAvLyBnZXRCaWtlVGFnKFxuICAvLyAgIHBheWxvYWQ6IFVwZGF0ZUltYWdlUGF5bG9hZCB8IFVwZGF0ZUltYWdlUGF5bG9hZFtdXG4gIC8vICk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgLy8gICBzd2l0Y2ggKHRoaXMuZ2V0TW9zdEF2YWlsYWJsZUFQSSgpKSB7XG4gIC8vICAgICBjYXNlIFwiaW1ndXJcIjpcbiAgLy8gICAgICAgcmV0dXJuIGdldEJpa2VUYWcodGhpcywgcGF5bG9hZClcbiAgLy8gICAgICAgYnJlYWtcbiAgLy8gICAgIGNhc2UgXCJzYW5pdHlcIjpcbiAgLy8gICAgICAgcmV0dXJuXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLy8gZ2V0QmlrZVRhZ015c3RlcnlJbWFnZShcbiAgLy8gICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuICAvLyApOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vICAgcmV0dXJuIGdldEJpa2VUYWdNeXN0ZXJ5SW1hZ2UodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIGdldEJpa2VUYWdGb3VuZEltYWdlKFxuICAvLyAgIHBheWxvYWQ6IFVwZGF0ZUltYWdlUGF5bG9hZCB8IFVwZGF0ZUltYWdlUGF5bG9hZFtdXG4gIC8vICk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgLy8gICByZXR1cm4gZ2V0QmlrZVRhZ0ZvdW5kSW1hZ2UodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIHF1ZXVlQmlrZVRhZ0ZvdW5kSW1hZ2UoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBxdWV1ZUJpa2VUYWdGb3VuZEltYWdlKHRoaXMsIHBheWxvYWQpXG4gIC8vIH1cblxuICAvLyBxdWV1ZUJpa2VUYWdNeXN0ZXJ5SW1hZ2UoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBxdWV1ZUJpa2VUYWdNeXN0ZXJ5SW1hZ2UodGhpcywgcGF5bG9hZClcbiAgLy8gfVxuXG4gIC8vIGdldFF1ZXVlZEltYWdlcyhcbiAgLy8gICBwYXlsb2FkOiBVcGRhdGVJbWFnZVBheWxvYWQgfCBVcGRhdGVJbWFnZVBheWxvYWRbXVxuICAvLyApOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vICAgcmV0dXJuIGdldFF1ZXVlZEltYWdlcyh0aGlzLCBwYXlsb2FkKVxuICAvLyB9XG5cbiAgLy8gZ2V0UXVldWUoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBnZXRRdWV1ZSh0aGlzLCBwYXlsb2FkKVxuICAvLyB9XG5cbiAgLy8gY29tcGxldGVCaWtlVGFnUm91bmQoXG4gIC8vICAgcGF5bG9hZDogVXBkYXRlSW1hZ2VQYXlsb2FkIHwgVXBkYXRlSW1hZ2VQYXlsb2FkW11cbiAgLy8gKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5bXT4ge1xuICAvLyAgIHJldHVybiBjb21wbGV0ZUJpa2VUYWdSb3VuZCh0aGlzLCBwYXlsb2FkKVxuICAvLyB9XG5cbiAgLy8gZ2V0QmlrZVRhZ1JvdW5kKFxuICAvLyAgIHBheWxvYWQ6IFVwZGF0ZUltYWdlUGF5bG9hZCB8IFVwZGF0ZUltYWdlUGF5bG9hZFtdXG4gIC8vICk6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+W10+IHtcbiAgLy8gICByZXR1cm4gZ2V0QmlrZVRhZ1JvdW5kKHRoaXMsIHBheWxvYWQpXG4gIC8vIH1cblxuICBjb250ZW50KG9wdGlvbnM6IGFueSA9IHt9KTogU2FuaXR5Q2xpZW50IHtcbiAgICBpZiAoaXNTYW5pdHlDcmVkZW50aWFscyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHNhbml0eUNsaWVudChvcHRpb25zKVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBhcmUgaW52YWxpZCBmb3IgY3JlYXRpbmcgYSBzYW5pdHkgY2xpZW50JylcbiAgfVxuXG4gIGltYWdlcyhvcHRpb25zOiBhbnkgPSB7fSk6IHR5cGVvZiBJbWd1ckNsaWVudCB7XG4gICAgaWYgKGlzSW1ndXJDcmVkZW50aWFscyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbWd1ckNsaWVudChvcHRpb25zKVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBhcmUgaW52YWxpZCBmb3IgY3JlYXRpbmcgYW4gaW1ndXIgY2xpZW50JylcbiAgfVxuXG4gIGRhdGEoKTogQmlrZVRhZ0NsaWVudCB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IHRhZ0RhdGFGaWVsZHMgPSBbXG4gICdzbHVnJyxcbiAgJ3RhZ251bWJlcicsXG4gICdteXN0ZXJ5SW1hZ2UnLFxuICAnbXlzdGVyeUltYWdlVXJsJyxcbiAgJ2dhbWUnLFxuICAncGxheWVyJyxcbiAgJ2hpbnQnLFxuICAnZGlzY3Vzc2lvblVybCcsXG4gICdmb3VuZExvY2F0aW9uJyxcbiAgJ2dwcycsXG4gICdmb3VuZEltYWdlJyxcbiAgJ2ZvdW5kSW1hZ2VVcmwnLFxuXVxuXG5leHBvcnQgY29uc3QgdGFnRGF0YVJlZmVyZW5jZUZpZWxkcyA9IFsnZ2FtZScsICdwbGF5ZXInXVxuIiwiZXhwb3J0IGNvbnN0IEJJS0VUQUdfQVBJX1BSRUZJWCA9ICdodHRwczovL2FwaS5iaWtldGFnLm9yZydcblxuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OID0gJzInXG5cbmV4cG9ydCBjb25zdCBBVVRIT1JJWkVfRU5EUE9JTlQgPSAnb2F1dGgyL2F1dGhvcml6ZSdcblxuZXhwb3J0IGNvbnN0IElNQUdFX0VORFBPSU5UID0gYCR7QVBJX1ZFUlNJT059L2ltYWdlYFxuXG5leHBvcnQgY29uc3QgVEFHX0VORFBPSU5UID0gYCR7QVBJX1ZFUlNJT059L3RhZ2BcblxuZXhwb3J0IGNvbnN0IFVQTE9BRF9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS91cGxvYWRgXG5cbmV4cG9ydCBjb25zdCBBTEJVTV9FTkRQT0lOVCA9IGAke0FQSV9WRVJTSU9OfS9hcmNoaXZlYFxuXG5leHBvcnQgY29uc3QgQ09ORklHX0VORFBPSU5UID0gYCR7QVBJX1ZFUlNJT059L2NvbmZpZ2BcbiIsImltcG9ydCB7XG4gIEFjY2Vzc1Rva2VuLFxuICBDbGllbnRLZXksXG4gIFNhbml0eUFjY2Vzc1Rva2VuLFxuICBJbWd1ckFjY2Vzc1Rva2VuLFxuICBJbWd1ckNsaWVudElkLFxuICBJbWd1ckNyZWRlbnRpYWxzLFxuICBTYW5pdHlDcmVkZW50aWFscyxcbiAgU2FuaXR5Q2xpZW50SWQsXG4gIEJpa2VUYWdDcmVkZW50aWFscyxcbiAgUGF5bG9hZCxcbn0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IHRhZ0RhdGFSZWZlcmVuY2VGaWVsZHMgfSBmcm9tICcuL2RhdGEnXG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnZm9ybS1kYXRhJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCYXNlNjQocGF5bG9hZDogc3RyaW5nIHwgUGF5bG9hZCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHBheWxvYWQuYmFzZTY0ICE9PSAndW5kZWZpbmVkJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbWFnZVVybChwYXlsb2FkOiBzdHJpbmcgfCBQYXlsb2FkKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkLmltYWdlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZydcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyZWFtKHBheWxvYWQ6IHN0cmluZyB8IFBheWxvYWQpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkLnN0cmVhbSAhPT0gJ3VuZGVmaW5lZCdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvcm0ocGF5bG9hZDogc3RyaW5nIHwgUGF5bG9hZCk6IEZvcm1EYXRhIHtcbiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgIGZvcm0uYXBwZW5kKCdpbWFnZScsIHBheWxvYWQpXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBheWxvYWQpKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkVXBsb2FkT2JqZWN0VHlwZXMgPSBbJ2Jhc2U2NCcsICdzdHJlYW0nXVxuICAgIGlmIChzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBpZiAoc3VwcG9ydGVkVXBsb2FkT2JqZWN0VHlwZXMuaW5kZXhPZihwYXlsb2FkLnR5cGUgYXMgc3RyaW5nKSAhPT0gLTEpIHtcbiAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCBwYXlsb2FkKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtLmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQWNjZXNzVG9rZW4oYXJnOiB1bmtub3duKTogYXJnIGlzIEFjY2Vzc1Rva2VuIHtcbiAgcmV0dXJuIChhcmcgYXMgQWNjZXNzVG9rZW4pLmNsaWVudFRva2VuICE9PSB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xpZW50S2V5KGFyZzogdW5rbm93bik6IGFyZyBpcyBDbGllbnRLZXkge1xuICByZXR1cm4gKGFyZyBhcyBDbGllbnRLZXkpLmNsaWVudEtleSAhPT0gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Nhbml0eUFjY2Vzc1Rva2VuKGFyZzogdW5rbm93bik6IGFyZyBpcyBTYW5pdHlBY2Nlc3NUb2tlbiB7XG4gIHJldHVybiAoYXJnIGFzIFNhbml0eUFjY2Vzc1Rva2VuKS5hY2Nlc3NUb2tlbiAhPT0gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Nhbml0eUNsaWVudElkKGFyZzogdW5rbm93bik6IGFyZyBpcyBTYW5pdHlDbGllbnRJZCB7XG4gIHJldHVybiAoYXJnIGFzIFNhbml0eUNsaWVudElkKS5wcm9qZWN0SWQgIT09IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbWd1ckFjY2Vzc1Rva2VuKGFyZzogdW5rbm93bik6IGFyZyBpcyBJbWd1ckFjY2Vzc1Rva2VuIHtcbiAgcmV0dXJuIChhcmcgYXMgSW1ndXJBY2Nlc3NUb2tlbikuYWNjZXNzVG9rZW4gIT09IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbWd1ckNsaWVudElkKGFyZzogdW5rbm93bik6IGFyZyBpcyBJbWd1ckNsaWVudElkIHtcbiAgcmV0dXJuIChhcmcgYXMgSW1ndXJDbGllbnRJZCkuY2xpZW50SWQgIT09IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0VGFnRGF0YU9iamVjdChkYXRhOiBhbnksIGZpZWxkcyA9IFtdKTogYW55IHtcbiAgY29uc3QgdGFnRGF0YSA9IGZpZWxkcy5sZW5ndGhcbiAgICA/IGZpZWxkcy5yZWR1Y2UoKG86IGFueSwgZjogYW55KSA9PiB7XG4gICAgICAgIG9bZl0gPSBkYXRhW2ZdXG4gICAgICAgIHJldHVybiBvXG4gICAgICB9LCB7fSlcbiAgICA6IGRhdGFcblxuICB0YWdEYXRhUmVmZXJlbmNlRmllbGRzLmZvckVhY2goKGYpID0+IHtcbiAgICBpZiAodHlwZW9mIHRhZ0RhdGFbZl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0YWdEYXRhW2ZdID0gdGFnRGF0YVtmXS5uYW1lXG4gICAgfVxuICB9KVxuXG4gIC8vIHRhZ0RhdGEuc2x1ZyA9IHRhZ0RhdGEuc2x1Zz8uY3VycmVudCA/IHRhZ0RhdGEuc2x1Zy5jdXJyZW50IDogdW5kZWZpbmVkIC8vIFVuZGVmaW5lZCB3b3VsZCBiZSBhIHByb2JsZW1cbiAgdGFnRGF0YS5zbHVnID0gdGFnRGF0YS5zbHVnLmN1cnJlbnRcblxuICByZXR1cm4gdGFnRGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0VGFnTnVtYmVyU2x1ZyhudW1iZXI6IG51bWJlciwgZ2FtZSA9ICcnKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2dhbWV9LXRhZy0ke251bWJlcn1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ltZ3VyQ3JlZGVudGlhbHMoY3JlZGVudGlhbHM6IEltZ3VyQ3JlZGVudGlhbHMpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKFxuICAgIGNyZWRlbnRpYWxzLmNsaWVudElkICE9PSB1bmRlZmluZWQgfHwgY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0ICE9PSB1bmRlZmluZWRcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYW5pdHlDcmVkZW50aWFscyhjcmVkZW50aWFsczogU2FuaXR5Q3JlZGVudGlhbHMpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKFxuICAgIGNyZWRlbnRpYWxzLnByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIGNyZWRlbnRpYWxzLmFjY2Vzc1Rva2VuICE9PSB1bmRlZmluZWRcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCaWtlVGFnQ3JlZGVudGlhbHMoY3JlZGVudGlhbHM6IEJpa2VUYWdDcmVkZW50aWFscyk6IGJvb2xlYW4ge1xuICByZXR1cm4gISEoXG4gICAgY3JlZGVudGlhbHMuY2xpZW50VG9rZW4gIT09IHVuZGVmaW5lZCAmJlxuICAgIChjcmVkZW50aWFscyBhcyBDbGllbnRLZXkpLmNsaWVudEtleSAhPT0gdW5kZWZpbmVkXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkltZ3VyQ3JlZGVudGlhbHMoXG4gIGNyZWRlbnRpYWxzOiBJbWd1ckNyZWRlbnRpYWxzXG4pOiBJbWd1ckNyZWRlbnRpYWxzIHtcbiAgY29uc3QgaW1ndXJDcmVkZW50aWFscyA9IGlzSW1ndXJDcmVkZW50aWFscyhjcmVkZW50aWFscyBhcyBJbWd1ckNyZWRlbnRpYWxzKVxuICAgID8ge1xuICAgICAgICBjbGllbnRJZDogY3JlZGVudGlhbHMuY2xpZW50SWQsXG4gICAgICAgIGNsaWVudFNlY3JldDogY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0LFxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkXG5cbiAgcmV0dXJuIGltZ3VyQ3JlZGVudGlhbHMgYXMgSW1ndXJDcmVkZW50aWFsc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduU2FuaXR5Q3JlZGVudGlhbHMoXG4gIGNyZWRlbnRpYWxzOiBTYW5pdHlDcmVkZW50aWFsc1xuKTogU2FuaXR5Q3JlZGVudGlhbHMge1xuICBjb25zdCBzYW5pdHlDcmVkZW50aWFscyA9IGlzU2FuaXR5Q3JlZGVudGlhbHMoXG4gICAgY3JlZGVudGlhbHMgYXMgU2FuaXR5Q3JlZGVudGlhbHNcbiAgKVxuICAgID8ge1xuICAgICAgICBwcm9qZWN0SWQ6IGNyZWRlbnRpYWxzLnByb2plY3RJZCxcbiAgICAgICAgdXNlQ2RuOiBjcmVkZW50aWFscy51c2VDZG4gfHwgdHJ1ZSxcbiAgICAgICAgZGF0YXNldDogY3JlZGVudGlhbHMuZGF0YXNldCB8fCAnZGV2ZWxvcG1lbnQnLFxuICAgICAgICBhY2Nlc3NUb2tlbjogY3JlZGVudGlhbHMuYWNjZXNzVG9rZW4gfHwgJycsXG4gICAgICAgIHBhc3N3b3JkOiBjcmVkZW50aWFscy5wYXNzd29yZCxcbiAgICAgICAgdXNlcm5hbWU6IGNyZWRlbnRpYWxzLnVzZXJuYW1lLFxuICAgICAgICBhcGlWZXJzaW9uOiBjcmVkZW50aWFscy5hcGlWZXJzaW9uIHx8ICcyMDIxLTAzLTI1JyxcbiAgICAgIH1cbiAgICA6IHVuZGVmaW5lZFxuXG4gIHJldHVybiBzYW5pdHlDcmVkZW50aWFscyBhcyBTYW5pdHlDcmVkZW50aWFsc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduQmlrZVRhZ0NyZWRlbnRpYWxzKFxuICBjcmVkZW50aWFsczogQmlrZVRhZ0NyZWRlbnRpYWxzXG4pOiBCaWtlVGFnQ3JlZGVudGlhbHMge1xuICBjb25zdCBiaWtldGFnQ3JlZGVudGlhbHMgPSBpc0Jpa2VUYWdDcmVkZW50aWFscyhcbiAgICBjcmVkZW50aWFscyBhcyBCaWtlVGFnQ3JlZGVudGlhbHNcbiAgKVxuICAgID8gY3JlZGVudGlhbHNcbiAgICA6ICh7IGdhbWU6IGNyZWRlbnRpYWxzLmdhbWUgfSBhcyBCaWtlVGFnQ3JlZGVudGlhbHMpXG5cbiAgcmV0dXJuIGJpa2V0YWdDcmVkZW50aWFsc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1ndXJQaWN0dXJlcygpOiBhbnlbXSB7XG4gIHJldHVybiBbXVxufVxuIiwiaW1wb3J0IHsgQmlrZVRhZ0NsaWVudCB9IGZyb20gJy4uL2NsaWVudCdcbmltcG9ydCB7IElNQUdFX0VORFBPSU5UIH0gZnJvbSAnLi4vY29tbW9uL2VuZHBvaW50cydcbmltcG9ydCB7IEJpa2VUYWdBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcydcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRhZyhcbiAgY2xpZW50OiBCaWtlVGFnQ2xpZW50LFxuICBpbWFnZUhhc2g6IHN0cmluZ1xuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj4+IHtcbiAgY29uc3QgdXJsID0gYCR7SU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofWBcbiAgcmV0dXJuICgoYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmwsIG1ldGhvZDogJ0RFTEVURScgfSkpXG4gICAgLmRhdGEgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+XG5cbiAgLy8gcmV0dXJuIChhd2FpdCBjbGllbnRcbiAgLy8gICAucmVxdWVzdCh1cmwsIHsgbWV0aG9kOiAnREVMRVRFJyB9KVxuICAvLyAgIC5qc29uKCkpIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPjtcbn1cbiIsIi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi9pbWd1ckNsaWVudCdcbmltcG9ydCB7IEJpa2VUYWdBcGlSZXNwb25zZSwgVGFnRGF0YSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcydcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhZyhcbiAgY2xpZW50OiBJbWd1ckNsaWVudCxcbiAgb3B0aW9uczogYW55XG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxUYWdEYXRhPj4ge1xuICAvLy8gVE9ETzogR2V0IHRoZSB0YWcgaW1hZ2UgaGFzaCBmb3IgUmVkZGl0IGZyb20gdGhlIHRhZ251bWJlciBwcm92aWRlZFxuICAvLy8gVE9ETzogR2V0IHRoZSBpbWFnZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0YWdudW1iZXJcbiAgLy8vIFRPRE86IEltcGxlbWVudCBkYXRhIHRyYW5zbGF0aW9uIGZvciBJbWd1ciBpbWFnZSB0byBUYWdEYXRhXG4gIC8vLyBUT0RPOiBXcmFwIHRoZSByZXNwb25zZSBpbiBhIEJpa2VUYWdBcGlSZXNwb25zZVxuXG4gIHJldHVybiAoYXdhaXQgKGNsaWVudC5nZXRJbWFnZShcbiAgICBvcHRpb25zLnNsdWdcbiAgKSBhcyBhbnkpKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT5cbn1cbiIsImV4cG9ydCB7IGRlbGV0ZVRhZyB9IGZyb20gJy4vZGVsZXRlVGFnJ1xuZXhwb3J0IHsgZ2V0VGFnIH0gZnJvbSAnLi9nZXRUYWcnXG5leHBvcnQgeyB1cGRhdGVUYWcgfSBmcm9tICcuL3VwZGF0ZVRhZydcbmV4cG9ydCB7IHVwbG9hZFRhZ0ltYWdlIH0gZnJvbSAnLi91cGxvYWRUYWdJbWFnZSdcbiIsIi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEltZ3VyQ2xpZW50IH0gZnJvbSAnLi9pbWd1ckNsaWVudCdcbmltcG9ydCB7IFBheWxvYWQsIEJpa2VUYWdBcGlSZXNwb25zZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcydcblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVUYWdQYXlsb2FkXG4gIGV4dGVuZHMgUGljazxQYXlsb2FkLCAndGl0bGUnIHwgJ2Rlc2NyaXB0aW9uJz4ge1xuICBpbWFnZUhhc2g6IHN0cmluZ1xufVxuXG4vLyBmdW5jdGlvbiBpc1ZhbGlkVXBkYXRlUGF5bG9hZChwOiBVcGRhdGVUYWdQYXlsb2FkKSB7XG4vLyAgIHJldHVybiB0eXBlb2YgcC50aXRsZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHAuZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnO1xuLy8gfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVGFnKFxuICBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBwYXlsb2FkOiBVcGRhdGVUYWdQYXlsb2FkIHwgVXBkYXRlVGFnUGF5bG9hZFtdXG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIC8vIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gIC8vICAgY29uc3QgcHJvbWlzZXMgPSBwYXlsb2FkLm1hcCgocDogVXBkYXRlVGFnUGF5bG9hZCkgPT4ge1xuICAvLyAgICAgaWYgKCFpc1ZhbGlkVXBkYXRlUGF5bG9hZChwKSkge1xuICAvLyAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpO1xuICAvLyAgICAgfVxuXG4gIC8vICAgICBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgLy8gICAgIHJldHVybiAoY2xpZW50LnJlcXVlc3QoJ3VybCcsIHtcbiAgLy8gICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gIC8vICAgICAgIGJvZHk6IGZvcm0sXG4gIC8vICAgICAgIHJlc29sdmVCb2R5T25seTogdHJ1ZSxcbiAgLy8gICAgIH0pIGFzIHVua25vd24pIGFzIFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+PjtcbiAgLy8gICB9KTtcblxuICAvLyAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIC8vIH1cblxuICAvLyBpZiAoIWlzVmFsaWRVcGRhdGVQYXlsb2FkKHBheWxvYWQpKSB7XG4gIC8vICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGUgcmVxdWlyZXMgYSB0aXRsZSBhbmQvb3IgZGVzY3JpcHRpb24nKTtcbiAgLy8gfVxuXG4gIC8vIGNvbnN0IGZvcm0gPSBjcmVhdGVGb3JtKHBheWxvYWQpO1xuICAvLyByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCgndXJsJywge1xuICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAvLyAgIGJvZHk6IGZvcm0sXG4gIC8vICAgcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAvLyB9KSkgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+O1xuICByZXR1cm4gKChhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybDogcGF5bG9hZCwgbWV0aG9kOiAnUE9TVCcgfSkpXG4gICAgLmRhdGEgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPGJvb2xlYW4+XG59XG4iLCIvLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBJbWd1ckNsaWVudCB9IGZyb20gJy4vaW1ndXJDbGllbnQnXG5pbXBvcnQgeyBQYXlsb2FkLCBCaWtlVGFnQXBpUmVzcG9uc2UsIFRhZ0RhdGEgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnXG4vLyBpbXBvcnQgeyBQcm9ncmVzcyB9IGZyb20gJ2F4aW9zJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFRhZ0ltYWdlKFxuICAvLyBjbGllbnQ6IEltZ3VyQ2xpZW50LFxuICBwYXlsb2FkOiBzdHJpbmcgfCBzdHJpbmdbXSB8IFBheWxvYWQgfCBQYXlsb2FkW11cbik6IFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+IHwgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+W10+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHBheWxvYWQubWFwKChwOiBzdHJpbmcgfCBQYXlsb2FkKSA9PiB7XG4gICAgICAvLyBjb25zdCBmb3JtID0gY3JlYXRlRm9ybShwKTtcbiAgICAgIC8vIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KCdVUExPQURfRU5EUE9JTlQnLCB7XG4gICAgICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgLy8gICBib2R5OiBmb3JtLFxuICAgICAgLy8gICByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gICAgICAvLyB9KTtcblxuICAgICAgY29uc3QgaWQgPSAnYScgKyBwXG4gICAgICAvLyByZXEub24oJ3VwbG9hZFByb2dyZXNzJywgKHByb2dyZXNzOiBQcm9ncmVzcykgPT4ge1xuICAgICAgLy8gICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzLCBpZCB9KTtcbiAgICAgIC8vIH0pO1xuXG4gICAgICByZXR1cm4gKGlkIGFzIHVua25vd24pIGFzIFByb21pc2U8QmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+PlxuICAgIH0pXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICB9XG5cbiAgLy8gY29uc3QgZm9ybSA9IGNyZWF0ZUZvcm0ocGF5bG9hZCk7XG4gIC8vIGNvbnN0IHJlcSA9IGNsaWVudC5yZXF1ZXN0KCdVUExPQURfRU5EUE9JTlQnLCB7XG4gIC8vICAgbWV0aG9kOiAnUE9TVCcsXG4gIC8vICAgYm9keTogZm9ybSxcbiAgLy8gICByZXNvbHZlQm9keU9ubHk6IHRydWUsXG4gIC8vIH0pO1xuXG4gIGNvbnN0IGlkID0gJ0FkcydcbiAgLy8gcmVxLm9uKCd1cGxvYWRQcm9ncmVzcycsIChwcm9ncmVzczogUHJvZ3Jlc3MpID0+IHtcbiAgLy8gICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzLCBpZCB9KTtcbiAgLy8gfSk7XG5cbiAgcmV0dXJuIChpZCBhcyB1bmtub3duKSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT5cbn1cbiIsImltcG9ydCB7IFNhbml0eUNsaWVudCB9IGZyb20gJ0BzYW5pdHkvY2xpZW50J1xuaW1wb3J0IHsgQmlrZVRhZ0FwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGFnKFxuICBjbGllbnQ6IFNhbml0eUNsaWVudFxuICAvLyBzbHVnPzogc3RyaW5nLFxuICAvLyB0YWdudW1iZXI/OiBudW1iZXIsXG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPj4ge1xuICByZXR1cm4gKHsgY2xpZW50IH0gYXMgYW55KSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8Ym9vbGVhbj5cbn1cbiIsImltcG9ydCB7IFNhbml0eUNsaWVudCB9IGZyb20gJ0BzYW5pdHkvY2xpZW50J1xuaW1wb3J0IHsgQmlrZVRhZ0FwaVJlc3BvbnNlLCBUYWdEYXRhIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJ1xuaW1wb3J0IHsgY29uc3RydWN0VGFnRGF0YU9iamVjdCB9IGZyb20gJy4uL2NvbW1vbi9tZXRob2RzJ1xuaW1wb3J0IHsgdGFnRGF0YVJlZmVyZW5jZUZpZWxkcyB9IGZyb20gJy4uL2NvbW1vbi9kYXRhJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGFnKFxuICBjbGllbnQ6IFNhbml0eUNsaWVudCxcbiAgb3B0aW9uczogYW55XG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxUYWdEYXRhPj4ge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG9wdGlvbnMnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zLnNsdWcubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBzbHVnJylcbiAgfVxuXG4gIGNvbnN0IGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzXG4gICAgLnJlZHVjZSgobzogYW55LCBmOiBhbnkpID0+IHtcbiAgICAgIG8gKz0gYCR7Zn0ke3RhZ0RhdGFSZWZlcmVuY2VGaWVsZHMuaW5kZXhPZihmKSAhPSAtMSA/ICctPntuYW1lfScgOiAnJ30sYFxuICAgICAgcmV0dXJuIG9cbiAgICB9LCAnJylcbiAgICAuc2xpY2UoMCwgLTEpXG5cbiAgY29uc3QgcXVlcnkgPSBgKltfdHlwZSA9PSBcInRhZ1wiICYmIHNsdWcuY3VycmVudCA9PSBcIiR7b3B0aW9ucy5zbHVnfVwiXVswXXske2ZpZWxkc319YFxuXG4gIGNvbnN0IHBhcmFtcyA9IHt9XG5cbiAgcmV0dXJuIGNsaWVudC5mZXRjaChxdWVyeSwgcGFyYW1zKS50aGVuKCh0YWcpID0+IHtcbiAgICAvLyBjb25zdHJ1Y3QgdGFnRGF0YSBvYmplY3QgZnJvbSB0YWdcbiAgICBjb25zdCB0YWdEYXRhID0gY29uc3RydWN0VGFnRGF0YU9iamVjdCh0YWcsIG9wdGlvbnMuZmllbGRzKVxuXG4gICAgLy8gd3JhcCB0YWcgaW4gQmlrZVRhZ0FwaVJlc3BvbnNlXG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICBkYXRhOiB0YWdEYXRhLFxuICAgICAgc3RhdHVzOiAxLFxuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHNvdXJjZTogJ3Nhbml0eScsXG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIEJpa2VUYWdBcGlSZXNwb25zZVxuICAgIHJldHVybiByZXNwb25zZSBhcyBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT5cbiAgfSlcbn1cbiIsImV4cG9ydCB7IGRlbGV0ZVRhZyB9IGZyb20gJy4vZGVsZXRlVGFnJ1xuZXhwb3J0IHsgZ2V0VGFnIH0gZnJvbSAnLi9nZXRUYWcnXG5leHBvcnQgeyB1cGRhdGVUYWcgfSBmcm9tICcuL3VwZGF0ZVRhZydcbmV4cG9ydCB7IHVwbG9hZFRhZ0ltYWdlIH0gZnJvbSAnLi91cGxvYWRUYWdJbWFnZSdcbiIsImltcG9ydCB7IFNhbml0eUNsaWVudCB9IGZyb20gJ0BzYW5pdHkvY2xpZW50J1xuaW1wb3J0IHsgUGF5bG9hZCwgQmlrZVRhZ0FwaVJlc3BvbnNlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVRhZ1BheWxvYWRcbiAgZXh0ZW5kcyBQaWNrPFBheWxvYWQsICd0aXRsZScgfCAnZGVzY3JpcHRpb24nPiB7XG4gIHNsdWc6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVGFnKFxuICBjbGllbnQ6IFNhbml0eUNsaWVudFxuICAvLyBwYXlsb2FkOiBVcGRhdGVUYWdQYXlsb2FkIHwgVXBkYXRlVGFnUGF5bG9hZFtdXG4pOiBQcm9taXNlPEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPiB8IEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPltdPiB7XG4gIHJldHVybiAoeyBjbGllbnQgfSBhcyBhbnkpIGFzIEJpa2VUYWdBcGlSZXNwb25zZTxib29sZWFuPlxufVxuIiwiaW1wb3J0IHsgU2FuaXR5Q2xpZW50IH0gZnJvbSAnQHNhbml0eS9jbGllbnQnXG5pbXBvcnQgeyBQYXlsb2FkLCBCaWtlVGFnQXBpUmVzcG9uc2UsIFRhZ0RhdGEgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRUYWdJbWFnZShcbiAgY2xpZW50OiBTYW5pdHlDbGllbnQsXG4gIHBheWxvYWQ6IHN0cmluZyB8IHN0cmluZ1tdIHwgUGF5bG9hZCB8IFBheWxvYWRbXVxuKTogUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT4gfCBCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT5bXT4ge1xuICBjb25zdCByZXEgPSBudWxsXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHBheWxvYWQubWFwKChwOiBzdHJpbmcgfCBQYXlsb2FkKSA9PiB7XG4gICAgICByZXR1cm4gKHAgYXMgdW5rbm93bikgYXMgUHJvbWlzZTxCaWtlVGFnQXBpUmVzcG9uc2U8VGFnRGF0YT4+XG4gICAgfSlcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gIH1cblxuICByZXR1cm4gKCgoYXdhaXQge1xuICAgIGNsaWVudCxcbiAgICByZXEsXG4gIH0pIGFzIGFueSkgYXMgdW5rbm93bikgYXMgQmlrZVRhZ0FwaVJlc3BvbnNlPFRhZ0RhdGE+XG59XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jcmVhdGVCaW5kaW5nKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOltcXFxcL10rL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhbXFxcXC9dezEsfSk/KFtcXFNcXHNdKikvaVxuICAsIHdoaXRlc3BhY2UgPSAnW1xcXFx4MDlcXFxceDBBXFxcXHgwQlxcXFx4MENcXFxceDBEXFxcXHgyMFxcXFx4QTBcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdUZFRkZdJ1xuICAsIGxlZnQgPSBuZXcgUmVnRXhwKCdeJysgd2hpdGVzcGFjZSArJysnKTtcblxuLyoqXG4gKiBUcmltIGEgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyaW0uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UobGVmdCwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGdsb2JhbFZhcjtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHdpbmRvdztcbiAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IGdsb2JhbDtcbiAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBzZWxmO1xuICBlbHNlIGdsb2JhbFZhciA9IHt9O1xuXG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbFZhci5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG5cbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpXG4gICAgLCBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnXG4gICAgLCBzbGFzaGVzID0gISEobWF0Y2hbMl0gJiYgbWF0Y2hbMl0ubGVuZ3RoID49IDIpXG4gICAgLCByZXN0ID0gIG1hdGNoWzJdICYmIG1hdGNoWzJdLmxlbmd0aCA9PT0gMSA/ICcvJyArIG1hdGNoWzNdIDogbWF0Y2hbM107XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgc2xhc2hlczogc2xhc2hlcyxcbiAgICByZXN0OiByZXN0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICBpZiAocmVsYXRpdmUgPT09ICcnKSByZXR1cm4gYmFzZTtcblxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2xvY2F0aW9uXSBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBhIC8gZm9yIHBhdGhuYW1lIGlmIG5vbmUgZXhpc3RzLiBUaGlzIG5vcm1hbGl6ZXMgdGhlIFVSTFxuICAvLyB0byBhbHdheXMgaGF2ZSBhIC9cbiAgLy9cbiAgaWYgKHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyAmJiB1cmwuaG9zdG5hbWUpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnLycgKyB1cmwucGF0aG5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwudHJpbUxlZnQgPSB0cmltTGVmdDtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vc3VwcG9ydC90eXBlcycpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gaGFzU3ltYm9scyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdsb2JhbFt0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIGFyciA9IG5ldyBnbG9iYWxbdHlwZWRBcnJheV0oKTtcblx0XHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFdmFsRXJyb3IoJ3RoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCAnICsgdHlwZWRBcnJheSArICcgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy4nKTtcblx0XHRcdH1cblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmROYW1lID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0dGVyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kTmFtZSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kTmFtZTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCI7KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgLy9Db21tb25KUzIgQ29tbWVudFxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXG4gIC8vQU1EIENvbW1lbnRcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIGZhY3RvcnkpXG4gIC8vQ29tbW9uSlMgQ29tbWVudFxuICBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIGV4cG9ydHNbJ2ltZ3VyJ10gPSBmYWN0b3J5KClcbiAgLy9Sb290IENvbW1lbnRcbiAgZWxzZSByb290WydpbWd1ciddID0gZmFjdG9yeSgpXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gLyoqKioqKi8gKCgpID0+IHtcbiAgICAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4gICAgLyoqKioqKi8gdmFyIF9fd2VicGFja19tb2R1bGVzX18gPSB7XG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXJyYXktZmlsdGVyL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXJyYXktZmlsdGVyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFycmF5I2ZpbHRlci5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBzZWxmXG4gICAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAgICogQHRocm93IFR5cGVFcnJvclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBmbiwgc2VsZikge1xuICAgICAgICAgICAgaWYgKGFyci5maWx0ZXIpIHJldHVybiBhcnIuZmlsdGVyKGZuLCBzZWxmKVxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYXJyIHx8IG51bGwgPT09IGFycikgdGhyb3cgbmV3IFR5cGVFcnJvcigpXG4gICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBUeXBlRXJyb3IoKVxuICAgICAgICAgICAgdmFyIHJldCA9IFtdXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKGFyciwgaSkpIGNvbnRpbnVlXG4gICAgICAgICAgICAgIHZhciB2YWwgPSBhcnJbaV1cbiAgICAgICAgICAgICAgaWYgKGZuLmNhbGwoc2VsZiwgdmFsLCBpLCBhcnIpKSByZXQucHVzaCh2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvYXNzZXJ0LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgcHJvY2Vzcy9icm93c2VyICovICcuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIC8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNvbnNvbGUtYnJvd3NlcmlmeSAqLyAnLi9ub2RlX21vZHVsZXMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICAvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2Fzc2VydC5qc1xuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMmE1MWFlNDI0YTUxM2VjOWE2YWEzNDY2YmFhMGNjMWQ1NWRkNGYzYlxuICAgICAgICAgIC8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbiAgICAgICAgICAvLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICAgICAgLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4gICAgICAgICAgLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiAgICAgICAgICAvLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAgICAgICAgICAvLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAgICAgIC8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICAgICAgICAgIC8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgICAgICAvLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgICAgICAvLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICAgICAgICAvLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICAgICAgICAgIC8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbiAgICAgICAgICAvLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuICAgICAgICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9ialxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJlxuICAgICAgICAgICAgICAgICAgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgICAgICAgICA6IHR5cGVvZiBvYmpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vaW50ZXJuYWwvZXJyb3JzICovICcuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gICAgICAgICAgICBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX0FNQklHVU9VU19BUkdVTUVOVCxcbiAgICAgICAgICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgICAgICAgICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gICAgICAgICAgICBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUsXG4gICAgICAgICAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHU1xuXG4gICAgICAgICAgdmFyIEFzc2VydGlvbkVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IgKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgdXRpbC8gKi8gJy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcydcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3RcblxuICAgICAgICAgIHZhciBfcmVxdWlyZSR0eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISB1dGlsLyAqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzJ1xuICAgICAgICAgICAgKS50eXBlcyxcbiAgICAgICAgICAgIGlzUHJvbWlzZSA9IF9yZXF1aXJlJHR5cGVzLmlzUHJvbWlzZSxcbiAgICAgICAgICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHBcblxuICAgICAgICAgIHZhciBvYmplY3RBc3NpZ24gPSBPYmplY3QuYXNzaWduXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ25cbiAgICAgICAgICAgIDogX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgICAvKiEgZXM2LW9iamVjdC1hc3NpZ24gKi8gJy4vbm9kZV9tb2R1bGVzL2VzNi1vYmplY3QtYXNzaWduL2luZGV4LmpzJ1xuICAgICAgICAgICAgICApLmFzc2lnblxuICAgICAgICAgIHZhciBvYmplY3RJcyA9IE9iamVjdC5pc1xuICAgICAgICAgICAgPyBPYmplY3QuaXNcbiAgICAgICAgICAgIDogX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgICAvKiEgb2JqZWN0LWlzICovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW5kZXguanMnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICB2YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKVxuICAgICAgICAgIHZhciBpc0RlZXBFcXVhbFxuICAgICAgICAgIHZhciBpc0RlZXBTdHJpY3RFcXVhbFxuICAgICAgICAgIHZhciBwYXJzZUV4cHJlc3Npb25BdFxuICAgICAgICAgIHZhciBmaW5kTm9kZUFyb3VuZFxuICAgICAgICAgIHZhciBkZWNvZGVyXG5cbiAgICAgICAgICBmdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyaXNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMgKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzJ1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWxcbiAgICAgICAgICAgIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbFxuICAgICAgICAgIH0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuICAgICAgICAgIC8vIGluZGVudGF0aW9uIGludGFjdC5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG4gICAgICAgICAgdmFyIGVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZdL2dcbiAgICAgICAgICB2YXIgbWV0YSA9IFtcbiAgICAgICAgICAgICdcXFxcdTAwMDAnLFxuICAgICAgICAgICAgJ1xcXFx1MDAwMScsXG4gICAgICAgICAgICAnXFxcXHUwMDAyJyxcbiAgICAgICAgICAgICdcXFxcdTAwMDMnLFxuICAgICAgICAgICAgJ1xcXFx1MDAwNCcsXG4gICAgICAgICAgICAnXFxcXHUwMDA1JyxcbiAgICAgICAgICAgICdcXFxcdTAwMDYnLFxuICAgICAgICAgICAgJ1xcXFx1MDAwNycsXG4gICAgICAgICAgICAnXFxcXGInLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdcXFxcdTAwMGInLFxuICAgICAgICAgICAgJ1xcXFxmJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ1xcXFx1MDAwZScsXG4gICAgICAgICAgICAnXFxcXHUwMDBmJyxcbiAgICAgICAgICAgICdcXFxcdTAwMTAnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxMScsXG4gICAgICAgICAgICAnXFxcXHUwMDEyJyxcbiAgICAgICAgICAgICdcXFxcdTAwMTMnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxNCcsXG4gICAgICAgICAgICAnXFxcXHUwMDE1JyxcbiAgICAgICAgICAgICdcXFxcdTAwMTYnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxNycsXG4gICAgICAgICAgICAnXFxcXHUwMDE4JyxcbiAgICAgICAgICAgICdcXFxcdTAwMTknLFxuICAgICAgICAgICAgJ1xcXFx1MDAxYScsXG4gICAgICAgICAgICAnXFxcXHUwMDFiJyxcbiAgICAgICAgICAgICdcXFxcdTAwMWMnLFxuICAgICAgICAgICAgJ1xcXFx1MDAxZCcsXG4gICAgICAgICAgICAnXFxcXHUwMDFlJyxcbiAgICAgICAgICAgICdcXFxcdTAwMWYnLFxuICAgICAgICAgIF1cblxuICAgICAgICAgIHZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlIC8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4gICAgICAgICAgLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4gICAgICAgICAgLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbiAgICAgICAgICB2YXIgYXNzZXJ0ID0gKG1vZHVsZS5leHBvcnRzID0gb2spXG4gICAgICAgICAgdmFyIE5PX0VYQ0VQVElPTl9TRU5USU5FTCA9IHt9IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4gICAgICAgICAgLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbiAgICAgICAgICAvLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbiAgICAgICAgICAvLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuICAgICAgICAgIC8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbiAgICAgICAgICBmdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2VcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZuKSB7XG4gICAgICAgICAgICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbE1lc3NhZ2VcblxuICAgICAgICAgICAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCdcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgICAgICAgICAgICBtZXNzYWdlID0gYWN0dWFsXG4gICAgICAgICAgICAgIGFjdHVhbCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB3YXJuZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nXG4gICAgICAgICAgICAgICAgICA/IHByb2Nlc3MuZW1pdFdhcm5pbmdcbiAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSlcbiAgICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICAgJ2Fzc2VydC5mYWlsKCkgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnUGxlYXNlIHVzZSBhc3NlcnQuc3RyaWN0RXF1YWwoKSBpbnN0ZWFkIG9yIG9ubHkgcGFzcyBhIG1lc3NhZ2UuJyxcbiAgICAgICAgICAgICAgICAgICdEZXByZWNhdGlvbldhcm5pbmcnLFxuICAgICAgICAgICAgICAgICAgJ0RFUDAwOTQnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFyZ3NMZW4gPT09IDIpIG9wZXJhdG9yID0gJyE9J1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtZXNzYWdlXG4gICAgICAgICAgICB2YXIgZXJyQXJncyA9IHtcbiAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSB1bmRlZmluZWQgPyAnZmFpbCcgOiBvcGVyYXRvcixcbiAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbCxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyQXJncylcblxuICAgICAgICAgICAgaWYgKGludGVybmFsTWVzc2FnZSkge1xuICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGludGVybmFsTWVzc2FnZVxuICAgICAgICAgICAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXNzZXJ0LmZhaWwgPSBmYWlsIC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG4gICAgICAgICAgYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3JcblxuICAgICAgICAgIGZ1bmN0aW9uIGlubmVyT2soZm4sIGFyZ0xlbiwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZVxuXG4gICAgICAgICAgICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnTm8gdmFsdWUgYXJndW1lbnQgcGFzc2VkIHRvIGBhc3NlcnQub2soKWAnXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbWVzc2FnZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogZm4sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZVxuICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbiAgICAgICAgICAvLyBieSAhIXZhbHVlLlxuXG4gICAgICAgICAgZnVuY3Rpb24gb2soKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xuICAgICAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5vayA9IG9rIC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cblxuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG4gICAgICAgICAgYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKVxuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cbiAgICAgICAgICAgIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdFxuICAgICAgICAgIC8vIGVxdWFsIHdpdGggIT0uXG5cbiAgICAgICAgICBhc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuICAgICAgICAgICAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICBpbm5lckZhaWwoe1xuICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnIT0nLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogbm90RXF1YWwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cblxuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKClcblxuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICBpbm5lckZhaWwoe1xuICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuXG4gICAgICAgICAgYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChcbiAgICAgICAgICAgIGFjdHVhbCxcbiAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKClcblxuICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdub3REZWVwRXF1YWwnLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICAgICAgICBhc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKFxuICAgICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKVxuXG4gICAgICAgICAgICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWxcblxuICAgICAgICAgIGZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKVxuXG4gICAgICAgICAgICBpZiAoaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwU3RyaWN0RXF1YWwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbCxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChcbiAgICAgICAgICAgIGFjdHVhbCxcbiAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgaW5uZXJGYWlsKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IG5vdFN0cmljdEVxdWFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBDb21wYXJpc29uID0gZnVuY3Rpb24gQ29tcGFyaXNvbihvYmosIGtleXMsIGFjdHVhbCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuXG4gICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbilcblxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBhY3R1YWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgaXNSZWdFeHAob2JqW2tleV0pICYmXG4gICAgICAgICAgICAgICAgICBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgX3RoaXNba2V5XSA9IGFjdHVhbFtrZXldXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb21wYXJlRXhjZXB0aW9uS2V5KFxuICAgICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIGZuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICEoa2V5IGluIGFjdHVhbCkgfHxcbiAgICAgICAgICAgICAgIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbFtrZXldLCBleHBlY3RlZFtrZXldKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIGNyZWF0ZSBhIG5pY2Ugb3V0cHV0LlxuICAgICAgICAgICAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKVxuICAgICAgICAgICAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbClcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBmbixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWxcbiAgICAgICAgICAgICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZFxuICAgICAgICAgICAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWVcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBmbixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBtc2csIGZuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCkgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cblxuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICAgICAgICAgICdleHBlY3RlZCcsXG4gICAgICAgICAgICAgICAgICBbJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLFxuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0gLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG5cbiAgICAgICAgICAgICAgaWYgKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogZm4sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKSAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAgICAgICAgICAgLy8gYXMgd2VsbC5cblxuICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJylcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoXG4gICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpXG4gICAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgaXNSZWdFeHAoZXhwZWN0ZWRba2V5XSkgJiZcbiAgICAgICAgICAgICAgICAgIGV4cGVjdGVkW2tleV0udGVzdChhY3R1YWxba2V5XSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtc2csIGtleXMsIGZuKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSAvLyBHdWFyZCBpbnN0YW5jZW9mIGFnYWluc3QgYXJyb3cgZnVuY3Rpb25zIGFzIHRoZXkgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZS5cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBleHBlY3RlZC5wcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRBY3R1YWwoZm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsICdGdW5jdGlvbicsIGZuKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmbigpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgICAgICAgICAgIC8vIEFjY2VwdCBuYXRpdmUgRVM2IHByb21pc2VzIGFuZCBwcm9taXNlcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBpbiBhIHNpbWlsYXJcbiAgICAgICAgICAgIC8vIHdheS4gRG8gbm90IGFjY2VwdCB0aGVuYWJsZXMgdGhhdCB1c2UgYSBmdW5jdGlvbiBhcyBgb2JqYCBhbmQgdGhhdCBoYXZlIG5vXG4gICAgICAgICAgICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGVuYWJsZXMgYXJlIGNoZWNrZWQgdXAgdW50aWwgdGhleSBoYXZlIHRoZSBjb3JyZWN0IG1ldGhvZHMsXG4gICAgICAgICAgICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gICAgICAgICAgICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBpc1Byb21pc2Uob2JqKSB8fFxuICAgICAgICAgICAgICAob2JqICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvYmouY2F0Y2ggPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdFByb21pc2VcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb21pc2VGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbigpIC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja0lzUHJvbWlzZShyZXN1bHRQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRShcbiAgICAgICAgICAgICAgICAgICAgJ2luc3RhbmNlIG9mIFByb21pc2UnLFxuICAgICAgICAgICAgICAgICAgICAncHJvbWlzZUZuJyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGblxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICAgICAgICAgICdwcm9taXNlRm4nLFxuICAgICAgICAgICAgICAgICAgWydGdW5jdGlvbicsICdQcm9taXNlJ10sXG4gICAgICAgICAgICAgICAgICBwcm9taXNlRm5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVChcbiAgICAgICAgICAgICAgICAgICAgJ2Vycm9yL21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAnVGhlIGVycm9yIG1lc3NhZ2UgXCInLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICBhY3R1YWwubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLidcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoXG4gICAgICAgICAgICAgICAgICAnZXJyb3IvbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAnVGhlIGVycm9yIFwiJy5jb25jYXQoYWN0dWFsLCAnXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLicpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yXG4gICAgICAgICAgICAgIGVycm9yID0gdW5kZWZpbmVkXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICBlcnJvciAhPSBudWxsICYmXG4gICAgICAgICAgICAgIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgICAgICAgICAgICB2YXIgZGV0YWlscyA9ICcnXG5cbiAgICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzICs9ICcgKCcuY29uY2F0KGVycm9yLm5hbWUsICcpJylcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRldGFpbHMgKz0gbWVzc2FnZSA/ICc6ICcuY29uY2F0KG1lc3NhZ2UpIDogJy4nXG4gICAgICAgICAgICAgIHZhciBmblR5cGUgPVxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbi5uYW1lID09PSAncmVqZWN0cycgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nXG4gICAgICAgICAgICAgIGlubmVyRmFpbCh7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlY3RlZCAnLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzKSxcbiAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnJvciAmJlxuICAgICAgICAgICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRocm93IGFjdHVhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yXG4gICAgICAgICAgICAgIGVycm9yID0gdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICAgICAgICAgICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gJzogJy5jb25jYXQobWVzc2FnZSkgOiAnLidcbiAgICAgICAgICAgICAgdmFyIGZuVHlwZSA9XG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0J1xuICAgICAgICAgICAgICAgICAgPyAncmVqZWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgOiAnZXhjZXB0aW9uJ1xuICAgICAgICAgICAgICBpbm5lckZhaWwoe1xuICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICdHb3QgdW53YW50ZWQgJy5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgJ1xcbicpICtcbiAgICAgICAgICAgICAgICAgICdBY3R1YWwgbWVzc2FnZTogXCInLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsICdcIicpLFxuICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBhY3R1YWxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gdGhyb3dzKHByb21pc2VGbikge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLFxuICAgICAgICAgICAgICAgIF9rZXkyID0gMTtcbiAgICAgICAgICAgICAgX2tleTIgPCBfbGVuMjtcbiAgICAgICAgICAgICAgX2tleTIrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwZWN0c0Vycm9yLmFwcGx5KFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncylcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksXG4gICAgICAgICAgICAgICAgX2tleTMgPSAxO1xuICAgICAgICAgICAgICBfa2V5MyA8IF9sZW4zO1xuICAgICAgICAgICAgICBfa2V5MysrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3JlamVjdHMsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksXG4gICAgICAgICAgICAgICAgX2tleTQgPSAxO1xuICAgICAgICAgICAgICBfa2V5NCA8IF9sZW40O1xuICAgICAgICAgICAgICBfa2V5NCsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBlY3RzTm9FcnJvci5hcHBseShcbiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncylcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSxcbiAgICAgICAgICAgICAgICBfa2V5NSA9IDE7XG4gICAgICAgICAgICAgIF9rZXk1IDwgX2xlbjU7XG4gICAgICAgICAgICAgIF9rZXk1KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdHNOb0Vycm9yLmFwcGx5KFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uIGlmRXJyb3IoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJ1xuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UubGVuZ3RoID09PSAwICYmIGVyci5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBlcnIuY29uc3RydWN0b3IubmFtZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBhY3R1YWw6IGVycixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yLFxuICAgICAgICAgICAgICB9KSAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgICAgICAgICAgIHZhciBvcmlnU3RhY2sgPSBlcnIuc3RhY2tcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgICAgICAgICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZWQgb25lcy5cbiAgICAgICAgICAgICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICB0bXAyLnNoaWZ0KCkgLy8gRmlsdGVyIGFsbCBmcmFtZXMgZXhpc3RpbmcgaW4gZXJyLnN0YWNrLlxuXG4gICAgICAgICAgICAgICAgdmFyIHRtcDEgPSBuZXdFcnIuc3RhY2suc3BsaXQoJ1xcbicpXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRtcDEuaW5kZXhPZih0bXAyW2ldKVxuXG4gICAgICAgICAgICAgICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICAgICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld0Vyci5zdGFjayA9ICcnXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KHRtcDEuam9pbignXFxuJyksICdcXG4nKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3RXJyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG4gICAgICAgICAgZnVuY3Rpb24gc3RyaWN0KCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDtcbiAgICAgICAgICAgICAgX2tleTYgPCBfbGVuNjtcbiAgICAgICAgICAgICAgX2tleTYrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gICAgICAgICAgICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICAgICAgICAgICAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICAgICAgICAgICAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgICAgICAgICAgIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdFxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgcHJvY2Vzcy9icm93c2VyICovICcuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIC8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qc1xuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuXG4gICAgICAgICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9XG4gICAgICAgICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoXG4gICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgIHN5bVxuICAgICAgICAgICAgICAgICAgICApLmVudW1lcmFibGVcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV1cbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKVxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGNhbGwgJiZcbiAgICAgICAgICAgICAgKF90eXBlb2YoY2FsbCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBjYWxsID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgICAgICAgICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXG4gICAgICAgICAgICAgIHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgICAgICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgICAgICAgICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzc1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcylcbiAgICAgICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoXG4gICAgICAgICAgICAgICAgICBDbGFzcyxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgICAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICAgICAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gW251bGxdXG4gICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpXG4gICAgICAgICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKClcbiAgICAgICAgICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT09IC0xXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XG4gICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICAgICAgICAgIG8uX19wcm90b19fID0gcFxuICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mXG4gICAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXG4gICAgICAgICAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgID8gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIG9ialxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3R5cGVvZihvYmopXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIHV0aWwvICovICcuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3RcblxuICAgICAgICAgIHZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi4vZXJyb3JzICovICcuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG4gICAgICAgICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2hcbiAgICAgICAgICB9IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcblxuICAgICAgICAgIGZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGNvdW50ID09IDApIHJldHVybiAnJ1xuICAgICAgICAgICAgdmFyIG1heENvdW50ID0gc3RyLmxlbmd0aCAqIGNvdW50XG4gICAgICAgICAgICBjb3VudCA9IE1hdGguZmxvb3IoTWF0aC5sb2coY291bnQpIC8gTWF0aC5sb2coMikpXG5cbiAgICAgICAgICAgIHdoaWxlIChjb3VudCkge1xuICAgICAgICAgICAgICBzdHIgKz0gc3RyXG4gICAgICAgICAgICAgIGNvdW50LS1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBibHVlID0gJydcbiAgICAgICAgICB2YXIgZ3JlZW4gPSAnJ1xuICAgICAgICAgIHZhciByZWQgPSAnJ1xuICAgICAgICAgIHZhciB3aGl0ZSA9ICcnXG4gICAgICAgICAgdmFyIGtSZWFkYWJsZU9wZXJhdG9yID0ge1xuICAgICAgICAgICAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgICAgICAgICAgIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gICAgICAgICAgICBzdHJpY3RFcXVhbE9iamVjdDpcbiAgICAgICAgICAgICAgJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICAgICAgICAgICAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICAgICAgICAgICAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICAgICAgICAgICAgbm90RGVlcFN0cmljdEVxdWFsOlxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbCB0bzonLFxuICAgICAgICAgICAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgICAgICAgICAgIG5vdFN0cmljdEVxdWFsT2JqZWN0OlxuICAgICAgICAgICAgICAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICAgICAgICAgICAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gICAgICAgICAgICBub3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgbG9vc2VseSB1bmVxdWFsIHRvOicsXG4gICAgICAgICAgICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOicsXG4gICAgICAgICAgfSAvLyBDb21wYXJpbmcgc2hvcnQgcHJpbWl0aXZlcyBzaG91bGQganVzdCBzaG93ID09PSAvICE9PSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuICAgICAgICAgIC8vIGRpZmYuXG5cbiAgICAgICAgICB2YXIga01heFNob3J0TGVuZ3RoID0gMTBcblxuICAgICAgICAgIGZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAgICAgICAgICAgLy8gVGhlIHV0aWwuaW5zcGVjdCBkZWZhdWx0IHZhbHVlcyBjb3VsZCBiZSBjaGFuZ2VkLiBUaGlzIG1ha2VzIHN1cmUgdGhlXG4gICAgICAgICAgICAvLyBlcnJvciBtZXNzYWdlcyBjb250YWluIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gbmV2ZXJ0aGVsZXNzLlxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgICAgICAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgZGVwdGg6IDEwMDAsXG4gICAgICAgICAgICAgIG1heEFycmF5TGVuZ3RoOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgLy8gQXNzZXJ0IGNvbXBhcmVzIG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzICh3aXRoIGEgZmV3IGV4Y2VwdGlvbnMpLlxuICAgICAgICAgICAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gSGF2aW5nIGEgbG9uZyBsaW5lIGFzIGVycm9yIGlzIGJldHRlciB0aGFuIHdyYXBwaW5nIHRoZSBsaW5lIGZvclxuICAgICAgICAgICAgICAvLyBjb21wYXJpc29uIGZvciBub3cuXG4gICAgICAgICAgICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgICAgICAgICAgICAvLyBoYXZlIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3BlY3RlZCBwcm9wZXJ0aWVzIChpLmUuLCBrbm93IHdoZXJlXG4gICAgICAgICAgICAgIC8vIGluIHdoYXQgbGluZSB0aGUgcHJvcGVydHkgc3RhcnRzIGFuZCBlbmRzKS5cbiAgICAgICAgICAgICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgICAgICAgICAgICAvLyBBc3NlcnQgZG9lcyBub3QgZGV0ZWN0IHByb3hpZXMgY3VycmVudGx5LlxuICAgICAgICAgICAgICBzaG93UHJveHk6IGZhbHNlLFxuICAgICAgICAgICAgICBzb3J0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIC8vIEluc3BlY3QgZ2V0dGVycyBhcyB3ZSBhbHNvIGNoZWNrIHRoZW0gd2hlbiBjb21wYXJpbmcgZW50cmllcy5cbiAgICAgICAgICAgICAgZ2V0dGVyczogdHJ1ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gJydcbiAgICAgICAgICAgIHZhciByZXMgPSAnJ1xuICAgICAgICAgICAgdmFyIGxhc3RQb3MgPSAwXG4gICAgICAgICAgICB2YXIgZW5kID0gJydcbiAgICAgICAgICAgIHZhciBza2lwcGVkID0gZmFsc2VcbiAgICAgICAgICAgIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKVxuICAgICAgICAgICAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgdmFyIGkgPSAwXG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9yID0gJycgLy8gSW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgb2JqZWN0cyBleHBsaWNpdGx5IG1hcmsgdGhlbSBhcyBub3QgcmVmZXJlbmNlIGVxdWFsXG4gICAgICAgICAgICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcgJiZcbiAgICAgICAgICAgICAgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgYWN0dWFsICE9PSBudWxsICYmXG4gICAgICAgICAgICAgIGV4cGVjdGVkICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPSAnc3RyaWN0RXF1YWxPYmplY3QnXG4gICAgICAgICAgICB9IC8vIElmIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiBmaXQgb24gYSBzaW5nbGUgbGluZSBhbmQgdGhleSBhcmUgbm90IHN0cmljdGx5XG4gICAgICAgICAgICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoIC8vIElmIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiB0b2dldGhlciBpcyBsZXNzIHRoYW5cbiAgICAgICAgICAgICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAgICAgICAgICAgLy8gbm90IGB6ZXJvYCwgdXNlIHRoZSBzdHJpY3QgZXF1YWwgY29tcGFyaXNvbiB0byB2aXN1YWxpemUgdGhlIG91dHB1dC5cblxuICAgICAgICAgICAgICBpZiAoaW5wdXRMZW5ndGggPD0ga01heFNob3J0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgICAgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiZcbiAgICAgICAgICAgICAgICAgIChhY3R1YWwgIT09IDAgfHwgZXhwZWN0ZWQgIT09IDApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyAtMCA9PT0gKzBcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICcnLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sICdcXG5cXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChhY3R1YWxMaW5lc1swXSwgJyAhPT0gJylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sICdcXG4nKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJ3N0cmljdEVxdWFsT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgIC8vIGNvbHVtbnMgcGVyIGxpbmUsIGFkZCBhIG1pc21hdGNoIGluZGljYXRvciBiZWxvdyB0aGUgb3V0cHV0LiBJZiBpdCBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIHR0eSwgdXNlIGEgZGVmYXVsdCB2YWx1ZSBvZiA4MCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIHZhciBtYXhMZW5ndGggPVxuICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFlcbiAgICAgICAgICAgICAgICAgICAgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgIDogODBcblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dExlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKGFjdHVhbExpbmVzWzBdW2ldID09PSBleHBlY3RlZExpbmVzWzBdW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChpID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBsaW5lIGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgY29sdW1uIGxlbmd0aC5cbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yID0gJ1xcbiAgJy5jb25jYXQocmVwZWF0KCcgJywgaSksICdeJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IDBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gUmVtb3ZlIGFsbCBlbmRpbmcgbGluZXMgdGhhdCBtYXRjaCAodGhpcyBvcHRpbWl6ZXMgdGhlIG91dHB1dCBmb3JcbiAgICAgICAgICAgIC8vIHJlYWRhYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBudW1iZXIgb2YgdG90YWwgY2hhbmdlZCBsaW5lcykuXG5cbiAgICAgICAgICAgIHZhciBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIHZhciBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdXG5cbiAgICAgICAgICAgIHdoaWxlIChhID09PSBiKSB7XG4gICAgICAgICAgICAgIGlmIChpKysgPCAyKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gJ1xcbiAgJy5jb25jYXQoYSkuY29uY2F0KGVuZClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdGhlciA9IGFcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFjdHVhbExpbmVzLnBvcCgpXG4gICAgICAgICAgICAgIGV4cGVjdGVkTGluZXMucG9wKClcbiAgICAgICAgICAgICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWtcbiAgICAgICAgICAgICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1heExpbmVzID0gTWF0aC5tYXgoYWN0dWFsTGluZXMubGVuZ3RoLCBleHBlY3RlZExpbmVzLmxlbmd0aCkgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gICAgICAgICAgICAvLyBFLmcuLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHsgYTogU3ltYm9sKCkgfSwgeyBhOiBTeW1ib2woKSB9KVxuXG4gICAgICAgICAgICBpZiAobWF4TGluZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgICAgICAgICAgICB2YXIgX2FjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKSAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG4gICAgICAgICAgICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgICAgICBfYWN0dWFsTGluZXNbMjZdID0gJycuY29uY2F0KGJsdWUsICcuLi4nKS5jb25jYXQod2hpdGUpXG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICAgICAgICBfYWN0dWFsTGluZXMucG9wKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgICAgICAuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yLm5vdElkZW50aWNhbCwgJ1xcblxcbicpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChfYWN0dWFsTGluZXMuam9pbignXFxuJyksICdcXG4nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA+IDMpIHtcbiAgICAgICAgICAgICAgZW5kID0gJ1xcbicuY29uY2F0KGJsdWUsICcuLi4nKS5jb25jYXQod2hpdGUpLmNvbmNhdChlbmQpXG4gICAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvdGhlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgZW5kID0gJ1xcbiAgJy5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpXG4gICAgICAgICAgICAgIG90aGVyID0gJydcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByaW50ZWRMaW5lcyA9IDBcbiAgICAgICAgICAgIHZhciBtc2cgPVxuICAgICAgICAgICAgICBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0gK1xuICAgICAgICAgICAgICAnXFxuJ1xuICAgICAgICAgICAgICAgIC5jb25jYXQoZ3JlZW4sICcrIGFjdHVhbCcpXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh3aGl0ZSwgJyAnKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVkLCAnLSBleHBlY3RlZCcpXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh3aGl0ZSlcbiAgICAgICAgICAgIHZhciBza2lwcGVkTXNnID0gJyAnXG4gICAgICAgICAgICAgIC5jb25jYXQoYmx1ZSwgJy4uLicpXG4gICAgICAgICAgICAgIC5jb25jYXQod2hpdGUsICcgTGluZXMgc2tpcHBlZCcpXG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXhMaW5lczsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICAgICAgICAgICAgdmFyIGN1ciA9IGkgLSBsYXN0UG9zXG5cbiAgICAgICAgICAgICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgICAgICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9ICdcXG4nLmNvbmNhdChibHVlLCAnLi4uJykuY29uY2F0KHdoaXRlKVxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSAnXFxuICAnLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAyXSlcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzKytcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzICs9ICdcXG4gICcuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDFdKVxuICAgICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzKytcbiAgICAgICAgICAgICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG4gICAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgLy8gQWRkIHRoZSBleHBlY3RlZCBsaW5lIHRvIHRoZSBjYWNoZS5cblxuICAgICAgICAgICAgICAgIG90aGVyICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KHJlZCwgJy0nKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdCh3aGl0ZSwgJyAnKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKVxuICAgICAgICAgICAgICAgIHByaW50ZWRMaW5lcysrIC8vIE9ubHkgZXh0cmEgYWN0dWFsIGxpbmVzIGV4aXN0XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgICAgICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSAnXFxuJy5jb25jYXQoYmx1ZSwgJy4uLicpLmNvbmNhdCh3aGl0ZSlcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbiAgJy5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKVxuICAgICAgICAgICAgICAgICAgICBwcmludGVkTGluZXMrK1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbiAgJy5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKVxuICAgICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzKytcbiAgICAgICAgICAgICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG4gICAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgICAgICAgICAgcmVzICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KGdyZWVuLCAnKycpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KHdoaXRlLCAnICcpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KGFjdHVhbExpbmVzW2ldKVxuICAgICAgICAgICAgICAgIHByaW50ZWRMaW5lcysrIC8vIExpbmVzIGRpdmVyZ2VcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXVxuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV0gLy8gSWYgdGhlIGxpbmVzIGRpdmVyZ2UsIHNwZWNpZmljYWxseSBjaGVjayBmb3IgbGluZXMgdGhhdCBvbmx5IGRpdmVyZ2UgYnlcbiAgICAgICAgICAgICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGl0IGFzIHN1Y2guXG5cbiAgICAgICAgICAgICAgICB2YXIgZGl2ZXJnaW5nTGluZXMgPVxuICAgICAgICAgICAgICAgICAgYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmXG4gICAgICAgICAgICAgICAgICAoIWVuZHNXaXRoKGFjdHVhbExpbmUsICcsJykgfHxcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsTGluZS5zbGljZSgwLCAtMSkgIT09IGV4cGVjdGVkTGluZSkgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgY29tbWEgYXQgdGhlIGVuZCBvZiB0aGUgYWN0dWFsIGxpbmUuIE90aGVyd2lzZSB0aGUgb3V0cHV0IGNvdWxkXG4gICAgICAgICAgICAgICAgLy8gbG9vayB3ZWlyZCBhcyBpbjpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgW1xuICAgICAgICAgICAgICAgIC8vICAgICAxICAgICAgICAgLy8gTm8gY29tbWEgYXQgdGhlIGVuZCFcbiAgICAgICAgICAgICAgICAvLyArICAgMlxuICAgICAgICAgICAgICAgIC8vICAgXVxuICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBkaXZlcmdpbmdMaW5lcyAmJlxuICAgICAgICAgICAgICAgICAgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmXG4gICAgICAgICAgICAgICAgICBleHBlY3RlZExpbmUuc2xpY2UoMCwgLTEpID09PSBhY3R1YWxMaW5lXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBkaXZlcmdpbmdMaW5lcyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICBhY3R1YWxMaW5lICs9ICcsJ1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgICAgICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSAnXFxuJy5jb25jYXQoYmx1ZSwgJy4uLicpLmNvbmNhdCh3aGl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbiAgJy5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKVxuICAgICAgICAgICAgICAgICAgICAgIHByaW50ZWRMaW5lcysrXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gJ1xcbiAgJy5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKVxuICAgICAgICAgICAgICAgICAgICBwcmludGVkTGluZXMrK1xuICAgICAgICAgICAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuICAgICAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0IGFuZCBjYWNoZSB0aGUgZXhwZWN0ZWQgZGl2ZXJnaW5nXG4gICAgICAgICAgICAgICAgICAvLyBsaW5lIHNvIGNvbnNlY3V0aXZlIGRpdmVyZ2luZyBsaW5lcyBzaG93IHVwIGFzICsrKy0tLSBhbmQgbm90ICstKy0rLS5cblxuICAgICAgICAgICAgICAgICAgcmVzICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZ3JlZW4sICcrJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh3aGl0ZSwgJyAnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFjdHVhbExpbmUpXG4gICAgICAgICAgICAgICAgICBvdGhlciArPSAnXFxuJ1xuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlZCwgJy0nKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHdoaXRlLCAnICcpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZXhwZWN0ZWRMaW5lKVxuICAgICAgICAgICAgICAgICAgcHJpbnRlZExpbmVzICs9IDIgLy8gTGluZXMgYXJlIGlkZW50aWNhbFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIGNhY2hlZCBpbmZvcm1hdGlvbiB0byB0aGUgcmVzdWx0IGJlZm9yZSBhZGRpbmcgb3RoZXIgdGhpbmdzXG4gICAgICAgICAgICAgICAgICAvLyBhbmQgcmVzZXQgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgcmVzICs9IG90aGVyXG4gICAgICAgICAgICAgICAgICBvdGhlciA9ICcnIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIGV4YWN0bHkgb25lIGxpbmUgYWJvdmUgb3IgaWYgaXQgaXMgdGhlXG4gICAgICAgICAgICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgICAgICAgICAgICBpZiAoY3VyID09PSAxIHx8IGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9ICdcXG4gICcuY29uY2F0KGFjdHVhbExpbmUpXG4gICAgICAgICAgICAgICAgICAgIHByaW50ZWRMaW5lcysrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIEluc3BlY3RlZCBvYmplY3QgdG8gYmlnIChTaG93IH4yMCByb3dzIG1heClcblxuICAgICAgICAgICAgICBpZiAocHJpbnRlZExpbmVzID4gMjAgJiYgaSA8IG1heExpbmVzIC0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1zZylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChza2lwcGVkTXNnLCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXMsICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGJsdWUsICcuLi4nKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHdoaXRlKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG90aGVyLCAnXFxuJykgKyAnJy5jb25jYXQoYmx1ZSwgJy4uLicpLmNvbmNhdCh3aGl0ZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICAgIC5jb25jYXQobXNnKVxuICAgICAgICAgICAgICAuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsICdcXG4nKVxuICAgICAgICAgICAgICAuY29uY2F0KHJlcylcbiAgICAgICAgICAgICAgLmNvbmNhdChvdGhlcilcbiAgICAgICAgICAgICAgLmNvbmNhdChlbmQpXG4gICAgICAgICAgICAgIC5jb25jYXQoaW5kaWNhdG9yKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBBc3NlcnRpb25FcnJvciA9XG4gICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAoZnVuY3Rpb24gKF9FcnJvcikge1xuICAgICAgICAgICAgICBfaW5oZXJpdHMoQXNzZXJ0aW9uRXJyb3IsIF9FcnJvcilcblxuICAgICAgICAgICAgICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzXG5cbiAgICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNzZXJ0aW9uRXJyb3IpXG5cbiAgICAgICAgICAgICAgICBpZiAoX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0Rm4gPSBvcHRpb25zLnN0YWNrU3RhcnRGblxuICAgICAgICAgICAgICAgIHZhciBhY3R1YWwgPSBvcHRpb25zLmFjdHVhbCxcbiAgICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZFxuICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdFxuICAgICAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDBcblxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBvbiBlYWNoIGNhbGwgdG8gbWFrZSBzdXJlIHdlIGhhbmRsZSBkeW5hbWljYWxseSBzZXQgZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGVzIGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZGVyciAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiZcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoKCkgIT09IDFcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYmx1ZSA9ICdcXHgxQlszNG0nXG4gICAgICAgICAgICAgICAgICAgICAgZ3JlZW4gPSAnXFx4MUJbMzJtJ1xuICAgICAgICAgICAgICAgICAgICAgIHdoaXRlID0gJ1xceDFCWzM5bSdcbiAgICAgICAgICAgICAgICAgICAgICByZWQgPSAnXFx4MUJbMzFtJ1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGJsdWUgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgIGdyZWVuID0gJydcbiAgICAgICAgICAgICAgICAgICAgICB3aGl0ZSA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgcmVkID0gJydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSAvLyBQcmV2ZW50IHRoZSBlcnJvciBzdGFjayBmcm9tIGJlaW5nIHZpc2libGUgYnkgZHVwbGljYXRpbmcgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICAvLyBpbiBhIHZlcnkgY2xvc2Ugd2F5IHRvIHRoZSBvcmlnaW5hbCBpbiBjYXNlIGJvdGggc2lkZXMgYXJlIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZXMgb2YgRXJyb3IuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICBhY3R1YWwgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICdzdGFjaycgaW4gYWN0dWFsICYmXG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICdzdGFjaycgaW4gZXhwZWN0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gY29weUVycm9yKGV4cGVjdGVkKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSAnZGVlcFN0cmljdEVxdWFsJyB8fFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJ1xuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcilcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSAnbm90RGVlcFN0cmljdEVxdWFsJyB8fFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJ1xuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCkuc3BsaXQoJ1xcbicpIC8vIEluIGNhc2UgXCJhY3R1YWxcIiBpcyBhbiBvYmplY3QsIGl0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlIGVxdWFsLlxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICBhY3R1YWwgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzWzI2XSA9ICcnLmNvbmNhdChibHVlLCAnLi4uJykuY29uY2F0KHdoaXRlKVxuXG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlcy5sZW5ndGggPiAyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJycuY29uY2F0KGJhc2UsICcgJykuY29uY2F0KHJlc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICcnLmNvbmNhdChiYXNlLCAnXFxuXFxuJykuY29uY2F0KHJlcy5qb2luKCdcXG4nKSwgJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gJydcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtub3duT3BlcmF0b3JzID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSAnbm90RGVlcEVxdWFsJyB8fFxuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSAnbm90RXF1YWwnXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIF9yZXMgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sICdcXG5cXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChfcmVzKVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlcyA9ICcnLmNvbmNhdChfcmVzLnNsaWNlKDAsIDEwMjEpLCAnLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSAnJy5jb25jYXQoaW5zcGVjdFZhbHVlKGV4cGVjdGVkKSlcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlcyA9ICcnLmNvbmNhdChfcmVzLnNsaWNlKDAsIDUwOSksICcuLi4nKVxuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyID0gJycuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksICcuLi4nKVxuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXMgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGtub3duT3BlcmF0b3JzLCAnXFxuXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChfcmVzLCAnXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSAnICcuY29uY2F0KG9wZXJhdG9yLCAnICcpLmNvbmNhdChvdGhlcilcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcnLmNvbmNhdChfcmVzKS5jb25jYXQob3RoZXIpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXRcbiAgICAgICAgICAgICAgICBfdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2VcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTidcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3R1YWwgPSBhY3R1YWxcbiAgICAgICAgICAgICAgICBfdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvclxuXG4gICAgICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKFxuICAgICAgICAgICAgICAgICAgICBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZuXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSAvLyBDcmVhdGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGUgaW4gdGhlIG5hbWUuXG5cbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFjayAvLyBSZXNldCB0aGUgbmFtZS5cblxuICAgICAgICAgICAgICAgIF90aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEFzc2VydGlvbkVycm9yLCBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMubmFtZSwgJyBbJylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuY29kZSwgJ106ICcpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAga2V5OiBpbnNwZWN0LmN1c3RvbSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZWN1cnNlVGltZXMsIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtaW5pbXVtIGRlcHRoLiBPdGhlcndpc2UgdGhvc2UgdmFsdWVzIHdvdWxkIGJlIHRvbyB2ZXJib3NlIGNvbXBhcmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZSB3aGljaCBjb250YWlucyBhIGNvbWJpbmVkIHZpZXcgb2YgdGhlc2UgdHdvXG4gICAgICAgICAgICAgICAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3BlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICBfb2JqZWN0U3ByZWFkKHt9LCBjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdKVxuXG4gICAgICAgICAgICAgIHJldHVybiBBc3NlcnRpb25FcnJvclxuICAgICAgICAgICAgfSkoX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Vycm9ycy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvaW50ZXJuYWwvZXJyb3JzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvZXJyb3JzLmpzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbiAgICAgICAgICAvKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuICAgICAgICAgIC8qIGVzbGludCBub2RlLWNvcmUvYWxwaGFiZXRpemUtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuICAgICAgICAgIC8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4gICAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4gICAgICAgICAgLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuICAgICAgICAgIC8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxuICAgICAgICAgIC8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3JcbiAgICAgICAgICAvLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICAgICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgPyAnc3ltYm9sJ1xuICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdHlwZW9mKG9iailcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY2FsbCAmJlxuICAgICAgICAgICAgICAoX3R5cGVvZihjYWxsKSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgICAgICAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuICAgICAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXG4gICAgICAgICAgICAgIHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICAgICAgX3NldFByb3RvdHlwZU9mID1cbiAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgICAgICAgICAgby5fX3Byb3RvX18gPSBwXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb2RlcyA9IHt9IC8vIExhenkgbG9hZGVkXG5cbiAgICAgICAgICB2YXIgYXNzZXJ0XG4gICAgICAgICAgdmFyIHV0aWxcblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gICAgICAgICAgICBpZiAoIUJhc2UpIHtcbiAgICAgICAgICAgICAgQmFzZSA9IEVycm9yXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBOb2RlRXJyb3IgPVxuICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgIChmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICAgICAgICAgICAgICBfaW5oZXJpdHMoTm9kZUVycm9yLCBfQmFzZSlcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXNcblxuICAgICAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVFcnJvcilcblxuICAgICAgICAgICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mKE5vZGVFcnJvcikuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMylcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgX3RoaXMuY29kZSA9IGNvZGVcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBOb2RlRXJyb3JcbiAgICAgICAgICAgICAgfSkoQmFzZSlcblxuICAgICAgICAgICAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3JcbiAgICAgICAgICB9IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG4gICAgICAgICAgZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aFxuICAgICAgICAgICAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaSlcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBpZiAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAnb25lIG9mICdcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aGluZywgJyAnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksICcsIG9yICcpICtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdGVkW2xlbiAtIDFdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnb25lIG9mICdcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQodGhpbmcsICcgJylcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoZXhwZWN0ZWRbMF0sICcgb3IgJylcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoZXhwZWN0ZWRbMV0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZiAnLmNvbmNhdCh0aGluZywgJyAnKS5jb25jYXQoZXhwZWN0ZWRbMF0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnb2YgJy5jb25jYXQodGhpbmcsICcgJykuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG4gICAgICAgICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuICAgICAgICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICAgICAgICAgICAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoXG4gICAgICAgICAgfSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuICAgICAgICAgIGZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNyZWF0ZUVycm9yVHlwZShcbiAgICAgICAgICAgICdFUlJfQU1CSUdVT1VTX0FSR1VNRU5UJyxcbiAgICAgICAgICAgICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLFxuICAgICAgICAgICAgVHlwZUVycm9yXG4gICAgICAgICAgKVxuICAgICAgICAgIGNyZWF0ZUVycm9yVHlwZShcbiAgICAgICAgICAgICdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gICAgICAgICAgICBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAgICAgICAgICAgICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgICAgIC8qISAuLi9hc3NlcnQgKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanMnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBcIiduYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIpIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgICAgICAgICAgICAgdmFyIGRldGVybWluZXJcblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSdcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJ1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG1zZ1xuXG4gICAgICAgICAgICAgIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgICAgICAgICAgICAgbXNnID0gJ1RoZSAnXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KG5hbWUsICcgJylcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoZGV0ZXJtaW5lciwgJyAnKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50J1xuICAgICAgICAgICAgICAgIG1zZyA9ICdUaGUgXCInXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KG5hbWUsICdcIiAnKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0eXBlLCAnICcpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KGRldGVybWluZXIsICcgJylcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpXG4gICAgICAgICAgICAgIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuICAgICAgICAgICAgICBtc2cgKz0gJy4gUmVjZWl2ZWQgdHlwZSAnLmNvbmNhdChfdHlwZW9mKGFjdHVhbCkpXG4gICAgICAgICAgICAgIHJldHVybiBtc2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBUeXBlRXJyb3JcbiAgICAgICAgICApXG4gICAgICAgICAgY3JlYXRlRXJyb3JUeXBlKFxuICAgICAgICAgICAgJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsXG4gICAgICAgICAgICBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgID8gYXJndW1lbnRzWzJdXG4gICAgICAgICAgICAgICAgICA6ICdpcyBpbnZhbGlkJ1xuICAgICAgICAgICAgICBpZiAodXRpbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgICAgLyohIHV0aWwvICovICcuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKVxuXG4gICAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkID0gJycuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCAnLi4uJylcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCJcbiAgICAgICAgICAgICAgICAuY29uY2F0KG5hbWUsIFwiJyBcIilcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlYXNvbiwgJy4gUmVjZWl2ZWQgJylcbiAgICAgICAgICAgICAgICAuY29uY2F0KGluc3BlY3RlZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBUeXBlRXJyb3IsXG4gICAgICAgICAgICBSYW5nZUVycm9yXG4gICAgICAgICAgKVxuICAgICAgICAgIGNyZWF0ZUVycm9yVHlwZShcbiAgICAgICAgICAgICdFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgdHlwZVxuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdpbnN0YW5jZSBvZiAnLmNvbmNhdCh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAndHlwZSAnLmNvbmNhdChfdHlwZW9mKHZhbHVlKSlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkICdcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoaW5wdXQsICcgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXCInKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChuYW1lLCAnXCInKSArICcgZnVuY3Rpb24gYnV0IGdvdCAnLmNvbmNhdCh0eXBlLCAnLicpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBUeXBlRXJyb3JcbiAgICAgICAgICApXG4gICAgICAgICAgY3JlYXRlRXJyb3JUeXBlKFxuICAgICAgICAgICAgJ0VSUl9NSVNTSU5HX0FSR1MnLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgICAgICAgX2tleSsrXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgICAgLyohIC4uL2Fzc2VydCAqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2Fzc2VydC5qcydcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpXG4gICAgICAgICAgICAgIHZhciBtc2cgPSAnVGhlICdcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoXG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXCInLmNvbmNhdChhLCAnXCInKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgbXNnICs9ICcnLmNvbmNhdChhcmdzWzBdLCAnIGFyZ3VtZW50JylcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBtc2cgKz0gJydcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChhcmdzWzBdLCAnIGFuZCAnKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGFyZ3NbMV0sICcgYXJndW1lbnRzJylcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKVxuICAgICAgICAgICAgICAgICAgbXNnICs9ICcsIGFuZCAnLmNvbmNhdChhcmdzW2xlbiAtIDFdLCAnIGFyZ3VtZW50cycpXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuICcnLmNvbmNhdChtc2csICcgbXVzdCBiZSBzcGVjaWZpZWQnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFR5cGVFcnJvclxuICAgICAgICAgIClcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanNcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuICAgICAgICAgIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgICAgICAgICAgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHxcbiAgICAgICAgICAgICAgX25vbkl0ZXJhYmxlUmVzdCgpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYXJyID0gW11cbiAgICAgICAgICAgIHZhciBfbiA9IHRydWVcbiAgICAgICAgICAgIHZhciBfZCA9IGZhbHNlXG4gICAgICAgICAgICB2YXIgX2UgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7XG4gICAgICAgICAgICAgICAgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7XG4gICAgICAgICAgICAgICAgX24gPSB0cnVlXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSlcbiAgICAgICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9kID0gdHJ1ZVxuICAgICAgICAgICAgICBfZSA9IGVyclxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSAhPSBudWxsKSBfaVsncmV0dXJuJ10oKVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9hcnJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXG4gICAgICAgICAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgID8gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIG9ialxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3R5cGVvZihvYmopXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPSAvYS9nLmZsYWdzICE9PSB1bmRlZmluZWRcblxuICAgICAgICAgIHZhciBhcnJheUZyb21TZXQgPSBmdW5jdGlvbiBhcnJheUZyb21TZXQoc2V0KSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXVxuICAgICAgICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXVxuICAgICAgICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvYmplY3RJcyA9IE9iamVjdC5pc1xuICAgICAgICAgICAgPyBPYmplY3QuaXNcbiAgICAgICAgICAgIDogX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgICAvKiEgb2JqZWN0LWlzICovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW5kZXguanMnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICB2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuICAgICAgICAgICAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG4gICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciBudW1iZXJJc05hTiA9IE51bWJlci5pc05hTlxuICAgICAgICAgICAgPyBOdW1iZXIuaXNOYU5cbiAgICAgICAgICAgIDogX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgICAvKiEgaXMtbmFuICovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vaW5kZXguanMnXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgIGZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmNhbGwuYmluZChmKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpXG4gICAgICAgICAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBvYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpXG5cbiAgICAgICAgICB2YXIgX3JlcXVpcmUkdHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgdXRpbC8gKi8gJy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcydcbiAgICAgICAgICAgICkudHlwZXMsXG4gICAgICAgICAgICBpc0FueUFycmF5QnVmZmVyID0gX3JlcXVpcmUkdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgICAgICAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgICAgICAgICBpc01hcCA9IF9yZXF1aXJlJHR5cGVzLmlzTWFwLFxuICAgICAgICAgICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICAgICAgICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgICAgICAgICBpc05hdGl2ZUVycm9yID0gX3JlcXVpcmUkdHlwZXMuaXNOYXRpdmVFcnJvcixcbiAgICAgICAgICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgICAgICAgICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICAgICAgICAgIGlzU3RyaW5nT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTdHJpbmdPYmplY3QsXG4gICAgICAgICAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgICAgICAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgICAgICAgICAgaXNTeW1ib2xPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N5bWJvbE9iamVjdCxcbiAgICAgICAgICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgICAgICAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpXG4gICAgICAgICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSAvLyBUaGUgbWF4aW11bSBzaXplIGZvciBhbiBhcnJheSBpcyAyICoqIDMyIC0xLlxuXG4gICAgICAgICAgICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgICAgICAgICAuZmlsdGVyKGlzTm9uSW5kZXgpXG4gICAgICAgICAgICAgIC5jb25jYXQoXG4gICAgICAgICAgICAgICAgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgfSAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuICAgICAgICAgIC8vIG9yaWdpbmFsIG5vdGljZTpcblxuICAgICAgICAgIC8qIVxuICAgICAgICAgICAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gICAgICAgICAgICogQGxpY2Vuc2UgIE1JVFxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeCA9IGEubGVuZ3RoXG4gICAgICAgICAgICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICAgICAgeCA9IGFbaV1cbiAgICAgICAgICAgICAgICB5ID0gYltpXVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHggPCB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA8IHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgT05MWV9FTlVNRVJBQkxFID0gdW5kZWZpbmVkXG4gICAgICAgICAgdmFyIGtTdHJpY3QgPSB0cnVlXG4gICAgICAgICAgdmFyIGtMb29zZSA9IGZhbHNlXG4gICAgICAgICAgdmFyIGtOb0l0ZXJhdG9yID0gMFxuICAgICAgICAgIHZhciBrSXNBcnJheSA9IDFcbiAgICAgICAgICB2YXIga0lzU2V0ID0gMlxuICAgICAgICAgIHZhciBrSXNNYXAgPSAzIC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbiAgICAgICAgICBmdW5jdGlvbiBhcmVTaW1pbGFyUmVnRXhwcyhhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZFxuICAgICAgICAgICAgICA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzXG4gICAgICAgICAgICAgIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PVxuICAgICAgICAgICAgICAgICAgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYXJlU2ltaWxhckZsb2F0QXJyYXlzKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYS5ieXRlTGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGNvbXBhcmUoXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICkgPT09IDBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJlxuICAgICAgICAgICAgICBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgaXNOdW1iZXJPYmplY3QodmFsMikgJiZcbiAgICAgICAgICAgICAgICBvYmplY3RJcyhcbiAgICAgICAgICAgICAgICAgIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLFxuICAgICAgICAgICAgICAgICAgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgaXNTdHJpbmdPYmplY3QodmFsMikgJiZcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT1cbiAgICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGlzQm9vbGVhbk9iamVjdCh2YWwyKSAmJlxuICAgICAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT1cbiAgICAgICAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0JpZ0ludE9iamVjdCh2YWwxKSkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmXG4gICAgICAgICAgICAgICAgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09XG4gICAgICAgICAgICAgICAgICBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmXG4gICAgICAgICAgICAgIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PVxuICAgICAgICAgICAgICAgIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSAvLyBOb3RlczogVHlwZSB0YWdzIGFyZSBoaXN0b3JpY2FsIFtbQ2xhc3NdXSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCBieVxuICAgICAgICAgIC8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbiAgICAgICAgICAvLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4gICAgICAgICAgLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4gICAgICAgICAgLy8gU2luY2UgdGFncyBjYW4gYmUgYWx0ZXJlZCwgdGhleSBvbmx5IHNlcnZlIGZhc3QgZmFpbHVyZXNcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbiAgICAgICAgICAvLyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGF0IGl0J3NcbiAgICAgICAgICAvLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4gICAgICAgICAgLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuICAgICAgICAgIC8vIChlLmcuIGEgVWludDhBcnJheSBhbmQgYSBVaW50MTZBcnJheSB3aXRoIHRoZSBzYW1lIG1lbW9yeSBjb250ZW50XG4gICAgICAgICAgLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEZvciBzdHJpY3QgY29tcGFyaXNvbiwgb2JqZWN0cyBzaG91bGQgaGF2ZVxuICAgICAgICAgIC8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuICAgICAgICAgIC8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cbiAgICAgICAgICBmdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gICAgICAgICAgICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gICAgICAgICAgICBpZiAodmFsMSA9PT0gdmFsMikge1xuICAgICAgICAgICAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZVxuICAgICAgICAgICAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgbnVtYmVySXNOYU4odmFsMSkgJiZcbiAgICAgICAgICAgICAgICAgIG51bWJlcklzTmFOKHZhbDIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgdmFsMSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHZhbDIgPT09IG51bGxcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsMVRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDEpXG4gICAgICAgICAgICB2YXIgdmFsMlRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDIpXG5cbiAgICAgICAgICAgIGlmICh2YWwxVGFnICE9PSB2YWwyVGFnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgICAgICAgICAgICAvLyBDaGVjayBmb3Igc3BhcnNlIGFycmF5cyBhbmQgZ2VuZXJhbCBmYXN0IHBhdGhcbiAgICAgICAgICAgICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGtleXMxID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSlcbiAgICAgICAgICAgICAgdmFyIGtleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSlcblxuICAgICAgICAgICAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpXG4gICAgICAgICAgICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAvLyB3YW4ndCB0byBlYXJseSByZXR1cm4gb3V0IG9mIHRoZSByZXN0IG9mIHRoZSBjaGVja3MuIEhvd2V2ZXIgd2UgY2FuIGNoZWNrXG4gICAgICAgICAgICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuICAgICAgICAgICAgaWYgKHZhbDFUYWcgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoIWlzTWFwKHZhbDEpICYmIGlzTWFwKHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgICghaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RhdGUodmFsMSkpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpc0RhdGUodmFsMikgfHxcbiAgICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMSkgIT09XG4gICAgICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAgICAgICAgICAgLy8gaXMgb3RoZXJ3aXNlIGlkZW50aWNhbC5cbiAgICAgICAgICAgICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlclZpZXcodmFsMSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgICAgICAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAgICAgICAgICAgLy8gb25seSBjb250YWluIG51bWVyaWMga2V5cywgd2UgZG9uJ3QgbmVlZCB0byBleGFtIGZ1cnRoZXIgdGhhbiBjaGVja2luZ1xuICAgICAgICAgICAgICAvLyB0aGUgc3ltYm9scy5cblxuICAgICAgICAgICAgICB2YXIgX2tleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKVxuXG4gICAgICAgICAgICAgIHZhciBfa2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKVxuXG4gICAgICAgICAgICAgIGlmIChfa2V5cy5sZW5ndGggIT09IF9rZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgICAgICAgICAgIGlmICghaXNTZXQodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgICAgICAgICAgIGlmICghaXNNYXAodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFhcmVFcXVhbEFycmF5QnVmZmVycyh2YWwxLCB2YWwyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICBpc0JveGVkUHJpbWl0aXZlKHZhbDEpICYmXG4gICAgICAgICAgICAgICFpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gICAgICAgICAgICAvLyBGb3IgYWxsIHJlbWFpbmluZyBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSwgb2JqZWN0cyBhbmQgTWFwcyxcbiAgICAgICAgICAgIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAgICAgICAgICAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gYikgVGhlIHNhbWUgc2V0IG9mIGtleXMvaW5kZXhlcyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKVxuICAgICAgICAgICAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gICAgICAgICAgICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpXG4gICAgICAgICAgICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpIC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgICAgICAgICAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG4gICAgICAgICAgICB2YXIgaSA9IDBcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSlcblxuICAgICAgICAgICAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMFxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHN5bWJvbEtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV1cblxuICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhS2V5cy5wdXNoKGtleSlcbiAgICAgICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc3ltYm9sS2V5c0EubGVuZ3RoICE9PSBzeW1ib2xLZXlzQi5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgX3N5bWJvbEtleXNCLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGFLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAoaXRlcmF0aW9uVHlwZSA9PT0ga05vSXRlcmF0b3IgfHxcbiAgICAgICAgICAgICAgICAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkgJiYgdmFsMS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgdmFsMS5zaXplID09PSAwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IC8vIFVzZSBtZW1vcyB0byBoYW5kbGUgY3ljbGVzLlxuXG4gICAgICAgICAgICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBtZW1vcyA9IHtcbiAgICAgICAgICAgICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBwcmV2ZW50IHVwIHRvIHR3byBtYXAuaGFzKHgpIGNhbGxzIGJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAgICAgICAgICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgICAgICAgICAgIHZhciB2YWwyTWVtb0EgPSBtZW1vcy52YWwxLmdldCh2YWwxKVxuXG4gICAgICAgICAgICAgIGlmICh2YWwyTWVtb0EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtZW1vcy5wb3NpdGlvbisrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKVxuICAgICAgICAgICAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pXG4gICAgICAgICAgICB2YXIgYXJlRXEgPSBvYmpFcXVpdihcbiAgICAgICAgICAgICAgdmFsMSxcbiAgICAgICAgICAgICAgdmFsMixcbiAgICAgICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgICAgICBhS2V5cyxcbiAgICAgICAgICAgICAgbWVtb3MsXG4gICAgICAgICAgICAgIGl0ZXJhdGlvblR5cGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpXG4gICAgICAgICAgICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKVxuICAgICAgICAgICAgcmV0dXJuIGFyZUVxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgdmFsMSwgc3RyaWN0LCBtZW1vKSB7XG4gICAgICAgICAgICAvLyBHbyBsb29raW5nLlxuICAgICAgICAgICAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwyID0gc2V0VmFsdWVzW2ldXG5cbiAgICAgICAgICAgICAgaWYgKGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgICAgICAgICAgIHNldC5kZWxldGUodmFsMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4gICAgICAgICAgLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuICAgICAgICAgIC8vIHR5cGUgaXMgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50IG9yIGJvb2xlYW4uIFRoZSByZWFzb24gaXMgdGhhdCB0aG9zZSB2YWx1ZXNcbiAgICAgICAgICAvLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG4gICAgICAgICAgZnVuY3Rpb24gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG5cbiAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBwcmltID0gK3ByaW1cbiAgICAgICAgICAgICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgICAgICAgICAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gICAgICAgICAgICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSlcbiAgICAgICAgICAgIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWVcbiAgICAgICAgICAgIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltLCBpdGVtLCBtZW1vKSB7XG4gICAgICAgICAgICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSlcblxuICAgICAgICAgICAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFsdFZhbHVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJCID0gYi5nZXQoYWx0VmFsdWUpXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpKSB8fFxuICAgICAgICAgICAgICAhaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGxhemlseSBpbml0aWF0ZWQgU2V0IG9mIGVudHJpZXMgd2hpY2ggaGF2ZSB0byBiZSBjb21wYXJlZFxuICAgICAgICAgICAgLy8gcGFpcndpc2UuXG4gICAgICAgICAgICB2YXIgc2V0ID0gbnVsbFxuICAgICAgICAgICAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSlcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBhVmFsdWVzW2ldIC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgICAgICAgICAgICAvLyBoZWF2eSBzZXRzIGJ1dCBpdCBpcyBhIG1pbm9yIHNsb3cgZG93biBmb3IgcHJpbWl0aXZlcy4gQXMgdGhleSBhcmUgZmFzdFxuICAgICAgICAgICAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICAgICAgICAgICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgc2V0ID0gbmV3IFNldCgpXG4gICAgICAgICAgICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgICAgICAgICAgIC8vIGh1bnRpbmcgZm9yIHNvbWV0aGluZyB0aGF0cyBkZWVwLShzdHJpY3QtKWVxdWFsIHRvIGl0LiBUbyBtYWtlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cbiAgICAgICAgICAgICAgICBzZXQuYWRkKHZhbClcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghYi5oYXModmFsKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZSAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbCB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBzZXQgPSBuZXcgU2V0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXQuYWRkKHZhbClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpXG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF92YWwgPSBiVmFsdWVzW19pXSAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBtYXRjaGluZyBhbmQgb25seSBpZiBpdCdzIG5vdCwgZ28gaHVudGluZyBmb3IgaXQuXG5cbiAgICAgICAgICAgICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgIXN0cmljdCAmJlxuICAgICAgICAgICAgICAgICAgIWEuaGFzKF92YWwpICYmXG4gICAgICAgICAgICAgICAgICAhc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHNldC5zaXplID09PSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAgICAgICAgICAgLy8gVG8gYmUgYWJsZSB0byBoYW5kbGUgY2FzZXMgbGlrZTpcbiAgICAgICAgICAgIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAgICAgICAgICAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gICAgICAgICAgICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldClcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV1cblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJlxuICAgICAgICAgICAgICAgIGlubmVyRGVlcEVxdWFsKGl0ZW0xLCBtYXAuZ2V0KGtleTIpLCBzdHJpY3QsIG1lbW8pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNldC5kZWxldGUoa2V5MilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAgICAgICAgICAgdmFyIHNldCA9IG51bGxcbiAgICAgICAgICAgIHZhciBhRW50cmllcyA9IGFycmF5RnJvbU1hcChhKVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBfYUVudHJpZXMkaVswXSxcbiAgICAgICAgICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdXG5cbiAgICAgICAgICAgICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgc2V0ID0gbmV3IFNldCgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWUgd2UgcHJldmVudCBhbm90aGVyIGIuaGFzKGtleSkgY2hlY2sgaW5cbiAgICAgICAgICAgICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgICAgICAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSlcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpKSB8fFxuICAgICAgICAgICAgICAgICAgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlIC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgICAgICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgICAgICAgICAgICBpZiAoIW1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBrZXksIGl0ZW0xLCBtZW1vKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgICAgICAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gbmV3IFNldCgpXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBiRW50cmllcyA9IGFycmF5RnJvbU1hcChiKVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGJFbnRyaWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAgICAgICAgICBrZXkgPSBfYkVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdXG5cbiAgICAgICAgICAgICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgc3RyaWN0LCBtZW1vKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICFzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICAgICghYS5oYXMoa2V5KSB8fFxuICAgICAgICAgICAgICAgICAgICAhaW5uZXJEZWVwRXF1YWwoYS5nZXQoa2V5KSwgaXRlbSwgZmFsc2UsIG1lbW8pKSAmJlxuICAgICAgICAgICAgICAgICAgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHNldC5zaXplID09PSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBrZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSkge1xuICAgICAgICAgICAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBpID0gMFxuXG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzU2V0KSB7XG4gICAgICAgICAgICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNNYXApIHtcbiAgICAgICAgICAgICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5KSB7XG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcGVydHkoYiwgaSkgfHxcbiAgICAgICAgICAgICAgICAgICAgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgICAgICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpXG5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNBW2ldXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eShiLCBrZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gICAgICAgICAgICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgX2tleSA9IGtleXNbaV1cblxuICAgICAgICAgICAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0RlZXBFcXVhbCh2YWwxLCB2YWwyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrU3RyaWN0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICAgICAgICAgICAgaXNEZWVwU3RyaWN0RXF1YWw6IGlzRGVlcFN0cmljdEVxdWFsLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9hdmFpbGFibGUtdHlwZWQtYXJyYXlzL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgZmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBhcnJheS1maWx0ZXIgKi8gJy4vbm9kZV9tb2R1bGVzL2FycmF5LWZpbHRlci9pbmRleC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdCaWdJbnQ2NEFycmF5JyxcbiAgICAgICAgICAgICAgICAnQmlnVWludDY0QXJyYXknLFxuICAgICAgICAgICAgICAgICdGbG9hdDMyQXJyYXknLFxuICAgICAgICAgICAgICAgICdGbG9hdDY0QXJyYXknLFxuICAgICAgICAgICAgICAgICdJbnQxNkFycmF5JyxcbiAgICAgICAgICAgICAgICAnSW50MzJBcnJheScsXG4gICAgICAgICAgICAgICAgJ0ludDhBcnJheScsXG4gICAgICAgICAgICAgICAgJ1VpbnQxNkFycmF5JyxcbiAgICAgICAgICAgICAgICAnVWludDMyQXJyYXknLFxuICAgICAgICAgICAgICAgICdVaW50OEFycmF5JyxcbiAgICAgICAgICAgICAgICAnVWludDhDbGFtcGVkQXJyYXknLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9saWIvYXhpb3MgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLy4uL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBzZXR0bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vY29yZS9zZXR0bGUgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGNvb2tpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vaGVscGVycy9jb29raWVzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgYnVpbGRVUkwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vaGVscGVycy9idWlsZFVSTCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBidWlsZEZ1bGxQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb3JlL2J1aWxkRnVsbFBhdGggKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBwYXJzZUhlYWRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGlzVVJMU2FtZU9yaWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbiAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgY3JlYXRlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvcmUvY3JlYXRlRXJyb3IgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhXG4gICAgICAgICAgICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzXG5cbiAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgICAgICAgICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJ1xuICAgICAgICAgICAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkXG4gICAgICAgICAgICAgICAgICA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpXG4gICAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9XG4gICAgICAgICAgICAgICAgICAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpXG4gICAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcbiAgICAgICAgICAgICAgICBjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgICAgICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dFxuXG4gICAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICAgICAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VVUkwgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPVxuICAgICAgICAgICAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VEYXRhID1cbiAgICAgICAgICAgICAgICAgICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgICAgICAgICAgICA/IHJlcXVlc3QucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICAgICAgICAgIDogcmVxdWVzdC5yZXNwb25zZVxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpXG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG51bGxcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICAgICAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1JlcXVlc3QgYWJvcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG51bGxcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSlcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbnVsbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICAgICAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCdcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbnVsbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgICAgICAgICAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgICAgICAgICAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgICAgICAgICAgIHZhciB4c3JmVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiZcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy54c3JmQ29va2llTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgICAgICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJ1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgICAgICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgICAgICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHJlcXVlc3QudXBsb2FkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAncHJvZ3Jlc3MnLFxuICAgICAgICAgICAgICAgICAgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgICAgICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgICAgICAgICByZWplY3QoY2FuY2VsKVxuICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG51bGxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhID0gbnVsbFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9oZWxwZXJzL2JpbmQgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBBeGlvcyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9jb3JlL0F4aW9zICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIG1lcmdlQ29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NvcmUvbWVyZ2VDb25maWcgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vZGVmYXVsdHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZylcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpXG5cbiAgICAgICAgICAgIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gICAgICAgICAgICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dClcblxuICAgICAgICAgICAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gICAgICAgICAgICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpXG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxuICAgICAgICAgIHZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKVxuXG4gICAgICAgICAgLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG4gICAgICAgICAgYXhpb3MuQXhpb3MgPSBBeGlvc1xuXG4gICAgICAgICAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICAgICAgICAgIGF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG4gICAgICAgICAgYXhpb3MuQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NhbmNlbC9DYW5jZWwgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBheGlvcy5DYW5jZWxUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9jYW5jZWwvQ2FuY2VsVG9rZW4gKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGF4aW9zLmlzQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NhbmNlbC9pc0NhbmNlbCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvLyBFeHBvc2UgYWxsL3NwcmVhZFxuICAgICAgICAgIGF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgIH1cbiAgICAgICAgICBheGlvcy5zcHJlYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaGVscGVycy9zcHJlYWQgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG4gICAgICAgICAgYXhpb3MuaXNBeGlvc0Vycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2hlbHBlcnMvaXNBeGlvc0Vycm9yICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBheGlvc1xuXG4gICAgICAgICAgLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIENhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL0NhbmNlbCAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBjbGFzc1xuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc29sdmVQcm9taXNlXG4gICAgICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXNcbiAgICAgICAgICAgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSlcbiAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIENhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLnJlYXNvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAgICAgICAgICAgKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIENhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgICAgICAgICAgIHZhciBjYW5jZWxcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgICAgICAgICAgIGNhbmNlbCA9IGNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW5cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vdXRpbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGJ1aWxkVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9oZWxwZXJzL2J1aWxkVVJMICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIEludGVyY2VwdG9yTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9JbnRlcmNlcHRvck1hbmFnZXIgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGRpc3BhdGNoUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9kaXNwYXRjaFJlcXVlc3QgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIG1lcmdlQ29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL21lcmdlQ29uZmlnICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWdcbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgICAgICAgICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBBeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gICAgICAgICAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAgICAgICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge31cbiAgICAgICAgICAgICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZylcblxuICAgICAgICAgICAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgICAgICAgICAgIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICAgICAgICAgICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0J1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gICAgICAgICAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpXG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChcbiAgICAgICAgICAgICAgZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICAgICAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIEF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRVUkwoXG4gICAgICAgICAgICAgIGNvbmZpZy51cmwsXG4gICAgICAgICAgICAgIGNvbmZpZy5wYXJhbXMsXG4gICAgICAgICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyXG4gICAgICAgICAgICApLnJlcGxhY2UoL15cXD8vLCAnJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbiAgICAgICAgICB1dGlscy5mb3JFYWNoKFxuICAgICAgICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgICAgICAgICAgICAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgICAgICAgICAgICAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgbWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdXRpbHMuZm9yRWFjaChcbiAgICAgICAgICAgIFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgICAgICAgICAgICAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgICAgICAgICAgICAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgbWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlvc1xuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLy4uL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gICAgICAgICAgICovXG4gICAgICAgICAgSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgICAgICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gICAgICAgICAgICovXG4gICAgICAgICAgSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gICAgICAgICAgICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICAgICAgICAgICAqL1xuICAgICAgICAgIEludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgICAgICAgICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZuKGgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXJcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgaXNBYnNvbHV0ZVVSTCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vaGVscGVycy9pc0Fic29sdXRlVVJMICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgY29tYmluZVVSTHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2hlbHBlcnMvY29tYmluZVVSTHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gICAgICAgICAgICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICAgICAgICAgICAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgICAgICAgICAgIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRVUkxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBlbmhhbmNlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vZW5oYW5jZUVycm9yICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gICAgICAgICAgICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgICAgICAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vdXRpbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIHRyYW5zZm9ybURhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vdHJhbnNmb3JtRGF0YSAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGlzQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jYW5jZWwvaXNDYW5jZWwgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vZGVmYXVsdHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZylcblxuICAgICAgICAgICAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge31cblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgICAgICBjb25maWcuZGF0YSxcbiAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMsXG4gICAgICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgICAgICAgICAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnNcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChcbiAgICAgICAgICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyXG5cbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKVxuXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKVxuXG4gICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgICAgICAgICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAgICAgICAgICAgKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZXJyb3IuY29uZmlnID0gY29uZmlnXG4gICAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdFxuICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZVxuICAgICAgICAgICAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZVxuXG4gICAgICAgICAgICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gU3RhbmRhcmRcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gTW96aWxsYVxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgICAgICAgICAgIC8vIEF4aW9zXG4gICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvclxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAgICAgICAgICAgKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcyID0gY29uZmlnMiB8fCB7fVxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHt9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ11cbiAgICAgICAgICAgIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgICAgICAgICAgICdiYXNlVVJMJyxcbiAgICAgICAgICAgICAgJ3RyYW5zZm9ybVJlcXVlc3QnLFxuICAgICAgICAgICAgICAndHJhbnNmb3JtUmVzcG9uc2UnLFxuICAgICAgICAgICAgICAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgICAgICAgICAgICd0aW1lb3V0JyxcbiAgICAgICAgICAgICAgJ3RpbWVvdXRNZXNzYWdlJyxcbiAgICAgICAgICAgICAgJ3dpdGhDcmVkZW50aWFscycsXG4gICAgICAgICAgICAgICdhZGFwdGVyJyxcbiAgICAgICAgICAgICAgJ3Jlc3BvbnNlVHlwZScsXG4gICAgICAgICAgICAgICd4c3JmQ29va2llTmFtZScsXG4gICAgICAgICAgICAgICd4c3JmSGVhZGVyTmFtZScsXG4gICAgICAgICAgICAgICdvblVwbG9hZFByb2dyZXNzJyxcbiAgICAgICAgICAgICAgJ29uRG93bmxvYWRQcm9ncmVzcycsXG4gICAgICAgICAgICAgICdkZWNvbXByZXNzJyxcbiAgICAgICAgICAgICAgJ21heENvbnRlbnRMZW5ndGgnLFxuICAgICAgICAgICAgICAnbWF4Qm9keUxlbmd0aCcsXG4gICAgICAgICAgICAgICdtYXhSZWRpcmVjdHMnLFxuICAgICAgICAgICAgICAndHJhbnNwb3J0JyxcbiAgICAgICAgICAgICAgJ2h0dHBBZ2VudCcsXG4gICAgICAgICAgICAgICdodHRwc0FnZW50JyxcbiAgICAgICAgICAgICAgJ2NhbmNlbFRva2VuJyxcbiAgICAgICAgICAgICAgJ3NvY2tldFBhdGgnLFxuICAgICAgICAgICAgICAncmVzcG9uc2VFbmNvZGluZycsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgICAgICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzb3VyY2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgICAgICAgICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1dGlscy5mb3JFYWNoKFxuICAgICAgICAgICAgICB2YWx1ZUZyb21Db25maWcyS2V5cyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKVxuXG4gICAgICAgICAgICB1dGlscy5mb3JFYWNoKFxuICAgICAgICAgICAgICBkZWZhdWx0VG9Db25maWcyS2V5cyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgICAgICAgICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgICAgICAgICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgICAgICAgICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgICAgICAgICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKVxuXG4gICAgICAgICAgICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMoY29uZmlnMSlcbiAgICAgICAgICAgICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKVxuXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGNyZWF0ZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NyZWF0ZUVycm9yICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFyZXNwb25zZS5zdGF0dXMgfHxcbiAgICAgICAgICAgICAgIXZhbGlkYXRlU3RhdHVzIHx8XG4gICAgICAgICAgICAgIHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLy4uL3V0aWxzICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gICAgICAgICAgICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgICAgICAgICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgICAgICAgICAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHByb2Nlc3MvYnJvd3NlciAqLyAnLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiZcbiAgICAgICAgICAgICAgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICAgICAgICAgICAgdmFyIGFkYXB0ZXJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICAgICAgICAgICAgYWRhcHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgICAgLyohIC4vYWRhcHRlcnMveGhyICovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgICAgICAgICAgIGFkYXB0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAgIC8qISAuL2FkYXB0ZXJzL2h0dHAgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICAgICAgICAgICAgdHJhbnNmb3JtUmVxdWVzdDogW1xuICAgICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKVxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgdXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgICAgICAgICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgICAgICAgICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgICAgICAgICAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICAgICAgICAgICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgICAgICAgICAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5idWZmZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCdcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBbXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZ25vcmUgKi9cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAgICAgICAgICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxuXG4gICAgICAgICAgICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICAgICAgICAgICAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gICAgICAgICAgICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgICAgICAgICAgIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gICAgICAgICAgICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0cy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmZvckVhY2goXG4gICAgICAgICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLFxuICAgICAgICAgICAgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG5cbiAgICAgICAgICB1dGlscy5mb3JFYWNoKFxuICAgICAgICAgICAgWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLFxuICAgICAgICAgICAgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAgICAgICAgICAgICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvJTNBL2dpLCAnOicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8lMjQvZywgJyQnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvJTJDL2dpLCAnLCcpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8lMjAvZywgJysnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvJTVCL2dpLCAnWycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC8lNUQvZ2ksICddJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgICAgICAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAgICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRQYXJhbXNcbiAgICAgICAgICAgIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgICAgICAgICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgICAgICAgICAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdXG5cbiAgICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGtleSA9IGtleSArICdbXSdcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsID0gW3ZhbF1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgICAgICAgICAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJylcbiAgICAgICAgICAgICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVybFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTFxuICAgICAgICAgICAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgK1xuICAgICAgICAgICAgICAgICAgJy8nICtcbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgICAgICAgICAgIDogYmFzZVVSTFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vdXRpbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KClcbiAgICAgICAgICAgID8gLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgICAgICAgICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXMsXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgc2VjdXJlXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IFtdXG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbilcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpXG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgIDogLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgICAgICAgICAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gICAgICAgICAgICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gICAgICAgICAgICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgICAgICAgICAgIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICAgICAgICAgICAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8uLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKVxuICAgICAgICAgICAgPyAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgICAgICAgICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICAgICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpblVSTFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSB1cmxcblxuICAgICAgICAgICAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKVxuICAgICAgICAgICAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZlxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKVxuXG4gICAgICAgICAgICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2xcbiAgICAgICAgICAgICAgICAgICAgICA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2hcbiAgICAgICAgICAgICAgICAgICAgICA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaFxuICAgICAgICAgICAgICAgICAgICAgID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKVxuICAgICAgICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6XG4gICAgICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZilcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gdXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTClcbiAgICAgICAgICAgICAgICAgICAgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpXG4gICAgICAgICAgICAgICAgICAgIDogcmVxdWVzdFVSTFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICA6IC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgICAgICAgICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi91dGlscyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBub3JtYWxpemVkTmFtZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJlxuICAgICAgICAgICAgICAgIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vLi4vdXRpbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuICAgICAgICAgIC8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbiAgICAgICAgICB2YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICAgICAgICAgICAnYWdlJyxcbiAgICAgICAgICAgICdhdXRob3JpemF0aW9uJyxcbiAgICAgICAgICAgICdjb250ZW50LWxlbmd0aCcsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJyxcbiAgICAgICAgICAgICdldGFnJyxcbiAgICAgICAgICAgICdleHBpcmVzJyxcbiAgICAgICAgICAgICdmcm9tJyxcbiAgICAgICAgICAgICdob3N0JyxcbiAgICAgICAgICAgICdpZi1tb2RpZmllZC1zaW5jZScsXG4gICAgICAgICAgICAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICAgICAgICAgICAnbGFzdC1tb2RpZmllZCcsXG4gICAgICAgICAgICAnbG9jYXRpb24nLFxuICAgICAgICAgICAgJ21heC1mb3J3YXJkcycsXG4gICAgICAgICAgICAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICAgICAgICAgICAncmVmZXJlcicsXG4gICAgICAgICAgICAncmV0cnktYWZ0ZXInLFxuICAgICAgICAgICAgJ3VzZXItYWdlbnQnLFxuICAgICAgICAgIF1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gICAgICAgICAgICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gICAgICAgICAgICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICAgICAgICAgICAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0ge31cbiAgICAgICAgICAgIHZhciBrZXlcbiAgICAgICAgICAgIHZhciB2YWxcbiAgICAgICAgICAgIHZhciBpXG5cbiAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgICAgICAgICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKVxuICAgICAgICAgICAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKVxuXG4gICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogIGBgYGpzXG4gICAgICAgICAgICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAgICAgICAgICAgKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gICAgICAgICAgICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICogIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgYGBganNcbiAgICAgICAgICAgKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICAgICAgICAgICAqICBgYGBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9oZWxwZXJzL2JpbmQgKi8gJy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbiAgICAgICAgICAvLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG4gICAgICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdmFsICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICFpc1VuZGVmaW5lZCh2YWwpICYmXG4gICAgICAgICAgICAgIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKSAmJlxuICAgICAgICAgICAgICB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbCAmJiB2YWwuYnVmZmVyICYmIHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgICAgICAgICAgIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbClcbiAgICAgICAgICAgIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gICAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICAgICAgICAgICAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIHdlYiB3b3JrZXJzOlxuICAgICAgICAgICAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICAgICAgICAgICAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiByZWFjdC1uYXRpdmU6XG4gICAgICAgICAgICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAgICAgICAgICAgKiBuYXRpdmVzY3JpcHRcbiAgICAgICAgICAgKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAgICAgICAgICAgKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gICAgICAgICAgICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAgICAgICAgICAgb2JqID0gW29ial1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAgICAgICAgICAgKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gICAgICAgICAgICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIGBgYGpzXG4gICAgICAgICAgICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICAgICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge31cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFba2V5XSA9IHZhbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhmZWZmKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudFxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgICAgIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gICAgICAgICAgICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICAgICAgICAgICAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICAgICAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICAgICAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICAgICAgICAgICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRGF0ZTogaXNEYXRlLFxuICAgICAgICAgICAgaXNGaWxlOiBpc0ZpbGUsXG4gICAgICAgICAgICBpc0Jsb2I6IGlzQmxvYixcbiAgICAgICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgICAgICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gICAgICAgICAgICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gICAgICAgICAgICBmb3JFYWNoOiBmb3JFYWNoLFxuICAgICAgICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICAgICAgICB0cmltOiB0cmltLFxuICAgICAgICAgICAgc3RyaXBCT006IHN0cmlwQk9NLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBnZXQtaW50cmluc2ljICovICcuL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi8gKi8gJy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG4gICAgICAgICAgICB2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludHJpbnNpY1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBmdW5jdGlvbi1iaW5kICovICcuL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBnZXQtaW50cmluc2ljICovICcuL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJylcbiAgICAgICAgICB2YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKVxuICAgICAgICAgIHZhciAkcmVmbGVjdEFwcGx5ID1cbiAgICAgICAgICAgIEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpXG5cbiAgICAgICAgICB2YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpXG4gICAgICAgICAgdmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKVxuICAgICAgICAgIHZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJylcblxuICAgICAgICAgIGlmICgkZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG4gICAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eSA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgaWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgZGVzYyA9ICRnT1BEKGZ1bmMsICdsZW5ndGgnKVxuICAgICAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcbiAgICAgICAgICAgICAgICAkZGVmaW5lUHJvcGVydHkoZnVuYywgJ2xlbmd0aCcsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOlxuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgIC8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbiAgICAgICAgICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgdXRpbCAqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBhc3NlcnQgKi8gJy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgIHZhciBjb25zb2xlXG4gICAgICAgICAgdmFyIHRpbWVzID0ge31cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuY29uc29sZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18uZy5jb25zb2xlXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUgPSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmdW5jdGlvbnMgPSBbXG4gICAgICAgICAgICBbbG9nLCAnbG9nJ10sXG4gICAgICAgICAgICBbaW5mbywgJ2luZm8nXSxcbiAgICAgICAgICAgIFt3YXJuLCAnd2FybiddLFxuICAgICAgICAgICAgW2Vycm9yLCAnZXJyb3InXSxcbiAgICAgICAgICAgIFt0aW1lLCAndGltZSddLFxuICAgICAgICAgICAgW3RpbWVFbmQsICd0aW1lRW5kJ10sXG4gICAgICAgICAgICBbdHJhY2UsICd0cmFjZSddLFxuICAgICAgICAgICAgW2RpciwgJ2RpciddLFxuICAgICAgICAgICAgW2NvbnNvbGVBc3NlcnQsICdhc3NlcnQnXSxcbiAgICAgICAgICBdXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgICAgICAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHR1cGxlWzFdXG5cbiAgICAgICAgICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29uc29sZVxuXG4gICAgICAgICAgZnVuY3Rpb24gbG9nKCkge31cblxuICAgICAgICAgIGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gd2FybigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgICAgICAgICAgdGltZXNbbGFiZWxdID0gbm93KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgICAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBsYWJlbDogJyArIGxhYmVsKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgdGltZXNbbGFiZWxdXG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGxhYmVsICsgJzogJyArIGR1cmF0aW9uICsgJ21zJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0cmFjZSgpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgICAgICAgICAgZXJyLm5hbWUgPSAnVHJhY2UnXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChvYmplY3QpICsgJ1xcbicpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY29uc29sZUFzc2VydChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgb2JqZWN0LWtleXMgKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgaGFzU3ltYm9scyA9XG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJ2ZvbycpID09PSAnc3ltYm9sJ1xuXG4gICAgICAgICAgdmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAgIHZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0XG4gICAgICAgICAgdmFyIG9yaWdEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuXG4gICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvcmlnRGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSlcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICBmb3IgKHZhciBfIGluIG9iaikge1xuICAgICAgICAgICAgICAgIC8vIGpzY3M6aWdub3JlIGRpc2FsbG93VW51c2VkVmFyaWFibGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG9iai54ID09PSBvYmpcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLyogdGhpcyBpcyBJRSA4LiAqL1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPVxuICAgICAgICAgICAgb3JpZ0RlZmluZVByb3BlcnR5ICYmIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQoKVxuXG4gICAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gb2JqZWN0ICYmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICBvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fVxuICAgICAgICAgICAgdmFyIHByb3BzID0ga2V5cyhtYXApXG4gICAgICAgICAgICBpZiAoaGFzU3ltYm9scykge1xuICAgICAgICAgICAgICBwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICBwcm9wc1tpXSxcbiAgICAgICAgICAgICAgICBtYXBbcHJvcHNbaV1dLFxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZXNbcHJvcHNbaV1dXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnNcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllc1xuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBnZXQtaW50cmluc2ljICovICcuL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJylcbiAgICAgICAgICBpZiAoJGdPUEQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICRnT1BEKFtdLCAnbGVuZ3RoJylcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuICAgICAgICAgICAgICAkZ09QRCA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9ICRnT1BEXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2VzNi1vYmplY3QtYXNzaWduL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ29kZSByZWZhY3RvcmVkIGZyb20gTW96aWxsYSBEZXZlbG9wZXIgTmV0d29yazpcbiAgICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBmaXJzdCBhcmd1bWVudCB0byBvYmplY3QnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV1cbiAgICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbmV4dEluZGV4IDwgbGVuO1xuICAgICAgICAgICAgICAgIG5leHRJbmRleCsrXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF1cbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSlcbiAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXNzaWduLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgYXNzaWduOiBhc3NpZ24sXG4gICAgICAgICAgICBwb2x5ZmlsbDogcG9seWZpbGwsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBjb25zb2xlLWJyb3dzZXJpZnkgKi8gJy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICAgICAgICAgIC8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAgICAgICAgICAvLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAgICAgICAgICAvLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gICAgICAgICAgLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICAgICAgICAgIC8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuICAgICAgICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAgICAgICAgICAvLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAgICAgICAgICAvLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gICAgICAgICAgLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICAgICAgICAgIC8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuICAgICAgICAgIC8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICAgICAgICAgIC8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAgICAgICAgICAvLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAgICAgICAgdmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxuICAgICAgICAgIHZhciBSZWZsZWN0QXBwbHkgPVxuICAgICAgICAgICAgUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICA/IFIuYXBwbHlcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFJlZmxlY3RPd25LZXlzXG4gICAgICAgICAgaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbiAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChcbiAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBOdW1iZXJJc05hTiA9XG4gICAgICAgICAgICBOdW1iZXIuaXNOYU4gfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgICAgIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcylcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXJcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZVxuXG4gICAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG4gICAgICAgICAgRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlclxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbiAgICAgICAgICAvLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuICAgICAgICAgIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTBcblxuICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgbGlzdGVuZXJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgICAgICBhcmcgK1xuICAgICAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4gICAgICAgICAgLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgICAnVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgICAgbiArXG4gICAgICAgICAgICAgICAgICAnLidcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgICAgICAgICAgIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pXG4gICAgICAgICAgICB2YXIgZG9FcnJvciA9IHR5cGUgPT09ICdlcnJvcidcblxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1xuICAgICAgICAgICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgZWxzZSBpZiAoIWRvRXJyb3IpIHJldHVybiBmYWxzZVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgICAgICAgICBpZiAoZG9FcnJvcikge1xuICAgICAgICAgICAgICB2YXIgZXJcbiAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgZXIgPSBhcmdzWzBdXG4gICAgICAgICAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAgICAgICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBlciAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIGVyci5jb250ZXh0ID0gZXJcbiAgICAgICAgICAgICAgdGhyb3cgZXJyIC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdXG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGhcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgICAgICAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgICAgICAgICAgIHZhciBtXG4gICAgICAgICAgICB2YXIgZXZlbnRzXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdcblxuICAgICAgICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcilcblxuICAgICAgICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHNcbiAgICAgICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICAgICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgICAgICAgICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICAgICAgICAgICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmVtaXQoXG4gICAgICAgICAgICAgICAgICAnbmV3TGlzdGVuZXInLFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICAgICAgICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lclxuICAgICAgICAgICAgICArK3RhcmdldC5fZXZlbnRzQ291bnRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgICAgICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmRcbiAgICAgICAgICAgICAgICAgID8gW2xpc3RlbmVyLCBleGlzdGluZ11cbiAgICAgICAgICAgICAgICAgIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcilcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgICAgICAgICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldClcbiAgICAgICAgICAgICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWVcbiAgICAgICAgICAgICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICAgIHZhciB3ID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgICAgIFN0cmluZyh0eXBlKSArXG4gICAgICAgICAgICAgICAgICAgICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnXG4gICAgICAgICAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgdy50eXBlID0gdHlwZVxuICAgICAgICAgICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGhcbiAgICAgICAgICAgICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGxpc3RlbmVyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lclxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbGlzdGVuZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbilcbiAgICAgICAgICAgICAgdGhpcy5maXJlZCA9IHRydWVcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgZmlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB3cmFwRm46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSlcbiAgICAgICAgICAgIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lclxuICAgICAgICAgICAgc3RhdGUud3JhcEZuID0gd3JhcHBlZFxuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGxpc3RlbmVyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbGlzdGVuZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyXG5cbiAgICAgICAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpXG5cbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1xuICAgICAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpc1xuXG4gICAgICAgICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdXG4gICAgICAgICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpc1xuXG4gICAgICAgICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXVxuICAgICAgICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBwb3NpdGlvbiA9IC0xXG5cbiAgICAgICAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSByZXR1cm4gdGhpc1xuXG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCkgbGlzdC5zaGlmdCgpXG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbilcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgZXZlbnRzW3R5cGVdID0gbGlzdFswXVxuXG4gICAgICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXJcblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpXG5cbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1xuICAgICAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpc1xuXG4gICAgICAgICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZSBldmVudHNbdHlwZV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKVxuICAgICAgICAgICAgICB2YXIga2V5XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXVxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpXG4gICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50c1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiBbXVxuXG4gICAgICAgICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXVxuICAgICAgICAgICAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdXG5cbiAgICAgICAgICAgIHJldHVybiB1bndyYXBcbiAgICAgICAgICAgICAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcilcbiAgICAgICAgICAgICAgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnRcbiAgICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNcblxuICAgICAgICAgICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgIH1cblxuICAgICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgY29weVtpXSA9IGFycltpXVxuICAgICAgICAgICAgcmV0dXJuIGNvcHlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICAgICAgICAgICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV1cbiAgICAgICAgICAgIGxpc3QucG9wKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwge1xuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwge1xuICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIGVtaXR0ZXIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICBmbGFnc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgICAgICAgICAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgICAgICAgICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgICAgICAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgICAgICAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihhcmcpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICtcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBlbWl0dGVyXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAgICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGwgPSBvYmoubGVuZ3RoXG4gICAgICAgICAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iailcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID1cbiAgICAgICAgICAgIHR5cGVvZiBzZWxmID09ICdvYmplY3QnID8gc2VsZi5Gb3JtRGF0YSA6IHdpbmRvdy5Gb3JtRGF0YVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICAvKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbiAgICAgICAgICB2YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICdcbiAgICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgICAgdmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cbiAgICAgICAgICAgIHZhciBib3VuZFxuICAgICAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhhdCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpXG4gICAgICAgICAgICB2YXIgYm91bmRBcmdzID0gW11cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZCA9IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAnYmluZGVyJyxcbiAgICAgICAgICAgICAgJ3JldHVybiBmdW5jdGlvbiAoJyArXG4gICAgICAgICAgICAgICAgYm91bmRBcmdzLmpvaW4oJywnKSArXG4gICAgICAgICAgICAgICAgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9J1xuICAgICAgICAgICAgKShiaW5kZXIpXG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge31cbiAgICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZVxuICAgICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKVxuICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBib3VuZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaW1wbGVtZW50YXRpb24gKi8gJy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvblxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciB1bmRlZmluZWRcblxuICAgICAgICAgIHZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvclxuICAgICAgICAgIHZhciAkRnVuY3Rpb24gPSBGdW5jdGlvblxuICAgICAgICAgIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yXG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgICB2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiAkRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7J1xuICAgICAgICAgICAgICApKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgIGlmICgkZ09QRCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgJGdPUEQoe30sICcnKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAkZ09QRCA9IG51bGwgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKClcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcbiAgICAgICAgICAgID8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5jYWxsZWUgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dUeXBlRXJyb3JcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldFxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZ09QRHRocm93cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dUeXBlRXJyb3JcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgIDogdGhyb3dUeXBlRXJyb3JcblxuICAgICAgICAgIHZhciBoYXNTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBoYXMtc3ltYm9scyAqLyAnLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMnXG4gICAgICAgICAgKSgpXG5cbiAgICAgICAgICB2YXIgZ2V0UHJvdG8gPVxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4geC5fX3Byb3RvX19cbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG4gICAgICAgICAgdmFyIG5lZWRzRXZhbCA9IHt9XG5cbiAgICAgICAgICB2YXIgVHlwZWRBcnJheSA9XG4gICAgICAgICAgICB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KVxuXG4gICAgICAgICAgdmFyIElOVFJJTlNJQ1MgPSB7XG4gICAgICAgICAgICAnJUFnZ3JlZ2F0ZUVycm9yJSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogQWdncmVnYXRlRXJyb3IsXG4gICAgICAgICAgICAnJUFycmF5JSc6IEFycmF5LFxuICAgICAgICAgICAgJyVBcnJheUJ1ZmZlciUnOlxuICAgICAgICAgICAgICB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9sc1xuICAgICAgICAgICAgICA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuICAgICAgICAgICAgJyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG4gICAgICAgICAgICAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuICAgICAgICAgICAgJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcbiAgICAgICAgICAgICclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuICAgICAgICAgICAgJyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG4gICAgICAgICAgICAnJUJvb2xlYW4lJzogQm9vbGVhbixcbiAgICAgICAgICAgICclRGF0YVZpZXclJzpcbiAgICAgICAgICAgICAgdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuICAgICAgICAgICAgJyVEYXRlJSc6IERhdGUsXG4gICAgICAgICAgICAnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG4gICAgICAgICAgICAnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG4gICAgICAgICAgICAnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG4gICAgICAgICAgICAnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG4gICAgICAgICAgICAnJUVycm9yJSc6IEVycm9yLFxuICAgICAgICAgICAgJyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuICAgICAgICAgICAgJyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuICAgICAgICAgICAgJyVGbG9hdDMyQXJyYXklJzpcbiAgICAgICAgICAgICAgdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG4gICAgICAgICAgICAnJUZsb2F0NjRBcnJheSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcbiAgICAgICAgICAgICclRmluYWxpemF0aW9uUmVnaXN0cnklJzpcbiAgICAgICAgICAgICAgdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcbiAgICAgICAgICAgICclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuICAgICAgICAgICAgJyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG4gICAgICAgICAgICAnJUludDhBcnJheSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcbiAgICAgICAgICAgICclSW50MTZBcnJheSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuICAgICAgICAgICAgJyVJbnQzMkFycmF5JSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG4gICAgICAgICAgICAnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuICAgICAgICAgICAgJyVpc05hTiUnOiBpc05hTixcbiAgICAgICAgICAgICclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9sc1xuICAgICAgICAgICAgICA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcbiAgICAgICAgICAgICclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzpcbiAgICAgICAgICAgICAgdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHNcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG4gICAgICAgICAgICAnJU1hdGglJzogTWF0aCxcbiAgICAgICAgICAgICclTnVtYmVyJSc6IE51bWJlcixcbiAgICAgICAgICAgICclT2JqZWN0JSc6IE9iamVjdCxcbiAgICAgICAgICAgICclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuICAgICAgICAgICAgJyVwYXJzZUludCUnOiBwYXJzZUludCxcbiAgICAgICAgICAgICclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuICAgICAgICAgICAgJyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG4gICAgICAgICAgICAnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG4gICAgICAgICAgICAnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcbiAgICAgICAgICAgICclUmVnRXhwJSc6IFJlZ0V4cCxcbiAgICAgICAgICAgICclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuICAgICAgICAgICAgJyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOlxuICAgICAgICAgICAgICB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9sc1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcbiAgICAgICAgICAgICclU2hhcmVkQXJyYXlCdWZmZXIlJzpcbiAgICAgICAgICAgICAgdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBTaGFyZWRBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICclU3RyaW5nJSc6IFN0cmluZyxcbiAgICAgICAgICAgICclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9sc1xuICAgICAgICAgICAgICA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG4gICAgICAgICAgICAnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuICAgICAgICAgICAgJyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG4gICAgICAgICAgICAnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuICAgICAgICAgICAgJyVVaW50OEFycmF5JSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG4gICAgICAgICAgICAnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogVWludDhDbGFtcGVkQXJyYXksXG4gICAgICAgICAgICAnJVVpbnQxNkFycmF5JSc6XG4gICAgICAgICAgICAgIHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcbiAgICAgICAgICAgICclVWludDMyQXJyYXklJzpcbiAgICAgICAgICAgICAgdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuICAgICAgICAgICAgJyVVUklFcnJvciUnOiBVUklFcnJvcixcbiAgICAgICAgICAgICclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuICAgICAgICAgICAgJyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG4gICAgICAgICAgICAnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldCxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9JylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuICAgICAgICAgICAgICB2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpXG4gICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZm4ucHJvdG90eXBlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcbiAgICAgICAgICAgICAgdmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpXG4gICAgICAgICAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlXG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcbiAgICAgICAgICAgICclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcbiAgICAgICAgICAgICclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcbiAgICAgICAgICAgICclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcbiAgICAgICAgICAgICclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG4gICAgICAgICAgICAnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFtcbiAgICAgICAgICAgICAgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLFxuICAgICAgICAgICAgICAncHJvdG90eXBlJyxcbiAgICAgICAgICAgICAgJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVHZW5lcmF0b3JQcm90b3R5cGUlJzogW1xuICAgICAgICAgICAgICAnR2VuZXJhdG9yRnVuY3Rpb24nLFxuICAgICAgICAgICAgICAncHJvdG90eXBlJyxcbiAgICAgICAgICAgICAgJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuICAgICAgICAgICAgJyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcbiAgICAgICAgICAgICclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG4gICAgICAgICAgICAnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcbiAgICAgICAgICAgICclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuICAgICAgICAgICAgJyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG4gICAgICAgICAgICAnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcbiAgICAgICAgICAgICclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG4gICAgICAgICAgICAnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgICAnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuICAgICAgICAgICAgJyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcbiAgICAgICAgICAgICclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ10sXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGZ1bmN0aW9uLWJpbmQgKi8gJy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGhhcyAqLyAnLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdClcbiAgICAgICAgICB2YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKVxuICAgICAgICAgIHZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpXG4gICAgICAgICAgdmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKVxuXG4gICAgICAgICAgLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xuICAgICAgICAgIHZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2dcbiAgICAgICAgICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2cgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gICAgICAgICAgdmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpXG4gICAgICAgICAgICB2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKVxuICAgICAgICAgICAgaWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3ICRTeW50YXhFcnJvcihcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgICAgICAgICAkcmVwbGFjZShcbiAgICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgICByZVByb3BOYW1lLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlXG4gICAgICAgICAgICAgICAgICA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKVxuICAgICAgICAgICAgICAgICAgOiBudW1iZXIgfHwgbWF0Y2hcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG4gICAgICAgICAgdmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuICAgICAgICAgICAgdmFyIGludHJpbnNpY05hbWUgPSBuYW1lXG4gICAgICAgICAgICB2YXIgYWxpYXNcbiAgICAgICAgICAgIGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG4gICAgICAgICAgICAgIGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV1cbiAgICAgICAgICAgICAgaW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXVxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ2ludHJpbnNpYyAnICtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxpYXM6IGFsaWFzLFxuICAgICAgICAgICAgICAgIG5hbWU6IGludHJpbnNpY05hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSlcbiAgICAgICAgICAgIHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnXG5cbiAgICAgICAgICAgIHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKFxuICAgICAgICAgICAgICAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJyxcbiAgICAgICAgICAgICAgYWxsb3dNaXNzaW5nXG4gICAgICAgICAgICApXG4gICAgICAgICAgICB2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlXG4gICAgICAgICAgICB2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2VcblxuICAgICAgICAgICAgdmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzXG4gICAgICAgICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgICAgICAgaW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXVxuICAgICAgICAgICAgICAkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldXG4gICAgICAgICAgICAgIHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKVxuICAgICAgICAgICAgICB2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSlcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChmaXJzdCA9PT0gJ1wiJyB8fFxuICAgICAgICAgICAgICAgICAgZmlyc3QgPT09IFwiJ1wiIHx8XG4gICAgICAgICAgICAgICAgICBmaXJzdCA9PT0gJ2AnIHx8XG4gICAgICAgICAgICAgICAgICBsYXN0ID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICBsYXN0ID09PSBcIidcIiB8fFxuICAgICAgICAgICAgICAgICAgbGFzdCA9PT0gJ2AnKSAmJlxuICAgICAgICAgICAgICAgIGZpcnN0ICE9PSBsYXN0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgICAgICAncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcydcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG4gICAgICAgICAgICAgICAgc2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydFxuICAgICAgICAgICAgICBpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnXG5cbiAgICAgICAgICAgICAgaWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWFsbG93TWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAnYmFzZSBpbnRyaW5zaWMgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLidcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkZ09QRCAmJiBpICsgMSA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpXG4gICAgICAgICAgICAgICAgICBpc093biA9ICEhZGVzY1xuXG4gICAgICAgICAgICAgICAgICAvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3JcbiAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cbiAgICAgICAgICAgICAgICAgIC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG4gICAgICAgICAgICAgICAgICAvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuICAgICAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBpc093biAmJlxuICAgICAgICAgICAgICAgICAgICAnZ2V0JyBpbiBkZXNjICYmXG4gICAgICAgICAgICAgICAgICAgICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVzYy5nZXRcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcGFydF1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW3BhcnRdXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgIElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2xcbiAgICAgICAgICB2YXIgaGFzU3ltYm9sU2hhbSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9zaGFtcyAqLyAnLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNTeW1ib2xTaGFtKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICAvKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2JqID0ge31cbiAgICAgICAgICAgIHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKVxuICAgICAgICAgICAgdmFyIHN5bU9iaiA9IE9iamVjdChzeW0pXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG4gICAgICAgICAgICAvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgLy8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG4gICAgICAgICAgICAvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgICAvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICAvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgICB2YXIgc3ltVmFsID0gNDJcbiAgICAgICAgICAgIG9ialtzeW1dID0gc3ltVmFsXG4gICAgICAgICAgICBmb3IgKHN5bSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3BcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopXG4gICAgICAgICAgICBpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGZ1bmN0aW9uLWJpbmQgKi8gJy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoXG4gICAgICAgICAgICBGdW5jdGlvbi5jYWxsLFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgICAgICAgICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgICAgICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgICAgICAgICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgICAgICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgICAgICAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgICAgICAgICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9XG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJ1xuICAgICAgICAgIHZhciBjYWxsQm91bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNhbGwtYmluZC9jYWxsQm91bmQgKi8gJy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpXG5cbiAgICAgICAgICB2YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGhhc1RvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA+PSAwICYmXG4gICAgICAgICAgICAgICR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgICAgICAgICAgJHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpXG4gICAgICAgICAgfSkoKVxuXG4gICAgICAgICAgaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzIC8vIGZvciB0ZXN0c1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzXG4gICAgICAgICAgICA/IGlzU3RhbmRhcmRBcmd1bWVudHNcbiAgICAgICAgICAgIDogaXNMZWdhY3lBcmd1bWVudHNcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgICAgdmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgICB2YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi9cbiAgICAgICAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPVxuICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCdcbiAgICAgICAgICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgICAgICAgICB2YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgICAgIGlmICghaGFzVG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpXG4gICAgICAgICAgdmFyIEdlbmVyYXRvckZ1bmN0aW9uID1cbiAgICAgICAgICAgIGdldFByb3RvICYmIGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGblJlZ2V4LnRlc3QoZm5Ub1N0ci5jYWxsKGZuKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzVG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAgICAgdmFyIHN0ciA9IHRvU3RyLmNhbGwoZm4pXG4gICAgICAgICAgICAgIHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRQcm90byAmJiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbXBsZW1lbnRhdGlvbi5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbXBsZW1lbnRhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIC8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNhbGwtYmluZCAqLyAnLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBkZWZpbmUtcHJvcGVydGllcyAqLyAnLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2ltcGxlbWVudGF0aW9uICovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9wb2x5ZmlsbCAqLyAnLi9ub2RlX21vZHVsZXMvaXMtbmFuL3BvbHlmaWxsLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgc2hpbSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9zaGltICovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpXG5cbiAgICAgICAgICAvKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbiAgICAgICAgICBkZWZpbmUocG9seWZpbGwsIHtcbiAgICAgICAgICAgIGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcbiAgICAgICAgICAgIHNoaW06IHNoaW0sXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWZpbGxcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vcG9seWZpbGwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pcy1uYW4vcG9seWZpbGwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9pbXBsZW1lbnRhdGlvbiAqLyAnLi9ub2RlX21vZHVsZXMvaXMtbmFuL2ltcGxlbWVudGF0aW9uLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb25cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvaXMtbmFuL3NoaW0uanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2lzLW5hbi9zaGltLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGRlZmluZS1wcm9wZXJ0aWVzICovICcuL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3BvbHlmaWxsICovICcuL25vZGVfbW9kdWxlcy9pcy1uYW4vcG9seWZpbGwuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTnVtYmVySXNOYU4oKSB7XG4gICAgICAgICAgICB2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpXG4gICAgICAgICAgICBkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG4gICAgICAgICAgICAgIGlzTmFOOiBmdW5jdGlvbiB0ZXN0SXNOYU4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTiAhPT0gcG9seWZpbGxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gcG9seWZpbGxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIHZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBmb3JlYWNoICovICcuL25vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGF2YWlsYWJsZS10eXBlZC1hcnJheXMgKi8gJy4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBjYWxsQm91bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNhbGwtYmluZC9jYWxsQm91bmQgKi8gJy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpXG4gICAgICAgICAgdmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGhhcy1zeW1ib2xzICovICcuL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcydcbiAgICAgICAgICApKClcbiAgICAgICAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPVxuICAgICAgICAgICAgaGFzU3ltYm9scyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJ1xuXG4gICAgICAgICAgdmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKVxuXG4gICAgICAgICAgdmFyICRpbmRleE9mID1cbiAgICAgICAgICAgIGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKVxuICAgICAgICAgIHZhciB0b1N0clRhZ3MgPSB7fVxuICAgICAgICAgIHZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvciAqLyAnLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuICAgICAgICAgIGlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICB2YXIgYXJyID0gbmV3IF9fd2VicGFja19yZXF1aXJlX18uZ1t0eXBlZEFycmF5XSgpXG4gICAgICAgICAgICAgIGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2YWxFcnJvcihcbiAgICAgICAgICAgICAgICAgICd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArXG4gICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXkgK1xuICAgICAgICAgICAgICAgICAgICAnIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgICAgICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGFueVRydWUgPSBmYWxzZVxuICAgICAgICAgICAgZm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgaWYgKCFhbnlUcnVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXlcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAvKiovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGFueVRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNUb1N0cmluZ1RhZykge1xuICAgICAgICAgICAgICB2YXIgdGFnID0gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKVxuICAgICAgICAgICAgICByZXR1cm4gJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnT1BEKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDEgLyBhID09PSAxIC8gYlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgZGVmaW5lLXByb3BlcnRpZXMgKi8gJy4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGNhbGwtYmluZCAqLyAnLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9pbXBsZW1lbnRhdGlvbiAqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vcG9seWZpbGwgKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vc2hpbSAqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3NoaW0uanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KVxuXG4gICAgICAgICAgZGVmaW5lKHBvbHlmaWxsLCB7XG4gICAgICAgICAgICBnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG4gICAgICAgICAgICBzaGltOiBzaGltLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3BvbHlmaWxsLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3BvbHlmaWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaW1wbGVtZW50YXRpb24gKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvc2hpbS5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3NoaW0uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3BvbHlmaWxsICovICcuL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGRlZmluZS1wcm9wZXJ0aWVzICovICcuL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcbiAgICAgICAgICAgIHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKClcbiAgICAgICAgICAgIGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcbiAgICAgICAgICAgICAgaXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBwb2x5ZmlsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbXBsZW1lbnRhdGlvbi5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGtleXNTaGltXG4gICAgICAgICAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAgICAgICAgICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICAgICAgICAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgICAgICB2YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vaXNBcmd1bWVudHMgKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzJ1xuICAgICAgICAgICAgKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG4gICAgICAgICAgICB2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAgICAgICAgICAgdmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKFxuICAgICAgICAgICAgICB7IHRvU3RyaW5nOiBudWxsIH0sXG4gICAgICAgICAgICAgICd0b1N0cmluZydcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICB2YXIgZG9udEVudW1zID0gW1xuICAgICAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgICAgICAgJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgIHZhciBjdG9yID0gby5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4Y2x1ZGVkS2V5cyA9IHtcbiAgICAgICAgICAgICAgJGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG4gICAgICAgICAgICAgICRjb25zb2xlOiB0cnVlLFxuICAgICAgICAgICAgICAkZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICAgICRmcmFtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgJGZyYW1lRWxlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgJGZyYW1lczogdHJ1ZSxcbiAgICAgICAgICAgICAgJGlubmVySGVpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAkaW5uZXJXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgJG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcbiAgICAgICAgICAgICAgJG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAkb3V0ZXJIZWlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICRvdXRlcldpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAkcGFnZVhPZmZzZXQ6IHRydWUsXG4gICAgICAgICAgICAgICRwYWdlWU9mZnNldDogdHJ1ZSxcbiAgICAgICAgICAgICAgJHBhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgJHNjcm9sbExlZnQ6IHRydWUsXG4gICAgICAgICAgICAgICRzY3JvbGxUb3A6IHRydWUsXG4gICAgICAgICAgICAgICRzY3JvbGxYOiB0cnVlLFxuICAgICAgICAgICAgICAkc2Nyb2xsWTogdHJ1ZSxcbiAgICAgICAgICAgICAgJHNlbGY6IHRydWUsXG4gICAgICAgICAgICAgICR3ZWJraXRJbmRleGVkREI6IHRydWUsXG4gICAgICAgICAgICAgICR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcbiAgICAgICAgICAgICAgJHdpbmRvdzogdHJ1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvKiBnbG9iYWwgd2luZG93ICovXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJlxuICAgICAgICAgICAgICAgICAgICBoYXMuY2FsbCh3aW5kb3csIGspICYmXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd1trXSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgIC8qIGdsb2JhbCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgICAgICAgICB2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgICAgICAgdmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdClcbiAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID1cbiAgICAgICAgICAgICAgICBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nXG4gICAgICAgICAgICAgIHZhciB0aGVLZXlzID0gW11cblxuICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uXG4gICAgICAgICAgICAgIGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goU3RyaW5nKGkpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goU3RyaW5nKGopKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiZcbiAgICAgICAgICAgICAgICAgICAgaGFzLmNhbGwob2JqZWN0LCBuYW1lKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShcbiAgICAgICAgICAgICAgICAgIG9iamVjdFxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiZcbiAgICAgICAgICAgICAgICAgICAgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoZUtleXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICB2YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2lzQXJndW1lbnRzICovICcuL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5c1xuICAgICAgICAgIHZhciBrZXlzU2hpbSA9IG9yaWdLZXlzXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIGtleXMobykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnS2V5cyhvKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgICAgLyohIC4vaW1wbGVtZW50YXRpb24gKi8gJy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2ltcGxlbWVudGF0aW9uLmpzJ1xuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXNcblxuICAgICAgICAgIGtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgICB2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDUuMCBidWdcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICB9KSgxLCAyKVxuICAgICAgICAgICAgICBpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgaWYgKGlzQXJncyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyA9IGtleXNTaGltXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSlcbiAgICAgICAgICAgIHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgICAgICAgICBpZiAoIWlzQXJncykge1xuICAgICAgICAgICAgICBpc0FyZ3MgPVxuICAgICAgICAgICAgICAgIHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgICAgICB0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0FyZ3NcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIC8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuICAgICAgICAgIHZhciBwcm9jZXNzID0gKG1vZHVsZS5leHBvcnRzID0ge30pXG5cbiAgICAgICAgICAvLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbiAgICAgICAgICAvLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbiAgICAgICAgICAvLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4gICAgICAgICAgLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxuICAgICAgICAgIHZhciBjYWNoZWRTZXRUaW1lb3V0XG4gICAgICAgICAgdmFyIGNhY2hlZENsZWFyVGltZW91dFxuXG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIDsoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKVxuICAgICAgICAgIGZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmXG4gICAgICAgICAgICAgIHNldFRpbWVvdXRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dFxuICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgICAgICAgICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fFxuICAgICAgICAgICAgICAgICFjYWNoZWRDbGVhclRpbWVvdXQpICYmXG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dFxuICAgICAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcXVldWUgPSBbXVxuICAgICAgICAgIHZhciBkcmFpbmluZyA9IGZhbHNlXG4gICAgICAgICAgdmFyIGN1cnJlbnRRdWV1ZVxuICAgICAgICAgIHZhciBxdWV1ZUluZGV4ID0gLTFcblxuICAgICAgICAgIGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICAgICAgICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYWluaW5nID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHF1ZXVlSW5kZXggPSAtMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBkcmFpblF1ZXVlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgICAgICAgICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljaylcbiAgICAgICAgICAgIGRyYWluaW5nID0gdHJ1ZVxuXG4gICAgICAgICAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoXG4gICAgICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlXG4gICAgICAgICAgICAgIHF1ZXVlID0gW11cbiAgICAgICAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBxdWV1ZUluZGV4ID0gLTFcbiAgICAgICAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50UXVldWUgPSBudWxsXG4gICAgICAgICAgICBkcmFpbmluZyA9IGZhbHNlXG4gICAgICAgICAgICBydW5DbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpXG4gICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuICAgICAgICAgIGZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgICAgICAgICAgdGhpcy5mdW4gPSBmdW5cbiAgICAgICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheVxuICAgICAgICAgIH1cbiAgICAgICAgICBJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInXG4gICAgICAgICAgcHJvY2Vzcy5icm93c2VyID0gdHJ1ZVxuICAgICAgICAgIHByb2Nlc3MuZW52ID0ge31cbiAgICAgICAgICBwcm9jZXNzLmFyZ3YgPSBbXVxuICAgICAgICAgIHByb2Nlc3MudmVyc2lvbiA9ICcnIC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG4gICAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucyA9IHt9XG5cbiAgICAgICAgICBmdW5jdGlvbiBub29wKCkge31cblxuICAgICAgICAgIHByb2Nlc3Mub24gPSBub29wXG4gICAgICAgICAgcHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLm9uY2UgPSBub29wXG4gICAgICAgICAgcHJvY2Vzcy5vZmYgPSBub29wXG4gICAgICAgICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3BcbiAgICAgICAgICBwcm9jZXNzLmVtaXQgPSBub29wXG4gICAgICAgICAgcHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wXG4gICAgICAgICAgcHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcFxuXG4gICAgICAgICAgcHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICcvJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIC8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAgICAgICAgICAvLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gICAgICAgICAgLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gICAgICAgICAgLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICAgICAgICAgIC8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbiAgICAgICAgICAvLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAgICAgICAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gICAgICAgICAgLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gICAgICAgICAgLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgICAgICAgIC8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbiAgICAgICAgICAvLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAgICAgICAgICAvLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAgICAgICAgICAvLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4gICAgICAgICAgLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuICAgICAgICAgIC8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbiAgICAgICAgICAvLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbiAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuICAgICAgICAgIGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHNlcCA9IHNlcCB8fCAnJidcbiAgICAgICAgICAgIGVxID0gZXEgfHwgJz0nXG4gICAgICAgICAgICB2YXIgb2JqID0ge31cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IC9cXCsvZ1xuICAgICAgICAgICAgcXMgPSBxcy5zcGxpdChzZXApXG5cbiAgICAgICAgICAgIHZhciBtYXhLZXlzID0gMTAwMFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5c1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVuID0gcXMubGVuZ3RoXG4gICAgICAgICAgICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgICAgICAgICAgIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgICAgICAgICAgIGxlbiA9IG1heEtleXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgICAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAgICAgICAgICBrc3RyLFxuICAgICAgICAgICAgICAgIHZzdHIsXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB2XG5cbiAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeClcbiAgICAgICAgICAgICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrc3RyID0geFxuICAgICAgICAgICAgICAgIHZzdHIgPSAnJ1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKVxuICAgICAgICAgICAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpXG5cbiAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tdID0gdlxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICAgICAgICAgIG9ialtrXS5wdXNoKHYpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2tdID0gW29ialtrXSwgdl1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gICAgICAgICAgLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICAgICAgICAgIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAgICAgICAgIC8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAgICAgICAgICAvLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gICAgICAgICAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gICAgICAgICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAgICAgICAgIC8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAgICAgICAgIC8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICAgICAgICAvLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gICAgICAgICAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gICAgICAgICAgLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4gICAgICAgICAgLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICAgICAgICAgIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAgICAgICB2YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdlxuXG4gICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJ1xuXG4gICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnXG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgICAgICAgICAgIHNlcCA9IHNlcCB8fCAnJidcbiAgICAgICAgICAgIGVxID0gZXEgfHwgJz0nXG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG9iaiA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxXG4gICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpba11cbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oc2VwKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oc2VwKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5hbWUpIHJldHVybiAnJ1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgK1xuICAgICAgICAgICAgICBlcSArXG4gICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9kZWNvZGUgKi8gJy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9lbmNvZGUgKi8gJy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvYWxidW0vZ2V0QWxidW0udHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2FsYnVtL2dldEFsYnVtLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmdldEFsYnVtID0gdm9pZCAwXG4gICAgICAgICAgY29uc3QgZW5kcG9pbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi9lbmRwb2ludHMgKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi91dGlscyAqLyAnLi9zcmMvY29tbW9uL3V0aWxzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBnZXRBbGJ1bShjbGllbnQsIGFsYnVtSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7ZW5kcG9pbnRzXzEuQUxCVU1fRU5EUE9JTlR9LyR7YWxidW1IYXNofWBcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZ2V0QWxidW0gPSBnZXRBbGJ1bVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2FsYnVtL2luZGV4LnRzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9hbGJ1bS9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgICAgY29uc3QgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgdHNsaWIgKi8gJy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEFsYnVtICovICcuL3NyYy9hbGJ1bS9nZXRBbGJ1bS50cycpLFxuICAgICAgICAgICAgZXhwb3J0c1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9jbGllbnQudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jbGllbnQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLkltZ3VyQ2xpZW50ID0gdm9pZCAwXG4gICAgICAgICAgY29uc3QgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgdHNsaWIgKi8gJy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGV2ZW50cyAqLyAnLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgZ2V0QXV0aG9yaXphdGlvbkhlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2dldEF1dGhvcml6YXRpb25IZWFkZXIgKi8gJy4vc3JjL2dldEF1dGhvcml6YXRpb25IZWFkZXIudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGltYWdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vaW1hZ2UgKi8gJy4vc3JjL2ltYWdlL2luZGV4LnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBnYWxsZXJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4vZ2FsbGVyeSAqLyAnLi9zcmMvZ2FsbGVyeS9pbmRleC50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgYWxidW1fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9hbGJ1bSAqLyAnLi9zcmMvYWxidW0vaW5kZXgudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NvbW1vbi9lbmRwb2ludHMgKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IFVTRVJBR0VOVCA9XG4gICAgICAgICAgICAnaW1ndXIvbmV4dCAoaHR0cHM6Ly9naXRodWIuY29tL2thaW1hbGxlYS9ub2RlLWltZ3VyKSdcbiAgICAgICAgICBjb25zdCBheGlvc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBheGlvcyAqLyAnLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMnKVxuICAgICAgICAgIClcbiAgICAgICAgICBjbGFzcyBJbWd1ckNsaWVudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFsc1xuICAgICAgICAgICAgICB0aGlzLnBsYWluRmV0Y2hlciA9IGF4aW9zXzEuZGVmYXVsdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGJhc2VVUkw6IGVuZHBvaW50c18xLklNR1VSX0FQSV9QUkVGSVgsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBVU0VSQUdFTlQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgdGhpcy5mZXRjaGVyID0gYXhpb3NfMS5kZWZhdWx0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYmFzZVVSTDogZW5kcG9pbnRzXzEuSU1HVVJfQVBJX1BSRUZJWCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IFVTRVJBR0VOVCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB0aGlzLmZldGNoZXIuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKFxuICAgICAgICAgICAgICAgIGFzeW5jIChjb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgPyBjb25maWcuaGVhZGVycyA6IHt9XG4gICAgICAgICAgICAgICAgICBjb25maWcuaGVhZGVycy5hdXRob3JpemF0aW9uID0gYXdhaXQgZ2V0QXV0aG9yaXphdGlvbkhlYWRlcl8xLmdldEF1dGhvcml6YXRpb25IZWFkZXIoXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlKSA9PiBQcm9taXNlLnJlamVjdChlKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGFpblJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wbGFpbkZldGNoZXIob3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoZXIob3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZUltYWdlKGltYWdlSGFzaCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VfMS5kZWxldGVJbWFnZSh0aGlzLCBpbWFnZUhhc2gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmYXZvcml0ZUltYWdlKGltYWdlSGFzaCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VfMS5mYXZvcml0ZUltYWdlKHRoaXMsIGltYWdlSGFzaClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEFsYnVtKGFsYnVtSGFzaCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWxidW1fMS5nZXRBbGJ1bSh0aGlzLCBhbGJ1bUhhc2gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRHYWxsZXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdhbGxlcnlfMS5nZXRHYWxsZXJ5KHRoaXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRTdWJyZWRkaXRHYWxsZXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdhbGxlcnlfMS5nZXRTdWJyZWRkaXRHYWxsZXJ5KHRoaXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWFyY2hHYWxsZXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdhbGxlcnlfMS5zZWFyY2hHYWxsZXJ5KHRoaXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRJbWFnZShpbWFnZUhhc2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGltYWdlXzEuZ2V0SW1hZ2UodGhpcywgaW1hZ2VIYXNoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlSW1hZ2UocGF5bG9hZCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VfMS51cGRhdGVJbWFnZSh0aGlzLCBwYXlsb2FkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGltYWdlXzEudXBsb2FkKHRoaXMsIHBheWxvYWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuSW1ndXJDbGllbnQgPSBJbWd1ckNsaWVudFxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLlNFQVJDSF9HQUxMRVJZX0VORFBPSU5UID0gZXhwb3J0cy5TVUJSRURESVRfR0FMTEVSWV9FTkRQT0lOVCA9IGV4cG9ydHMuR0FMTEVSWV9FTkRQT0lOVCA9IGV4cG9ydHMuVVBMT0FEX0VORFBPSU5UID0gZXhwb3J0cy5JTUFHRV9FTkRQT0lOVCA9IGV4cG9ydHMuQUxCVU1fRU5EUE9JTlQgPSBleHBvcnRzLkFVVEhPUklaRV9FTkRQT0lOVCA9IGV4cG9ydHMuQVBJX1ZFUlNJT04gPSBleHBvcnRzLklNR1VSX0FQSV9QUkVGSVggPSB2b2lkIDBcbiAgICAgICAgICBleHBvcnRzLklNR1VSX0FQSV9QUkVGSVggPSAnaHR0cHM6Ly9hcGkuaW1ndXIuY29tJ1xuICAgICAgICAgIGV4cG9ydHMuQVBJX1ZFUlNJT04gPSAnMydcbiAgICAgICAgICBleHBvcnRzLkFVVEhPUklaRV9FTkRQT0lOVCA9ICdvYXV0aDIvYXV0aG9yaXplJ1xuICAgICAgICAgIGV4cG9ydHMuQUxCVU1fRU5EUE9JTlQgPSBgJHtleHBvcnRzLkFQSV9WRVJTSU9OfS9hbGJ1bWBcbiAgICAgICAgICBleHBvcnRzLklNQUdFX0VORFBPSU5UID0gYCR7ZXhwb3J0cy5BUElfVkVSU0lPTn0vaW1hZ2VgXG4gICAgICAgICAgZXhwb3J0cy5VUExPQURfRU5EUE9JTlQgPSBgJHtleHBvcnRzLkFQSV9WRVJTSU9OfS91cGxvYWRgXG4gICAgICAgICAgZXhwb3J0cy5HQUxMRVJZX0VORFBPSU5UID0gYCR7ZXhwb3J0cy5BUElfVkVSU0lPTn0vZ2FsbGVyeWBcbiAgICAgICAgICBleHBvcnRzLlNVQlJFRERJVF9HQUxMRVJZX0VORFBPSU5UID0gYCR7ZXhwb3J0cy5BUElfVkVSU0lPTn0vZ2FsbGVyeS9yYFxuICAgICAgICAgIGV4cG9ydHMuU0VBUkNIX0dBTExFUllfRU5EUE9JTlQgPSBgJHtleHBvcnRzLkFQSV9WRVJTSU9OfS9nYWxsZXJ5L3NlYXJjaGBcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9jb21tb24vdHlwZXMudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21tb24vdHlwZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmlzTG9naW4gPSBleHBvcnRzLmlzQ2xpZW50SWQgPSBleHBvcnRzLmlzQWNjZXNzVG9rZW4gPSB2b2lkIDBcbiAgICAgICAgICBmdW5jdGlvbiBpc0FjY2Vzc1Rva2VuKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZy5hY2Nlc3NUb2tlbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNBY2Nlc3NUb2tlbiA9IGlzQWNjZXNzVG9rZW5cbiAgICAgICAgICBmdW5jdGlvbiBpc0NsaWVudElkKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZy5jbGllbnRJZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNDbGllbnRJZCA9IGlzQ2xpZW50SWRcbiAgICAgICAgICBmdW5jdGlvbiBpc0xvZ2luKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgYXJnLmNsaWVudElkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgYXJnLnVzZXJuYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgYXJnLnBhc3N3b3JkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0xvZ2luID0gaXNMb2dpblxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2NvbW1vbi91dGlscy50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbW1vbi91dGlscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZSA9IGV4cG9ydHMuY3JlYXRlRm9ybSA9IGV4cG9ydHMuZ2V0U291cmNlID0gZXhwb3J0cy5pc1N0cmVhbSA9IGV4cG9ydHMuaXNJbWFnZVVybCA9IGV4cG9ydHMuaXNCYXNlNjQgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISB0c2xpYiAqLyAnLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBmb3JtX2RhdGFfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIGZvcm0tZGF0YSAqLyAnLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgICBmdW5jdGlvbiBpc0Jhc2U2NChwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdHlwZW9mIHBheWxvYWQuYmFzZTY0ICE9PSAndW5kZWZpbmVkJyAmJiBwYXlsb2FkLnR5cGUgPT09ICdiYXNlNjQnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNCYXNlNjQgPSBpc0Jhc2U2NFxuICAgICAgICAgIGZ1bmN0aW9uIGlzSW1hZ2VVcmwocGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdHlwZW9mIHBheWxvYWQuaW1hZ2UgIT09ICd1bmRlZmluZWQnICYmIHBheWxvYWQudHlwZSA9PT0gJ3VybCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0ltYWdlVXJsID0gaXNJbWFnZVVybFxuICAgICAgICAgIGZ1bmN0aW9uIGlzU3RyZWFtKHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBheWxvYWQuc3RyZWFtICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzU3RyZWFtID0gaXNTdHJlYW1cbiAgICAgICAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGlzIHRvIGJlIGEgdW5pcXVlIG5hbWUgb2Ygc29tZSBraW5kIChhIGhhc2g/KVxuICAgICAgICAgIGZ1bmN0aW9uIGdldFNvdXJjZShwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCYXNlNjQocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdwYXlsb2FkLmJhc2U2NCdcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJlYW0ocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdwYXlsb2FkLnN0cmVhbSdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLmltYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZ2V0U291cmNlID0gZ2V0U291cmNlXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRm9ybShwYXlsb2FkKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtID0gbmV3IGZvcm1fZGF0YV8xLmRlZmF1bHQoKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBmb3JtLmFwcGVuZCgnaW1hZ2UnLCBwYXlsb2FkKVxuICAgICAgICAgICAgICByZXR1cm4gZm9ybVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkVXBsb2FkT2JqZWN0VHlwZXMgPSBbJ2Jhc2U2NCcsICdzdHJlYW0nXVxuICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkVXBsb2FkT2JqZWN0VHlwZXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRVcGxvYWRPYmplY3RUeXBlcy5pbmRleE9mKHBheWxvYWQudHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXksIHBheWxvYWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuY3JlYXRlRm9ybSA9IGNyZWF0ZUZvcm1cbiAgICAgICAgICBmdW5jdGlvbiBnZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiAoKF9hID0gcmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgOiBfYS5zdGF0dXMpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgKChfYiA9IHJlc3BvbnNlLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDBcbiAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgIDogX2Iuc3VjY2VzcykgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAvLyBUT0RPOiBkZXRlcm1pbmUgdGhlIHN1Y2Nlc3Mgb2YgdGhlIGNhbGw/XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZSA9IGdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2VcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9nYWxsZXJ5L2dldEdhbGxlcnkudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9nYWxsZXJ5L2dldEdhbGxlcnkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmdldEdhbGxlcnkgPSBleHBvcnRzLmNvbnN0cnVjdEdhbGxlcnlVcmwgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXJsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHVybCAqLyAnLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL3V0aWxzICovICcuL3NyYy9jb21tb24vdXRpbHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgc2VjdGlvbjogJ2hvdCcsXG4gICAgICAgICAgICBzb3J0OiAndmlyYWwnLFxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RHYWxsZXJ5VXJsKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgICAgICAgIGxldCB1cmkgPSBgJHttZXJnZWRPcHRpb25zLnNlY3Rpb259YFxuICAgICAgICAgICAgaWYgKG1lcmdlZE9wdGlvbnMuc29ydCkge1xuICAgICAgICAgICAgICB1cmkgKz0gYC8ke21lcmdlZE9wdGlvbnMuc29ydH1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyZ2VkT3B0aW9ucy5zZWN0aW9uID09PSAndG9wJyAmJiBtZXJnZWRPcHRpb25zLndpbmRvdykge1xuICAgICAgICAgICAgICB1cmkgKz0gYC8ke21lcmdlZE9wdGlvbnMud2luZG93fWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJnZWRPcHRpb25zLnBhZ2UpIHtcbiAgICAgICAgICAgICAgdXJpICs9IGAvJHttZXJnZWRPcHRpb25zLnBhZ2V9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IHVybF8xLlVSTChcbiAgICAgICAgICAgICAgYCR7ZW5kcG9pbnRzXzEuSU1HVVJfQVBJX1BSRUZJWH0vJHtlbmRwb2ludHNfMS5HQUxMRVJZX0VORFBPSU5UfS8ke3VyaX1gXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAobWVyZ2VkT3B0aW9ucy5zaG93VmlyYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcbiAgICAgICAgICAgICAgICAnc2hvd1ZpcmFsJyxcbiAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zLnNob3dWaXJhbC50b1N0cmluZygpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJnZWRPcHRpb25zLm1hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdtYXR1cmUnLCBtZXJnZWRPcHRpb25zLm1hdHVyZS50b1N0cmluZygpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmdlZE9wdGlvbnMuYWxidW1fcHJldmlld3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcbiAgICAgICAgICAgICAgICAnYWxidW1fcHJldmlld3MnLFxuICAgICAgICAgICAgICAgIG1lcmdlZE9wdGlvbnMuYWxidW1fcHJldmlld3MudG9TdHJpbmcoKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuY29uc3RydWN0R2FsbGVyeVVybCA9IGNvbnN0cnVjdEdhbGxlcnlVcmxcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBnZXRHYWxsZXJ5KGNsaWVudCwgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBjb25zdHJ1Y3RHYWxsZXJ5VXJsKG9wdGlvbnMpXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSB1c2luZyBwcmVmaXhVcmwgd2l0aCBnb3QsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBzdGFydGluZyBzbGFzaCBvciBpdCdsbCB0aHJvd1xuICAgICAgICAgICAgY29uc3QgZmluYWxQYXRobmFtZSA9IHBhdGhuYW1lLnNsaWNlKDEpXG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybDogZmluYWxQYXRobmFtZSB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmdldEdhbGxlcnkgPSBnZXRHYWxsZXJ5XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvZ2FsbGVyeS9nZXRTdWJyZWRkaXRHYWxsZXJ5LnRzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZ2FsbGVyeS9nZXRTdWJyZWRkaXRHYWxsZXJ5LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgICAgZXhwb3J0cy5nZXRTdWJyZWRkaXRHYWxsZXJ5ID0gZXhwb3J0cy5jb25zdHJ1Y3RTdWJyZWRkaXRHYWxsZXJ5VXJsID0gdm9pZCAwXG4gICAgICAgICAgY29uc3QgZW5kcG9pbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi9lbmRwb2ludHMgKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHVybF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISB1cmwgKi8gJy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi91dGlscyAqLyAnLi9zcmMvY29tbW9uL3V0aWxzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RTdWJyZWRkaXRHYWxsZXJ5VXJsKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB1cmkgPSBgJHtvcHRpb25zLnN1YnJlZGRpdH1gXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgICAgIHVyaSArPSBgLyR7b3B0aW9ucy5zb3J0fWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvcnQgPT09ICd0b3AnICYmIG9wdGlvbnMud2luZG93KSB7XG4gICAgICAgICAgICAgIHVyaSArPSBgLyR7b3B0aW9ucy53aW5kb3d9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFnZSkge1xuICAgICAgICAgICAgICB1cmkgKz0gYC8ke29wdGlvbnMucGFnZX1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgdXJsXzEuVVJMKFxuICAgICAgICAgICAgICBgJHtlbmRwb2ludHNfMS5JTUdVUl9BUElfUFJFRklYfS8ke2VuZHBvaW50c18xLlNVQlJFRERJVF9HQUxMRVJZX0VORFBPSU5UfS8ke3VyaX1gXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuY29uc3RydWN0U3VicmVkZGl0R2FsbGVyeVVybCA9IGNvbnN0cnVjdFN1YnJlZGRpdEdhbGxlcnlVcmxcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBnZXRTdWJyZWRkaXRHYWxsZXJ5KGNsaWVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSB9ID0gY29uc3RydWN0U3VicmVkZGl0R2FsbGVyeVVybChvcHRpb25zKVxuICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgdXNpbmcgcHJlZml4VXJsIHdpdGggZ290LCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgc3RhcnRpbmcgc2xhc2ggb3IgaXQnbGwgdGhyb3dcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsUGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShcbiAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmw6IGZpbmFsUGF0aG5hbWUgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5nZXRTdWJyZWRkaXRHYWxsZXJ5ID0gZ2V0U3VicmVkZGl0R2FsbGVyeVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2dhbGxlcnkvaW5kZXgudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZ2FsbGVyeS9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBjb25zdCB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISB0c2xpYiAqLyAnLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2dldEdhbGxlcnkgKi8gJy4vc3JjL2dhbGxlcnkvZ2V0R2FsbGVyeS50cydcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBleHBvcnRzXG4gICAgICAgICAgKVxuICAgICAgICAgIHRzbGliXzEuX19leHBvcnRTdGFyKFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vZ2V0U3VicmVkZGl0R2FsbGVyeSAqLyAnLi9zcmMvZ2FsbGVyeS9nZXRTdWJyZWRkaXRHYWxsZXJ5LnRzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4cG9ydHNcbiAgICAgICAgICApXG4gICAgICAgICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9zZWFyY2hHYWxsZXJ5ICovICcuL3NyYy9nYWxsZXJ5L3NlYXJjaEdhbGxlcnkudHMnXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZXhwb3J0c1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9nYWxsZXJ5L3NlYXJjaEdhbGxlcnkudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9nYWxsZXJ5L3NlYXJjaEdhbGxlcnkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLnNlYXJjaEdhbGxlcnkgPSBleHBvcnRzLmNvbnN0cnVjdFNlYXJjaEdhbGxlcnlVcmwgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL3V0aWxzICovICcuL3NyYy9jb21tb24vdXRpbHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHVybF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISB1cmwgKi8gJy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGFkdmFuY2VkUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgICdxX2FsbCcsXG4gICAgICAgICAgICAncV9hbnknLFxuICAgICAgICAgICAgJ3FfZXhhY3RseScsXG4gICAgICAgICAgICAncV9ub3QnLFxuICAgICAgICAgICAgJ3FfdHlwZScsXG4gICAgICAgICAgICAncV9zaXplX3B4JyxcbiAgICAgICAgICBdXG4gICAgICAgICAgZnVuY3Rpb24gY29uc3RydWN0U2VhcmNoR2FsbGVyeVVybChvcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgdXJpID0gJydcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICAgICAgdXJpICs9IGAvJHtvcHRpb25zLnNvcnR9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc29ydCA9PT0gJ3RvcCcgJiYgb3B0aW9ucy53aW5kb3cpIHtcbiAgICAgICAgICAgICAgdXJpICs9IGAvJHtvcHRpb25zLndpbmRvd31gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWdlKSB7XG4gICAgICAgICAgICAgIHVyaSArPSBgLyR7b3B0aW9ucy5wYWdlfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyB1cmxfMS5VUkwoXG4gICAgICAgICAgICAgIGAke2VuZHBvaW50c18xLklNR1VSX0FQSV9QUkVGSVh9LyR7ZW5kcG9pbnRzXzEuU0VBUkNIX0dBTExFUllfRU5EUE9JTlR9JHt1cml9YFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgYWR2YW5jZWRQYXJhbWV0ZXJzLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKF9hID0gb3B0aW9uc1twYXJhbV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgICA6IF9hLmxlbmd0aFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChwYXJhbSwgb3B0aW9uc1twYXJhbV0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpZiAoIXVybC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBvcHRpb25zLnEgfHwgb3B0aW9ucy5xdWVyeVxuICAgICAgICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBxdWVyeSB3YXMgcHJvdmlkZWQnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdxJywgcXVlcnkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuY29uc3RydWN0U2VhcmNoR2FsbGVyeVVybCA9IGNvbnN0cnVjdFNlYXJjaEdhbGxlcnlVcmxcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBzZWFyY2hHYWxsZXJ5KGNsaWVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSB9ID0gY29uc3RydWN0U2VhcmNoR2FsbGVyeVVybChvcHRpb25zKVxuICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgdXNpbmcgcHJlZml4VXJsIHdpdGggZ290LCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgc3RhcnRpbmcgc2xhc2ggb3IgaXQnbGwgdGhyb3dcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsUGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShcbiAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LnJlcXVlc3QoeyB1cmw6IGZpbmFsUGF0aG5hbWUgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5zZWFyY2hHYWxsZXJ5ID0gc2VhcmNoR2FsbGVyeVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2dldEF1dGhvcml6YXRpb25IZWFkZXIudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZ2V0QXV0aG9yaXphdGlvbkhlYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmdldEF1dGhvcml6YXRpb25IZWFkZXIgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCB0eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL2NvbW1vbi90eXBlcyAqLyAnLi9zcmMvY29tbW9uL3R5cGVzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9jb21tb24vZW5kcG9pbnRzICovICcuL3NyYy9jb21tb24vZW5kcG9pbnRzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBnZXRBdXRob3JpemF0aW9uSGVhZGVyKGNsaWVudCkge1xuICAgICAgICAgICAgaWYgKHR5cGVzXzEuaXNBY2Nlc3NUb2tlbihjbGllbnQuY3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBgQmVhcmVyICR7Y2xpZW50LmNyZWRlbnRpYWxzLmFjY2Vzc1Rva2VufWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZXNfMS5pc0NsaWVudElkKGNsaWVudC5jcmVkZW50aWFscykgJiZcbiAgICAgICAgICAgICAgIXR5cGVzXzEuaXNMb2dpbihjbGllbnQuY3JlZGVudGlhbHMpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGBDbGllbnQtSUQgJHtjbGllbnQuY3JlZGVudGlhbHMuY2xpZW50SWR9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjbGllbnRJZCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBjbGllbnQuY3JlZGVudGlhbHNcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIHVybDogZW5kcG9pbnRzXzEuQVVUSE9SSVpFX0VORFBPSU5ULFxuICAgICAgICAgICAgICBiYXNlVVJMOiBlbmRwb2ludHNfMS5JTUdVUl9BUElfUFJFRklYLFxuICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlX3R5cGU6ICd0b2tlbicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQucGxhaW5SZXF1ZXN0KG9wdGlvbnMpXG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gQXJyYXkuaXNBcnJheShyZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10pXG4gICAgICAgICAgICAgID8gcmVzcG9uc2UuaGVhZGVyc1snc2V0LWNvb2tpZSddWzBdXG4gICAgICAgICAgICAgIDogcmVzcG9uc2UuaGVhZGVyc1snc2V0LWNvb2tpZSddXG4gICAgICAgICAgICBpZiAoIWNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb29raWVzIHdlcmUgc2V0IGR1cmluZyBhdXRob3JpemF0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBjb29raWVzLm1hdGNoKCcoXnw7KVtzXSphdXRob3JpemVfdG9rZW49KFteO10qKScpXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgYXV0aG9yaXplX3Rva2VuIGNvb2tpZScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemVUb2tlbiA9IG1hdGNoZXNbMl1cbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ1BPU1QnXG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lLFxuICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgYWxsb3c6IGF1dGhvcml6ZVRva2VuLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5mb2xsb3dSZWRpcmVjdCA9IGZhbHNlXG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgIGNvb2tpZTogYGF1dGhvcml6ZV90b2tlbj0ke2F1dGhvcml6ZVRva2VufWAsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wbGFpblJlcXVlc3Qob3B0aW9ucylcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvblxuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBsb2NhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICd7XCInICtcbiAgICAgICAgICAgICAgICBkZWNvZGVVUkkobG9jYXRpb24uc2xpY2UobG9jYXRpb24uaW5kZXhPZignIycpICsgMSkpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnXCIsXCInKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLz0vZywgJ1wiOlwiJykgK1xuICAgICAgICAgICAgICAgICdcIn0nXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRva2VuLmFjY2Vzc190b2tlblxuICAgICAgICAgICAgY2xpZW50LmNyZWRlbnRpYWxzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW5cbiAgICAgICAgICAgIHJldHVybiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YFxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmdldEF1dGhvcml6YXRpb25IZWFkZXIgPSBnZXRBdXRob3JpemF0aW9uSGVhZGVyXG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9zcmMvaW1hZ2UvZGVsZXRlSW1hZ2UudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ltYWdlL2RlbGV0ZUltYWdlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmRlbGV0ZUltYWdlID0gdm9pZCAwXG4gICAgICAgICAgY29uc3QgZW5kcG9pbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi9lbmRwb2ludHMgKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi91dGlscyAqLyAnLi9zcmMvY29tbW9uL3V0aWxzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBkZWxldGVJbWFnZShjbGllbnQsIGltYWdlSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7ZW5kcG9pbnRzXzEuSU1BR0VfRU5EUE9JTlR9LyR7aW1hZ2VIYXNofWBcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsLCBtZXRob2Q6ICdERUxFVEUnIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZGVsZXRlSW1hZ2UgPSBkZWxldGVJbWFnZVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2ltYWdlL2Zhdm9yaXRlSW1hZ2UudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW1hZ2UvZmF2b3JpdGVJbWFnZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgICBleHBvcnRzLmZhdm9yaXRlSW1hZ2UgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL3V0aWxzICovICcuL3NyYy9jb21tb24vdXRpbHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGZhdm9yaXRlSW1hZ2UoY2xpZW50LCBpbWFnZUhhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke2VuZHBvaW50c18xLklNQUdFX0VORFBPSU5UfS8ke2ltYWdlSGFzaH0vZmF2b3JpdGVgXG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCwgbWV0aG9kOiAnUE9TVCcgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5mYXZvcml0ZUltYWdlID0gZmF2b3JpdGVJbWFnZVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vc3JjL2ltYWdlL2dldEltYWdlLnRzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS9nZXRJbWFnZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgICAgZXhwb3J0cy5nZXRJbWFnZSA9IHZvaWQgMFxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vZW5kcG9pbnRzICovICcuL3NyYy9jb21tb24vZW5kcG9pbnRzLnRzJ1xuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vdXRpbHMgKi8gJy4vc3JjL2NvbW1vbi91dGlscy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2UoY2xpZW50LCBpbWFnZUhhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke2VuZHBvaW50c18xLklNQUdFX0VORFBPSU5UfS8ke2ltYWdlSGFzaH1gXG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmdldEltYWdlID0gZ2V0SW1hZ2VcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9pbWFnZS9pbmRleC50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW1hZ2UvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGNvbnN0IHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHRzbGliICovICcuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHRzbGliXzEuX19leHBvcnRTdGFyKFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIC4vZGVsZXRlSW1hZ2UgKi8gJy4vc3JjL2ltYWdlL2RlbGV0ZUltYWdlLnRzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4cG9ydHNcbiAgICAgICAgICApXG4gICAgICAgICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9mYXZvcml0ZUltYWdlICovICcuL3NyYy9pbWFnZS9mYXZvcml0ZUltYWdlLnRzJ1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV4cG9ydHNcbiAgICAgICAgICApXG4gICAgICAgICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEltYWdlICovICcuL3NyYy9pbWFnZS9nZXRJbWFnZS50cycpLFxuICAgICAgICAgICAgZXhwb3J0c1xuICAgICAgICAgIClcbiAgICAgICAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL3VwZGF0ZUltYWdlICovICcuL3NyYy9pbWFnZS91cGRhdGVJbWFnZS50cydcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBleHBvcnRzXG4gICAgICAgICAgKVxuICAgICAgICAgIHRzbGliXzEuX19leHBvcnRTdGFyKFxuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91cGxvYWQgKi8gJy4vc3JjL2ltYWdlL3VwbG9hZC50cycpLFxuICAgICAgICAgICAgZXhwb3J0c1xuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9pbWFnZS91cGRhdGVJbWFnZS50cyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW1hZ2UvdXBkYXRlSW1hZ2UudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KVxuICAgICAgICAgIGV4cG9ydHMudXBkYXRlSW1hZ2UgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCBlbmRwb2ludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL2VuZHBvaW50cyAqLyAnLi9zcmMvY29tbW9uL2VuZHBvaW50cy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi4vY29tbW9uL3V0aWxzICovICcuL3NyYy9jb21tb24vdXRpbHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGZ1bmN0aW9uIGlzVmFsaWRVcGRhdGVQYXlsb2FkKHApIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBwLnRpdGxlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcC5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSW1hZ2UoY2xpZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHBheWxvYWQubWFwKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVXBkYXRlUGF5bG9hZChwKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGUgcmVxdWlyZXMgYSB0aXRsZSBhbmQvb3IgZGVzY3JpcHRpb24nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtlbmRwb2ludHNfMS5JTUFHRV9FTkRQT0lOVH0vJHtwLmltYWdlSGFzaH1gXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IHV0aWxzXzEuY3JlYXRlRm9ybShwKVxuICAgICAgICAgICAgICAgIC8qIGVzbGludCBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yOiAwICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmVCb2R5T25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVXBkYXRlUGF5bG9hZChwYXlsb2FkKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSByZXF1aXJlcyBhIHRpdGxlIGFuZC9vciBkZXNjcmlwdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtlbmRwb2ludHNfMS5JTUFHRV9FTkRQT0lOVH0vJHtwYXlsb2FkLmltYWdlSGFzaH1gXG4gICAgICAgICAgICBjb25zdCBmb3JtID0gdXRpbHNfMS5jcmVhdGVGb3JtKHBheWxvYWQpXG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5nZXRJbWd1ckFwaVJlc3BvbnNlRnJvbVJlc3BvbnNlKFxuICAgICAgICAgICAgICBhd2FpdCBjbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZvcm0sXG4gICAgICAgICAgICAgICAgLy8gcmVzb2x2ZUJvZHlPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLnVwZGF0ZUltYWdlID0gdXBkYXRlSW1hZ2VcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL3NyYy9pbWFnZS91cGxvYWQudHMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS91cGxvYWQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBjb25zb2xlLWJyb3dzZXJpZnkgKi8gJy4vbm9kZV9tb2R1bGVzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgICAgICAgZXhwb3J0cy51cGxvYWQgPSB2b2lkIDBcbiAgICAgICAgICBjb25zdCB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuLi9jb21tb24vdXRpbHMgKi8gJy4vc3JjL2NvbW1vbi91dGlscy50cydcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgZW5kcG9pbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIC4uL2NvbW1vbi9lbmRwb2ludHMgKi8gJy4vc3JjL2NvbW1vbi9lbmRwb2ludHMudHMnXG4gICAgICAgICAgKVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZChjbGllbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gcGF5bG9hZC5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gdXRpbHNfMS5jcmVhdGVGb3JtKHApXG4gICAgICAgICAgICAgICAgLyogZXNsaW50IG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3I6IDAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZ2V0SW1ndXJBcGlSZXNwb25zZUZyb21SZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGVuZHBvaW50c18xLlVQTE9BRF9FTkRQT0lOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsgcHJvZ3Jlc3NFdmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzRXZlbnQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSB1dGlsc18xLmNyZWF0ZUZvcm0ocGF5bG9hZClcbiAgICAgICAgICAgIC8vIGNvbnN0IGlkID0gRGF0ZS5ub3cudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgIHVybDogZW5kcG9pbnRzXzEuVVBMT0FEX0VORFBPSU5ULFxuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgZGF0YTogZm9ybSxcbiAgICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogKHByb2dyZXNzRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh7IHByb2dyZXNzRXZlbnQgfSlcbiAgICAgICAgICAgICAgICBjbGllbnQuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB7IC4uLnByb2dyZXNzRXZlbnQgfSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgICB1dGlsc18xLmdldEltZ3VyQXBpUmVzcG9uc2VGcm9tUmVzcG9uc2UocmVxdWVzdClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy51cGxvYWQgPSB1cGxvYWRcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoXG4gICAgICAgICAgX191bnVzZWRfd2VicGFja19tb2R1bGUsXG4gICAgICAgICAgX193ZWJwYWNrX2V4cG9ydHNfXyxcbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fXG4gICAgICAgICkgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKVxuICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2V4dGVuZHM6ICgpID0+IC8qIGJpbmRpbmcgKi8gX19leHRlbmRzLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19hc3NpZ246ICgpID0+IC8qIGJpbmRpbmcgKi8gX19hc3NpZ24sXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX3Jlc3Q6ICgpID0+IC8qIGJpbmRpbmcgKi8gX19yZXN0LFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19kZWNvcmF0ZTogKCkgPT4gLyogYmluZGluZyAqLyBfX2RlY29yYXRlLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19wYXJhbTogKCkgPT4gLyogYmluZGluZyAqLyBfX3BhcmFtLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19tZXRhZGF0YTogKCkgPT4gLyogYmluZGluZyAqLyBfX21ldGFkYXRhLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19hd2FpdGVyOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fYXdhaXRlcixcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fZ2VuZXJhdG9yOiAoKSA9PiAvKiBiaW5kaW5nICovIF9fZ2VuZXJhdG9yLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19jcmVhdGVCaW5kaW5nOiAoKSA9PlxuICAgICAgICAgICAgICAvKiBiaW5kaW5nICovIF9fY3JlYXRlQmluZGluZyxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fZXhwb3J0U3RhcjogKCkgPT4gLyogYmluZGluZyAqLyBfX2V4cG9ydFN0YXIsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX3ZhbHVlczogKCkgPT4gLyogYmluZGluZyAqLyBfX3ZhbHVlcyxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fcmVhZDogKCkgPT4gLyogYmluZGluZyAqLyBfX3JlYWQsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX3NwcmVhZDogKCkgPT4gLyogYmluZGluZyAqLyBfX3NwcmVhZCxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fc3ByZWFkQXJyYXlzOiAoKSA9PlxuICAgICAgICAgICAgICAvKiBiaW5kaW5nICovIF9fc3ByZWFkQXJyYXlzLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19hd2FpdDogKCkgPT4gLyogYmluZGluZyAqLyBfX2F3YWl0LFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19hc3luY0dlbmVyYXRvcjogKCkgPT5cbiAgICAgICAgICAgICAgLyogYmluZGluZyAqLyBfX2FzeW5jR2VuZXJhdG9yLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19hc3luY0RlbGVnYXRvcjogKCkgPT5cbiAgICAgICAgICAgICAgLyogYmluZGluZyAqLyBfX2FzeW5jRGVsZWdhdG9yLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19hc3luY1ZhbHVlczogKCkgPT5cbiAgICAgICAgICAgICAgLyogYmluZGluZyAqLyBfX2FzeW5jVmFsdWVzLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19tYWtlVGVtcGxhdGVPYmplY3Q6ICgpID0+XG4gICAgICAgICAgICAgIC8qIGJpbmRpbmcgKi8gX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gICAgICAgICAgICAvKiBoYXJtb255IGV4cG9ydCAqLyBfX2ltcG9ydFN0YXI6ICgpID0+IC8qIGJpbmRpbmcgKi8gX19pbXBvcnRTdGFyLFxuICAgICAgICAgICAgLyogaGFybW9ueSBleHBvcnQgKi8gX19pbXBvcnREZWZhdWx0OiAoKSA9PlxuICAgICAgICAgICAgICAvKiBiaW5kaW5nICovIF9faW1wb3J0RGVmYXVsdCxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ6ICgpID0+XG4gICAgICAgICAgICAgIC8qIGJpbmRpbmcgKi8gX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ6ICgpID0+XG4gICAgICAgICAgICAgIC8qIGJpbmRpbmcgKi8gX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgICAgICAgICAgIC8qIGhhcm1vbnkgZXhwb3J0ICovXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAgICAgICAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG4gICAgICAgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICAgICAgZXh0ZW5kU3RhdGljcyA9XG4gICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgICAgICAgICAgICBkLl9fcHJvdG9fXyA9IGJcbiAgICAgICAgICAgICAgICB9KSB8fFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICAgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYilcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5wcm90b3R5cGUgPVxuICAgICAgICAgICAgICBiID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuY3JlYXRlKGIpXG4gICAgICAgICAgICAgICAgOiAoKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlKSwgbmV3IF9fKCkpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX19hc3NpZ24gPVxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduIHx8XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV1cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICAgICAgICAgICAgdmFyIHQgPSB7fVxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmXG4gICAgICAgICAgICAgICAgZS5pbmRleE9mKHApIDwgMFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF1cbiAgICAgICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTtcbiAgICAgICAgICAgICAgICBpIDwgcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIGUuaW5kZXhPZihwW2ldKSA8IDAgJiZcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICByID1cbiAgICAgICAgICAgICAgICBjIDwgM1xuICAgICAgICAgICAgICAgICAgPyB0YXJnZXRcbiAgICAgICAgICAgICAgICAgIDogZGVzYyA9PT0gbnVsbFxuICAgICAgICAgICAgICAgICAgPyAoZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpKVxuICAgICAgICAgICAgICAgICAgOiBkZXNjLFxuICAgICAgICAgICAgICBkXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgaWYgKChkID0gZGVjb3JhdG9yc1tpXSkpXG4gICAgICAgICAgICAgICAgICByID1cbiAgICAgICAgICAgICAgICAgICAgKGMgPCAzXG4gICAgICAgICAgICAgICAgICAgICAgPyBkKHIpXG4gICAgICAgICAgICAgICAgICAgICAgOiBjID4gM1xuICAgICAgICAgICAgICAgICAgICAgID8gZCh0YXJnZXQsIGtleSwgcilcbiAgICAgICAgICAgICAgICAgICAgICA6IGQodGFyZ2V0LCBrZXkpKSB8fCByXG4gICAgICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFBcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yWyd0aHJvdyddKHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QoZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZG9uZVxuICAgICAgICAgICAgICAgICAgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RlcChcbiAgICAgICAgICAgICAgICAoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gICAgICAgICAgICB2YXIgXyA9IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogMCxcbiAgICAgICAgICAgICAgICBzZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0WzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgICAgICAgICBvcHM6IFtdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICBnXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoZyA9IHsgbmV4dDogdmVyYigwKSwgdGhyb3c6IHZlcmIoMSksIHJldHVybjogdmVyYigyKSB9KSxcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBnXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuJylcbiAgICAgICAgICAgICAgd2hpbGUgKF8pXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKChmID0gMSksXG4gICAgICAgICAgICAgICAgICAgIHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAodCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcFswXSAmIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyB5WydyZXR1cm4nXVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9wWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8geVsndGhyb3cnXSB8fCAoKHQgPSB5WydyZXR1cm4nXSkgJiYgdC5jYWxsKHkpLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkubmV4dCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICAgICAgICAgICAgaWYgKCgoeSA9IDApLCB0KSkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXVxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICB0ID0gb3BcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKytcbiAgICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV1cbiAgICAgICAgICAgICAgICAgICAgICBvcCA9IFswXVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhKCh0ID0gXy50cnlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BbMF0gPT09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdXG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgb3AgPSBbNiwgZV1cbiAgICAgICAgICAgICAgICAgIHkgPSAwXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGYgPSB0ID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV1cbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0ga1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gbSlcbiAgICAgICAgICAgICAgaWYgKHAgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSlcbiAgICAgICAgICAgICAgICBleHBvcnRzW3BdID0gbVtwXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgICAgICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICAgICAgICAgIG0gPSBzICYmIG9bc10sXG4gICAgICAgICAgICAgIGkgPSAwXG4gICAgICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKVxuICAgICAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBzID8gJ09iamVjdCBpcyBub3QgaXRlcmFibGUuJyA6ICdTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgb1tTeW1ib2wuaXRlcmF0b3JdXG4gICAgICAgICAgICBpZiAoIW0pIHJldHVybiBvXG4gICAgICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgYXIgPSBbXSxcbiAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbJ3JldHVybiddKSkgbS5jYWxsKGkpXG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3JcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpXG4gICAgICAgICAgICByZXR1cm4gYXJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKylcbiAgICAgICAgICAgICAgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoXG4gICAgICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdXG4gICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fYXdhaXQodikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0XG4gICAgICAgICAgICAgID8gKCh0aGlzLnYgPSB2KSwgdGhpcylcbiAgICAgICAgICAgICAgOiBuZXcgX19hd2FpdCh2KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC4nKVxuICAgICAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIHEgPSBbXVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGkgPSB7fSksXG4gICAgICAgICAgICAgIHZlcmIoJ25leHQnKSxcbiAgICAgICAgICAgICAgdmVyYigndGhyb3cnKSxcbiAgICAgICAgICAgICAgdmVyYigncmV0dXJuJyksXG4gICAgICAgICAgICAgIChpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgICAgIGlmIChnW25dKVxuICAgICAgICAgICAgICAgIGlbbl0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdilcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGVwKGdbbl0odikpXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZXR0bGUocVswXVszXSwgZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7XG4gICAgICAgICAgICAgIHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0XG4gICAgICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdClcbiAgICAgICAgICAgICAgICA6IHNldHRsZShxWzBdWzJdLCByKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXN1bWUoJ25leHQnLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikge1xuICAgICAgICAgICAgICBpZiAoKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpKSByZXN1bWUocVswXVswXSwgcVswXVsxXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgICAgICAgICAgIHZhciBpLCBwXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaSA9IHt9KSxcbiAgICAgICAgICAgICAgdmVyYignbmV4dCcpLFxuICAgICAgICAgICAgICB2ZXJiKCd0aHJvdycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdmVyYigncmV0dXJuJyksXG4gICAgICAgICAgICAgIChpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikge1xuICAgICAgICAgICAgICBpW25dID0gb1tuXVxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwID0gIXApXG4gICAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSAncmV0dXJuJyB9XG4gICAgICAgICAgICAgICAgICAgICAgOiBmXG4gICAgICAgICAgICAgICAgICAgICAgPyBmKHYpXG4gICAgICAgICAgICAgICAgICAgICAgOiB2XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC4nKVxuICAgICAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSxcbiAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgcmV0dXJuIG1cbiAgICAgICAgICAgICAgPyBtLmNhbGwobylcbiAgICAgICAgICAgICAgOiAoKG8gPVxuICAgICAgICAgICAgICAgICAgdHlwZW9mIF9fdmFsdWVzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gX192YWx1ZXMobylcbiAgICAgICAgICAgICAgICAgICAgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSksXG4gICAgICAgICAgICAgICAgKGkgPSB7fSksXG4gICAgICAgICAgICAgICAgdmVyYignbmV4dCcpLFxuICAgICAgICAgICAgICAgIHZlcmIoJ3Rocm93JyksXG4gICAgICAgICAgICAgICAgdmVyYigncmV0dXJuJyksXG4gICAgICAgICAgICAgICAgKGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpKVxuICAgICAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgICAgIGlbbl0gPVxuICAgICAgICAgICAgICAgIG9bbl0gJiZcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgOyh2ID0gb1tuXSh2KSksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikge1xuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KVxuICAgICAgICAgICAgICB9LCByZWplY3QpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgJ3JhdycsIHsgdmFsdWU6IHJhdyB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29va2VkLnJhdyA9IHJhd1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvb2tlZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2RcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fVxuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKVxuICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIG1vZClcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdXG4gICAgICAgICAgICByZXN1bHQuZGVmYXVsdCA9IG1vZFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgICAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZSdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAvKiBtb2R1bGUgZGVjb3JhdG9yICovIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18ubm1kKG1vZHVsZSlcbiAgICAgICAgICB2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbiAgICAgICAgICA7KGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgICAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG4gICAgICAgICAgICB2YXIgZnJlZUV4cG9ydHMgPSB0cnVlICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0c1xuICAgICAgICAgICAgdmFyIGZyZWVNb2R1bGUgPSB0cnVlICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZVxuICAgICAgICAgICAgdmFyIGZyZWVHbG9iYWwgPVxuICAgICAgICAgICAgICB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nID09ICdvYmplY3QnICYmIF9fd2VicGFja19yZXF1aXJlX18uZ1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuICAgICAgICAgICAgICBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuICAgICAgICAgICAgICBmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByb290ID0gZnJlZUdsb2JhbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cbiAgICAgICAgICAgICAqIEBuYW1lIHB1bnljb2RlXG4gICAgICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHB1bnljb2RlLFxuICAgICAgICAgICAgICAvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG4gICAgICAgICAgICAgIG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcbiAgICAgICAgICAgICAgLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuICAgICAgICAgICAgICBiYXNlID0gMzYsXG4gICAgICAgICAgICAgIHRNaW4gPSAxLFxuICAgICAgICAgICAgICB0TWF4ID0gMjYsXG4gICAgICAgICAgICAgIHNrZXcgPSAzOCxcbiAgICAgICAgICAgICAgZGFtcCA9IDcwMCxcbiAgICAgICAgICAgICAgaW5pdGlhbEJpYXMgPSA3MixcbiAgICAgICAgICAgICAgaW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcbiAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG4gICAgICAgICAgICAgIC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG4gICAgICAgICAgICAgIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuICAgICAgICAgICAgICByZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcbiAgICAgICAgICAgICAgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAvKiogRXJyb3IgbWVzc2FnZXMgKi9cbiAgICAgICAgICAgICAgZXJyb3JzID0ge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuICAgICAgICAgICAgICAgICdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCcsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbiAgICAgICAgICAgICAgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuICAgICAgICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG4gICAgICAgICAgICAgIC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cbiAgICAgICAgICAgICAga2V5XG5cbiAgICAgICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICAgICAgICAgICAgICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG4gICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAgICAgICAgICAgICAqIGl0ZW0uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aFxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW11cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAgICAgICAgICAgICAqIGFkZHJlc3Nlcy5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gICAgICAgICAgICAgKiBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICogZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSAnJ1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gcGFydHNbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG4gICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJylcbiAgICAgICAgICAgICAgdmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpXG4gICAgICAgICAgICAgIHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgZW5jb2RlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAgICAgICAgICAgICAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAgICAgICAgICAgICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gICAgICAgICAgICAgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAgICAgICAgICAgICAqIG1hdGNoaW5nIFVURi0xNi5cbiAgICAgICAgICAgICAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICAgICAgICAgICAgICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICAgICAgICAgICAgICogQG5hbWUgZGVjb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgY291bnRlciA9IDAsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspXG4gICAgICAgICAgICAgICAgICBpZiAoKGV4dHJhICYgMHhmYzAwKSA9PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG93IHN1cnJvZ2F0ZVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAoKHZhbHVlICYgMHgzZmYpIDw8IDEwKSArIChleHRyYSAmIDB4M2ZmKSArIDB4MTAwMDBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyLS1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gICAgICAgICAgICAgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gICAgICAgICAgICAgKiBAbmFtZSBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSAtPSAweDEwMDAwXG4gICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICAgICAoKHZhbHVlID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDBcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gMHhkYzAwIHwgKHZhbHVlICYgMHgzZmYpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICAgICAgICB9KS5qb2luKCcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAgICAgICAgICAgICAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICAgICAgICAgICAgICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICAgICAgICAgICAgICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gMjJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA2NVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDk3XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcbiAgICAgICAgICAgICAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICAgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAgICAgICAgICAgICAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcbiAgICAgICAgICAgICAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgICAgICAgICAgICAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gICAgICAgICAgICAgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICAgICAgICAgICAgICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gMFxuICAgICAgICAgICAgICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxXG4gICAgICAgICAgICAgIGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAvKiBubyBpbml0aWFsaXphdGlvbiAqLyBkZWx0YSA+IChiYXNlTWludXNUTWluICogdE1heCkgPj4gMTtcbiAgICAgICAgICAgICAgICBrICs9IGJhc2VcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKGsgKyAoKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhKSAvIChkZWx0YSArIHNrZXcpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG4gICAgICAgICAgICAgKiBzeW1ib2xzLlxuICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgICAvLyBEb24ndCB1c2UgVUNTLTJcbiAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG91dCxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBuID0gaW5pdGlhbE4sXG4gICAgICAgICAgICAgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuICAgICAgICAgICAgICAgIGJhc2ljLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgb2xkaSxcbiAgICAgICAgICAgICAgICB3LFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgZGlnaXQsXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICAgICAgICAgICAgICBiYXNlTWludXNUXG5cbiAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG4gICAgICAgICAgICAgIC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG4gICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG4gICAgICAgICAgICAgIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKVxuICAgICAgICAgICAgICBpZiAoYmFzaWMgPCAwKSB7XG4gICAgICAgICAgICAgICAgYmFzaWMgPSAwXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdub3QtYmFzaWMnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuICAgICAgICAgICAgICAvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwO1xuICAgICAgICAgICAgICAgIGluZGV4IDwgaW5wdXRMZW5ndGggLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLztcblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlIC8qIG5vIGNvbmRpdGlvbiAqLztcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgIGsgKz0gYmFzZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdpbnZhbGlkLWlucHV0JylcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSlcblxuICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpICs9IGRpZ2l0ICogd1xuICAgICAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzXG5cbiAgICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYmFzZU1pbnVzVCA9IGJhc2UgLSB0XG4gICAgICAgICAgICAgICAgICBpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHcgKj0gYmFzZU1pbnVzVFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dCA9IG91dHB1dC5sZW5ndGggKyAxXG4gICAgICAgICAgICAgICAgYmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMClcblxuICAgICAgICAgICAgICAgIC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG4gICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcbiAgICAgICAgICAgICAgICBpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG4gKz0gZmxvb3IoaSAvIG91dClcbiAgICAgICAgICAgICAgICBpICU9IG91dFxuXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gICAgICAgICAgICAgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgICAgICAgICAgICB2YXIgbixcbiAgICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgICBoYW5kbGVkQ1BDb3VudCxcbiAgICAgICAgICAgICAgICBiYXNpY0xlbmd0aCxcbiAgICAgICAgICAgICAgICBiaWFzLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cbiAgICAgICAgICAgICAgICBpbnB1dExlbmd0aCxcbiAgICAgICAgICAgICAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICAgICAgICAgICAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG4gICAgICAgICAgICAgICAgYmFzZU1pbnVzVCxcbiAgICAgICAgICAgICAgICBxTWludXNUXG5cbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuICAgICAgICAgICAgICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpXG5cbiAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGxlbmd0aFxuICAgICAgICAgICAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aFxuXG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG4gICAgICAgICAgICAgIG4gPSBpbml0aWFsTlxuICAgICAgICAgICAgICBkZWx0YSA9IDBcbiAgICAgICAgICAgICAgYmlhcyA9IGluaXRpYWxCaWFzXG5cbiAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoXG5cbiAgICAgICAgICAgICAgLy8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG4gICAgICAgICAgICAgIC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuICAgICAgICAgICAgICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZGVsaW1pdGVyKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTWFpbiBlbmNvZGluZyBsb29wOlxuICAgICAgICAgICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBsYXJnZXIgb25lOlxuICAgICAgICAgICAgICAgIGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXVxuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcbiAgICAgICAgICAgICAgICAvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuICAgICAgICAgICAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMVxuICAgICAgICAgICAgICAgIGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmVcbiAgICAgICAgICAgICAgICBuID0gbVxuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdXG5cbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93JylcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocSA9IGRlbHRhLCBrID0gYmFzZSAvKiBubyBjb25kaXRpb24gKi87IDsgayArPSBiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBxTWludXNUID0gcSAtIHRcbiAgICAgICAgICAgICAgICAgICAgICBiYXNlTWludXNUID0gYmFzZSAtIHRcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0Zyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRUb0Jhc2ljKHQgKyAocU1pbnVzVCAlIGJhc2VNaW51c1QpLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSlcbiAgICAgICAgICAgICAgICAgICAgYmlhcyA9IGFkYXB0KFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gMFxuICAgICAgICAgICAgICAgICAgICArK2hhbmRsZWRDUENvdW50XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgKytkZWx0YVxuICAgICAgICAgICAgICAgICsrblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gICAgICAgICAgICAgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gICAgICAgICAgICAgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgICAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gICAgICAgICAgICAgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAgICAgICAgICAgICAqIHN0cmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcbiAgICAgICAgICAgICAgICAgID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgOiBzdHJpbmdcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAgICAgICAgICAgICAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICAgICAgICAgICAgICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gICAgICAgICAgICAgKiBBU0NJSS5cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAgICAgICAgICAgICAqIFVuaWNvZGUgc3RyaW5nLlxuICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICAgICAgICAgICAgICogZW1haWwgYWRkcmVzcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG4gICAgICAgICAgICAgICAgICA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG4gICAgICAgICAgICAgICAgICA6IHN0cmluZ1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuICAgICAgICAgICAgcHVueWNvZGUgPSB7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIHZlcnNpb246ICcxLjMuMicsXG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAgICAgICAgICAgICAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgICAgICAgICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICAgICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgdWNzMjoge1xuICAgICAgICAgICAgICAgIGRlY29kZTogdWNzMmRlY29kZSxcbiAgICAgICAgICAgICAgICBlbmNvZGU6IHVjczJlbmNvZGUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRlY29kZTogZGVjb2RlLFxuICAgICAgICAgICAgICBlbmNvZGU6IGVuY29kZSxcbiAgICAgICAgICAgICAgdG9BU0NJSTogdG9BU0NJSSxcbiAgICAgICAgICAgICAgdG9Vbmljb2RlOiB0b1VuaWNvZGUsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuICAgICAgICAgICAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG4gICAgICAgICAgICAvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAhKChfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVueWNvZGVcbiAgICAgICAgICAgICAgfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpLFxuICAgICAgICAgICAgICBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSh0aGlzKVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKi8gJy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAndXNlIHN0cmljdCdcbiAgICAgICAgICAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gICAgICAgICAgLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICAgICAgICAgIC8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICAgICAgICAgIC8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAgICAgICAgICAvLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gICAgICAgICAgLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gICAgICAgICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICAgICAgICAgIC8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICAgICAgICAgIC8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgICAgICAgICAvLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gICAgICAgICAgLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gICAgICAgICAgLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4gICAgICAgICAgLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICAgICAgICAgIC8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAgICAgICB2YXIgcHVueWNvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHB1bnljb2RlICovICcuL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi91dGlsICovICcuL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBleHBvcnRzLnBhcnNlID0gdXJsUGFyc2VcbiAgICAgICAgICBleHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlXG4gICAgICAgICAgZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdFxuICAgICAgICAgIGV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0XG5cbiAgICAgICAgICBleHBvcnRzLlVybCA9IFVybFxuXG4gICAgICAgICAgZnVuY3Rpb24gVXJsKCkge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuc2xhc2hlcyA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IG51bGxcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBudWxsXG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBudWxsXG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9IG51bGxcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBudWxsXG4gICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5wYXRoID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5ocmVmID0gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4gICAgICAgICAgLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbiAgICAgICAgICAvLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbiAgICAgICAgICB2YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICAgICAgICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICAgICAgICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcbiAgICAgICAgICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgICAgICAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgICAgICAgICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG4gICAgICAgICAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgICAgICAgICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuICAgICAgICAgICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgICAgICAgICAgYXV0b0VzY2FwZSA9IFtcIidcIl0uY29uY2F0KHVud2lzZSksXG4gICAgICAgICAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgICAgICAgICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgICAgICAgICAvLyB0aGVtLlxuICAgICAgICAgICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgICAgICAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgICAgICAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICAgICAgICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgICAgICAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAgICAgICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgICAgICAgICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAgICAgICAgIGphdmFzY3JpcHQ6IHRydWUsXG4gICAgICAgICAgICAgICdqYXZhc2NyaXB0Oic6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgICAgICAgICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICAgICAgICAgamF2YXNjcmlwdDogdHJ1ZSxcbiAgICAgICAgICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICAgICAgICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICAgICAgICAgaHR0cDogdHJ1ZSxcbiAgICAgICAgICAgICAgaHR0cHM6IHRydWUsXG4gICAgICAgICAgICAgIGZ0cDogdHJ1ZSxcbiAgICAgICAgICAgICAgZ29waGVyOiB0cnVlLFxuICAgICAgICAgICAgICBmaWxlOiB0cnVlLFxuICAgICAgICAgICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgICAgICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICAgICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgICAgICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAgICAgICAgICdmaWxlOic6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVlcnlzdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgcXVlcnlzdHJpbmcgKi8gJy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzJ1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICAgICAgICAgICAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsXG5cbiAgICAgICAgICAgIHZhciB1ID0gbmV3IFVybCgpXG4gICAgICAgICAgICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpXG4gICAgICAgICAgICByZXR1cm4gdVxuICAgICAgICAgIH1cblxuICAgICAgICAgIFVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBwYXJzZVF1ZXJ5U3RyaW5nLFxuICAgICAgICAgICAgc2xhc2hlc0Rlbm90ZUhvc3RcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAgICAgICAgICAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICAgICAgICAgICAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgICAgICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgICAgICAgcXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykgPyAnPycgOiAnIycsXG4gICAgICAgICAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICAgICAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nXG4gICAgICAgICAgICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpXG4gICAgICAgICAgICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcilcblxuICAgICAgICAgICAgdmFyIHJlc3QgPSB1cmxcblxuICAgICAgICAgICAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnRyaW0oKVxuXG4gICAgICAgICAgICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgICAgICAgICAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdClcbiAgICAgICAgICAgICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSByZXN0XG4gICAgICAgICAgICAgICAgdGhpcy5ocmVmID0gcmVzdFxuICAgICAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdXG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSlcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gJydcbiAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpXG4gICAgICAgICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgICAgICAgcHJvdG8gPSBwcm90b1swXVxuICAgICAgICAgICAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG9cbiAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgICAgICAgICAgIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgICAgICAgICAgIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgICAgICAgICAgIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzbGFzaGVzRGVub3RlSG9zdCB8fFxuICAgICAgICAgICAgICBwcm90byB8fFxuICAgICAgICAgICAgICByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLydcbiAgICAgICAgICAgICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMilcbiAgICAgICAgICAgICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgICAgICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAgICAgICAgICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAgICAgICAgICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBleDpcbiAgICAgICAgICAgICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAgICAgICAgICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgICAgICAgICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAgICAgICAgICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgICAgICAgICAgIHZhciBob3N0RW5kID0gLTFcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSlcbiAgICAgICAgICAgICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgICAgICAgICAgICBob3N0RW5kID0gaGVjXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAgICAgICAgICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgICAgICAgICAgIHZhciBhdXRoLCBhdFNpZ25cbiAgICAgICAgICAgICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgICAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgICAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgICAgICAgICAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgICAgICAgICAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbilcbiAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKVxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgICAgICAgICAgICBob3N0RW5kID0gLTFcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSlcbiAgICAgICAgICAgICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgICAgICAgICAgICBob3N0RW5kID0gaGVjXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgICAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIGhvc3RFbmQgPSByZXN0Lmxlbmd0aFxuXG4gICAgICAgICAgICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZClcbiAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZClcblxuICAgICAgICAgICAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgICAgICAgICAgICB0aGlzLnBhcnNlSG9zdCgpXG5cbiAgICAgICAgICAgICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAgICAgICAgICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJydcblxuICAgICAgICAgICAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgICAgICAgICAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICAgICAgICAgICAgdmFyIGlwdjZIb3N0bmFtZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSdcblxuICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICAgICAgICAgICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldXG4gICAgICAgICAgICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJ1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4J1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKVxuICAgICAgICAgICAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgICAgICAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAgICAgICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJ1xuICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJydcbiAgICAgICAgICAgICAgdGhpcy5ob3N0ID0gaCArIHBcbiAgICAgICAgICAgICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdFxuXG4gICAgICAgICAgICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAgICAgICAgICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICAgICAgICAgICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cihcbiAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIHJlc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gICAgICAgICAgICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gICAgICAgICAgICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG4gICAgICAgICAgICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAgICAgICAgICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldXG4gICAgICAgICAgICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKSBjb250aW51ZVxuICAgICAgICAgICAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpXG4gICAgICAgICAgICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgICAgICAgICAgIGVzYyA9IGVzY2FwZShhZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpXG4gICAgICAgICAgICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgICAgICAgICAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKVxuICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/JylcbiAgICAgICAgICAgIGlmIChxbSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSlcbiAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSlcbiAgICAgICAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgICAgICAgICAgICB0aGlzLnNlYXJjaCA9ICcnXG4gICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lICYmXG4gICAgICAgICAgICAgICF0aGlzLnBhdGhuYW1lXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9ICcvJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJydcbiAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJ1xuICAgICAgICAgICAgICB0aGlzLnBhdGggPSBwICsgc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgICAgICAgICAgIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KClcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuICAgICAgICAgIGZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAgICAgICAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAgICAgICAgICAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iailcbiAgICAgICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iailcbiAgICAgICAgICAgIHJldHVybiBvYmouZm9ybWF0KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBVcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnXG4gICAgICAgICAgICBpZiAoYXV0aCkge1xuICAgICAgICAgICAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpXG4gICAgICAgICAgICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpXG4gICAgICAgICAgICAgIGF1dGggKz0gJ0AnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICAgICAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgICAgICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgICAgICAgICBxdWVyeSA9ICcnXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgICAgICAgICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3RcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgICAgICAgICAgICBob3N0ID1cbiAgICAgICAgICAgICAgICBhdXRoICtcbiAgICAgICAgICAgICAgICAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xXG4gICAgICAgICAgICAgICAgICA/IHRoaXMuaG9zdG5hbWVcbiAgICAgICAgICAgICAgICAgIDogJ1snICsgdGhpcy5ob3N0bmFtZSArICddJylcbiAgICAgICAgICAgICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgICAgICAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ICYmXG4gICAgICAgICAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAnPycgKyBxdWVyeSkgfHwgJydcblxuICAgICAgICAgICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonXG5cbiAgICAgICAgICAgIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAgICAgICAgICAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzIHx8XG4gICAgICAgICAgICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgICAgICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJylcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICAgIGhvc3QgPSAnJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICAgICAgICAgICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaFxuXG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlXG4gICAgICAgICAgICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBVcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgICAgICAgICAgICB2YXIgcmVsID0gbmV3IFVybCgpXG4gICAgICAgICAgICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgICAgIHJlbGF0aXZlID0gcmVsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgVXJsKClcbiAgICAgICAgICAgIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpXG4gICAgICAgICAgICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgICAgICAgICAgIHZhciB0a2V5ID0gdGtleXNbdGtdXG4gICAgICAgICAgICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gICAgICAgICAgICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgICAgICAgICAgIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaFxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgICAgICAgICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKVxuICAgICAgICAgICAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJrZXkgPSBya2V5c1tya11cbiAgICAgICAgICAgICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJykgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJlxuICAgICAgICAgICAgICAgICFyZXN1bHQucGF0aG5hbWVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLydcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgICAgICAgICAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAgICAgICAgICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgICAgICAgICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgICAgICAgICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgICAgICAgICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICAgICAgICAgICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrID0ga2V5c1t2XVxuICAgICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbFxuICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJylcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJydcbiAgICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnXG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpXG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoXG4gICAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJ1xuICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGhcbiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdFxuICAgICAgICAgICAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICAgICAgICAgICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJydcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJydcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IHAgKyBzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzXG4gICAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzU291cmNlQWJzID1cbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgICAgICAgICAgICBpc1JlbEFicyA9XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgICAgICAgIChyZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICAgICAgICAgIG11c3RFbmRBYnMgPVxuICAgICAgICAgICAgICAgIGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8IChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSksXG4gICAgICAgICAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgICAgICAgICBzcmNQYXRoID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSkgfHwgW10sXG4gICAgICAgICAgICAgIHJlbFBhdGggPVxuICAgICAgICAgICAgICAgIChyZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpKSB8fCBbXSxcbiAgICAgICAgICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gICAgICAgICAgICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gICAgICAgICAgICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gICAgICAgICAgICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAgICAgICAgICAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gICAgICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnXG4gICAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gbnVsbFxuICAgICAgICAgICAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdFxuICAgICAgICAgICAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gJydcbiAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGxcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdFxuICAgICAgICAgICAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtdXN0RW5kQWJzID1cbiAgICAgICAgICAgICAgICBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzUmVsQWJzKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID1cbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnXG4gICAgICAgICAgICAgICAgICA/IHJlbGF0aXZlLmhvc3RcbiAgICAgICAgICAgICAgICAgIDogcmVzdWx0Lmhvc3RcbiAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID1cbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJydcbiAgICAgICAgICAgICAgICAgID8gcmVsYXRpdmUuaG9zdG5hbWVcbiAgICAgICAgICAgICAgICAgIDogcmVzdWx0Lmhvc3RuYW1lXG4gICAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2hcbiAgICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgICAgICAgc3JjUGF0aCA9IHJlbFBhdGhcbiAgICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAgICAgICAgICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgICAgICAgICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdXG4gICAgICAgICAgICAgIHNyY1BhdGgucG9wKClcbiAgICAgICAgICAgICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpXG4gICAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2hcbiAgICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgICAgICAgICAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgICAgICAgICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgICAgICAgICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgICAgICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KClcbiAgICAgICAgICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgICAgICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgICAgICAgICAgICB2YXIgYXV0aEluSG9zdCA9XG4gICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpXG4gICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoXG4gICAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID1cbiAgICAgICAgICAgICAgICAgIChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgICAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbFxuICAgICAgICAgICAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAgICAgICAgICAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgICAgIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF1cbiAgICAgICAgICAgIHZhciBoYXNUcmFpbGluZ1NsYXNoID1cbiAgICAgICAgICAgICAgKChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgICAgICAgICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpKSB8fFxuICAgICAgICAgICAgICBsYXN0ID09PSAnJ1xuXG4gICAgICAgICAgICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgICAgICAgICAgdmFyIHVwID0gMFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICBsYXN0ID0gc3JjUGF0aFtpXVxuICAgICAgICAgICAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICB1cCsrXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgICAgIHVwLS1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gICAgICAgICAgICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICAgICAgICAgICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBtdXN0RW5kQWJzICYmXG4gICAgICAgICAgICAgIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAgICAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgnJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgIHNyY1BhdGgucHVzaCgnJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzQWJzb2x1dGUgPVxuICAgICAgICAgICAgICBzcmNQYXRoWzBdID09PSAnJyB8fCAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKVxuXG4gICAgICAgICAgICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICAgICAgICAgICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGVcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBzcmNQYXRoLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gc3JjUGF0aC5zaGlmdCgpXG4gICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgICAgICAgICB2YXIgYXV0aEluSG9zdCA9XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMFxuICAgICAgICAgICAgICAgICAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpXG4gICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KClcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aClcblxuICAgICAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGxcbiAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBudWxsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wYXRoID1cbiAgICAgICAgICAgICAgICAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aFxuICAgICAgICAgICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzXG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgIH1cblxuICAgICAgICAgIFVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhvc3QgPSB0aGlzLmhvc3RcbiAgICAgICAgICAgIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KVxuICAgICAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgICAgcG9ydCA9IHBvcnRbMF1cbiAgICAgICAgICAgICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3RcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgICAgIGlzU3RyaW5nOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzT2JqZWN0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc051bGw6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmcgPT0gbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUpID0+IHtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgYXJnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAvKioqLyAnLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzJzpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLyoqKi8gKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG4gICAgICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICAgICAgLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbiAgICAgICAgICB2YXIgaXNBcmd1bWVudHNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGlzLWFyZ3VtZW50cyAqLyAnLi9ub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uICovICcuL25vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIHdoaWNoLXR5cGVkLWFycmF5ICovICcuL25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaXMtdHlwZWQtYXJyYXkgKi8gJy4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIGZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmNhbGwuYmluZChmKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgIHZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuXG4gICAgICAgICAgdmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZylcblxuICAgICAgICAgIHZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZilcbiAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpXG4gICAgICAgICAgdmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpXG5cbiAgICAgICAgICBpZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0XG4gICAgICAgICAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvblxuICAgICAgICAgIGV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5XG5cbiAgICAgICAgICAvLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG4gICAgICAgICAgZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZSkgfHxcbiAgICAgICAgICAgICAgKGlucHV0ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgICAgICAgICAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0RhdGFWaWV3KHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXdcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXlcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXlcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5J1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNYXBUb1N0cmluZy53b3JraW5nID1cbiAgICAgICAgICAgIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgICAgICAgICAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc01hcCA9IGlzTWFwXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1NldFRvU3RyaW5nLndvcmtpbmcgPVxuICAgICAgICAgICAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4gICAgICAgICAgZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgICAgICAgICAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXRcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1NldCA9IGlzU2V0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPVxuICAgICAgICAgICAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4gICAgICAgICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgICAgICAgICAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcFxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID1cbiAgICAgICAgICAgIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuICAgICAgICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID1cbiAgICAgICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgICAgICAgICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlclxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID1cbiAgICAgICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbiAgICAgICAgICBmdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgICAgICAgICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlld1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID1cbiAgICAgICAgICAgIHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICBmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgICAgICAgICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlclxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb25cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3JcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3JcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3RcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGVcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgKGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyXG4gICAgICAgICAgO1snaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMnOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvKioqLyAoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcbiAgICAgICAgICAvKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBwcm9jZXNzL2Jyb3dzZXIgKi8gJy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgY29uc29sZS1icm93c2VyaWZ5ICovICcuL25vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIC8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAgICAgICAgICAvLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gICAgICAgICAgLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gICAgICAgICAgLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICAgICAgICAgIC8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbiAgICAgICAgICAvLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAgICAgICAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gICAgICAgICAgLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gICAgICAgICAgLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICAgICAgICAgIC8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbiAgICAgICAgICAvLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAgICAgICAgICAvLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAgICAgICAgICAvLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4gICAgICAgICAgLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuICAgICAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID1cbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3JzID0ge31cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgICAgICAgICAgb2JqLFxuICAgICAgICAgICAgICAgICAga2V5c1tpXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nXG4gICAgICAgICAgZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgICAgICAgICAgICB2YXIgb2JqZWN0cyA9IFtdXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAxXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50c1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoXG4gICAgICAgICAgICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJ1xuICAgICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4XG4gICAgICAgICAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJyVzJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYXJnc1tpKytdKVxuICAgICAgICAgICAgICAgIGNhc2UgJyVkJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYXJnc1tpKytdKVxuICAgICAgICAgICAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgICAgICAgICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIHhcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgICAgICAvLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICAgICAgICAgIC8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gICAgICAgICAgZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbiAoZm4sIG1zZykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd2FybmVkID0gZmFsc2VcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShtc2cpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuZWQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlcHJlY2F0ZWRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGVidWdzID0ge31cbiAgICAgICAgICB2YXIgZGVidWdFbnZSZWdleCA9IC9eJC9cblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHXG4gICAgICAgICAgICBkZWJ1Z0VudiA9IGRlYnVnRW52XG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgICAgICAgICAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWRcbiAgICAgICAgICAgICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWJ1Z3Nbc2V0XVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAgICAgICAgICAgKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICAvKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG4gICAgICAgICAgZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgdmFyIGN0eCA9IHtcbiAgICAgICAgICAgICAgc2VlbjogW10sXG4gICAgICAgICAgICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGVnYWN5Li4uXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM11cbiAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAgICAgICAgICAgLy8gbGVnYWN5Li4uXG4gICAgICAgICAgICAgIGN0eC5zaG93SGlkZGVuID0gb3B0c1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgICAgICAgICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICAgICAgICAgICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2VcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZVxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlXG4gICAgICAgICAgICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aClcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdFxuXG4gICAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG4gICAgICAgICAgaW5zcGVjdC5jb2xvcnMgPSB7XG4gICAgICAgICAgICBib2xkOiBbMSwgMjJdLFxuICAgICAgICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgICAgICAgdW5kZXJsaW5lOiBbNCwgMjRdLFxuICAgICAgICAgICAgaW52ZXJzZTogWzcsIDI3XSxcbiAgICAgICAgICAgIHdoaXRlOiBbMzcsIDM5XSxcbiAgICAgICAgICAgIGdyZXk6IFs5MCwgMzldLFxuICAgICAgICAgICAgYmxhY2s6IFszMCwgMzldLFxuICAgICAgICAgICAgYmx1ZTogWzM0LCAzOV0sXG4gICAgICAgICAgICBjeWFuOiBbMzYsIDM5XSxcbiAgICAgICAgICAgIGdyZWVuOiBbMzIsIDM5XSxcbiAgICAgICAgICAgIG1hZ2VudGE6IFszNSwgMzldLFxuICAgICAgICAgICAgcmVkOiBbMzEsIDM5XSxcbiAgICAgICAgICAgIHllbGxvdzogWzMzLCAzOV0sXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG4gICAgICAgICAgaW5zcGVjdC5zdHlsZXMgPSB7XG4gICAgICAgICAgICBzcGVjaWFsOiAnY3lhbicsXG4gICAgICAgICAgICBudW1iZXI6ICd5ZWxsb3cnLFxuICAgICAgICAgICAgYm9vbGVhbjogJ3llbGxvdycsXG4gICAgICAgICAgICB1bmRlZmluZWQ6ICdncmV5JyxcbiAgICAgICAgICAgIG51bGw6ICdib2xkJyxcbiAgICAgICAgICAgIHN0cmluZzogJ2dyZWVuJyxcbiAgICAgICAgICAgIGRhdGU6ICdtYWdlbnRhJyxcbiAgICAgICAgICAgIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICAgICAgICAgICByZWdleHA6ICdyZWQnLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV1cblxuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgJ1xcdTAwMWJbJyArXG4gICAgICAgICAgICAgICAgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICtcbiAgICAgICAgICAgICAgICAnbScgK1xuICAgICAgICAgICAgICAgIHN0ciArXG4gICAgICAgICAgICAgICAgJ1xcdTAwMWJbJyArXG4gICAgICAgICAgICAgICAgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICtcbiAgICAgICAgICAgICAgICAnbSdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0ge31cblxuICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpZHgpIHtcbiAgICAgICAgICAgICAgaGFzaFt2YWxdID0gdHJ1ZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIGhhc2hcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICAgICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgICAgICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAgICAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eClcbiAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSlcbiAgICAgICAgICAgIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpXG5cbiAgICAgICAgICAgIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGlzRXJyb3IodmFsdWUpICYmXG4gICAgICAgICAgICAgIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJydcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcbiAgICAgICAgICAgICAgICAgIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAncmVnZXhwJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmFzZSA9ICcnLFxuICAgICAgICAgICAgICBhcnJheSA9IGZhbHNlLFxuICAgICAgICAgICAgICBicmFjZXMgPSBbJ3snLCAnfSddXG5cbiAgICAgICAgICAgIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBhcnJheSA9IHRydWVcbiAgICAgICAgICAgICAgYnJhY2VzID0gWydbJywgJ10nXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnXG4gICAgICAgICAgICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICAgICAgICAgICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgICAgICAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgICAgICAgICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFxuICAgICAgICAgICAgICAgICAgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICdyZWdleHAnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnNlZW4ucHVzaCh2YWx1ZSlcblxuICAgICAgICAgICAgdmFyIG91dHB1dFxuICAgICAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICByZWN1cnNlVGltZXMsXG4gICAgICAgICAgICAgICAgICB2aXNpYmxlS2V5cyxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIGFycmF5XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc2Vlbi5wb3AoKVxuXG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhciBzaW1wbGUgPVxuICAgICAgICAgICAgICAgIFwiJ1wiICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArXG4gICAgICAgICAgICAgICAgXCInXCJcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpXG4gICAgICAgICAgICBpZiAoaXNCb29sZWFuKHZhbHVlKSkgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJylcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgICAgICAgICAgIGlmIChpc051bGwodmFsdWUpKSByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW11cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2VUaW1lcyxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIFN0cmluZyhpKSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXG4gICAgICAgICAgICAgICAgICBmb3JtYXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZVRpbWVzLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KFxuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByZWN1cnNlVGltZXMsXG4gICAgICAgICAgICB2aXNpYmxlS2V5cyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGFycmF5XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSwgc3RyLCBkZXNjXG4gICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtrZXldLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgbmFtZSA9ICdbJyArIGtleSArICddJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyXG4gICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgICAgLnN1YnN0cigyKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID1cbiAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgc3RyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgICAgICAgICAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpXG4gICAgICAgICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpXG4gICAgICAgICAgICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIilcbiAgICAgICAgICAgICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgICAgICAgICAgIHZhciBudW1MaW5lc0VzdCA9IDBcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgICAgICAgICAgbnVtTGluZXNFc3QrK1xuICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0KytcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxXG4gICAgICAgICAgICB9LCAwKVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBicmFjZXNbMF0gK1xuICAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgIGJyYWNlc1sxXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbiAgICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbiAgICAgICAgICBleHBvcnRzLnR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3N1cHBvcnQvdHlwZXMgKi8gJy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcilcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhblxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzTnVsbCA9IGlzTnVsbFxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnID09IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXJcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZ1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcgPT09IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWRcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwXG4gICAgICAgICAgZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0RhdGUoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGVcbiAgICAgICAgICBleHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBpc09iamVjdChlKSAmJlxuICAgICAgICAgICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yXG4gICAgICAgICAgZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvclxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb25cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgYXJnID09PSBudWxsIHx8XG4gICAgICAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAvLyBFUzYgc3ltYm9sXG4gICAgICAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZVxuXG4gICAgICAgICAgZXhwb3J0cy5pc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9zdXBwb3J0L2lzQnVmZmVyICovICcuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYWQobikge1xuICAgICAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbW9udGhzID0gW1xuICAgICAgICAgICAgJ0phbicsXG4gICAgICAgICAgICAnRmViJyxcbiAgICAgICAgICAgICdNYXInLFxuICAgICAgICAgICAgJ0FwcicsXG4gICAgICAgICAgICAnTWF5JyxcbiAgICAgICAgICAgICdKdW4nLFxuICAgICAgICAgICAgJ0p1bCcsXG4gICAgICAgICAgICAnQXVnJyxcbiAgICAgICAgICAgICdTZXAnLFxuICAgICAgICAgICAgJ09jdCcsXG4gICAgICAgICAgICAnTm92JyxcbiAgICAgICAgICAgICdEZWMnLFxuICAgICAgICAgIF1cblxuICAgICAgICAgIC8vIDI2IEZlYiAxNjoxOTozNFxuICAgICAgICAgIGZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKVxuICAgICAgICAgICAgdmFyIHRpbWUgPSBbXG4gICAgICAgICAgICAgIHBhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpLFxuICAgICAgICAgICAgXS5qb2luKCc6JylcbiAgICAgICAgICAgIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG4gICAgICAgICAgZXhwb3J0cy5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgJyVzIC0gJXMnLFxuICAgICAgICAgICAgICB0aW1lc3RhbXAoKSxcbiAgICAgICAgICAgICAgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAgICAgICAgICAgKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICAgICAgICAgICAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICAgICAgICAgICAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICAgICAgICAgICAqICAgICBwcm90b3R5cGUuXG4gICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gICAgICAgICAgICovXG4gICAgICAgICAgZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaW5oZXJpdHMgKi8gJy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24gKG9yaWdpbiwgYWRkKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gICAgICAgICAgICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpblxuXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZClcbiAgICAgICAgICAgIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID1cbiAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICAgICAgZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJ1xuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmXG4gICAgICAgICAgICAgIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZm4sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZuKCkge1xuICAgICAgICAgICAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3RcbiAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW11cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHByb21pc2VSZWplY3QoZXJyKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KGVycilcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSlcblxuICAgICAgICAgICAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbClcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZm4sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbiAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAgICAgICAgICAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgICAgICAgICAgIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gICAgICAgICAgICBpZiAoIXJlYXNvbikge1xuICAgICAgICAgICAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvblxuICAgICAgICAgICAgICByZWFzb24gPSBuZXdSZWFzb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYihyZWFzb24pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgICAgICAgICAgIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW11cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAgICAgICAgICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICAgICAgICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncykudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZWopIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgICAgICAgICAgY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgICAgICAgIGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tpZmllZFxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnlcblxuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgIC8qKiovICcuL25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcyc6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qKiovIChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuICAgICAgICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgICAgICAgdmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIGZvcmVhY2ggKi8gJy4vbm9kZV9tb2R1bGVzL2ZvcmVhY2gvaW5kZXguanMnXG4gICAgICAgICAgKVxuICAgICAgICAgIHZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgYXZhaWxhYmxlLXR5cGVkLWFycmF5cyAqLyAnLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcydcbiAgICAgICAgICApXG4gICAgICAgICAgdmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgY2FsbC1iaW5kL2NhbGxCb3VuZCAqLyAnLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcydcbiAgICAgICAgICApXG5cbiAgICAgICAgICB2YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJylcbiAgICAgICAgICB2YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaGFzLXN5bWJvbHMgKi8gJy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzJ1xuICAgICAgICAgICkoKVxuICAgICAgICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9XG4gICAgICAgICAgICBoYXNTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnXG5cbiAgICAgICAgICB2YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpXG5cbiAgICAgICAgICB2YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJylcbiAgICAgICAgICB2YXIgdG9TdHJUYWdzID0ge31cbiAgICAgICAgICB2YXIgZ09QRCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgKi8gJy4vbm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmpzJ1xuICAgICAgICAgIClcbiAgICAgICAgICB2YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbiAgICAgICAgICBpZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgZm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gbmV3IF9fd2VicGFja19yZXF1aXJlX18uZ1t0eXBlZEFycmF5XSgpXG4gICAgICAgICAgICAgICAgaWYgKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmFsRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheSArXG4gICAgICAgICAgICAgICAgICAgICAgJyBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLidcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKVxuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgICAgICAgICAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgICAgdmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90bylcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGZvdW5kTmFtZSA9IGZhbHNlXG4gICAgICAgICAgICBmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICBpZiAoIWZvdW5kTmFtZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGdldHRlci5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IHR5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmROYW1lID0gbmFtZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gZm91bmROYW1lXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgaXMtdHlwZWQtYXJyYXkgKi8gJy4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG4gICAgICAgICAgICAgIHJldHVybiAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgLyoqKioqKi9cbiAgICB9IC8vIFRoZSBtb2R1bGUgY2FjaGVcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKioqKiovIC8qKioqKiovIHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fSAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuICAgIC8qKioqKiovXG4gICAgLyoqKioqKi8gLyoqKioqKi8gZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuICAgICAgLyoqKioqKi8gLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gICAgICAvKioqKioqLyB2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXVxuICAgICAgLyoqKioqKi8gaWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKioqKiovIHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0c1xuICAgICAgICAvKioqKioqL1xuICAgICAgfSAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuICAgICAgLyoqKioqKi8gLyoqKioqKi8gdmFyIG1vZHVsZSA9IChfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuICAgICAgICAvKioqKioqLyBpZDogbW9kdWxlSWQsXG4gICAgICAgIC8qKioqKiovIGxvYWRlZDogZmFsc2UsXG4gICAgICAgIC8qKioqKiovIGV4cG9ydHM6IHt9LFxuICAgICAgICAvKioqKioqL1xuICAgICAgfSkgLy8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gICAgICAvKioqKioqL1xuICAgICAgLyoqKioqKi8gLyoqKioqKi8gX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX19cbiAgICAgICkgLy8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuICAgICAgLyoqKioqKi9cbiAgICAgIC8qKioqKiovIC8qKioqKiovIG1vZHVsZS5sb2FkZWQgPSB0cnVlIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gICAgICAvKioqKioqL1xuICAgICAgLyoqKioqKi8gLyoqKioqKi8gcmV0dXJuIG1vZHVsZS5leHBvcnRzXG4gICAgICAvKioqKioqL1xuICAgIH0gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovIC8qKioqKiovXG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKioqKiovIDsoKCkgPT4ge1xuICAgICAgLyoqKioqKi8gLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuICAgICAgLyoqKioqKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbiAgICAgICAgLyoqKioqKi8gZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAvKioqKioqLyBpZiAoXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJlxuICAgICAgICAgICAgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvKioqKioqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogZGVmaW5pdGlvbltrZXldLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgIH1cbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH1cbiAgICAgIC8qKioqKiovXG4gICAgfSkoKSAvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovIC8qKioqKiovXG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqL1xuICAgIDsoKCkgPT4ge1xuICAgICAgLyoqKioqKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqKioqKi8gaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXNcbiAgICAgICAgLyoqKioqKi8gdHJ5IHtcbiAgICAgICAgICAvKioqKioqLyByZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvKioqKioqLyBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3dcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICB9XG4gICAgICAgIC8qKioqKiovXG4gICAgICB9KSgpXG4gICAgICAvKioqKioqL1xuICAgIH0pKCkgLyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqLyAvKioqKioqL1xuICAgIC8qKioqKiovXG4gICAgLyoqKioqKi9cbiAgICA7KCgpID0+IHtcbiAgICAgIC8qKioqKiovIF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApXG4gICAgICAvKioqKioqL1xuICAgIH0pKCkgLyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqLyAvKioqKioqL1xuICAgIC8qKioqKiovXG4gICAgLyoqKioqKi9cbiAgICA7KCgpID0+IHtcbiAgICAgIC8qKioqKiovIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiAgICAgIC8qKioqKiovIF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4gICAgICAgIC8qKioqKiovIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAvKioqKioqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ01vZHVsZScsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICB9XG4gICAgICAgIC8qKioqKiovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgICAgLyoqKioqKi9cbiAgICAgIH1cbiAgICAgIC8qKioqKiovXG4gICAgfSkoKSAvKiB3ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yICovIC8qKioqKiovXG4gICAgLyoqKioqKi9cbiAgICAvKioqKioqL1xuICAgIDsoKCkgPT4ge1xuICAgICAgLyoqKioqKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG4gICAgICAgIC8qKioqKiovIG1vZHVsZS5wYXRocyA9IFtdXG4gICAgICAgIC8qKioqKiovIGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXVxuICAgICAgICAvKioqKioqLyByZXR1cm4gbW9kdWxlXG4gICAgICAgIC8qKioqKiovXG4gICAgICB9XG4gICAgICAvKioqKioqL1xuICAgIH0pKClcbiAgICAvKioqKioqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fVxuICAgIC8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGluIHN0cmljdCBtb2RlLlxuICAgIDsoKCkgPT4ge1xuICAgICAgJ3VzZSBzdHJpY3QnXG4gICAgICB2YXIgZXhwb3J0cyA9IF9fd2VicGFja19leHBvcnRzX19cbiAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSlcbiAgICAgIGV4cG9ydHMuSW1ndXJDbGllbnQgPSB2b2lkIDBcbiAgICAgIHZhciBjbGllbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2xpZW50ICovICcuL3NyYy9jbGllbnQudHMnKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdJbWd1ckNsaWVudCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNsaWVudF8xLkltZ3VyQ2xpZW50XG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pKClcblxuICAgIC8qKioqKiovIHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fXG4gICAgLyoqKioqKi9cbiAgfSkoKVxufSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZkMlZpY0dGamF5OTFibWwyWlhKellXeE5iMlIxYkdWRVpXWnBibWwwYVc5dUlpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWhjbkpoZVMxbWFXeDBaWEl2YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGemMyVnlkQzlpZFdsc1pDOWhjM05sY25RdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkZ6YzJWeWRDOWlkV2xzWkM5cGJuUmxjbTVoYkM5aGMzTmxjblF2WVhOelpYSjBhVzl1WDJWeWNtOXlMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5aGMzTmxjblF2WW5WcGJHUXZhVzUwWlhKdVlXd3ZaWEp5YjNKekxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTloYzNObGNuUXZZblZwYkdRdmFXNTBaWEp1WVd3dmRYUnBiQzlqYjIxd1lYSnBjMjl1Y3k1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZZWFpoYVd4aFlteGxMWFI1Y0dWa0xXRnljbUY1Y3k5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdllYaHBiM012YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5aFpHRndkR1Z5Y3k5NGFISXVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5aGVHbHZjeTVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdllYaHBiM012YkdsaUwyTmhibU5sYkM5RFlXNWpaV3d1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRjRhVzl6TDJ4cFlpOWpZVzVqWld3dlEyRnVZMlZzVkc5clpXNHVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5allXNWpaV3d2YVhORFlXNWpaV3d1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRjRhVzl6TDJ4cFlpOWpiM0psTDBGNGFXOXpMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5aGVHbHZjeTlzYVdJdlkyOXlaUzlKYm5SbGNtTmxjSFJ2Y2sxaGJtRm5aWEl1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRjRhVzl6TDJ4cFlpOWpiM0psTDJKMWFXeGtSblZzYkZCaGRHZ3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5amIzSmxMMk55WldGMFpVVnljbTl5TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWhlR2x2Y3k5c2FXSXZZMjl5WlM5a2FYTndZWFJqYUZKbGNYVmxjM1F1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRjRhVzl6TDJ4cFlpOWpiM0psTDJWdWFHRnVZMlZGY25KdmNpNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZiR2xpTDJOdmNtVXZiV1Z5WjJWRGIyNW1hV2N1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyRjRhVzl6TDJ4cFlpOWpiM0psTDNObGRIUnNaUzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdllYaHBiM012YkdsaUwyTnZjbVV2ZEhKaGJuTm1iM0p0UkdGMFlTNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZiR2xpTDJSbFptRjFiSFJ6TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWhlR2x2Y3k5c2FXSXZhR1ZzY0dWeWN5OWlhVzVrTG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OWhlR2x2Y3k5c2FXSXZhR1ZzY0dWeWN5OWlkV2xzWkZWU1RDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZiR2xpTDJobGJIQmxjbk12WTI5dFltbHVaVlZTVEhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTlvWld4d1pYSnpMMk52YjJ0cFpYTXVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5b1pXeHdaWEp6TDJselFXSnpiMngxZEdWVlVrd3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJGNGFXOXpMMnhwWWk5b1pXeHdaWEp6TDJselFYaHBiM05GY25KdmNpNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZiR2xpTDJobGJIQmxjbk12YVhOVlVreFRZVzFsVDNKcFoybHVMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5aGVHbHZjeTlzYVdJdmFHVnNjR1Z5Y3k5dWIzSnRZV3hwZW1WSVpXRmtaWEpPWVcxbExtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTloZUdsdmN5OXNhV0l2YUdWc2NHVnljeTl3WVhKelpVaGxZV1JsY25NdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMkY0YVc5ekwyeHBZaTlvWld4d1pYSnpMM053Y21WaFpDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WVhocGIzTXZiR2xpTDNWMGFXeHpMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5allXeHNMV0pwYm1RdlkyRnNiRUp2ZFc1a0xtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTlqWVd4c0xXSnBibVF2YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJOdmJuTnZiR1V0WW5KdmQzTmxjbWxtZVM5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdlpHVm1hVzVsTFhCeWIzQmxjblJwWlhNdmFXNWtaWGd1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwyVnpMV0ZpYzNSeVlXTjBMMmhsYkhCbGNuTXZaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eUxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTlsY3pZdGIySnFaV04wTFdGemMybG5iaTlwYm1SbGVDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12WlhabGJuUnpMMlYyWlc1MGN5NXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12Wm05eVpXRmphQzlwYm1SbGVDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12Wm05eWJTMWtZWFJoTDJ4cFlpOWljbTkzYzJWeUxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTltZFc1amRHbHZiaTFpYVc1a0wybHRjR3hsYldWdWRHRjBhVzl1TG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OW1kVzVqZEdsdmJpMWlhVzVrTDJsdVpHVjRMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5blpYUXRhVzUwY21sdWMybGpMMmx1WkdWNExtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTlvWVhNdGMzbHRZbTlzY3k5cGJtUmxlQzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdmFHRnpMWE41YldKdmJITXZjMmhoYlhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMmhoY3k5emNtTXZhVzVrWlhndWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMmx1YUdWeWFYUnpMMmx1YUdWeWFYUnpYMkp5YjNkelpYSXVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJsekxXRnlaM1Z0Wlc1MGN5OXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZhWE10WjJWdVpYSmhkRzl5TFdaMWJtTjBhVzl1TDJsdVpHVjRMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5cGN5MXVZVzR2YVcxd2JHVnRaVzUwWVhScGIyNHVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDJsekxXNWhiaTlwYm1SbGVDNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12YVhNdGJtRnVMM0J2YkhsbWFXeHNMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5cGN5MXVZVzR2YzJocGJTNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12YVhNdGRIbHdaV1F0WVhKeVlYa3ZhVzVrWlhndWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMjlpYW1WamRDMXBjeTlwYlhCc1pXMWxiblJoZEdsdmJpNXFjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXViMlJsWDIxdlpIVnNaWE12YjJKcVpXTjBMV2x6TDJsdVpHVjRMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5dlltcGxZM1F0YVhNdmNHOXNlV1pwYkd3dWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMjlpYW1WamRDMXBjeTl6YUdsdExtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTl2WW1wbFkzUXRhMlY1Y3k5cGJYQnNaVzFsYm5SaGRHbHZiaTVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdmIySnFaV04wTFd0bGVYTXZhVzVrWlhndWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMMjlpYW1WamRDMXJaWGx6TDJselFYSm5kVzFsYm5SekxtcHpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwyNXZaR1ZmYlc5a2RXeGxjeTl3Y205alpYTnpMMkp5YjNkelpYSXVhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDNGMVpYSjVjM1J5YVc1bkwyUmxZMjlrWlM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5dWIyUmxYMjF2WkhWc1pYTXZjWFZsY25semRISnBibWN2Wlc1amIyUmxMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5eGRXVnllWE4wY21sdVp5OXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTlwYldkMWNpMWhjR2t2TGk5emNtTXZZV3hpZFcwdloyVjBRV3hpZFcwdWRITWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmMzSmpMMkZzWW5WdEwybHVaR1Y0TG5Seklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDNOeVl5OWpiR2xsYm5RdWRITWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmMzSmpMMk52YlcxdmJpOWxibVJ3YjJsdWRITXVkSE1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZjM0pqTDJOdmJXMXZiaTkwZVhCbGN5NTBjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXpjbU12WTI5dGJXOXVMM1YwYVd4ekxuUnpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwzTnlZeTluWVd4c1pYSjVMMmRsZEVkaGJHeGxjbmt1ZEhNaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2YzNKakwyZGhiR3hsY25rdloyVjBVM1ZpY21Wa1pHbDBSMkZzYkdWeWVTNTBjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXpjbU12WjJGc2JHVnllUzlwYm1SbGVDNTBjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXpjbU12WjJGc2JHVnllUzl6WldGeVkyaEhZV3hzWlhKNUxuUnpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwzTnlZeTluWlhSQmRYUm9iM0pwZW1GMGFXOXVTR1ZoWkdWeUxuUnpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwzTnlZeTlwYldGblpTOWtaV3hsZEdWSmJXRm5aUzUwY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl6Y21NdmFXMWhaMlV2Wm1GMmIzSnBkR1ZKYldGblpTNTBjeUlzSW5kbFluQmhZMnM2THk5cGJXZDFjaTFoY0drdkxpOXpjbU12YVcxaFoyVXZaMlYwU1cxaFoyVXVkSE1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZjM0pqTDJsdFlXZGxMMmx1WkdWNExuUnpJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM4dUwzTnlZeTlwYldGblpTOTFjR1JoZEdWSmJXRm5aUzUwY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl6Y21NdmFXMWhaMlV2ZFhCc2IyRmtMblJ6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5MGMyeHBZaTkwYzJ4cFlpNWxjell1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMeTR2Ym05a1pWOXRiMlIxYkdWekwzVnliQzl1YjJSbFgyMXZaSFZzWlhNdmNIVnVlV052WkdVdmNIVnVlV052WkdVdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMM1Z5YkM5MWNtd3Vhbk1pTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZibTlrWlY5dGIyUjFiR1Z6TDNWeWJDOTFkR2xzTG1weklpd2lkMlZpY0dGamF6b3ZMMmx0WjNWeUxXRndhUzh1TDI1dlpHVmZiVzlrZFd4bGN5OTFkR2xzTDNOMWNIQnZjblF2YVhOQ2RXWm1aWEpDY205M2MyVnlMbXB6SWl3aWQyVmljR0ZqYXpvdkwybHRaM1Z5TFdGd2FTOHVMMjV2WkdWZmJXOWtkV3hsY3k5MWRHbHNMM04xY0hCdmNuUXZkSGx3WlhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTHk0dmJtOWtaVjl0YjJSMWJHVnpMM1YwYVd3dmRYUnBiQzVxY3lJc0luZGxZbkJoWTJzNkx5OXBiV2QxY2kxaGNHa3ZMaTl1YjJSbFgyMXZaSFZzWlhNdmQyaHBZMmd0ZEhsd1pXUXRZWEp5WVhrdmFXNWtaWGd1YW5NaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMM2RsWW5CaFkyc3ZZbTl2ZEhOMGNtRndJaXdpZDJWaWNHRmphem92TDJsdFozVnlMV0Z3YVM5M1pXSndZV05yTDNKMWJuUnBiV1V2WkdWbWFXNWxJSEJ5YjNCbGNuUjVJR2RsZEhSbGNuTWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTDNkbFluQmhZMnN2Y25WdWRHbHRaUzluYkc5aVlXd2lMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTDNkbFluQmhZMnN2Y25WdWRHbHRaUzlvWVhOUGQyNVFjbTl3WlhKMGVTQnphRzl5ZEdoaGJtUWlMQ0ozWldKd1lXTnJPaTh2YVcxbmRYSXRZWEJwTDNkbFluQmhZMnN2Y25WdWRHbHRaUzl0WVd0bElHNWhiV1Z6Y0dGalpTQnZZbXBsWTNRaUxDSjNaV0p3WVdOck9pOHZhVzFuZFhJdFlYQnBMM2RsWW5CaFkyc3ZjblZ1ZEdsdFpTOXViMlJsSUcxdlpIVnNaU0JrWldOdmNtRjBiM0lpTENKM1pXSndZV05yT2k4dmFXMW5kWEl0WVhCcEx5NHZjM0pqTDJsdVpHVjRMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNRMEZCUXp0QlFVTkVMRTg3T3pzN096czdPenM3UVVOaVFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WFFVRlhMRTFCUVUwN1FVRkRha0lzVjBGQlZ5eFRRVUZUTzBGQlEzQkNMRmRCUVZjc1VVRkJVVHRCUVVOdVFpeFpRVUZaTzBGQlExbzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNhVUpCUVdsQ0xHZENRVUZuUWp0QlFVTnFRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN096czdPenM3T3pzN096czdPMEZEZUVKQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5oT3p0QlFVVmlMSFZDUVVGMVFpd3lSVUZCTWtVc2EwTkJRV3RETEcxQ1FVRnRRaXhIUVVGSExFVkJRVVVzVDBGQlR5eHJRMEZCYTBNc09FaEJRVGhJTEVkQlFVY3NSVUZCUlN4eFFrRkJjVUk3TzBGQlJUZFdMR2xFUVVGcFJDd3dRMEZCTUVNc01FUkJRVEJFTEVWQlFVVTdPMEZCUlhaS0xHVkJRV1VzYlVKQlFVOHNRMEZCUXl4NVJVRkJiVUk3UVVGRE1VTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEhGQ1FVRnhRaXh0UWtGQlR5eERRVUZETEhsSFFVRnRRenM3UVVGRmFFVXNaMEpCUVdkQ0xHMUNRVUZQTEVOQlFVTXNNRU5CUVU4N1FVRkRMMEk3TzBGQlJVRXNjVUpCUVhGQ0xIRkZRVUZ6UWp0QlFVTXpRenRCUVVOQk96dEJRVVZCTEcxRVFVRnRSQ3huUjBGQmJVTTdRVUZEZEVZc2RVTkJRWFZETEcxQ1FVRlBMRU5CUVVNc2IwUkJRVmM3UVVGRE1VUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNiVUpCUVcxQ0xHMUNRVUZQTEVOQlFVTXNOa1pCUVRaQ096dEJRVVY0UkR0QlFVTkJPMEZCUTBFc1EwRkJRenRCUVVORU8wRkJRMEU3T3p0QlFVZEJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMRzFDUVVGdFFqdEJRVU51UWp0QlFVTkJPenRCUVVWQk8wRkJRMEVzSzBKQlFTdENPMEZCUXk5Q08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQkxHbENRVUZwUWl4UFFVRlBMR1ZCUVdVc1QwRkJUeXhsUVVGbExFOUJRVThzVjBGQlZ5eFBRVUZQTzBGQlEzUkdPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVN4dFFrRkJiVUk3TzBGQlJXNUNPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenRCUVVORU96czdRVUZIUVR0QlFVTkJMSEZGUVVGeFJTeGhRVUZoTzBGQlEyeEdPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVN4bFFVRmxPenRCUVVWbU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN096dEJRVWRJTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRXNSVUZCUlR0QlFVTkdPenM3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPenM3UVVGSFNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTEVWQlFVVTdPenRCUVVkR08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEVzUlVGQlJUczdPMEZCUjBZN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzZVVSQlFYbEVPenRCUVVWNlJEdEJRVU5CTzBGQlEwRXNTMEZCU3pzN08wRkJSMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CT3p0QlFVVkJMSEZEUVVGeFF6dEJRVU55UXpzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQkxFZEJRVWM3T3p0QlFVZElPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc2VVSkJRWGxDTzBGQlEzcENPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxHdERRVUZyUXpzN1FVRkZiRU03UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTEV0QlFVczdRVUZEVEN4SFFVRkhPMEZCUTBnN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTdzBSa0ZCTkVZc1pVRkJaVHRCUVVNelJ6dEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTdzBSa0ZCTkVZc1pVRkJaVHRCUVVNelJ6dEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3TzBGQlJVRTdRVUZEUVN3MFJrRkJORVlzWlVGQlpUdEJRVU16Unp0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN3MFJrRkJORVlzWlVGQlpUdEJRVU16Unp0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3l4RlFVRkZPenRCUVVWUU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSTdPMEZCUlc1Q096dEJRVVZCTEhGQ1FVRnhRaXhwUWtGQmFVSTdRVUZEZEVNN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc1JVRkJSVHM3TzBGQlIwWTdRVUZEUVN4M1JVRkJkMFVzWlVGQlpUdEJRVU4yUmp0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFTkJRVU03UVVGRFJDeHhRenM3T3pzN096czdPenM3TzBGRGRHNUNRVHRCUVVOQk8wRkJRMkU3TzBGQlJXSXNaME5CUVdkRExHZENRVUZuUWl4elFrRkJjMElzVDBGQlR5eDFSRUZCZFVRc2JVTkJRVzFETERCRVFVRXdSQ3h6UmtGQmMwWXNaMFZCUVdkRkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEdsRFFVRnBReXd5UTBGQk1rTXNSVUZCUlN4RlFVRkZMRVZCUVVVc1pVRkJaVHM3UVVGRkwyUXNNa05CUVRKRExHdENRVUZyUWl4clEwRkJhME1zY1VWQlFYRkZMRVZCUVVVc1JVRkJSU3hQUVVGUExHdENRVUZyUWl4RlFVRkZMRmxCUVZrN08wRkJSUzlOTEdsRVFVRnBSQ3d3UTBGQk1FTXNNRVJCUVRCRUxFVkJRVVU3TzBGQlJYWktMREpEUVVFeVF5eG5Ra0ZCWjBJc2EwSkJRV3RDTEU5QlFVOHNNa0pCUVRKQ0xIZEVRVUYzUkN4blEwRkJaME1zZFVSQlFYVkVMREpFUVVFeVJDeEZRVUZGT3p0QlFVVXpWQ3cyUkVGQk5rUXNjMFZCUVhORkxEaEVRVUU0UkN4dlFrRkJiMEk3TzBGQlJYSk9MR2xFUVVGcFJDd3dSVUZCTUVVc1lVRkJZU3hGUVVGRkxIRkRRVUZ4UXpzN1FVRkZMMHNzZFVOQlFYVkRMSFZDUVVGMVFpeDFSa0ZCZFVZc1JVRkJSU3hoUVVGaE96dEJRVVZ3U3l3d1EwRkJNRU1zSzBSQlFTdEVMREpGUVVFeVJTeEZRVUZGTEhsRlFVRjVSU3hsUVVGbExITkVRVUZ6UkN4RlFVRkZMRVZCUVVVc2RVUkJRWFZFT3p0QlFVVXZXQ3hyUTBGQmEwTXNaMFZCUVdkRkxITkVRVUZ6UkN3clJFRkJLMFFzYlVOQlFXMURMREpGUVVFeVJTeEZRVUZGTEhGRFFVRnhReXhwUkVGQmFVUXNORUpCUVRSQ0xFVkJRVVVzY1VKQlFYRkNMSGRGUVVGM1JTeEZRVUZGTEhGRVFVRnhSQ3hsUVVGbExIZEZRVUYzUlN4RlFVRkZMRVZCUVVVc2QwTkJRWGRETEVkQlFVY3NaME5CUVdkRE96dEJRVVZ5ZGtJc2NVTkJRWEZETEhkRlFVRjNSU3d3UTBGQk1FTXNPRU5CUVRoRExFMUJRVTBzZDBWQlFYZEZMRWRCUVVjc1lVRkJZU3hGUVVGRkxGbEJRVmtzWTBGQll5eEZRVUZGT3p0QlFVVnFWU3d3UTBGQk1FTXNhME5CUVd0RExHZERRVUZuUXl4RlFVRkZMRTlCUVU4c2QwUkJRWGRFTEdkQ1FVRm5RaXgxUWtGQmRVSXNhMFJCUVd0RUxHdERRVUZyUXl4MVJFRkJkVVFzYVVKQlFXbENMRWRCUVVjc1JVRkJSU3d3UTBGQk1FTTdPMEZCUlM5YUxHZERRVUZuUXl4dFJVRkJiVVU3TzBGQlJXNUhMR2REUVVGblF5dzBSVUZCTkVVc2FVSkJRV2xDTEZWQlFWVXNSMEZCUnl3NFFrRkJPRUk3TzBGQlJYaExMRFpDUVVFMlFpeG5SMEZCWjBjc1owUkJRV2RFTEVkQlFVY3NNa0pCUVRKQ096dEJRVVV6VFN4MVFrRkJkVUlzTWtWQlFUSkZMR3REUVVGclF5eHRRa0ZCYlVJc1IwRkJSeXhGUVVGRkxFOUJRVThzYTBOQlFXdERMRGhJUVVFNFNDeEhRVUZITEVWQlFVVXNjVUpCUVhGQ096dEJRVVUzVml4bFFVRmxMRzFDUVVGUExFTkJRVU1zTUVOQlFVODdRVUZET1VJN08wRkJSVUVzWjBKQlFXZENMRzFDUVVGUExFTkJRVU1zYVVWQlFWYzdRVUZEYmtNc1owVkJRV2RGT3pzN1FVRkhhRVU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3hEUVVGRE96czdRVUZIUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVWQlFVVTdRVUZEUmpzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h4UWtGQmNVSTdRVUZEY2tJN08wRkJSVUU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0RzN08wRkJSMEU3UVVGRFFTeHpSVUZCYzBVN1FVRkRkRVU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJMSE5DUVVGelFpeFBRVUZQTEZkQlFWY3NUMEZCVHl4blFrRkJaMElzVDBGQlR6czdRVUZGZEVVN1FVRkRRVHRCUVVOQk8wRkJRMEVzVTBGQlV6czdPMEZCUjFRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHM3TzBGQlIwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc2IwVkJRVzlGTzBGQlEzQkZMRzFEUVVGdFF5eGpRVUZqTEVkQlFVY3NZMEZCWXpzN1FVRkZiRVU3UVVGRFFUdEJRVU5CTEcxRVFVRnRSRHRCUVVOdVJEczdPMEZCUjBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeGhRVUZoTEdOQlFXTTdRVUZETTBJN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVTBGQlV6dEJRVU5VTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzVDBGQlR6czdPMEZCUjFBc2EwSkJRV3RDT3p0QlFVVnNRanRCUVVOQkxIRkNRVUZ4UWp0QlFVTnlRaXhMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hQUVVGUE96czdRVUZIVUN4clFrRkJhMEk3TzBGQlJXeENPMEZCUTBFc2NVSkJRWEZDTzBGQlEzSkNMRXRCUVVzN1FVRkRURHRCUVVOQkxITkRRVUZ6UXp0QlFVTjBRenRCUVVOQk96dEJRVVZCTEcxSlFVRnRTVHRCUVVOdVNUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWE8wRkJRMWc3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hUUVVGVE96czdRVUZIVkN4dlFrRkJiMEk3UVVGRGNFSTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxEQkNRVUV3UWp0QlFVTXhRaXhQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRXNiVUpCUVcxQ08wRkJRMjVDT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMT3pzN1FVRkhURHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwd3NWVUZCVlN4UFFVRlBMRmRCUVZjc1QwRkJUenRCUVVOdVF6dEJRVU5CTzBGQlEwRXNXVUZCV1N4UFFVRlBMRmRCUVZjc1QwRkJUeXg1UWtGQmVVSXNUMEZCVHp0QlFVTnlSVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVDBGQlR6dEJRVU5RTzBGQlEwRTdPenRCUVVkQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRXNiVVJCUVcxRU96dEJRVVZ1UkR0QlFVTkJPMEZCUTBFc1UwRkJVenRCUVVOVU96czdRVUZIUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdPenRCUVVkVU8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEZkQlFWYzdRVUZEV0R0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN096dEJRVWRNTEdkQ1FVRm5RanM3UVVGRmFFSTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNNa05CUVRKRE8wRkJRek5ETzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRU3hIUVVGSE96dEJRVVZJTzBGQlEwRXNRMEZCUXpzN1FVRkZSQ3huUXpzN096czdPenM3T3pzN1FVTndaa0U3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5oTzBGQlEySTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzZFVKQlFYVkNMREpGUVVFeVJTeHJRMEZCYTBNc2JVSkJRVzFDTEVkQlFVY3NSVUZCUlN4UFFVRlBMR3REUVVGclF5dzRTRUZCT0Vnc1IwRkJSeXhGUVVGRkxIRkNRVUZ4UWpzN1FVRkZOMVlzYVVSQlFXbEVMREJEUVVFd1F5d3dSRUZCTUVRc1JVRkJSVHM3UVVGRmRrb3NhVVJCUVdsRUxEQkZRVUV3UlN4aFFVRmhMRVZCUVVVc2NVTkJRWEZET3p0QlFVVXZTeXgxUTBGQmRVTXNkVUpCUVhWQ0xIVkdRVUYxUml4RlFVRkZMR0ZCUVdFN08wRkJSWEJMTERaQ1FVRTJRaXhuUjBGQlowY3NaMFJCUVdkRUxFZEJRVWNzTWtKQlFUSkNPenRCUVVVelRTd3dRMEZCTUVNc0swUkJRU3RFTERKRlFVRXlSU3hGUVVGRkxIbEZRVUY1UlN4bFFVRmxMSE5FUVVGelJDeEZRVUZGTEVWQlFVVXNkVVJCUVhWRU96dEJRVVV2V0N4blEwRkJaME1zTkVWQlFUUkZMR2xDUVVGcFFpeFZRVUZWTEVkQlFVY3NPRUpCUVRoQ096dEJRVVY0U3l4bFFVRmxPenRCUVVWbU8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQkxFTkJRVU03T3p0QlFVZEVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMT3p0QlFVVk1PMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEVzUTBGQlF6czdPMEZCUjBRN1FVRkRRVHRCUVVOQkxFTkJRVU03T3p0QlFVZEVPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNRMEZCUXpzN08wRkJSMFE3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxIRkRRVUZ4UXl4dFFrRkJUeXhEUVVGRExIZEVRVUZYTzBGQlEzaEVMRGhFUVVFNFJEczdRVUZGT1VRN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFTeEhRVUZIT3pzN1FVRkhTRHRCUVVOQk8wRkJRMEVzUTBGQlF6dEJRVU5FTzBGQlEwRTdRVUZEUVN4cFEwRkJhVU1zYlVKQlFVOHNRMEZCUXl3d1EwRkJUenRCUVVOb1JEczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTeERRVUZETzBGQlEwUTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3hEUVVGRE8wRkJRMFE3UVVGRFFTeHhSVUZCY1VVc1lVRkJZVHRCUVVOc1JqdEJRVU5CT3p0QlFVVkJMSEZEUVVGeFF5eHRRa0ZCVHl4RFFVRkRMSGRFUVVGWE8wRkJRM2hFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE96dEJRVVZJTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNRMEZCUXp0QlFVTkVMRzlDUVVGdlFpeFRPenM3T3pzN096czdPenRCUTJ4TmNFSTdRVUZEUVR0QlFVTmhPenRCUVVWaUxHbERRVUZwUXl4dlJrRkJiMFk3TzBGQlJYSklMRFpDUVVFMlFpdzJSVUZCTmtVN08wRkJSVEZITEhkRFFVRjNReXhsUVVGbExHVkJRV1VzWjBKQlFXZENMRzlDUVVGdlFpeE5RVUZOTERCRFFVRXdReXdyUWtGQkswSXNZVUZCWVN4eFFrRkJjVUlzYlVOQlFXMURMRVZCUVVVc1JVRkJSU3hqUVVGakxGZEJRVmNzVlVGQlZTeEZRVUZGTEZWQlFWVXNUVUZCVFN4cFJFRkJhVVFzUlVGQlJTeFZRVUZWTEd0Q1FVRnJRaXhGUVVGRkxFVkJRVVVzWVVGQllUczdRVUZGZGxvc0swSkJRU3RDTEc5RFFVRnZRenM3UVVGRmJrVXNkVUpCUVhWQ0xESkZRVUV5UlN4clEwRkJhME1zYlVKQlFXMUNMRWRCUVVjc1JVRkJSU3hQUVVGUExHdERRVUZyUXl3NFNFRkJPRWdzUjBGQlJ5eEZRVUZGTEhGQ1FVRnhRanM3UVVGRk4xWTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPenRCUVVWQkxIVkRRVUYxUXl4dFFrRkJUeXhEUVVGRExHOUVRVUZYTzBGQlF6RkVPMEZCUTBFN1FVRkRRVHRCUVVOQkxHZEVRVUZuUkN4dFFrRkJUeXhEUVVGRExEaERRVUZST3p0QlFVVm9SVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQkxIRkNRVUZ4UWl4eFJVRkJjMEk3UVVGRE0wTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFc2FVSkJRV2xDTEdkQ1FVRm5RanRCUVVOcVF6dEJRVU5CTzBGQlEwRXNSMEZCUnpzN08wRkJSMGc3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc1EwRkJRenRCUVVORU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3TzBGQlIwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVN4MVEwRkJkVU1zVTBGQlV6dEJRVU5vUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR1ZCUVdVN08wRkJSV1k3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEhOQ1FVRnpRaXgxUWtGQmRVSTdRVUZETjBNN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxFTkJRVU03UVVGRFJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6czdPMEZCUjBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPenM3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUczdPMEZCUjBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4clEwRkJhME03TzBGQlJXeERPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3T3p0QlFVZElPenRCUVVWQkxGRkJRVkVzYTBKQlFXdENPMEZCUXpGQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVN4cFFrRkJhVUlzZDBKQlFYZENPMEZCUTNwRE96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZIT3pzN1FVRkhTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVN4cFFrRkJhVUlzYzBKQlFYTkNPMEZCUTNaRE96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTEVOQlFVTTdRVUZEUkR0QlFVTkJPMEZCUTBFN096dEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzYVVKQlFXbENMRzlDUVVGdlFqdEJRVU55UXl4NVFrRkJlVUk3UVVGRGVrSTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPenM3UVVGSFFUdEJRVU5CTEV0QlFVczdRVUZEVEN3clFrRkJLMEk3TzBGQlJTOUNPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFc2IwSkJRVzlDTEhGQ1FVRnhRanRCUVVONlF5dzJRa0ZCTmtJN1FVRkROMEk3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4bFFVRmxMRmRCUVZjc2IwSkJRVzlDTEZkQlFWYzdRVUZEZWtRN1FVRkRRVHM3UVVGRlFTeHBRa0ZCYVVJc2MwSkJRWE5DTzBGQlEzWkRPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc2FVSkJRV2xDTEhGQ1FVRnhRanRCUVVOMFF6dEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNhVU5CUVdsRE8wRkJRMnBET3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJMSEZDUVVGeFFpeDFRa0ZCZFVJN1FVRkROVU03UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZ3NWVUZCVlN4alFVRmpPMEZCUTNoQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNUMEZCVHp0QlFVTlFPMEZCUTBFc1QwRkJUenRCUVVOUU8wRkJRMEU3TzBGQlJVRXNZMEZCWXl4clFrRkJhMEk3UVVGRGFFTTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0RzN08wRkJSMEVzWVVGQllTeHBRa0ZCYVVJN1FVRkRPVUk3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFVTdPenM3T3pzN096czdPMEZETDNGQ1lUczdRVUZGWWl4aFFVRmhMRzFDUVVGUExFTkJRVU1zTUVSQlFXTTdPMEZCUlc1RE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4blFrRkJaMElzY1VKQlFVMDdRVUZEZEVJc1JVRkJSVHRCUVVOR096czdPenM3T3pzN096dEJRM0JDUVN3MFJrRkJkVU1zUXpzN096czdPenM3T3pzN1FVTkJNVUk3TzBGQlJXSXNXVUZCV1N4dFFrRkJUeXhEUVVGRExIRkVRVUZaTzBGQlEyaERMR0ZCUVdFc2JVSkJRVThzUTBGQlF5eHBSVUZCYTBJN1FVRkRka01zWTBGQll5eHRRa0ZCVHl4RFFVRkRMSGxGUVVGelFqdEJRVU0xUXl4bFFVRmxMRzFDUVVGUExFTkJRVU1zTWtWQlFYVkNPMEZCUXpsRExHOUNRVUZ2UWl4dFFrRkJUeXhEUVVGRExEWkZRVUYxUWp0QlFVTnVSQ3h0UWtGQmJVSXNiVUpCUVU4c1EwRkJReXh0UmtGQk1rSTdRVUZEZEVRc2MwSkJRWE5DTEcxQ1FVRlBMRU5CUVVNc2VVWkJRVGhDTzBGQlF6VkVMR3RDUVVGclFpeHRRa0ZCVHl4RFFVRkRMSGxGUVVGeFFqczdRVUZGTDBNN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN3MFEwRkJORU03UVVGRE5VTTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVTBGQlV6dEJRVU5VTzBGQlEwRTdRVUZEUVR0QlFVTkJMRTlCUVU4N1FVRkRVRHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEU5QlFVODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN096czdPenM3T3pzN096dEJRMnhNWVRzN1FVRkZZaXhaUVVGWkxHMUNRVUZQTEVOQlFVTXNhMFJCUVZNN1FVRkROMElzVjBGQlZ5eHRRa0ZCVHl4RFFVRkRMR2RGUVVGblFqdEJRVU51UXl4WlFVRlpMRzFDUVVGUExFTkJRVU1zTkVSQlFXTTdRVUZEYkVNc2EwSkJRV3RDTEcxQ1FVRlBMRU5CUVVNc2QwVkJRVzlDTzBGQlF6bERMR1ZCUVdVc2JVSkJRVThzUTBGQlF5eDNSRUZCV1RzN1FVRkZia003UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGbEJRVmtzVFVGQlRUdEJRVU5zUWp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFTeGxRVUZsTEcxQ1FVRlBMRU5CUVVNc2EwVkJRV2xDTzBGQlEzaERMRzlDUVVGdlFpeHRRa0ZCVHl4RFFVRkRMRFJGUVVGelFqdEJRVU5zUkN4cFFrRkJhVUlzYlVKQlFVOHNRMEZCUXl4elJVRkJiVUk3TzBGQlJUVkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWlVGQlpTeHRRa0ZCVHl4RFFVRkRMRzlGUVVGclFqczdRVUZGZWtNN1FVRkRRU3h4UWtGQmNVSXNiVUpCUVU4c1EwRkJReXhuUmtGQmQwSTdPMEZCUlhKRU96dEJRVVZCTzBGQlEwRXNjMEpCUVhOQ096czdPenM3T3pzN096czdRVU4yUkZRN08wRkJSV0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WFFVRlhMRkZCUVZFN1FVRkRia0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPenM3T3pzN096czdPenM3UVVOc1FtRTdPMEZCUldJc1lVRkJZU3h0UWtGQlR5eERRVUZETERKRVFVRlZPenRCUVVVdlFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1UwRkJVenRCUVVOd1FqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdPMEZCUlVnN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPenM3T3pzN096czdPenRCUTNoRVlUczdRVUZGWWp0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN096dEJRMHBoT3p0QlFVVmlMRmxCUVZrc2JVSkJRVThzUTBGQlF5eHhSRUZCV1R0QlFVTm9ReXhsUVVGbExHMUNRVUZQTEVOQlFVTXNlVVZCUVhGQ08wRkJRelZETEhsQ1FVRjVRaXh0UWtGQlR5eERRVUZETEdsR1FVRnpRanRCUVVOMlJDeHpRa0ZCYzBJc2JVSkJRVThzUTBGQlF5d3lSVUZCYlVJN1FVRkRha1FzYTBKQlFXdENMRzFDUVVGUExFTkJRVU1zYlVWQlFXVTdPMEZCUlhwRE8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHZEVRVUZuUkR0QlFVTm9SRHRCUVVOQk8wRkJRMEVzZVVKQlFYbENPMEZCUTNwQ0xFdEJRVXM3UVVGRFREdEJRVU5CTEVOQlFVTTdPMEZCUlVRN1FVRkRRVHRCUVVOQk8wRkJRMEVzWjBSQlFXZEVPMEZCUTJoRU8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJMRU5CUVVNN08wRkJSVVE3T3pzN096czdPenM3T3p0QlF6bEdZVHM3UVVGRllpeFpRVUZaTEcxQ1FVRlBMRU5CUVVNc2NVUkJRVms3TzBGQlJXaERPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WFFVRlhMRk5CUVZNN1FVRkRjRUlzVjBGQlZ5eFRRVUZUTzBGQlEzQkNPMEZCUTBFc1dVRkJXU3hQUVVGUE8wRkJRMjVDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExFOUJRVTg3UVVGRGJFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVTBGQlV6dEJRVU53UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdPMEZCUlVFN096czdPenM3T3pzN096dEJRMjVFWVRzN1FVRkZZaXh2UWtGQmIwSXNiVUpCUVU4c1EwRkJReXh0UmtGQk1FSTdRVUZEZEVRc2EwSkJRV3RDTEcxQ1FVRlBMRU5CUVVNc0swVkJRWGRDT3p0QlFVVnNSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGZEJRVmNzVDBGQlR6dEJRVU5zUWl4aFFVRmhMRTlCUVU4N1FVRkRjRUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN096dEJRMjVDWVRzN1FVRkZZaXh0UWtGQmJVSXNiVUpCUVU4c1EwRkJReXh4UlVGQlowSTdPMEZCUlRORE8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhYUVVGWExFOUJRVTg3UVVGRGJFSXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGZEJRVmNzVDBGQlR6dEJRVU5zUWl4WFFVRlhMRTlCUVU4N1FVRkRiRUlzWVVGQllTeE5RVUZOTzBGQlEyNUNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3T3p0QlEycENZVHM3UVVGRllpeFpRVUZaTEcxQ1FVRlBMRU5CUVVNc2NVUkJRVms3UVVGRGFFTXNiMEpCUVc5Q0xHMUNRVUZQTEVOQlFVTXNkVVZCUVdsQ08wRkJRemRETEdWQlFXVXNiVUpCUVU4c1EwRkJReXgxUlVGQmIwSTdRVUZETTBNc1pVRkJaU3h0UWtGQlR5eERRVUZETEhsRVFVRmhPenRCUVVWd1F6dEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeGhRVUZoTEZGQlFWRTdRVUZEY2tJN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3dyUWtGQkswSTdRVUZETDBJc2RVTkJRWFZETzBGQlEzWkRPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc1IwRkJSenRCUVVOSU96czdPenM3T3pzN096czdRVU01UldFN08wRkJSV0k3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4TlFVRk5PMEZCUTJwQ0xGZEJRVmNzVDBGQlR6dEJRVU5zUWl4WFFVRlhMRTlCUVU4N1FVRkRiRUlzVjBGQlZ5eFBRVUZQTzBGQlEyeENMRmRCUVZjc1QwRkJUenRCUVVOc1FpeGhRVUZoTEUxQlFVMDdRVUZEYmtJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTjZRMkU3TzBGQlJXSXNXVUZCV1N4dFFrRkJUeXhEUVVGRExHMUVRVUZWT3p0QlFVVTVRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhYUVVGWExFOUJRVTg3UVVGRGJFSXNZVUZCWVN4UFFVRlBPMEZCUTNCQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1MREpDUVVFeVFqdEJRVU16UWl4TFFVRkxPMEZCUTB3N1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3TzBGQlJVZzdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVN4SFFVRkhPenRCUVVWSU8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFc1IwRkJSenM3UVVGRlNEdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3pzN1FVRkZURHM3UVVGRlFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTjBSbUU3TzBGQlJXSXNhMEpCUVd0Q0xHMUNRVUZQTEVOQlFVTXNiVVZCUVdVN08wRkJSWHBETzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1UwRkJVenRCUVVOd1FpeFhRVUZYTEZOQlFWTTdRVUZEY0VJc1YwRkJWeXhQUVVGUE8wRkJRMnhDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU40UW1FN08wRkJSV0lzV1VGQldTeHRRa0ZCVHl4RFFVRkRMSEZFUVVGWk96dEJRVVZvUXp0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExHTkJRV003UVVGRGVrSXNWMEZCVnl4TlFVRk5PMEZCUTJwQ0xGZEJRVmNzWlVGQlpUdEJRVU14UWl4aFFVRmhMRVZCUVVVN1FVRkRaanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQk96czdPenM3T3pzN096czdPMEZEYmtKaE96dEJRVVZpTEZsQlFWa3NiVUpCUVU4c1EwRkJReXhyUkVGQlV6dEJRVU0zUWl3d1FrRkJNRUlzYlVKQlFVOHNRMEZCUXl3NFJrRkJLMEk3TzBGQlJXcEZPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNZMEZCWXl4dFFrRkJUeXhEUVVGRExHZEZRVUZuUWp0QlFVTjBReXhIUVVGSExHbENRVUZwUWl4UFFVRlBMRzFFUVVGdFJDeFBRVUZQTzBGQlEzSkdPMEZCUTBFc1kwRkJZeXh0UWtGQlR5eERRVUZETEdsRlFVRnBRanRCUVVOMlF6dEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxIZEZRVUYzUlR0QlFVTjRSVHRCUVVOQk8wRkJRMEU3UVVGRFFTeDFSRUZCZFVRN1FVRkRka1E3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNUMEZCVHl4WlFVRlpPMEZCUTI1Q08wRkJRMEU3UVVGRFFTeEhRVUZIT3p0QlFVVklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFTkJRVU03TzBGQlJVUTdRVUZEUVR0QlFVTkJMRU5CUVVNN08wRkJSVVE3T3pzN096czdPenM3T3p0QlEycEhZVHM3UVVGRllqdEJRVU5CTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzYVVKQlFXbENPMEZCUTNCRE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenM3T3pzN096czdPenRCUTFaaE96dEJRVVZpTEZsQlFWa3NiVUpCUVU4c1EwRkJReXh4UkVGQldUczdRVUZGYUVNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhYUVVGWExFOUJRVTg3UVVGRGJFSXNZVUZCWVN4UFFVRlBPMEZCUTNCQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVN4SFFVRkhPMEZCUTBnN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFOUJRVTg3UVVGRFVEdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBc1MwRkJTenM3UVVGRlREdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96czdPenM3T3pzN096czdRVU55UldFN08wRkJSV0k3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGZEJRVmNzVDBGQlR6dEJRVU5zUWl4aFFVRmhMRTlCUVU4N1FVRkRjRUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVOaVlUczdRVUZGWWl4WlFVRlpMRzFDUVVGUExFTkJRVU1zY1VSQlFWazdPMEZCUldoRE8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVN3d1EwRkJNRU03UVVGRE1VTXNVMEZCVXpzN1FVRkZWRHRCUVVOQkxEUkVRVUUwUkN4M1FrRkJkMEk3UVVGRGNFWTdRVUZEUVN4VFFVRlRPenRCUVVWVU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3pzN1FVRkZURHRCUVVOQk8wRkJRMEU3UVVGRFFTeHJRMEZCYTBNN1FVRkRiRU1zSzBKQlFTdENMR0ZCUVdFc1JVRkJSVHRCUVVNNVF6dEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PenM3T3pzN096czdPenM3UVVOd1JHRTdPMEZCUldJN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ5eFBRVUZQTzBGQlEyeENMR0ZCUVdFc1VVRkJVVHRCUVVOeVFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3T3pzN096czdPenM3TzBGRFltRTdPMEZCUldJN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ5eEZRVUZGTzBGQlEySXNZVUZCWVN4UlFVRlJPMEZCUTNKQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTldZVHM3UVVGRllpeFpRVUZaTEcxQ1FVRlBMRU5CUVVNc2NVUkJRVms3TzBGQlJXaERPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdOQlFXTXNUMEZCVHp0QlFVTnlRaXhuUWtGQlowSTdRVUZEYUVJN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hqUVVGakxFOUJRVTg3UVVGRGNrSXNaMEpCUVdkQ0xGRkJRVkU3UVVGRGVFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6czdRVUZGVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NT3pzN096czdPenM3T3pzN1FVTnVSV0U3TzBGQlJXSXNXVUZCV1N4dFFrRkJUeXhEUVVGRExHMUVRVUZWT3p0QlFVVTVRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN096czdPenM3T3pzN096dEJRMWhoT3p0QlFVVmlMRmxCUVZrc2JVSkJRVThzUTBGQlF5eHhSRUZCV1RzN1FVRkZhRU03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhoUVVGaExFOUJRVTg3UVVGRGNFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEdsQ1FVRnBRaXhsUVVGbE96dEJRVVZvUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hQUVVGUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnpzN1FVRkZTRHRCUVVOQk96czdPenM3T3pzN096czdRVU53UkdFN08wRkJSV0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMQ3RDUVVFclFqdEJRVU12UWp0QlFVTkJPMEZCUTBFc1YwRkJWeXhUUVVGVE8wRkJRM0JDTEdGQlFXRTdRVUZEWWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3T3pzN096czdPenM3T3p0QlF6RkNZVHM3UVVGRllpeFhRVUZYTEcxQ1FVRlBMRU5CUVVNc1owVkJRV2RDT3p0QlFVVnVRenM3UVVGRlFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEU5QlFVODdRVUZEYkVJc1lVRkJZU3hSUVVGUk8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhoUVVGaExGRkJRVkU3UVVGRGNrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xHRkJRV0VzVVVGQlVUdEJRVU55UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeGhRVUZoTEZGQlFWRTdRVUZEY2tJN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEdGQlFXRXNVVUZCVVR0QlFVTnlRanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExFOUJRVTg3UVVGRGJFSXNZVUZCWVN4UlFVRlJPMEZCUTNKQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1YwRkJWeXhQUVVGUE8wRkJRMnhDTEdGQlFXRXNVVUZCVVR0QlFVTnlRanRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExFOUJRVTg3UVVGRGJFSXNZVUZCWVN4UlFVRlJPMEZCUTNKQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVDBGQlR6dEJRVU5zUWl4aFFVRmhMRkZCUVZFN1FVRkRja0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ5eFBRVUZQTzBGQlEyeENMRmxCUVZrc1VVRkJVVHRCUVVOd1FqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExFOUJRVTg3UVVGRGJFSXNZVUZCWVN4UlFVRlJPMEZCUTNKQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGZEJRVmNzVDBGQlR6dEJRVU5zUWl4aFFVRmhMRkZCUVZFN1FVRkRja0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ5eFBRVUZQTzBGQlEyeENMR0ZCUVdFc1VVRkJVVHRCUVVOeVFqdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEU5QlFVODdRVUZEYkVJc1lVRkJZU3hSUVVGUk8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZkQlFWY3NUMEZCVHp0QlFVTnNRaXhoUVVGaExGRkJRVkU3UVVGRGNrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xHRkJRV0VzVVVGQlVUdEJRVU55UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WFFVRlhMRTlCUVU4N1FVRkRiRUlzWVVGQllTeFBRVUZQTzBGQlEzQkNPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4aFFVRmhPMEZCUTNoQ0xGZEJRVmNzVTBGQlV6dEJRVU53UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNiVU5CUVcxRExFOUJRVTg3UVVGRE1VTTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzZFVKQlFYVkNMRk5CUVZNc1IwRkJSeXhUUVVGVE8wRkJRelZETERKQ1FVRXlRanRCUVVNelFqdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xHRkJRV0VzVDBGQlR6dEJRVU53UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwd3NORUpCUVRSQ08wRkJRelZDTEV0QlFVczdRVUZEVER0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3TzBGQlJVRXNkVU5CUVhWRExFOUJRVTg3UVVGRE9VTTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGZEJRVmNzVDBGQlR6dEJRVU5zUWl4WFFVRlhMRTlCUVU4N1FVRkRiRUlzV1VGQldTeFBRVUZQTzBGQlEyNUNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmRCUVZjc1QwRkJUenRCUVVOc1FpeFpRVUZaTEU5QlFVODdRVUZEYmtJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTTVWbUU3TzBGQlJXSXNiVUpCUVcxQ0xHMUNRVUZQTEVOQlFVTXNORVJCUVdVN08wRkJSVEZETEdWQlFXVXNiVUpCUVU4c1EwRkJReXcyUTBGQlNUczdRVUZGTTBJN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN096czdPenM3T3pzN096dEJRMlJoT3p0QlFVVmlMRmRCUVZjc2JVSkJRVThzUTBGQlF5dzBSRUZCWlR0QlFVTnNReXh0UWtGQmJVSXNiVUpCUVU4c1EwRkJReXcwUkVGQlpUczdRVUZGTVVNN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzYjBKQlFXOUNMRkZCUVZFc1YwRkJWenRCUVVOMlF5eEZRVUZGTzBGQlEwWTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc01rTkJRVEpETEcxQ1FVRnRRanRCUVVNNVJDeERRVUZETzBGQlEwUXNRMEZCUXl4dlFrRkJiMEk3UVVGRGNrSTdPenM3T3pzN096czdPMEZET1VOQk8wRkJRMEVzVjBGQlZ5eHRRa0ZCVHl4RFFVRkRMSGxEUVVGTk8wRkJRM3BDTEdGQlFXRXNiVUpCUVU4c1EwRkJReXh4UkVGQlVUdEJRVU0zUWl4blFrRkJaMEk3TzBGQlJXaENPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeFhRVUZYTEhGQ1FVRk5MRzlDUVVGdlFpeHhRa0ZCVFR0QlFVTXpReXhqUVVGakxIRkNRVUZOTzBGQlEzQkNMRU5CUVVNN1FVRkRSRHRCUVVOQkxFTkJRVU03UVVGRFJEdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzWlVGQlpTeHpRa0ZCYzBJN1FVRkRja003UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenM3UVVOMFJtRTdPMEZCUldJc1YwRkJWeXh0UWtGQlR5eERRVUZETEhkRVFVRmhPMEZCUTJoRE96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1owTkJRV2RETEdkRFFVRm5RenRCUVVOb1JUdEJRVU5CTEhOQ1FVRnpRanRCUVVOMFFqdEJRVU5CTzBGQlEwRTdRVUZEUVN4RlFVRkZMRmxCUVZrN1FVRkRaRHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTQ3hGUVVGRk8wRkJRMFk3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEdkQ1FVRm5RaXhyUWtGQmEwSTdRVUZEYkVNN1FVRkRRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPenM3T3pzN096czdPenM3UVVONlJHRTdPMEZCUldJc2JVSkJRVzFDTEcxQ1FVRlBMRU5CUVVNc05FUkJRV1U3TzBGQlJURkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlJUdEJRVU5HTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk96czdPenM3T3pzN096czdRVU5rUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRllUczdRVUZGWWp0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTEdsQ1FVRnBRaXh6UWtGQmMwSTdRVUZEZGtNN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4dFJFRkJiVVFzYVVKQlFXbENPMEZCUTNCRk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdPMEZETjBOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJXRTdPMEZCUldJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFTkJRVU03UVVGRFJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRU5CUVVNN1FVRkRSRHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRTFCUVUwc1QwRkJUeXhKUVVGSkxFOUJRVThzVDBGQlR5eFBRVUZQTzBGQlEzUkRPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHMUNRVUZ0UWpzN1FVRkZia0k3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenM3UVVGRlJEczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4cFFrRkJhVUlzYzBKQlFYTkNPMEZCUTNaRE96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHVkJRV1U3UVVGRFpqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR05CUVdNN1FVRkRaRHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJMRzFDUVVGdFFpeFRRVUZUTzBGQlF6VkNPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN4bFFVRmxPMEZCUTJZN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdPMEZCUlVFc2FVTkJRV2xETEZGQlFWRTdRVUZEZWtNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHMUNRVUZ0UWl4cFFrRkJhVUk3UVVGRGNFTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVN4elEwRkJjME1zVVVGQlVUdEJRVU01UXp0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRXNhVUpCUVdsQ0xFOUJRVTg3UVVGRGVFSTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzVVVGQlVTeDVRa0ZCZVVJN1FVRkRha003UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hwUWtGQmFVSXNaMEpCUVdkQ08wRkJRMnBETzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFc05rUkJRVFpFTEdGQlFXRTdRVUZETVVVN1FVRkRRU3cyUkVGQk5rUXNZVUZCWVR0QlFVTXhSVHRCUVVOQkxFZEJRVWM3UVVGRFNEczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFc2IwTkJRVzlETEdGQlFXRTdRVUZEYWtRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVEN4SFFVRkhPMEZCUTBnN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU12WlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gxUWtGQmRVSXNUMEZCVHp0QlFVTTVRanRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU53UWtFN1FVRkRRVHM3T3pzN096czdPenM3TzBGRFJHRTdPMEZCUldJN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeHRRa0ZCYlVJc2FVSkJRV2xDTzBGQlEzQkRPMEZCUTBFN08wRkJSVUVzT0VWQlFUaEZMSEZEUVVGeFF5eEZRVUZGT3p0QlFVVnlTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3T3pzN096czdPenM3TzBGRGJrUmhPenRCUVVWaUxIRkNRVUZ4UWl4dFFrRkJUeXhEUVVGRExIZEZRVUZyUWpzN1FVRkZMME03T3pzN096czdPenM3T3p0QlEwcGhPenRCUVVWaU96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRMEZCYVVNc0swTkJRU3RETzBGQlEyaEdMRVZCUVVVN1FVRkRSanM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4VlFVRlZPMEZCUTFZc1JVRkJSVHRCUVVOR0xHVkJRV1U3UVVGRFpqdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiMEpCUVc5Q08wRkJRM0JDTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQkxFbEJRVWs3UVVGRFNqdEJRVU5CTzBGQlEwRTdRVUZEUVN4RlFVRkZPMEZCUTBZN08wRkJSVUVzYVVKQlFXbENMRzFDUVVGUExFTkJRVU1zZDBSQlFXRTdPMEZCUlhSRExITkVRVUZ6UkN4dlFrRkJiMElzUjBGQlJ6czdRVUZGTjBVN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhGRVFVRnhSRHRCUVVOeVJDeEZRVUZGTzBGQlEwWXNaMFJCUVdkRU8wRkJRMmhFTEVWQlFVVTdRVUZEUml4elJFRkJjMFE3UVVGRGRFUXNSVUZCUlR0QlFVTkdPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlJUdEJRVU5HTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQkxGZEJRVmNzYlVKQlFVOHNRMEZCUXl3MFJFRkJaVHRCUVVOc1F5eGhRVUZoTEcxQ1FVRlBMRU5CUVVNc05FTkJRVXM3UVVGRE1VSTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTERoQ1FVRTRRanRCUVVNNVFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1JVRkJSVHRCUVVOR08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4RlFVRkZPMEZCUTBZN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJMRGhDUVVFNFFpeHJRa0ZCYTBJN1FVRkRhRVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVN4SlFVRkpPMEZCUTBvN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU42VldFN08wRkJSV0k3UVVGRFFTeHZRa0ZCYjBJc2JVSkJRVThzUTBGQlF5eHZSRUZCVXpzN1FVRkZja003UVVGRFFTeDNRMEZCZDBNc1kwRkJZenRCUVVOMFJDeHZRMEZCYjBNc1kwRkJZenRCUVVOc1JDdzJRMEZCTmtNc1kwRkJZenRCUVVNelJDeDVRMEZCZVVNc1kwRkJZenM3UVVGRmRrUTdRVUZEUVRzN096czdPenM3T3pzN08wRkRXbUU3TzBGQlJXSTdRVUZEUVR0QlFVTkJMREJHUVVFd1JpeGpRVUZqTzBGQlEzaEhMREpEUVVFeVF5eGhRVUZoT3p0QlFVVjRSRHRCUVVOQk8wRkJRMEU3UVVGRFFTd3JRa0ZCSzBJc1kwRkJZenM3UVVGRk4wTXNhVVZCUVdsRkxHTkJRV003UVVGREwwVXNiMFZCUVc5RkxHTkJRV003TzBGQlJXeEdPMEZCUTBFc1owTkJRV2RETEdOQlFXTTdRVUZET1VNN1FVRkRRU3h6UTBGQmMwTXNZMEZCWXpzN1FVRkZjRVFzTUVSQlFUQkVMR05CUVdNN1FVRkRlRVVzT0VSQlFUaEVMR05CUVdNN08wRkJSVFZGTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzWTBGQll5eEZRVUZGTzBGQlEyNURMREJGUVVFd1JTeGpRVUZqT3p0QlFVVjRSaXgzUjBGQmQwY3NZMEZCWXpzN1FVRkZkRWc3UVVGRFFTdzBRMEZCTkVNc1kwRkJZenM3UVVGRk1VUXNOa1JCUVRaRUxHTkJRV003TzBGQlJUTkZPMEZCUTBFN1FVRkRRU3h6UlVGQmMwVXNZMEZCWXp0QlFVTndSanM3UVVGRlFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTjZRMkU3TzBGQlJXSXNWMEZCVnl4dFFrRkJUeXhEUVVGRExEUkVRVUZsT3p0QlFVVnNRenM3T3pzN096czdPenM3UVVOS1FUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4UFFVRlBPMEZCUTFBN1FVRkRRVHRCUVVOQkxFTkJRVU03UVVGRFJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTXhRbUU3TzBGQlJXSTdRVUZEUVN4blFrRkJaMElzYlVKQlFVOHNRMEZCUXl4clJVRkJjVUk3TzBGQlJUZERPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4RFFVRkRPenRCUVVWRUxEQkVRVUV3UkRzN1FVRkZNVVE3T3pzN096czdPenM3T3p0QlEyaERZVHM3UVVGRllqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2IwTkJRVzlETzBGQlEzQkRPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzZDBOQlFYZERPMEZCUTNoRExFVkJRVVU3UVVGRFJqdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdPenM3T3pzN096czdPMEZETDBKaE96dEJRVVZpT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3T3pzN096czdPenM3TzBGRFRtRTdPMEZCUldJc1pVRkJaU3h0UWtGQlR5eERRVUZETEc5RVFVRlhPMEZCUTJ4RExHRkJRV0VzYlVKQlFVOHNRMEZCUXl4dlJVRkJiVUk3TzBGQlJYaERMSEZDUVVGeFFpeHRRa0ZCVHl4RFFVRkRMR2xGUVVGclFqdEJRVU12UXl4clFrRkJhMElzYlVKQlFVOHNRMEZCUXl4eFJFRkJXVHRCUVVOMFF5eFhRVUZYTEcxQ1FVRlBMRU5CUVVNc05rTkJRVkU3TzBGQlJUTkNPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1EwRkJRenM3UVVGRlJEczdPenM3T3pzN096czdPMEZEYmtKaE96dEJRVVZpTEhGQ1FVRnhRaXh0UWtGQlR5eERRVUZETEdsRlFVRnJRanM3UVVGRkwwTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU5VWVRzN1FVRkZZaXhoUVVGaExHMUNRVUZQTEVOQlFVTXNiMFZCUVcxQ08wRkJRM2hETEd0Q1FVRnJRaXh0UWtGQlR5eERRVUZETEhGRVFVRlpPenRCUVVWMFF6czdRVUZGUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEd0Q1FVRnJRanRCUVVOdVF6dEJRVU5CTzBGQlEwRTdRVUZEUVN4RlFVRkZPMEZCUTBZN1FVRkRRVHM3T3pzN096czdPenM3TzBGRFptRTdPMEZCUldJc1kwRkJZeXh0UWtGQlR5eERRVUZETEdkRVFVRlRPMEZCUXk5Q0xESkNRVUV5UWl4dFFrRkJUeXhEUVVGRExEaEZRVUYzUWp0QlFVTXpSQ3huUWtGQlowSXNiVUpCUVU4c1EwRkJReXhyUlVGQmNVSTdPMEZCUlRkRE8wRkJRMEVzYVVKQlFXbENMRzFDUVVGUExFTkJRVU1zZDBSQlFXRTdRVUZEZEVNN08wRkJSVUU3TzBGQlJVRTdRVUZEUVN4blFrRkJaMElzYTBKQlFXdENPMEZCUTJ4RE8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hYUVVGWExHMUNRVUZQTEVOQlFVTXNiMGhCUVRoRE8wRkJRMnBGTERKRFFVRXlRenRCUVVNelF6dEJRVU5CTzBGQlEwRXNaMEpCUVdkQ0xIRkNRVUZOTzBGQlEzUkNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1JVRkJSVHRCUVVOR096dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFbEJRVWtzV1VGQldUdEJRVU5vUWp0QlFVTkJMRVZCUVVVN1FVRkRSanRCUVVOQk96dEJRVVZCTzBGQlEwRXNNa05CUVRKRExHTkJRV003UVVGRGVrUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hoUVVGaExHTkJRV003UVVGRE0wSTdRVUZEUVRzN096czdPenM3T3pzN08wRkROVVJoT3p0QlFVVmlPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenM3T3pzN096czdPenM3UVVOcVFtRTdPMEZCUldJc1lVRkJZU3h0UWtGQlR5eERRVUZETEc5RlFVRnRRanRCUVVONFF5eGxRVUZsTEcxQ1FVRlBMRU5CUVVNc2IwUkJRVmM3TzBGQlJXeERMSEZDUVVGeFFpeHRRa0ZCVHl4RFFVRkRMRzlGUVVGclFqdEJRVU12UXl4clFrRkJhMElzYlVKQlFVOHNRMEZCUXl4M1JFRkJXVHRCUVVOMFF5eFhRVUZYTEcxQ1FVRlBMRU5CUVVNc1owUkJRVkU3TzBGQlJUTkNPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNRMEZCUXpzN1FVRkZSRHM3T3pzN096czdPenM3TzBGRGFrSmhPenRCUVVWaUxIRkNRVUZ4UWl4dFFrRkJUeXhEUVVGRExHOUZRVUZyUWpzN1FVRkZMME03UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN1FVTk9ZVHM3UVVGRllpeHJRa0ZCYTBJc2JVSkJRVThzUTBGQlF5eDNSRUZCV1R0QlFVTjBReXhoUVVGaExHMUNRVUZQTEVOQlFVTXNiMFZCUVcxQ096dEJRVVY0UXp0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEdWQlFXVTdRVUZEYUVNN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlJUdEJRVU5HTzBGQlEwRTdPenM3T3pzN096czdPenRCUTJKaE96dEJRVVZpTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hqUVVGakxHMUNRVUZQTEVOQlFVTXNaMFZCUVdVc1JVRkJSVHRCUVVOMlF6dEJRVU5CTERCRFFVRXdReXhwUWtGQmFVSTdRVUZETTBRc2RVUkJRWFZFTzBGQlEzWkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYzBOQlFYTkRMR05CUVdNN1FVRkRjRVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRTFCUVUwN1FVRkRUanRCUVVOQk8wRkJRMEU3UVVGRFFTeEpRVUZKTzBGQlEwbzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRk8wRkJRMFk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTEd0Q1FVRnJRaXh0UWtGQmJVSTdRVUZEY2tNN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNhMEpCUVd0Q0xHMUNRVUZ0UWp0QlFVTnlRenRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJMR3RDUVVGclFpeHpRa0ZCYzBJN1FVRkRlRU03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU42U0dFN08wRkJSV0k3UVVGRFFTeGhRVUZoTEcxQ1FVRlBMRU5CUVVNc1owVkJRV1U3TzBGQlJYQkRPMEZCUTBFc05FTkJRVFJETEc5Q1FVRnZRaXhGUVVGRkxFZEJRVWNzYlVKQlFVOHNRMEZCUXl4elJVRkJhMEk3TzBGQlJTOUdPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQkxIZERRVUYzUXp0QlFVTjRRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4RlFVRkZPMEZCUTBZN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdPenM3T3pzN096czdPenRCUXk5Q1lUczdRVUZGWWpzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdPenM3T3pzN096czdRVU5vUWtFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRk5CUVZNN1FVRkRWRHRCUVVOQk8wRkJRMEVzUzBGQlN6dEJRVU5NTzBGQlEwRTdRVUZEUVN4RFFVRkRPMEZCUTBRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFc1UwRkJVenRCUVVOVU8wRkJRMEU3UVVGRFFUdEJRVU5CT3pzN1FVRkhRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3TzBGQlNVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhWQ1FVRjFRaXh6UWtGQmMwSTdRVUZETjBNN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHhRa0ZCY1VJN1FVRkRja0k3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQkxIRkRRVUZ4UXpzN1FVRkZja003UVVGRFFUdEJRVU5CT3p0QlFVVkJMREpDUVVFeVFqdEJRVU16UWp0QlFVTkJPMEZCUTBFN1FVRkRRU3cwUWtGQk5FSXNWVUZCVlRzN096czdPenM3T3pzN08wRkRka3gwUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWaE96dEJRVVZpTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTEdsQ1FVRnBRaXhUUVVGVE8wRkJRekZDTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3T3pzN096czdPenM3TzBGREwwVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSV0U3TzBGQlJXSTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFRRVUZUTzBGQlExUXNUMEZCVHp0QlFVTlFPMEZCUTBFN1FVRkRRU3hMUVVGTE96dEJRVVZNT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU12UkdFN08wRkJSV0lzWTBGQll5eEhRVUZITERKR1FVRnRRenRCUVVOd1JDeGpRVUZqTEVkQlFVY3NLMFpCUVhWRE96czdPenM3T3pzN096czdPenM3UVVOR2VFUXNaMGRCUVhGRU8wRkJSWEpFTEc5R1FVRnJSVHRCUVVVelJDeExRVUZMTEZWQlFWVXNVVUZCVVN4RFFVTTFRaXhOUVVGdFFpeEZRVU51UWl4VFFVRnBRanRKUVVWcVFpeE5RVUZOTEVkQlFVY3NSMEZCUnl4SFFVRkhMREJDUVVGakxFbEJRVWtzVTBGQlV5eEZRVUZGTEVOQlFVTTdTVUZETjBNc1QwRkJUeXgxUTBGQkswSXNRMEZCUXl4TlFVRk5MRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlF5eEhRVUZITEVWQlFVTXNRMEZCUXl4RFFVRm5ReXhEUVVGRE8wRkJRM0pITEVOQlFVTTdRVUZPUkN3MFFrRk5RenM3T3pzN096czdPenM3T3pzN08wRkRXRVFzWjBkQlFUSkNPenM3T3pzN096czdPenM3T3pzN08wRkRRVE5DTEhOR1FVRnpRenRCUVVOMFF5eDNTRUZCYTBVN1FVRkRiRVVzTWtWQlQybENPMEZCUTJwQ0xHbEdRVTl0UWp0QlFVTnVRaXd5UlVGQmJVTTdRVUZEYmtNc0swWkJRWE5FTzBGQlZYUkVMRTFCUVUwc1UwRkJVeXhIUVVGSExITkVRVUZ6UkN4RFFVRkRPMEZCUlhwRkxESkhRVUZuUmp0QlFVVm9SaXhOUVVGaExGZEJRVmtzVTBGQlVTeHhRa0ZCV1R0SlFVa3pReXhaUVVGeFFpeFhRVUYzUWp0UlFVTXpReXhMUVVGTExFVkJRVVVzUTBGQlF6dFJRVVJYTEdkQ1FVRlhMRWRCUVZnc1YwRkJWeXhEUVVGaE8xRkJSek5ETEVsQlFVa3NRMEZCUXl4WlFVRlpMRWRCUVVjc1pVRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF6dFpRVU12UWl4UFFVRlBMRVZCUVVVc05FSkJRV2RDTzFsQlEzcENMRTlCUVU4c1JVRkJSVHRuUWtGRFVDeFpRVUZaTEVWQlFVVXNVMEZCVXp0aFFVTjRRanRaUVVORUxGbEJRVmtzUlVGQlJTeE5RVUZOTzFOQlEzSkNMRU5CUVVNc1EwRkJRenRSUVVOSUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NaVUZCU3l4RFFVRkRMRTFCUVUwc1EwRkJRenRaUVVNeFFpeFBRVUZQTEVWQlFVVXNORUpCUVdkQ08xbEJRM3BDTEU5QlFVOHNSVUZCUlR0blFrRkRVQ3haUVVGWkxFVkJRVVVzVTBGQlV6dGhRVU40UWp0WlFVTkVMRmxCUVZrc1JVRkJSU3hOUVVGTk8xTkJRM0pDTEVOQlFVTXNRMEZCUXp0UlFVTklMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zV1VGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUTI1RExFdEJRVXNzUlVGQlJTeE5RVUV3UWl4RlFVRkZMRVZCUVVVN1dVRkRia01zVFVGQlRTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU03V1VGRGRFUXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhoUVVGaExFZEJRVWNzVFVGQlRTd3JRMEZCYzBJc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5zUlN4UFFVRlBMRTFCUVUwc1EwRkJRenRSUVVOb1FpeERRVUZETEVWQlEwUXNRMEZCUXl4RFFVRlJMRVZCUVVVc1JVRkJSU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUTJoRExFTkJRVU03U1VGRFNpeERRVUZETzBsQlJVUXNXVUZCV1N4RFFVRkRMRTlCUVRKQ08xRkJRM1JETEU5QlFVOHNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU53UXl4RFFVRkRPMGxCUlVRc1QwRkJUeXhEUVVGRExGVkJRVGhDTEVWQlFVVTdVVUZEZEVNc1QwRkJUeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUXk5Q0xFTkJRVU03U1VGRlJDeFhRVUZYTEVOQlFVTXNVMEZCYVVJN1VVRkRNMElzVDBGQlR5eHRRa0ZCVnl4RFFVRkRMRWxCUVVrc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUlVRc1lVRkJZU3hEUVVGRExGTkJRV2xDTzFGQlF6ZENMRTlCUVU4c2NVSkJRV0VzUTBGQlF5eEpRVUZKTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1NVRkRlRU1zUTBGQlF6dEpRVVZFTEZGQlFWRXNRMEZCUXl4VFFVRnBRanRSUVVONFFpeFBRVUZQTEdkQ1FVRlJMRU5CUVVNc1NVRkJTU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzBsQlEyNURMRU5CUVVNN1NVRkZSQ3hWUVVGVkxFTkJRVU1zVDBGQmRVSTdVVUZEYUVNc1QwRkJUeXh2UWtGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOdVF5eERRVUZETzBsQlJVUXNiVUpCUVcxQ0xFTkJRMnBDTEU5QlFXZERPMUZCUldoRExFOUJRVThzTmtKQlFXMUNMRU5CUVVNc1NVRkJTU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlF6VkRMRU5CUVVNN1NVRkZSQ3hoUVVGaExFTkJRMWdzVDBGQk5rSTdVVUZGTjBJc1QwRkJUeXgxUWtGQllTeERRVUZETEVsQlFVa3NSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOMFF5eERRVUZETzBsQlJVUXNVVUZCVVN4RFFVRkRMRk5CUVdsQ08xRkJRM2hDTEU5QlFVOHNaMEpCUVZFc1EwRkJReXhKUVVGSkxFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTTdTVUZEYmtNc1EwRkJRenRKUVVWRUxGZEJRVmNzUTBGRFZDeFBRVUZyUkR0UlFVVnNSQ3hQUVVGUExHMUNRVUZYTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRM0JETEVOQlFVTTdTVUZGUkN4TlFVRk5MRU5CUTBvc1QwRkJaMFE3VVVGRmFFUXNUMEZCVHl4alFVRk5MRU5CUVVNc1NVRkJTU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlF5OUNMRU5CUVVNN1EwRkRSanRCUVd4R1JDeHJRMEZyUmtNN096czdPenM3T3pzN096czdPenRCUTI1SVdTeDNRa0ZCWjBJc1IwRkJSeXgxUWtGQmRVSXNRMEZCUXp0QlFVVXpReXh0UWtGQlZ5eEhRVUZITEVkQlFVY3NRMEZCUXp0QlFVVnNRaXd3UWtGQmEwSXNSMEZCUnl4clFrRkJhMElzUTBGQlF6dEJRVVY0UXl4elFrRkJZeXhIUVVGSExFZEJRVWNzYlVKQlFWY3NVVUZCVVN4RFFVRkRPMEZCUlhoRExITkNRVUZqTEVkQlFVY3NSMEZCUnl4dFFrRkJWeXhSUVVGUkxFTkJRVU03UVVGRmVFTXNkVUpCUVdVc1IwRkJSeXhIUVVGSExHMUNRVUZYTEZOQlFWTXNRMEZCUXp0QlFVVXhReXgzUWtGQlowSXNSMEZCUnl4SFFVRkhMRzFDUVVGWExGVkJRVlVzUTBGQlF6dEJRVVUxUXl4clEwRkJNRUlzUjBGQlJ5eEhRVUZITEcxQ1FVRlhMRmxCUVZrc1EwRkJRenRCUVVWNFJDd3JRa0ZCZFVJc1IwRkJSeXhIUVVGSExHMUNRVUZYTEdsQ1FVRnBRaXhEUVVGRE96czdPenM3T3pzN096czdPenM3UVVORGRrVXNVMEZCWjBJc1lVRkJZU3hEUVVGRExFZEJRVms3U1VGRGVFTXNUMEZCVVN4SFFVRnRRaXhEUVVGRExGZEJRVmNzUzBGQlN5eFRRVUZUTEVOQlFVTTdRVUZEZUVRc1EwRkJRenRCUVVaRUxITkRRVVZETzBGQlJVUXNVMEZCWjBJc1ZVRkJWU3hEUVVGRExFZEJRVms3U1VGRGNrTXNUMEZCVVN4SFFVRm5RaXhEUVVGRExGRkJRVkVzUzBGQlN5eFRRVUZUTEVOQlFVTTdRVUZEYkVRc1EwRkJRenRCUVVaRUxHZERRVVZETzBGQlJVUXNVMEZCWjBJc1QwRkJUeXhEUVVGRExFZEJRVms3U1VGRGJFTXNUMEZCVHl4RFFVTktMRWRCUVdFc1EwRkJReXhSUVVGUkxFdEJRVXNzVTBGQlV6dFJRVU53UXl4SFFVRmhMRU5CUVVNc1VVRkJVU3hMUVVGTExGTkJRVk03VVVGRGNFTXNSMEZCWVN4RFFVRkRMRkZCUVZFc1MwRkJTeXhUUVVGVExFTkJRM1JETEVOQlFVTTdRVUZEU2l4RFFVRkRPMEZCVGtRc01FSkJUVU03T3pzN096czdPenM3T3pzN096czdRVU01UWtRc05raEJRV2xETzBGQlNXcERMRk5CUVdkQ0xGRkJRVkVzUTBGQlF5eFBRVUY1UWp0SlFVTm9SQ3hKUVVGSkxFOUJRVThzVDBGQlR5eExRVUZMTEZGQlFWRXNSVUZCUlR0UlFVTXZRaXhQUVVGUExFdEJRVXNzUTBGQlF6dExRVU5rTzBsQlJVUXNUMEZCVHl4UFFVRlBMRTlCUVU4c1EwRkJReXhOUVVGTkxFdEJRVXNzVjBGQlZ5eEpRVUZKTEU5QlFVOHNRMEZCUXl4SlFVRkpMRXRCUVVzc1VVRkJVU3hEUVVGRE8wRkJRelZGTEVOQlFVTTdRVUZPUkN3MFFrRk5RenRCUVVWRUxGTkJRV2RDTEZWQlFWVXNRMEZCUXl4UFFVRjVRanRKUVVOc1JDeEpRVUZKTEU5QlFVOHNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkJSVHRSUVVNdlFpeFBRVUZQTEVsQlFVa3NRMEZCUXp0TFFVTmlPMGxCUlVRc1QwRkJUeXhQUVVGUExFOUJRVThzUTBGQlF5eExRVUZMTEV0QlFVc3NWMEZCVnl4SlFVRkpMRTlCUVU4c1EwRkJReXhKUVVGSkxFdEJRVXNzUzBGQlN5eERRVUZETzBGQlEzaEZMRU5CUVVNN1FVRk9SQ3huUTBGTlF6dEJRVVZFTEZOQlFXZENMRkZCUVZFc1EwRkJReXhQUVVGNVFqdEpRVU5vUkN4SlFVRkpMRTlCUVU4c1QwRkJUeXhMUVVGTExGRkJRVkVzUlVGQlJUdFJRVU12UWl4UFFVRlBMRXRCUVVzc1EwRkJRenRMUVVOa08wbEJSVVFzVDBGQlR5eFBRVUZQTEU5QlFVOHNRMEZCUXl4TlFVRk5MRXRCUVVzc1YwRkJWeXhEUVVGRE8wRkJReTlETEVOQlFVTTdRVUZPUkN3MFFrRk5RenRCUVVWRUxHbEZRVUZwUlR0QlFVTnFSU3hUUVVGblFpeFRRVUZUTEVOQlFVTXNUMEZCZVVJN1NVRkRha1FzU1VGQlNTeFBRVUZQTEU5QlFVOHNTMEZCU3l4UlFVRlJMRVZCUVVVN1VVRkRMMElzVDBGQlR5eFBRVUZQTEVOQlFVTTdTMEZEYUVJN1NVRkZSQ3hKUVVGSkxGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlR0UlFVTnlRaXhQUVVGUExHZENRVUV3UWl4RFFVRkRPMHRCUTI1RE8xTkJRVTBzU1VGQlNTeFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVN1VVRkROVUlzVDBGQlR5eG5Ra0ZCTUVJc1EwRkJRenRMUVVOdVF6dFRRVUZOTzFGQlEwd3NUMEZCVHl4UFFVRlBMRU5CUVVNc1MwRkJaU3hEUVVGRE8wdEJRMmhETzBGQlEwZ3NRMEZCUXp0QlFWcEVMRGhDUVZsRE8wRkJSVVFzVTBGQlowSXNWVUZCVlN4RFFVRkRMRTlCUVhsQ08wbEJRMnhFTEUxQlFVMHNTVUZCU1N4SFFVRkhMRWxCUVVrc2JVSkJRVkVzUlVGQlJTeERRVUZETzBsQlJUVkNMRWxCUVVrc1QwRkJUeXhQUVVGUExFdEJRVXNzVVVGQlVTeEZRVUZGTzFGQlF5OUNMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUXpsQ0xFOUJRVThzU1VGQlNTeERRVUZETzB0QlEySTdTVUZGUkN4TFFVRkxMRTFCUVUwc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eERRVUZETEVsQlFVa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlJUdFJRVU5zUkN4TlFVRk5MREJDUVVFd1FpeEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1EwRkJRenRSUVVOMlJDeEpRVUZKTERCQ1FVRXdRaXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1JVRkJSVHRaUVVOc1JDeEpRVUZKTERCQ1FVRXdRaXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCWXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFVkJRVVU3WjBKQlEzSkZMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMkZCUXpOQ08xTkJRMFk3WVVGQlRUdFpRVU5NTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETzFOQlEzcENPMHRCUTBZN1NVRkRSQ3hQUVVGUExFbEJRVWtzUTBGQlF6dEJRVU5rTEVOQlFVTTdRVUZ1UWtRc1owTkJiVUpETzBGQlJVUXNVMEZCWjBJc0swSkJRU3RDTEVOQlF6ZERMRkZCUVhWQ096dEpRVVYyUWl4SlFVRkpMRTlCUVU4c1pVRkJVU3hEUVVGRExFbEJRVWtzTUVOQlFVVXNUVUZCVFN4TlFVRkxMRmRCUVZjc1NVRkJTU3hQUVVGUExHVkJRVkVzUTBGQlF5eEpRVUZKTERCRFFVRkZMRTlCUVU4c1RVRkJTeXhYUVVGWExFVkJRVVU3VVVGRGFrY3NUMEZCVHl4UlFVRlJMRU5CUVVNc1NVRkJTVHRMUVVOeVFqdEpRVVZFTEU5QlFVODdVVUZEVEN4SlFVRkpMRVZCUVVVc1VVRkJVU3hEUVVGRExFbEJRVWs3VVVGRGJrSXNUVUZCVFN4RlFVRkZMRkZCUVZFc1EwRkJReXhOUVVGTk8xRkJRM1pDTERKRFFVRXlRenRSUVVNelF5eFBRVUZQTEVWQlFVVXNTVUZCU1R0TFFVTmtPMEZCUTBnc1EwRkJRenRCUVdKRUxEQkZRV0ZET3pzN096czdPenM3T3pzN096czdRVU0zUlVRc1owZEJRWGxGTzBGQlJYcEZMREJGUVVFd1FqdEJRVU14UWl4dlJrRkJhMFU3UVVFclFteEZMRTFCUVUwc1kwRkJZeXhIUVVGdFFqdEpRVU55UXl4UFFVRlBMRVZCUVVVc1MwRkJTenRKUVVOa0xFbEJRVWtzUlVGQlJTeFBRVUZQTzBOQlEyUXNRMEZCUXp0QlFVVkdMRk5CUVdkQ0xHMUNRVUZ0UWl4RFFVRkRMRTlCUVhWQ08wbEJRM3BFTEUxQlFVMHNZVUZCWVN4SFFVRkhMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUlVGQlJTeEZRVUZGTEdOQlFXTXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVWcVJTeEpRVUZKTEVkQlFVY3NSMEZCUnl4SFFVRkhMR0ZCUVdFc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF6dEpRVVZ5UXl4SlFVRkpMR0ZCUVdFc1EwRkJReXhKUVVGSkxFVkJRVVU3VVVGRGRFSXNSMEZCUnl4SlFVRkpMRWxCUVVrc1lVRkJZU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzB0QlEycERPMGxCUlVRc1NVRkJTU3hoUVVGaExFTkJRVU1zVDBGQlR5eExRVUZMTEV0QlFVc3NTVUZCU1N4aFFVRmhMRU5CUVVNc1RVRkJUU3hGUVVGRk8xRkJRek5FTEVkQlFVY3NTVUZCU1N4SlFVRkpMR0ZCUVdFc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dExRVU51UXp0SlFVVkVMRWxCUVVrc1lVRkJZU3hEUVVGRExFbEJRVWtzUlVGQlJUdFJRVU4wUWl4SFFVRkhMRWxCUVVrc1NVRkJTU3hoUVVGaExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTTdTMEZEYWtNN1NVRkZSQ3hOUVVGTkxFZEJRVWNzUjBGQlJ5eEpRVUZKTEZOQlFVY3NRMEZCUXl4SFFVRkhMRFJDUVVGblFpeEpRVUZKTERSQ1FVRm5RaXhKUVVGSkxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZGZEVVc1NVRkJTU3hoUVVGaExFTkJRVU1zVTBGQlV5eExRVUZMTEZOQlFWTXNSVUZCUlR0UlFVTjZReXhIUVVGSExFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4WFFVRlhMRVZCUVVVc1lVRkJZU3hEUVVGRExGTkJRVk1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRPMHRCUXpGRk8wbEJSVVFzU1VGQlNTeGhRVUZoTEVOQlFVTXNUVUZCVFN4TFFVRkxMRk5CUVZNc1JVRkJSVHRSUVVOMFF5eEhRVUZITEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhSUVVGUkxFVkJRVVVzWVVGQllTeERRVUZETEUxQlFVMHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8wdEJRM0JGTzBsQlJVUXNTVUZCU1N4aFFVRmhMRU5CUVVNc1kwRkJZeXhMUVVGTExGTkJRVk1zUlVGQlJUdFJRVU01UXl4SFFVRkhMRU5CUVVNc1dVRkJXU3hEUVVGRExFMUJRVTBzUTBGRGNrSXNaMEpCUVdkQ0xFVkJRMmhDTEdGQlFXRXNRMEZCUXl4alFVRmpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRM2hETEVOQlFVTTdTMEZEU0R0SlFVVkVMRTlCUVU4c1IwRkJSeXhEUVVGRE8wRkJRMklzUTBGQlF6dEJRVzVEUkN4clJFRnRRME03UVVGRlRTeExRVUZMTEZWQlFWVXNWVUZCVlN4RFFVTTVRaXhOUVVGdFFpeEZRVU51UWl4VlFVRXdRaXhqUVVGak8wbEJSWGhETEUxQlFVMHNSVUZCUlN4UlFVRlJMRVZCUVVVc1IwRkJSeXh0UWtGQmJVSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOc1JDdzBSa0ZCTkVZN1NVRkROVVlzVFVGQlRTeGhRVUZoTEVkQlFVY3NVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVY0UXl4UFFVRlBMSFZEUVVFclFpeERRVUZETEUxQlFVMHNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeGhRVUZoTEVWQlFVVXNRMEZCUXl4RFFVRnJReXhEUVVGRE8wRkJRM2hJTEVOQlFVTTdRVUZVUkN4blEwRlRRenM3T3pzN096czdPenM3T3pzN08wRkRja1pFTEdkSFFVYzJRanRCUVVVM1Fpd3dSVUZCTUVJN1FVRkRNVUlzYjBaQlFXdEZPMEZCWld4RkxGTkJRV2RDTERSQ1FVRTBRaXhEUVVNeFF5eFBRVUZuUXp0SlFVVm9ReXhKUVVGSkxFZEJRVWNzUjBGQlJ5eEhRVUZITEU5QlFVOHNRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRKUVVWcVF5eEpRVUZKTEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVVN1VVRkRhRUlzUjBGQlJ5eEpRVUZKTEVsQlFVa3NUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRE8wdEJRek5DTzBsQlJVUXNTVUZCU1N4UFFVRlBMRU5CUVVNc1NVRkJTU3hMUVVGTExFdEJRVXNzU1VGQlNTeFBRVUZQTEVOQlFVTXNUVUZCVFN4RlFVRkZPMUZCUXpWRExFZEJRVWNzU1VGQlNTeEpRVUZKTEU5QlFVOHNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJRenRMUVVNM1FqdEpRVVZFTEVsQlFVa3NUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkJSVHRSUVVOb1FpeEhRVUZITEVsQlFVa3NTVUZCU1N4UFFVRlBMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU03UzBGRE0wSTdTVUZGUkN4TlFVRk5MRWRCUVVjc1IwRkJSeXhKUVVGSkxGTkJRVWNzUTBGRGFrSXNSMEZCUnl3MFFrRkJaMElzU1VGQlNTeHpRMEZCTUVJc1NVRkJTU3hIUVVGSExFVkJRVVVzUTBGRE0wUXNRMEZCUXp0SlFVVkdMRTlCUVU4c1IwRkJSeXhEUVVGRE8wRkJRMklzUTBGQlF6dEJRWFJDUkN4dlJVRnpRa003UVVGRlRTeExRVUZMTEZWQlFWVXNiVUpCUVcxQ0xFTkJRM1pETEUxQlFXMUNMRVZCUTI1Q0xFOUJRV2RETzBsQlJXaERMRTFCUVUwc1JVRkJSU3hSUVVGUkxFVkJRVVVzUjBGQlJ5dzBRa0ZCTkVJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU16UkN3MFJrRkJORVk3U1VGRE5VWXNUVUZCVFN4aFFVRmhMRWRCUVVjc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVVjRReXhQUVVGUExIVkRRVUVyUWl4RFFVRkRMRTFCUVUwc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZGTEVkQlFVY3NSVUZCUlN4aFFVRmhMRVZCUVVVc1EwRkJReXhEUVVGclF5eERRVUZETzBGQlEzaElMRU5CUVVNN1FVRlVSQ3hyUkVGVFF6czdPenM3T3pzN096czdPenM3TzBGRGRrUkVMSE5IUVVFMlFqdEJRVU0zUWl4M1NFRkJjME03UVVGRGRFTXNORWRCUVdkRE96czdPenM3T3pzN096czdPenM3UVVORWFFTXNaMGRCUVdkR08wRkJSV2hHTEc5R1FVRnJSVHRCUVVOc1JTd3dSVUZCTUVJN1FVRjFRakZDTEUxQlFVMHNhMEpCUVd0Q0xFZEJRU3RETzBsQlEzSkZMRTlCUVU4N1NVRkRVQ3hQUVVGUE8wbEJRMUFzVjBGQlZ6dEpRVU5ZTEU5QlFVODdTVUZEVUN4UlFVRlJPMGxCUTFJc1YwRkJWenREUVVOYUxFTkJRVU03UVVGTFJpeFRRVUZuUWl4NVFrRkJlVUlzUTBGQlF5eFBRVUUyUWp0SlFVTnlSU3hKUVVGSkxFZEJRVWNzUjBGQlJ5eEZRVUZGTEVOQlFVTTdTVUZGWWl4SlFVRkpMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVU3VVVGRGFFSXNSMEZCUnl4SlFVRkpMRWxCUVVrc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzB0QlF6TkNPMGxCUlVRc1NVRkJTU3hQUVVGUExFTkJRVU1zU1VGQlNTeExRVUZMTEV0QlFVc3NTVUZCU1N4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRk8xRkJRelZETEVkQlFVY3NTVUZCU1N4SlFVRkpMRTlCUVU4c1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dExRVU0zUWp0SlFVVkVMRWxCUVVrc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJUdFJRVU5vUWl4SFFVRkhMRWxCUVVrc1NVRkJTU3hQUVVGUExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTTdTMEZETTBJN1NVRkZSQ3hOUVVGTkxFZEJRVWNzUjBGQlJ5eEpRVUZKTEZOQlFVY3NRMEZCUXl4SFFVRkhMRFJDUVVGblFpeEpRVUZKTEcxRFFVRjFRaXhIUVVGSExFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZGTlVVc2EwSkJRV3RDTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVGRkxFVkJRVVU3TzFGQlEyNURMRWxCUVVrc1lVRkJUeXhEUVVGRExFdEJRVXNzUTBGQlF5d3dRMEZCUlN4TlFVRk5MRVZCUVVVN1dVRkRNVUlzUjBGQlJ5eERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUTBGQlF5eExRVUZMTEVOQlFWY3NRMEZCUXl4RFFVRkRPMU5CUXpGRU8wbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZGU0N4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFMUJRVTBzUlVGQlJUdFJRVU5tTEUxQlFVMHNTMEZCU3l4SFFVRkhMRTlCUVU4c1EwRkJReXhEUVVGRExFbEJRVWtzVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTjZReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTzFsQlExWXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXgxUWtGQmRVSXNRMEZCUXl4RFFVRkRPMU5CUXpGRE8xRkJSVVFzUjBGQlJ5eERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETzB0QlEzSkRPMGxCUlVRc1QwRkJUeXhIUVVGSExFTkJRVU03UVVGRFlpeERRVUZETzBGQmFrTkVMRGhFUVdsRFF6dEJRVVZOTEV0QlFVc3NWVUZCVlN4aFFVRmhMRU5CUTJwRExFMUJRVzFDTEVWQlEyNUNMRTlCUVRaQ08wbEJSVGRDTEUxQlFVMHNSVUZCUlN4UlFVRlJMRVZCUVVVc1IwRkJSeXg1UWtGQmVVSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVONFJDdzBSa0ZCTkVZN1NVRkROVVlzVFVGQlRTeGhRVUZoTEVkQlFVY3NVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVY0UXl4UFFVRlBMSFZEUVVFclFpeERRVUZETEUxQlFVMHNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeGhRVUZoTEVWQlFVVXNRMEZCUXl4RFFVRnJReXhEUVVGRE8wRkJRM2hJTEVOQlFVTTdRVUZVUkN4elEwRlRRenM3T3pzN096czdPenM3T3pzN08wRkRia1pFTEcxR1FVdDNRanRCUVVWNFFpd3JSa0ZCTUVVN1FVRkZia1VzUzBGQlN5eFZRVUZWTEhOQ1FVRnpRaXhEUVVNeFF5eE5RVUZ0UWp0SlFVVnVRaXhKUVVGSkxIRkNRVUZoTEVOQlFVTXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhGUVVGRk8xRkJRM0pETEU5QlFVOHNWVUZCVlN4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETzB0QlEyNUVPMGxCUlVRc1NVRkJTU3hyUWtGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExHVkJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRVZCUVVVN1VVRkRiRVVzVDBGQlR5eGhRVUZoTEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03UzBGRGJrUTdTVUZGUkN4TlFVRk5MRVZCUVVVc1VVRkJVU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFJRVUZSTEVWQlFVVXNSMEZCUnl4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRE8wbEJSVFZFTEUxQlFVMHNUMEZCVHl4SFFVRTBRanRSUVVOMlF5eEhRVUZITEVWQlFVVXNPRUpCUVd0Q08xRkJRM1pDTEU5QlFVOHNSVUZCUlN3MFFrRkJaMEk3VVVGRGVrSXNUVUZCVFN4RlFVRkZPMWxCUTA0c1UwRkJVeXhGUVVGRkxGRkJRVkU3V1VGRGJrSXNZVUZCWVN4RlFVRkZMRTlCUVU4N1UwRkRka0k3UzBGRFJpeERRVUZETzBsQlJVWXNTVUZCU1N4UlFVRlJMRWRCUVVjc1RVRkJUU3hOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUld4RUxFMUJRVTBzVDBGQlR5eEhRVUZITEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXp0UlFVTXpSQ3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJrTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdTVUZGYmtNc1NVRkJTU3hEUVVGRExFOUJRVThzUlVGQlJUdFJRVU5hTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc01FTkJRVEJETEVOQlFVTXNRMEZCUXp0TFFVTTNSRHRKUVVWRUxFMUJRVTBzVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc2EwTkJRV3RETEVOQlFVTXNRMEZCUXp0SlFVVnNSU3hKUVVGSkxFTkJRVU1zVDBGQlR5eEpRVUZKTEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRk8xRkJRMnhETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2RVTkJRWFZETEVOQlFVTXNRMEZCUXp0TFFVTXhSRHRKUVVWRUxFMUJRVTBzWTBGQll5eEhRVUZITEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVWc1F5eFBRVUZQTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJRenRKUVVONFFpeFBRVUZQTEVOQlFVTXNTVUZCU1N4SFFVRkhPMUZCUTJJc1VVRkJVVHRSUVVOU0xGRkJRVkU3VVVGRFVpeExRVUZMTEVWQlFVVXNZMEZCWXp0TFFVTjBRaXhEUVVGRE8wbEJSVVlzVDBGQlR5eERRVUZETEdOQlFXTXNSMEZCUnl4TFFVRkxMRU5CUVVNN1NVRkRMMElzVDBGQlR5eERRVUZETEU5QlFVOHNSMEZCUnp0UlFVTm9RaXhOUVVGTkxFVkJRVVVzYlVKQlFXMUNMR05CUVdNc1JVRkJSVHRMUVVNMVF5eERRVUZETzBsQlJVWXNVVUZCVVN4SFFVRkhMRTFCUVUwc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTTVReXhOUVVGTkxGRkJRVkVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJRenRKUVVNelF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZPMUZCUTJJc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5d3dRa0ZCTUVJc1EwRkJReXhEUVVGRE8wdEJRemRETzBsQlJVUXNUVUZCVFN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGRGRFSXNTVUZCU1R0UlFVTkdMRk5CUVZNc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdZVUZEYWtRc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTTdZVUZEY0VJc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTTdZVUZEY0VJc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTTdVVUZEZGtJc1NVRkJTU3hEUVVOUUxFTkJRVU03U1VGRlJpeE5RVUZOTEZkQlFWY3NSMEZCUnl4TFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRE8wbEJRM0pETEUxQlFVMHNRMEZCUXl4WFFVRjFReXhEUVVGRExGZEJRVmNzUjBGQlJ5eFhRVUZYTEVOQlFVTTdTVUZGTTBVc1QwRkJUeXhWUVVGVkxGZEJRVmNzUlVGQlJTeERRVUZETzBGQlEycERMRU5CUVVNN1FVRjJSVVFzZDBSQmRVVkRPenM3T3pzN096czdPenM3T3pzN1FVTXZSVVFzWjBkQlFYRkVPMEZCUlhKRUxHOUdRVUZyUlR0QlFVVXpSQ3hMUVVGTExGVkJRVlVzVjBGQlZ5eERRVU12UWl4TlFVRnRRaXhGUVVOdVFpeFRRVUZwUWp0SlFVVnFRaXhOUVVGTkxFZEJRVWNzUjBGQlJ5eEhRVUZITERCQ1FVRmpMRWxCUVVrc1UwRkJVeXhGUVVGRkxFTkJRVU03U1VGRE4wTXNUMEZCVHl4MVEwRkJLMElzUTBGQlF5eE5RVUZOTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzVFVGQlRTeEZRVUZGTEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVRoQ0xFTkJRVU03UVVGRGRrZ3NRMEZCUXp0QlFVNUVMR3REUVUxRE96czdPenM3T3pzN096czdPenM3UVVOV1JDeG5SMEZCY1VRN1FVRkZja1FzYjBaQlFXdEZPMEZCUlRORUxFdEJRVXNzVlVGQlZTeGhRVUZoTEVOQlEycERMRTFCUVcxQ0xFVkJRMjVDTEZOQlFXbENPMGxCUldwQ0xFMUJRVTBzUjBGQlJ5eEhRVUZITEVkQlFVY3NNRUpCUVdNc1NVRkJTU3hUUVVGVExGZEJRVmNzUTBGQlF6dEpRVU4wUkN4UFFVRlBMSFZEUVVFclFpeERRVUZETEUxQlFVMHNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeE5RVUZOTEVWQlFVVXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJhME1zUTBGQlF6dEJRVU42U0N4RFFVRkRPMEZCVGtRc2MwTkJUVU03T3pzN096czdPenM3T3pzN096dEJRMVpFTEdkSFFVRnhSRHRCUVVWeVJDeHZSa0ZCYTBVN1FVRkZNMFFzUzBGQlN5eFZRVUZWTEZGQlFWRXNRMEZETlVJc1RVRkJiVUlzUlVGRGJrSXNVMEZCYVVJN1NVRkZha0lzVFVGQlRTeEhRVUZITEVkQlFVY3NSMEZCUnl3d1FrRkJZeXhKUVVGSkxGTkJRVk1zUlVGQlJTeERRVUZETzBsQlF6ZERMRTlCUVU4c2RVTkJRU3RDTEVOQlFVTXNUVUZCVFN4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCWjBNN1FVRkRkRWNzUTBGQlF6dEJRVTVFTERSQ1FVMURPenM3T3pzN096czdPenM3T3pzN1FVTllSQ3h6UjBGQk9FSTdRVUZET1VJc01FZEJRV2RETzBGQlEyaERMR2RIUVVFeVFqdEJRVU16UWl4elIwRkJPRUk3UVVGRE9VSXNORVpCUVhsQ096czdPenM3T3pzN096czdPenM3UVVOSWVrSXNaMGRCUVhGRU8wRkJRM0pFTEc5R1FVRTRSVHRCUVZFNVJTeFRRVUZUTEc5Q1FVRnZRaXhEUVVGRExFTkJRWEZDTzBsQlEycEVMRTlCUVU4c1QwRkJUeXhEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEZGQlFWRXNTVUZCU1N4UFFVRlBMRU5CUVVNc1EwRkJReXhYUVVGWExFdEJRVXNzVVVGQlVTeERRVUZETzBGQlF6RkZMRU5CUVVNN1FVRkZUU3hMUVVGTExGVkJRVlVzVjBGQlZ5eERRVU12UWl4TlFVRnRRaXhGUVVOdVFpeFBRVUZyUkR0SlFVVnNSQ3hKUVVGSkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVN1VVRkRNVUlzVFVGQlRTeFJRVUZSTEVkQlFVY3NUMEZCVHl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRWEZDTEVWQlFVVXNSVUZCUlR0WlFVTnlSQ3hKUVVGSkxFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVU3WjBKQlF6VkNMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zTkVOQlFUUkRMRU5CUVVNc1EwRkJRenRoUVVNdlJEdFpRVVZFTEUxQlFVMHNSMEZCUnl4SFFVRkhMRWRCUVVjc01FSkJRV01zU1VGQlNTeERRVUZETEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1dVRkRMME1zVFVGQlRTeEpRVUZKTEVkQlFVY3NhMEpCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU16UWl4NVEwRkJlVU03V1VGRGVrTXNUMEZCVHl4SlFVRkpMRTlCUVU4c1EwRkJReXhMUVVGTExGZEJRVlVzVDBGQlR6dG5Ra0ZEY2tNc1QwRkJUeXhQUVVGUExFTkJRVU1zZFVOQlFTdENMRU5CUVVNc1RVRkJUU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzI5Q1FVTnNSU3hIUVVGSE8yOUNRVU5JTEUxQlFVMHNSVUZCUlN4TlFVRk5PMjlDUVVOa0xFbEJRVWtzUlVGQlJTeEpRVUZKTzI5Q1FVTldMSGxDUVVGNVFqdHBRa0ZETVVJc1EwRkJReXhEUVVFNFFpeERRVUZETzFsQlEyNURMRU5CUVVNc1EwRkJkVU1zUTBGQlF6dFJRVU0zUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVWSUxFOUJRVThzVFVGQlRTeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8wdEJRM0JETzBsQlJVUXNTVUZCU1N4RFFVRkRMRzlDUVVGdlFpeERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZPMUZCUTJ4RExFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNORU5CUVRSRExFTkJRVU1zUTBGQlF6dExRVU12UkR0SlFVVkVMRTFCUVUwc1IwRkJSeXhIUVVGSExFZEJRVWNzTUVKQlFXTXNTVUZCU1N4UFFVRlBMRU5CUVVNc1UwRkJVeXhGUVVGRkxFTkJRVU03U1VGRGNrUXNUVUZCVFN4SlFVRkpMRWRCUVVjc2EwSkJRVlVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTnFReXhQUVVGUExIVkRRVUVyUWl4RFFVRkRMRTFCUVUwc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dFJRVU14UkN4SFFVRkhPMUZCUTBnc1RVRkJUU3hGUVVGRkxFMUJRVTA3VVVGRFpDeEpRVUZKTEVWQlFVVXNTVUZCU1R0UlFVTldMSGxDUVVGNVFqdExRVU14UWl4RFFVRkRMRU5CUVRoQ08wRkJRMnhETEVOQlFVTTdRVUYwUTBRc2EwTkJjME5ET3pzN096czdPenM3T3pzN096czdPMEZEYmtSRUxHOUdRVWw1UWp0QlFVVjZRaXhuUjBGQmMwUTdRVUZGTDBNc1MwRkJTeXhWUVVGVkxFMUJRVTBzUTBGRE1VSXNUVUZCYlVJc1JVRkRia0lzVDBGQlowUTdTVUZGYUVRc1NVRkJTU3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZPMUZCUXpGQ0xFMUJRVTBzVVVGQlVTeEhRVUZITEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGdFFpeEZRVUZGTEVWQlFVVTdXVUZEYmtRc1RVRkJUU3hKUVVGSkxFZEJRVWNzYTBKQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVVelFpeDVRMEZCZVVNN1dVRkRla01zVDBGQlR5eEpRVUZKTEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxFVkJRVVU3WjBKQlEyNURMRTlCUVU4c1EwRkJReXgxUTBGQkswSXNRMEZEYmtNc1RVRkJUU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzI5Q1FVTnVRaXhIUVVGSExFVkJRVVVzTWtKQlFXVTdiMEpCUTNCQ0xFMUJRVTBzUlVGQlJTeE5RVUZOTzI5Q1FVTmtMRWxCUVVrc1JVRkJSU3hKUVVGSk8yOUNRVU5XTEdkQ1FVRm5RaXhGUVVGRkxFTkJRVU1zWVVGQllTeEZRVUZGTEVWQlFVVTdkMEpCUTJ4RExFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4aFFVRmhMRVZCUVVVc1EwRkJReXhEUVVGRE8zZENRVU12UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExHZENRVUZuUWl4RlFVRkZMRVZCUVVVc1IwRkJSeXhoUVVGaExFVkJRVVVzUTBGQlF5eERRVUZETzI5Q1FVTjBSQ3hEUVVGRE8ybENRVU5HTEVOQlFVTXNRMEZETkVJc1EwRkJReXhEUVVGRE8xbEJRM1JETEVOQlFVTXNRMEZCZVVNc1EwRkJRenRSUVVNM1F5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTklMRTlCUVU4c1RVRkJUU3hQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMHRCUTNCRE8wbEJSVVFzVFVGQlRTeEpRVUZKTEVkQlFVY3NhMEpCUVZVc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU5xUXl4clEwRkJhME03U1VGRGJFTXNUVUZCVFN4UFFVRlBMRWRCUVVjc1RVRkJUU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzFGQlEyNURMRWRCUVVjc1JVRkJSU3d5UWtGQlpUdFJRVU53UWl4TlFVRk5MRVZCUVVVc1RVRkJUVHRSUVVOa0xFbEJRVWtzUlVGQlJTeEpRVUZKTzFGQlExWXNaMEpCUVdkQ0xFVkJRVVVzUTBGQlF5eGhRVUZoTEVWQlFVVXNSVUZCUlR0WlFVTnNReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNZVUZCWVN4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVNdlFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMR2RDUVVGblFpeEZRVUZGTEVWQlFVVXNSMEZCUnl4aFFVRmhMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRM1JFTEVOQlFVTTdTMEZEUml4RFFVRkRMRU5CUVVNN1NVRkZTQ3hQUVVGUExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlEzQkNMSFZEUVVFclFpeERRVUZETEU5QlFVOHNRMEZCWjBNc1EwRkRlRVVzUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUY2UTBRc2QwSkJlVU5ET3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3p0QlEyeEVSRHRCUVVOQk96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeFZRVUZWTEdkQ1FVRm5RaXh6UTBGQmMwTXNhVUpCUVdsQ0xFVkJRVVU3UVVGRGJrWXNlVUpCUVhsQ0xIVkVRVUYxUkR0QlFVTm9SanRCUVVOQk96dEJRVVZQTzBGQlExQTdRVUZEUVN4dFFrRkJiVUlzYzBKQlFYTkNPMEZCUTNwRE8wRkJRMEU3TzBGQlJVODdRVUZEVUR0QlFVTkJMR2RFUVVGblJDeFBRVUZQTzBGQlEzWkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVlBPMEZCUTFBN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTdzBSRUZCTkVRc1kwRkJZenRCUVVNeFJUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWUE8wRkJRMUE3UVVGRFFUdEJRVU5CTERSRFFVRTBReXhSUVVGUk8wRkJRM0JFTzBGQlEwRTdPMEZCUlU4N1FVRkRVQ3h0UTBGQmJVTXNiME5CUVc5RE8wRkJRM1pGT3p0QlFVVlBPMEZCUTFBN1FVRkRRVHM3UVVGRlR6dEJRVU5RTERKQ1FVRXlRaXdyUkVGQkswUXNaMEpCUVdkQ0xFVkJRVVVzUlVGQlJUdEJRVU01Unp0QlFVTkJMRzFEUVVGdFF5eE5RVUZOTERaQ1FVRTJRaXhGUVVGRkxGbEJRVmtzVjBGQlZ5eEZRVUZGTzBGQlEycEhMR3REUVVGclF5eE5RVUZOTEdsRFFVRnBReXhGUVVGRkxGbEJRVmtzVjBGQlZ5eEZRVUZGTzBGQlEzQkhMQ3RDUVVFclFpeHhSa0ZCY1VZN1FVRkRjRWc3UVVGRFFTeExRVUZMTzBGQlEwdzdPMEZCUlU4N1FVRkRVQ3hoUVVGaExEWkNRVUUyUWl3d1FrRkJNRUlzWVVGQllTeEZRVUZGTEhGQ1FVRnhRanRCUVVONFJ5eG5Ra0ZCWjBJc2NVUkJRWEZFTEc5RlFVRnZSU3hoUVVGaExFVkJRVVU3UVVGRGVFb3NjMEpCUVhOQ0xITkNRVUZ6UWl4eFFrRkJjVUlzUjBGQlJ6dEJRVU53UlR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeDFRMEZCZFVNN1FVRkRka01zYTBOQlFXdERMRk5CUVZNN1FVRkRNME1zYTBOQlFXdERMRmRCUVZjc1ZVRkJWVHRCUVVOMlJDeDVRMEZCZVVNc1kwRkJZenRCUVVOMlJEdEJRVU5CTERaSFFVRTJSeXhQUVVGUExGVkJRVlU3UVVGRE9VZ3NaMFpCUVdkR0xHbENRVUZwUWl4UFFVRlBPMEZCUTNoSExIZEVRVUYzUkN4blFrRkJaMElzVVVGQlVTeFBRVUZQTzBGQlEzWkdMRGhEUVVFNFF5eG5Ra0ZCWjBJc1owSkJRV2RDTEU5QlFVODdRVUZEY2tZN1FVRkRRU3hwUTBGQmFVTTdRVUZEYWtNN1FVRkRRVHRCUVVOQkxGTkJRVk1zV1VGQldTeGhRVUZoTEU5QlFVOHNSVUZCUlN4VlFVRlZMRmRCUVZjN1FVRkRhRVVzYlVOQlFXMURMRk5CUVZNN1FVRkROVU03UVVGRFFUczdRVUZGVHp0QlFVTlFPMEZCUTBFN1FVRkRRVHM3UVVGRlR6dEJRVU5RTzBGQlEwRTdPMEZCUlU4N1FVRkRVRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiMEpCUVc5Q08wRkJRM0JDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWUE8wRkJRMUE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTEUxQlFVMHNaMEpCUVdkQ08wRkJRM3BETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTEhOQ1FVRnpRanRCUVVOMlF6dEJRVU5CTzBGQlEwRTdPMEZCUlU4N1FVRkRVQ3cwUWtGQk5FSXNjMEpCUVhOQ08wRkJRMnhFTzBGQlEwRTdRVUZEUVRzN1FVRkZUenRCUVVOUUxHbEVRVUZwUkN4UlFVRlJPMEZCUTNwRUxIZERRVUYzUXl4UlFVRlJPMEZCUTJoRUxIZEVRVUYzUkN4UlFVRlJPMEZCUTJoRk8wRkJRMEU3UVVGRFFUczdRVUZGVHp0QlFVTlFPMEZCUTBFN08wRkJSVTg3UVVGRFVEdEJRVU5CTzBGQlEwRXNhVUpCUVdsQ0xITkdRVUZ6Uml4aFFVRmhMRVZCUVVVN1FVRkRkRWdzYzBKQlFYTkNMR2REUVVGblF5eHhRMEZCY1VNc01FTkJRVEJETEVWQlFVVXNSVUZCUlN4SFFVRkhPMEZCUXpWSkxESkNRVUV5UWl4TlFVRk5MR1ZCUVdVc1JVRkJSU3haUVVGWkxHOUNRVUZ2UWl4RlFVRkZPMEZCUTNCR0xITkNRVUZ6UWl4dlIwRkJiMGM3UVVGRE1VZ3NOa0pCUVRaQ0xIVkNRVUYxUWp0QlFVTndSQ3cwUWtGQk5FSXNkMEpCUVhkQ08wRkJRM0JFTERKQ1FVRXlRaXg1UkVGQmVVUTdRVUZEY0VZN08wRkJSVTg3UVVGRFVEdEJRVU5CTEdsQ1FVRnBRaXcwUTBGQk5FTXNVMEZCVXl4RlFVRkZMSEZFUVVGeFJDeGhRVUZoTEVWQlFVVTdRVUZETlVrc2VVSkJRWGxDTERaQ1FVRTJRaXh2UWtGQmIwSXNaMFJCUVdkRUxHZENRVUZuUWl4RlFVRkZMRXRCUVVzN1FVRkRha283TzBGQlJVODdRVUZEVUR0QlFVTkJPMEZCUTBFc01rZEJRVEpITEhOR1FVRnpSaXhoUVVGaExFVkJRVVU3UVVGRGFFNHNjMEpCUVhOQ0xEaENRVUU0UWl4blJFRkJaMFFzZFVSQlFYVkVMRVZCUVVVc1JVRkJSU3hIUVVGSE8wRkJRMnhMTERSRFFVRTBReXh6UTBGQmMwTXNWVUZCVlN4dlFrRkJiMElzUlVGQlJTeEZRVUZGTEZWQlFWVTdRVUZET1VnN08wRkJSVTg3UVVGRFVDeG5RMEZCWjBNc2RVTkJRWFZETEdGQlFXRXNSVUZCUlN4RlFVRkZMRTlCUVU4c2EwSkJRV3RDTzBGQlEycElPMEZCUTBFN08wRkJSVTg3UVVGRFVEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVTg3UVVGRFVDdzBRMEZCTkVNN1FVRkROVU03TzBGQlJVODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdPenM3T3pzN096czdRVU42VGtFN1FVRkRRU3hEUVVGRE96dEJRVVZFTzBGQlEwRXNiVUpCUVcxQ0xFdEJRVEJDTzBGQlF6ZERPMEZCUTBFc2EwSkJRV3RDTEV0QlFYbENPMEZCUXpORE8wRkJRMEVzZVVKQlFYbENMSEZDUVVGTkxHZENRVUZuUWl4eFFrRkJUVHRCUVVOeVJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFVkJRVVU3TzBGQlJVWTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFpRVUZaTEU5QlFVODdRVUZEYmtJc1kwRkJZeXhOUVVGTk8wRkJRM0JDTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZsQlFWa3NUVUZCVFR0QlFVTnNRaXhaUVVGWkxGTkJRVk03UVVGRGNrSTdRVUZEUVN4alFVRmpMRTFCUVUwN1FVRkRjRUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1dVRkJXU3hQUVVGUE8wRkJRMjVDTEZsQlFWa3NVMEZCVXp0QlFVTnlRanRCUVVOQkxHTkJRV01zVFVGQlRUdEJRVU53UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1dVRkJXU3hQUVVGUE8wRkJRMjVDTEdOQlFXTXNUVUZCVFR0QlFVTndRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHhRMEZCY1VNN1FVRkRja003UVVGRFFTeExRVUZMTzBGQlEwd3NORUpCUVRSQ08wRkJRelZDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1NVRkJTVHRCUVVOS08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZsQlFWa3NUVUZCVFR0QlFVTnNRaXhqUVVGakxFOUJRVTg3UVVGRGNrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRmxCUVZrc1QwRkJUenRCUVVOdVFpeGpRVUZqTEU5QlFVODdRVUZEY2tJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzV1VGQldTeFBRVUZQTzBGQlEyNUNMR05CUVdNc1QwRkJUenRCUVVOeVFqdEJRVU5CTzBGQlEwRXNVMEZCVXp0QlFVTlVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMQ3RDUVVFclFpeHRRMEZCYlVNN1FVRkRiRVU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFpRVUZaTEU5QlFVODdRVUZEYmtJc1kwRkJZeXhQUVVGUE8wRkJRM0pDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRU3hoUVVGaExGZEJRVmM3UVVGRGVFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNkMEpCUVhkQ096dEJRVVY0UWl4NVEwRkJlVU1zY1VKQlFYRkNPenRCUVVVNVJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2EwTkJRV3RETEc5Q1FVRnZRanM3UVVGRmRFUTdRVUZEUVR0QlFVTkJPenRCUVVWQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4WlFVRlpMRTlCUVU4N1FVRkRia0lzWTBGQll5eFBRVUZQTzBGQlEzSkNPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFc1lVRkJZU3hwUWtGQmFVSTdRVUZET1VJN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMREJDUVVFd1FpeHBRa0ZCYVVJN1FVRkRNME03UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFTeGpRVUZqTEdsQ1FVRnBRanRCUVVNdlFqczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTERoQ1FVRTRRaXh2UWtGQmIwSTdRVUZEYkVRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1dVRkJXU3hQUVVGUE8wRkJRMjVDTzBGQlEwRXNZMEZCWXl4UFFVRlBPMEZCUTNKQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGbEJRVmtzVDBGQlR6dEJRVU51UWp0QlFVTkJMR05CUVdNc1QwRkJUenRCUVVOeVFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVWQlFVVXNTVUZGVlR0QlFVTmFPMEZCUTBFc1JVRkJSU3h0UTBGQmJVSTdRVUZEY2tJN1FVRkRRU3hIUVVGSE8wRkJRVUVzYTBkQlFVTTdRVUZEU2l4RlFVRkZMRTFCUVUwc1JVRlZUanM3UVVGRlJpeERRVUZET3pzN096czdPenM3T3pzN1FVTnFhRUpFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUldFN08wRkJSV0lzWlVGQlpTeHRRa0ZCVHl4RFFVRkRMSE5GUVVGVk8wRkJRMnBETEZkQlFWY3NiVUpCUVU4c1EwRkJReXd3UTBGQlVUczdRVUZGTTBJc1lVRkJZVHRCUVVOaUxHVkJRV1U3UVVGRFppeHhRa0ZCY1VJN1FVRkRja0lzWTBGQll6czdRVUZGWkN4WFFVRlhPenRCUVVWWU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRU3huUWtGQlowSXNTMEZCU3pzN1FVRkZja0k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVTkJRWEZETzBGQlEzSkRPMEZCUTBFN1FVRkRRU3d5UTBGQk1rTXNTMEZCU3p0QlFVTm9SQ3d3UTBGQk1FTXNTMEZCU3p0QlFVTXZRenRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPMEZCUTB3c2EwSkJRV3RDTEcxQ1FVRlBMRU5CUVVNc2QwUkJRV0U3TzBGQlJYWkRPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hUUVVGVE8wRkJRMVE3UVVGRFFUdEJRVU5CTEU5QlFVODdRVUZEVUR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRXNiME5CUVc5RE8wRkJRM0JETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeHRRa0ZCYlVJc05FSkJRVFJDTzBGQlF5OURPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzYlVKQlFXMUNMSGxDUVVGNVFqdEJRVU0xUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxESkRRVUV5UXl4UFFVRlBPMEZCUTJ4RU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNNRU5CUVRCRExFOUJRVTg3UVVGRGFrUTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHRkJRV0U3UVVGRFlqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVN3d1EwRkJNRU1zVDBGQlR6dEJRVU5xUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN08wRkJSMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU96dEJRVVZCTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJMR3RDUVVGclFpeHRRa0ZCYlVJN1FVRkRja003UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiMEpCUVc5Q0xHMUNRVUZ0UWp0QlFVTjJRenRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VKQlFYRkNMR2xDUVVGcFFqdEJRVU4wUXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRGhDUVVFNFFpeFJRVUZSTzBGQlEzUkRPMEZCUTBFN1FVRkRRVHRCUVVOQkxFdEJRVXM3UVVGRFREdEJRVU5CTzBGQlEwRXNTMEZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVN4VlFVRlZMRTFCUVUwN1FVRkRhRUk3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVkQlFVYzdRVUZEU0R0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN096czdPenM3T3pzN08wRkRNM1JDWVRzN1FVRkZZanRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPenM3T3pzN096czdPenRCUTJaQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4RE96czdPenM3T3pzN096dEJRMHhCTzBGQlEwRTdPMEZCUldFN08wRkJSV0lzZDBKQlFYZENMRzFDUVVGUExFTkJRVU1zTUVSQlFXTTdRVUZET1VNc01FSkJRVEJDTEcxQ1FVRlBMRU5CUVVNc05FVkJRWFZDTzBGQlEzcEVMSE5DUVVGelFpeHRRa0ZCVHl4RFFVRkRMRzlGUVVGdFFqdEJRVU5xUkN4dFFrRkJiVUlzYlVKQlFVOHNRMEZCUXl3NFJFRkJaMEk3TzBGQlJUTkRPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSMEZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHM3UVVGRlFTeDVRa0ZCZVVJN1FVRkRla0lzTWtKQlFUSkNPMEZCUXpOQ0xHOUNRVUZ2UWpzN1FVRkZjRUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hwUWtGQmFVSTdPMEZCUldwQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeDVRa0ZCZVVJN096dEJRVWQ2UWp0QlFVTkJPMEZCUTBFN1FVRkRRU3h2UWtGQmIwSTdPMEZCUlhCQ08wRkJRMEU3UVVGRFFUdEJRVU5CTERKQ1FVRXlRanM3UVVGRk0wSTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVSkJRWEZDT3p0QlFVVnlRanRCUVVOQk8wRkJRMEU3UVVGRFFTeHhRa0ZCY1VJN08wRkJSWEpDTzBGQlEwRTdRVUZEUVR0QlFVTkJMRzFDUVVGdFFqczdRVUZGYmtJN1FVRkRRVHRCUVVOQk8wRkJRMEVzYjBKQlFXOUNPenRCUVVWd1FqdEJRVU5CTzBGQlEwRTdRVUZEUVN4dlFrRkJiMEk3TzBGQlJYQkNPMEZCUTBFN1FVRkRRVHRCUVVOQkxITkNRVUZ6UWpzN1FVRkZkRUk3UVVGRFFUdEJRVU5CTzBGQlEwRXNjMEpCUVhOQ096dEJRVVYwUWp0QlFVTkJPMEZCUTBFN1FVRkRRU3gxUWtGQmRVSTdPMEZCUlhaQ08wRkJRMEU3UVVGRFFUdEJRVU5CTEhkQ1FVRjNRanM3UVVGRmVFSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4aFFVRmhPenRCUVVWaU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hoUVVGaE96dEJRVVZpTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHBRa0ZCYVVJN08wRkJSV3BDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNhVUpCUVdsQ096dEJRVVZxUWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNjVUpCUVhGQ096dEJRVVZ5UWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4clFrRkJhMEk3TzBGQlJXeENPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN3eVFrRkJNa0k3TzBGQlJUTkNPMEZCUTBFN1FVRkRRVHRCUVVOQkxIVkNRVUYxUWpzN1FVRkZka0k3UVVGRFFUdEJRVU5CTzBGQlEwRXNjVUpCUVhGQ096dEJRVVZ5UWp0QlFVTkJPMEZCUTBFN1FVRkRRU3h4UWtGQmNVSTdPMEZCUlhKQ08wRkJRMEU3UVVGRFFUdEJRVU5CTEhsQ1FVRjVRanM3UVVGRmVrSTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVTkJRVzFET3p0QlFVVnVRenRCUVVOQk8wRkJRMEU3UVVGRFFTeHpRa0ZCYzBJN08wRkJSWFJDTzBGQlEwRTdRVUZEUVR0QlFVTkJMSE5DUVVGelFqczdRVUZGZEVJN1FVRkRRVHRCUVVOQk8wRkJRMEVzZFVKQlFYVkNPenRCUVVWMlFqdEJRVU5CTzBGQlEwRTdRVUZEUVN4elFrRkJjMEk3TzBGQlJYUkNPMEZCUTBFN1FVRkRRVHRCUVVOQkxITkNRVUZ6UWpzN1FVRkZkRUk3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzZDBKQlFYZENPenRCUVVWNFFqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3gzUWtGQmQwSTdPMEZCUlhoQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWRCUVVjN1FVRkRTQ3hEUVVGRE96czdPenM3T3pzN096czdPMEZETTFWRU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3h0UWtGQmJVSXNhVUpCUVdsQ08wRkJRM0JETzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzWTBGQll6dEJRVU5rTzBGQlEwRTdRVUZEUVN4dFFrRkJiVUlzYzBKQlFYTkNPMEZCUTNwRE8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGTkJRVk03UVVGRFZEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSUxIVkNRVUYxUWl4VFFVRlRPMEZCUTJoRE8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3TzBGQlIwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDTzBGQlEycENMR0ZCUVdFc1QwRkJUeXh2UWtGQmIwSXNUMEZCVHp0QlFVTXZRenRCUVVOQk96dEJRVVZCTzBGQlEwRXNZVUZCWVN4UFFVRlBPMEZCUTNCQ08wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxGVkJRVlVzVDBGQlR6dEJRVU5xUWp0QlFVTkJMRTlCUVU4c1ZVRkJWU3hQUVVGUE8wRkJRM2hDTEZGQlFWRXNUMEZCVHp0QlFVTm1MRTlCUVU4N1FVRkRVQ3hSUVVGUkxFOUJRVTg3UVVGRFpqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3T3p0QlFVZEJPMEZCUTBFN08wRkJSVUVzU1VGQlNTeFBRVUZQTzBGQlExZ3NhVUpCUVdsQ0xFOUJRVTg3UVVGRGVFSXNjVU5CUVhGRE8wRkJRM0pETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3huUWtGQlowSTdRVUZEYUVJN1FVRkRRVHRCUVVOQk8wRkJRMEVzWjBKQlFXZENMRTlCUVU4N1FVRkRka0k3UVVGRFFUdEJRVU5CTEZGQlFWRXNUMEZCVHp0QlFVTm1PMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenRCUVVkQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNWMEZCVnl4UFFVRlBPMEZCUTJ4Q0xGZEJRVmNzVDBGQlR6dEJRVU5zUWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4bFFVRmxPenM3UVVGSFpqdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenRCUVVkQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUczdPMEZCUjBFN1FVRkRRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhRVUZIT3p0QlFVVklPMEZCUTBFN096dEJRVWRCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzTkVOQlFUUkRMRXRCUVVzN08wRkJSV3BFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1MwRkJTenRCUVVOTU8wRkJRMEU3UVVGRFFUczdRVUZGUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHM3UVVGRlFUczdRVUZGUVR0QlFVTkJPenM3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96czdRVUZIUVR0QlFVTkJPMEZCUTBFN096dEJRVWRCTzBGQlEwRTdRVUZEUVN4dFEwRkJiVU1zVDBGQlR6dEJRVU14UXp0QlFVTkJPMEZCUTBFN1FVRkRRU3hMUVVGTE8wRkJRMHc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFZEJRVWM3UVVGRFNEdEJRVU5CT3pzN1FVRkhRVHRCUVVOQk8wRkJRMEVzZVVSQlFYbEVPMEZCUTNwRU8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPMEZCUTBFc1IwRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFBRVUZQTzBGQlExQTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVjBGQlZ6dEJRVU5ZTEZOQlFWTTdRVUZEVkR0QlFVTkJPMEZCUTBFc1YwRkJWenRCUVVOWU8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRXRCUVVzN1FVRkRURHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHM3TzBGQlIwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUjBGQlJ6czdRVUZGU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN096dEJRVWRCTzBGQlEwRTdRVUZEUVN4clIwRkJNRU03TzBGQlJURkRPMEZCUTBFN1FVRkRRVHRCUVVOQkxHVkJRV1U3TzBGQlJXWTdRVUZEUVR0QlFVTkJPMEZCUTBFc2FVSkJRV2xDT3p0QlFVVnFRanRCUVVOQk8wRkJRMEU3UVVGRFFTeGpRVUZqT3p0QlFVVmtPMEZCUTBFN1FVRkRRVHRCUVVOQkxIbENRVUY1UWpzN1FVRkZla0k3UVVGRFFUdEJRVU5CTzBGQlEwRXNaMEpCUVdkQ096dEJRVVZvUWp0QlFVTkJPMEZCUTBFN1FVRkRRU3huUWtGQlowSTdPMEZCUldoQ08wRkJRMEU3UVVGRFFUdEJRVU5CTEdkQ1FVRm5RanM3UVVGRmFFSTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDT3p0QlFVVnVRanRCUVVOQk8wRkJRMEU3UVVGRFFTeG5Ra0ZCWjBJN1FVRkRhRUlzYzBKQlFYTkNPenRCUVVWMFFqdEJRVU5CTzBGQlEwRTdRVUZEUVN4blFrRkJaMEk3TzBGQlJXaENPMEZCUTBFN1FVRkRRVHRCUVVOQkxHTkJRV003UVVGRFpDeHZRa0ZCYjBJN08wRkJSWEJDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1pVRkJaVHRCUVVObUxESkNRVUV5UWpzN1FVRkZNMEk3UVVGRFFUdEJRVU5CTzBGQlEwRXNhMEpCUVd0Q096dEJRVVZzUWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNiVUpCUVcxQ096dEJRVVZ1UWl4clNFRkJaMFE3TzBGQlJXaEVPMEZCUTBFN1FVRkRRVHM3TzBGQlIwRTdRVUZEUVR0QlFVTkJPenM3UVVGSFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPenRCUVVkQk8wRkJRMEVzVjBGQlZ6dEJRVU5ZTEVWQlFVVXNUMEZCVHp0QlFVTlVPenM3UVVGSFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeFhRVUZYTEZOQlFWTTdRVUZEY0VJN1FVRkRRU3hYUVVGWExGTkJRVk03UVVGRGNFSTdRVUZEUVN4eFIwRkJjME03TzBGQlJYUkRMR1ZCUVdVN1FVRkRaanRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHM3UVVGRlFTeHBRa0ZCYVVJN1FVRkRha0k3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEV0QlFVczdRVUZEVER0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4TFFVRkxPenRCUVVWTU8wRkJRMEVzYlVKQlFXMUNMSE5DUVVGelFqdEJRVU42UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzVDBGQlR6dEJRVU5RTzBGQlEwRTdRVUZEUVN4TFFVRkxPenRCUVVWTU8wRkJRMEU3UVVGRFFTeExRVUZMTzBGQlEwdzdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hIUVVGSE8wRkJRMGc3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVRzN1FVRkZRU3gzUWtGQmQwSTdPMEZCUlhoQ08wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRVzFDTEhOQ1FVRnpRanRCUVVONlF6dEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3d5UWtGQk1rSXNRMEZCUXl4UFFVRlBMSEZEUVVGeFF6dEJRVU40UlN3eVFrRkJNa0lzUTBGQlF5eFBRVUZQTEhORVFVRnpSRHRCUVVONlJqczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVKQlFXMUNPenM3T3pzN096czdPenM3UVVNeGMwSk9PenRCUVVWaUxHTkJRV01zYlVKQlFVOHNRMEZCUXl4blJFRkJVenRCUVVNdlFpd3lRa0ZCTWtJc2JVSkJRVThzUTBGQlF5dzRSVUZCZDBJN1FVRkRNMFFzWjBKQlFXZENMRzFDUVVGUExFTkJRVU1zYTBWQlFYRkNPenRCUVVVM1F6dEJRVU5CTEdsQ1FVRnBRaXh0UWtGQlR5eERRVUZETEhkRVFVRmhPMEZCUTNSRE96dEJRVVZCT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3hYUVVGWExHMUNRVUZQTEVOQlFVTXNiMGhCUVRoRE8wRkJRMnBGTERKRFFVRXlRenRCUVVNelF6dEJRVU5CTzBGQlEwRXNZVUZCWVN4eFFrRkJUVHRCUVVOdVFpeHBRa0ZCYVVJc2NVSkJRVTA3UVVGRGRrSTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRVZCUVVVN1FVRkRSanM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEpRVUZKTzBGQlEwbzdRVUZEUVN4RlFVRkZPMEZCUTBZN1FVRkRRVHM3UVVGRlFTeHRRa0ZCYlVJc2JVSkJRVThzUTBGQlF5dzRSRUZCWjBJN08wRkJSVE5ETzBGQlEwRXNORUpCUVRSQ0xHTkJRV003UVVGRE1VTXNkVUpCUVhWQ0xIZERRVUYzUXp0QlFVTXZSRHRCUVVOQk96czdPenM3TzFWRGRrUkJPMVZCUTBFN08xVkJSVUU3VlVGRFFUdFZRVU5CTzFWQlEwRTdWVUZEUVR0VlFVTkJPMVZCUTBFN1ZVRkRRVHRWUVVOQk8xVkJRMEU3VlVGRFFUdFZRVU5CTzFWQlEwRTdPMVZCUlVFN1ZVRkRRVHM3VlVGRlFUdFZRVU5CT3p0VlFVVkJPMVZCUTBFN1ZVRkRRVHM3T3pzN1YwTjZRa0U3VjBGRFFUdFhRVU5CTzFkQlEwRTdWMEZEUVN4M1EwRkJkME1zZVVOQlFYbERPMWRCUTJwR08xZEJRMEU3VjBGRFFTeEZPenM3T3p0WFExQkJPMWRCUTBFN1YwRkRRVHRYUVVOQk8xZEJRMEVzUlVGQlJUdFhRVU5HTzFkQlEwRTdWMEZEUVN4RFFVRkRMRWs3T3pzN08xZERVRVFzZDBZN096czdPMWREUVVFN1YwRkRRVHRYUVVOQk8xZEJRMEVzYzBSQlFYTkVMR3RDUVVGclFqdFhRVU40UlR0WFFVTkJMQ3REUVVFclF5eGpRVUZqTzFkQlF6ZEVMRVU3T3pzN08xZERUa0U3VjBGRFFUdFhRVU5CTzFkQlEwRTdWMEZEUVN4Rk96czdPenM3T3pzN096czdPenM3UVVOS1FTeHpSVUZCZFVNN1FVRkJPVUlzYVVoQlFWY2lMQ0ptYVd4bElqb2lZblZ1Wkd4bExtcHpJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpS0daMWJtTjBhVzl1SUhkbFluQmhZMnRWYm1sMlpYSnpZV3hOYjJSMWJHVkVaV1pwYm1sMGFXOXVLSEp2YjNRc0lHWmhZM1J2Y25rcElIdGNibHgwTHk5RGIyMXRiMjVLVXpJZ1EyOXRiV1Z1ZEZ4dVhIUnBaaWgwZVhCbGIyWWdaWGh3YjNKMGN5QTlQVDBnSjI5aWFtVmpkQ2NnSmlZZ2RIbHdaVzltSUcxdlpIVnNaU0E5UFQwZ0oyOWlhbVZqZENjcFhHNWNkRngwYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtWVdOMGIzSjVLQ2s3WEc1Y2RDOHZRVTFFSUVOdmJXMWxiblJjYmx4MFpXeHpaU0JwWmloMGVYQmxiMllnWkdWbWFXNWxJRDA5UFNBblpuVnVZM1JwYjI0bklDWW1JR1JsWm1sdVpTNWhiV1FwWEc1Y2RGeDBaR1ZtYVc1bEtGdGRMQ0JtWVdOMGIzSjVLVHRjYmx4MEx5OURiMjF0YjI1S1V5QkRiMjF0Wlc1MFhHNWNkR1ZzYzJVZ2FXWW9kSGx3Wlc5bUlHVjRjRzl5ZEhNZ1BUMDlJQ2R2WW1wbFkzUW5LVnh1WEhSY2RHVjRjRzl5ZEhOYlhDSnBiV2QxY2x3aVhTQTlJR1poWTNSdmNua29LVHRjYmx4MEx5OVNiMjkwSUVOdmJXMWxiblJjYmx4MFpXeHpaVnh1WEhSY2RISnZiM1JiWENKcGJXZDFjbHdpWFNBOUlHWmhZM1J2Y25rb0tUdGNibjBwS0hSNWNHVnZaaUJ6Wld4bUlDRTlQU0FuZFc1a1pXWnBibVZrSnlBL0lITmxiR1lnT2lCMGFHbHpMQ0JtZFc1amRHbHZiaWdwSUh0Y2JuSmxkSFZ5YmlBaUxDSmNiaThxS2x4dUlDb2dRWEp5WVhralptbHNkR1Z5TGx4dUlDcGNiaUFxSUVCd1lYSmhiU0I3UVhKeVlYbDlJR0Z5Y2x4dUlDb2dRSEJoY21GdElIdEdkVzVqZEdsdmJuMGdabTVjYmlBcUlFQndZWEpoYlNCN1QySnFaV04wUFgwZ2MyVnNabHh1SUNvZ1FISmxkSFZ5YmlCN1FYSnlZWGw5WEc0Z0tpQkFkR2h5YjNjZ1ZIbHdaVVZ5Y205eVhHNGdLaTljYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlBb1lYSnlMQ0JtYml3Z2MyVnNaaWtnZTF4dUlDQnBaaUFvWVhKeUxtWnBiSFJsY2lrZ2NtVjBkWEp1SUdGeWNpNW1hV3gwWlhJb1ptNHNJSE5sYkdZcE8xeHVJQ0JwWmlBb2RtOXBaQ0F3SUQwOVBTQmhjbklnZkh3Z2JuVnNiQ0E5UFQwZ1lYSnlLU0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5TzF4dUlDQnBaaUFvSjJaMWJtTjBhVzl1SnlBaFBTQjBlWEJsYjJZZ1ptNHBJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0k3WEc0Z0lIWmhjaUJ5WlhRZ1BTQmJYVHRjYmlBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQmhjbkl1YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNCcFppQW9JV2hoYzA5M2JpNWpZV3hzS0dGeWNpd2dhU2twSUdOdmJuUnBiblZsTzF4dUlDQWdJSFpoY2lCMllXd2dQU0JoY25KYmFWMDdYRzRnSUNBZ2FXWWdLR1p1TG1OaGJHd29jMlZzWml3Z2RtRnNMQ0JwTENCaGNuSXBLU0J5WlhRdWNIVnphQ2gyWVd3cE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYUTdYRzU5TzF4dVhHNTJZWElnYUdGelQzZHVJRDBnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzVvWVhOUGQyNVFjbTl3WlhKMGVUdGNiaUlzSWk4dklFTjFjbkpsYm5Sc2VTQnBiaUJ6ZVc1aklIZHBkR2dnVG05a1pTNXFjeUJzYVdJdllYTnpaWEowTG1welhHNHZMeUJvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ym05a1pXcHpMMjV2WkdVdlkyOXRiV2wwTHpKaE5URmhaVFF5TkdFMU1UTmxZemxoTm1GaE16UTJObUpoWVRCall6RmtOVFZrWkRSbU0ySmNiaTh2SUU5eWFXZHBibUZzYkhrZ1puSnZiU0J1WVhKM2FHRnNMbXB6SUNob2RIUndPaTh2Ym1GeWQyaGhiR3B6TG05eVp5bGNiaTh2SUVOdmNIbHlhV2RvZENBb1l5a2dNakF3T1NCVWFHOXRZWE1nVW05aWFXNXpiMjRnUERJNE1HNXZjblJvTG1OdmJUNWNiaTh2WEc0dkx5QlFaWEp0YVhOemFXOXVJR2x6SUdobGNtVmllU0JuY21GdWRHVmtMQ0JtY21WbElHOW1JR05vWVhKblpTd2dkRzhnWVc1NUlIQmxjbk52YmlCdlluUmhhVzVwYm1jZ1lTQmpiM0I1WEc0dkx5QnZaaUIwYUdseklITnZablIzWVhKbElHRnVaQ0JoYzNOdlkybGhkR1ZrSUdSdlkzVnRaVzUwWVhScGIyNGdabWxzWlhNZ0tIUm9aU0FuVTI5bWRIZGhjbVVuS1N3Z2RHOWNiaTh2SUdSbFlXd2dhVzRnZEdobElGTnZablIzWVhKbElIZHBkR2h2ZFhRZ2NtVnpkSEpwWTNScGIyNHNJR2x1WTJ4MVpHbHVaeUIzYVhSb2IzVjBJR3hwYldsMFlYUnBiMjRnZEdobFhHNHZMeUJ5YVdkb2RITWdkRzhnZFhObExDQmpiM0I1TENCdGIyUnBabmtzSUcxbGNtZGxMQ0J3ZFdKc2FYTm9MQ0JrYVhOMGNtbGlkWFJsTENCemRXSnNhV05sYm5ObExDQmhibVF2YjNKY2JpOHZJSE5sYkd3Z1kyOXdhV1Z6SUc5bUlIUm9aU0JUYjJaMGQyRnlaU3dnWVc1a0lIUnZJSEJsY20xcGRDQndaWEp6YjI1eklIUnZJSGRvYjIwZ2RHaGxJRk52Wm5SM1lYSmxJR2x6WEc0dkx5Qm1kWEp1YVhOb1pXUWdkRzhnWkc4Z2MyOHNJSE4xWW1wbFkzUWdkRzhnZEdobElHWnZiR3h2ZDJsdVp5QmpiMjVrYVhScGIyNXpPbHh1THk5Y2JpOHZJRlJvWlNCaFltOTJaU0JqYjNCNWNtbG5hSFFnYm05MGFXTmxJR0Z1WkNCMGFHbHpJSEJsY20xcGMzTnBiMjRnYm05MGFXTmxJSE5vWVd4c0lHSmxJR2x1WTJ4MVpHVmtJR2x1WEc0dkx5QmhiR3dnWTI5d2FXVnpJRzl5SUhOMVluTjBZVzUwYVdGc0lIQnZjblJwYjI1eklHOW1JSFJvWlNCVGIyWjBkMkZ5WlM1Y2JpOHZYRzR2THlCVVNFVWdVMDlHVkZkQlVrVWdTVk1nVUZKUFZrbEVSVVFnSjBGVElFbFRKeXdnVjBsVVNFOVZWQ0JYUVZKU1FVNVVXU0JQUmlCQlRsa2dTMGxPUkN3Z1JWaFFVa1ZUVXlCUFVseHVMeThnU1UxUVRFbEZSQ3dnU1U1RFRGVkVTVTVISUVKVlZDQk9UMVFnVEVsTlNWUkZSQ0JVVHlCVVNFVWdWMEZTVWtGT1ZFbEZVeUJQUmlCTlJWSkRTRUZPVkVGQ1NVeEpWRmtzWEc0dkx5QkdTVlJPUlZOVElFWlBVaUJCSUZCQlVsUkpRMVZNUVZJZ1VGVlNVRTlUUlNCQlRrUWdUazlPU1U1R1VrbE9SMFZOUlU1VUxpQkpUaUJPVHlCRlZrVk9WQ0JUU0VGTVRDQlVTRVZjYmk4dklFRlZWRWhQVWxNZ1FrVWdURWxCUWt4RklFWlBVaUJCVGxrZ1EweEJTVTBzSUVSQlRVRkhSVk1nVDFJZ1QxUklSVklnVEVsQlFrbE1TVlJaTENCWFNFVlVTRVZTSUVsT0lFRk9YRzR2THlCQlExUkpUMDRnVDBZZ1EwOU9WRkpCUTFRc0lGUlBVbFFnVDFJZ1QxUklSVkpYU1ZORkxDQkJVa2xUU1U1SElFWlNUMDBzSUU5VlZDQlBSaUJQVWlCSlRpQkRUMDVPUlVOVVNVOU9YRzR2THlCWFNWUklJRlJJUlNCVFQwWlVWMEZTUlNCUFVpQlVTRVVnVlZORklFOVNJRTlVU0VWU0lFUkZRVXhKVGtkVElFbE9JRlJJUlNCVFQwWlVWMEZTUlM1Y2JpZDFjMlVnYzNSeWFXTjBKenRjYmx4dVpuVnVZM1JwYjI0Z1gzUjVjR1Z2Wmlodlltb3BJSHNnYVdZZ0tIUjVjR1Z2WmlCVGVXMWliMndnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCMGVYQmxiMllnVTNsdFltOXNMbWwwWlhKaGRHOXlJRDA5UFNCY0luTjViV0p2YkZ3aUtTQjdJRjkwZVhCbGIyWWdQU0JtZFc1amRHbHZiaUJmZEhsd1pXOW1LRzlpYWlrZ2V5QnlaWFIxY200Z2RIbHdaVzltSUc5aWFqc2dmVHNnZlNCbGJITmxJSHNnWDNSNWNHVnZaaUE5SUdaMWJtTjBhVzl1SUY5MGVYQmxiMllvYjJKcUtTQjdJSEpsZEhWeWJpQnZZbW9nSmlZZ2RIbHdaVzltSUZONWJXSnZiQ0E5UFQwZ1hDSm1kVzVqZEdsdmJsd2lJQ1ltSUc5aWFpNWpiMjV6ZEhKMVkzUnZjaUE5UFQwZ1UzbHRZbTlzSUNZbUlHOWlhaUFoUFQwZ1UzbHRZbTlzTG5CeWIzUnZkSGx3WlNBL0lGd2ljM2x0WW05c1hDSWdPaUIwZVhCbGIyWWdiMkpxT3lCOU95QjlJSEpsZEhWeWJpQmZkSGx3Wlc5bUtHOWlhaWs3SUgxY2JseHVablZ1WTNScGIyNGdYMk5zWVhOelEyRnNiRU5vWldOcktHbHVjM1JoYm1ObExDQkRiMjV6ZEhKMVkzUnZjaWtnZXlCcFppQW9JU2hwYm5OMFlXNWpaU0JwYm5OMFlXNWpaVzltSUVOdmJuTjBjblZqZEc5eUtTa2dleUIwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0Z3aVEyRnVibTkwSUdOaGJHd2dZU0JqYkdGemN5QmhjeUJoSUdaMWJtTjBhVzl1WENJcE95QjlJSDFjYmx4dWRtRnlJRjl5WlhGMWFYSmxJRDBnY21WeGRXbHlaU2duTGk5cGJuUmxjbTVoYkM5bGNuSnZjbk1uS1N4Y2JpQWdJQ0JmY21WeGRXbHlaU1JqYjJSbGN5QTlJRjl5WlhGMWFYSmxMbU52WkdWekxGeHVJQ0FnSUVWU1VsOUJUVUpKUjFWUFZWTmZRVkpIVlUxRlRsUWdQU0JmY21WeGRXbHlaU1JqYjJSbGN5NUZVbEpmUVUxQ1NVZFZUMVZUWDBGU1IxVk5SVTVVTEZ4dUlDQWdJRVZTVWw5SlRsWkJURWxFWDBGU1IxOVVXVkJGSUQwZ1gzSmxjWFZwY21Va1kyOWtaWE11UlZKU1gwbE9Wa0ZNU1VSZlFWSkhYMVJaVUVVc1hHNGdJQ0FnUlZKU1gwbE9Wa0ZNU1VSZlFWSkhYMVpCVEZWRklEMGdYM0psY1hWcGNtVWtZMjlrWlhNdVJWSlNYMGxPVmtGTVNVUmZRVkpIWDFaQlRGVkZMRnh1SUNBZ0lFVlNVbDlKVGxaQlRFbEVYMUpGVkZWU1RsOVdRVXhWUlNBOUlGOXlaWEYxYVhKbEpHTnZaR1Z6TGtWU1VsOUpUbFpCVEVsRVgxSkZWRlZTVGw5V1FVeFZSU3hjYmlBZ0lDQkZVbEpmVFVsVFUwbE9SMTlCVWtkVElEMGdYM0psY1hWcGNtVWtZMjlrWlhNdVJWSlNYMDFKVTFOSlRrZGZRVkpIVXp0Y2JseHVkbUZ5SUVGemMyVnlkR2x2YmtWeWNtOXlJRDBnY21WeGRXbHlaU2duTGk5cGJuUmxjbTVoYkM5aGMzTmxjblF2WVhOelpYSjBhVzl1WDJWeWNtOXlKeWs3WEc1Y2JuWmhjaUJmY21WeGRXbHlaVElnUFNCeVpYRjFhWEpsS0NkMWRHbHNMeWNwTEZ4dUlDQWdJR2x1YzNCbFkzUWdQU0JmY21WeGRXbHlaVEl1YVc1emNHVmpkRHRjYmx4dWRtRnlJRjl5WlhGMWFYSmxKSFI1Y0dWeklEMGdjbVZ4ZFdseVpTZ25kWFJwYkM4bktTNTBlWEJsY3l4Y2JpQWdJQ0JwYzFCeWIyMXBjMlVnUFNCZmNtVnhkV2x5WlNSMGVYQmxjeTVwYzFCeWIyMXBjMlVzWEc0Z0lDQWdhWE5TWldkRmVIQWdQU0JmY21WeGRXbHlaU1IwZVhCbGN5NXBjMUpsWjBWNGNEdGNibHh1ZG1GeUlHOWlhbVZqZEVGemMybG5iaUE5SUU5aWFtVmpkQzVoYzNOcFoyNGdQeUJQWW1wbFkzUXVZWE56YVdkdUlEb2djbVZ4ZFdseVpTZ25aWE0yTFc5aWFtVmpkQzFoYzNOcFoyNG5LUzVoYzNOcFoyNDdYRzUyWVhJZ2IySnFaV04wU1hNZ1BTQlBZbXBsWTNRdWFYTWdQeUJQWW1wbFkzUXVhWE1nT2lCeVpYRjFhWEpsS0NkdlltcGxZM1F0YVhNbktUdGNiblpoY2lCbGNuSnZja05oWTJobElEMGdibVYzSUUxaGNDZ3BPMXh1ZG1GeUlHbHpSR1ZsY0VWeGRXRnNPMXh1ZG1GeUlHbHpSR1ZsY0ZOMGNtbGpkRVZ4ZFdGc08xeHVkbUZ5SUhCaGNuTmxSWGh3Y21WemMybHZia0YwTzF4dWRtRnlJR1pwYm1ST2IyUmxRWEp2ZFc1a08xeHVkbUZ5SUdSbFkyOWtaWEk3WEc1Y2JtWjFibU4wYVc5dUlHeGhlbmxNYjJGa1EyOXRjR0Z5YVhOdmJpZ3BJSHRjYmlBZ2RtRnlJR052YlhCaGNtbHpiMjRnUFNCeVpYRjFhWEpsS0NjdUwybHVkR1Z5Ym1Gc0wzVjBhV3d2WTI5dGNHRnlhWE52Ym5NbktUdGNibHh1SUNCcGMwUmxaWEJGY1hWaGJDQTlJR052YlhCaGNtbHpiMjR1YVhORVpXVndSWEYxWVd3N1hHNGdJR2x6UkdWbGNGTjBjbWxqZEVWeGRXRnNJRDBnWTI5dGNHRnlhWE52Ymk1cGMwUmxaWEJUZEhKcFkzUkZjWFZoYkR0Y2JuMGdMeThnUlhOallYQmxJR052Ym5SeWIyd2dZMmhoY21GamRHVnljeUJpZFhRZ2JtOTBJRnhjYmlCaGJtUWdYRngwSUhSdklHdGxaWEFnZEdobElHeHBibVVnWW5KbFlXdHpJR0Z1WkZ4dUx5OGdhVzVrWlc1MFlYUnBiMjRnYVc1MFlXTjBMbHh1THk4Z1pYTnNhVzUwTFdScGMyRmliR1V0Ym1WNGRDMXNhVzVsSUc1dkxXTnZiblJ5YjJ3dGNtVm5aWGhjYmx4dVhHNTJZWElnWlhOallYQmxVMlZ4ZFdWdVkyVnpVbVZuUlhod0lEMGdMMXRjWEhnd01DMWNYSGd3T0Z4Y2VEQmlYRng0TUdOY1hIZ3daUzFjWEhneFpsMHZaenRjYm5aaGNpQnRaWFJoSUQwZ1cxd2lYRnhjWEhVd01EQXdYQ0lzSUZ3aVhGeGNYSFV3TURBeFhDSXNJRndpWEZ4Y1hIVXdNREF5WENJc0lGd2lYRnhjWEhVd01EQXpYQ0lzSUZ3aVhGeGNYSFV3TURBMFhDSXNJRndpWEZ4Y1hIVXdNREExWENJc0lGd2lYRnhjWEhVd01EQTJYQ0lzSUZ3aVhGeGNYSFV3TURBM1hDSXNJQ2RjWEZ4Y1lpY3NJQ2NuTENBbkp5d2dYQ0pjWEZ4Y2RUQXdNR0pjSWl3Z0oxeGNYRnhtSnl3Z0p5Y3NJRndpWEZ4Y1hIVXdNREJsWENJc0lGd2lYRnhjWEhVd01EQm1YQ0lzSUZ3aVhGeGNYSFV3TURFd1hDSXNJRndpWEZ4Y1hIVXdNREV4WENJc0lGd2lYRnhjWEhVd01ERXlYQ0lzSUZ3aVhGeGNYSFV3TURFelhDSXNJRndpWEZ4Y1hIVXdNREUwWENJc0lGd2lYRnhjWEhVd01ERTFYQ0lzSUZ3aVhGeGNYSFV3TURFMlhDSXNJRndpWEZ4Y1hIVXdNREUzWENJc0lGd2lYRnhjWEhVd01ERTRYQ0lzSUZ3aVhGeGNYSFV3TURFNVhDSXNJRndpWEZ4Y1hIVXdNREZoWENJc0lGd2lYRnhjWEhVd01ERmlYQ0lzSUZ3aVhGeGNYSFV3TURGalhDSXNJRndpWEZ4Y1hIVXdNREZrWENJc0lGd2lYRnhjWEhVd01ERmxYQ0lzSUZ3aVhGeGNYSFV3TURGbVhDSmRPMXh1WEc1MllYSWdaWE5qWVhCbFJtNGdQU0JtZFc1amRHbHZiaUJsYzJOaGNHVkdiaWh6ZEhJcElIdGNiaUFnY21WMGRYSnVJRzFsZEdGYmMzUnlMbU5vWVhKRGIyUmxRWFFvTUNsZE8xeHVmVHRjYmx4dWRtRnlJSGRoY201bFpDQTlJR1poYkhObE95QXZMeUJVYUdVZ1lYTnpaWEowSUcxdlpIVnNaU0J3Y205MmFXUmxjeUJtZFc1amRHbHZibk1nZEdoaGRDQjBhSEp2ZDF4dUx5OGdRWE56WlhKMGFXOXVSWEp5YjNJbmN5QjNhR1Z1SUhCaGNuUnBZM1ZzWVhJZ1kyOXVaR2wwYVc5dWN5QmhjbVVnYm05MElHMWxkQzRnVkdobFhHNHZMeUJoYzNObGNuUWdiVzlrZFd4bElHMTFjM1FnWTI5dVptOXliU0IwYnlCMGFHVWdabTlzYkc5M2FXNW5JR2x1ZEdWeVptRmpaUzVjYmx4dWRtRnlJR0Z6YzJWeWRDQTlJRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdiMnM3WEc1MllYSWdUazlmUlZoRFJWQlVTVTlPWDFORlRsUkpUa1ZNSUQwZ2UzMDdJQzh2SUVGc2JDQnZaaUIwYUdVZ1ptOXNiRzkzYVc1bklHWjFibU4wYVc5dWN5QnRkWE4wSUhSb2NtOTNJR0Z1SUVGemMyVnlkR2x2YmtWeWNtOXlYRzR2THlCM2FHVnVJR0VnWTI5eWNtVnpjRzl1WkdsdVp5QmpiMjVrYVhScGIyNGdhWE1nYm05MElHMWxkQ3dnZDJsMGFDQmhJRzFsYzNOaFoyVWdkR2hoZEZ4dUx5OGdiV0Y1SUdKbElIVnVaR1ZtYVc1bFpDQnBaaUJ1YjNRZ2NISnZkbWxrWldRdUlFRnNiQ0JoYzNObGNuUnBiMjRnYldWMGFHOWtjeUJ3Y205MmFXUmxYRzR2THlCaWIzUm9JSFJvWlNCaFkzUjFZV3dnWVc1a0lHVjRjR1ZqZEdWa0lIWmhiSFZsY3lCMGJ5QjBhR1VnWVhOelpYSjBhVzl1SUdWeWNtOXlJR1p2Y2x4dUx5OGdaR2x6Y0d4aGVTQndkWEp3YjNObGN5NWNibHh1Wm5WdVkzUnBiMjRnYVc1dVpYSkdZV2xzS0c5aWFpa2dlMXh1SUNCcFppQW9iMkpxTG0xbGMzTmhaMlVnYVc1emRHRnVZMlZ2WmlCRmNuSnZjaWtnZEdoeWIzY2diMkpxTG0xbGMzTmhaMlU3WEc0Z0lIUm9jbTkzSUc1bGR5QkJjM05sY25ScGIyNUZjbkp2Y2lodlltb3BPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm1ZV2xzS0dGamRIVmhiQ3dnWlhod1pXTjBaV1FzSUcxbGMzTmhaMlVzSUc5d1pYSmhkRzl5TENCemRHRmphMU4wWVhKMFJtNHBJSHRjYmlBZ2RtRnlJR0Z5WjNOTVpXNGdQU0JoY21kMWJXVnVkSE11YkdWdVozUm9PMXh1SUNCMllYSWdhVzUwWlhKdVlXeE5aWE56WVdkbE8xeHVYRzRnSUdsbUlDaGhjbWR6VEdWdUlEMDlQU0F3S1NCN1hHNGdJQ0FnYVc1MFpYSnVZV3hOWlhOellXZGxJRDBnSjBaaGFXeGxaQ2M3WEc0Z0lIMGdaV3h6WlNCcFppQW9ZWEpuYzB4bGJpQTlQVDBnTVNrZ2UxeHVJQ0FnSUcxbGMzTmhaMlVnUFNCaFkzUjFZV3c3WEc0Z0lDQWdZV04wZFdGc0lEMGdkVzVrWldacGJtVmtPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR2xtSUNoM1lYSnVaV1FnUFQwOUlHWmhiSE5sS1NCN1hHNGdJQ0FnSUNCM1lYSnVaV1FnUFNCMGNuVmxPMXh1SUNBZ0lDQWdkbUZ5SUhkaGNtNGdQU0J3Y205alpYTnpMbVZ0YVhSWFlYSnVhVzVuSUQ4Z2NISnZZMlZ6Y3k1bGJXbDBWMkZ5Ym1sdVp5QTZJR052Ym5OdmJHVXVkMkZ5Ymk1aWFXNWtLR052Ym5OdmJHVXBPMXh1SUNBZ0lDQWdkMkZ5YmlnbllYTnpaWEowTG1aaGFXd29LU0IzYVhSb0lHMXZjbVVnZEdoaGJpQnZibVVnWVhKbmRXMWxiblFnYVhNZ1pHVndjbVZqWVhSbFpDNGdKeUFySUNkUWJHVmhjMlVnZFhObElHRnpjMlZ5ZEM1emRISnBZM1JGY1hWaGJDZ3BJR2x1YzNSbFlXUWdiM0lnYjI1c2VTQndZWE56SUdFZ2JXVnpjMkZuWlM0bkxDQW5SR1Z3Y21WallYUnBiMjVYWVhKdWFXNW5KeXdnSjBSRlVEQXdPVFFuS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JwWmlBb1lYSm5jMHhsYmlBOVBUMGdNaWtnYjNCbGNtRjBiM0lnUFNBbklUMG5PMXh1SUNCOVhHNWNiaUFnYVdZZ0tHMWxjM05oWjJVZ2FXNXpkR0Z1WTJWdlppQkZjbkp2Y2lrZ2RHaHliM2NnYldWemMyRm5aVHRjYmlBZ2RtRnlJR1Z5Y2tGeVozTWdQU0I3WEc0Z0lDQWdZV04wZFdGc09pQmhZM1IxWVd3c1hHNGdJQ0FnWlhod1pXTjBaV1E2SUdWNGNHVmpkR1ZrTEZ4dUlDQWdJRzl3WlhKaGRHOXlPaUJ2Y0dWeVlYUnZjaUE5UFQwZ2RXNWtaV1pwYm1Wa0lEOGdKMlpoYVd3bklEb2diM0JsY21GMGIzSXNYRzRnSUNBZ2MzUmhZMnRUZEdGeWRFWnVPaUJ6ZEdGamExTjBZWEowUm00Z2ZId2dabUZwYkZ4dUlDQjlPMXh1WEc0Z0lHbG1JQ2h0WlhOellXZGxJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNCbGNuSkJjbWR6TG0xbGMzTmhaMlVnUFNCdFpYTnpZV2RsTzF4dUlDQjlYRzVjYmlBZ2RtRnlJR1Z5Y2lBOUlHNWxkeUJCYzNObGNuUnBiMjVGY25KdmNpaGxjbkpCY21kektUdGNibHh1SUNCcFppQW9hVzUwWlhKdVlXeE5aWE56WVdkbEtTQjdYRzRnSUNBZ1pYSnlMbTFsYzNOaFoyVWdQU0JwYm5SbGNtNWhiRTFsYzNOaFoyVTdYRzRnSUNBZ1pYSnlMbWRsYm1WeVlYUmxaRTFsYzNOaFoyVWdQU0IwY25WbE8xeHVJQ0I5WEc1Y2JpQWdkR2h5YjNjZ1pYSnlPMXh1ZlZ4dVhHNWhjM05sY25RdVptRnBiQ0E5SUdaaGFXdzdJQzh2SUZSb1pTQkJjM05sY25ScGIyNUZjbkp2Y2lCcGN5QmtaV1pwYm1Wa0lHbHVJR2x1ZEdWeWJtRnNMMlZ5Y205eUxseHVYRzVoYzNObGNuUXVRWE56WlhKMGFXOXVSWEp5YjNJZ1BTQkJjM05sY25ScGIyNUZjbkp2Y2p0Y2JseHVablZ1WTNScGIyNGdhVzV1WlhKUGF5aG1iaXdnWVhKblRHVnVMQ0IyWVd4MVpTd2diV1Z6YzJGblpTa2dlMXh1SUNCcFppQW9JWFpoYkhWbEtTQjdYRzRnSUNBZ2RtRnlJR2RsYm1WeVlYUmxaRTFsYzNOaFoyVWdQU0JtWVd4elpUdGNibHh1SUNBZ0lHbG1JQ2hoY21kTVpXNGdQVDA5SURBcElIdGNiaUFnSUNBZ0lHZGxibVZ5WVhSbFpFMWxjM05oWjJVZ1BTQjBjblZsTzF4dUlDQWdJQ0FnYldWemMyRm5aU0E5SUNkT2J5QjJZV3gxWlNCaGNtZDFiV1Z1ZENCd1lYTnpaV1FnZEc4Z1lHRnpjMlZ5ZEM1dmF5Z3BZQ2M3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h0WlhOellXZGxJR2x1YzNSaGJtTmxiMllnUlhKeWIzSXBJSHRjYmlBZ0lDQWdJSFJvY205M0lHMWxjM05oWjJVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnZG1GeUlHVnljaUE5SUc1bGR5QkJjM05sY25ScGIyNUZjbkp2Y2loN1hHNGdJQ0FnSUNCaFkzUjFZV3c2SUhaaGJIVmxMRnh1SUNBZ0lDQWdaWGh3WldOMFpXUTZJSFJ5ZFdVc1hHNGdJQ0FnSUNCdFpYTnpZV2RsT2lCdFpYTnpZV2RsTEZ4dUlDQWdJQ0FnYjNCbGNtRjBiM0k2SUNjOVBTY3NYRzRnSUNBZ0lDQnpkR0ZqYTFOMFlYSjBSbTQ2SUdadVhHNGdJQ0FnZlNrN1hHNGdJQ0FnWlhKeUxtZGxibVZ5WVhSbFpFMWxjM05oWjJVZ1BTQm5aVzVsY21GMFpXUk5aWE56WVdkbE8xeHVJQ0FnSUhSb2NtOTNJR1Z5Y2p0Y2JpQWdmVnh1ZlNBdkx5QlFkWEpsSUdGemMyVnlkR2x2YmlCMFpYTjBjeUIzYUdWMGFHVnlJR0VnZG1Gc2RXVWdhWE1nZEhKMWRHaDVMQ0JoY3lCa1pYUmxjbTFwYm1Wa1hHNHZMeUJpZVNBaElYWmhiSFZsTGx4dVhHNWNibVoxYm1OMGFXOXVJRzlyS0NrZ2UxeHVJQ0JtYjNJZ0tIWmhjaUJmYkdWdUlEMGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFDd2dZWEpuY3lBOUlHNWxkeUJCY25KaGVTaGZiR1Z1S1N3Z1gydGxlU0E5SURBN0lGOXJaWGtnUENCZmJHVnVPeUJmYTJWNUt5c3BJSHRjYmlBZ0lDQmhjbWR6VzE5clpYbGRJRDBnWVhKbmRXMWxiblJ6VzE5clpYbGRPMXh1SUNCOVhHNWNiaUFnYVc1dVpYSlBheTVoY0hCc2VTaDJiMmxrSURBc0lGdHZheXdnWVhKbmN5NXNaVzVuZEdoZExtTnZibU5oZENoaGNtZHpLU2s3WEc1OVhHNWNibUZ6YzJWeWRDNXZheUE5SUc5ck95QXZMeUJVYUdVZ1pYRjFZV3hwZEhrZ1lYTnpaWEowYVc5dUlIUmxjM1J6SUhOb1lXeHNiM2NzSUdOdlpYSmphWFpsSUdWeGRXRnNhWFI1SUhkcGRHZ2dQVDB1WEc1Y2JpOHFJR1Z6YkdsdWRDMWthWE5oWW14bElHNXZMWEpsYzNSeWFXTjBaV1F0Y0hKdmNHVnlkR2xsY3lBcUwxeHVYRzVoYzNObGNuUXVaWEYxWVd3Z1BTQm1kVzVqZEdsdmJpQmxjWFZoYkNoaFkzUjFZV3dzSUdWNGNHVmpkR1ZrTENCdFpYTnpZV2RsS1NCN1hHNGdJR2xtSUNoaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvSUR3Z01pa2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QkZVbEpmVFVsVFUwbE9SMTlCVWtkVEtDZGhZM1IxWVd3bkxDQW5aWGh3WldOMFpXUW5LVHRjYmlBZ2ZTQXZMeUJsYzJ4cGJuUXRaR2x6WVdKc1pTMXVaWGgwTFd4cGJtVWdaWEZsY1dWeFhHNWNibHh1SUNCcFppQW9ZV04wZFdGc0lDRTlJR1Y0Y0dWamRHVmtLU0I3WEc0Z0lDQWdhVzV1WlhKR1lXbHNLSHRjYmlBZ0lDQWdJR0ZqZEhWaGJEb2dZV04wZFdGc0xGeHVJQ0FnSUNBZ1pYaHdaV04wWldRNklHVjRjR1ZqZEdWa0xGeHVJQ0FnSUNBZ2JXVnpjMkZuWlRvZ2JXVnpjMkZuWlN4Y2JpQWdJQ0FnSUc5d1pYSmhkRzl5T2lBblBUMG5MRnh1SUNBZ0lDQWdjM1JoWTJ0VGRHRnlkRVp1T2lCbGNYVmhiRnh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlPeUF2THlCVWFHVWdibTl1TFdWeGRXRnNhWFI1SUdGemMyVnlkR2x2YmlCMFpYTjBjeUJtYjNJZ2QyaGxkR2hsY2lCMGQyOGdiMkpxWldOMGN5QmhjbVVnYm05MFhHNHZMeUJsY1hWaGJDQjNhWFJvSUNFOUxseHVYRzVjYm1GemMyVnlkQzV1YjNSRmNYVmhiQ0E5SUdaMWJtTjBhVzl1SUc1dmRFVnhkV0ZzS0dGamRIVmhiQ3dnWlhod1pXTjBaV1FzSUcxbGMzTmhaMlVwSUh0Y2JpQWdhV1lnS0dGeVozVnRaVzUwY3k1c1pXNW5kR2dnUENBeUtTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVlNVbDlOU1ZOVFNVNUhYMEZTUjFNb0oyRmpkSFZoYkNjc0lDZGxlSEJsWTNSbFpDY3BPMXh1SUNCOUlDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXNWxlSFF0YkdsdVpTQmxjV1Z4WlhGY2JseHVYRzRnSUdsbUlDaGhZM1IxWVd3Z1BUMGdaWGh3WldOMFpXUXBJSHRjYmlBZ0lDQnBibTVsY2taaGFXd29lMXh1SUNBZ0lDQWdZV04wZFdGc09pQmhZM1IxWVd3c1hHNGdJQ0FnSUNCbGVIQmxZM1JsWkRvZ1pYaHdaV04wWldRc1hHNGdJQ0FnSUNCdFpYTnpZV2RsT2lCdFpYTnpZV2RsTEZ4dUlDQWdJQ0FnYjNCbGNtRjBiM0k2SUNjaFBTY3NYRzRnSUNBZ0lDQnpkR0ZqYTFOMFlYSjBSbTQ2SUc1dmRFVnhkV0ZzWEc0Z0lDQWdmU2s3WEc0Z0lIMWNibjA3SUM4dklGUm9aU0JsY1hWcGRtRnNaVzVqWlNCaGMzTmxjblJwYjI0Z2RHVnpkSE1nWVNCa1pXVndJR1Z4ZFdGc2FYUjVJSEpsYkdGMGFXOXVMbHh1WEc1Y2JtRnpjMlZ5ZEM1a1pXVndSWEYxWVd3Z1BTQm1kVzVqZEdsdmJpQmtaV1Z3UlhGMVlXd29ZV04wZFdGc0xDQmxlSEJsWTNSbFpDd2diV1Z6YzJGblpTa2dlMXh1SUNCcFppQW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQThJRElwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlZKU1gwMUpVMU5KVGtkZlFWSkhVeWduWVdOMGRXRnNKeXdnSjJWNGNHVmpkR1ZrSnlrN1hHNGdJSDFjYmx4dUlDQnBaaUFvYVhORVpXVndSWEYxWVd3Z1BUMDlJSFZ1WkdWbWFXNWxaQ2tnYkdGNmVVeHZZV1JEYjIxd1lYSnBjMjl1S0NrN1hHNWNiaUFnYVdZZ0tDRnBjMFJsWlhCRmNYVmhiQ2hoWTNSMVlXd3NJR1Y0Y0dWamRHVmtLU2tnZTF4dUlDQWdJR2x1Ym1WeVJtRnBiQ2g3WEc0Z0lDQWdJQ0JoWTNSMVlXdzZJR0ZqZEhWaGJDeGNiaUFnSUNBZ0lHVjRjR1ZqZEdWa09pQmxlSEJsWTNSbFpDeGNiaUFnSUNBZ0lHMWxjM05oWjJVNklHMWxjM05oWjJVc1hHNGdJQ0FnSUNCdmNHVnlZWFJ2Y2pvZ0oyUmxaWEJGY1hWaGJDY3NYRzRnSUNBZ0lDQnpkR0ZqYTFOMFlYSjBSbTQ2SUdSbFpYQkZjWFZoYkZ4dUlDQWdJSDBwTzF4dUlDQjlYRzU5T3lBdkx5QlVhR1VnYm05dUxXVnhkV2wyWVd4bGJtTmxJR0Z6YzJWeWRHbHZiaUIwWlhOMGN5Qm1iM0lnWVc1NUlHUmxaWEFnYVc1bGNYVmhiR2wwZVM1Y2JseHVYRzVoYzNObGNuUXVibTkwUkdWbGNFVnhkV0ZzSUQwZ1puVnVZM1JwYjI0Z2JtOTBSR1ZsY0VWeGRXRnNLR0ZqZEhWaGJDd2daWGh3WldOMFpXUXNJRzFsYzNOaFoyVXBJSHRjYmlBZ2FXWWdLR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ2dQQ0F5S1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWU1VsOU5TVk5UU1U1SFgwRlNSMU1vSjJGamRIVmhiQ2NzSUNkbGVIQmxZM1JsWkNjcE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0dselJHVmxjRVZ4ZFdGc0lEMDlQU0IxYm1SbFptbHVaV1FwSUd4aGVubE1iMkZrUTI5dGNHRnlhWE52YmlncE8xeHVYRzRnSUdsbUlDaHBjMFJsWlhCRmNYVmhiQ2hoWTNSMVlXd3NJR1Y0Y0dWamRHVmtLU2tnZTF4dUlDQWdJR2x1Ym1WeVJtRnBiQ2g3WEc0Z0lDQWdJQ0JoWTNSMVlXdzZJR0ZqZEhWaGJDeGNiaUFnSUNBZ0lHVjRjR1ZqZEdWa09pQmxlSEJsWTNSbFpDeGNiaUFnSUNBZ0lHMWxjM05oWjJVNklHMWxjM05oWjJVc1hHNGdJQ0FnSUNCdmNHVnlZWFJ2Y2pvZ0oyNXZkRVJsWlhCRmNYVmhiQ2NzWEc0Z0lDQWdJQ0J6ZEdGamExTjBZWEowUm00NklHNXZkRVJsWlhCRmNYVmhiRnh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlPMXh1THlvZ1pYTnNhVzUwTFdWdVlXSnNaU0FxTDF4dVhHNWNibUZ6YzJWeWRDNWtaV1Z3VTNSeWFXTjBSWEYxWVd3Z1BTQm1kVzVqZEdsdmJpQmtaV1Z3VTNSeWFXTjBSWEYxWVd3b1lXTjBkV0ZzTENCbGVIQmxZM1JsWkN3Z2JXVnpjMkZuWlNrZ2UxeHVJQ0JwWmlBb1lYSm5kVzFsYm5SekxteGxibWQwYUNBOElESXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSVkpTWDAxSlUxTkpUa2RmUVZKSFV5Z25ZV04wZFdGc0p5d2dKMlY0Y0dWamRHVmtKeWs3WEc0Z0lIMWNibHh1SUNCcFppQW9hWE5FWldWd1JYRjFZV3dnUFQwOUlIVnVaR1ZtYVc1bFpDa2diR0Y2ZVV4dllXUkRiMjF3WVhKcGMyOXVLQ2s3WEc1Y2JpQWdhV1lnS0NGcGMwUmxaWEJUZEhKcFkzUkZjWFZoYkNoaFkzUjFZV3dzSUdWNGNHVmpkR1ZrS1NrZ2UxeHVJQ0FnSUdsdWJtVnlSbUZwYkNoN1hHNGdJQ0FnSUNCaFkzUjFZV3c2SUdGamRIVmhiQ3hjYmlBZ0lDQWdJR1Y0Y0dWamRHVmtPaUJsZUhCbFkzUmxaQ3hjYmlBZ0lDQWdJRzFsYzNOaFoyVTZJRzFsYzNOaFoyVXNYRzRnSUNBZ0lDQnZjR1Z5WVhSdmNqb2dKMlJsWlhCVGRISnBZM1JGY1hWaGJDY3NYRzRnSUNBZ0lDQnpkR0ZqYTFOMFlYSjBSbTQ2SUdSbFpYQlRkSEpwWTNSRmNYVmhiRnh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlPMXh1WEc1aGMzTmxjblF1Ym05MFJHVmxjRk4wY21samRFVnhkV0ZzSUQwZ2JtOTBSR1ZsY0ZOMGNtbGpkRVZ4ZFdGc08xeHVYRzVtZFc1amRHbHZiaUJ1YjNSRVpXVndVM1J5YVdOMFJYRjFZV3dvWVdOMGRXRnNMQ0JsZUhCbFkzUmxaQ3dnYldWemMyRm5aU2tnZTF4dUlDQnBaaUFvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0E4SURJcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JWSlNYMDFKVTFOSlRrZGZRVkpIVXlnbllXTjBkV0ZzSnl3Z0oyVjRjR1ZqZEdWa0p5azdYRzRnSUgxY2JseHVJQ0JwWmlBb2FYTkVaV1Z3UlhGMVlXd2dQVDA5SUhWdVpHVm1hVzVsWkNrZ2JHRjZlVXh2WVdSRGIyMXdZWEpwYzI5dUtDazdYRzVjYmlBZ2FXWWdLR2x6UkdWbGNGTjBjbWxqZEVWeGRXRnNLR0ZqZEhWaGJDd2daWGh3WldOMFpXUXBLU0I3WEc0Z0lDQWdhVzV1WlhKR1lXbHNLSHRjYmlBZ0lDQWdJR0ZqZEhWaGJEb2dZV04wZFdGc0xGeHVJQ0FnSUNBZ1pYaHdaV04wWldRNklHVjRjR1ZqZEdWa0xGeHVJQ0FnSUNBZ2JXVnpjMkZuWlRvZ2JXVnpjMkZuWlN4Y2JpQWdJQ0FnSUc5d1pYSmhkRzl5T2lBbmJtOTBSR1ZsY0ZOMGNtbGpkRVZ4ZFdGc0p5eGNiaUFnSUNBZ0lITjBZV05yVTNSaGNuUkdiam9nYm05MFJHVmxjRk4wY21samRFVnhkV0ZzWEc0Z0lDQWdmU2s3WEc0Z0lIMWNibjFjYmx4dVlYTnpaWEowTG5OMGNtbGpkRVZ4ZFdGc0lEMGdablZ1WTNScGIyNGdjM1J5YVdOMFJYRjFZV3dvWVdOMGRXRnNMQ0JsZUhCbFkzUmxaQ3dnYldWemMyRm5aU2tnZTF4dUlDQnBaaUFvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0E4SURJcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JWSlNYMDFKVTFOSlRrZGZRVkpIVXlnbllXTjBkV0ZzSnl3Z0oyVjRjR1ZqZEdWa0p5azdYRzRnSUgxY2JseHVJQ0JwWmlBb0lXOWlhbVZqZEVsektHRmpkSFZoYkN3Z1pYaHdaV04wWldRcEtTQjdYRzRnSUNBZ2FXNXVaWEpHWVdsc0tIdGNiaUFnSUNBZ0lHRmpkSFZoYkRvZ1lXTjBkV0ZzTEZ4dUlDQWdJQ0FnWlhod1pXTjBaV1E2SUdWNGNHVmpkR1ZrTEZ4dUlDQWdJQ0FnYldWemMyRm5aVG9nYldWemMyRm5aU3hjYmlBZ0lDQWdJRzl3WlhKaGRHOXlPaUFuYzNSeWFXTjBSWEYxWVd3bkxGeHVJQ0FnSUNBZ2MzUmhZMnRUZEdGeWRFWnVPaUJ6ZEhKcFkzUkZjWFZoYkZ4dUlDQWdJSDBwTzF4dUlDQjlYRzU5TzF4dVhHNWhjM05sY25RdWJtOTBVM1J5YVdOMFJYRjFZV3dnUFNCbWRXNWpkR2x2YmlCdWIzUlRkSEpwWTNSRmNYVmhiQ2hoWTNSMVlXd3NJR1Y0Y0dWamRHVmtMQ0J0WlhOellXZGxLU0I3WEc0Z0lHbG1JQ2hoY21kMWJXVnVkSE11YkdWdVozUm9JRHdnTWlrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCRlVsSmZUVWxUVTBsT1IxOUJVa2RUS0NkaFkzUjFZV3duTENBblpYaHdaV04wWldRbktUdGNiaUFnZlZ4dVhHNGdJR2xtSUNodlltcGxZM1JKY3loaFkzUjFZV3dzSUdWNGNHVmpkR1ZrS1NrZ2UxeHVJQ0FnSUdsdWJtVnlSbUZwYkNoN1hHNGdJQ0FnSUNCaFkzUjFZV3c2SUdGamRIVmhiQ3hjYmlBZ0lDQWdJR1Y0Y0dWamRHVmtPaUJsZUhCbFkzUmxaQ3hjYmlBZ0lDQWdJRzFsYzNOaFoyVTZJRzFsYzNOaFoyVXNYRzRnSUNBZ0lDQnZjR1Z5WVhSdmNqb2dKMjV2ZEZOMGNtbGpkRVZ4ZFdGc0p5eGNiaUFnSUNBZ0lITjBZV05yVTNSaGNuUkdiam9nYm05MFUzUnlhV04wUlhGMVlXeGNiaUFnSUNCOUtUdGNiaUFnZlZ4dWZUdGNibHh1ZG1GeUlFTnZiWEJoY21semIyNGdQU0JtZFc1amRHbHZiaUJEYjIxd1lYSnBjMjl1S0c5aWFpd2dhMlY1Y3l3Z1lXTjBkV0ZzS1NCN1hHNGdJSFpoY2lCZmRHaHBjeUE5SUhSb2FYTTdYRzVjYmlBZ1gyTnNZWE56UTJGc2JFTm9aV05yS0hSb2FYTXNJRU52YlhCaGNtbHpiMjRwTzF4dVhHNGdJR3RsZVhNdVptOXlSV0ZqYUNobWRXNWpkR2x2YmlBb2EyVjVLU0I3WEc0Z0lDQWdhV1lnS0d0bGVTQnBiaUJ2WW1vcElIdGNiaUFnSUNBZ0lHbG1JQ2hoWTNSMVlXd2dJVDA5SUhWdVpHVm1hVzVsWkNBbUppQjBlWEJsYjJZZ1lXTjBkV0ZzVzJ0bGVWMGdQVDA5SUNkemRISnBibWNuSUNZbUlHbHpVbVZuUlhod0tHOWlhbHRyWlhsZEtTQW1KaUJ2WW1wYmEyVjVYUzUwWlhOMEtHRmpkSFZoYkZ0clpYbGRLU2tnZTF4dUlDQWdJQ0FnSUNCZmRHaHBjMXRyWlhsZElEMGdZV04wZFdGc1cydGxlVjA3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JmZEdocGMxdHJaWGxkSUQwZ2IySnFXMnRsZVYwN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlLVHRjYm4wN1hHNWNibVoxYm1OMGFXOXVJR052YlhCaGNtVkZlR05sY0hScGIyNUxaWGtvWVdOMGRXRnNMQ0JsZUhCbFkzUmxaQ3dnYTJWNUxDQnRaWE56WVdkbExDQnJaWGx6TENCbWJpa2dlMXh1SUNCcFppQW9JU2hyWlhrZ2FXNGdZV04wZFdGc0tTQjhmQ0FoYVhORVpXVndVM1J5YVdOMFJYRjFZV3dvWVdOMGRXRnNXMnRsZVYwc0lHVjRjR1ZqZEdWa1cydGxlVjBwS1NCN1hHNGdJQ0FnYVdZZ0tDRnRaWE56WVdkbEtTQjdYRzRnSUNBZ0lDQXZMeUJEY21WaGRHVWdjR3hoWTJWb2IyeGtaWElnYjJKcVpXTjBjeUIwYnlCamNtVmhkR1VnWVNCdWFXTmxJRzkxZEhCMWRDNWNiaUFnSUNBZ0lIWmhjaUJoSUQwZ2JtVjNJRU52YlhCaGNtbHpiMjRvWVdOMGRXRnNMQ0JyWlhsektUdGNiaUFnSUNBZ0lIWmhjaUJpSUQwZ2JtVjNJRU52YlhCaGNtbHpiMjRvWlhod1pXTjBaV1FzSUd0bGVYTXNJR0ZqZEhWaGJDazdYRzRnSUNBZ0lDQjJZWElnWlhKeUlEMGdibVYzSUVGemMyVnlkR2x2YmtWeWNtOXlLSHRjYmlBZ0lDQWdJQ0FnWVdOMGRXRnNPaUJoTEZ4dUlDQWdJQ0FnSUNCbGVIQmxZM1JsWkRvZ1lpeGNiaUFnSUNBZ0lDQWdiM0JsY21GMGIzSTZJQ2RrWldWd1UzUnlhV04wUlhGMVlXd25MRnh1SUNBZ0lDQWdJQ0J6ZEdGamExTjBZWEowUm00NklHWnVYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJR1Z5Y2k1aFkzUjFZV3dnUFNCaFkzUjFZV3c3WEc0Z0lDQWdJQ0JsY25JdVpYaHdaV04wWldRZ1BTQmxlSEJsWTNSbFpEdGNiaUFnSUNBZ0lHVnljaTV2Y0dWeVlYUnZjaUE5SUdadUxtNWhiV1U3WEc0Z0lDQWdJQ0IwYUhKdmR5Qmxjbkk3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdhVzV1WlhKR1lXbHNLSHRjYmlBZ0lDQWdJR0ZqZEhWaGJEb2dZV04wZFdGc0xGeHVJQ0FnSUNBZ1pYaHdaV04wWldRNklHVjRjR1ZqZEdWa0xGeHVJQ0FnSUNBZ2JXVnpjMkZuWlRvZ2JXVnpjMkZuWlN4Y2JpQWdJQ0FnSUc5d1pYSmhkRzl5T2lCbWJpNXVZVzFsTEZ4dUlDQWdJQ0FnYzNSaFkydFRkR0Z5ZEVadU9pQm1ibHh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdWNGNHVmpkR1ZrUlhoalpYQjBhVzl1S0dGamRIVmhiQ3dnWlhod1pXTjBaV1FzSUcxelp5d2dabTRwSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUJsZUhCbFkzUmxaQ0FoUFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lHbG1JQ2hwYzFKbFowVjRjQ2hsZUhCbFkzUmxaQ2twSUhKbGRIVnliaUJsZUhCbFkzUmxaQzUwWlhOMEtHRmpkSFZoYkNrN0lDOHZJR0Z6YzJWeWRDNWtiMlZ6VG05MFZHaHliM2NnWkc5bGN5QnViM1FnWVdOalpYQjBJRzlpYW1WamRITXVYRzVjYmlBZ0lDQnBaaUFvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0E5UFQwZ01pa2dlMXh1SUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZTVWw5SlRsWkJURWxFWDBGU1IxOVVXVkJGS0NkbGVIQmxZM1JsWkNjc0lGc25SblZ1WTNScGIyNG5MQ0FuVW1WblJYaHdKMTBzSUdWNGNHVmpkR1ZrS1R0Y2JpQWdJQ0I5SUM4dklFaGhibVJzWlNCd2NtbHRhWFJwZG1WeklIQnliM0JsY214NUxseHVYRzVjYmlBZ0lDQnBaaUFvWDNSNWNHVnZaaWhoWTNSMVlXd3BJQ0U5UFNBbmIySnFaV04wSnlCOGZDQmhZM1IxWVd3Z1BUMDlJRzUxYkd3cElIdGNiaUFnSUNBZ0lIWmhjaUJsY25JZ1BTQnVaWGNnUVhOelpYSjBhVzl1UlhKeWIzSW9lMXh1SUNBZ0lDQWdJQ0JoWTNSMVlXdzZJR0ZqZEhWaGJDeGNiaUFnSUNBZ0lDQWdaWGh3WldOMFpXUTZJR1Y0Y0dWamRHVmtMRnh1SUNBZ0lDQWdJQ0J0WlhOellXZGxPaUJ0YzJjc1hHNGdJQ0FnSUNBZ0lHOXdaWEpoZEc5eU9pQW5aR1ZsY0ZOMGNtbGpkRVZ4ZFdGc0p5eGNiaUFnSUNBZ0lDQWdjM1JoWTJ0VGRHRnlkRVp1T2lCbWJseHVJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQmxjbkl1YjNCbGNtRjBiM0lnUFNCbWJpNXVZVzFsTzF4dUlDQWdJQ0FnZEdoeWIzY2daWEp5TzF4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCclpYbHpJRDBnVDJKcVpXTjBMbXRsZVhNb1pYaHdaV04wWldRcE95QXZMeUJUY0dWamFXRnNJR2hoYm1Sc1pTQmxjbkp2Y25NZ2RHOGdiV0ZyWlNCemRYSmxJSFJvWlNCdVlXMWxJR0Z1WkNCMGFHVWdiV1Z6YzJGblpTQmhjbVVnWTI5dGNHRnlaV1JjYmlBZ0lDQXZMeUJoY3lCM1pXeHNMbHh1WEc0Z0lDQWdhV1lnS0dWNGNHVmpkR1ZrSUdsdWMzUmhibU5sYjJZZ1JYSnliM0lwSUh0Y2JpQWdJQ0FnSUd0bGVYTXVjSFZ6YUNnbmJtRnRaU2NzSUNkdFpYTnpZV2RsSnlrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoclpYbHpMbXhsYm1kMGFDQTlQVDBnTUNrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVlNVbDlKVGxaQlRFbEVYMEZTUjE5V1FVeFZSU2duWlhKeWIzSW5MQ0JsZUhCbFkzUmxaQ3dnSjIxaGVTQnViM1FnWW1VZ1lXNGdaVzF3ZEhrZ2IySnFaV04wSnlrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYVdZZ0tHbHpSR1ZsY0VWeGRXRnNJRDA5UFNCMWJtUmxabWx1WldRcElHeGhlbmxNYjJGa1EyOXRjR0Z5YVhOdmJpZ3BPMXh1SUNBZ0lHdGxlWE11Wm05eVJXRmphQ2htZFc1amRHbHZiaUFvYTJWNUtTQjdYRzRnSUNBZ0lDQnBaaUFvZEhsd1pXOW1JR0ZqZEhWaGJGdHJaWGxkSUQwOVBTQW5jM1J5YVc1bkp5QW1KaUJwYzFKbFowVjRjQ2hsZUhCbFkzUmxaRnRyWlhsZEtTQW1KaUJsZUhCbFkzUmxaRnRyWlhsZExuUmxjM1FvWVdOMGRXRnNXMnRsZVYwcEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdZMjl0Y0dGeVpVVjRZMlZ3ZEdsdmJrdGxlU2hoWTNSMVlXd3NJR1Y0Y0dWamRHVmtMQ0JyWlhrc0lHMXpaeXdnYTJWNWN5d2dabTRwTzF4dUlDQWdJSDBwTzF4dUlDQWdJSEpsZEhWeWJpQjBjblZsTzF4dUlDQjlJQzh2SUVkMVlYSmtJR2x1YzNSaGJtTmxiMllnWVdkaGFXNXpkQ0JoY25KdmR5Qm1kVzVqZEdsdmJuTWdZWE1nZEdobGVTQmtiMjRuZENCb1lYWmxJR0VnY0hKdmRHOTBlWEJsTGx4dVhHNWNiaUFnYVdZZ0tHVjRjR1ZqZEdWa0xuQnliM1J2ZEhsd1pTQWhQVDBnZFc1a1pXWnBibVZrSUNZbUlHRmpkSFZoYkNCcGJuTjBZVzVqWlc5bUlHVjRjR1ZqZEdWa0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSeWRXVTdYRzRnSUgxY2JseHVJQ0JwWmlBb1JYSnliM0l1YVhOUWNtOTBiM1I1Y0dWUFppaGxlSEJsWTNSbFpDa3BJSHRjYmlBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnWlhod1pXTjBaV1F1WTJGc2JDaDdmU3dnWVdOMGRXRnNLU0E5UFQwZ2RISjFaVHRjYm4xY2JseHVablZ1WTNScGIyNGdaMlYwUVdOMGRXRnNLR1p1S1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnWm00Z0lUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnUlZKU1gwbE9Wa0ZNU1VSZlFWSkhYMVJaVUVVb0oyWnVKeXdnSjBaMWJtTjBhVzl1Snl3Z1ptNHBPMXh1SUNCOVhHNWNiaUFnZEhKNUlIdGNiaUFnSUNCbWJpZ3BPMXh1SUNCOUlHTmhkR05vSUNobEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdVN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z1RrOWZSVmhEUlZCVVNVOU9YMU5GVGxSSlRrVk1PMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmphR1ZqYTBselVISnZiV2x6WlNodlltb3BJSHRjYmlBZ0x5OGdRV05qWlhCMElHNWhkR2wyWlNCRlV6WWdjSEp2YldselpYTWdZVzVrSUhCeWIyMXBjMlZ6SUhSb1lYUWdZWEpsSUdsdGNHeGxiV1Z1ZEdWa0lHbHVJR0VnYzJsdGFXeGhjbHh1SUNBdkx5QjNZWGt1SUVSdklHNXZkQ0JoWTJObGNIUWdkR2hsYm1GaWJHVnpJSFJvWVhRZ2RYTmxJR0VnWm5WdVkzUnBiMjRnWVhNZ1lHOWlhbUFnWVc1a0lIUm9ZWFFnYUdGMlpTQnViMXh1SUNBdkx5QmdZMkYwWTJoZ0lHaGhibVJzWlhJdVhHNGdJQzh2SUZSUFJFODZJSFJvWlc1aFlteGxjeUJoY21VZ1kyaGxZMnRsWkNCMWNDQjFiblJwYkNCMGFHVjVJR2hoZG1VZ2RHaGxJR052Y25KbFkzUWdiV1YwYUc5a2N5eGNiaUFnTHk4Z1luVjBJR0ZqWTI5eVpHbHVaeUIwYnlCa2IyTjFiV1Z1ZEdGMGFXOXVMQ0IwYUdVZ1lIUm9aVzVnSUcxbGRHaHZaQ0J6YUc5MWJHUWdjbVZqWldsMlpWeHVJQ0F2THlCMGFHVWdZR1oxYkdacGJHeGdJR0Z1WkNCZ2NtVnFaV04wWUNCaGNtZDFiV1Z1ZEhNZ1lYTWdkMlZzYkNCdmNpQnBkQ0J0WVhrZ1ltVWdibVYyWlhJZ2NtVnpiMngyWldRdVhHNGdJSEpsZEhWeWJpQnBjMUJ5YjIxcGMyVW9iMkpxS1NCOGZDQnZZbW9nSVQwOUlHNTFiR3dnSmlZZ1gzUjVjR1Z2Wmlodlltb3BJRDA5UFNBbmIySnFaV04wSnlBbUppQjBlWEJsYjJZZ2IySnFMblJvWlc0Z1BUMDlJQ2RtZFc1amRHbHZiaWNnSmlZZ2RIbHdaVzltSUc5aWFpNWpZWFJqYUNBOVBUMGdKMloxYm1OMGFXOXVKenRjYm4xY2JseHVablZ1WTNScGIyNGdkMkZwZEVadmNrRmpkSFZoYkNod2NtOXRhWE5sUm00cElIdGNiaUFnY21WMGRYSnVJRkJ5YjIxcGMyVXVjbVZ6YjJ4MlpTZ3BMblJvWlc0b1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lIWmhjaUJ5WlhOMWJIUlFjbTl0YVhObE8xeHVYRzRnSUNBZ2FXWWdLSFI1Y0dWdlppQndjbTl0YVhObFJtNGdQVDA5SUNkbWRXNWpkR2x2YmljcElIdGNiaUFnSUNBZ0lDOHZJRkpsZEhWeWJpQmhJSEpsYW1WamRHVmtJSEJ5YjIxcGMyVWdhV1lnWUhCeWIyMXBjMlZHYm1BZ2RHaHliM2R6SUhONWJtTm9jbTl1YjNWemJIa3VYRzRnSUNBZ0lDQnlaWE4xYkhSUWNtOXRhWE5sSUQwZ2NISnZiV2x6WlVadUtDazdJQzh2SUVaaGFXd2dhVzRnWTJGelpTQnVieUJ3Y205dGFYTmxJR2x6SUhKbGRIVnlibVZrTGx4dVhHNGdJQ0FnSUNCcFppQW9JV05vWldOclNYTlFjbTl0YVhObEtISmxjM1ZzZEZCeWIyMXBjMlVwS1NCN1hHNGdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZVbEpmU1U1V1FVeEpSRjlTUlZSVlVrNWZWa0ZNVlVVb0oybHVjM1JoYm1ObElHOW1JRkJ5YjIxcGMyVW5MQ0FuY0hKdmJXbHpaVVp1Snl3Z2NtVnpkV3gwVUhKdmJXbHpaU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2hqYUdWamEwbHpVSEp2YldselpTaHdjbTl0YVhObFJtNHBLU0I3WEc0Z0lDQWdJQ0J5WlhOMWJIUlFjbTl0YVhObElEMGdjSEp2YldselpVWnVPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JWSlNYMGxPVmtGTVNVUmZRVkpIWDFSWlVFVW9KM0J5YjIxcGMyVkdiaWNzSUZzblJuVnVZM1JwYjI0bkxDQW5VSEp2YldselpTZGRMQ0J3Y205dGFYTmxSbTRwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEpsZEhWeWJpQlFjbTl0YVhObExuSmxjMjlzZG1Vb0tTNTBhR1Z1S0daMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCeVpYTjFiSFJRY205dGFYTmxPMXh1SUNBZ0lIMHBMblJvWlc0b1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlFNVBYMFZZUTBWUVZFbFBUbDlUUlU1VVNVNUZURHRjYmlBZ0lDQjlLUzVqWVhSamFDaG1kVzVqZEdsdmJpQW9aU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1U3WEc0Z0lDQWdmU2s3WEc0Z0lIMHBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmxlSEJsWTNSelJYSnliM0lvYzNSaFkydFRkR0Z5ZEVadUxDQmhZM1IxWVd3c0lHVnljbTl5TENCdFpYTnpZV2RsS1NCN1hHNGdJR2xtSUNoMGVYQmxiMllnWlhKeWIzSWdQVDA5SUNkemRISnBibWNuS1NCN1hHNGdJQ0FnYVdZZ0tHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnZ1BUMDlJRFFwSUh0Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRlVsSmZTVTVXUVV4SlJGOUJVa2RmVkZsUVJTZ25aWEp5YjNJbkxDQmJKMDlpYW1WamRDY3NJQ2RGY25KdmNpY3NJQ2RHZFc1amRHbHZiaWNzSUNkU1pXZEZlSEFuWFN3Z1pYSnliM0lwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNoZmRIbHdaVzltS0dGamRIVmhiQ2tnUFQwOUlDZHZZbXBsWTNRbklDWW1JR0ZqZEhWaGJDQWhQVDBnYm5Wc2JDa2dlMXh1SUNBZ0lDQWdhV1lnS0dGamRIVmhiQzV0WlhOellXZGxJRDA5UFNCbGNuSnZjaWtnZTF4dUlDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JWSlNYMEZOUWtsSFZVOVZVMTlCVWtkVlRVVk9WQ2duWlhKeWIzSXZiV1Z6YzJGblpTY3NJRndpVkdobElHVnljbTl5SUcxbGMzTmhaMlVnWEZ4Y0lsd2lMbU52Ym1OaGRDaGhZM1IxWVd3dWJXVnpjMkZuWlN3Z1hDSmNYRndpSUdseklHbGtaVzUwYVdOaGJDQjBieUIwYUdVZ2JXVnpjMkZuWlM1Y0lpa3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9ZV04wZFdGc0lEMDlQU0JsY25KdmNpa2dlMXh1SUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZTVWw5QlRVSkpSMVZQVlZOZlFWSkhWVTFGVGxRb0oyVnljbTl5TDIxbGMzTmhaMlVuTENCY0lsUm9aU0JsY25KdmNpQmNYRndpWENJdVkyOXVZMkYwS0dGamRIVmhiQ3dnWENKY1hGd2lJR2x6SUdsa1pXNTBhV05oYkNCMGJ5QjBhR1VnYldWemMyRm5aUzVjSWlrcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUcxbGMzTmhaMlVnUFNCbGNuSnZjanRjYmlBZ0lDQmxjbkp2Y2lBOUlIVnVaR1ZtYVc1bFpEdGNiaUFnZlNCbGJITmxJR2xtSUNobGNuSnZjaUFoUFNCdWRXeHNJQ1ltSUY5MGVYQmxiMllvWlhKeWIzSXBJQ0U5UFNBbmIySnFaV04wSnlBbUppQjBlWEJsYjJZZ1pYSnliM0lnSVQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSVkpTWDBsT1ZrRk1TVVJmUVZKSFgxUlpVRVVvSjJWeWNtOXlKeXdnV3lkUFltcGxZM1FuTENBblJYSnliM0luTENBblJuVnVZM1JwYjI0bkxDQW5VbVZuUlhod0oxMHNJR1Z5Y205eUtUdGNiaUFnZlZ4dVhHNGdJR2xtSUNoaFkzUjFZV3dnUFQwOUlFNVBYMFZZUTBWUVZFbFBUbDlUUlU1VVNVNUZUQ2tnZTF4dUlDQWdJSFpoY2lCa1pYUmhhV3h6SUQwZ0p5YzdYRzVjYmlBZ0lDQnBaaUFvWlhKeWIzSWdKaVlnWlhKeWIzSXVibUZ0WlNrZ2UxeHVJQ0FnSUNBZ1pHVjBZV2xzY3lBclBTQmNJaUFvWENJdVkyOXVZMkYwS0dWeWNtOXlMbTVoYldVc0lGd2lLVndpS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JrWlhSaGFXeHpJQ3M5SUcxbGMzTmhaMlVnUHlCY0lqb2dYQ0l1WTI5dVkyRjBLRzFsYzNOaFoyVXBJRG9nSnk0bk8xeHVJQ0FnSUhaaGNpQm1ibFI1Y0dVZ1BTQnpkR0ZqYTFOMFlYSjBSbTR1Ym1GdFpTQTlQVDBnSjNKbGFtVmpkSE1uSUQ4Z0ozSmxhbVZqZEdsdmJpY2dPaUFuWlhoalpYQjBhVzl1Snp0Y2JpQWdJQ0JwYm01bGNrWmhhV3dvZTF4dUlDQWdJQ0FnWVdOMGRXRnNPaUIxYm1SbFptbHVaV1FzWEc0Z0lDQWdJQ0JsZUhCbFkzUmxaRG9nWlhKeWIzSXNYRzRnSUNBZ0lDQnZjR1Z5WVhSdmNqb2djM1JoWTJ0VGRHRnlkRVp1TG01aGJXVXNYRzRnSUNBZ0lDQnRaWE56WVdkbE9pQmNJazFwYzNOcGJtY2daWGh3WldOMFpXUWdYQ0l1WTI5dVkyRjBLR1p1Vkhsd1pTa3VZMjl1WTJGMEtHUmxkR0ZwYkhNcExGeHVJQ0FnSUNBZ2MzUmhZMnRUZEdGeWRFWnVPaUJ6ZEdGamExTjBZWEowUm01Y2JpQWdJQ0I5S1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2hsY25KdmNpQW1KaUFoWlhod1pXTjBaV1JGZUdObGNIUnBiMjRvWVdOMGRXRnNMQ0JsY25KdmNpd2diV1Z6YzJGblpTd2djM1JoWTJ0VGRHRnlkRVp1S1NrZ2UxeHVJQ0FnSUhSb2NtOTNJR0ZqZEhWaGJEdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJsZUhCbFkzUnpUbTlGY25KdmNpaHpkR0ZqYTFOMFlYSjBSbTRzSUdGamRIVmhiQ3dnWlhKeWIzSXNJRzFsYzNOaFoyVXBJSHRjYmlBZ2FXWWdLR0ZqZEhWaGJDQTlQVDBnVGs5ZlJWaERSVkJVU1U5T1gxTkZUbFJKVGtWTUtTQnlaWFIxY200N1hHNWNiaUFnYVdZZ0tIUjVjR1Z2WmlCbGNuSnZjaUE5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCdFpYTnpZV2RsSUQwZ1pYSnliM0k3WEc0Z0lDQWdaWEp5YjNJZ1BTQjFibVJsWm1sdVpXUTdYRzRnSUgxY2JseHVJQ0JwWmlBb0lXVnljbTl5SUh4OElHVjRjR1ZqZEdWa1JYaGpaWEIwYVc5dUtHRmpkSFZoYkN3Z1pYSnliM0lwS1NCN1hHNGdJQ0FnZG1GeUlHUmxkR0ZwYkhNZ1BTQnRaWE56WVdkbElEOGdYQ0k2SUZ3aUxtTnZibU5oZENodFpYTnpZV2RsS1NBNklDY3VKenRjYmlBZ0lDQjJZWElnWm01VWVYQmxJRDBnYzNSaFkydFRkR0Z5ZEVadUxtNWhiV1VnUFQwOUlDZGtiMlZ6VG05MFVtVnFaV04wSnlBL0lDZHlaV3BsWTNScGIyNG5JRG9nSjJWNFkyVndkR2x2YmljN1hHNGdJQ0FnYVc1dVpYSkdZV2xzS0h0Y2JpQWdJQ0FnSUdGamRIVmhiRG9nWVdOMGRXRnNMRnh1SUNBZ0lDQWdaWGh3WldOMFpXUTZJR1Z5Y205eUxGeHVJQ0FnSUNBZ2IzQmxjbUYwYjNJNklITjBZV05yVTNSaGNuUkdiaTV1WVcxbExGeHVJQ0FnSUNBZ2JXVnpjMkZuWlRvZ1hDSkhiM1FnZFc1M1lXNTBaV1FnWENJdVkyOXVZMkYwS0dadVZIbHdaU2t1WTI5dVkyRjBLR1JsZEdGcGJITXNJRndpWEZ4dVhDSXBJQ3NnWENKQlkzUjFZV3dnYldWemMyRm5aVG9nWEZ4Y0lsd2lMbU52Ym1OaGRDaGhZM1IxWVd3Z0ppWWdZV04wZFdGc0xtMWxjM05oWjJVc0lGd2lYRnhjSWx3aUtTeGNiaUFnSUNBZ0lITjBZV05yVTNSaGNuUkdiam9nYzNSaFkydFRkR0Z5ZEVadVhHNGdJQ0FnZlNrN1hHNGdJSDFjYmx4dUlDQjBhSEp2ZHlCaFkzUjFZV3c3WEc1OVhHNWNibUZ6YzJWeWRDNTBhSEp2ZDNNZ1BTQm1kVzVqZEdsdmJpQjBhSEp2ZDNNb2NISnZiV2x6WlVadUtTQjdYRzRnSUdadmNpQW9kbUZ5SUY5c1pXNHlJRDBnWVhKbmRXMWxiblJ6TG14bGJtZDBhQ3dnWVhKbmN5QTlJRzVsZHlCQmNuSmhlU2hmYkdWdU1pQStJREVnUHlCZmJHVnVNaUF0SURFZ09pQXdLU3dnWDJ0bGVUSWdQU0F4T3lCZmEyVjVNaUE4SUY5c1pXNHlPeUJmYTJWNU1pc3JLU0I3WEc0Z0lDQWdZWEpuYzF0ZmEyVjVNaUF0SURGZElEMGdZWEpuZFcxbGJuUnpXMTlyWlhreVhUdGNiaUFnZlZ4dVhHNGdJR1Y0Y0dWamRITkZjbkp2Y2k1aGNIQnNlU2gyYjJsa0lEQXNJRnQwYUhKdmQzTXNJR2RsZEVGamRIVmhiQ2h3Y205dGFYTmxSbTRwWFM1amIyNWpZWFFvWVhKbmN5a3BPMXh1ZlR0Y2JseHVZWE56WlhKMExuSmxhbVZqZEhNZ1BTQm1kVzVqZEdsdmJpQnlaV3BsWTNSektIQnliMjFwYzJWR2Jpa2dlMXh1SUNCbWIzSWdLSFpoY2lCZmJHVnVNeUE5SUdGeVozVnRaVzUwY3k1c1pXNW5kR2dzSUdGeVozTWdQU0J1WlhjZ1FYSnlZWGtvWDJ4bGJqTWdQaUF4SUQ4Z1gyeGxiak1nTFNBeElEb2dNQ2tzSUY5clpYa3pJRDBnTVRzZ1gydGxlVE1nUENCZmJHVnVNenNnWDJ0bGVUTXJLeWtnZTF4dUlDQWdJR0Z5WjNOYlgydGxlVE1nTFNBeFhTQTlJR0Z5WjNWdFpXNTBjMXRmYTJWNU0xMDdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdkMkZwZEVadmNrRmpkSFZoYkNod2NtOXRhWE5sUm00cExuUm9aVzRvWm5WdVkzUnBiMjRnS0hKbGMzVnNkQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQmxlSEJsWTNSelJYSnliM0l1WVhCd2JIa29kbTlwWkNBd0xDQmJjbVZxWldOMGN5d2djbVZ6ZFd4MFhTNWpiMjVqWVhRb1lYSm5jeWtwTzF4dUlDQjlLVHRjYm4wN1hHNWNibUZ6YzJWeWRDNWtiMlZ6VG05MFZHaHliM2NnUFNCbWRXNWpkR2x2YmlCa2IyVnpUbTkwVkdoeWIzY29abTRwSUh0Y2JpQWdabTl5SUNoMllYSWdYMnhsYmpRZ1BTQmhjbWQxYldWdWRITXViR1Z1WjNSb0xDQmhjbWR6SUQwZ2JtVjNJRUZ5Y21GNUtGOXNaVzQwSUQ0Z01TQS9JRjlzWlc0MElDMGdNU0E2SURBcExDQmZhMlY1TkNBOUlERTdJRjlyWlhrMElEd2dYMnhsYmpRN0lGOXJaWGswS3lzcElIdGNiaUFnSUNCaGNtZHpXMTlyWlhrMElDMGdNVjBnUFNCaGNtZDFiV1Z1ZEhOYlgydGxlVFJkTzF4dUlDQjlYRzVjYmlBZ1pYaHdaV04wYzA1dlJYSnliM0l1WVhCd2JIa29kbTlwWkNBd0xDQmJaRzlsYzA1dmRGUm9jbTkzTENCblpYUkJZM1IxWVd3b1ptNHBYUzVqYjI1allYUW9ZWEpuY3lrcE8xeHVmVHRjYmx4dVlYTnpaWEowTG1SdlpYTk9iM1JTWldwbFkzUWdQU0JtZFc1amRHbHZiaUJrYjJWelRtOTBVbVZxWldOMEtHWnVLU0I3WEc0Z0lHWnZjaUFvZG1GeUlGOXNaVzQxSUQwZ1lYSm5kVzFsYm5SekxteGxibWQwYUN3Z1lYSm5jeUE5SUc1bGR5QkJjbkpoZVNoZmJHVnVOU0ErSURFZ1B5QmZiR1Z1TlNBdElERWdPaUF3S1N3Z1gydGxlVFVnUFNBeE95QmZhMlY1TlNBOElGOXNaVzQxT3lCZmEyVjVOU3NyS1NCN1hHNGdJQ0FnWVhKbmMxdGZhMlY1TlNBdElERmRJRDBnWVhKbmRXMWxiblJ6VzE5clpYazFYVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUIzWVdsMFJtOXlRV04wZFdGc0tHWnVLUzUwYUdWdUtHWjFibU4wYVc5dUlDaHlaWE4xYkhRcElIdGNiaUFnSUNCeVpYUjFjbTRnWlhod1pXTjBjMDV2UlhKeWIzSXVZWEJ3Ykhrb2RtOXBaQ0F3TENCYlpHOWxjMDV2ZEZKbGFtVmpkQ3dnY21WemRXeDBYUzVqYjI1allYUW9ZWEpuY3lrcE8xeHVJQ0I5S1R0Y2JuMDdYRzVjYm1GemMyVnlkQzVwWmtWeWNtOXlJRDBnWm5WdVkzUnBiMjRnYVdaRmNuSnZjaWhsY25JcElIdGNiaUFnYVdZZ0tHVnljaUFoUFQwZ2JuVnNiQ0FtSmlCbGNuSWdJVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUhaaGNpQnRaWE56WVdkbElEMGdKMmxtUlhKeWIzSWdaMjkwSUhWdWQyRnVkR1ZrSUdWNFkyVndkR2x2YmpvZ0p6dGNibHh1SUNBZ0lHbG1JQ2hmZEhsd1pXOW1LR1Z5Y2lrZ1BUMDlJQ2R2WW1wbFkzUW5JQ1ltSUhSNWNHVnZaaUJsY25JdWJXVnpjMkZuWlNBOVBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQWdJR2xtSUNobGNuSXViV1Z6YzJGblpTNXNaVzVuZEdnZ1BUMDlJREFnSmlZZ1pYSnlMbU52Ym5OMGNuVmpkRzl5S1NCN1hHNGdJQ0FnSUNBZ0lHMWxjM05oWjJVZ0t6MGdaWEp5TG1OdmJuTjBjblZqZEc5eUxtNWhiV1U3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0J0WlhOellXZGxJQ3M5SUdWeWNpNXRaWE56WVdkbE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J0WlhOellXZGxJQ3M5SUdsdWMzQmxZM1FvWlhKeUtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCMllYSWdibVYzUlhKeUlEMGdibVYzSUVGemMyVnlkR2x2YmtWeWNtOXlLSHRjYmlBZ0lDQWdJR0ZqZEhWaGJEb2daWEp5TEZ4dUlDQWdJQ0FnWlhod1pXTjBaV1E2SUc1MWJHd3NYRzRnSUNBZ0lDQnZjR1Z5WVhSdmNqb2dKMmxtUlhKeWIzSW5MRnh1SUNBZ0lDQWdiV1Z6YzJGblpUb2diV1Z6YzJGblpTeGNiaUFnSUNBZ0lITjBZV05yVTNSaGNuUkdiam9nYVdaRmNuSnZjbHh1SUNBZ0lIMHBPeUF2THlCTllXdGxJSE4xY21VZ2QyVWdZV04wZFdGc2JIa2dhR0YyWlNCaElITjBZV05ySUhSeVlXTmxJVnh1WEc0Z0lDQWdkbUZ5SUc5eWFXZFRkR0ZqYXlBOUlHVnljaTV6ZEdGamF6dGNibHh1SUNBZ0lHbG1JQ2gwZVhCbGIyWWdiM0pwWjFOMFlXTnJJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUNBZ0x5OGdWR2hwY3lCM2FXeHNJSEpsYlc5MlpTQmhibmtnWkhWd2JHbGpZWFJsWkNCbWNtRnRaWE1nWm5KdmJTQjBhR1VnWlhKeWIzSWdabkpoYldWeklIUmhhMlZ1WEc0Z0lDQWdJQ0F2THlCbWNtOXRJSGRwZEdocGJpQmdhV1pGY25KdmNtQWdZVzVrSUdGa1pDQjBhR1VnYjNKcFoybHVZV3dnWlhKeWIzSWdabkpoYldWeklIUnZJSFJvWlNCdVpYZHNlVnh1SUNBZ0lDQWdMeThnWTNKbFlYUmxaQ0J2Ym1WekxseHVJQ0FnSUNBZ2RtRnlJSFJ0Y0RJZ1BTQnZjbWxuVTNSaFkyc3VjM0JzYVhRb0oxeGNiaWNwTzF4dUlDQWdJQ0FnZEcxd01pNXphR2xtZENncE95QXZMeUJHYVd4MFpYSWdZV3hzSUdaeVlXMWxjeUJsZUdsemRHbHVaeUJwYmlCbGNuSXVjM1JoWTJzdVhHNWNiaUFnSUNBZ0lIWmhjaUIwYlhBeElEMGdibVYzUlhKeUxuTjBZV05yTG5Od2JHbDBLQ2RjWEc0bktUdGNibHh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0IwYlhBeUxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0FnSUM4dklFWnBibVFnZEdobElHWnBjbk4wSUc5alkzVnljbVZ1WTJVZ2IyWWdkR2hsSUdaeVlXMWxMbHh1SUNBZ0lDQWdJQ0IyWVhJZ2NHOXpJRDBnZEcxd01TNXBibVJsZUU5bUtIUnRjREpiYVYwcE8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNod2IzTWdJVDA5SUMweEtTQjdYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1QyNXNlU0JyWldWd0lHNWxkeUJtY21GdFpYTXVYRzRnSUNBZ0lDQWdJQ0FnZEcxd01TQTlJSFJ0Y0RFdWMyeHBZMlVvTUN3Z2NHOXpLVHRjYmlBZ0lDQWdJQ0FnSUNCaWNtVmhhenRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCdVpYZEZjbkl1YzNSaFkyc2dQU0JjSWx3aUxtTnZibU5oZENoMGJYQXhMbXB2YVc0b0oxeGNiaWNwTENCY0lseGNibHdpS1M1amIyNWpZWFFvZEcxd01pNXFiMmx1S0NkY1hHNG5LU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdkR2h5YjNjZ2JtVjNSWEp5TzF4dUlDQjlYRzU5T3lBdkx5QkZlSEJ2YzJVZ1lTQnpkSEpwWTNRZ2IyNXNlU0IyWVhKcFlXNTBJRzltSUdGemMyVnlkRnh1WEc1Y2JtWjFibU4wYVc5dUlITjBjbWxqZENncElIdGNiaUFnWm05eUlDaDJZWElnWDJ4bGJqWWdQU0JoY21kMWJXVnVkSE11YkdWdVozUm9MQ0JoY21keklEMGdibVYzSUVGeWNtRjVLRjlzWlc0MktTd2dYMnRsZVRZZ1BTQXdPeUJmYTJWNU5pQThJRjlzWlc0Mk95QmZhMlY1TmlzcktTQjdYRzRnSUNBZ1lYSm5jMXRmYTJWNU5sMGdQU0JoY21kMWJXVnVkSE5iWDJ0bGVUWmRPMXh1SUNCOVhHNWNiaUFnYVc1dVpYSlBheTVoY0hCc2VTaDJiMmxrSURBc0lGdHpkSEpwWTNRc0lHRnlaM011YkdWdVozUm9YUzVqYjI1allYUW9ZWEpuY3lrcE8xeHVmVnh1WEc1aGMzTmxjblF1YzNSeWFXTjBJRDBnYjJKcVpXTjBRWE56YVdkdUtITjBjbWxqZEN3Z1lYTnpaWEowTENCN1hHNGdJR1Z4ZFdGc09pQmhjM05sY25RdWMzUnlhV04wUlhGMVlXd3NYRzRnSUdSbFpYQkZjWFZoYkRvZ1lYTnpaWEowTG1SbFpYQlRkSEpwWTNSRmNYVmhiQ3hjYmlBZ2JtOTBSWEYxWVd3NklHRnpjMlZ5ZEM1dWIzUlRkSEpwWTNSRmNYVmhiQ3hjYmlBZ2JtOTBSR1ZsY0VWeGRXRnNPaUJoYzNObGNuUXVibTkwUkdWbGNGTjBjbWxqZEVWeGRXRnNYRzU5S1R0Y2JtRnpjMlZ5ZEM1emRISnBZM1F1YzNSeWFXTjBJRDBnWVhOelpYSjBMbk4wY21samREc2lMQ0l2THlCRGRYSnlaVzUwYkhrZ2FXNGdjM2x1WXlCM2FYUm9JRTV2WkdVdWFuTWdiR2xpTDJsdWRHVnlibUZzTDJGemMyVnlkQzloYzNObGNuUnBiMjVmWlhKeWIzSXVhbk5jYmk4dklHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOXViMlJsYW5NdmJtOWtaUzlqYjIxdGFYUXZNRGd4TnpnME1HWTNOelV3TXpJeE5qbGtaR1EzTUdNNE5XRmpNRFU1WmpFNFptWmpZemd4WTF4dUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1bWRXNWpkR2x2YmlCZmIySnFaV04wVTNCeVpXRmtLSFJoY21kbGRDa2dleUJtYjNJZ0tIWmhjaUJwSUQwZ01Uc2dhU0E4SUdGeVozVnRaVzUwY3k1c1pXNW5kR2c3SUdrckt5a2dleUIyWVhJZ2MyOTFjbU5sSUQwZ1lYSm5kVzFsYm5SelcybGRJQ0U5SUc1MWJHd2dQeUJoY21kMWJXVnVkSE5iYVYwZ09pQjdmVHNnZG1GeUlHOTNia3RsZVhNZ1BTQlBZbXBsWTNRdWEyVjVjeWh6YjNWeVkyVXBPeUJwWmlBb2RIbHdaVzltSUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNZ1BUMDlJQ2RtZFc1amRHbHZiaWNwSUhzZ2IzZHVTMlY1Y3lBOUlHOTNia3RsZVhNdVkyOXVZMkYwS0U5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNb2MyOTFjbU5sS1M1bWFXeDBaWElvWm5WdVkzUnBiMjRnS0hONWJTa2dleUJ5WlhSMWNtNGdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y2loemIzVnlZMlVzSUhONWJTa3VaVzUxYldWeVlXSnNaVHNnZlNrcE95QjlJRzkzYmt0bGVYTXVabTl5UldGamFDaG1kVzVqZEdsdmJpQW9hMlY1S1NCN0lGOWtaV1pwYm1WUWNtOXdaWEowZVNoMFlYSm5aWFFzSUd0bGVTd2djMjkxY21ObFcydGxlVjBwT3lCOUtUc2dmU0J5WlhSMWNtNGdkR0Z5WjJWME95QjlYRzVjYm1aMWJtTjBhVzl1SUY5a1pXWnBibVZRY205d1pYSjBlU2h2WW1vc0lHdGxlU3dnZG1Gc2RXVXBJSHNnYVdZZ0tHdGxlU0JwYmlCdlltb3BJSHNnVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtHOWlhaXdnYTJWNUxDQjdJSFpoYkhWbE9pQjJZV3gxWlN3Z1pXNTFiV1Z5WVdKc1pUb2dkSEoxWlN3Z1kyOXVabWxuZFhKaFlteGxPaUIwY25WbExDQjNjbWwwWVdKc1pUb2dkSEoxWlNCOUtUc2dmU0JsYkhObElIc2diMkpxVzJ0bGVWMGdQU0IyWVd4MVpUc2dmU0J5WlhSMWNtNGdiMkpxT3lCOVhHNWNibVoxYm1OMGFXOXVJRjlqYkdGemMwTmhiR3hEYUdWamF5aHBibk4wWVc1alpTd2dRMjl1YzNSeWRXTjBiM0lwSUhzZ2FXWWdLQ0VvYVc1emRHRnVZMlVnYVc1emRHRnVZMlZ2WmlCRGIyNXpkSEoxWTNSdmNpa3BJSHNnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2loY0lrTmhibTV2ZENCallXeHNJR0VnWTJ4aGMzTWdZWE1nWVNCbWRXNWpkR2x2Ymx3aUtUc2dmU0I5WEc1Y2JtWjFibU4wYVc5dUlGOWtaV1pwYm1WUWNtOXdaWEowYVdWektIUmhjbWRsZEN3Z2NISnZjSE1wSUhzZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQndjbTl3Y3k1c1pXNW5kR2c3SUdrckt5a2dleUIyWVhJZ1pHVnpZM0pwY0hSdmNpQTlJSEJ5YjNCelcybGRPeUJrWlhOamNtbHdkRzl5TG1WdWRXMWxjbUZpYkdVZ1BTQmtaWE5qY21sd2RHOXlMbVZ1ZFcxbGNtRmliR1VnZkh3Z1ptRnNjMlU3SUdSbGMyTnlhWEIwYjNJdVkyOXVabWxuZFhKaFlteGxJRDBnZEhKMVpUc2dhV1lnS0Z3aWRtRnNkV1ZjSWlCcGJpQmtaWE5qY21sd2RHOXlLU0JrWlhOamNtbHdkRzl5TG5keWFYUmhZbXhsSUQwZ2RISjFaVHNnVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtIUmhjbWRsZEN3Z1pHVnpZM0pwY0hSdmNpNXJaWGtzSUdSbGMyTnlhWEIwYjNJcE95QjlJSDFjYmx4dVpuVnVZM1JwYjI0Z1gyTnlaV0YwWlVOc1lYTnpLRU52Ym5OMGNuVmpkRzl5TENCd2NtOTBiMUJ5YjNCekxDQnpkR0YwYVdOUWNtOXdjeWtnZXlCcFppQW9jSEp2ZEc5UWNtOXdjeWtnWDJSbFptbHVaVkJ5YjNCbGNuUnBaWE1vUTI5dWMzUnlkV04wYjNJdWNISnZkRzkwZVhCbExDQndjbTkwYjFCeWIzQnpLVHNnYVdZZ0tITjBZWFJwWTFCeWIzQnpLU0JmWkdWbWFXNWxVSEp2Y0dWeWRHbGxjeWhEYjI1emRISjFZM1J2Y2l3Z2MzUmhkR2xqVUhKdmNITXBPeUJ5WlhSMWNtNGdRMjl1YzNSeWRXTjBiM0k3SUgxY2JseHVablZ1WTNScGIyNGdYM0J2YzNOcFlteGxRMjl1YzNSeWRXTjBiM0pTWlhSMWNtNG9jMlZzWml3Z1kyRnNiQ2tnZXlCcFppQW9ZMkZzYkNBbUppQW9YM1I1Y0dWdlppaGpZV3hzS1NBOVBUMGdYQ0p2WW1wbFkzUmNJaUI4ZkNCMGVYQmxiMllnWTJGc2JDQTlQVDBnWENKbWRXNWpkR2x2Ymx3aUtTa2dleUJ5WlhSMWNtNGdZMkZzYkRzZ2ZTQnlaWFIxY200Z1gyRnpjMlZ5ZEZSb2FYTkpibWwwYVdGc2FYcGxaQ2h6Wld4bUtUc2dmVnh1WEc1bWRXNWpkR2x2YmlCZllYTnpaWEowVkdocGMwbHVhWFJwWVd4cGVtVmtLSE5sYkdZcElIc2dhV1lnS0hObGJHWWdQVDA5SUhadmFXUWdNQ2tnZXlCMGFISnZkeUJ1WlhjZ1VtVm1aWEpsYm1ObFJYSnliM0lvWENKMGFHbHpJR2hoYzI0bmRDQmlaV1Z1SUdsdWFYUnBZV3hwYzJWa0lDMGdjM1Z3WlhJb0tTQm9ZWE51SjNRZ1ltVmxiaUJqWVd4c1pXUmNJaWs3SUgwZ2NtVjBkWEp1SUhObGJHWTdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gybHVhR1Z5YVhSektITjFZa05zWVhOekxDQnpkWEJsY2tOc1lYTnpLU0I3SUdsbUlDaDBlWEJsYjJZZ2MzVndaWEpEYkdGemN5QWhQVDBnWENKbWRXNWpkR2x2Ymx3aUlDWW1JSE4xY0dWeVEyeGhjM01nSVQwOUlHNTFiR3dwSUhzZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpaGNJbE4xY0dWeUlHVjRjSEpsYzNOcGIyNGdiWFZ6ZENCbGFYUm9aWElnWW1VZ2JuVnNiQ0J2Y2lCaElHWjFibU4wYVc5dVhDSXBPeUI5SUhOMVlrTnNZWE56TG5CeWIzUnZkSGx3WlNBOUlFOWlhbVZqZEM1amNtVmhkR1VvYzNWd1pYSkRiR0Z6Y3lBbUppQnpkWEJsY2tOc1lYTnpMbkJ5YjNSdmRIbHdaU3dnZXlCamIyNXpkSEoxWTNSdmNqb2dleUIyWVd4MVpUb2djM1ZpUTJ4aGMzTXNJSGR5YVhSaFlteGxPaUIwY25WbExDQmpiMjVtYVdkMWNtRmliR1U2SUhSeWRXVWdmU0I5S1RzZ2FXWWdLSE4xY0dWeVEyeGhjM01wSUY5elpYUlFjbTkwYjNSNWNHVlBaaWh6ZFdKRGJHRnpjeXdnYzNWd1pYSkRiR0Z6Y3lrN0lIMWNibHh1Wm5WdVkzUnBiMjRnWDNkeVlYQk9ZWFJwZG1WVGRYQmxjaWhEYkdGemN5a2dleUIyWVhJZ1gyTmhZMmhsSUQwZ2RIbHdaVzltSUUxaGNDQTlQVDBnWENKbWRXNWpkR2x2Ymx3aUlEOGdibVYzSUUxaGNDZ3BJRG9nZFc1a1pXWnBibVZrT3lCZmQzSmhjRTVoZEdsMlpWTjFjR1Z5SUQwZ1puVnVZM1JwYjI0Z1gzZHlZWEJPWVhScGRtVlRkWEJsY2loRGJHRnpjeWtnZXlCcFppQW9RMnhoYzNNZ1BUMDlJRzUxYkd3Z2ZId2dJVjlwYzA1aGRHbDJaVVoxYm1OMGFXOXVLRU5zWVhOektTa2djbVYwZFhKdUlFTnNZWE56T3lCcFppQW9kSGx3Wlc5bUlFTnNZWE56SUNFOVBTQmNJbVoxYm1OMGFXOXVYQ0lwSUhzZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpaGNJbE4xY0dWeUlHVjRjSEpsYzNOcGIyNGdiWFZ6ZENCbGFYUm9aWElnWW1VZ2JuVnNiQ0J2Y2lCaElHWjFibU4wYVc5dVhDSXBPeUI5SUdsbUlDaDBlWEJsYjJZZ1gyTmhZMmhsSUNFOVBTQmNJblZ1WkdWbWFXNWxaRndpS1NCN0lHbG1JQ2hmWTJGamFHVXVhR0Z6S0VOc1lYTnpLU2tnY21WMGRYSnVJRjlqWVdOb1pTNW5aWFFvUTJ4aGMzTXBPeUJmWTJGamFHVXVjMlYwS0VOc1lYTnpMQ0JYY21Gd2NHVnlLVHNnZlNCbWRXNWpkR2x2YmlCWGNtRndjR1Z5S0NrZ2V5QnlaWFIxY200Z1gyTnZibk4wY25WamRDaERiR0Z6Y3l3Z1lYSm5kVzFsYm5SekxDQmZaMlYwVUhKdmRHOTBlWEJsVDJZb2RHaHBjeWt1WTI5dWMzUnlkV04wYjNJcE95QjlJRmR5WVhCd1pYSXVjSEp2ZEc5MGVYQmxJRDBnVDJKcVpXTjBMbU55WldGMFpTaERiR0Z6Y3k1d2NtOTBiM1I1Y0dVc0lIc2dZMjl1YzNSeWRXTjBiM0k2SUhzZ2RtRnNkV1U2SUZkeVlYQndaWElzSUdWdWRXMWxjbUZpYkdVNklHWmhiSE5sTENCM2NtbDBZV0pzWlRvZ2RISjFaU3dnWTI5dVptbG5kWEpoWW14bE9pQjBjblZsSUgwZ2ZTazdJSEpsZEhWeWJpQmZjMlYwVUhKdmRHOTBlWEJsVDJZb1YzSmhjSEJsY2l3Z1EyeGhjM01wT3lCOU95QnlaWFIxY200Z1gzZHlZWEJPWVhScGRtVlRkWEJsY2loRGJHRnpjeWs3SUgxY2JseHVablZ1WTNScGIyNGdhWE5PWVhScGRtVlNaV1pzWldOMFEyOXVjM1J5ZFdOMEtDa2dleUJwWmlBb2RIbHdaVzltSUZKbFpteGxZM1FnUFQwOUlGd2lkVzVrWldacGJtVmtYQ0lnZkh3Z0lWSmxabXhsWTNRdVkyOXVjM1J5ZFdOMEtTQnlaWFIxY200Z1ptRnNjMlU3SUdsbUlDaFNaV1pzWldOMExtTnZibk4wY25WamRDNXphR0Z0S1NCeVpYUjFjbTRnWm1Gc2MyVTdJR2xtSUNoMGVYQmxiMllnVUhKdmVIa2dQVDA5SUZ3aVpuVnVZM1JwYjI1Y0lpa2djbVYwZFhKdUlIUnlkV1U3SUhSeWVTQjdJRVJoZEdVdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bkxtTmhiR3dvVW1WbWJHVmpkQzVqYjI1emRISjFZM1FvUkdGMFpTd2dXMTBzSUdaMWJtTjBhVzl1SUNncElIdDlLU2s3SUhKbGRIVnliaUIwY25WbE95QjlJR05oZEdOb0lDaGxLU0I3SUhKbGRIVnliaUJtWVd4elpUc2dmU0I5WEc1Y2JtWjFibU4wYVc5dUlGOWpiMjV6ZEhKMVkzUW9VR0Z5Wlc1MExDQmhjbWR6TENCRGJHRnpjeWtnZXlCcFppQW9hWE5PWVhScGRtVlNaV1pzWldOMFEyOXVjM1J5ZFdOMEtDa3BJSHNnWDJOdmJuTjBjblZqZENBOUlGSmxabXhsWTNRdVkyOXVjM1J5ZFdOME95QjlJR1ZzYzJVZ2V5QmZZMjl1YzNSeWRXTjBJRDBnWm5WdVkzUnBiMjRnWDJOdmJuTjBjblZqZENoUVlYSmxiblFzSUdGeVozTXNJRU5zWVhOektTQjdJSFpoY2lCaElEMGdXMjUxYkd4ZE95QmhMbkIxYzJndVlYQndiSGtvWVN3Z1lYSm5jeWs3SUhaaGNpQkRiMjV6ZEhKMVkzUnZjaUE5SUVaMWJtTjBhVzl1TG1KcGJtUXVZWEJ3Ykhrb1VHRnlaVzUwTENCaEtUc2dkbUZ5SUdsdWMzUmhibU5sSUQwZ2JtVjNJRU52Ym5OMGNuVmpkRzl5S0NrN0lHbG1JQ2hEYkdGemN5a2dYM05sZEZCeWIzUnZkSGx3WlU5bUtHbHVjM1JoYm1ObExDQkRiR0Z6Y3k1d2NtOTBiM1I1Y0dVcE95QnlaWFIxY200Z2FXNXpkR0Z1WTJVN0lIMDdJSDBnY21WMGRYSnVJRjlqYjI1emRISjFZM1F1WVhCd2JIa29iblZzYkN3Z1lYSm5kVzFsYm5SektUc2dmVnh1WEc1bWRXNWpkR2x2YmlCZmFYTk9ZWFJwZG1WR2RXNWpkR2x2YmlobWJpa2dleUJ5WlhSMWNtNGdSblZ1WTNScGIyNHVkRzlUZEhKcGJtY3VZMkZzYkNobWJpa3VhVzVrWlhoUFppaGNJbHR1WVhScGRtVWdZMjlrWlYxY0lpa2dJVDA5SUMweE95QjlYRzVjYm1aMWJtTjBhVzl1SUY5elpYUlFjbTkwYjNSNWNHVlBaaWh2TENCd0tTQjdJRjl6WlhSUWNtOTBiM1I1Y0dWUFppQTlJRTlpYW1WamRDNXpaWFJRY205MGIzUjVjR1ZQWmlCOGZDQm1kVzVqZEdsdmJpQmZjMlYwVUhKdmRHOTBlWEJsVDJZb2J5d2djQ2tnZXlCdkxsOWZjSEp2ZEc5Zlh5QTlJSEE3SUhKbGRIVnliaUJ2T3lCOU95QnlaWFIxY200Z1gzTmxkRkJ5YjNSdmRIbHdaVTltS0c4c0lIQXBPeUI5WEc1Y2JtWjFibU4wYVc5dUlGOW5aWFJRY205MGIzUjVjR1ZQWmlodktTQjdJRjluWlhSUWNtOTBiM1I1Y0dWUFppQTlJRTlpYW1WamRDNXpaWFJRY205MGIzUjVjR1ZQWmlBL0lFOWlhbVZqZEM1blpYUlFjbTkwYjNSNWNHVlBaaUE2SUdaMWJtTjBhVzl1SUY5blpYUlFjbTkwYjNSNWNHVlBaaWh2S1NCN0lISmxkSFZ5YmlCdkxsOWZjSEp2ZEc5Zlh5QjhmQ0JQWW1wbFkzUXVaMlYwVUhKdmRHOTBlWEJsVDJZb2J5azdJSDA3SUhKbGRIVnliaUJmWjJWMFVISnZkRzkwZVhCbFQyWW9ieWs3SUgxY2JseHVablZ1WTNScGIyNGdYM1I1Y0dWdlppaHZZbW9wSUhzZ2FXWWdLSFI1Y0dWdlppQlRlVzFpYjJ3Z1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQjBlWEJsYjJZZ1UzbHRZbTlzTG1sMFpYSmhkRzl5SUQwOVBTQmNJbk41YldKdmJGd2lLU0I3SUY5MGVYQmxiMllnUFNCbWRXNWpkR2x2YmlCZmRIbHdaVzltS0c5aWFpa2dleUJ5WlhSMWNtNGdkSGx3Wlc5bUlHOWlhanNnZlRzZ2ZTQmxiSE5sSUhzZ1gzUjVjR1Z2WmlBOUlHWjFibU4wYVc5dUlGOTBlWEJsYjJZb2IySnFLU0I3SUhKbGRIVnliaUJ2WW1vZ0ppWWdkSGx3Wlc5bUlGTjViV0p2YkNBOVBUMGdYQ0ptZFc1amRHbHZibHdpSUNZbUlHOWlhaTVqYjI1emRISjFZM1J2Y2lBOVBUMGdVM2x0WW05c0lDWW1JRzlpYWlBaFBUMGdVM2x0WW05c0xuQnliM1J2ZEhsd1pTQS9JRndpYzNsdFltOXNYQ0lnT2lCMGVYQmxiMllnYjJKcU95QjlPeUI5SUhKbGRIVnliaUJmZEhsd1pXOW1LRzlpYWlrN0lIMWNibHh1ZG1GeUlGOXlaWEYxYVhKbElEMGdjbVZ4ZFdseVpTZ25kWFJwYkM4bktTeGNiaUFnSUNCcGJuTndaV04wSUQwZ1gzSmxjWFZwY21VdWFXNXpjR1ZqZER0Y2JseHVkbUZ5SUY5eVpYRjFhWEpsTWlBOUlISmxjWFZwY21Vb0p5NHVMMlZ5Y205eWN5Y3BMRnh1SUNBZ0lFVlNVbDlKVGxaQlRFbEVYMEZTUjE5VVdWQkZJRDBnWDNKbGNYVnBjbVV5TG1OdlpHVnpMa1ZTVWw5SlRsWkJURWxFWDBGU1IxOVVXVkJGT3lBdkx5Qm9kSFJ3Y3pvdkwyUmxkbVZzYjNCbGNpNXRiM3BwYkd4aExtOXlaeTlsYmkxVlV5OWtiMk56TDFkbFlpOUtZWFpoVTJOeWFYQjBMMUpsWm1WeVpXNWpaUzlIYkc5aVlXeGZUMkpxWldOMGN5OVRkSEpwYm1jdlpXNWtjMWRwZEdoY2JseHVYRzVtZFc1amRHbHZiaUJsYm1SelYybDBhQ2h6ZEhJc0lITmxZWEpqYUN3Z2RHaHBjMTlzWlc0cElIdGNiaUFnYVdZZ0tIUm9hWE5mYkdWdUlEMDlQU0IxYm1SbFptbHVaV1FnZkh3Z2RHaHBjMTlzWlc0Z1BpQnpkSEl1YkdWdVozUm9LU0I3WEc0Z0lDQWdkR2hwYzE5c1pXNGdQU0J6ZEhJdWJHVnVaM1JvTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhOMGNpNXpkV0p6ZEhKcGJtY29kR2hwYzE5c1pXNGdMU0J6WldGeVkyZ3ViR1Z1WjNSb0xDQjBhR2x6WDJ4bGJpa2dQVDA5SUhObFlYSmphRHRjYm4wZ0x5OGdhSFIwY0hNNkx5OWtaWFpsYkc5d1pYSXViVzk2YVd4c1lTNXZjbWN2Wlc0dFZWTXZaRzlqY3k5WFpXSXZTbUYyWVZOamNtbHdkQzlTWldabGNtVnVZMlV2UjJ4dlltRnNYMDlpYW1WamRITXZVM1J5YVc1bkwzSmxjR1ZoZEZ4dVhHNWNibVoxYm1OMGFXOXVJSEpsY0dWaGRDaHpkSElzSUdOdmRXNTBLU0I3WEc0Z0lHTnZkVzUwSUQwZ1RXRjBhQzVtYkc5dmNpaGpiM1Z1ZENrN1hHNGdJR2xtSUNoemRISXViR1Z1WjNSb0lEMDlJREFnZkh3Z1kyOTFiblFnUFQwZ01Da2djbVYwZFhKdUlDY25PMXh1SUNCMllYSWdiV0Y0UTI5MWJuUWdQU0J6ZEhJdWJHVnVaM1JvSUNvZ1kyOTFiblE3WEc0Z0lHTnZkVzUwSUQwZ1RXRjBhQzVtYkc5dmNpaE5ZWFJvTG14dlp5aGpiM1Z1ZENrZ0x5Qk5ZWFJvTG14dlp5Z3lLU2s3WEc1Y2JpQWdkMmhwYkdVZ0tHTnZkVzUwS1NCN1hHNGdJQ0FnYzNSeUlDczlJSE4wY2p0Y2JpQWdJQ0JqYjNWdWRDMHRPMXh1SUNCOVhHNWNiaUFnYzNSeUlDczlJSE4wY2k1emRXSnpkSEpwYm1jb01Dd2diV0Y0UTI5MWJuUWdMU0J6ZEhJdWJHVnVaM1JvS1R0Y2JpQWdjbVYwZFhKdUlITjBjanRjYm4xY2JseHVkbUZ5SUdKc2RXVWdQU0FuSnp0Y2JuWmhjaUJuY21WbGJpQTlJQ2NuTzF4dWRtRnlJSEpsWkNBOUlDY25PMXh1ZG1GeUlIZG9hWFJsSUQwZ0p5YzdYRzUyWVhJZ2ExSmxZV1JoWW14bFQzQmxjbUYwYjNJZ1BTQjdYRzRnSUdSbFpYQlRkSEpwWTNSRmNYVmhiRG9nSjBWNGNHVmpkR1ZrSUhaaGJIVmxjeUIwYnlCaVpTQnpkSEpwWTNSc2VTQmtaV1Z3TFdWeGRXRnNPaWNzWEc0Z0lITjBjbWxqZEVWeGRXRnNPaUFuUlhod1pXTjBaV1FnZG1Gc2RXVnpJSFJ2SUdKbElITjBjbWxqZEd4NUlHVnhkV0ZzT2ljc1hHNGdJSE4wY21samRFVnhkV0ZzVDJKcVpXTjBPaUFuUlhod1pXTjBaV1FnWENKaFkzUjFZV3hjSWlCMGJ5QmlaU0J5WldabGNtVnVZMlV0WlhGMVlXd2dkRzhnWENKbGVIQmxZM1JsWkZ3aU9pY3NYRzRnSUdSbFpYQkZjWFZoYkRvZ0owVjRjR1ZqZEdWa0lIWmhiSFZsY3lCMGJ5QmlaU0JzYjI5elpXeDVJR1JsWlhBdFpYRjFZV3c2Snl4Y2JpQWdaWEYxWVd3NklDZEZlSEJsWTNSbFpDQjJZV3gxWlhNZ2RHOGdZbVVnYkc5dmMyVnNlU0JsY1hWaGJEb25MRnh1SUNCdWIzUkVaV1Z3VTNSeWFXTjBSWEYxWVd3NklDZEZlSEJsWTNSbFpDQmNJbUZqZEhWaGJGd2lJRzV2ZENCMGJ5QmlaU0J6ZEhKcFkzUnNlU0JrWldWd0xXVnhkV0ZzSUhSdk9pY3NYRzRnSUc1dmRGTjBjbWxqZEVWeGRXRnNPaUFuUlhod1pXTjBaV1FnWENKaFkzUjFZV3hjSWlCMGJ5QmlaU0J6ZEhKcFkzUnNlU0IxYm1WeGRXRnNJSFJ2T2ljc1hHNGdJRzV2ZEZOMGNtbGpkRVZ4ZFdGc1QySnFaV04wT2lBblJYaHdaV04wWldRZ1hDSmhZM1IxWVd4Y0lpQnViM1FnZEc4Z1ltVWdjbVZtWlhKbGJtTmxMV1Z4ZFdGc0lIUnZJRndpWlhod1pXTjBaV1JjSWpvbkxGeHVJQ0J1YjNSRVpXVndSWEYxWVd3NklDZEZlSEJsWTNSbFpDQmNJbUZqZEhWaGJGd2lJRzV2ZENCMGJ5QmlaU0JzYjI5elpXeDVJR1JsWlhBdFpYRjFZV3dnZEc4Nkp5eGNiaUFnYm05MFJYRjFZV3c2SUNkRmVIQmxZM1JsWkNCY0ltRmpkSFZoYkZ3aUlIUnZJR0psSUd4dmIzTmxiSGtnZFc1bGNYVmhiQ0IwYnpvbkxGeHVJQ0J1YjNSSlpHVnVkR2xqWVd3NklDZFdZV3gxWlhNZ2FXUmxiblJwWTJGc0lHSjFkQ0J1YjNRZ2NtVm1aWEpsYm1ObExXVnhkV0ZzT2lkY2JuMDdJQzh2SUVOdmJYQmhjbWx1WnlCemFHOXlkQ0J3Y21sdGFYUnBkbVZ6SUhOb2IzVnNaQ0JxZFhOMElITm9iM2NnUFQwOUlDOGdJVDA5SUdsdWMzUmxZV1FnYjJZZ2RYTnBibWNnZEdobFhHNHZMeUJrYVdabUxseHVYRzUyWVhJZ2EwMWhlRk5vYjNKMFRHVnVaM1JvSUQwZ01UQTdYRzVjYm1aMWJtTjBhVzl1SUdOdmNIbEZjbkp2Y2loemIzVnlZMlVwSUh0Y2JpQWdkbUZ5SUd0bGVYTWdQU0JQWW1wbFkzUXVhMlY1Y3loemIzVnlZMlVwTzF4dUlDQjJZWElnZEdGeVoyVjBJRDBnVDJKcVpXTjBMbU55WldGMFpTaFBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvYzI5MWNtTmxLU2s3WEc0Z0lHdGxlWE11Wm05eVJXRmphQ2htZFc1amRHbHZiaUFvYTJWNUtTQjdYRzRnSUNBZ2RHRnlaMlYwVzJ0bGVWMGdQU0J6YjNWeVkyVmJhMlY1WFR0Y2JpQWdmU2s3WEc0Z0lFOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBlU2gwWVhKblpYUXNJQ2R0WlhOellXZGxKeXdnZTF4dUlDQWdJSFpoYkhWbE9pQnpiM1Z5WTJVdWJXVnpjMkZuWlZ4dUlDQjlLVHRjYmlBZ2NtVjBkWEp1SUhSaGNtZGxkRHRjYm4xY2JseHVablZ1WTNScGIyNGdhVzV6Y0dWamRGWmhiSFZsS0haaGJDa2dlMXh1SUNBdkx5QlVhR1VnZFhScGJDNXBibk53WldOMElHUmxabUYxYkhRZ2RtRnNkV1Z6SUdOdmRXeGtJR0psSUdOb1lXNW5aV1F1SUZSb2FYTWdiV0ZyWlhNZ2MzVnlaU0IwYUdWY2JpQWdMeThnWlhKeWIzSWdiV1Z6YzJGblpYTWdZMjl1ZEdGcGJpQjBhR1VnYm1WalpYTnpZWEo1SUdsdVptOXliV0YwYVc5dUlHNWxkbVZ5ZEdobGJHVnpjeTVjYmlBZ2NtVjBkWEp1SUdsdWMzQmxZM1FvZG1Gc0xDQjdYRzRnSUNBZ1kyOXRjR0ZqZERvZ1ptRnNjMlVzWEc0Z0lDQWdZM1Z6ZEc5dFNXNXpjR1ZqZERvZ1ptRnNjMlVzWEc0Z0lDQWdaR1Z3ZEdnNklERXdNREFzWEc0Z0lDQWdiV0Y0UVhKeVlYbE1aVzVuZEdnNklFbHVabWx1YVhSNUxGeHVJQ0FnSUM4dklFRnpjMlZ5ZENCamIyMXdZWEpsY3lCdmJteDVJR1Z1ZFcxbGNtRmliR1VnY0hKdmNHVnlkR2xsY3lBb2QybDBhQ0JoSUdabGR5QmxlR05sY0hScGIyNXpLUzVjYmlBZ0lDQnphRzkzU0dsa1pHVnVPaUJtWVd4elpTeGNiaUFnSUNBdkx5QklZWFpwYm1jZ1lTQnNiMjVuSUd4cGJtVWdZWE1nWlhKeWIzSWdhWE1nWW1WMGRHVnlJSFJvWVc0Z2QzSmhjSEJwYm1jZ2RHaGxJR3hwYm1VZ1ptOXlYRzRnSUNBZ0x5OGdZMjl0Y0dGeWFYTnZiaUJtYjNJZ2JtOTNMbHh1SUNBZ0lDOHZJRlJQUkU4b1FuSnBaR2RsUVZJcE9pQmdZbkpsWVd0TVpXNW5kR2hnSUhOb2IzVnNaQ0JpWlNCc2FXMXBkR1ZrSUdGeklITnZiMjRnWVhNZ2MyOXZiaUJoY3lCM1pWeHVJQ0FnSUM4dklHaGhkbVVnYldWMFlTQnBibVp2Y20xaGRHbHZiaUJoWW05MWRDQjBhR1VnYVc1emNHVmpkR1ZrSUhCeWIzQmxjblJwWlhNZ0tHa3VaUzRzSUd0dWIzY2dkMmhsY21WY2JpQWdJQ0F2THlCcGJpQjNhR0YwSUd4cGJtVWdkR2hsSUhCeWIzQmxjblI1SUhOMFlYSjBjeUJoYm1RZ1pXNWtjeWt1WEc0Z0lDQWdZbkpsWVd0TVpXNW5kR2c2SUVsdVptbHVhWFI1TEZ4dUlDQWdJQzh2SUVGemMyVnlkQ0JrYjJWeklHNXZkQ0JrWlhSbFkzUWdjSEp2ZUdsbGN5QmpkWEp5Wlc1MGJIa3VYRzRnSUNBZ2MyaHZkMUJ5YjNoNU9pQm1ZV3h6WlN4Y2JpQWdJQ0J6YjNKMFpXUTZJSFJ5ZFdVc1hHNGdJQ0FnTHk4Z1NXNXpjR1ZqZENCblpYUjBaWEp6SUdGeklIZGxJR0ZzYzI4Z1kyaGxZMnNnZEdobGJTQjNhR1Z1SUdOdmJYQmhjbWx1WnlCbGJuUnlhV1Z6TGx4dUlDQWdJR2RsZEhSbGNuTTZJSFJ5ZFdWY2JpQWdmU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJR055WldGMFpVVnlja1JwWm1Zb1lXTjBkV0ZzTENCbGVIQmxZM1JsWkN3Z2IzQmxjbUYwYjNJcElIdGNiaUFnZG1GeUlHOTBhR1Z5SUQwZ0p5YzdYRzRnSUhaaGNpQnlaWE1nUFNBbkp6dGNiaUFnZG1GeUlHeGhjM1JRYjNNZ1BTQXdPMXh1SUNCMllYSWdaVzVrSUQwZ0p5YzdYRzRnSUhaaGNpQnphMmx3Y0dWa0lEMGdabUZzYzJVN1hHNGdJSFpoY2lCaFkzUjFZV3hKYm5Od1pXTjBaV1FnUFNCcGJuTndaV04wVm1Gc2RXVW9ZV04wZFdGc0tUdGNiaUFnZG1GeUlHRmpkSFZoYkV4cGJtVnpJRDBnWVdOMGRXRnNTVzV6Y0dWamRHVmtMbk53YkdsMEtDZGNYRzRuS1R0Y2JpQWdkbUZ5SUdWNGNHVmpkR1ZrVEdsdVpYTWdQU0JwYm5Od1pXTjBWbUZzZFdVb1pYaHdaV04wWldRcExuTndiR2wwS0NkY1hHNG5LVHRjYmlBZ2RtRnlJR2tnUFNBd08xeHVJQ0IyWVhJZ2FXNWthV05oZEc5eUlEMGdKeWM3SUM4dklFbHVJR05oYzJVZ1ltOTBhQ0IyWVd4MVpYTWdZWEpsSUc5aWFtVmpkSE1nWlhod2JHbGphWFJzZVNCdFlYSnJJSFJvWlcwZ1lYTWdibTkwSUhKbFptVnlaVzVqWlNCbGNYVmhiRnh1SUNBdkx5Qm1iM0lnZEdobElHQnpkSEpwWTNSRmNYVmhiR0FnYjNCbGNtRjBiM0l1WEc1Y2JpQWdhV1lnS0c5d1pYSmhkRzl5SUQwOVBTQW5jM1J5YVdOMFJYRjFZV3duSUNZbUlGOTBlWEJsYjJZb1lXTjBkV0ZzS1NBOVBUMGdKMjlpYW1WamRDY2dKaVlnWDNSNWNHVnZaaWhsZUhCbFkzUmxaQ2tnUFQwOUlDZHZZbXBsWTNRbklDWW1JR0ZqZEhWaGJDQWhQVDBnYm5Wc2JDQW1KaUJsZUhCbFkzUmxaQ0FoUFQwZ2JuVnNiQ2tnZTF4dUlDQWdJRzl3WlhKaGRHOXlJRDBnSjNOMGNtbGpkRVZ4ZFdGc1QySnFaV04wSnp0Y2JpQWdmU0F2THlCSlppQmNJbUZqZEhWaGJGd2lJR0Z1WkNCY0ltVjRjR1ZqZEdWa1hDSWdabWwwSUc5dUlHRWdjMmx1WjJ4bElHeHBibVVnWVc1a0lIUm9aWGtnWVhKbElHNXZkQ0J6ZEhKcFkzUnNlVnh1SUNBdkx5QmxjWFZoYkN3Z1kyaGxZMnNnWm5WeWRHaGxjaUJ6Y0dWamFXRnNJR2hoYm1Sc2FXNW5MbHh1WEc1Y2JpQWdhV1lnS0dGamRIVmhiRXhwYm1WekxteGxibWQwYUNBOVBUMGdNU0FtSmlCbGVIQmxZM1JsWkV4cGJtVnpMbXhsYm1kMGFDQTlQVDBnTVNBbUppQmhZM1IxWVd4TWFXNWxjMXN3WFNBaFBUMGdaWGh3WldOMFpXUk1hVzVsYzFzd1hTa2dlMXh1SUNBZ0lIWmhjaUJwYm5CMWRFeGxibWQwYUNBOUlHRmpkSFZoYkV4cGJtVnpXekJkTG14bGJtZDBhQ0FySUdWNGNHVmpkR1ZrVEdsdVpYTmJNRjB1YkdWdVozUm9PeUF2THlCSlppQjBhR1VnWTJoaGNtRmpkR1Z5SUd4bGJtZDBhQ0J2WmlCY0ltRmpkSFZoYkZ3aUlHRnVaQ0JjSW1WNGNHVmpkR1ZrWENJZ2RHOW5aWFJvWlhJZ2FYTWdiR1Z6Y3lCMGFHRnVYRzRnSUNBZ0x5OGdhMDFoZUZOb2IzSjBUR1Z1WjNSb0lHRnVaQ0JwWmlCdVpXbDBhR1Z5SUdseklHRnVJRzlpYW1WamRDQmhibVFnWVhRZ2JHVmhjM1FnYjI1bElHOW1JSFJvWlcwZ2FYTmNiaUFnSUNBdkx5QnViM1FnWUhwbGNtOWdMQ0IxYzJVZ2RHaGxJSE4wY21samRDQmxjWFZoYkNCamIyMXdZWEpwYzI5dUlIUnZJSFpwYzNWaGJHbDZaU0IwYUdVZ2IzVjBjSFYwTGx4dVhHNGdJQ0FnYVdZZ0tHbHVjSFYwVEdWdVozUm9JRHc5SUd0TllYaFRhRzl5ZEV4bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tDaGZkSGx3Wlc5bUtHRmpkSFZoYkNrZ0lUMDlJQ2R2WW1wbFkzUW5JSHg4SUdGamRIVmhiQ0E5UFQwZ2JuVnNiQ2tnSmlZZ0tGOTBlWEJsYjJZb1pYaHdaV04wWldRcElDRTlQU0FuYjJKcVpXTjBKeUI4ZkNCbGVIQmxZM1JsWkNBOVBUMGdiblZzYkNrZ0ppWWdLR0ZqZEhWaGJDQWhQVDBnTUNCOGZDQmxlSEJsWTNSbFpDQWhQVDBnTUNrcElIdGNiaUFnSUNBZ0lDQWdMeThnTFRBZ1BUMDlJQ3N3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJjSWx3aUxtTnZibU5oZENoclVtVmhaR0ZpYkdWUGNHVnlZWFJ2Y2x0dmNHVnlZWFJ2Y2wwc0lGd2lYRnh1WEZ4dVhDSXBJQ3NnWENKY0lpNWpiMjVqWVhRb1lXTjBkV0ZzVEdsdVpYTmJNRjBzSUZ3aUlDRTlQU0JjSWlrdVkyOXVZMkYwS0dWNGNHVmpkR1ZrVEdsdVpYTmJNRjBzSUZ3aVhGeHVYQ0lwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQnBaaUFvYjNCbGNtRjBiM0lnSVQwOUlDZHpkSEpwWTNSRmNYVmhiRTlpYW1WamRDY3BJSHRjYmlBZ0lDQWdJQzh2SUVsbUlIUm9aU0J6ZEdSbGNuSWdhWE1nWVNCMGRIa2dZVzVrSUhSb1pTQnBibkIxZENCc1pXNW5kR2dnYVhNZ2JHOTNaWElnZEdoaGJpQjBhR1VnWTNWeWNtVnVkRnh1SUNBZ0lDQWdMeThnWTI5c2RXMXVjeUJ3WlhJZ2JHbHVaU3dnWVdSa0lHRWdiV2x6YldGMFkyZ2dhVzVrYVdOaGRHOXlJR0psYkc5M0lIUm9aU0J2ZFhSd2RYUXVJRWxtSUdsMElHbHpYRzRnSUNBZ0lDQXZMeUJ1YjNRZ1lTQjBkSGtzSUhWelpTQmhJR1JsWm1GMWJIUWdkbUZzZFdVZ2IyWWdPREFnWTJoaGNtRmpkR1Z5Y3k1Y2JpQWdJQ0FnSUhaaGNpQnRZWGhNWlc1bmRHZ2dQU0J3Y205alpYTnpMbk4wWkdWeWNpQW1KaUJ3Y205alpYTnpMbk4wWkdWeWNpNXBjMVJVV1NBL0lIQnliMk5sYzNNdWMzUmtaWEp5TG1OdmJIVnRibk1nT2lBNE1EdGNibHh1SUNBZ0lDQWdhV1lnS0dsdWNIVjBUR1Z1WjNSb0lEd2diV0Y0VEdWdVozUm9LU0I3WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2hoWTNSMVlXeE1hVzVsYzFzd1hWdHBYU0E5UFQwZ1pYaHdaV04wWldSTWFXNWxjMXN3WFZ0cFhTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdrckt6dGNiaUFnSUNBZ0lDQWdmU0F2THlCSloyNXZjbVVnZEdobElHWnBjbk4wSUdOb1lYSmhZM1JsY25NdVhHNWNibHh1SUNBZ0lDQWdJQ0JwWmlBb2FTQStJRElwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJCWkdRZ2NHOXphWFJwYjI0Z2FXNWthV05oZEc5eUlHWnZjaUIwYUdVZ1ptbHljM1FnYldsemJXRjBZMmdnYVc0Z1kyRnpaU0JwZENCcGN5QmhYRzRnSUNBZ0lDQWdJQ0FnTHk4Z2MybHVaMnhsSUd4cGJtVWdZVzVrSUhSb1pTQnBibkIxZENCc1pXNW5kR2dnYVhNZ2JHVnpjeUIwYUdGdUlIUm9aU0JqYjJ4MWJXNGdiR1Z1WjNSb0xseHVJQ0FnSUNBZ0lDQWdJR2x1WkdsallYUnZjaUE5SUZ3aVhGeHVJQ0JjSWk1amIyNWpZWFFvY21Wd1pXRjBLQ2NnSnl3Z2FTa3NJRndpWGx3aUtUdGNiaUFnSUNBZ0lDQWdJQ0JwSUQwZ01EdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlNBdkx5QlNaVzF2ZG1VZ1lXeHNJR1Z1WkdsdVp5QnNhVzVsY3lCMGFHRjBJRzFoZEdOb0lDaDBhR2x6SUc5d2RHbHRhWHBsY3lCMGFHVWdiM1YwY0hWMElHWnZjbHh1SUNBdkx5QnlaV0ZrWVdKcGJHbDBlU0JpZVNCeVpXUjFZMmx1WnlCMGFHVWdiblZ0WW1WeUlHOW1JSFJ2ZEdGc0lHTm9ZVzVuWldRZ2JHbHVaWE1wTGx4dVhHNWNiaUFnZG1GeUlHRWdQU0JoWTNSMVlXeE1hVzVsYzF0aFkzUjFZV3hNYVc1bGN5NXNaVzVuZEdnZ0xTQXhYVHRjYmlBZ2RtRnlJR0lnUFNCbGVIQmxZM1JsWkV4cGJtVnpXMlY0Y0dWamRHVmtUR2x1WlhNdWJHVnVaM1JvSUMwZ01WMDdYRzVjYmlBZ2QyaHBiR1VnS0dFZ1BUMDlJR0lwSUh0Y2JpQWdJQ0JwWmlBb2FTc3JJRHdnTWlrZ2UxeHVJQ0FnSUNBZ1pXNWtJRDBnWENKY1hHNGdJRndpTG1OdmJtTmhkQ2hoS1M1amIyNWpZWFFvWlc1a0tUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnYjNSb1pYSWdQU0JoTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0ZqZEhWaGJFeHBibVZ6TG5CdmNDZ3BPMXh1SUNBZ0lHVjRjR1ZqZEdWa1RHbHVaWE11Y0c5d0tDazdYRzRnSUNBZ2FXWWdLR0ZqZEhWaGJFeHBibVZ6TG14bGJtZDBhQ0E5UFQwZ01DQjhmQ0JsZUhCbFkzUmxaRXhwYm1WekxteGxibWQwYUNBOVBUMGdNQ2tnWW5KbFlXczdYRzRnSUNBZ1lTQTlJR0ZqZEhWaGJFeHBibVZ6VzJGamRIVmhiRXhwYm1WekxteGxibWQwYUNBdElERmRPMXh1SUNBZ0lHSWdQU0JsZUhCbFkzUmxaRXhwYm1WelcyVjRjR1ZqZEdWa1RHbHVaWE11YkdWdVozUm9JQzBnTVYwN1hHNGdJSDFjYmx4dUlDQjJZWElnYldGNFRHbHVaWE1nUFNCTllYUm9MbTFoZUNoaFkzUjFZV3hNYVc1bGN5NXNaVzVuZEdnc0lHVjRjR1ZqZEdWa1RHbHVaWE11YkdWdVozUm9LVHNnTHk4Z1UzUnlhV04wSUdWeGRXRnNJSGRwZEdnZ2FXUmxiblJwWTJGc0lHOWlhbVZqZEhNZ2RHaGhkQ0JoY21VZ2JtOTBJR2xrWlc1MGFXTmhiQ0JpZVNCeVpXWmxjbVZ1WTJVdVhHNGdJQzh2SUVVdVp5NHNJR0Z6YzJWeWRDNWtaV1Z3VTNSeWFXTjBSWEYxWVd3b2V5QmhPaUJUZVcxaWIyd29LU0I5TENCN0lHRTZJRk41YldKdmJDZ3BJSDBwWEc1Y2JpQWdhV1lnS0cxaGVFeHBibVZ6SUQwOVBTQXdLU0I3WEc0Z0lDQWdMeThnVjJVZ2FHRjJaU0IwYnlCblpYUWdkR2hsSUhKbGMzVnNkQ0JoWjJGcGJpNGdWR2hsSUd4cGJtVnpJSGRsY21VZ1lXeHNJSEpsYlc5MlpXUWdZbVZtYjNKbExseHVJQ0FnSUhaaGNpQmZZV04wZFdGc1RHbHVaWE1nUFNCaFkzUjFZV3hKYm5Od1pXTjBaV1F1YzNCc2FYUW9KMXhjYmljcE95QXZMeUJQYm14NUlISmxiVzkyWlNCc2FXNWxjeUJwYmlCallYTmxJR2wwSUcxaGEyVnpJSE5sYm5ObElIUnZJR052Ykd4aGNITmxJSFJvYjNObExseHVJQ0FnSUM4dklGUlBSRTg2SUVGalkyVndkQ0JsYm5ZZ2RHOGdZV3gzWVhseklITm9iM2NnZEdobElHWjFiR3dnWlhKeWIzSXVYRzVjYmx4dUlDQWdJR2xtSUNoZllXTjBkV0ZzVEdsdVpYTXViR1Z1WjNSb0lENGdNekFwSUh0Y2JpQWdJQ0FnSUY5aFkzUjFZV3hNYVc1bGMxc3lObDBnUFNCY0lsd2lMbU52Ym1OaGRDaGliSFZsTENCY0lpNHVMbHdpS1M1amIyNWpZWFFvZDJocGRHVXBPMXh1WEc0Z0lDQWdJQ0IzYUdsc1pTQW9YMkZqZEhWaGJFeHBibVZ6TG14bGJtZDBhQ0ErSURJM0tTQjdYRzRnSUNBZ0lDQWdJRjloWTNSMVlXeE1hVzVsY3k1d2IzQW9LVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWFIxY200Z1hDSmNJaTVqYjI1allYUW9hMUpsWVdSaFlteGxUM0JsY21GMGIzSXVibTkwU1dSbGJuUnBZMkZzTENCY0lseGNibHhjYmx3aUtTNWpiMjVqWVhRb1gyRmpkSFZoYkV4cGJtVnpMbXB2YVc0b0oxeGNiaWNwTENCY0lseGNibHdpS1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2hwSUQ0Z015a2dlMXh1SUNBZ0lHVnVaQ0E5SUZ3aVhGeHVYQ0l1WTI5dVkyRjBLR0pzZFdVc0lGd2lMaTR1WENJcExtTnZibU5oZENoM2FHbDBaU2t1WTI5dVkyRjBLR1Z1WkNrN1hHNGdJQ0FnYzJ0cGNIQmxaQ0E5SUhSeWRXVTdYRzRnSUgxY2JseHVJQ0JwWmlBb2IzUm9aWElnSVQwOUlDY25LU0I3WEc0Z0lDQWdaVzVrSUQwZ1hDSmNYRzRnSUZ3aUxtTnZibU5oZENodmRHaGxjaWt1WTI5dVkyRjBLR1Z1WkNrN1hHNGdJQ0FnYjNSb1pYSWdQU0FuSnp0Y2JpQWdmVnh1WEc0Z0lIWmhjaUJ3Y21sdWRHVmtUR2x1WlhNZ1BTQXdPMXh1SUNCMllYSWdiWE5uSUQwZ2ExSmxZV1JoWW14bFQzQmxjbUYwYjNKYmIzQmxjbUYwYjNKZElDc2dYQ0pjWEc1Y0lpNWpiMjVqWVhRb1ozSmxaVzRzSUZ3aUt5QmhZM1IxWVd4Y0lpa3VZMjl1WTJGMEtIZG9hWFJsTENCY0lpQmNJaWt1WTI5dVkyRjBLSEpsWkN3Z1hDSXRJR1Y0Y0dWamRHVmtYQ0lwTG1OdmJtTmhkQ2gzYUdsMFpTazdYRzRnSUhaaGNpQnphMmx3Y0dWa1RYTm5JRDBnWENJZ1hDSXVZMjl1WTJGMEtHSnNkV1VzSUZ3aUxpNHVYQ0lwTG1OdmJtTmhkQ2gzYUdsMFpTd2dYQ0lnVEdsdVpYTWdjMnRwY0hCbFpGd2lLVHRjYmx4dUlDQm1iM0lnS0drZ1BTQXdPeUJwSUR3Z2JXRjRUR2x1WlhNN0lHa3JLeWtnZTF4dUlDQWdJQzh2SUU5dWJIa2daWGgwY21FZ1pYaHdaV04wWldRZ2JHbHVaWE1nWlhocGMzUmNiaUFnSUNCMllYSWdZM1Z5SUQwZ2FTQXRJR3hoYzNSUWIzTTdYRzVjYmlBZ0lDQnBaaUFvWVdOMGRXRnNUR2x1WlhNdWJHVnVaM1JvSUR3Z2FTQXJJREVwSUh0Y2JpQWdJQ0FnSUM4dklFbG1JSFJvWlNCc1lYTjBJR1JwZG1WeVoybHVaeUJzYVc1bElHbHpJRzF2Y21VZ2RHaGhiaUJ2Ym1VZ2JHbHVaU0JoWW05MlpTQmhibVFnZEdobFhHNGdJQ0FnSUNBdkx5QmpkWEp5Wlc1MElHeHBibVVnYVhNZ1lYUWdiR1ZoYzNRZ2JHbHVaU0IwYUhKbFpTd2dZV1JrSUhOdmJXVWdiMllnZEdobElHWnZjbTFsY2lCc2FXNWxjeUJoYm1SY2JpQWdJQ0FnSUM4dklHRnNjMjhnWVdSa0lHUnZkSE1nZEc4Z2FXNWthV05oZEdVZ2MydHBjSEJsWkNCbGJuUnlhV1Z6TGx4dUlDQWdJQ0FnYVdZZ0tHTjFjaUErSURFZ0ppWWdhU0ErSURJcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0dOMWNpQStJRFFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnlaWE1nS3owZ1hDSmNYRzVjSWk1amIyNWpZWFFvWW14MVpTd2dYQ0l1TGk1Y0lpa3VZMjl1WTJGMEtIZG9hWFJsS1R0Y2JpQWdJQ0FnSUNBZ0lDQnphMmx3Y0dWa0lEMGdkSEoxWlR0Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaGpkWElnUGlBektTQjdYRzRnSUNBZ0lDQWdJQ0FnY21WeklDczlJRndpWEZ4dUlDQmNJaTVqYjI1allYUW9aWGh3WldOMFpXUk1hVzVsYzF0cElDMGdNbDBwTzF4dUlDQWdJQ0FnSUNBZ0lIQnlhVzUwWldSTWFXNWxjeXNyTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdjbVZ6SUNzOUlGd2lYRnh1SUNCY0lpNWpiMjVqWVhRb1pYaHdaV04wWldSTWFXNWxjMXRwSUMwZ01WMHBPMXh1SUNBZ0lDQWdJQ0J3Y21sdWRHVmtUR2x1WlhNckt6dGNiaUFnSUNBZ0lIMGdMeThnVFdGeWF5QjBhR1VnWTNWeWNtVnVkQ0JzYVc1bElHRnpJSFJvWlNCc1lYTjBJR1JwZG1WeVoybHVaeUJ2Ym1VdVhHNWNibHh1SUNBZ0lDQWdiR0Z6ZEZCdmN5QTlJR2s3SUM4dklFRmtaQ0IwYUdVZ1pYaHdaV04wWldRZ2JHbHVaU0IwYnlCMGFHVWdZMkZqYUdVdVhHNWNiaUFnSUNBZ0lHOTBhR1Z5SUNzOUlGd2lYRnh1WENJdVkyOXVZMkYwS0hKbFpDd2dYQ0l0WENJcExtTnZibU5oZENoM2FHbDBaU3dnWENJZ1hDSXBMbU52Ym1OaGRDaGxlSEJsWTNSbFpFeHBibVZ6VzJsZEtUdGNiaUFnSUNBZ0lIQnlhVzUwWldSTWFXNWxjeXNyT3lBdkx5QlBibXg1SUdWNGRISmhJR0ZqZEhWaGJDQnNhVzVsY3lCbGVHbHpkRnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9aWGh3WldOMFpXUk1hVzVsY3k1c1pXNW5kR2dnUENCcElDc2dNU2tnZTF4dUlDQWdJQ0FnTHk4Z1NXWWdkR2hsSUd4aGMzUWdaR2wyWlhKbmFXNW5JR3hwYm1VZ2FYTWdiVzl5WlNCMGFHRnVJRzl1WlNCc2FXNWxJR0ZpYjNabElHRnVaQ0IwYUdWY2JpQWdJQ0FnSUM4dklHTjFjbkpsYm5RZ2JHbHVaU0JwY3lCaGRDQnNaV0Z6ZENCc2FXNWxJSFJvY21WbExDQmhaR1FnYzI5dFpTQnZaaUIwYUdVZ1ptOXliV1Z5SUd4cGJtVnpJR0Z1WkZ4dUlDQWdJQ0FnTHk4Z1lXeHpieUJoWkdRZ1pHOTBjeUIwYnlCcGJtUnBZMkYwWlNCemEybHdjR1ZrSUdWdWRISnBaWE11WEc0Z0lDQWdJQ0JwWmlBb1kzVnlJRDRnTVNBbUppQnBJRDRnTWlrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWTNWeUlENGdOQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lISmxjeUFyUFNCY0lseGNibHdpTG1OdmJtTmhkQ2hpYkhWbExDQmNJaTR1TGx3aUtTNWpiMjVqWVhRb2QyaHBkR1VwTzF4dUlDQWdJQ0FnSUNBZ0lITnJhWEJ3WldRZ1BTQjBjblZsTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHTjFjaUErSURNcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WlhNZ0t6MGdYQ0pjWEc0Z0lGd2lMbU52Ym1OaGRDaGhZM1IxWVd4TWFXNWxjMXRwSUMwZ01sMHBPMXh1SUNBZ0lDQWdJQ0FnSUhCeWFXNTBaV1JNYVc1bGN5c3JPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2NtVnpJQ3M5SUZ3aVhGeHVJQ0JjSWk1amIyNWpZWFFvWVdOMGRXRnNUR2x1WlhOYmFTQXRJREZkS1R0Y2JpQWdJQ0FnSUNBZ2NISnBiblJsWkV4cGJtVnpLeXM3WEc0Z0lDQWdJQ0I5SUM4dklFMWhjbXNnZEdobElHTjFjbkpsYm5RZ2JHbHVaU0JoY3lCMGFHVWdiR0Z6ZENCa2FYWmxjbWRwYm1jZ2IyNWxMbHh1WEc1Y2JpQWdJQ0FnSUd4aGMzUlFiM01nUFNCcE95QXZMeUJCWkdRZ2RHaGxJR0ZqZEhWaGJDQnNhVzVsSUhSdklIUm9aU0J5WlhOMWJIUXVYRzVjYmlBZ0lDQWdJSEpsY3lBclBTQmNJbHhjYmx3aUxtTnZibU5oZENobmNtVmxiaXdnWENJclhDSXBMbU52Ym1OaGRDaDNhR2wwWlN3Z1hDSWdYQ0lwTG1OdmJtTmhkQ2hoWTNSMVlXeE1hVzVsYzF0cFhTazdYRzRnSUNBZ0lDQndjbWx1ZEdWa1RHbHVaWE1yS3pzZ0x5OGdUR2x1WlhNZ1pHbDJaWEpuWlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQjJZWElnWlhod1pXTjBaV1JNYVc1bElEMGdaWGh3WldOMFpXUk1hVzVsYzF0cFhUdGNiaUFnSUNBZ0lIWmhjaUJoWTNSMVlXeE1hVzVsSUQwZ1lXTjBkV0ZzVEdsdVpYTmJhVjA3SUM4dklFbG1JSFJvWlNCc2FXNWxjeUJrYVhabGNtZGxMQ0J6Y0dWamFXWnBZMkZzYkhrZ1kyaGxZMnNnWm05eUlHeHBibVZ6SUhSb1lYUWdiMjVzZVNCa2FYWmxjbWRsSUdKNVhHNGdJQ0FnSUNBdkx5QmhJSFJ5WVdsc2FXNW5JR052YlcxaExpQkpiaUIwYUdGMElHTmhjMlVnYVhRZ2FYTWdZV04wZFdGc2JIa2dhV1JsYm5ScFkyRnNJR0Z1WkNCM1pTQnphRzkxYkdSY2JpQWdJQ0FnSUM4dklHMWhjbXNnYVhRZ1lYTWdjM1ZqYUM1Y2JseHVJQ0FnSUNBZ2RtRnlJR1JwZG1WeVoybHVaMHhwYm1WeklEMGdZV04wZFdGc1RHbHVaU0FoUFQwZ1pYaHdaV04wWldSTWFXNWxJQ1ltSUNnaFpXNWtjMWRwZEdnb1lXTjBkV0ZzVEdsdVpTd2dKeXduS1NCOGZDQmhZM1IxWVd4TWFXNWxMbk5zYVdObEtEQXNJQzB4S1NBaFBUMGdaWGh3WldOMFpXUk1hVzVsS1RzZ0x5OGdTV1lnZEdobElHVjRjR1ZqZEdWa0lHeHBibVVnYUdGeklHRWdkSEpoYVd4cGJtY2dZMjl0YldFZ1luVjBJR2x6SUc5MGFHVnlkMmx6WlNCcFpHVnVkR2xqWVd3c1hHNGdJQ0FnSUNBdkx5QmhaR1FnWVNCamIyMXRZU0JoZENCMGFHVWdaVzVrSUc5bUlIUm9aU0JoWTNSMVlXd2diR2x1WlM0Z1QzUm9aWEozYVhObElIUm9aU0J2ZFhSd2RYUWdZMjkxYkdSY2JpQWdJQ0FnSUM4dklHeHZiMnNnZDJWcGNtUWdZWE1nYVc0NlhHNGdJQ0FnSUNBdkwxeHVJQ0FnSUNBZ0x5OGdJQ0JiWEc0Z0lDQWdJQ0F2THlBZ0lDQWdNU0FnSUNBZ0lDQWdJQzh2SUU1dklHTnZiVzFoSUdGMElIUm9aU0JsYm1RaFhHNGdJQ0FnSUNBdkx5QXJJQ0FnTWx4dUlDQWdJQ0FnTHk4Z0lDQmRYRzRnSUNBZ0lDQXZMMXh1WEc0Z0lDQWdJQ0JwWmlBb1pHbDJaWEpuYVc1blRHbHVaWE1nSmlZZ1pXNWtjMWRwZEdnb1pYaHdaV04wWldSTWFXNWxMQ0FuTENjcElDWW1JR1Y0Y0dWamRHVmtUR2x1WlM1emJHbGpaU2d3TENBdE1Ta2dQVDA5SUdGamRIVmhiRXhwYm1VcElIdGNiaUFnSUNBZ0lDQWdaR2wyWlhKbmFXNW5UR2x1WlhNZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0FnSUNBZ1lXTjBkV0ZzVEdsdVpTQXJQU0FuTENjN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lHbG1JQ2hrYVhabGNtZHBibWRNYVc1bGN5a2dlMXh1SUNBZ0lDQWdJQ0F2THlCSlppQjBhR1VnYkdGemRDQmthWFpsY21kcGJtY2diR2x1WlNCcGN5QnRiM0psSUhSb1lXNGdiMjVsSUd4cGJtVWdZV0p2ZG1VZ1lXNWtJSFJvWlZ4dUlDQWdJQ0FnSUNBdkx5QmpkWEp5Wlc1MElHeHBibVVnYVhNZ1lYUWdiR1ZoYzNRZ2JHbHVaU0IwYUhKbFpTd2dZV1JrSUhOdmJXVWdiMllnZEdobElHWnZjbTFsY2lCc2FXNWxjeUJoYm1SY2JpQWdJQ0FnSUNBZ0x5OGdZV3h6YnlCaFpHUWdaRzkwY3lCMGJ5QnBibVJwWTJGMFpTQnphMmx3Y0dWa0lHVnVkSEpwWlhNdVhHNGdJQ0FnSUNBZ0lHbG1JQ2hqZFhJZ1BpQXhJQ1ltSUdrZ1BpQXlLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR04xY2lBK0lEUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxjeUFyUFNCY0lseGNibHdpTG1OdmJtTmhkQ2hpYkhWbExDQmNJaTR1TGx3aUtTNWpiMjVqWVhRb2QyaHBkR1VwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdjMnRwY0hCbFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hqZFhJZ1BpQXpLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWE1nS3owZ1hDSmNYRzRnSUZ3aUxtTnZibU5oZENoaFkzUjFZV3hNYVc1bGMxdHBJQzBnTWwwcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnY0hKcGJuUmxaRXhwYm1Wekt5czdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDQWdjbVZ6SUNzOUlGd2lYRnh1SUNCY0lpNWpiMjVqWVhRb1lXTjBkV0ZzVEdsdVpYTmJhU0F0SURGZEtUdGNiaUFnSUNBZ0lDQWdJQ0J3Y21sdWRHVmtUR2x1WlhNckt6dGNiaUFnSUNBZ0lDQWdmU0F2THlCTllYSnJJSFJvWlNCamRYSnlaVzUwSUd4cGJtVWdZWE1nZEdobElHeGhjM1FnWkdsMlpYSm5hVzVuSUc5dVpTNWNibHh1WEc0Z0lDQWdJQ0FnSUd4aGMzUlFiM01nUFNCcE95QXZMeUJCWkdRZ2RHaGxJR0ZqZEhWaGJDQnNhVzVsSUhSdklIUm9aU0J5WlhOMWJIUWdZVzVrSUdOaFkyaGxJSFJvWlNCbGVIQmxZM1JsWkNCa2FYWmxjbWRwYm1kY2JpQWdJQ0FnSUNBZ0x5OGdiR2x1WlNCemJ5QmpiMjV6WldOMWRHbDJaU0JrYVhabGNtZHBibWNnYkdsdVpYTWdjMmh2ZHlCMWNDQmhjeUFyS3lzdExTMGdZVzVrSUc1dmRDQXJMU3N0S3kwdVhHNWNiaUFnSUNBZ0lDQWdjbVZ6SUNzOUlGd2lYRnh1WENJdVkyOXVZMkYwS0dkeVpXVnVMQ0JjSWl0Y0lpa3VZMjl1WTJGMEtIZG9hWFJsTENCY0lpQmNJaWt1WTI5dVkyRjBLR0ZqZEhWaGJFeHBibVVwTzF4dUlDQWdJQ0FnSUNCdmRHaGxjaUFyUFNCY0lseGNibHdpTG1OdmJtTmhkQ2h5WldRc0lGd2lMVndpS1M1amIyNWpZWFFvZDJocGRHVXNJRndpSUZ3aUtTNWpiMjVqWVhRb1pYaHdaV04wWldSTWFXNWxLVHRjYmlBZ0lDQWdJQ0FnY0hKcGJuUmxaRXhwYm1WeklDczlJREk3SUM4dklFeHBibVZ6SUdGeVpTQnBaR1Z1ZEdsallXeGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDOHZJRUZrWkNCaGJHd2dZMkZqYUdWa0lHbHVabTl5YldGMGFXOXVJSFJ2SUhSb1pTQnlaWE4xYkhRZ1ltVm1iM0psSUdGa1pHbHVaeUJ2ZEdobGNpQjBhR2x1WjNOY2JpQWdJQ0FnSUNBZ0x5OGdZVzVrSUhKbGMyVjBJSFJvWlNCallXTm9aUzVjYmlBZ0lDQWdJQ0FnY21WeklDczlJRzkwYUdWeU8xeHVJQ0FnSUNBZ0lDQnZkR2hsY2lBOUlDY25PeUF2THlCSlppQjBhR1VnYkdGemRDQmthWFpsY21kcGJtY2diR2x1WlNCcGN5QmxlR0ZqZEd4NUlHOXVaU0JzYVc1bElHRmliM1psSUc5eUlHbG1JR2wwSUdseklIUm9aVnh1SUNBZ0lDQWdJQ0F2THlCMlpYSjVJR1pwY25OMElHeHBibVVzSUdGa1pDQjBhR1VnYkdsdVpTQjBieUIwYUdVZ2NtVnpkV3gwTGx4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2hqZFhJZ1BUMDlJREVnZkh3Z2FTQTlQVDBnTUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsY3lBclBTQmNJbHhjYmlBZ1hDSXVZMjl1WTJGMEtHRmpkSFZoYkV4cGJtVXBPMXh1SUNBZ0lDQWdJQ0FnSUhCeWFXNTBaV1JNYVc1bGN5c3JPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU0F2THlCSmJuTndaV04wWldRZ2IySnFaV04wSUhSdklHSnBaeUFvVTJodmR5QitNakFnY205M2N5QnRZWGdwWEc1Y2JseHVJQ0FnSUdsbUlDaHdjbWx1ZEdWa1RHbHVaWE1nUGlBeU1DQW1KaUJwSUR3Z2JXRjRUR2x1WlhNZ0xTQXlLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdYQ0pjSWk1amIyNWpZWFFvYlhObktTNWpiMjVqWVhRb2MydHBjSEJsWkUxelp5d2dYQ0pjWEc1Y0lpa3VZMjl1WTJGMEtISmxjeXdnWENKY1hHNWNJaWt1WTI5dVkyRjBLR0pzZFdVc0lGd2lMaTR1WENJcExtTnZibU5oZENoM2FHbDBaU2t1WTI5dVkyRjBLRzkwYUdWeUxDQmNJbHhjYmx3aUtTQXJJRndpWENJdVkyOXVZMkYwS0dKc2RXVXNJRndpTGk0dVhDSXBMbU52Ym1OaGRDaDNhR2wwWlNrN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUZ3aVhDSXVZMjl1WTJGMEtHMXpaeWt1WTI5dVkyRjBLSE5yYVhCd1pXUWdQeUJ6YTJsd2NHVmtUWE5uSURvZ0p5Y3NJRndpWEZ4dVhDSXBMbU52Ym1OaGRDaHlaWE1wTG1OdmJtTmhkQ2h2ZEdobGNpa3VZMjl1WTJGMEtHVnVaQ2t1WTI5dVkyRjBLR2x1WkdsallYUnZjaWs3WEc1OVhHNWNiblpoY2lCQmMzTmxjblJwYjI1RmNuSnZjaUE5WEc0dktpTmZYMUJWVWtWZlh5b3ZYRzVtZFc1amRHbHZiaUFvWDBWeWNtOXlLU0I3WEc0Z0lGOXBibWhsY21sMGN5aEJjM05sY25ScGIyNUZjbkp2Y2l3Z1gwVnljbTl5S1R0Y2JseHVJQ0JtZFc1amRHbHZiaUJCYzNObGNuUnBiMjVGY25KdmNpaHZjSFJwYjI1ektTQjdYRzRnSUNBZ2RtRnlJRjkwYUdsek8xeHVYRzRnSUNBZ1gyTnNZWE56UTJGc2JFTm9aV05yS0hSb2FYTXNJRUZ6YzJWeWRHbHZia1Z5Y205eUtUdGNibHh1SUNBZ0lHbG1JQ2hmZEhsd1pXOW1LRzl3ZEdsdmJuTXBJQ0U5UFNBbmIySnFaV04wSnlCOGZDQnZjSFJwYjI1eklEMDlQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSVkpTWDBsT1ZrRk1TVVJmUVZKSFgxUlpVRVVvSjI5d2RHbHZibk1uTENBblQySnFaV04wSnl3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnZG1GeUlHMWxjM05oWjJVZ1BTQnZjSFJwYjI1ekxtMWxjM05oWjJVc1hHNGdJQ0FnSUNBZ0lHOXdaWEpoZEc5eUlEMGdiM0IwYVc5dWN5NXZjR1Z5WVhSdmNpeGNiaUFnSUNBZ0lDQWdjM1JoWTJ0VGRHRnlkRVp1SUQwZ2IzQjBhVzl1Y3k1emRHRmphMU4wWVhKMFJtNDdYRzRnSUNBZ2RtRnlJR0ZqZEhWaGJDQTlJRzl3ZEdsdmJuTXVZV04wZFdGc0xGeHVJQ0FnSUNBZ0lDQmxlSEJsWTNSbFpDQTlJRzl3ZEdsdmJuTXVaWGh3WldOMFpXUTdYRzRnSUNBZ2RtRnlJR3hwYldsMElEMGdSWEp5YjNJdWMzUmhZMnRVY21GalpVeHBiV2wwTzF4dUlDQWdJRVZ5Y205eUxuTjBZV05yVkhKaFkyVk1hVzFwZENBOUlEQTdYRzVjYmlBZ0lDQnBaaUFvYldWemMyRm5aU0FoUFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0JmZEdocGN5QTlJRjl3YjNOemFXSnNaVU52Ym5OMGNuVmpkRzl5VW1WMGRYSnVLSFJvYVhNc0lGOW5aWFJRY205MGIzUjVjR1ZQWmloQmMzTmxjblJwYjI1RmNuSnZjaWt1WTJGc2JDaDBhR2x6TENCVGRISnBibWNvYldWemMyRm5aU2twS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdhV1lnS0hCeWIyTmxjM011YzNSa1pYSnlJQ1ltSUhCeWIyTmxjM011YzNSa1pYSnlMbWx6VkZSWktTQjdYRzRnSUNBZ0lDQWdJQzh2SUZKbGMyVjBJRzl1SUdWaFkyZ2dZMkZzYkNCMGJ5QnRZV3RsSUhOMWNtVWdkMlVnYUdGdVpHeGxJR1I1Ym1GdGFXTmhiR3g1SUhObGRDQmxiblpwY205dWJXVnVkRnh1SUNBZ0lDQWdJQ0F2THlCMllYSnBZV0pzWlhNZ1kyOXljbVZqZEM1Y2JpQWdJQ0FnSUNBZ2FXWWdLSEJ5YjJObGMzTXVjM1JrWlhKeUlDWW1JSEJ5YjJObGMzTXVjM1JrWlhKeUxtZGxkRU52Ykc5eVJHVndkR2dnSmlZZ2NISnZZMlZ6Y3k1emRHUmxjbkl1WjJWMFEyOXNiM0pFWlhCMGFDZ3BJQ0U5UFNBeEtTQjdYRzRnSUNBZ0lDQWdJQ0FnWW14MVpTQTlJRndpWEZ4NE1VSmJNelJ0WENJN1hHNGdJQ0FnSUNBZ0lDQWdaM0psWlc0Z1BTQmNJbHhjZURGQ1d6TXliVndpTzF4dUlDQWdJQ0FnSUNBZ0lIZG9hWFJsSUQwZ1hDSmNYSGd4UWxzek9XMWNJanRjYmlBZ0lDQWdJQ0FnSUNCeVpXUWdQU0JjSWx4Y2VERkNXek14YlZ3aU8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJR0pzZFdVZ1BTQW5KenRjYmlBZ0lDQWdJQ0FnSUNCbmNtVmxiaUE5SUNjbk8xeHVJQ0FnSUNBZ0lDQWdJSGRvYVhSbElEMGdKeWM3WEc0Z0lDQWdJQ0FnSUNBZ2NtVmtJRDBnSnljN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMGdMeThnVUhKbGRtVnVkQ0IwYUdVZ1pYSnliM0lnYzNSaFkyc2dabkp2YlNCaVpXbHVaeUIyYVhOcFlteGxJR0o1SUdSMWNHeHBZMkYwYVc1bklIUm9aU0JsY25KdmNseHVJQ0FnSUNBZ0x5OGdhVzRnWVNCMlpYSjVJR05zYjNObElIZGhlU0IwYnlCMGFHVWdiM0pwWjJsdVlXd2dhVzRnWTJGelpTQmliM1JvSUhOcFpHVnpJR0Z5WlNCaFkzUjFZV3hzZVZ4dUlDQWdJQ0FnTHk4Z2FXNXpkR0Z1WTJWeklHOW1JRVZ5Y205eUxseHVYRzVjYmlBZ0lDQWdJR2xtSUNoZmRIbHdaVzltS0dGamRIVmhiQ2tnUFQwOUlDZHZZbXBsWTNRbklDWW1JR0ZqZEhWaGJDQWhQVDBnYm5Wc2JDQW1KaUJmZEhsd1pXOW1LR1Y0Y0dWamRHVmtLU0E5UFQwZ0oyOWlhbVZqZENjZ0ppWWdaWGh3WldOMFpXUWdJVDA5SUc1MWJHd2dKaVlnSjNOMFlXTnJKeUJwYmlCaFkzUjFZV3dnSmlZZ1lXTjBkV0ZzSUdsdWMzUmhibU5sYjJZZ1JYSnliM0lnSmlZZ0ozTjBZV05ySnlCcGJpQmxlSEJsWTNSbFpDQW1KaUJsZUhCbFkzUmxaQ0JwYm5OMFlXNWpaVzltSUVWeWNtOXlLU0I3WEc0Z0lDQWdJQ0FnSUdGamRIVmhiQ0E5SUdOdmNIbEZjbkp2Y2loaFkzUjFZV3dwTzF4dUlDQWdJQ0FnSUNCbGVIQmxZM1JsWkNBOUlHTnZjSGxGY25KdmNpaGxlSEJsWTNSbFpDazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJR2xtSUNodmNHVnlZWFJ2Y2lBOVBUMGdKMlJsWlhCVGRISnBZM1JGY1hWaGJDY2dmSHdnYjNCbGNtRjBiM0lnUFQwOUlDZHpkSEpwWTNSRmNYVmhiQ2NwSUh0Y2JpQWdJQ0FnSUNBZ1gzUm9hWE1nUFNCZmNHOXpjMmxpYkdWRGIyNXpkSEoxWTNSdmNsSmxkSFZ5YmloMGFHbHpMQ0JmWjJWMFVISnZkRzkwZVhCbFQyWW9RWE56WlhKMGFXOXVSWEp5YjNJcExtTmhiR3dvZEdocGN5d2dZM0psWVhSbFJYSnlSR2xtWmloaFkzUjFZV3dzSUdWNGNHVmpkR1ZrTENCdmNHVnlZWFJ2Y2lrcEtUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCcFppQW9iM0JsY21GMGIzSWdQVDA5SUNkdWIzUkVaV1Z3VTNSeWFXTjBSWEYxWVd3bklIeDhJRzl3WlhKaGRHOXlJRDA5UFNBbmJtOTBVM1J5YVdOMFJYRjFZV3duS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJRWx1SUdOaGMyVWdkR2hsSUc5aWFtVmpkSE1nWVhKbElHVnhkV0ZzSUdKMWRDQjBhR1VnYjNCbGNtRjBiM0lnY21WeGRXbHlaWE1nZFc1bGNYVmhiQ3dnYzJodmQxeHVJQ0FnSUNBZ0lDQXZMeUIwYUdVZ1ptbHljM1FnYjJKcVpXTjBJR0Z1WkNCellYa2dRU0JsY1hWaGJITWdRbHh1SUNBZ0lDQWdJQ0IyWVhJZ1ltRnpaU0E5SUd0U1pXRmtZV0pzWlU5d1pYSmhkRzl5VzI5d1pYSmhkRzl5WFR0Y2JpQWdJQ0FnSUNBZ2RtRnlJSEpsY3lBOUlHbHVjM0JsWTNSV1lXeDFaU2hoWTNSMVlXd3BMbk53YkdsMEtDZGNYRzRuS1RzZ0x5OGdTVzRnWTJGelpTQmNJbUZqZEhWaGJGd2lJR2x6SUdGdUlHOWlhbVZqZEN3Z2FYUWdjMmh2ZFd4a0lHNXZkQ0JpWlNCeVpXWmxjbVZ1WTJVZ1pYRjFZV3d1WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLRzl3WlhKaGRHOXlJRDA5UFNBbmJtOTBVM1J5YVdOMFJYRjFZV3duSUNZbUlGOTBlWEJsYjJZb1lXTjBkV0ZzS1NBOVBUMGdKMjlpYW1WamRDY2dKaVlnWVdOMGRXRnNJQ0U5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1ltRnpaU0E5SUd0U1pXRmtZV0pzWlU5d1pYSmhkRzl5TG01dmRGTjBjbWxqZEVWeGRXRnNUMkpxWldOME8xeHVJQ0FnSUNBZ0lDQjlJQzh2SUU5dWJIa2djbVZ0YjNabElHeHBibVZ6SUdsdUlHTmhjMlVnYVhRZ2JXRnJaWE1nYzJWdWMyVWdkRzhnWTI5c2JHRndjMlVnZEdodmMyVXVYRzRnSUNBZ0lDQWdJQzh2SUZSUFJFODZJRUZqWTJWd2RDQmxibllnZEc4Z1lXeDNZWGx6SUhOb2IzY2dkR2hsSUdaMWJHd2daWEp5YjNJdVhHNWNibHh1SUNBZ0lDQWdJQ0JwWmlBb2NtVnpMbXhsYm1kMGFDQStJRE13S1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVZ6V3pJMlhTQTlJRndpWENJdVkyOXVZMkYwS0dKc2RXVXNJRndpTGk0dVhDSXBMbU52Ym1OaGRDaDNhR2wwWlNrN1hHNWNiaUFnSUNBZ0lDQWdJQ0IzYUdsc1pTQW9jbVZ6TG14bGJtZDBhQ0ErSURJM0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYTXVjRzl3S0NrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5SUM4dklFOXViSGtnY0hKcGJuUWdZU0J6YVc1bmJHVWdhVzV3ZFhRdVhHNWNibHh1SUNBZ0lDQWdJQ0JwWmlBb2NtVnpMbXhsYm1kMGFDQTlQVDBnTVNrZ2UxeHVJQ0FnSUNBZ0lDQWdJRjkwYUdseklEMGdYM0J2YzNOcFlteGxRMjl1YzNSeWRXTjBiM0pTWlhSMWNtNG9kR2hwY3l3Z1gyZGxkRkJ5YjNSdmRIbHdaVTltS0VGemMyVnlkR2x2YmtWeWNtOXlLUzVqWVd4c0tIUm9hWE1zSUZ3aVhDSXVZMjl1WTJGMEtHSmhjMlVzSUZ3aUlGd2lLUzVqYjI1allYUW9jbVZ6V3pCZEtTa3BPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUY5MGFHbHpJRDBnWDNCdmMzTnBZbXhsUTI5dWMzUnlkV04wYjNKU1pYUjFjbTRvZEdocGN5d2dYMmRsZEZCeWIzUnZkSGx3WlU5bUtFRnpjMlZ5ZEdsdmJrVnljbTl5S1M1allXeHNLSFJvYVhNc0lGd2lYQ0l1WTI5dVkyRjBLR0poYzJVc0lGd2lYRnh1WEZ4dVhDSXBMbU52Ym1OaGRDaHlaWE11YW05cGJpZ25YRnh1Snlrc0lGd2lYRnh1WENJcEtTazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCZmNtVnpJRDBnYVc1emNHVmpkRlpoYkhWbEtHRmpkSFZoYkNrN1hHNWNiaUFnSUNBZ0lDQWdkbUZ5SUc5MGFHVnlJRDBnSnljN1hHNGdJQ0FnSUNBZ0lIWmhjaUJyYm05M2JrOXdaWEpoZEc5eWN5QTlJR3RTWldGa1lXSnNaVTl3WlhKaGRHOXlXMjl3WlhKaGRHOXlYVHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9iM0JsY21GMGIzSWdQVDA5SUNkdWIzUkVaV1Z3UlhGMVlXd25JSHg4SUc5d1pYSmhkRzl5SUQwOVBTQW5ibTkwUlhGMVlXd25LU0I3WEc0Z0lDQWdJQ0FnSUNBZ1gzSmxjeUE5SUZ3aVhDSXVZMjl1WTJGMEtHdFNaV0ZrWVdKc1pVOXdaWEpoZEc5eVcyOXdaWEpoZEc5eVhTd2dYQ0pjWEc1Y1hHNWNJaWt1WTI5dVkyRjBLRjl5WlhNcE8xeHVYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tGOXlaWE11YkdWdVozUm9JRDRnTVRBeU5Da2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1gzSmxjeUE5SUZ3aVhDSXVZMjl1WTJGMEtGOXlaWE11YzJ4cFkyVW9NQ3dnTVRBeU1Ta3NJRndpTGk0dVhDSXBPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQnZkR2hsY2lBOUlGd2lYQ0l1WTI5dVkyRjBLR2x1YzNCbFkzUldZV3gxWlNobGVIQmxZM1JsWkNrcE8xeHVYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tGOXlaWE11YkdWdVozUm9JRDRnTlRFeUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCZmNtVnpJRDBnWENKY0lpNWpiMjVqWVhRb1gzSmxjeTV6YkdsalpTZ3dMQ0ExTURrcExDQmNJaTR1TGx3aUtUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvYjNSb1pYSXViR1Z1WjNSb0lENGdOVEV5S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J2ZEdobGNpQTlJRndpWENJdVkyOXVZMkYwS0c5MGFHVnlMbk5zYVdObEtEQXNJRFV3T1Nrc0lGd2lMaTR1WENJcE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h2Y0dWeVlYUnZjaUE5UFQwZ0oyUmxaWEJGY1hWaGJDY2dmSHdnYjNCbGNtRjBiM0lnUFQwOUlDZGxjWFZoYkNjcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUY5eVpYTWdQU0JjSWx3aUxtTnZibU5oZENocmJtOTNiazl3WlhKaGRHOXljeXdnWENKY1hHNWNYRzVjSWlrdVkyOXVZMkYwS0Y5eVpYTXNJRndpWEZ4dVhGeHVjMmh2ZFd4a0lHVnhkV0ZzWEZ4dVhGeHVYQ0lwTzF4dUlDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J2ZEdobGNpQTlJRndpSUZ3aUxtTnZibU5oZENodmNHVnlZWFJ2Y2l3Z1hDSWdYQ0lwTG1OdmJtTmhkQ2h2ZEdobGNpazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdYM1JvYVhNZ1BTQmZjRzl6YzJsaWJHVkRiMjV6ZEhKMVkzUnZjbEpsZEhWeWJpaDBhR2x6TENCZloyVjBVSEp2ZEc5MGVYQmxUMllvUVhOelpYSjBhVzl1UlhKeWIzSXBMbU5oYkd3b2RHaHBjeXdnWENKY0lpNWpiMjVqWVhRb1gzSmxjeWt1WTI5dVkyRjBLRzkwYUdWeUtTa3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lFVnljbTl5TG5OMFlXTnJWSEpoWTJWTWFXMXBkQ0E5SUd4cGJXbDBPMXh1SUNBZ0lGOTBhR2x6TG1kbGJtVnlZWFJsWkUxbGMzTmhaMlVnUFNBaGJXVnpjMkZuWlR0Y2JpQWdJQ0JQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1gyRnpjMlZ5ZEZSb2FYTkpibWwwYVdGc2FYcGxaQ2hmZEdocGN5a3NJQ2R1WVcxbEp5d2dlMXh1SUNBZ0lDQWdkbUZzZFdVNklDZEJjM05sY25ScGIyNUZjbkp2Y2lCYlJWSlNYMEZUVTBWU1ZFbFBUbDBuTEZ4dUlDQWdJQ0FnWlc1MWJXVnlZV0pzWlRvZ1ptRnNjMlVzWEc0Z0lDQWdJQ0IzY21sMFlXSnNaVG9nZEhKMVpTeGNiaUFnSUNBZ0lHTnZibVpwWjNWeVlXSnNaVG9nZEhKMVpWeHVJQ0FnSUgwcE8xeHVJQ0FnSUY5MGFHbHpMbU52WkdVZ1BTQW5SVkpTWDBGVFUwVlNWRWxQVGljN1hHNGdJQ0FnWDNSb2FYTXVZV04wZFdGc0lEMGdZV04wZFdGc08xeHVJQ0FnSUY5MGFHbHpMbVY0Y0dWamRHVmtJRDBnWlhod1pXTjBaV1E3WEc0Z0lDQWdYM1JvYVhNdWIzQmxjbUYwYjNJZ1BTQnZjR1Z5WVhSdmNqdGNibHh1SUNBZ0lHbG1JQ2hGY25KdmNpNWpZWEIwZFhKbFUzUmhZMnRVY21GalpTa2dlMXh1SUNBZ0lDQWdMeThnWlhOc2FXNTBMV1JwYzJGaWJHVXRibVY0ZEMxc2FXNWxJRzV2TFhKbGMzUnlhV04wWldRdGMzbHVkR0Y0WEc0Z0lDQWdJQ0JGY25KdmNpNWpZWEIwZFhKbFUzUmhZMnRVY21GalpTaGZZWE56WlhKMFZHaHBjMGx1YVhScFlXeHBlbVZrS0Y5MGFHbHpLU3dnYzNSaFkydFRkR0Z5ZEVadUtUdGNiaUFnSUNCOUlDOHZJRU55WldGMFpTQmxjbkp2Y2lCdFpYTnpZV2RsSUdsdVkyeDFaR2x1WnlCMGFHVWdaWEp5YjNJZ1kyOWtaU0JwYmlCMGFHVWdibUZ0WlM1Y2JseHVYRzRnSUNBZ1gzUm9hWE11YzNSaFkyczdJQzh2SUZKbGMyVjBJSFJvWlNCdVlXMWxMbHh1WEc0Z0lDQWdYM1JvYVhNdWJtRnRaU0E5SUNkQmMzTmxjblJwYjI1RmNuSnZjaWM3WEc0Z0lDQWdjbVYwZFhKdUlGOXdiM056YVdKc1pVTnZibk4wY25WamRHOXlVbVYwZFhKdUtGOTBhR2x6S1R0Y2JpQWdmVnh1WEc0Z0lGOWpjbVZoZEdWRGJHRnpjeWhCYzNObGNuUnBiMjVGY25KdmNpd2dXM3RjYmlBZ0lDQnJaWGs2SUZ3aWRHOVRkSEpwYm1kY0lpeGNiaUFnSUNCMllXeDFaVG9nWm5WdVkzUnBiMjRnZEc5VGRISnBibWNvS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWENKY0lpNWpiMjVqWVhRb2RHaHBjeTV1WVcxbExDQmNJaUJiWENJcExtTnZibU5oZENoMGFHbHpMbU52WkdVc0lGd2lYVG9nWENJcExtTnZibU5oZENoMGFHbHpMbTFsYzNOaFoyVXBPMXh1SUNBZ0lIMWNiaUFnZlN3Z2UxeHVJQ0FnSUd0bGVUb2dhVzV6Y0dWamRDNWpkWE4wYjIwc1hHNGdJQ0FnZG1Gc2RXVTZJR1oxYm1OMGFXOXVJSFpoYkhWbEtISmxZM1Z5YzJWVWFXMWxjeXdnWTNSNEtTQjdYRzRnSUNBZ0lDQXZMeUJVYUdseklHeHBiV2wwY3lCMGFHVWdZR0ZqZEhWaGJHQWdZVzVrSUdCbGVIQmxZM1JsWkdBZ2NISnZjR1Z5ZEhrZ1pHVm1ZWFZzZENCcGJuTndaV04wYVc5dUlIUnZYRzRnSUNBZ0lDQXZMeUIwYUdVZ2JXbHVhVzExYlNCa1pYQjBhQzRnVDNSb1pYSjNhWE5sSUhSb2IzTmxJSFpoYkhWbGN5QjNiM1ZzWkNCaVpTQjBiMjhnZG1WeVltOXpaU0JqYjIxd1lYSmxaRnh1SUNBZ0lDQWdMeThnZEc4Z2RHaGxJR0ZqZEhWaGJDQmxjbkp2Y2lCdFpYTnpZV2RsSUhkb2FXTm9JR052Ym5SaGFXNXpJR0VnWTI5dFltbHVaV1FnZG1sbGR5QnZaaUIwYUdWelpTQjBkMjljYmlBZ0lDQWdJQzh2SUdsdWNIVjBJSFpoYkhWbGN5NWNiaUFnSUNBZ0lISmxkSFZ5YmlCcGJuTndaV04wS0hSb2FYTXNJRjl2WW1wbFkzUlRjSEpsWVdRb2UzMHNJR04wZUN3Z2UxeHVJQ0FnSUNBZ0lDQmpkWE4wYjIxSmJuTndaV04wT2lCbVlXeHpaU3hjYmlBZ0lDQWdJQ0FnWkdWd2RHZzZJREJjYmlBZ0lDQWdJSDBwS1R0Y2JpQWdJQ0I5WEc0Z0lIMWRLVHRjYmx4dUlDQnlaWFIxY200Z1FYTnpaWEowYVc5dVJYSnliM0k3WEc1OUtGOTNjbUZ3VG1GMGFYWmxVM1Z3WlhJb1JYSnliM0lwS1R0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQkJjM05sY25ScGIyNUZjbkp2Y2pzaUxDSXZMeUJEZFhKeVpXNTBiSGtnYVc0Z2MzbHVZeUIzYVhSb0lFNXZaR1V1YW5NZ2JHbGlMMmx1ZEdWeWJtRnNMMlZ5Y205eWN5NXFjMXh1THk4Z2FIUjBjSE02THk5bmFYUm9kV0l1WTI5dEwyNXZaR1ZxY3k5dWIyUmxMMk52YlcxcGRDOHpZakEwTkRrMk1tTTBPR1psTXpFek9UQTFPRGMzWVRrMllqVmtNRGc1TkdFMU5EQTBaalptWEc1Y2JpOHFJR1Z6YkdsdWRDQnViMlJsTFdOdmNtVXZaRzlqZFcxbGJuUmxaQzFsY25KdmNuTTZJRndpWlhKeWIzSmNJaUFxTDF4dVhHNHZLaUJsYzJ4cGJuUWdibTlrWlMxamIzSmxMMkZzY0doaFltVjBhWHBsTFdWeWNtOXljem9nWENKbGNuSnZjbHdpSUNvdlhHNWNiaThxSUdWemJHbHVkQ0J1YjJSbExXTnZjbVV2Y0hKbFptVnlMWFYwYVd3dFptOXliV0YwTFdWeWNtOXljem9nWENKbGNuSnZjbHdpSUNvdlhHNG5kWE5sSUhOMGNtbGpkQ2M3SUM4dklGUm9aU0IzYUc5c1pTQndiMmx1ZENCaVpXaHBibVFnZEdocGN5QnBiblJsY201aGJDQnRiMlIxYkdVZ2FYTWdkRzhnWVd4c2IzY2dUbTlrWlM1cWN5QjBieUJ1YjF4dUx5OGdiRzl1WjJWeUlHSmxJR1p2Y21ObFpDQjBieUIwY21WaGRDQmxkbVZ5ZVNCbGNuSnZjaUJ0WlhOellXZGxJR05vWVc1blpTQmhjeUJoSUhObGJYWmxjaTF0WVdwdmNseHVMeThnWTJoaGJtZGxMaUJVYUdVZ1RtOWtaVVZ5Y205eUlHTnNZWE56WlhNZ2FHVnlaU0JoYkd3Z1pYaHdiM05sSUdFZ1lHTnZaR1ZnSUhCeWIzQmxjblI1SUhkb2IzTmxYRzR2THlCMllXeDFaU0J6ZEdGMGFXTmhiR3g1SUdGdVpDQndaWEp0WVc1bGJuUnNlU0JwWkdWdWRHbG1hV1Z6SUhSb1pTQmxjbkp2Y2k0Z1YyaHBiR1VnZEdobElHVnljbTl5WEc0dkx5QnRaWE56WVdkbElHMWhlU0JqYUdGdVoyVXNJSFJvWlNCamIyUmxJSE5vYjNWc1pDQnViM1F1WEc1Y2JtWjFibU4wYVc5dUlGOTBlWEJsYjJZb2IySnFLU0I3SUdsbUlDaDBlWEJsYjJZZ1UzbHRZbTlzSUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lnSmlZZ2RIbHdaVzltSUZONWJXSnZiQzVwZEdWeVlYUnZjaUE5UFQwZ1hDSnplVzFpYjJ4Y0lpa2dleUJmZEhsd1pXOW1JRDBnWm5WdVkzUnBiMjRnWDNSNWNHVnZaaWh2WW1vcElIc2djbVYwZFhKdUlIUjVjR1Z2WmlCdlltbzdJSDA3SUgwZ1pXeHpaU0I3SUY5MGVYQmxiMllnUFNCbWRXNWpkR2x2YmlCZmRIbHdaVzltS0c5aWFpa2dleUJ5WlhSMWNtNGdiMkpxSUNZbUlIUjVjR1Z2WmlCVGVXMWliMndnUFQwOUlGd2lablZ1WTNScGIyNWNJaUFtSmlCdlltb3VZMjl1YzNSeWRXTjBiM0lnUFQwOUlGTjViV0p2YkNBbUppQnZZbW9nSVQwOUlGTjViV0p2YkM1d2NtOTBiM1I1Y0dVZ1B5QmNJbk41YldKdmJGd2lJRG9nZEhsd1pXOW1JRzlpYWpzZ2ZUc2dmU0J5WlhSMWNtNGdYM1I1Y0dWdlppaHZZbW9wT3lCOVhHNWNibVoxYm1OMGFXOXVJRjlqYkdGemMwTmhiR3hEYUdWamF5aHBibk4wWVc1alpTd2dRMjl1YzNSeWRXTjBiM0lwSUhzZ2FXWWdLQ0VvYVc1emRHRnVZMlVnYVc1emRHRnVZMlZ2WmlCRGIyNXpkSEoxWTNSdmNpa3BJSHNnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2loY0lrTmhibTV2ZENCallXeHNJR0VnWTJ4aGMzTWdZWE1nWVNCbWRXNWpkR2x2Ymx3aUtUc2dmU0I5WEc1Y2JtWjFibU4wYVc5dUlGOXdiM056YVdKc1pVTnZibk4wY25WamRHOXlVbVYwZFhKdUtITmxiR1lzSUdOaGJHd3BJSHNnYVdZZ0tHTmhiR3dnSmlZZ0tGOTBlWEJsYjJZb1kyRnNiQ2tnUFQwOUlGd2liMkpxWldOMFhDSWdmSHdnZEhsd1pXOW1JR05oYkd3Z1BUMDlJRndpWm5WdVkzUnBiMjVjSWlrcElIc2djbVYwZFhKdUlHTmhiR3c3SUgwZ2NtVjBkWEp1SUY5aGMzTmxjblJVYUdselNXNXBkR2xoYkdsNlpXUW9jMlZzWmlrN0lIMWNibHh1Wm5WdVkzUnBiMjRnWDJGemMyVnlkRlJvYVhOSmJtbDBhV0ZzYVhwbFpDaHpaV3htS1NCN0lHbG1JQ2h6Wld4bUlEMDlQU0IyYjJsa0lEQXBJSHNnZEdoeWIzY2dibVYzSUZKbFptVnlaVzVqWlVWeWNtOXlLRndpZEdocGN5Qm9ZWE51SjNRZ1ltVmxiaUJwYm1sMGFXRnNhWE5sWkNBdElITjFjR1Z5S0NrZ2FHRnpiaWQwSUdKbFpXNGdZMkZzYkdWa1hDSXBPeUI5SUhKbGRIVnliaUJ6Wld4bU95QjlYRzVjYm1aMWJtTjBhVzl1SUY5blpYUlFjbTkwYjNSNWNHVlBaaWh2S1NCN0lGOW5aWFJRY205MGIzUjVjR1ZQWmlBOUlFOWlhbVZqZEM1elpYUlFjbTkwYjNSNWNHVlBaaUEvSUU5aWFtVmpkQzVuWlhSUWNtOTBiM1I1Y0dWUFppQTZJR1oxYm1OMGFXOXVJRjluWlhSUWNtOTBiM1I1Y0dWUFppaHZLU0I3SUhKbGRIVnliaUJ2TGw5ZmNISnZkRzlmWHlCOGZDQlBZbXBsWTNRdVoyVjBVSEp2ZEc5MGVYQmxUMllvYnlrN0lIMDdJSEpsZEhWeWJpQmZaMlYwVUhKdmRHOTBlWEJsVDJZb2J5azdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gybHVhR1Z5YVhSektITjFZa05zWVhOekxDQnpkWEJsY2tOc1lYTnpLU0I3SUdsbUlDaDBlWEJsYjJZZ2MzVndaWEpEYkdGemN5QWhQVDBnWENKbWRXNWpkR2x2Ymx3aUlDWW1JSE4xY0dWeVEyeGhjM01nSVQwOUlHNTFiR3dwSUhzZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpaGNJbE4xY0dWeUlHVjRjSEpsYzNOcGIyNGdiWFZ6ZENCbGFYUm9aWElnWW1VZ2JuVnNiQ0J2Y2lCaElHWjFibU4wYVc5dVhDSXBPeUI5SUhOMVlrTnNZWE56TG5CeWIzUnZkSGx3WlNBOUlFOWlhbVZqZEM1amNtVmhkR1VvYzNWd1pYSkRiR0Z6Y3lBbUppQnpkWEJsY2tOc1lYTnpMbkJ5YjNSdmRIbHdaU3dnZXlCamIyNXpkSEoxWTNSdmNqb2dleUIyWVd4MVpUb2djM1ZpUTJ4aGMzTXNJSGR5YVhSaFlteGxPaUIwY25WbExDQmpiMjVtYVdkMWNtRmliR1U2SUhSeWRXVWdmU0I5S1RzZ2FXWWdLSE4xY0dWeVEyeGhjM01wSUY5elpYUlFjbTkwYjNSNWNHVlBaaWh6ZFdKRGJHRnpjeXdnYzNWd1pYSkRiR0Z6Y3lrN0lIMWNibHh1Wm5WdVkzUnBiMjRnWDNObGRGQnliM1J2ZEhsd1pVOW1LRzhzSUhBcElIc2dYM05sZEZCeWIzUnZkSGx3WlU5bUlEMGdUMkpxWldOMExuTmxkRkJ5YjNSdmRIbHdaVTltSUh4OElHWjFibU4wYVc5dUlGOXpaWFJRY205MGIzUjVjR1ZQWmlodkxDQndLU0I3SUc4dVgxOXdjbTkwYjE5ZklEMGdjRHNnY21WMGRYSnVJRzg3SUgwN0lISmxkSFZ5YmlCZmMyVjBVSEp2ZEc5MGVYQmxUMllvYnl3Z2NDazdJSDFjYmx4dWRtRnlJR052WkdWeklEMGdlMzA3SUM4dklFeGhlbmtnYkc5aFpHVmtYRzVjYm5aaGNpQmhjM05sY25RN1hHNTJZWElnZFhScGJEdGNibHh1Wm5WdVkzUnBiMjRnWTNKbFlYUmxSWEp5YjNKVWVYQmxLR052WkdVc0lHMWxjM05oWjJVc0lFSmhjMlVwSUh0Y2JpQWdhV1lnS0NGQ1lYTmxLU0I3WEc0Z0lDQWdRbUZ6WlNBOUlFVnljbTl5TzF4dUlDQjlYRzVjYmlBZ1puVnVZM1JwYjI0Z1oyVjBUV1Z6YzJGblpTaGhjbWN4TENCaGNtY3lMQ0JoY21jektTQjdYRzRnSUNBZ2FXWWdLSFI1Y0dWdlppQnRaWE56WVdkbElEMDlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRzFsYzNOaFoyVTdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ0WlhOellXZGxLR0Z5WnpFc0lHRnlaeklzSUdGeVp6TXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSFpoY2lCT2IyUmxSWEp5YjNJZ1BWeHVJQ0F2S2lOZlgxQlZVa1ZmWHlvdlhHNGdJR1oxYm1OMGFXOXVJQ2hmUW1GelpTa2dlMXh1SUNBZ0lGOXBibWhsY21sMGN5aE9iMlJsUlhKeWIzSXNJRjlDWVhObEtUdGNibHh1SUNBZ0lHWjFibU4wYVc5dUlFNXZaR1ZGY25KdmNpaGhjbWN4TENCaGNtY3lMQ0JoY21jektTQjdYRzRnSUNBZ0lDQjJZWElnWDNSb2FYTTdYRzVjYmlBZ0lDQWdJRjlqYkdGemMwTmhiR3hEYUdWamF5aDBhR2x6TENCT2IyUmxSWEp5YjNJcE8xeHVYRzRnSUNBZ0lDQmZkR2hwY3lBOUlGOXdiM056YVdKc1pVTnZibk4wY25WamRHOXlVbVYwZFhKdUtIUm9hWE1zSUY5blpYUlFjbTkwYjNSNWNHVlBaaWhPYjJSbFJYSnliM0lwTG1OaGJHd29kR2hwY3l3Z1oyVjBUV1Z6YzJGblpTaGhjbWN4TENCaGNtY3lMQ0JoY21jektTa3BPMXh1SUNBZ0lDQWdYM1JvYVhNdVkyOWtaU0E5SUdOdlpHVTdYRzRnSUNBZ0lDQnlaWFIxY200Z1gzUm9hWE03WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlFNXZaR1ZGY25KdmNqdGNiaUFnZlNoQ1lYTmxLVHRjYmx4dUlDQmpiMlJsYzF0amIyUmxYU0E5SUU1dlpHVkZjbkp2Y2p0Y2JuMGdMeThnYUhSMGNITTZMeTluYVhSb2RXSXVZMjl0TDI1dlpHVnFjeTl1YjJSbEwySnNiMkl2ZGpFd0xqZ3VNQzlzYVdJdmFXNTBaWEp1WVd3dlpYSnliM0p6TG1welhHNWNibHh1Wm5WdVkzUnBiMjRnYjI1bFQyWW9aWGh3WldOMFpXUXNJSFJvYVc1bktTQjdYRzRnSUdsbUlDaEJjbkpoZVM1cGMwRnljbUY1S0dWNGNHVmpkR1ZrS1NrZ2UxeHVJQ0FnSUhaaGNpQnNaVzRnUFNCbGVIQmxZM1JsWkM1c1pXNW5kR2c3WEc0Z0lDQWdaWGh3WldOMFpXUWdQU0JsZUhCbFkzUmxaQzV0WVhBb1puVnVZM1JwYjI0Z0tHa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQlRkSEpwYm1jb2FTazdYRzRnSUNBZ2ZTazdYRzVjYmlBZ0lDQnBaaUFvYkdWdUlENGdNaWtnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRndpYjI1bElHOW1JRndpTG1OdmJtTmhkQ2gwYUdsdVp5d2dYQ0lnWENJcExtTnZibU5oZENobGVIQmxZM1JsWkM1emJHbGpaU2d3TENCc1pXNGdMU0F4S1M1cWIybHVLQ2NzSUNjcExDQmNJaXdnYjNJZ1hDSXBJQ3NnWlhod1pXTjBaV1JiYkdWdUlDMGdNVjA3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2hzWlc0Z1BUMDlJRElwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJjSW05dVpTQnZaaUJjSWk1amIyNWpZWFFvZEdocGJtY3NJRndpSUZ3aUtTNWpiMjVqWVhRb1pYaHdaV04wWldSYk1GMHNJRndpSUc5eUlGd2lLUzVqYjI1allYUW9aWGh3WldOMFpXUmJNVjBwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1hDSnZaaUJjSWk1amIyNWpZWFFvZEdocGJtY3NJRndpSUZ3aUtTNWpiMjVqWVhRb1pYaHdaV04wWldSYk1GMHBPMXh1SUNBZ0lIMWNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnlaWFIxY200Z1hDSnZaaUJjSWk1amIyNWpZWFFvZEdocGJtY3NJRndpSUZ3aUtTNWpiMjVqWVhRb1UzUnlhVzVuS0dWNGNHVmpkR1ZrS1NrN1hHNGdJSDFjYm4wZ0x5OGdhSFIwY0hNNkx5OWtaWFpsYkc5d1pYSXViVzk2YVd4c1lTNXZjbWN2Wlc0dFZWTXZaRzlqY3k5WFpXSXZTbUYyWVZOamNtbHdkQzlTWldabGNtVnVZMlV2UjJ4dlltRnNYMDlpYW1WamRITXZVM1J5YVc1bkwzTjBZWEowYzFkcGRHaGNibHh1WEc1bWRXNWpkR2x2YmlCemRHRnlkSE5YYVhSb0tITjBjaXdnYzJWaGNtTm9MQ0J3YjNNcElIdGNiaUFnY21WMGRYSnVJSE4wY2k1emRXSnpkSElvSVhCdmN5QjhmQ0J3YjNNZ1BDQXdJRDhnTUNBNklDdHdiM01zSUhObFlYSmphQzVzWlc1bmRHZ3BJRDA5UFNCelpXRnlZMmc3WEc1OUlDOHZJR2gwZEhCek9pOHZaR1YyWld4dmNHVnlMbTF2ZW1sc2JHRXViM0puTDJWdUxWVlRMMlJ2WTNNdlYyVmlMMHBoZG1GVFkzSnBjSFF2VW1WbVpYSmxibU5sTDBkc2IySmhiRjlQWW1wbFkzUnpMMU4wY21sdVp5OWxibVJ6VjJsMGFGeHVYRzVjYm1aMWJtTjBhVzl1SUdWdVpITlhhWFJvS0hOMGNpd2djMlZoY21Ob0xDQjBhR2x6WDJ4bGJpa2dlMXh1SUNCcFppQW9kR2hwYzE5c1pXNGdQVDA5SUhWdVpHVm1hVzVsWkNCOGZDQjBhR2x6WDJ4bGJpQStJSE4wY2k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0IwYUdselgyeGxiaUE5SUhOMGNpNXNaVzVuZEdnN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2MzUnlMbk4xWW5OMGNtbHVaeWgwYUdselgyeGxiaUF0SUhObFlYSmphQzVzWlc1bmRHZ3NJSFJvYVhOZmJHVnVLU0E5UFQwZ2MyVmhjbU5vTzF4dWZTQXZMeUJvZEhSd2N6b3ZMMlJsZG1Wc2IzQmxjaTV0YjNwcGJHeGhMbTl5Wnk5bGJpMVZVeTlrYjJOekwxZGxZaTlLWVhaaFUyTnlhWEIwTDFKbFptVnlaVzVqWlM5SGJHOWlZV3hmVDJKcVpXTjBjeTlUZEhKcGJtY3ZhVzVqYkhWa1pYTmNibHh1WEc1bWRXNWpkR2x2YmlCcGJtTnNkV1JsY3loemRISXNJSE5sWVhKamFDd2djM1JoY25RcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCemRHRnlkQ0FoUFQwZ0oyNTFiV0psY2ljcElIdGNiaUFnSUNCemRHRnlkQ0E5SURBN1hHNGdJSDFjYmx4dUlDQnBaaUFvYzNSaGNuUWdLeUJ6WldGeVkyZ3ViR1Z1WjNSb0lENGdjM1J5TG14bGJtZDBhQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCeVpYUjFjbTRnYzNSeUxtbHVaR1Y0VDJZb2MyVmhjbU5vTENCemRHRnlkQ2tnSVQwOUlDMHhPMXh1SUNCOVhHNTlYRzVjYm1OeVpXRjBaVVZ5Y205eVZIbHdaU2duUlZKU1gwRk5Ra2xIVlU5VlUxOUJVa2RWVFVWT1ZDY3NJQ2RVYUdVZ1hDSWxjMXdpSUdGeVozVnRaVzUwSUdseklHRnRZbWxuZFc5MWN5NGdKWE1uTENCVWVYQmxSWEp5YjNJcE8xeHVZM0psWVhSbFJYSnliM0pVZVhCbEtDZEZVbEpmU1U1V1FVeEpSRjlCVWtkZlZGbFFSU2NzSUdaMWJtTjBhVzl1SUNodVlXMWxMQ0JsZUhCbFkzUmxaQ3dnWVdOMGRXRnNLU0I3WEc0Z0lHbG1JQ2hoYzNObGNuUWdQVDA5SUhWdVpHVm1hVzVsWkNrZ1lYTnpaWEowSUQwZ2NtVnhkV2x5WlNnbkxpNHZZWE56WlhKMEp5azdYRzRnSUdGemMyVnlkQ2gwZVhCbGIyWWdibUZ0WlNBOVBUMGdKM04wY21sdVp5Y3NJRndpSjI1aGJXVW5JRzExYzNRZ1ltVWdZU0J6ZEhKcGJtZGNJaWs3SUM4dklHUmxkR1Z5YldsdVpYSTZJQ2R0ZFhOMElHSmxKeUJ2Y2lBbmJYVnpkQ0J1YjNRZ1ltVW5YRzVjYmlBZ2RtRnlJR1JsZEdWeWJXbHVaWEk3WEc1Y2JpQWdhV1lnS0hSNWNHVnZaaUJsZUhCbFkzUmxaQ0E5UFQwZ0ozTjBjbWx1WnljZ0ppWWdjM1JoY25SelYybDBhQ2hsZUhCbFkzUmxaQ3dnSjI1dmRDQW5LU2tnZTF4dUlDQWdJR1JsZEdWeWJXbHVaWElnUFNBbmJYVnpkQ0J1YjNRZ1ltVW5PMXh1SUNBZ0lHVjRjR1ZqZEdWa0lEMGdaWGh3WldOMFpXUXVjbVZ3YkdGalpTZ3ZYbTV2ZENBdkxDQW5KeWs3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnWkdWMFpYSnRhVzVsY2lBOUlDZHRkWE4wSUdKbEp6dGNiaUFnZlZ4dVhHNGdJSFpoY2lCdGMyYzdYRzVjYmlBZ2FXWWdLR1Z1WkhOWGFYUm9LRzVoYldVc0lDY2dZWEpuZFcxbGJuUW5LU2tnZTF4dUlDQWdJQzh2SUVadmNpQmpZWE5sY3lCc2FXdGxJQ2RtYVhKemRDQmhjbWQxYldWdWRDZGNiaUFnSUNCdGMyY2dQU0JjSWxSb1pTQmNJaTVqYjI1allYUW9ibUZ0WlN3Z1hDSWdYQ0lwTG1OdmJtTmhkQ2hrWlhSbGNtMXBibVZ5TENCY0lpQmNJaWt1WTI5dVkyRjBLRzl1WlU5bUtHVjRjR1ZqZEdWa0xDQW5kSGx3WlNjcEtUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQjJZWElnZEhsd1pTQTlJR2x1WTJ4MVpHVnpLRzVoYldVc0lDY3VKeWtnUHlBbmNISnZjR1Z5ZEhrbklEb2dKMkZ5WjNWdFpXNTBKenRjYmlBZ0lDQnRjMmNnUFNCY0lsUm9aU0JjWEZ3aVhDSXVZMjl1WTJGMEtHNWhiV1VzSUZ3aVhGeGNJaUJjSWlrdVkyOXVZMkYwS0hSNWNHVXNJRndpSUZ3aUtTNWpiMjVqWVhRb1pHVjBaWEp0YVc1bGNpd2dYQ0lnWENJcExtTnZibU5oZENodmJtVlBaaWhsZUhCbFkzUmxaQ3dnSjNSNWNHVW5LU2s3WEc0Z0lIMGdMeThnVkU5RVR5aENjbWxrWjJWQlVpazZJRWx0Y0hKdmRtVWdkR2hsSUc5MWRIQjFkQ0JpZVNCemFHOTNhVzVuSUdCdWRXeHNZQ0JoYm1RZ2MybHRhV3hoY2k1Y2JseHVYRzRnSUcxelp5QXJQU0JjSWk0Z1VtVmpaV2wyWldRZ2RIbHdaU0JjSWk1amIyNWpZWFFvWDNSNWNHVnZaaWhoWTNSMVlXd3BLVHRjYmlBZ2NtVjBkWEp1SUcxelp6dGNibjBzSUZSNWNHVkZjbkp2Y2lrN1hHNWpjbVZoZEdWRmNuSnZjbFI1Y0dVb0owVlNVbDlKVGxaQlRFbEVYMEZTUjE5V1FVeFZSU2NzSUdaMWJtTjBhVzl1SUNodVlXMWxMQ0IyWVd4MVpTa2dlMXh1SUNCMllYSWdjbVZoYzI5dUlEMGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQStJRElnSmlZZ1lYSm5kVzFsYm5Seld6SmRJQ0U5UFNCMWJtUmxabWx1WldRZ1B5QmhjbWQxYldWdWRITmJNbDBnT2lBbmFYTWdhVzUyWVd4cFpDYzdYRzRnSUdsbUlDaDFkR2xzSUQwOVBTQjFibVJsWm1sdVpXUXBJSFYwYVd3Z1BTQnlaWEYxYVhKbEtDZDFkR2xzTHljcE8xeHVJQ0IyWVhJZ2FXNXpjR1ZqZEdWa0lEMGdkWFJwYkM1cGJuTndaV04wS0haaGJIVmxLVHRjYmx4dUlDQnBaaUFvYVc1emNHVmpkR1ZrTG14bGJtZDBhQ0ErSURFeU9Da2dlMXh1SUNBZ0lHbHVjM0JsWTNSbFpDQTlJRndpWENJdVkyOXVZMkYwS0dsdWMzQmxZM1JsWkM1emJHbGpaU2d3TENBeE1qZ3BMQ0JjSWk0dUxsd2lLVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJjSWxSb1pTQmhjbWQxYldWdWRDQW5YQ0l1WTI5dVkyRjBLRzVoYldVc0lGd2lKeUJjSWlrdVkyOXVZMkYwS0hKbFlYTnZiaXdnWENJdUlGSmxZMlZwZG1Wa0lGd2lLUzVqYjI1allYUW9hVzV6Y0dWamRHVmtLVHRjYm4wc0lGUjVjR1ZGY25KdmNpd2dVbUZ1WjJWRmNuSnZjaWs3WEc1amNtVmhkR1ZGY25KdmNsUjVjR1VvSjBWU1VsOUpUbFpCVEVsRVgxSkZWRlZTVGw5V1FVeFZSU2NzSUdaMWJtTjBhVzl1SUNocGJuQjFkQ3dnYm1GdFpTd2dkbUZzZFdVcElIdGNiaUFnZG1GeUlIUjVjR1U3WEc1Y2JpQWdhV1lnS0haaGJIVmxJQ1ltSUhaaGJIVmxMbU52Ym5OMGNuVmpkRzl5SUNZbUlIWmhiSFZsTG1OdmJuTjBjblZqZEc5eUxtNWhiV1VwSUh0Y2JpQWdJQ0IwZVhCbElEMGdYQ0pwYm5OMFlXNWpaU0J2WmlCY0lpNWpiMjVqWVhRb2RtRnNkV1V1WTI5dWMzUnlkV04wYjNJdWJtRnRaU2s3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnZEhsd1pTQTlJRndpZEhsd1pTQmNJaTVqYjI1allYUW9YM1I1Y0dWdlppaDJZV3gxWlNrcE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlGd2lSWGh3WldOMFpXUWdYQ0l1WTI5dVkyRjBLR2x1Y0hWMExDQmNJaUIwYnlCaVpTQnlaWFIxY201bFpDQm1jbTl0SUhSb1pTQmNYRndpWENJcExtTnZibU5oZENodVlXMWxMQ0JjSWx4Y1hDSmNJaWtnS3lCY0lpQm1kVzVqZEdsdmJpQmlkWFFnWjI5MElGd2lMbU52Ym1OaGRDaDBlWEJsTENCY0lpNWNJaWs3WEc1OUxDQlVlWEJsUlhKeWIzSXBPMXh1WTNKbFlYUmxSWEp5YjNKVWVYQmxLQ2RGVWxKZlRVbFRVMGxPUjE5QlVrZFRKeXdnWm5WdVkzUnBiMjRnS0NrZ2UxeHVJQ0JtYjNJZ0tIWmhjaUJmYkdWdUlEMGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFDd2dZWEpuY3lBOUlHNWxkeUJCY25KaGVTaGZiR1Z1S1N3Z1gydGxlU0E5SURBN0lGOXJaWGtnUENCZmJHVnVPeUJmYTJWNUt5c3BJSHRjYmlBZ0lDQmhjbWR6VzE5clpYbGRJRDBnWVhKbmRXMWxiblJ6VzE5clpYbGRPMXh1SUNCOVhHNWNiaUFnYVdZZ0tHRnpjMlZ5ZENBOVBUMGdkVzVrWldacGJtVmtLU0JoYzNObGNuUWdQU0J5WlhGMWFYSmxLQ2N1TGk5aGMzTmxjblFuS1R0Y2JpQWdZWE56WlhKMEtHRnlaM011YkdWdVozUm9JRDRnTUN3Z0owRjBJR3hsWVhOMElHOXVaU0JoY21jZ2JtVmxaSE1nZEc4Z1ltVWdjM0JsWTJsbWFXVmtKeWs3WEc0Z0lIWmhjaUJ0YzJjZ1BTQW5WR2hsSUNjN1hHNGdJSFpoY2lCc1pXNGdQU0JoY21kekxteGxibWQwYUR0Y2JpQWdZWEpuY3lBOUlHRnlaM011YldGd0tHWjFibU4wYVc5dUlDaGhLU0I3WEc0Z0lDQWdjbVYwZFhKdUlGd2lYRnhjSWx3aUxtTnZibU5oZENoaExDQmNJbHhjWENKY0lpazdYRzRnSUgwcE8xeHVYRzRnSUhOM2FYUmphQ0FvYkdWdUtTQjdYRzRnSUNBZ1kyRnpaU0F4T2x4dUlDQWdJQ0FnYlhObklDczlJRndpWENJdVkyOXVZMkYwS0dGeVozTmJNRjBzSUZ3aUlHRnlaM1Z0Wlc1MFhDSXBPMXh1SUNBZ0lDQWdZbkpsWVdzN1hHNWNiaUFnSUNCallYTmxJREk2WEc0Z0lDQWdJQ0J0YzJjZ0t6MGdYQ0pjSWk1amIyNWpZWFFvWVhKbmMxc3dYU3dnWENJZ1lXNWtJRndpS1M1amIyNWpZWFFvWVhKbmMxc3hYU3dnWENJZ1lYSm5kVzFsYm5SelhDSXBPMXh1SUNBZ0lDQWdZbkpsWVdzN1hHNWNiaUFnSUNCa1pXWmhkV3gwT2x4dUlDQWdJQ0FnYlhObklDczlJR0Z5WjNNdWMyeHBZMlVvTUN3Z2JHVnVJQzBnTVNrdWFtOXBiaWduTENBbktUdGNiaUFnSUNBZ0lHMXpaeUFyUFNCY0lpd2dZVzVrSUZ3aUxtTnZibU5oZENoaGNtZHpXMnhsYmlBdElERmRMQ0JjSWlCaGNtZDFiV1Z1ZEhOY0lpazdYRzRnSUNBZ0lDQmljbVZoYXp0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCY0lsd2lMbU52Ym1OaGRDaHRjMmNzSUZ3aUlHMTFjM1FnWW1VZ2MzQmxZMmxtYVdWa1hDSXBPMXh1ZlN3Z1ZIbHdaVVZ5Y205eUtUdGNibTF2WkhWc1pTNWxlSEJ2Y25SekxtTnZaR1Z6SUQwZ1kyOWtaWE03SWl3aUx5OGdRM1Z5Y21WdWRHeDVJR2x1SUhONWJtTWdkMmwwYUNCT2IyUmxMbXB6SUd4cFlpOXBiblJsY201aGJDOTFkR2xzTDJOdmJYQmhjbWx6YjI1ekxtcHpYRzR2THlCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdmJtOWtaV3B6TDI1dlpHVXZZMjl0YldsMEx6RXhNbU5qTjJNeU56VTFNVEkxTkdGaE1tSXhOekE1T0daaU56YzBPRFkzWmpBMVpXUXdaRGxjYmlkMWMyVWdjM1J5YVdOMEp6dGNibHh1Wm5WdVkzUnBiMjRnWDNOc2FXTmxaRlJ2UVhKeVlYa29ZWEp5TENCcEtTQjdJSEpsZEhWeWJpQmZZWEp5WVhsWGFYUm9TRzlzWlhNb1lYSnlLU0I4ZkNCZmFYUmxjbUZpYkdWVWIwRnljbUY1VEdsdGFYUW9ZWEp5TENCcEtTQjhmQ0JmYm05dVNYUmxjbUZpYkdWU1pYTjBLQ2s3SUgxY2JseHVablZ1WTNScGIyNGdYMjV2YmtsMFpYSmhZbXhsVW1WemRDZ3BJSHNnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2loY0lrbHVkbUZzYVdRZ1lYUjBaVzF3ZENCMGJ5QmtaWE4wY25WamRIVnlaU0J1YjI0dGFYUmxjbUZpYkdVZ2FXNXpkR0Z1WTJWY0lpazdJSDFjYmx4dVpuVnVZM1JwYjI0Z1gybDBaWEpoWW14bFZHOUJjbkpoZVV4cGJXbDBLR0Z5Y2l3Z2FTa2dleUIyWVhJZ1gyRnljaUE5SUZ0ZE95QjJZWElnWDI0Z1BTQjBjblZsT3lCMllYSWdYMlFnUFNCbVlXeHpaVHNnZG1GeUlGOWxJRDBnZFc1a1pXWnBibVZrT3lCMGNua2dleUJtYjNJZ0tIWmhjaUJmYVNBOUlHRnljbHRUZVcxaWIyd3VhWFJsY21GMGIzSmRLQ2tzSUY5ek95QWhLRjl1SUQwZ0tGOXpJRDBnWDJrdWJtVjRkQ2dwS1M1a2IyNWxLVHNnWDI0Z1BTQjBjblZsS1NCN0lGOWhjbkl1Y0hWemFDaGZjeTUyWVd4MVpTazdJR2xtSUNocElDWW1JRjloY25JdWJHVnVaM1JvSUQwOVBTQnBLU0JpY21WaGF6c2dmU0I5SUdOaGRHTm9JQ2hsY25JcElIc2dYMlFnUFNCMGNuVmxPeUJmWlNBOUlHVnljanNnZlNCbWFXNWhiR3g1SUhzZ2RISjVJSHNnYVdZZ0tDRmZiaUFtSmlCZmFWdGNJbkpsZEhWeWJsd2lYU0FoUFNCdWRXeHNLU0JmYVZ0Y0luSmxkSFZ5Ymx3aVhTZ3BPeUI5SUdacGJtRnNiSGtnZXlCcFppQW9YMlFwSUhSb2NtOTNJRjlsT3lCOUlIMGdjbVYwZFhKdUlGOWhjbkk3SUgxY2JseHVablZ1WTNScGIyNGdYMkZ5Y21GNVYybDBhRWh2YkdWektHRnljaWtnZXlCcFppQW9RWEp5WVhrdWFYTkJjbkpoZVNoaGNuSXBLU0J5WlhSMWNtNGdZWEp5T3lCOVhHNWNibVoxYm1OMGFXOXVJRjkwZVhCbGIyWW9iMkpxS1NCN0lHbG1JQ2gwZVhCbGIyWWdVM2x0WW05c0lEMDlQU0JjSW1aMWJtTjBhVzl1WENJZ0ppWWdkSGx3Wlc5bUlGTjViV0p2YkM1cGRHVnlZWFJ2Y2lBOVBUMGdYQ0p6ZVcxaWIyeGNJaWtnZXlCZmRIbHdaVzltSUQwZ1puVnVZM1JwYjI0Z1gzUjVjR1Z2Wmlodlltb3BJSHNnY21WMGRYSnVJSFI1Y0dWdlppQnZZbW83SUgwN0lIMGdaV3h6WlNCN0lGOTBlWEJsYjJZZ1BTQm1kVzVqZEdsdmJpQmZkSGx3Wlc5bUtHOWlhaWtnZXlCeVpYUjFjbTRnYjJKcUlDWW1JSFI1Y0dWdlppQlRlVzFpYjJ3Z1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQnZZbW91WTI5dWMzUnlkV04wYjNJZ1BUMDlJRk41YldKdmJDQW1KaUJ2WW1vZ0lUMDlJRk41YldKdmJDNXdjbTkwYjNSNWNHVWdQeUJjSW5ONWJXSnZiRndpSURvZ2RIbHdaVzltSUc5aWFqc2dmVHNnZlNCeVpYUjFjbTRnWDNSNWNHVnZaaWh2WW1vcE95QjlYRzVjYm5aaGNpQnlaV2RsZUVac1lXZHpVM1Z3Y0c5eWRHVmtJRDBnTDJFdlp5NW1iR0ZuY3lBaFBUMGdkVzVrWldacGJtVmtPMXh1WEc1MllYSWdZWEp5WVhsR2NtOXRVMlYwSUQwZ1puVnVZM1JwYjI0Z1lYSnlZWGxHY205dFUyVjBLSE5sZENrZ2UxeHVJQ0IyWVhJZ1lYSnlZWGtnUFNCYlhUdGNiaUFnYzJWMExtWnZja1ZoWTJnb1puVnVZM1JwYjI0Z0tIWmhiSFZsS1NCN1hHNGdJQ0FnY21WMGRYSnVJR0Z5Y21GNUxuQjFjMmdvZG1Gc2RXVXBPMXh1SUNCOUtUdGNiaUFnY21WMGRYSnVJR0Z5Y21GNU8xeHVmVHRjYmx4dWRtRnlJR0Z5Y21GNVJuSnZiVTFoY0NBOUlHWjFibU4wYVc5dUlHRnljbUY1Um5KdmJVMWhjQ2h0WVhBcElIdGNiaUFnZG1GeUlHRnljbUY1SUQwZ1cxMDdYRzRnSUcxaGNDNW1iM0pGWVdOb0tHWjFibU4wYVc5dUlDaDJZV3gxWlN3Z2EyVjVLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHRnljbUY1TG5CMWMyZ29XMnRsZVN3Z2RtRnNkV1ZkS1R0Y2JpQWdmU2s3WEc0Z0lISmxkSFZ5YmlCaGNuSmhlVHRjYm4wN1hHNWNiblpoY2lCdlltcGxZM1JKY3lBOUlFOWlhbVZqZEM1cGN5QS9JRTlpYW1WamRDNXBjeUE2SUhKbGNYVnBjbVVvSjI5aWFtVmpkQzFwY3ljcE8xeHVkbUZ5SUc5aWFtVmpkRWRsZEU5M2JsQnliM0JsY25SNVUzbHRZbTlzY3lBOUlFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVk41YldKdmJITWdQeUJQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsVGVXMWliMnh6SURvZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNCeVpYUjFjbTRnVzEwN1hHNTlPMXh1ZG1GeUlHNTFiV0psY2tselRtRk9JRDBnVG5WdFltVnlMbWx6VG1GT0lEOGdUblZ0WW1WeUxtbHpUbUZPSURvZ2NtVnhkV2x5WlNnbmFYTXRibUZ1SnlrN1hHNWNibVoxYm1OMGFXOXVJSFZ1WTNWeWNubFVhR2x6S0dZcElIdGNiaUFnY21WMGRYSnVJR1l1WTJGc2JDNWlhVzVrS0dZcE8xeHVmVnh1WEc1MllYSWdhR0Z6VDNkdVVISnZjR1Z5ZEhrZ1BTQjFibU4xY25KNVZHaHBjeWhQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMbWhoYzA5M2JsQnliM0JsY25SNUtUdGNiblpoY2lCd2NtOXdaWEowZVVselJXNTFiV1Z5WVdKc1pTQTlJSFZ1WTNWeWNubFVhR2x6S0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1Y0hKdmNHVnlkSGxKYzBWdWRXMWxjbUZpYkdVcE8xeHVkbUZ5SUc5aWFtVmpkRlJ2VTNSeWFXNW5JRDBnZFc1amRYSnllVlJvYVhNb1QySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1WnlrN1hHNWNiblpoY2lCZmNtVnhkV2x5WlNSMGVYQmxjeUE5SUhKbGNYVnBjbVVvSjNWMGFXd3ZKeWt1ZEhsd1pYTXNYRzRnSUNBZ2FYTkJibmxCY25KaGVVSjFabVpsY2lBOUlGOXlaWEYxYVhKbEpIUjVjR1Z6TG1selFXNTVRWEp5WVhsQ2RXWm1aWElzWEc0Z0lDQWdhWE5CY25KaGVVSjFabVpsY2xacFpYY2dQU0JmY21WeGRXbHlaU1IwZVhCbGN5NXBjMEZ5Y21GNVFuVm1abVZ5Vm1sbGR5eGNiaUFnSUNCcGMwUmhkR1VnUFNCZmNtVnhkV2x5WlNSMGVYQmxjeTVwYzBSaGRHVXNYRzRnSUNBZ2FYTk5ZWEFnUFNCZmNtVnhkV2x5WlNSMGVYQmxjeTVwYzAxaGNDeGNiaUFnSUNCcGMxSmxaMFY0Y0NBOUlGOXlaWEYxYVhKbEpIUjVjR1Z6TG1selVtVm5SWGh3TEZ4dUlDQWdJR2x6VTJWMElEMGdYM0psY1hWcGNtVWtkSGx3WlhNdWFYTlRaWFFzWEc0Z0lDQWdhWE5PWVhScGRtVkZjbkp2Y2lBOUlGOXlaWEYxYVhKbEpIUjVjR1Z6TG1selRtRjBhWFpsUlhKeWIzSXNYRzRnSUNBZ2FYTkNiM2hsWkZCeWFXMXBkR2wyWlNBOUlGOXlaWEYxYVhKbEpIUjVjR1Z6TG1selFtOTRaV1JRY21sdGFYUnBkbVVzWEc0Z0lDQWdhWE5PZFcxaVpYSlBZbXBsWTNRZ1BTQmZjbVZ4ZFdseVpTUjBlWEJsY3k1cGMwNTFiV0psY2s5aWFtVmpkQ3hjYmlBZ0lDQnBjMU4wY21sdVowOWlhbVZqZENBOUlGOXlaWEYxYVhKbEpIUjVjR1Z6TG1selUzUnlhVzVuVDJKcVpXTjBMRnh1SUNBZ0lHbHpRbTl2YkdWaGJrOWlhbVZqZENBOUlGOXlaWEYxYVhKbEpIUjVjR1Z6TG1selFtOXZiR1ZoYms5aWFtVmpkQ3hjYmlBZ0lDQnBjMEpwWjBsdWRFOWlhbVZqZENBOUlGOXlaWEYxYVhKbEpIUjVjR1Z6TG1selFtbG5TVzUwVDJKcVpXTjBMRnh1SUNBZ0lHbHpVM2x0WW05c1QySnFaV04wSUQwZ1gzSmxjWFZwY21Va2RIbHdaWE11YVhOVGVXMWliMnhQWW1wbFkzUXNYRzRnSUNBZ2FYTkdiRzloZERNeVFYSnlZWGtnUFNCZmNtVnhkV2x5WlNSMGVYQmxjeTVwYzBac2IyRjBNekpCY25KaGVTeGNiaUFnSUNCcGMwWnNiMkYwTmpSQmNuSmhlU0E5SUY5eVpYRjFhWEpsSkhSNWNHVnpMbWx6Um14dllYUTJORUZ5Y21GNU8xeHVYRzVtZFc1amRHbHZiaUJwYzA1dmJrbHVaR1Y0S0d0bGVTa2dlMXh1SUNCcFppQW9hMlY1TG14bGJtZDBhQ0E5UFQwZ01DQjhmQ0JyWlhrdWJHVnVaM1JvSUQ0Z01UQXBJSEpsZEhWeWJpQjBjblZsTzF4dVhHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYTJWNUxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdkbUZ5SUdOdlpHVWdQU0JyWlhrdVkyaGhja052WkdWQmRDaHBLVHRjYmlBZ0lDQnBaaUFvWTI5a1pTQThJRFE0SUh4OElHTnZaR1VnUGlBMU55a2djbVYwZFhKdUlIUnlkV1U3WEc0Z0lIMGdMeThnVkdobElHMWhlR2x0ZFcwZ2MybDZaU0JtYjNJZ1lXNGdZWEp5WVhrZ2FYTWdNaUFxS2lBek1pQXRNUzVjYmx4dVhHNGdJSEpsZEhWeWJpQnJaWGt1YkdWdVozUm9JRDA5UFNBeE1DQW1KaUJyWlhrZ1BqMGdUV0YwYUM1d2IzY29NaXdnTXpJcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCblpYUlBkMjVPYjI1SmJtUmxlRkJ5YjNCbGNuUnBaWE1vZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUU5aWFtVmpkQzVyWlhsektIWmhiSFZsS1M1bWFXeDBaWElvYVhOT2IyNUpibVJsZUNrdVkyOXVZMkYwS0c5aWFtVmpkRWRsZEU5M2JsQnliM0JsY25SNVUzbHRZbTlzY3loMllXeDFaU2t1Wm1sc2RHVnlLRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVjSEp2Y0dWeWRIbEpjMFZ1ZFcxbGNtRmliR1V1WW1sdVpDaDJZV3gxWlNrcEtUdGNibjBnTHk4Z1ZHRnJaVzRnWm5KdmJTQm9kSFJ3Y3pvdkwyZHBkR2gxWWk1amIyMHZabVZ5YjNOekwySjFabVpsY2k5aWJHOWlMelk0TUdVNVpUVmxORGc0WmpJeVlXRmpNamMxT1RsaE5UZGtZemcwTkdFMk16RTFPVEk0WkdRdmFXNWtaWGd1YW5OY2JpOHZJRzl5YVdkcGJtRnNJRzV2ZEdsalpUcGNibHh1THlvaFhHNGdLaUJVYUdVZ1luVm1abVZ5SUcxdlpIVnNaU0JtY205dElHNXZaR1V1YW5Nc0lHWnZjaUIwYUdVZ1luSnZkM05sY2k1Y2JpQXFYRzRnS2lCQVlYVjBhRzl5SUNBZ1JtVnliM056SUVGaWIzVnJhR0ZrYVdwbGFDQThabVZ5YjNOelFHWmxjbTl6Y3k1dmNtYytJRHhvZEhSd09pOHZabVZ5YjNOekxtOXlaejVjYmlBcUlFQnNhV05sYm5ObElDQk5TVlJjYmlBcUwxeHVYRzVjYm1aMWJtTjBhVzl1SUdOdmJYQmhjbVVvWVN3Z1lpa2dlMXh1SUNCcFppQW9ZU0E5UFQwZ1lpa2dlMXh1SUNBZ0lISmxkSFZ5YmlBd08xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhnZ1BTQmhMbXhsYm1kMGFEdGNiaUFnZG1GeUlIa2dQU0JpTG14bGJtZDBhRHRjYmx4dUlDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JHVnVJRDBnVFdGMGFDNXRhVzRvZUN3Z2VTazdJR2tnUENCc1pXNDdJQ3NyYVNrZ2UxeHVJQ0FnSUdsbUlDaGhXMmxkSUNFOVBTQmlXMmxkS1NCN1hHNGdJQ0FnSUNCNElEMGdZVnRwWFR0Y2JpQWdJQ0FnSUhrZ1BTQmlXMmxkTzF4dUlDQWdJQ0FnWW5KbFlXczdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdhV1lnS0hnZ1BDQjVLU0I3WEc0Z0lDQWdjbVYwZFhKdUlDMHhPMXh1SUNCOVhHNWNiaUFnYVdZZ0tIa2dQQ0I0S1NCN1hHNGdJQ0FnY21WMGRYSnVJREU3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnTUR0Y2JuMWNibHh1ZG1GeUlFOU9URmxmUlU1VlRVVlNRVUpNUlNBOUlIVnVaR1ZtYVc1bFpEdGNiblpoY2lCclUzUnlhV04wSUQwZ2RISjFaVHRjYm5aaGNpQnJURzl2YzJVZ1BTQm1ZV3h6WlR0Y2JuWmhjaUJyVG05SmRHVnlZWFJ2Y2lBOUlEQTdYRzUyWVhJZ2EwbHpRWEp5WVhrZ1BTQXhPMXh1ZG1GeUlHdEpjMU5sZENBOUlESTdYRzUyWVhJZ2EwbHpUV0Z3SUQwZ016c2dMeThnUTJobFkyc2dhV1lnZEdobGVTQm9ZWFpsSUhSb1pTQnpZVzFsSUhOdmRYSmpaU0JoYm1RZ1pteGhaM05jYmx4dVpuVnVZM1JwYjI0Z1lYSmxVMmx0YVd4aGNsSmxaMFY0Y0hNb1lTd2dZaWtnZTF4dUlDQnlaWFIxY200Z2NtVm5aWGhHYkdGbmMxTjFjSEJ2Y25SbFpDQS9JR0V1YzI5MWNtTmxJRDA5UFNCaUxuTnZkWEpqWlNBbUppQmhMbVpzWVdkeklEMDlQU0JpTG1ac1lXZHpJRG9nVW1WblJYaHdMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaeTVqWVd4c0tHRXBJRDA5UFNCU1pXZEZlSEF1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29ZaWs3WEc1OVhHNWNibVoxYm1OMGFXOXVJR0Z5WlZOcGJXbHNZWEpHYkc5aGRFRnljbUY1Y3loaExDQmlLU0I3WEc0Z0lHbG1JQ2hoTG1KNWRHVk1aVzVuZEdnZ0lUMDlJR0l1WW5sMFpVeGxibWQwYUNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnZlZ4dVhHNGdJR1p2Y2lBb2RtRnlJRzltWm5ObGRDQTlJREE3SUc5bVpuTmxkQ0E4SUdFdVlubDBaVXhsYm1kMGFEc2diMlptYzJWMEt5c3BJSHRjYmlBZ0lDQnBaaUFvWVZ0dlptWnpaWFJkSUNFOVBTQmlXMjltWm5ObGRGMHBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZEhKMVpUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1lYSmxVMmx0YVd4aGNsUjVjR1ZrUVhKeVlYbHpLR0VzSUdJcElIdGNiaUFnYVdZZ0tHRXVZbmwwWlV4bGJtZDBhQ0FoUFQwZ1lpNWllWFJsVEdWdVozUm9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdOdmJYQmhjbVVvYm1WM0lGVnBiblE0UVhKeVlYa29ZUzVpZFdabVpYSXNJR0V1WW5sMFpVOW1abk5sZEN3Z1lTNWllWFJsVEdWdVozUm9LU3dnYm1WM0lGVnBiblE0UVhKeVlYa29ZaTVpZFdabVpYSXNJR0l1WW5sMFpVOW1abk5sZEN3Z1lpNWllWFJsVEdWdVozUm9LU2tnUFQwOUlEQTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHRnlaVVZ4ZFdGc1FYSnlZWGxDZFdabVpYSnpLR0oxWmpFc0lHSjFaaklwSUh0Y2JpQWdjbVYwZFhKdUlHSjFaakV1WW5sMFpVeGxibWQwYUNBOVBUMGdZblZtTWk1aWVYUmxUR1Z1WjNSb0lDWW1JR052YlhCaGNtVW9ibVYzSUZWcGJuUTRRWEp5WVhrb1luVm1NU2tzSUc1bGR5QlZhVzUwT0VGeWNtRjVLR0oxWmpJcEtTQTlQVDBnTUR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYVhORmNYVmhiRUp2ZUdWa1VISnBiV2wwYVhabEtIWmhiREVzSUhaaGJESXBJSHRjYmlBZ2FXWWdLR2x6VG5WdFltVnlUMkpxWldOMEtIWmhiREVwS1NCN1hHNGdJQ0FnY21WMGRYSnVJR2x6VG5WdFltVnlUMkpxWldOMEtIWmhiRElwSUNZbUlHOWlhbVZqZEVsektFNTFiV0psY2k1d2NtOTBiM1I1Y0dVdWRtRnNkV1ZQWmk1allXeHNLSFpoYkRFcExDQk9kVzFpWlhJdWNISnZkRzkwZVhCbExuWmhiSFZsVDJZdVkyRnNiQ2gyWVd3eUtTazdYRzRnSUgxY2JseHVJQ0JwWmlBb2FYTlRkSEpwYm1kUFltcGxZM1FvZG1Gc01Ta3BJSHRjYmlBZ0lDQnlaWFIxY200Z2FYTlRkSEpwYm1kUFltcGxZM1FvZG1Gc01pa2dKaVlnVTNSeWFXNW5MbkJ5YjNSdmRIbHdaUzUyWVd4MVpVOW1MbU5oYkd3b2RtRnNNU2tnUFQwOUlGTjBjbWx1Wnk1d2NtOTBiM1I1Y0dVdWRtRnNkV1ZQWmk1allXeHNLSFpoYkRJcE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0dselFtOXZiR1ZoYms5aWFtVmpkQ2gyWVd3eEtTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCcGMwSnZiMnhsWVc1UFltcGxZM1FvZG1Gc01pa2dKaVlnUW05dmJHVmhiaTV3Y205MGIzUjVjR1V1ZG1Gc2RXVlBaaTVqWVd4c0tIWmhiREVwSUQwOVBTQkNiMjlzWldGdUxuQnliM1J2ZEhsd1pTNTJZV3gxWlU5bUxtTmhiR3dvZG1Gc01pazdYRzRnSUgxY2JseHVJQ0JwWmlBb2FYTkNhV2RKYm5SUFltcGxZM1FvZG1Gc01Ta3BJSHRjYmlBZ0lDQnlaWFIxY200Z2FYTkNhV2RKYm5SUFltcGxZM1FvZG1Gc01pa2dKaVlnUW1sblNXNTBMbkJ5YjNSdmRIbHdaUzUyWVd4MVpVOW1MbU5oYkd3b2RtRnNNU2tnUFQwOUlFSnBaMGx1ZEM1d2NtOTBiM1I1Y0dVdWRtRnNkV1ZQWmk1allXeHNLSFpoYkRJcE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHbHpVM2x0WW05c1QySnFaV04wS0haaGJESXBJQ1ltSUZONWJXSnZiQzV3Y205MGIzUjVjR1V1ZG1Gc2RXVlBaaTVqWVd4c0tIWmhiREVwSUQwOVBTQlRlVzFpYjJ3dWNISnZkRzkwZVhCbExuWmhiSFZsVDJZdVkyRnNiQ2gyWVd3eUtUdGNibjBnTHk4Z1RtOTBaWE02SUZSNWNHVWdkR0ZuY3lCaGNtVWdhR2x6ZEc5eWFXTmhiQ0JiVzBOc1lYTnpYVjBnY0hKdmNHVnlkR2xsY3lCMGFHRjBJR05oYmlCaVpTQnpaWFFnWW5sY2JpOHZJRVoxYm1OMGFXOXVWR1Z0Y0d4aGRHVTZPbE5sZEVOc1lYTnpUbUZ0WlNncElHbHVJRU1yS3lCdmNpQlRlVzFpYjJ3dWRHOVRkSEpwYm1kVVlXY2dhVzRnU2xOY2JpOHZJR0Z1WkNCeVpYUnlhV1YyWldRZ2RYTnBibWNnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaeTVqWVd4c0tHOWlhaWtnYVc0Z1NsTmNiaTh2SUZObFpTQm9kSFJ3Y3pvdkwzUmpNemt1WjJsMGFIVmlMbWx2TDJWamJXRXlOakl2STNObFl5MXZZbXBsWTNRdWNISnZkRzkwZVhCbExuUnZjM1J5YVc1blhHNHZMeUJtYjNJZ1lTQnNhWE4wSUc5bUlIUmhaM01nY0hKbExXUmxabWx1WldRZ2FXNGdkR2hsSUhOd1pXTXVYRzR2THlCVWFHVnlaU0JoY21VZ2MyOXRaU0IxYm5Od1pXTnBabWxsWkNCMFlXZHpJR2x1SUhSb1pTQjNhV3hrSUhSdmJ5QW9aUzVuTGlCMGVYQmxaQ0JoY25KaGVTQjBZV2R6S1M1Y2JpOHZJRk5wYm1ObElIUmhaM01nWTJGdUlHSmxJR0ZzZEdWeVpXUXNJSFJvWlhrZ2IyNXNlU0J6WlhKMlpTQm1ZWE4wSUdaaGFXeDFjbVZ6WEc0dkwxeHVMeThnVkhsd1pXUWdZWEp5WVhseklHRnVaQ0JpZFdabVpYSnpJR0Z5WlNCamFHVmphMlZrSUdKNUlHTnZiWEJoY21sdVp5QjBhR1VnWTI5dWRHVnVkQ0JwYmlCMGFHVnBjbHh1THk4Z2RXNWtaWEpzZVdsdVp5QkJjbkpoZVVKMVptWmxjaTRnVkdocGN5QnZjSFJwYldsNllYUnBiMjRnY21WeGRXbHlaWE1nZEdoaGRDQnBkQ2R6WEc0dkx5QnlaV0Z6YjI1aFlteGxJSFJ2SUdsdWRHVnljSEpsZENCMGFHVnBjaUIxYm1SbGNteDVhVzVuSUcxbGJXOXllU0JwYmlCMGFHVWdjMkZ0WlNCM1lYa3NYRzR2THlCM2FHbGphQ0JwY3lCamFHVmphMlZrSUdKNUlHTnZiWEJoY21sdVp5QjBhR1ZwY2lCMGVYQmxJSFJoWjNNdVhHNHZMeUFvWlM1bkxpQmhJRlZwYm5RNFFYSnlZWGtnWVc1a0lHRWdWV2x1ZERFMlFYSnlZWGtnZDJsMGFDQjBhR1VnYzJGdFpTQnRaVzF2Y25rZ1kyOXVkR1Z1ZEZ4dUx5OGdZMjkxYkdRZ2MzUnBiR3dnWW1VZ1pHbG1abVZ5Wlc1MElHSmxZMkYxYzJVZ2RHaGxlU0IzYVd4c0lHSmxJR2x1ZEdWeWNISmxkR1ZrSUdScFptWmxjbVZ1ZEd4NUtTNWNiaTh2WEc0dkx5QkdiM0lnYzNSeWFXTjBJR052YlhCaGNtbHpiMjRzSUc5aWFtVmpkSE1nYzJodmRXeGtJR2hoZG1WY2JpOHZJR0VwSUZSb1pTQnpZVzFsSUdKMWFXeDBMV2x1SUhSNWNHVWdkR0ZuYzF4dUx5OGdZaWtnVkdobElITmhiV1VnY0hKdmRHOTBlWEJsY3k1Y2JseHVYRzVtZFc1amRHbHZiaUJwYm01bGNrUmxaWEJGY1hWaGJDaDJZV3d4TENCMllXd3lMQ0J6ZEhKcFkzUXNJRzFsYlc5ektTQjdYRzRnSUM4dklFRnNiQ0JwWkdWdWRHbGpZV3dnZG1Gc2RXVnpJR0Z5WlNCbGNYVnBkbUZzWlc1MExDQmhjeUJrWlhSbGNtMXBibVZrSUdKNUlEMDlQUzVjYmlBZ2FXWWdLSFpoYkRFZ1BUMDlJSFpoYkRJcElIdGNiaUFnSUNCcFppQW9kbUZzTVNBaFBUMGdNQ2tnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJQ0FnY21WMGRYSnVJSE4wY21samRDQS9JRzlpYW1WamRFbHpLSFpoYkRFc0lIWmhiRElwSURvZ2RISjFaVHRjYmlBZ2ZTQXZMeUJEYUdWamF5QnRiM0psSUdOc2IzTmxiSGtnYVdZZ2RtRnNNU0JoYm1RZ2RtRnNNaUJoY21VZ1pYRjFZV3d1WEc1Y2JseHVJQ0JwWmlBb2MzUnlhV04wS1NCN1hHNGdJQ0FnYVdZZ0tGOTBlWEJsYjJZb2RtRnNNU2tnSVQwOUlDZHZZbXBsWTNRbktTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2RIbHdaVzltSUhaaGJERWdQVDA5SUNkdWRXMWlaWEluSUNZbUlHNTFiV0psY2tselRtRk9LSFpoYkRFcElDWW1JRzUxYldKbGNrbHpUbUZPS0haaGJESXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2hmZEhsd1pXOW1LSFpoYkRJcElDRTlQU0FuYjJKcVpXTjBKeUI4ZkNCMllXd3hJRDA5UFNCdWRXeHNJSHg4SUhaaGJESWdQVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JwWmlBb1QySnFaV04wTG1kbGRGQnliM1J2ZEhsd1pVOW1LSFpoYkRFcElDRTlQU0JQWW1wbFkzUXVaMlYwVUhKdmRHOTBlWEJsVDJZb2RtRnNNaWtwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNCOVhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2FXWWdLSFpoYkRFZ1BUMDlJRzUxYkd3Z2ZId2dYM1I1Y0dWdlppaDJZV3d4S1NBaFBUMGdKMjlpYW1WamRDY3BJSHRjYmlBZ0lDQWdJR2xtSUNoMllXd3lJRDA5UFNCdWRXeHNJSHg4SUY5MGVYQmxiMllvZG1Gc01pa2dJVDA5SUNkdlltcGxZM1FuS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXNWxlSFF0YkdsdVpTQmxjV1Z4WlhGY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhaaGJERWdQVDBnZG1Gc01qdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNoMllXd3lJRDA5UFNCdWRXeHNJSHg4SUY5MGVYQmxiMllvZG1Gc01pa2dJVDA5SUNkdlltcGxZM1FuS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhaaGJERlVZV2NnUFNCdlltcGxZM1JVYjFOMGNtbHVaeWgyWVd3eEtUdGNiaUFnZG1GeUlIWmhiREpVWVdjZ1BTQnZZbXBsWTNSVWIxTjBjbWx1WnloMllXd3lLVHRjYmx4dUlDQnBaaUFvZG1Gc01WUmhaeUFoUFQwZ2RtRnNNbFJoWnlrZ2UxeHVJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnZlZ4dVhHNGdJR2xtSUNoQmNuSmhlUzVwYzBGeWNtRjVLSFpoYkRFcEtTQjdYRzRnSUNBZ0x5OGdRMmhsWTJzZ1ptOXlJSE53WVhKelpTQmhjbkpoZVhNZ1lXNWtJR2RsYm1WeVlXd2dabUZ6ZENCd1lYUm9YRzRnSUNBZ2FXWWdLSFpoYkRFdWJHVnVaM1JvSUNFOVBTQjJZV3d5TG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhaaGNpQnJaWGx6TVNBOUlHZGxkRTkzYms1dmJrbHVaR1Y0VUhKdmNHVnlkR2xsY3loMllXd3hMQ0JQVGt4WlgwVk9WVTFGVWtGQ1RFVXBPMXh1SUNBZ0lIWmhjaUJyWlhsek1pQTlJR2RsZEU5M2JrNXZia2x1WkdWNFVISnZjR1Z5ZEdsbGN5aDJZV3d5TENCUFRreFpYMFZPVlUxRlVrRkNURVVwTzF4dVhHNGdJQ0FnYVdZZ0tHdGxlWE14TG14bGJtZDBhQ0FoUFQwZ2EyVjVjekl1YkdWdVozUm9LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJR3RsZVVOb1pXTnJLSFpoYkRFc0lIWmhiRElzSUhOMGNtbGpkQ3dnYldWdGIzTXNJR3RKYzBGeWNtRjVMQ0JyWlhsek1TazdYRzRnSUgwZ0x5OGdXMkp5YjNkelpYSnBabmxkSUZSb2FYTWdkSEpwWjJkbGNuTWdiMjRnWTJWeWRHRnBiaUIwZVhCbGN5QnBiaUJKUlNBb1RXRndMMU5sZENrZ2MyOGdkMlVnWkc5dUozUmNiaUFnTHk4Z2QyRnVKM1FnZEc4Z1pXRnliSGtnY21WMGRYSnVJRzkxZENCdlppQjBhR1VnY21WemRDQnZaaUIwYUdVZ1kyaGxZMnR6TGlCSWIzZGxkbVZ5SUhkbElHTmhiaUJqYUdWamExeHVJQ0F2THlCcFppQjBhR1VnYzJWamIyNWtJSFpoYkhWbElHbHpJRzl1WlNCdlppQjBhR1Z6WlNCMllXeDFaWE1nWVc1a0lIUm9aU0JtYVhKemRDQnBjMjRuZEM1Y2JseHVYRzRnSUdsbUlDaDJZV3d4VkdGbklEMDlQU0FuVzI5aWFtVmpkQ0JQWW1wbFkzUmRKeWtnZTF4dUlDQWdJQzh2SUhKbGRIVnliaUJyWlhsRGFHVmpheWgyWVd3eExDQjJZV3d5TENCemRISnBZM1FzSUcxbGJXOXpMQ0JyVG05SmRHVnlZWFJ2Y2lrN1hHNGdJQ0FnYVdZZ0tDRnBjMDFoY0NoMllXd3hLU0FtSmlCcGMwMWhjQ2gyWVd3eUtTQjhmQ0FoYVhOVFpYUW9kbUZzTVNrZ0ppWWdhWE5UWlhRb2RtRnNNaWtwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnBaaUFvYVhORVlYUmxLSFpoYkRFcEtTQjdYRzRnSUNBZ2FXWWdLQ0ZwYzBSaGRHVW9kbUZzTWlrZ2ZId2dSR0YwWlM1d2NtOTBiM1I1Y0dVdVoyVjBWR2x0WlM1allXeHNLSFpoYkRFcElDRTlQU0JFWVhSbExuQnliM1J2ZEhsd1pTNW5aWFJVYVcxbExtTmhiR3dvZG1Gc01pa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCcFppQW9hWE5TWldkRmVIQW9kbUZzTVNrcElIdGNiaUFnSUNCcFppQW9JV2x6VW1WblJYaHdLSFpoYkRJcElIeDhJQ0ZoY21WVGFXMXBiR0Z5VW1WblJYaHdjeWgyWVd3eExDQjJZV3d5S1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lIMWNiaUFnZlNCbGJITmxJR2xtSUNocGMwNWhkR2wyWlVWeWNtOXlLSFpoYkRFcElIeDhJSFpoYkRFZ2FXNXpkR0Z1WTJWdlppQkZjbkp2Y2lrZ2UxeHVJQ0FnSUM4dklFUnZJRzV2ZENCamIyMXdZWEpsSUhSb1pTQnpkR0ZqYXlCaGN5QnBkQ0J0YVdkb2RDQmthV1ptWlhJZ1pYWmxiaUIwYUc5MVoyZ2dkR2hsSUdWeWNtOXlJR2wwYzJWc1pseHVJQ0FnSUM4dklHbHpJRzkwYUdWeWQybHpaU0JwWkdWdWRHbGpZV3d1WEc0Z0lDQWdhV1lnS0haaGJERXViV1Z6YzJGblpTQWhQVDBnZG1Gc01pNXRaWE56WVdkbElIeDhJSFpoYkRFdWJtRnRaU0FoUFQwZ2RtRnNNaTV1WVcxbEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnYVdZZ0tHbHpRWEp5WVhsQ2RXWm1aWEpXYVdWM0tIWmhiREVwS1NCN1hHNGdJQ0FnYVdZZ0tDRnpkSEpwWTNRZ0ppWWdLR2x6Um14dllYUXpNa0Z5Y21GNUtIWmhiREVwSUh4OElHbHpSbXh2WVhRMk5FRnljbUY1S0haaGJERXBLU2tnZTF4dUlDQWdJQ0FnYVdZZ0tDRmhjbVZUYVcxcGJHRnlSbXh2WVhSQmNuSmhlWE1vZG1Gc01Td2dkbUZzTWlrcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQnBaaUFvSVdGeVpWTnBiV2xzWVhKVWVYQmxaRUZ5Y21GNWN5aDJZV3d4TENCMllXd3lLU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgwZ0x5OGdRblZtWm1WeUxtTnZiWEJoY21VZ2NtVjBkWEp1Y3lCMGNuVmxMQ0J6YnlCMllXd3hMbXhsYm1kMGFDQTlQVDBnZG1Gc01pNXNaVzVuZEdndUlFbG1JSFJvWlhrZ1ltOTBhRnh1SUNBZ0lDOHZJRzl1YkhrZ1kyOXVkR0ZwYmlCdWRXMWxjbWxqSUd0bGVYTXNJSGRsSUdSdmJpZDBJRzVsWldRZ2RHOGdaWGhoYlNCbWRYSjBhR1Z5SUhSb1lXNGdZMmhsWTJ0cGJtZGNiaUFnSUNBdkx5QjBhR1VnYzNsdFltOXNjeTVjYmx4dVhHNGdJQ0FnZG1GeUlGOXJaWGx6SUQwZ1oyVjBUM2R1VG05dVNXNWtaWGhRY205d1pYSjBhV1Z6S0haaGJERXNJRTlPVEZsZlJVNVZUVVZTUVVKTVJTazdYRzVjYmlBZ0lDQjJZWElnWDJ0bGVYTXlJRDBnWjJWMFQzZHVUbTl1U1c1a1pYaFFjbTl3WlhKMGFXVnpLSFpoYkRJc0lFOU9URmxmUlU1VlRVVlNRVUpNUlNrN1hHNWNiaUFnSUNCcFppQW9YMnRsZVhNdWJHVnVaM1JvSUNFOVBTQmZhMlY1Y3pJdWJHVnVaM1JvS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUd0bGVVTm9aV05yS0haaGJERXNJSFpoYkRJc0lITjBjbWxqZEN3Z2JXVnRiM01zSUd0T2IwbDBaWEpoZEc5eUxDQmZhMlY1Y3lrN1hHNGdJSDBnWld4elpTQnBaaUFvYVhOVFpYUW9kbUZzTVNrcElIdGNiaUFnSUNCcFppQW9JV2x6VTJWMEtIWmhiRElwSUh4OElIWmhiREV1YzJsNlpTQWhQVDBnZG1Gc01pNXphWHBsS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUd0bGVVTm9aV05yS0haaGJERXNJSFpoYkRJc0lITjBjbWxqZEN3Z2JXVnRiM01zSUd0SmMxTmxkQ2s3WEc0Z0lIMGdaV3h6WlNCcFppQW9hWE5OWVhBb2RtRnNNU2twSUh0Y2JpQWdJQ0JwWmlBb0lXbHpUV0Z3S0haaGJESXBJSHg4SUhaaGJERXVjMmw2WlNBaFBUMGdkbUZzTWk1emFYcGxLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJR3RsZVVOb1pXTnJLSFpoYkRFc0lIWmhiRElzSUhOMGNtbGpkQ3dnYldWdGIzTXNJR3RKYzAxaGNDazdYRzRnSUgwZ1pXeHpaU0JwWmlBb2FYTkJibmxCY25KaGVVSjFabVpsY2loMllXd3hLU2tnZTF4dUlDQWdJR2xtSUNnaFlYSmxSWEYxWVd4QmNuSmhlVUoxWm1abGNuTW9kbUZzTVN3Z2RtRnNNaWtwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNCOVhHNGdJSDBnWld4elpTQnBaaUFvYVhOQ2IzaGxaRkJ5YVcxcGRHbDJaU2gyWVd3eEtTQW1KaUFoYVhORmNYVmhiRUp2ZUdWa1VISnBiV2wwYVhabEtIWmhiREVzSUhaaGJESXBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUd0bGVVTm9aV05yS0haaGJERXNJSFpoYkRJc0lITjBjbWxqZEN3Z2JXVnRiM01zSUd0T2IwbDBaWEpoZEc5eUtUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1oyVjBSVzUxYldWeVlXSnNaWE1vZG1Gc0xDQnJaWGx6S1NCN1hHNGdJSEpsZEhWeWJpQnJaWGx6TG1acGJIUmxjaWhtZFc1amRHbHZiaUFvYXlrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlNoMllXd3NJR3NwTzF4dUlDQjlLVHRjYm4xY2JseHVablZ1WTNScGIyNGdhMlY1UTJobFkyc29kbUZzTVN3Z2RtRnNNaXdnYzNSeWFXTjBMQ0J0WlcxdmN5d2dhWFJsY21GMGFXOXVWSGx3WlN3Z1lVdGxlWE1wSUh0Y2JpQWdMeThnUm05eUlHRnNiQ0J5WlcxaGFXNXBibWNnVDJKcVpXTjBJSEJoYVhKekxDQnBibU5zZFdScGJtY2dRWEp5WVhrc0lHOWlhbVZqZEhNZ1lXNWtJRTFoY0hNc1hHNGdJQzh2SUdWeGRXbDJZV3hsYm1ObElHbHpJR1JsZEdWeWJXbHVaV1FnWW5rZ2FHRjJhVzVuT2x4dUlDQXZMeUJoS1NCVWFHVWdjMkZ0WlNCdWRXMWlaWElnYjJZZ2IzZHVaV1FnWlc1MWJXVnlZV0pzWlNCd2NtOXdaWEowYVdWelhHNGdJQzh2SUdJcElGUm9aU0J6WVcxbElITmxkQ0J2WmlCclpYbHpMMmx1WkdWNFpYTWdLR0ZzZEdodmRXZG9JRzV2ZENCdVpXTmxjM05oY21sc2VTQjBhR1VnYzJGdFpTQnZjbVJsY2lsY2JpQWdMeThnWXlrZ1JYRjFhWFpoYkdWdWRDQjJZV3gxWlhNZ1ptOXlJR1YyWlhKNUlHTnZjbkpsYzNCdmJtUnBibWNnYTJWNUwybHVaR1Y0WEc0Z0lDOHZJR1FwSUVadmNpQlRaWFJ6SUdGdVpDQk5ZWEJ6TENCbGNYVmhiQ0JqYjI1MFpXNTBjMXh1SUNBdkx5Qk9iM1JsT2lCMGFHbHpJR0ZqWTI5MWJuUnpJR1p2Y2lCaWIzUm9JRzVoYldWa0lHRnVaQ0JwYm1SbGVHVmtJSEJ5YjNCbGNuUnBaWE1nYjI0Z1FYSnlZWGx6TGx4dUlDQnBaaUFvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0E5UFQwZ05Ta2dlMXh1SUNBZ0lHRkxaWGx6SUQwZ1QySnFaV04wTG10bGVYTW9kbUZzTVNrN1hHNGdJQ0FnZG1GeUlHSkxaWGx6SUQwZ1QySnFaV04wTG10bGVYTW9kbUZzTWlrN0lDOHZJRlJvWlNCd1lXbHlJRzExYzNRZ2FHRjJaU0IwYUdVZ2MyRnRaU0J1ZFcxaVpYSWdiMllnYjNkdVpXUWdjSEp2Y0dWeWRHbGxjeTVjYmx4dUlDQWdJR2xtSUNoaFMyVjVjeTVzWlc1bmRHZ2dJVDA5SUdKTFpYbHpMbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJSDFjYmlBZ2ZTQXZMeUJEYUdWaGNDQnJaWGtnZEdWemRGeHVYRzVjYmlBZ2RtRnlJR2tnUFNBd08xeHVYRzRnSUdadmNpQW9PeUJwSUR3Z1lVdGxlWE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNCcFppQW9JV2hoYzA5M2JsQnliM0JsY25SNUtIWmhiRElzSUdGTFpYbHpXMmxkS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR2xtSUNoemRISnBZM1FnSmlZZ1lYSm5kVzFsYm5SekxteGxibWQwYUNBOVBUMGdOU2tnZTF4dUlDQWdJSFpoY2lCemVXMWliMnhMWlhselFTQTlJRzlpYW1WamRFZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjeWgyWVd3eEtUdGNibHh1SUNBZ0lHbG1JQ2h6ZVcxaWIyeExaWGx6UVM1c1pXNW5kR2dnSVQwOUlEQXBJSHRjYmlBZ0lDQWdJSFpoY2lCamIzVnVkQ0E5SURBN1hHNWNiaUFnSUNBZ0lHWnZjaUFvYVNBOUlEQTdJR2tnUENCemVXMWliMnhMWlhselFTNXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNCMllYSWdhMlY1SUQwZ2MzbHRZbTlzUzJWNWMwRmJhVjA3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLSEJ5YjNCbGNuUjVTWE5GYm5WdFpYSmhZbXhsS0haaGJERXNJR3RsZVNrcElIdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb0lYQnliM0JsY25SNVNYTkZiblZ0WlhKaFlteGxLSFpoYkRJc0lHdGxlU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNCaFMyVjVjeTV3ZFhOb0tHdGxlU2s3WEc0Z0lDQWdJQ0FnSUNBZ1kyOTFiblFyS3p0Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaU2gyWVd3eUxDQnJaWGtwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lIWmhjaUJ6ZVcxaWIyeExaWGx6UWlBOUlHOWlhbVZqZEVkbGRFOTNibEJ5YjNCbGNuUjVVM2x0WW05c2N5aDJZV3d5S1R0Y2JseHVJQ0FnSUNBZ2FXWWdLSE41YldKdmJFdGxlWE5CTG14bGJtZDBhQ0FoUFQwZ2MzbHRZbTlzUzJWNWMwSXViR1Z1WjNSb0lDWW1JR2RsZEVWdWRXMWxjbUZpYkdWektIWmhiRElzSUhONWJXSnZiRXRsZVhOQ0tTNXNaVzVuZEdnZ0lUMDlJR052ZFc1MEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdkbUZ5SUY5emVXMWliMnhMWlhselFpQTlJRzlpYW1WamRFZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjeWgyWVd3eUtUdGNibHh1SUNBZ0lDQWdhV1lnS0Y5emVXMWliMnhMWlhselFpNXNaVzVuZEdnZ0lUMDlJREFnSmlZZ1oyVjBSVzUxYldWeVlXSnNaWE1vZG1Gc01pd2dYM041YldKdmJFdGxlWE5DS1M1c1pXNW5kR2dnSVQwOUlEQXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHbG1JQ2hoUzJWNWN5NXNaVzVuZEdnZ1BUMDlJREFnSmlZZ0tHbDBaWEpoZEdsdmJsUjVjR1VnUFQwOUlHdE9iMGwwWlhKaGRHOXlJSHg4SUdsMFpYSmhkR2x2YmxSNWNHVWdQVDA5SUd0SmMwRnljbUY1SUNZbUlIWmhiREV1YkdWdVozUm9JRDA5UFNBd0lIeDhJSFpoYkRFdWMybDZaU0E5UFQwZ01Da3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RISjFaVHRjYmlBZ2ZTQXZMeUJWYzJVZ2JXVnRiM01nZEc4Z2FHRnVaR3hsSUdONVkyeGxjeTVjYmx4dVhHNGdJR2xtSUNodFpXMXZjeUE5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ2JXVnRiM01nUFNCN1hHNGdJQ0FnSUNCMllXd3hPaUJ1WlhjZ1RXRndLQ2tzWEc0Z0lDQWdJQ0IyWVd3eU9pQnVaWGNnVFdGd0tDa3NYRzRnSUNBZ0lDQndiM05wZEdsdmJqb2dNRnh1SUNBZ0lIMDdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdMeThnVjJVZ2NISmxkbVZ1ZENCMWNDQjBieUIwZDI4Z2JXRndMbWhoY3loNEtTQmpZV3hzY3lCaWVTQmthWEpsWTNSc2VTQnlaWFJ5YVdWMmFXNW5JSFJvWlNCMllXeDFaVnh1SUNBZ0lDOHZJR0Z1WkNCamFHVmphMmx1WnlCbWIzSWdkVzVrWldacGJtVmtMaUJVYUdVZ2JXRndJR05oYmlCdmJteDVJR052Ym5SaGFXNGdiblZ0WW1WeWN5d2djMjhnYVhRZ2FYTmNiaUFnSUNBdkx5QnpZV1psSUhSdklHTm9aV05ySUdadmNpQjFibVJsWm1sdVpXUWdiMjVzZVM1Y2JpQWdJQ0IyWVhJZ2RtRnNNazFsYlc5QklEMGdiV1Z0YjNNdWRtRnNNUzVuWlhRb2RtRnNNU2s3WEc1Y2JpQWdJQ0JwWmlBb2RtRnNNazFsYlc5QklDRTlQU0IxYm1SbFptbHVaV1FwSUh0Y2JpQWdJQ0FnSUhaaGNpQjJZV3d5VFdWdGIwSWdQU0J0WlcxdmN5NTJZV3d5TG1kbGRDaDJZV3d5S1R0Y2JseHVJQ0FnSUNBZ2FXWWdLSFpoYkRKTlpXMXZRaUFoUFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjJZV3d5VFdWdGIwRWdQVDA5SUhaaGJESk5aVzF2UWp0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J0WlcxdmN5NXdiM05wZEdsdmJpc3JPMXh1SUNCOVhHNWNiaUFnYldWdGIzTXVkbUZzTVM1elpYUW9kbUZzTVN3Z2JXVnRiM011Y0c5emFYUnBiMjRwTzF4dUlDQnRaVzF2Y3k1MllXd3lMbk5sZENoMllXd3lMQ0J0WlcxdmN5NXdiM05wZEdsdmJpazdYRzRnSUhaaGNpQmhjbVZGY1NBOUlHOWlha1Z4ZFdsMktIWmhiREVzSUhaaGJESXNJSE4wY21samRDd2dZVXRsZVhNc0lHMWxiVzl6TENCcGRHVnlZWFJwYjI1VWVYQmxLVHRjYmlBZ2JXVnRiM011ZG1Gc01TNWtaV3hsZEdVb2RtRnNNU2s3WEc0Z0lHMWxiVzl6TG5aaGJESXVaR1ZzWlhSbEtIWmhiRElwTzF4dUlDQnlaWFIxY200Z1lYSmxSWEU3WEc1OVhHNWNibVoxYm1OMGFXOXVJSE5sZEVoaGMwVnhkV0ZzUld4bGJXVnVkQ2h6WlhRc0lIWmhiREVzSUhOMGNtbGpkQ3dnYldWdGJ5a2dlMXh1SUNBdkx5QkhieUJzYjI5cmFXNW5MbHh1SUNCMllYSWdjMlYwVm1Gc2RXVnpJRDBnWVhKeVlYbEdjbTl0VTJWMEtITmxkQ2s3WEc1Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0J6WlhSV1lXeDFaWE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNCMllYSWdkbUZzTWlBOUlITmxkRlpoYkhWbGMxdHBYVHRjYmx4dUlDQWdJR2xtSUNocGJtNWxja1JsWlhCRmNYVmhiQ2gyWVd3eExDQjJZV3d5TENCemRISnBZM1FzSUcxbGJXOHBLU0I3WEc0Z0lDQWdJQ0F2THlCU1pXMXZkbVVnZEdobElHMWhkR05vYVc1bklHVnNaVzFsYm5RZ2RHOGdiV0ZyWlNCemRYSmxJSGRsSUdSdklHNXZkQ0JqYUdWamF5QjBhR0YwSUdGbllXbHVMbHh1SUNBZ0lDQWdjMlYwTG1SbGJHVjBaU2gyWVd3eUtUdGNiaUFnSUNBZ0lISmxkSFZ5YmlCMGNuVmxPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JuMGdMeThnVTJWbElHaDBkSEJ6T2k4dlpHVjJaV3h2Y0dWeUxtMXZlbWxzYkdFdWIzSm5MMlZ1TFZWVEwyUnZZM012VjJWaUwwcGhkbUZUWTNKcGNIUXZSWEYxWVd4cGRIbGZZMjl0Y0dGeWFYTnZibk5mWVc1a1gzTmhiV1Z1WlhOekkweHZiM05sWDJWeGRXRnNhWFI1WDNWemFXNW5YRzR2THlCVFlXUnNlU0JwZENCcGN5QnViM1FnY0c5emMybGliR1VnZEc4Z1pHVjBaV04wSUdOdmNuSmxjM0J2Ym1ScGJtY2dkbUZzZFdWeklIQnliM0JsY214NUlHbHVJR05oYzJVZ2RHaGxYRzR2THlCMGVYQmxJR2x6SUdFZ2MzUnlhVzVuTENCdWRXMWlaWElzSUdKcFoybHVkQ0J2Y2lCaWIyOXNaV0Z1TGlCVWFHVWdjbVZoYzI5dUlHbHpJSFJvWVhRZ2RHaHZjMlVnZG1Gc2RXVnpYRzR2THlCallXNGdiV0YwWTJnZ2JHOTBjeUJ2WmlCa2FXWm1aWEpsYm5RZ2MzUnlhVzVuSUhaaGJIVmxjeUFvWlM1bkxpd2dNVzRnUFQwZ0p5c3dNREF3TVNjcExseHVYRzVjYm1aMWJtTjBhVzl1SUdacGJtUk1iMjl6WlUxaGRHTm9hVzVuVUhKcGJXbDBhWFpsY3lod2NtbHRLU0I3WEc0Z0lITjNhWFJqYUNBb1gzUjVjR1Z2Wmlod2NtbHRLU2tnZTF4dUlDQWdJR05oYzJVZ0ozVnVaR1ZtYVc1bFpDYzZYRzRnSUNBZ0lDQnlaWFIxY200Z2JuVnNiRHRjYmx4dUlDQWdJR05oYzJVZ0oyOWlhbVZqZENjNlhHNGdJQ0FnSUNBdkx5QlBibXg1SUhCaGMzTWdhVzRnYm5Wc2JDQmhjeUJ2WW1wbFkzUWhYRzRnSUNBZ0lDQnlaWFIxY200Z2RXNWtaV1pwYm1Wa08xeHVYRzRnSUNBZ1kyRnpaU0FuYzNsdFltOXNKenBjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JseHVJQ0FnSUdOaGMyVWdKM04wY21sdVp5YzZYRzRnSUNBZ0lDQndjbWx0SUQwZ0szQnlhVzA3WEc0Z0lDQWdMeThnVEc5dmMyVWdaWEYxWVd3Z1pXNTBjbWxsY3lCbGVHbHpkQ0J2Ym14NUlHbG1JSFJvWlNCemRISnBibWNnYVhNZ2NHOXpjMmxpYkdVZ2RHOGdZMjl1ZG1WeWRDQjBiMXh1SUNBZ0lDOHZJR0VnY21WbmRXeGhjaUJ1ZFcxaVpYSWdZVzVrSUc1dmRDQk9ZVTR1WEc0Z0lDQWdMeThnUm1Gc2JDQjBhSEp2ZFdkb1hHNWNiaUFnSUNCallYTmxJQ2R1ZFcxaVpYSW5PbHh1SUNBZ0lDQWdhV1lnS0c1MWJXSmxja2x6VG1GT0tIQnlhVzBwS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhSeWRXVTdYRzU5WEc1Y2JtWjFibU4wYVc5dUlITmxkRTFwWjJoMFNHRjJaVXh2YjNObFVISnBiU2hoTENCaUxDQndjbWx0S1NCN1hHNGdJSFpoY2lCaGJIUldZV3gxWlNBOUlHWnBibVJNYjI5elpVMWhkR05vYVc1blVISnBiV2wwYVhabGN5aHdjbWx0S1R0Y2JpQWdhV1lnS0dGc2RGWmhiSFZsSUNFOUlHNTFiR3dwSUhKbGRIVnliaUJoYkhSV1lXeDFaVHRjYmlBZ2NtVjBkWEp1SUdJdWFHRnpLR0ZzZEZaaGJIVmxLU0FtSmlBaFlTNW9ZWE1vWVd4MFZtRnNkV1VwTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJ0WVhCTmFXZG9kRWhoZG1WTWIyOXpaVkJ5YVcwb1lTd2dZaXdnY0hKcGJTd2dhWFJsYlN3Z2JXVnRieWtnZTF4dUlDQjJZWElnWVd4MFZtRnNkV1VnUFNCbWFXNWtURzl2YzJWTllYUmphR2x1WjFCeWFXMXBkR2wyWlhNb2NISnBiU2s3WEc1Y2JpQWdhV1lnS0dGc2RGWmhiSFZsSUNFOUlHNTFiR3dwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdZV3gwVm1Gc2RXVTdYRzRnSUgxY2JseHVJQ0IyWVhJZ1kzVnlRaUE5SUdJdVoyVjBLR0ZzZEZaaGJIVmxLVHRjYmx4dUlDQnBaaUFvWTNWeVFpQTlQVDBnZFc1a1pXWnBibVZrSUNZbUlDRmlMbWhoY3loaGJIUldZV3gxWlNrZ2ZId2dJV2x1Ym1WeVJHVmxjRVZ4ZFdGc0tHbDBaVzBzSUdOMWNrSXNJR1poYkhObExDQnRaVzF2S1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQWhZUzVvWVhNb1lXeDBWbUZzZFdVcElDWW1JR2x1Ym1WeVJHVmxjRVZ4ZFdGc0tHbDBaVzBzSUdOMWNrSXNJR1poYkhObExDQnRaVzF2S1R0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYzJWMFJYRjFhWFlvWVN3Z1lpd2djM1J5YVdOMExDQnRaVzF2S1NCN1hHNGdJQzh2SUZSb2FYTWdhWE1nWVNCc1lYcHBiSGtnYVc1cGRHbGhkR1ZrSUZObGRDQnZaaUJsYm5SeWFXVnpJSGRvYVdOb0lHaGhkbVVnZEc4Z1ltVWdZMjl0Y0dGeVpXUmNiaUFnTHk4Z2NHRnBjbmRwYzJVdVhHNGdJSFpoY2lCelpYUWdQU0J1ZFd4c08xeHVJQ0IyWVhJZ1lWWmhiSFZsY3lBOUlHRnljbUY1Um5KdmJWTmxkQ2hoS1R0Y2JseHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGV1lXeDFaWE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNCMllYSWdkbUZzSUQwZ1lWWmhiSFZsYzF0cFhUc2dMeThnVG05MFpUb2dRMmhsWTJ0cGJtY2dabTl5SUhSb1pTQnZZbXBsWTNSeklHWnBjbk4wSUdsdGNISnZkbVZ6SUhSb1pTQndaWEptYjNKdFlXNWpaU0JtYjNJZ2IySnFaV04wWEc0Z0lDQWdMeThnYUdWaGRua2djMlYwY3lCaWRYUWdhWFFnYVhNZ1lTQnRhVzV2Y2lCemJHOTNJR1J2ZDI0Z1ptOXlJSEJ5YVcxcGRHbDJaWE11SUVGeklIUm9aWGtnWVhKbElHWmhjM1JjYmlBZ0lDQXZMeUIwYnlCamFHVmpheUIwYUdseklHbHRjSEp2ZG1WeklIUm9aU0IzYjNKemRDQmpZWE5sSUhOalpXNWhjbWx2SUdsdWMzUmxZV1F1WEc1Y2JpQWdJQ0JwWmlBb1gzUjVjR1Z2WmloMllXd3BJRDA5UFNBbmIySnFaV04wSnlBbUppQjJZV3dnSVQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUdsbUlDaHpaWFFnUFQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUNBZ2MyVjBJRDBnYm1WM0lGTmxkQ2dwTzF4dUlDQWdJQ0FnZlNBdkx5QkpaaUIwYUdVZ2MzQmxZMmxtYVdWa0lIWmhiSFZsSUdSdlpYTnVKM1FnWlhocGMzUWdhVzRnZEdobElITmxZMjl1WkNCelpYUWdhWFJ6SUdGdUlHNXZkQ0J1ZFd4c1hHNGdJQ0FnSUNBdkx5QnZZbXBsWTNRZ0tHOXlJRzV2YmlCemRISnBZM1FnYjI1c2VUb2dZU0J1YjNRZ2JXRjBZMmhwYm1jZ2NISnBiV2wwYVhabEtTQjNaU2RzYkNCdVpXVmtJSFJ2SUdkdlhHNGdJQ0FnSUNBdkx5Qm9kVzUwYVc1bklHWnZjaUJ6YjIxbGRHaHBibWNnZEdoaGRITWdaR1ZsY0Mwb2MzUnlhV04wTFNsbGNYVmhiQ0IwYnlCcGRDNGdWRzhnYldGclpTQjBhR2x6WEc0Z0lDQWdJQ0F2THlCUEtHNGdiRzluSUc0cElHTnZiWEJzWlhocGRIa2dkMlVnYUdGMlpTQjBieUJqYjNCNUlIUm9aWE5sSUhaaGJIVmxjeUJwYmlCaElHNWxkeUJ6WlhRZ1ptbHljM1F1WEc1Y2JseHVJQ0FnSUNBZ2MyVjBMbUZrWkNoMllXd3BPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9JV0l1YUdGektIWmhiQ2twSUh0Y2JpQWdJQ0FnSUdsbUlDaHpkSEpwWTNRcElISmxkSFZ5YmlCbVlXeHpaVHNnTHk4Z1JtRnpkQ0J3WVhSb0lIUnZJR1JsZEdWamRDQnRhWE56YVc1bklITjBjbWx1Wnl3Z2MzbHRZbTlzTENCMWJtUmxabWx1WldRZ1lXNWtJRzUxYkd3Z2RtRnNkV1Z6TGx4dVhHNGdJQ0FnSUNCcFppQW9JWE5sZEUxcFoyaDBTR0YyWlV4dmIzTmxVSEpwYlNoaExDQmlMQ0IyWVd3cEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2FXWWdLSE5sZENBOVBUMGdiblZzYkNrZ2UxeHVJQ0FnSUNBZ0lDQnpaWFFnUFNCdVpYY2dVMlYwS0NrN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lITmxkQzVoWkdRb2RtRnNLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0JwWmlBb2MyVjBJQ0U5UFNCdWRXeHNLU0I3WEc0Z0lDQWdkbUZ5SUdKV1lXeDFaWE1nUFNCaGNuSmhlVVp5YjIxVFpYUW9ZaWs3WEc1Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJmYVNBOUlEQTdJRjlwSUR3Z1lsWmhiSFZsY3k1c1pXNW5kR2c3SUY5cEt5c3BJSHRjYmlBZ0lDQWdJSFpoY2lCZmRtRnNJRDBnWWxaaGJIVmxjMXRmYVYwN0lDOHZJRmRsSUdoaGRtVWdkRzhnWTJobFkyc2dhV1lnWVNCd2NtbHRhWFJwZG1VZ2RtRnNkV1VnYVhNZ1lXeHlaV0ZrZVZ4dUlDQWdJQ0FnTHk4Z2JXRjBZMmhwYm1jZ1lXNWtJRzl1YkhrZ2FXWWdhWFFuY3lCdWIzUXNJR2R2SUdoMWJuUnBibWNnWm05eUlHbDBMbHh1WEc0Z0lDQWdJQ0JwWmlBb1gzUjVjR1Z2WmloZmRtRnNLU0E5UFQwZ0oyOWlhbVZqZENjZ0ppWWdYM1poYkNBaFBUMGdiblZzYkNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvSVhObGRFaGhjMFZ4ZFdGc1JXeGxiV1Z1ZENoelpYUXNJRjkyWVd3c0lITjBjbWxqZEN3Z2JXVnRieWtwSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCcFppQW9JWE4wY21samRDQW1KaUFoWVM1b1lYTW9YM1poYkNrZ0ppWWdJWE5sZEVoaGMwVnhkV0ZzUld4bGJXVnVkQ2h6WlhRc0lGOTJZV3dzSUhOMGNtbGpkQ3dnYldWdGJ5a3BJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUJ6WlhRdWMybDZaU0E5UFQwZ01EdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjBjblZsTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJ0WVhCSVlYTkZjWFZoYkVWdWRISjVLSE5sZEN3Z2JXRndMQ0JyWlhreExDQnBkR1Z0TVN3Z2MzUnlhV04wTENCdFpXMXZLU0I3WEc0Z0lDOHZJRlJ2SUdKbElHRmliR1VnZEc4Z2FHRnVaR3hsSUdOaGMyVnpJR3hwYTJVNlhHNGdJQzh2SUNBZ1RXRndLRnRiZTMwc0lDZGhKMTBzSUZ0N2ZTd2dKMkluWFYwcElIWnpJRTFoY0NoYlczdDlMQ0FuWWlkZExDQmJlMzBzSUNkaEoxMWRLVnh1SUNBdkx5QXVMaTRnZDJVZ2JtVmxaQ0IwYnlCamIyNXphV1JsY2lBcVlXeHNLaUJ0WVhSamFHbHVaeUJyWlhsekxDQnViM1FnYW5WemRDQjBhR1VnWm1seWMzUWdkMlVnWm1sdVpDNWNiaUFnZG1GeUlITmxkRlpoYkhWbGN5QTlJR0Z5Y21GNVJuSnZiVk5sZENoelpYUXBPMXh1WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2djMlYwVm1Gc2RXVnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnZG1GeUlHdGxlVElnUFNCelpYUldZV3gxWlhOYmFWMDdYRzVjYmlBZ0lDQnBaaUFvYVc1dVpYSkVaV1Z3UlhGMVlXd29hMlY1TVN3Z2EyVjVNaXdnYzNSeWFXTjBMQ0J0WlcxdktTQW1KaUJwYm01bGNrUmxaWEJGY1hWaGJDaHBkR1Z0TVN3Z2JXRndMbWRsZENoclpYa3lLU3dnYzNSeWFXTjBMQ0J0WlcxdktTa2dlMXh1SUNBZ0lDQWdjMlYwTG1SbGJHVjBaU2hyWlhreUtUdGNiaUFnSUNBZ0lISmxkSFZ5YmlCMGNuVmxPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYldGd1JYRjFhWFlvWVN3Z1lpd2djM1J5YVdOMExDQnRaVzF2S1NCN1hHNGdJSFpoY2lCelpYUWdQU0J1ZFd4c08xeHVJQ0IyWVhJZ1lVVnVkSEpwWlhNZ1BTQmhjbkpoZVVaeWIyMU5ZWEFvWVNrN1hHNWNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCaFJXNTBjbWxsY3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lIWmhjaUJmWVVWdWRISnBaWE1rYVNBOUlGOXpiR2xqWldSVWIwRnljbUY1S0dGRmJuUnlhV1Z6VzJsZExDQXlLU3hjYmlBZ0lDQWdJQ0FnYTJWNUlEMGdYMkZGYm5SeWFXVnpKR2xiTUYwc1hHNGdJQ0FnSUNBZ0lHbDBaVzB4SUQwZ1gyRkZiblJ5YVdWekpHbGJNVjA3WEc1Y2JpQWdJQ0JwWmlBb1gzUjVjR1Z2WmloclpYa3BJRDA5UFNBbmIySnFaV04wSnlBbUppQnJaWGtnSVQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUdsbUlDaHpaWFFnUFQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0FnSUNBZ2MyVjBJRDBnYm1WM0lGTmxkQ2dwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCelpYUXVZV1JrS0d0bGVTazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUM4dklFSjVJR1JwY21WamRHeDVJSEpsZEhKcFpYWnBibWNnZEdobElIWmhiSFZsSUhkbElIQnlaWFpsYm5RZ1lXNXZkR2hsY2lCaUxtaGhjeWhyWlhrcElHTm9aV05ySUdsdVhHNGdJQ0FnSUNBdkx5QmhiRzF2YzNRZ1lXeHNJSEJ2YzNOcFlteGxJR05oYzJWekxseHVJQ0FnSUNBZ2RtRnlJR2wwWlcweUlEMGdZaTVuWlhRb2EyVjVLVHRjYmx4dUlDQWdJQ0FnYVdZZ0tHbDBaVzB5SUQwOVBTQjFibVJsWm1sdVpXUWdKaVlnSVdJdWFHRnpLR3RsZVNrZ2ZId2dJV2x1Ym1WeVJHVmxjRVZ4ZFdGc0tHbDBaVzB4TENCcGRHVnRNaXdnYzNSeWFXTjBMQ0J0WlcxdktTa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2MzUnlhV04wS1NCeVpYUjFjbTRnWm1Gc2MyVTdJQzh2SUVaaGMzUWdjR0YwYUNCMGJ5QmtaWFJsWTNRZ2JXbHpjMmx1WnlCemRISnBibWNzSUhONWJXSnZiQ3dnZFc1a1pXWnBibVZrSUdGdVpDQnVkV3hzWEc0Z0lDQWdJQ0FnSUM4dklHdGxlWE11WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0Z0WVhCTmFXZG9kRWhoZG1WTWIyOXpaVkJ5YVcwb1lTd2dZaXdnYTJWNUxDQnBkR1Z0TVN3Z2JXVnRieWtwSUhKbGRIVnliaUJtWVd4elpUdGNibHh1SUNBZ0lDQWdJQ0JwWmlBb2MyVjBJRDA5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2MyVjBJRDBnYm1WM0lGTmxkQ2dwTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdjMlYwTG1Ga1pDaHJaWGtwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdsbUlDaHpaWFFnSVQwOUlHNTFiR3dwSUh0Y2JpQWdJQ0IyWVhJZ1lrVnVkSEpwWlhNZ1BTQmhjbkpoZVVaeWIyMU5ZWEFvWWlrN1hHNWNiaUFnSUNCbWIzSWdLSFpoY2lCZmFUSWdQU0F3T3lCZmFUSWdQQ0JpUlc1MGNtbGxjeTVzWlc1bmRHZzdJRjlwTWlzcktTQjdYRzRnSUNBZ0lDQjJZWElnWDJKRmJuUnlhV1Z6SkY5cElEMGdYM05zYVdObFpGUnZRWEp5WVhrb1lrVnVkSEpwWlhOYlgya3lYU3dnTWlrc1hHNGdJQ0FnSUNBZ0lDQWdhMlY1SUQwZ1gySkZiblJ5YVdWekpGOXBXekJkTEZ4dUlDQWdJQ0FnSUNBZ0lHbDBaVzBnUFNCZllrVnVkSEpwWlhNa1gybGJNVjA3WEc1Y2JpQWdJQ0FnSUdsbUlDaGZkSGx3Wlc5bUtHdGxlU2tnUFQwOUlDZHZZbXBsWTNRbklDWW1JR3RsZVNBaFBUMGdiblZzYkNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvSVcxaGNFaGhjMFZ4ZFdGc1JXNTBjbmtvYzJWMExDQmhMQ0JyWlhrc0lHbDBaVzBzSUhOMGNtbGpkQ3dnYldWdGJ5a3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb0lYTjBjbWxqZENBbUppQW9JV0V1YUdGektHdGxlU2tnZkh3Z0lXbHVibVZ5UkdWbGNFVnhkV0ZzS0dFdVoyVjBLR3RsZVNrc0lHbDBaVzBzSUdaaGJITmxMQ0J0WlcxdktTa2dKaVlnSVcxaGNFaGhjMFZ4ZFdGc1JXNTBjbmtvYzJWMExDQmhMQ0JyWlhrc0lHbDBaVzBzSUdaaGJITmxMQ0J0WlcxdktTa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMGRYSnVJSE5sZEM1emFYcGxJRDA5UFNBd08xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIUnlkV1U3WEc1OVhHNWNibVoxYm1OMGFXOXVJRzlpYWtWeGRXbDJLR0VzSUdJc0lITjBjbWxqZEN3Z2EyVjVjeXdnYldWdGIzTXNJR2wwWlhKaGRHbHZibFI1Y0dVcElIdGNiaUFnTHk4Z1UyVjBjeUJoYm1RZ2JXRndjeUJrYjI0bmRDQm9ZWFpsSUhSb1pXbHlJR1Z1ZEhKcFpYTWdZV05qWlhOemFXSnNaU0IyYVdFZ2JtOXliV0ZzSUc5aWFtVmpkRnh1SUNBdkx5QndjbTl3WlhKMGFXVnpMbHh1SUNCMllYSWdhU0E5SURBN1hHNWNiaUFnYVdZZ0tHbDBaWEpoZEdsdmJsUjVjR1VnUFQwOUlHdEpjMU5sZENrZ2UxeHVJQ0FnSUdsbUlDZ2hjMlYwUlhGMWFYWW9ZU3dnWWl3Z2MzUnlhV04wTENCdFpXMXZjeWtwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNCOVhHNGdJSDBnWld4elpTQnBaaUFvYVhSbGNtRjBhVzl1Vkhsd1pTQTlQVDBnYTBselRXRndLU0I3WEc0Z0lDQWdhV1lnS0NGdFlYQkZjWFZwZGloaExDQmlMQ0J6ZEhKcFkzUXNJRzFsYlc5ektTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJSDFjYmlBZ2ZTQmxiSE5sSUdsbUlDaHBkR1Z5WVhScGIyNVVlWEJsSUQwOVBTQnJTWE5CY25KaGVTa2dlMXh1SUNBZ0lHWnZjaUFvT3lCcElEd2dZUzVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ2FXWWdLR2hoYzA5M2JsQnliM0JsY25SNUtHRXNJR2twS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2doYUdGelQzZHVVSEp2Y0dWeWRIa29ZaXdnYVNrZ2ZId2dJV2x1Ym1WeVJHVmxjRVZ4ZFdGc0tHRmJhVjBzSUdKYmFWMHNJSE4wY21samRDd2diV1Z0YjNNcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2hoYzA5M2JsQnliM0JsY25SNUtHSXNJR2twS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQzh2SUVGeWNtRjVJR2x6SUhOd1lYSnpaUzVjYmlBZ0lDQWdJQ0FnZG1GeUlHdGxlWE5CSUQwZ1QySnFaV04wTG10bGVYTW9ZU2s3WEc1Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2c3SUdrZ1BDQnJaWGx6UVM1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0FnSUhaaGNpQnJaWGtnUFNCclpYbHpRVnRwWFR0Y2JseHVJQ0FnSUNBZ0lDQWdJR2xtSUNnaGFHRnpUM2R1VUhKdmNHVnlkSGtvWWl3Z2EyVjVLU0I4ZkNBaGFXNXVaWEpFWldWd1JYRjFZV3dvWVZ0clpYbGRMQ0JpVzJ0bGVWMHNJSE4wY21samRDd2diV1Z0YjNNcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdhV1lnS0d0bGVYTkJMbXhsYm1kMGFDQWhQVDBnVDJKcVpXTjBMbXRsZVhNb1lpa3ViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlJQzh2SUZSb1pTQndZV2x5SUcxMWMzUWdhR0YyWlNCbGNYVnBkbUZzWlc1MElIWmhiSFZsY3lCbWIzSWdaWFpsY25rZ1kyOXljbVZ6Y0c5dVpHbHVaeUJyWlhrdVhHNGdJQzh2SUZCdmMzTnBZbXg1SUdWNGNHVnVjMmwyWlNCa1pXVndJSFJsYzNRNlhHNWNibHh1SUNCbWIzSWdLR2tnUFNBd095QnBJRHdnYTJWNWN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJSFpoY2lCZmEyVjVJRDBnYTJWNWMxdHBYVHRjYmx4dUlDQWdJR2xtSUNnaGFXNXVaWEpFWldWd1JYRjFZV3dvWVZ0ZmEyVjVYU3dnWWx0ZmEyVjVYU3dnYzNSeWFXTjBMQ0J0WlcxdmN5a3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZEhKMVpUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2FYTkVaV1Z3UlhGMVlXd29kbUZzTVN3Z2RtRnNNaWtnZTF4dUlDQnlaWFIxY200Z2FXNXVaWEpFWldWd1JYRjFZV3dvZG1Gc01Td2dkbUZzTWl3Z2EweHZiM05sS1R0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYVhORVpXVndVM1J5YVdOMFJYRjFZV3dvZG1Gc01Td2dkbUZzTWlrZ2UxeHVJQ0J5WlhSMWNtNGdhVzV1WlhKRVpXVndSWEYxWVd3b2RtRnNNU3dnZG1Gc01pd2dhMU4wY21samRDazdYRzU5WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2UxeHVJQ0JwYzBSbFpYQkZjWFZoYkRvZ2FYTkVaV1Z3UlhGMVlXd3NYRzRnSUdselJHVmxjRk4wY21samRFVnhkV0ZzT2lCcGMwUmxaWEJUZEhKcFkzUkZjWFZoYkZ4dWZUc2lMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCbWFXeDBaWElnUFNCeVpYRjFhWEpsS0NkaGNuSmhlUzFtYVd4MFpYSW5LVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCaGRtRnBiR0ZpYkdWVWVYQmxaRUZ5Y21GNWN5Z3BJSHRjYmx4MGNtVjBkWEp1SUdacGJIUmxjaWhiWEc1Y2RGeDBKMEpwWjBsdWREWTBRWEp5WVhrbkxGeHVYSFJjZENkQ2FXZFZhVzUwTmpSQmNuSmhlU2NzWEc1Y2RGeDBKMFpzYjJGME16SkJjbkpoZVNjc1hHNWNkRngwSjBac2IyRjBOalJCY25KaGVTY3NYRzVjZEZ4MEowbHVkREUyUVhKeVlYa25MRnh1WEhSY2RDZEpiblF6TWtGeWNtRjVKeXhjYmx4MFhIUW5TVzUwT0VGeWNtRjVKeXhjYmx4MFhIUW5WV2x1ZERFMlFYSnlZWGtuTEZ4dVhIUmNkQ2RWYVc1ME16SkJjbkpoZVNjc1hHNWNkRngwSjFWcGJuUTRRWEp5WVhrbkxGeHVYSFJjZENkVmFXNTBPRU5zWVcxd1pXUkJjbkpoZVNkY2JseDBYU3dnWm5WdVkzUnBiMjRnS0hSNWNHVmtRWEp5WVhrcElIdGNibHgwWEhSeVpYUjFjbTRnZEhsd1pXOW1JR2RzYjJKaGJGdDBlWEJsWkVGeWNtRjVYU0E5UFQwZ0oyWjFibU4wYVc5dUp6dGNibHgwZlNrN1hHNTlPMXh1SWl3aWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCeVpYRjFhWEpsS0NjdUwyeHBZaTloZUdsdmN5Y3BPeUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1ZG1GeUlIVjBhV3h6SUQwZ2NtVnhkV2x5WlNnbkxpOHVMaTkxZEdsc2N5Y3BPMXh1ZG1GeUlITmxkSFJzWlNBOUlISmxjWFZwY21Vb0p5NHZMaTR2WTI5eVpTOXpaWFIwYkdVbktUdGNiblpoY2lCamIyOXJhV1Z6SUQwZ2NtVnhkV2x5WlNnbkxpOHVMaTlvWld4d1pYSnpMMk52YjJ0cFpYTW5LVHRjYm5aaGNpQmlkV2xzWkZWU1RDQTlJSEpsY1hWcGNtVW9KeTR2TGk0dmFHVnNjR1Z5Y3k5aWRXbHNaRlZTVENjcE8xeHVkbUZ5SUdKMWFXeGtSblZzYkZCaGRHZ2dQU0J5WlhGMWFYSmxLQ2N1TGk5amIzSmxMMkoxYVd4a1JuVnNiRkJoZEdnbktUdGNiblpoY2lCd1lYSnpaVWhsWVdSbGNuTWdQU0J5WlhGMWFYSmxLQ2N1THk0dUwyaGxiSEJsY25NdmNHRnljMlZJWldGa1pYSnpKeWs3WEc1MllYSWdhWE5WVWt4VFlXMWxUM0pwWjJsdUlEMGdjbVZ4ZFdseVpTZ25MaTh1TGk5b1pXeHdaWEp6TDJselZWSk1VMkZ0WlU5eWFXZHBiaWNwTzF4dWRtRnlJR055WldGMFpVVnljbTl5SUQwZ2NtVnhkV2x5WlNnbkxpNHZZMjl5WlM5amNtVmhkR1ZGY25KdmNpY3BPMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUhob2NrRmtZWEIwWlhJb1kyOXVabWxuS1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnVUhKdmJXbHpaU2htZFc1amRHbHZiaUJrYVhOd1lYUmphRmhvY2xKbGNYVmxjM1FvY21WemIyeDJaU3dnY21WcVpXTjBLU0I3WEc0Z0lDQWdkbUZ5SUhKbGNYVmxjM1JFWVhSaElEMGdZMjl1Wm1sbkxtUmhkR0U3WEc0Z0lDQWdkbUZ5SUhKbGNYVmxjM1JJWldGa1pYSnpJRDBnWTI5dVptbG5MbWhsWVdSbGNuTTdYRzVjYmlBZ0lDQnBaaUFvZFhScGJITXVhWE5HYjNKdFJHRjBZU2h5WlhGMVpYTjBSR0YwWVNrcElIdGNiaUFnSUNBZ0lHUmxiR1YwWlNCeVpYRjFaWE4wU0dWaFpHVnljMXNuUTI5dWRHVnVkQzFVZVhCbEoxMDdJQzh2SUV4bGRDQjBhR1VnWW5KdmQzTmxjaUJ6WlhRZ2FYUmNiaUFnSUNCOVhHNWNiaUFnSUNCMllYSWdjbVZ4ZFdWemRDQTlJRzVsZHlCWVRVeElkSFJ3VW1WeGRXVnpkQ2dwTzF4dVhHNGdJQ0FnTHk4Z1NGUlVVQ0JpWVhOcFl5QmhkWFJvWlc1MGFXTmhkR2x2Ymx4dUlDQWdJR2xtSUNoamIyNW1hV2N1WVhWMGFDa2dlMXh1SUNBZ0lDQWdkbUZ5SUhWelpYSnVZVzFsSUQwZ1kyOXVabWxuTG1GMWRHZ3VkWE5sY201aGJXVWdmSHdnSnljN1hHNGdJQ0FnSUNCMllYSWdjR0Z6YzNkdmNtUWdQU0JqYjI1bWFXY3VZWFYwYUM1d1lYTnpkMjl5WkNBL0lIVnVaWE5qWVhCbEtHVnVZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDaGpiMjVtYVdjdVlYVjBhQzV3WVhOemQyOXlaQ2twSURvZ0p5YzdYRzRnSUNBZ0lDQnlaWEYxWlhOMFNHVmhaR1Z5Y3k1QmRYUm9iM0pwZW1GMGFXOXVJRDBnSjBKaGMybGpJQ2NnS3lCaWRHOWhLSFZ6WlhKdVlXMWxJQ3NnSnpvbklDc2djR0Z6YzNkdmNtUXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIWmhjaUJtZFd4c1VHRjBhQ0E5SUdKMWFXeGtSblZzYkZCaGRHZ29ZMjl1Wm1sbkxtSmhjMlZWVWt3c0lHTnZibVpwWnk1MWNtd3BPMXh1SUNBZ0lISmxjWFZsYzNRdWIzQmxiaWhqYjI1bWFXY3ViV1YwYUc5a0xuUnZWWEJ3WlhKRFlYTmxLQ2tzSUdKMWFXeGtWVkpNS0daMWJHeFFZWFJvTENCamIyNW1hV2N1Y0dGeVlXMXpMQ0JqYjI1bWFXY3VjR0Z5WVcxelUyVnlhV0ZzYVhwbGNpa3NJSFJ5ZFdVcE8xeHVYRzRnSUNBZ0x5OGdVMlYwSUhSb1pTQnlaWEYxWlhOMElIUnBiV1Z2ZFhRZ2FXNGdUVk5jYmlBZ0lDQnlaWEYxWlhOMExuUnBiV1Z2ZFhRZ1BTQmpiMjVtYVdjdWRHbHRaVzkxZER0Y2JseHVJQ0FnSUM4dklFeHBjM1JsYmlCbWIzSWdjbVZoWkhrZ2MzUmhkR1ZjYmlBZ0lDQnlaWEYxWlhOMExtOXVjbVZoWkhsemRHRjBaV05vWVc1blpTQTlJR1oxYm1OMGFXOXVJR2hoYm1Sc1pVeHZZV1FvS1NCN1hHNGdJQ0FnSUNCcFppQW9JWEpsY1hWbGMzUWdmSHdnY21WeGRXVnpkQzV5WldGa2VWTjBZWFJsSUNFOVBTQTBLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnlianRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1ZHaGxJSEpsY1hWbGMzUWdaWEp5YjNKbFpDQnZkWFFnWVc1a0lIZGxJR1JwWkc0bmRDQm5aWFFnWVNCeVpYTndiMjV6WlN3Z2RHaHBjeUIzYVd4c0lHSmxYRzRnSUNBZ0lDQXZMeUJvWVc1a2JHVmtJR0o1SUc5dVpYSnliM0lnYVc1emRHVmhaRnh1SUNBZ0lDQWdMeThnVjJsMGFDQnZibVVnWlhoalpYQjBhVzl1T2lCeVpYRjFaWE4wSUhSb1lYUWdkWE5wYm1jZ1ptbHNaVG9nY0hKdmRHOWpiMndzSUcxdmMzUWdZbkp2ZDNObGNuTmNiaUFnSUNBZ0lDOHZJSGRwYkd3Z2NtVjBkWEp1SUhOMFlYUjFjeUJoY3lBd0lHVjJaVzRnZEdodmRXZG9JR2wwSjNNZ1lTQnpkV05qWlhOelpuVnNJSEpsY1hWbGMzUmNiaUFnSUNBZ0lHbG1JQ2h5WlhGMVpYTjBMbk4wWVhSMWN5QTlQVDBnTUNBbUppQWhLSEpsY1hWbGMzUXVjbVZ6Y0c5dWMyVlZVa3dnSmlZZ2NtVnhkV1Z6ZEM1eVpYTndiMjV6WlZWU1RDNXBibVJsZUU5bUtDZG1hV3hsT2ljcElEMDlQU0F3S1NrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200N1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDOHZJRkJ5WlhCaGNtVWdkR2hsSUhKbGMzQnZibk5sWEc0Z0lDQWdJQ0IyWVhJZ2NtVnpjRzl1YzJWSVpXRmtaWEp6SUQwZ0oyZGxkRUZzYkZKbGMzQnZibk5sU0dWaFpHVnljeWNnYVc0Z2NtVnhkV1Z6ZENBL0lIQmhjbk5sU0dWaFpHVnljeWh5WlhGMVpYTjBMbWRsZEVGc2JGSmxjM0J2Ym5ObFNHVmhaR1Z5Y3lncEtTQTZJRzUxYkd3N1hHNGdJQ0FnSUNCMllYSWdjbVZ6Y0c5dWMyVkVZWFJoSUQwZ0lXTnZibVpwWnk1eVpYTndiMjV6WlZSNWNHVWdmSHdnWTI5dVptbG5MbkpsYzNCdmJuTmxWSGx3WlNBOVBUMGdKM1JsZUhRbklEOGdjbVZ4ZFdWemRDNXlaWE53YjI1elpWUmxlSFFnT2lCeVpYRjFaWE4wTG5KbGMzQnZibk5sTzF4dUlDQWdJQ0FnZG1GeUlISmxjM0J2Ym5ObElEMGdlMXh1SUNBZ0lDQWdJQ0JrWVhSaE9pQnlaWE53YjI1elpVUmhkR0VzWEc0Z0lDQWdJQ0FnSUhOMFlYUjFjem9nY21WeGRXVnpkQzV6ZEdGMGRYTXNYRzRnSUNBZ0lDQWdJSE4wWVhSMWMxUmxlSFE2SUhKbGNYVmxjM1F1YzNSaGRIVnpWR1Y0ZEN4Y2JpQWdJQ0FnSUNBZ2FHVmhaR1Z5Y3pvZ2NtVnpjRzl1YzJWSVpXRmtaWEp6TEZ4dUlDQWdJQ0FnSUNCamIyNW1hV2M2SUdOdmJtWnBaeXhjYmlBZ0lDQWdJQ0FnY21WeGRXVnpkRG9nY21WeGRXVnpkRnh1SUNBZ0lDQWdmVHRjYmx4dUlDQWdJQ0FnYzJWMGRHeGxLSEpsYzI5c2RtVXNJSEpsYW1WamRDd2djbVZ6Y0c5dWMyVXBPMXh1WEc0Z0lDQWdJQ0F2THlCRGJHVmhiaUIxY0NCeVpYRjFaWE4wWEc0Z0lDQWdJQ0J5WlhGMVpYTjBJRDBnYm5Wc2JEdGNiaUFnSUNCOU8xeHVYRzRnSUNBZ0x5OGdTR0Z1Wkd4bElHSnliM2R6WlhJZ2NtVnhkV1Z6ZENCallXNWpaV3hzWVhScGIyNGdLR0Z6SUc5d2NHOXpaV1FnZEc4Z1lTQnRZVzUxWVd3Z1kyRnVZMlZzYkdGMGFXOXVLVnh1SUNBZ0lISmxjWFZsYzNRdWIyNWhZbTl5ZENBOUlHWjFibU4wYVc5dUlHaGhibVJzWlVGaWIzSjBLQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tDRnlaWEYxWlhOMEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdjbVZxWldOMEtHTnlaV0YwWlVWeWNtOXlLQ2RTWlhGMVpYTjBJR0ZpYjNKMFpXUW5MQ0JqYjI1bWFXY3NJQ2RGUTA5T1RrRkNUMUpVUlVRbkxDQnlaWEYxWlhOMEtTazdYRzVjYmlBZ0lDQWdJQzh2SUVOc1pXRnVJSFZ3SUhKbGNYVmxjM1JjYmlBZ0lDQWdJSEpsY1hWbGMzUWdQU0J1ZFd4c08xeHVJQ0FnSUgwN1hHNWNiaUFnSUNBdkx5QklZVzVrYkdVZ2JHOTNJR3hsZG1Wc0lHNWxkSGR2Y21zZ1pYSnliM0p6WEc0Z0lDQWdjbVZ4ZFdWemRDNXZibVZ5Y205eUlEMGdablZ1WTNScGIyNGdhR0Z1Wkd4bFJYSnliM0lvS1NCN1hHNGdJQ0FnSUNBdkx5QlNaV0ZzSUdWeWNtOXljeUJoY21VZ2FHbGtaR1Z1SUdaeWIyMGdkWE1nWW5rZ2RHaGxJR0p5YjNkelpYSmNiaUFnSUNBZ0lDOHZJRzl1WlhKeWIzSWdjMmh2ZFd4a0lHOXViSGtnWm1seVpTQnBaaUJwZENkeklHRWdibVYwZDI5eWF5Qmxjbkp2Y2x4dUlDQWdJQ0FnY21WcVpXTjBLR055WldGMFpVVnljbTl5S0NkT1pYUjNiM0pySUVWeWNtOXlKeXdnWTI5dVptbG5MQ0J1ZFd4c0xDQnlaWEYxWlhOMEtTazdYRzVjYmlBZ0lDQWdJQzh2SUVOc1pXRnVJSFZ3SUhKbGNYVmxjM1JjYmlBZ0lDQWdJSEpsY1hWbGMzUWdQU0J1ZFd4c08xeHVJQ0FnSUgwN1hHNWNiaUFnSUNBdkx5QklZVzVrYkdVZ2RHbHRaVzkxZEZ4dUlDQWdJSEpsY1hWbGMzUXViMjUwYVcxbGIzVjBJRDBnWm5WdVkzUnBiMjRnYUdGdVpHeGxWR2x0Wlc5MWRDZ3BJSHRjYmlBZ0lDQWdJSFpoY2lCMGFXMWxiM1YwUlhKeWIzSk5aWE56WVdkbElEMGdKM1JwYldWdmRYUWdiMllnSnlBcklHTnZibVpwWnk1MGFXMWxiM1YwSUNzZ0oyMXpJR1Y0WTJWbFpHVmtKenRjYmlBZ0lDQWdJR2xtSUNoamIyNW1hV2N1ZEdsdFpXOTFkRVZ5Y205eVRXVnpjMkZuWlNrZ2UxeHVJQ0FnSUNBZ0lDQjBhVzFsYjNWMFJYSnliM0pOWlhOellXZGxJRDBnWTI5dVptbG5MblJwYldWdmRYUkZjbkp2Y2sxbGMzTmhaMlU3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WldwbFkzUW9ZM0psWVhSbFJYSnliM0lvZEdsdFpXOTFkRVZ5Y205eVRXVnpjMkZuWlN3Z1kyOXVabWxuTENBblJVTlBUazVCUWs5U1ZFVkVKeXhjYmlBZ0lDQWdJQ0FnY21WeGRXVnpkQ2twTzF4dVhHNGdJQ0FnSUNBdkx5QkRiR1ZoYmlCMWNDQnlaWEYxWlhOMFhHNGdJQ0FnSUNCeVpYRjFaWE4wSUQwZ2JuVnNiRHRjYmlBZ0lDQjlPMXh1WEc0Z0lDQWdMeThnUVdSa0lIaHpjbVlnYUdWaFpHVnlYRzRnSUNBZ0x5OGdWR2hwY3lCcGN5QnZibXg1SUdSdmJtVWdhV1lnY25WdWJtbHVaeUJwYmlCaElITjBZVzVrWVhKa0lHSnliM2R6WlhJZ1pXNTJhWEp2Ym0xbGJuUXVYRzRnSUNBZ0x5OGdVM0JsWTJsbWFXTmhiR3g1SUc1dmRDQnBaaUIzWlNkeVpTQnBiaUJoSUhkbFlpQjNiM0pyWlhJc0lHOXlJSEpsWVdOMExXNWhkR2wyWlM1Y2JpQWdJQ0JwWmlBb2RYUnBiSE11YVhOVGRHRnVaR0Z5WkVKeWIzZHpaWEpGYm5Zb0tTa2dlMXh1SUNBZ0lDQWdMeThnUVdSa0lIaHpjbVlnYUdWaFpHVnlYRzRnSUNBZ0lDQjJZWElnZUhOeVpsWmhiSFZsSUQwZ0tHTnZibVpwWnk1M2FYUm9RM0psWkdWdWRHbGhiSE1nZkh3Z2FYTlZVa3hUWVcxbFQzSnBaMmx1S0daMWJHeFFZWFJvS1NrZ0ppWWdZMjl1Wm1sbkxuaHpjbVpEYjI5cmFXVk9ZVzFsSUQ5Y2JpQWdJQ0FnSUNBZ1kyOXZhMmxsY3k1eVpXRmtLR052Ym1acFp5NTRjM0ptUTI5dmEybGxUbUZ0WlNrZ09seHVJQ0FnSUNBZ0lDQjFibVJsWm1sdVpXUTdYRzVjYmlBZ0lDQWdJR2xtSUNoNGMzSm1WbUZzZFdVcElIdGNiaUFnSUNBZ0lDQWdjbVZ4ZFdWemRFaGxZV1JsY25OYlkyOXVabWxuTG5oemNtWklaV0ZrWlhKT1lXMWxYU0E5SUhoemNtWldZV3gxWlR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCQlpHUWdhR1ZoWkdWeWN5QjBieUIwYUdVZ2NtVnhkV1Z6ZEZ4dUlDQWdJR2xtSUNnbmMyVjBVbVZ4ZFdWemRFaGxZV1JsY2ljZ2FXNGdjbVZ4ZFdWemRDa2dlMXh1SUNBZ0lDQWdkWFJwYkhNdVptOXlSV0ZqYUNoeVpYRjFaWE4wU0dWaFpHVnljeXdnWm5WdVkzUnBiMjRnYzJWMFVtVnhkV1Z6ZEVobFlXUmxjaWgyWVd3c0lHdGxlU2tnZTF4dUlDQWdJQ0FnSUNCcFppQW9kSGx3Wlc5bUlISmxjWFZsYzNSRVlYUmhJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUJyWlhrdWRHOU1iM2RsY2tOaGMyVW9LU0E5UFQwZ0oyTnZiblJsYm5RdGRIbHdaU2NwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJTWlcxdmRtVWdRMjl1ZEdWdWRDMVVlWEJsSUdsbUlHUmhkR0VnYVhNZ2RXNWtaV1pwYm1Wa1hHNGdJQ0FnSUNBZ0lDQWdaR1ZzWlhSbElISmxjWFZsYzNSSVpXRmtaWEp6VzJ0bGVWMDdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1QzUm9aWEozYVhObElHRmtaQ0JvWldGa1pYSWdkRzhnZEdobElISmxjWFZsYzNSY2JpQWdJQ0FnSUNBZ0lDQnlaWEYxWlhOMExuTmxkRkpsY1hWbGMzUklaV0ZrWlhJb2EyVjVMQ0IyWVd3cE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJCWkdRZ2QybDBhRU55WldSbGJuUnBZV3h6SUhSdklISmxjWFZsYzNRZ2FXWWdibVZsWkdWa1hHNGdJQ0FnYVdZZ0tDRjFkR2xzY3k1cGMxVnVaR1ZtYVc1bFpDaGpiMjVtYVdjdWQybDBhRU55WldSbGJuUnBZV3h6S1NrZ2UxeHVJQ0FnSUNBZ2NtVnhkV1Z6ZEM1M2FYUm9RM0psWkdWdWRHbGhiSE1nUFNBaElXTnZibVpwWnk1M2FYUm9RM0psWkdWdWRHbGhiSE03WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnUVdSa0lISmxjM0J2Ym5ObFZIbHdaU0IwYnlCeVpYRjFaWE4wSUdsbUlHNWxaV1JsWkZ4dUlDQWdJR2xtSUNoamIyNW1hV2N1Y21WemNHOXVjMlZVZVhCbEtTQjdYRzRnSUNBZ0lDQjBjbmtnZTF4dUlDQWdJQ0FnSUNCeVpYRjFaWE4wTG5KbGMzQnZibk5sVkhsd1pTQTlJR052Ym1acFp5NXlaWE53YjI1elpWUjVjR1U3WEc0Z0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJRVY0Y0dWamRHVmtJRVJQVFVWNFkyVndkR2x2YmlCMGFISnZkMjRnWW5rZ1luSnZkM05sY25NZ2JtOTBJR052YlhCaGRHbGliR1VnV0UxTVNIUjBjRkpsY1hWbGMzUWdUR1YyWld3Z01pNWNiaUFnSUNBZ0lDQWdMeThnUW5WMExDQjBhR2x6SUdOaGJpQmlaU0J6ZFhCd2NtVnpjMlZrSUdadmNpQW5hbk52YmljZ2RIbHdaU0JoY3lCcGRDQmpZVzRnWW1VZ2NHRnljMlZrSUdKNUlHUmxabUYxYkhRZ0ozUnlZVzV6Wm05eWJWSmxjM0J2Ym5ObEp5Qm1kVzVqZEdsdmJpNWNiaUFnSUNBZ0lDQWdhV1lnS0dOdmJtWnBaeTV5WlhOd2IyNXpaVlI1Y0dVZ0lUMDlJQ2RxYzI5dUp5a2dlMXh1SUNBZ0lDQWdJQ0FnSUhSb2NtOTNJR1U3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCSVlXNWtiR1VnY0hKdlozSmxjM01nYVdZZ2JtVmxaR1ZrWEc0Z0lDQWdhV1lnS0hSNWNHVnZaaUJqYjI1bWFXY3ViMjVFYjNkdWJHOWhaRkJ5YjJkeVpYTnpJRDA5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQnlaWEYxWlhOMExtRmtaRVYyWlc1MFRHbHpkR1Z1WlhJb0ozQnliMmR5WlhOekp5d2dZMjl1Wm1sbkxtOXVSRzkzYm14dllXUlFjbTluY21WemN5azdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdUbTkwSUdGc2JDQmljbTkzYzJWeWN5QnpkWEJ3YjNKMElIVndiRzloWkNCbGRtVnVkSE5jYmlBZ0lDQnBaaUFvZEhsd1pXOW1JR052Ym1acFp5NXZibFZ3Ykc5aFpGQnliMmR5WlhOeklEMDlQU0FuWm5WdVkzUnBiMjRuSUNZbUlISmxjWFZsYzNRdWRYQnNiMkZrS1NCN1hHNGdJQ0FnSUNCeVpYRjFaWE4wTG5Wd2JHOWhaQzVoWkdSRmRtVnVkRXhwYzNSbGJtVnlLQ2R3Y205bmNtVnpjeWNzSUdOdmJtWnBaeTV2YmxWd2JHOWhaRkJ5YjJkeVpYTnpLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvWTI5dVptbG5MbU5oYm1ObGJGUnZhMlZ1S1NCN1hHNGdJQ0FnSUNBdkx5QklZVzVrYkdVZ1kyRnVZMlZzYkdGMGFXOXVYRzRnSUNBZ0lDQmpiMjVtYVdjdVkyRnVZMlZzVkc5clpXNHVjSEp2YldselpTNTBhR1Z1S0daMWJtTjBhVzl1SUc5dVEyRnVZMlZzWldRb1kyRnVZMlZzS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2doY21WeGRXVnpkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJSEpsY1hWbGMzUXVZV0p2Y25Rb0tUdGNiaUFnSUNBZ0lDQWdjbVZxWldOMEtHTmhibU5sYkNrN1hHNGdJQ0FnSUNBZ0lDOHZJRU5zWldGdUlIVndJSEpsY1hWbGMzUmNiaUFnSUNBZ0lDQWdjbVZ4ZFdWemRDQTlJRzUxYkd3N1hHNGdJQ0FnSUNCOUtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9JWEpsY1hWbGMzUkVZWFJoS1NCN1hHNGdJQ0FnSUNCeVpYRjFaWE4wUkdGMFlTQTlJRzUxYkd3N1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1UyVnVaQ0IwYUdVZ2NtVnhkV1Z6ZEZ4dUlDQWdJSEpsY1hWbGMzUXVjMlZ1WkNoeVpYRjFaWE4wUkdGMFlTazdYRzRnSUgwcE8xeHVmVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dWRtRnlJSFYwYVd4eklEMGdjbVZ4ZFdseVpTZ25MaTkxZEdsc2N5Y3BPMXh1ZG1GeUlHSnBibVFnUFNCeVpYRjFhWEpsS0NjdUwyaGxiSEJsY25NdlltbHVaQ2NwTzF4dWRtRnlJRUY0YVc5eklEMGdjbVZ4ZFdseVpTZ25MaTlqYjNKbEwwRjRhVzl6SnlrN1hHNTJZWElnYldWeVoyVkRiMjVtYVdjZ1BTQnlaWEYxYVhKbEtDY3VMMk52Y21VdmJXVnlaMlZEYjI1bWFXY25LVHRjYm5aaGNpQmtaV1poZFd4MGN5QTlJSEpsY1hWcGNtVW9KeTR2WkdWbVlYVnNkSE1uS1R0Y2JseHVMeW9xWEc0Z0tpQkRjbVZoZEdVZ1lXNGdhVzV6ZEdGdVkyVWdiMllnUVhocGIzTmNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ1pHVm1ZWFZzZEVOdmJtWnBaeUJVYUdVZ1pHVm1ZWFZzZENCamIyNW1hV2NnWm05eUlIUm9aU0JwYm5OMFlXNWpaVnh1SUNvZ1FISmxkSFZ5YmlCN1FYaHBiM045SUVFZ2JtVjNJR2x1YzNSaGJtTmxJRzltSUVGNGFXOXpYRzRnS2k5Y2JtWjFibU4wYVc5dUlHTnlaV0YwWlVsdWMzUmhibU5sS0dSbFptRjFiSFJEYjI1bWFXY3BJSHRjYmlBZ2RtRnlJR052Ym5SbGVIUWdQU0J1WlhjZ1FYaHBiM01vWkdWbVlYVnNkRU52Ym1acFp5azdYRzRnSUhaaGNpQnBibk4wWVc1alpTQTlJR0pwYm1Rb1FYaHBiM011Y0hKdmRHOTBlWEJsTG5KbGNYVmxjM1FzSUdOdmJuUmxlSFFwTzF4dVhHNGdJQzh2SUVOdmNIa2dZWGhwYjNNdWNISnZkRzkwZVhCbElIUnZJR2x1YzNSaGJtTmxYRzRnSUhWMGFXeHpMbVY0ZEdWdVpDaHBibk4wWVc1alpTd2dRWGhwYjNNdWNISnZkRzkwZVhCbExDQmpiMjUwWlhoMEtUdGNibHh1SUNBdkx5QkRiM0I1SUdOdmJuUmxlSFFnZEc4Z2FXNXpkR0Z1WTJWY2JpQWdkWFJwYkhNdVpYaDBaVzVrS0dsdWMzUmhibU5sTENCamIyNTBaWGgwS1R0Y2JseHVJQ0J5WlhSMWNtNGdhVzV6ZEdGdVkyVTdYRzU5WEc1Y2JpOHZJRU55WldGMFpTQjBhR1VnWkdWbVlYVnNkQ0JwYm5OMFlXNWpaU0IwYnlCaVpTQmxlSEJ2Y25SbFpGeHVkbUZ5SUdGNGFXOXpJRDBnWTNKbFlYUmxTVzV6ZEdGdVkyVW9aR1ZtWVhWc2RITXBPMXh1WEc0dkx5QkZlSEJ2YzJVZ1FYaHBiM01nWTJ4aGMzTWdkRzhnWVd4c2IzY2dZMnhoYzNNZ2FXNW9aWEpwZEdGdVkyVmNibUY0YVc5ekxrRjRhVzl6SUQwZ1FYaHBiM003WEc1Y2JpOHZJRVpoWTNSdmNua2dabTl5SUdOeVpXRjBhVzVuSUc1bGR5QnBibk4wWVc1alpYTmNibUY0YVc5ekxtTnlaV0YwWlNBOUlHWjFibU4wYVc5dUlHTnlaV0YwWlNocGJuTjBZVzVqWlVOdmJtWnBaeWtnZTF4dUlDQnlaWFIxY200Z1kzSmxZWFJsU1c1emRHRnVZMlVvYldWeVoyVkRiMjVtYVdjb1lYaHBiM011WkdWbVlYVnNkSE1zSUdsdWMzUmhibU5sUTI5dVptbG5LU2s3WEc1OU8xeHVYRzR2THlCRmVIQnZjMlVnUTJGdVkyVnNJQ1lnUTJGdVkyVnNWRzlyWlc1Y2JtRjRhVzl6TGtOaGJtTmxiQ0E5SUhKbGNYVnBjbVVvSnk0dlkyRnVZMlZzTDBOaGJtTmxiQ2NwTzF4dVlYaHBiM011UTJGdVkyVnNWRzlyWlc0Z1BTQnlaWEYxYVhKbEtDY3VMMk5oYm1ObGJDOURZVzVqWld4VWIydGxiaWNwTzF4dVlYaHBiM011YVhORFlXNWpaV3dnUFNCeVpYRjFhWEpsS0NjdUwyTmhibU5sYkM5cGMwTmhibU5sYkNjcE8xeHVYRzR2THlCRmVIQnZjMlVnWVd4c0wzTndjbVZoWkZ4dVlYaHBiM011WVd4c0lEMGdablZ1WTNScGIyNGdZV3hzS0hCeWIyMXBjMlZ6S1NCN1hHNGdJSEpsZEhWeWJpQlFjbTl0YVhObExtRnNiQ2h3Y205dGFYTmxjeWs3WEc1OU8xeHVZWGhwYjNNdWMzQnlaV0ZrSUQwZ2NtVnhkV2x5WlNnbkxpOW9aV3h3WlhKekwzTndjbVZoWkNjcE8xeHVYRzR2THlCRmVIQnZjMlVnYVhOQmVHbHZjMFZ5Y205eVhHNWhlR2x2Y3k1cGMwRjRhVzl6UlhKeWIzSWdQU0J5WlhGMWFYSmxLQ2N1TDJobGJIQmxjbk12YVhOQmVHbHZjMFZ5Y205eUp5azdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWVhocGIzTTdYRzVjYmk4dklFRnNiRzkzSUhWelpTQnZaaUJrWldaaGRXeDBJR2x0Y0c5eWRDQnplVzUwWVhnZ2FXNGdWSGx3WlZOamNtbHdkRnh1Ylc5a2RXeGxMbVY0Y0c5eWRITXVaR1ZtWVhWc2RDQTlJR0Y0YVc5ek8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzR2S2lwY2JpQXFJRUVnWUVOaGJtTmxiR0FnYVhNZ1lXNGdiMkpxWldOMElIUm9ZWFFnYVhNZ2RHaHliM2R1SUhkb1pXNGdZVzRnYjNCbGNtRjBhVzl1SUdseklHTmhibU5sYkdWa0xseHVJQ3BjYmlBcUlFQmpiR0Z6YzF4dUlDb2dRSEJoY21GdElIdHpkSEpwYm1jOWZTQnRaWE56WVdkbElGUm9aU0J0WlhOellXZGxMbHh1SUNvdlhHNW1kVzVqZEdsdmJpQkRZVzVqWld3b2JXVnpjMkZuWlNrZ2UxeHVJQ0IwYUdsekxtMWxjM05oWjJVZ1BTQnRaWE56WVdkbE8xeHVmVnh1WEc1RFlXNWpaV3d1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuSUQwZ1puVnVZM1JwYjI0Z2RHOVRkSEpwYm1jb0tTQjdYRzRnSUhKbGRIVnliaUFuUTJGdVkyVnNKeUFySUNoMGFHbHpMbTFsYzNOaFoyVWdQeUFuT2lBbklDc2dkR2hwY3k1dFpYTnpZV2RsSURvZ0p5Y3BPMXh1ZlR0Y2JseHVRMkZ1WTJWc0xuQnliM1J2ZEhsd1pTNWZYME5CVGtORlRGOWZJRDBnZEhKMVpUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JEWVc1alpXdzdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQkRZVzVqWld3Z1BTQnlaWEYxYVhKbEtDY3VMME5oYm1ObGJDY3BPMXh1WEc0dktpcGNiaUFxSUVFZ1lFTmhibU5sYkZSdmEyVnVZQ0JwY3lCaGJpQnZZbXBsWTNRZ2RHaGhkQ0JqWVc0Z1ltVWdkWE5sWkNCMGJ5QnlaWEYxWlhOMElHTmhibU5sYkd4aGRHbHZiaUJ2WmlCaGJpQnZjR1Z5WVhScGIyNHVYRzRnS2x4dUlDb2dRR05zWVhOelhHNGdLaUJBY0dGeVlXMGdlMFoxYm1OMGFXOXVmU0JsZUdWamRYUnZjaUJVYUdVZ1pYaGxZM1YwYjNJZ1puVnVZM1JwYjI0dVhHNGdLaTljYm1aMWJtTjBhVzl1SUVOaGJtTmxiRlJ2YTJWdUtHVjRaV04xZEc5eUtTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ1pYaGxZM1YwYjNJZ0lUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkbGVHVmpkWFJ2Y2lCdGRYTjBJR0psSUdFZ1puVnVZM1JwYjI0dUp5azdYRzRnSUgxY2JseHVJQ0IyWVhJZ2NtVnpiMngyWlZCeWIyMXBjMlU3WEc0Z0lIUm9hWE11Y0hKdmJXbHpaU0E5SUc1bGR5QlFjbTl0YVhObEtHWjFibU4wYVc5dUlIQnliMjFwYzJWRmVHVmpkWFJ2Y2loeVpYTnZiSFpsS1NCN1hHNGdJQ0FnY21WemIyeDJaVkJ5YjIxcGMyVWdQU0J5WlhOdmJIWmxPMXh1SUNCOUtUdGNibHh1SUNCMllYSWdkRzlyWlc0Z1BTQjBhR2x6TzF4dUlDQmxlR1ZqZFhSdmNpaG1kVzVqZEdsdmJpQmpZVzVqWld3b2JXVnpjMkZuWlNrZ2UxeHVJQ0FnSUdsbUlDaDBiMnRsYmk1eVpXRnpiMjRwSUh0Y2JpQWdJQ0FnSUM4dklFTmhibU5sYkd4aGRHbHZiaUJvWVhNZ1lXeHlaV0ZrZVNCaVpXVnVJSEpsY1hWbGMzUmxaRnh1SUNBZ0lDQWdjbVYwZFhKdU8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhSdmEyVnVMbkpsWVhOdmJpQTlJRzVsZHlCRFlXNWpaV3dvYldWemMyRm5aU2s3WEc0Z0lDQWdjbVZ6YjJ4MlpWQnliMjFwYzJVb2RHOXJaVzR1Y21WaGMyOXVLVHRjYmlBZ2ZTazdYRzU5WEc1Y2JpOHFLbHh1SUNvZ1ZHaHliM2R6SUdFZ1lFTmhibU5sYkdBZ2FXWWdZMkZ1WTJWc2JHRjBhVzl1SUdoaGN5QmlaV1Z1SUhKbGNYVmxjM1JsWkM1Y2JpQXFMMXh1UTJGdVkyVnNWRzlyWlc0dWNISnZkRzkwZVhCbExuUm9jbTkzU1daU1pYRjFaWE4wWldRZ1BTQm1kVzVqZEdsdmJpQjBhSEp2ZDBsbVVtVnhkV1Z6ZEdWa0tDa2dlMXh1SUNCcFppQW9kR2hwY3k1eVpXRnpiMjRwSUh0Y2JpQWdJQ0IwYUhKdmR5QjBhR2x6TG5KbFlYTnZianRjYmlBZ2ZWeHVmVHRjYmx4dUx5b3FYRzRnS2lCU1pYUjFjbTV6SUdGdUlHOWlhbVZqZENCMGFHRjBJR052Ym5SaGFXNXpJR0VnYm1WM0lHQkRZVzVqWld4VWIydGxibUFnWVc1a0lHRWdablZ1WTNScGIyNGdkR2hoZEN3Z2QyaGxiaUJqWVd4c1pXUXNYRzRnS2lCallXNWpaV3h6SUhSb1pTQmdRMkZ1WTJWc1ZHOXJaVzVnTGx4dUlDb3ZYRzVEWVc1alpXeFViMnRsYmk1emIzVnlZMlVnUFNCbWRXNWpkR2x2YmlCemIzVnlZMlVvS1NCN1hHNGdJSFpoY2lCallXNWpaV3c3WEc0Z0lIWmhjaUIwYjJ0bGJpQTlJRzVsZHlCRFlXNWpaV3hVYjJ0bGJpaG1kVzVqZEdsdmJpQmxlR1ZqZFhSdmNpaGpLU0I3WEc0Z0lDQWdZMkZ1WTJWc0lEMGdZenRjYmlBZ2ZTazdYRzRnSUhKbGRIVnliaUI3WEc0Z0lDQWdkRzlyWlc0NklIUnZhMlZ1TEZ4dUlDQWdJR05oYm1ObGJEb2dZMkZ1WTJWc1hHNGdJSDA3WEc1OU8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRU5oYm1ObGJGUnZhMlZ1TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlHbHpRMkZ1WTJWc0tIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQWhJU2gyWVd4MVpTQW1KaUIyWVd4MVpTNWZYME5CVGtORlRGOWZLVHRjYm4wN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCMWRHbHNjeUE5SUhKbGNYVnBjbVVvSnk0dkxpNHZkWFJwYkhNbktUdGNiblpoY2lCaWRXbHNaRlZTVENBOUlISmxjWFZwY21Vb0p5NHVMMmhsYkhCbGNuTXZZblZwYkdSVlVrd25LVHRjYm5aaGNpQkpiblJsY21ObGNIUnZjazFoYm1GblpYSWdQU0J5WlhGMWFYSmxLQ2N1TDBsdWRHVnlZMlZ3ZEc5eVRXRnVZV2RsY2ljcE8xeHVkbUZ5SUdScGMzQmhkR05vVW1WeGRXVnpkQ0E5SUhKbGNYVnBjbVVvSnk0dlpHbHpjR0YwWTJoU1pYRjFaWE4wSnlrN1hHNTJZWElnYldWeVoyVkRiMjVtYVdjZ1BTQnlaWEYxYVhKbEtDY3VMMjFsY21kbFEyOXVabWxuSnlrN1hHNWNiaThxS2x4dUlDb2dRM0psWVhSbElHRWdibVYzSUdsdWMzUmhibU5sSUc5bUlFRjRhVzl6WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJR2x1YzNSaGJtTmxRMjl1Wm1sbklGUm9aU0JrWldaaGRXeDBJR052Ym1acFp5Qm1iM0lnZEdobElHbHVjM1JoYm1ObFhHNGdLaTljYm1aMWJtTjBhVzl1SUVGNGFXOXpLR2x1YzNSaGJtTmxRMjl1Wm1sbktTQjdYRzRnSUhSb2FYTXVaR1ZtWVhWc2RITWdQU0JwYm5OMFlXNWpaVU52Ym1acFp6dGNiaUFnZEdocGN5NXBiblJsY21ObGNIUnZjbk1nUFNCN1hHNGdJQ0FnY21WeGRXVnpkRG9nYm1WM0lFbHVkR1Z5WTJWd2RHOXlUV0Z1WVdkbGNpZ3BMRnh1SUNBZ0lISmxjM0J2Ym5ObE9pQnVaWGNnU1c1MFpYSmpaWEIwYjNKTllXNWhaMlZ5S0NsY2JpQWdmVHRjYm4xY2JseHVMeW9xWEc0Z0tpQkVhWE53WVhSamFDQmhJSEpsY1hWbGMzUmNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ1kyOXVabWxuSUZSb1pTQmpiMjVtYVdjZ2MzQmxZMmxtYVdNZ1ptOXlJSFJvYVhNZ2NtVnhkV1Z6ZENBb2JXVnlaMlZrSUhkcGRHZ2dkR2hwY3k1a1pXWmhkV3gwY3lsY2JpQXFMMXh1UVhocGIzTXVjSEp2ZEc5MGVYQmxMbkpsY1hWbGMzUWdQU0JtZFc1amRHbHZiaUJ5WlhGMVpYTjBLR052Ym1acFp5a2dlMXh1SUNBdkttVnpiR2x1ZENCdWJ5MXdZWEpoYlMxeVpXRnpjMmxuYmpvd0tpOWNiaUFnTHk4Z1FXeHNiM2NnWm05eUlHRjRhVzl6S0NkbGVHRnRjR3hsTDNWeWJDZGJMQ0JqYjI1bWFXZGRLU0JoSUd4aElHWmxkR05vSUVGUVNWeHVJQ0JwWmlBb2RIbHdaVzltSUdOdmJtWnBaeUE5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCamIyNW1hV2NnUFNCaGNtZDFiV1Z1ZEhOYk1WMGdmSHdnZTMwN1hHNGdJQ0FnWTI5dVptbG5MblZ5YkNBOUlHRnlaM1Z0Wlc1MGMxc3dYVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0JqYjI1bWFXY2dQU0JqYjI1bWFXY2dmSHdnZTMwN1hHNGdJSDFjYmx4dUlDQmpiMjVtYVdjZ1BTQnRaWEpuWlVOdmJtWnBaeWgwYUdsekxtUmxabUYxYkhSekxDQmpiMjVtYVdjcE8xeHVYRzRnSUM4dklGTmxkQ0JqYjI1bWFXY3ViV1YwYUc5a1hHNGdJR2xtSUNoamIyNW1hV2N1YldWMGFHOWtLU0I3WEc0Z0lDQWdZMjl1Wm1sbkxtMWxkR2h2WkNBOUlHTnZibVpwWnk1dFpYUm9iMlF1ZEc5TWIzZGxja05oYzJVb0tUdGNiaUFnZlNCbGJITmxJR2xtSUNoMGFHbHpMbVJsWm1GMWJIUnpMbTFsZEdodlpDa2dlMXh1SUNBZ0lHTnZibVpwWnk1dFpYUm9iMlFnUFNCMGFHbHpMbVJsWm1GMWJIUnpMbTFsZEdodlpDNTBiMHh2ZDJWeVEyRnpaU2dwTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdOdmJtWnBaeTV0WlhSb2IyUWdQU0FuWjJWMEp6dGNiaUFnZlZ4dVhHNGdJQzh2SUVodmIyc2dkWEFnYVc1MFpYSmpaWEIwYjNKeklHMXBaR1JzWlhkaGNtVmNiaUFnZG1GeUlHTm9ZV2x1SUQwZ1cyUnBjM0JoZEdOb1VtVnhkV1Z6ZEN3Z2RXNWtaV1pwYm1Wa1hUdGNiaUFnZG1GeUlIQnliMjFwYzJVZ1BTQlFjbTl0YVhObExuSmxjMjlzZG1Vb1kyOXVabWxuS1R0Y2JseHVJQ0IwYUdsekxtbHVkR1Z5WTJWd2RHOXljeTV5WlhGMVpYTjBMbVp2Y2tWaFkyZ29ablZ1WTNScGIyNGdkVzV6YUdsbWRGSmxjWFZsYzNSSmJuUmxjbU5sY0hSdmNuTW9hVzUwWlhKalpYQjBiM0lwSUh0Y2JpQWdJQ0JqYUdGcGJpNTFibk5vYVdaMEtHbHVkR1Z5WTJWd2RHOXlMbVoxYkdacGJHeGxaQ3dnYVc1MFpYSmpaWEIwYjNJdWNtVnFaV04wWldRcE8xeHVJQ0I5S1R0Y2JseHVJQ0IwYUdsekxtbHVkR1Z5WTJWd2RHOXljeTV5WlhOd2IyNXpaUzVtYjNKRllXTm9LR1oxYm1OMGFXOXVJSEIxYzJoU1pYTndiMjV6WlVsdWRHVnlZMlZ3ZEc5eWN5aHBiblJsY21ObGNIUnZjaWtnZTF4dUlDQWdJR05vWVdsdUxuQjFjMmdvYVc1MFpYSmpaWEIwYjNJdVpuVnNabWxzYkdWa0xDQnBiblJsY21ObGNIUnZjaTV5WldwbFkzUmxaQ2s3WEc0Z0lIMHBPMXh1WEc0Z0lIZG9hV3hsSUNoamFHRnBiaTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQndjbTl0YVhObElEMGdjSEp2YldselpTNTBhR1Z1S0dOb1lXbHVMbk5vYVdaMEtDa3NJR05vWVdsdUxuTm9hV1owS0NrcE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIQnliMjFwYzJVN1hHNTlPMXh1WEc1QmVHbHZjeTV3Y205MGIzUjVjR1V1WjJWMFZYSnBJRDBnWm5WdVkzUnBiMjRnWjJWMFZYSnBLR052Ym1acFp5a2dlMXh1SUNCamIyNW1hV2NnUFNCdFpYSm5aVU52Ym1acFp5aDBhR2x6TG1SbFptRjFiSFJ6TENCamIyNW1hV2NwTzF4dUlDQnlaWFIxY200Z1luVnBiR1JWVWt3b1kyOXVabWxuTG5WeWJDd2dZMjl1Wm1sbkxuQmhjbUZ0Y3l3Z1kyOXVabWxuTG5CaGNtRnRjMU5sY21saGJHbDZaWElwTG5KbGNHeGhZMlVvTDE1Y1hEOHZMQ0FuSnlrN1hHNTlPMXh1WEc0dkx5QlFjbTkyYVdSbElHRnNhV0Z6WlhNZ1ptOXlJSE4xY0hCdmNuUmxaQ0J5WlhGMVpYTjBJRzFsZEdodlpITmNiblYwYVd4ekxtWnZja1ZoWTJnb1d5ZGtaV3hsZEdVbkxDQW5aMlYwSnl3Z0oyaGxZV1FuTENBbmIzQjBhVzl1Y3lkZExDQm1kVzVqZEdsdmJpQm1iM0pGWVdOb1RXVjBhRzlrVG05RVlYUmhLRzFsZEdodlpDa2dlMXh1SUNBdkttVnpiR2x1ZENCbWRXNWpMVzVoYldWek9qQXFMMXh1SUNCQmVHbHZjeTV3Y205MGIzUjVjR1ZiYldWMGFHOWtYU0E5SUdaMWJtTjBhVzl1S0hWeWJDd2dZMjl1Wm1sbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZ4ZFdWemRDaHRaWEpuWlVOdmJtWnBaeWhqYjI1bWFXY2dmSHdnZTMwc0lIdGNiaUFnSUNBZ0lHMWxkR2h2WkRvZ2JXVjBhRzlrTEZ4dUlDQWdJQ0FnZFhKc09pQjFjbXdzWEc0Z0lDQWdJQ0JrWVhSaE9pQW9ZMjl1Wm1sbklIeDhJSHQ5S1M1a1lYUmhYRzRnSUNBZ2ZTa3BPMXh1SUNCOU8xeHVmU2s3WEc1Y2JuVjBhV3h6TG1admNrVmhZMmdvV3lkd2IzTjBKeXdnSjNCMWRDY3NJQ2R3WVhSamFDZGRMQ0JtZFc1amRHbHZiaUJtYjNKRllXTm9UV1YwYUc5a1YybDBhRVJoZEdFb2JXVjBhRzlrS1NCN1hHNGdJQzhxWlhOc2FXNTBJR1oxYm1NdGJtRnRaWE02TUNvdlhHNGdJRUY0YVc5ekxuQnliM1J2ZEhsd1pWdHRaWFJvYjJSZElEMGdablZ1WTNScGIyNG9kWEpzTENCa1lYUmhMQ0JqYjI1bWFXY3BJSHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjeTV5WlhGMVpYTjBLRzFsY21kbFEyOXVabWxuS0dOdmJtWnBaeUI4ZkNCN2ZTd2dlMXh1SUNBZ0lDQWdiV1YwYUc5a09pQnRaWFJvYjJRc1hHNGdJQ0FnSUNCMWNtdzZJSFZ5YkN4Y2JpQWdJQ0FnSUdSaGRHRTZJR1JoZEdGY2JpQWdJQ0I5S1NrN1hHNGdJSDA3WEc1OUtUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JCZUdsdmN6dGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1ZG1GeUlIVjBhV3h6SUQwZ2NtVnhkV2x5WlNnbkxpOHVMaTkxZEdsc2N5Y3BPMXh1WEc1bWRXNWpkR2x2YmlCSmJuUmxjbU5sY0hSdmNrMWhibUZuWlhJb0tTQjdYRzRnSUhSb2FYTXVhR0Z1Wkd4bGNuTWdQU0JiWFR0Y2JuMWNibHh1THlvcVhHNGdLaUJCWkdRZ1lTQnVaWGNnYVc1MFpYSmpaWEIwYjNJZ2RHOGdkR2hsSUhOMFlXTnJYRzRnS2x4dUlDb2dRSEJoY21GdElIdEdkVzVqZEdsdmJuMGdablZzWm1sc2JHVmtJRlJvWlNCbWRXNWpkR2x2YmlCMGJ5Qm9ZVzVrYkdVZ1lIUm9aVzVnSUdadmNpQmhJR0JRY205dGFYTmxZRnh1SUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ2NtVnFaV04wWldRZ1ZHaGxJR1oxYm1OMGFXOXVJSFJ2SUdoaGJtUnNaU0JnY21WcVpXTjBZQ0JtYjNJZ1lTQmdVSEp2YldselpXQmNiaUFxWEc0Z0tpQkFjbVYwZFhKdUlIdE9kVzFpWlhKOUlFRnVJRWxFSUhWelpXUWdkRzhnY21WdGIzWmxJR2x1ZEdWeVkyVndkRzl5SUd4aGRHVnlYRzRnS2k5Y2JrbHVkR1Z5WTJWd2RHOXlUV0Z1WVdkbGNpNXdjbTkwYjNSNWNHVXVkWE5sSUQwZ1puVnVZM1JwYjI0Z2RYTmxLR1oxYkdacGJHeGxaQ3dnY21WcVpXTjBaV1FwSUh0Y2JpQWdkR2hwY3k1b1lXNWtiR1Z5Y3k1d2RYTm9LSHRjYmlBZ0lDQm1kV3htYVd4c1pXUTZJR1oxYkdacGJHeGxaQ3hjYmlBZ0lDQnlaV3BsWTNSbFpEb2djbVZxWldOMFpXUmNiaUFnZlNrN1hHNGdJSEpsZEhWeWJpQjBhR2x6TG1oaGJtUnNaWEp6TG14bGJtZDBhQ0F0SURFN1hHNTlPMXh1WEc0dktpcGNiaUFxSUZKbGJXOTJaU0JoYmlCcGJuUmxjbU5sY0hSdmNpQm1jbTl0SUhSb1pTQnpkR0ZqYTF4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VG5WdFltVnlmU0JwWkNCVWFHVWdTVVFnZEdoaGRDQjNZWE1nY21WMGRYSnVaV1FnWW5rZ1lIVnpaV0JjYmlBcUwxeHVTVzUwWlhKalpYQjBiM0pOWVc1aFoyVnlMbkJ5YjNSdmRIbHdaUzVsYW1WamRDQTlJR1oxYm1OMGFXOXVJR1ZxWldOMEtHbGtLU0I3WEc0Z0lHbG1JQ2gwYUdsekxtaGhibVJzWlhKelcybGtYU2tnZTF4dUlDQWdJSFJvYVhNdWFHRnVaR3hsY25OYmFXUmRJRDBnYm5Wc2JEdGNiaUFnZlZ4dWZUdGNibHh1THlvcVhHNGdLaUJKZEdWeVlYUmxJRzkyWlhJZ1lXeHNJSFJvWlNCeVpXZHBjM1JsY21Wa0lHbHVkR1Z5WTJWd2RHOXljMXh1SUNwY2JpQXFJRlJvYVhNZ2JXVjBhRzlrSUdseklIQmhjblJwWTNWc1lYSnNlU0IxYzJWbWRXd2dabTl5SUhOcmFYQndhVzVuSUc5MlpYSWdZVzU1WEc0Z0tpQnBiblJsY21ObGNIUnZjbk1nZEdoaGRDQnRZWGtnYUdGMlpTQmlaV052YldVZ1lHNTFiR3hnSUdOaGJHeHBibWNnWUdWcVpXTjBZQzVjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMFoxYm1OMGFXOXVmU0JtYmlCVWFHVWdablZ1WTNScGIyNGdkRzhnWTJGc2JDQm1iM0lnWldGamFDQnBiblJsY21ObGNIUnZjbHh1SUNvdlhHNUpiblJsY21ObGNIUnZjazFoYm1GblpYSXVjSEp2ZEc5MGVYQmxMbVp2Y2tWaFkyZ2dQU0JtZFc1amRHbHZiaUJtYjNKRllXTm9LR1p1S1NCN1hHNGdJSFYwYVd4ekxtWnZja1ZoWTJnb2RHaHBjeTVvWVc1a2JHVnljeXdnWm5WdVkzUnBiMjRnWm05eVJXRmphRWhoYm1Sc1pYSW9hQ2tnZTF4dUlDQWdJR2xtSUNob0lDRTlQU0J1ZFd4c0tTQjdYRzRnSUNBZ0lDQm1iaWhvS1R0Y2JpQWdJQ0I5WEc0Z0lIMHBPMXh1ZlR0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQkpiblJsY21ObGNIUnZjazFoYm1GblpYSTdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQnBjMEZpYzI5c2RYUmxWVkpNSUQwZ2NtVnhkV2x5WlNnbkxpNHZhR1ZzY0dWeWN5OXBjMEZpYzI5c2RYUmxWVkpNSnlrN1hHNTJZWElnWTI5dFltbHVaVlZTVEhNZ1BTQnlaWEYxYVhKbEtDY3VMaTlvWld4d1pYSnpMMk52YldKcGJtVlZVa3h6SnlrN1hHNWNiaThxS2x4dUlDb2dRM0psWVhSbGN5QmhJRzVsZHlCVlVrd2dZbmtnWTI5dFltbHVhVzVuSUhSb1pTQmlZWE5sVlZKTUlIZHBkR2dnZEdobElISmxjWFZsYzNSbFpGVlNUQ3hjYmlBcUlHOXViSGtnZDJobGJpQjBhR1VnY21WeGRXVnpkR1ZrVlZKTUlHbHpJRzV2ZENCaGJISmxZV1I1SUdGdUlHRmljMjlzZFhSbElGVlNUQzVjYmlBcUlFbG1JSFJvWlNCeVpYRjFaWE4wVlZKTUlHbHpJR0ZpYzI5c2RYUmxMQ0IwYUdseklHWjFibU4wYVc5dUlISmxkSFZ5Ym5NZ2RHaGxJSEpsY1hWbGMzUmxaRlZTVENCMWJuUnZkV05vWldRdVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0emRISnBibWQ5SUdKaGMyVlZVa3dnVkdobElHSmhjMlVnVlZKTVhHNGdLaUJBY0dGeVlXMGdlM04wY21sdVozMGdjbVZ4ZFdWemRHVmtWVkpNSUVGaWMyOXNkWFJsSUc5eUlISmxiR0YwYVhabElGVlNUQ0IwYnlCamIyMWlhVzVsWEc0Z0tpQkFjbVYwZFhKdWN5QjdjM1J5YVc1bmZTQlVhR1VnWTI5dFltbHVaV1FnWm5Wc2JDQndZWFJvWEc0Z0tpOWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdZblZwYkdSR2RXeHNVR0YwYUNoaVlYTmxWVkpNTENCeVpYRjFaWE4wWldSVlVrd3BJSHRjYmlBZ2FXWWdLR0poYzJWVlVrd2dKaVlnSVdselFXSnpiMngxZEdWVlVrd29jbVZ4ZFdWemRHVmtWVkpNS1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJqYjIxaWFXNWxWVkpNY3loaVlYTmxWVkpNTENCeVpYRjFaWE4wWldSVlVrd3BPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnlaWEYxWlhOMFpXUlZVa3c3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ1pXNW9ZVzVqWlVWeWNtOXlJRDBnY21WeGRXbHlaU2duTGk5bGJtaGhibU5sUlhKeWIzSW5LVHRjYmx4dUx5b3FYRzRnS2lCRGNtVmhkR1VnWVc0Z1JYSnliM0lnZDJsMGFDQjBhR1VnYzNCbFkybG1hV1ZrSUcxbGMzTmhaMlVzSUdOdmJtWnBaeXdnWlhKeWIzSWdZMjlrWlN3Z2NtVnhkV1Z6ZENCaGJtUWdjbVZ6Y0c5dWMyVXVYRzRnS2x4dUlDb2dRSEJoY21GdElIdHpkSEpwYm1kOUlHMWxjM05oWjJVZ1ZHaGxJR1Z5Y205eUlHMWxjM05oWjJVdVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdZMjl1Wm1sbklGUm9aU0JqYjI1bWFXY3VYRzRnS2lCQWNHRnlZVzBnZTNOMGNtbHVaMzBnVzJOdlpHVmRJRlJvWlNCbGNuSnZjaUJqYjJSbElDaG1iM0lnWlhoaGJYQnNaU3dnSjBWRFQwNU9RVUpQVWxSRlJDY3BMbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUZ0eVpYRjFaWE4wWFNCVWFHVWdjbVZ4ZFdWemRDNWNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0JiY21WemNHOXVjMlZkSUZSb1pTQnlaWE53YjI1elpTNWNiaUFxSUVCeVpYUjFjbTV6SUh0RmNuSnZjbjBnVkdobElHTnlaV0YwWldRZ1pYSnliM0l1WEc0Z0tpOWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdZM0psWVhSbFJYSnliM0lvYldWemMyRm5aU3dnWTI5dVptbG5MQ0JqYjJSbExDQnlaWEYxWlhOMExDQnlaWE53YjI1elpTa2dlMXh1SUNCMllYSWdaWEp5YjNJZ1BTQnVaWGNnUlhKeWIzSW9iV1Z6YzJGblpTazdYRzRnSUhKbGRIVnliaUJsYm1oaGJtTmxSWEp5YjNJb1pYSnliM0lzSUdOdmJtWnBaeXdnWTI5a1pTd2djbVZ4ZFdWemRDd2djbVZ6Y0c5dWMyVXBPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVkbUZ5SUhWMGFXeHpJRDBnY21WeGRXbHlaU2duTGk4dUxpOTFkR2xzY3ljcE8xeHVkbUZ5SUhSeVlXNXpabTl5YlVSaGRHRWdQU0J5WlhGMWFYSmxLQ2N1TDNSeVlXNXpabTl5YlVSaGRHRW5LVHRjYm5aaGNpQnBjME5oYm1ObGJDQTlJSEpsY1hWcGNtVW9KeTR1TDJOaGJtTmxiQzlwYzBOaGJtTmxiQ2NwTzF4dWRtRnlJR1JsWm1GMWJIUnpJRDBnY21WeGRXbHlaU2duTGk0dlpHVm1ZWFZzZEhNbktUdGNibHh1THlvcVhHNGdLaUJVYUhKdmQzTWdZU0JnUTJGdVkyVnNZQ0JwWmlCallXNWpaV3hzWVhScGIyNGdhR0Z6SUdKbFpXNGdjbVZ4ZFdWemRHVmtMbHh1SUNvdlhHNW1kVzVqZEdsdmJpQjBhSEp2ZDBsbVEyRnVZMlZzYkdGMGFXOXVVbVZ4ZFdWemRHVmtLR052Ym1acFp5a2dlMXh1SUNCcFppQW9ZMjl1Wm1sbkxtTmhibU5sYkZSdmEyVnVLU0I3WEc0Z0lDQWdZMjl1Wm1sbkxtTmhibU5sYkZSdmEyVnVMblJvY205M1NXWlNaWEYxWlhOMFpXUW9LVHRjYmlBZ2ZWeHVmVnh1WEc0dktpcGNiaUFxSUVScGMzQmhkR05vSUdFZ2NtVnhkV1Z6ZENCMGJ5QjBhR1VnYzJWeWRtVnlJSFZ6YVc1bklIUm9aU0JqYjI1bWFXZDFjbVZrSUdGa1lYQjBaWEl1WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHR2WW1wbFkzUjlJR052Ym1acFp5QlVhR1VnWTI5dVptbG5JSFJvWVhRZ2FYTWdkRzhnWW1VZ2RYTmxaQ0JtYjNJZ2RHaGxJSEpsY1hWbGMzUmNiaUFxSUVCeVpYUjFjbTV6SUh0UWNtOXRhWE5sZlNCVWFHVWdVSEp2YldselpTQjBieUJpWlNCbWRXeG1hV3hzWldSY2JpQXFMMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJrYVhOd1lYUmphRkpsY1hWbGMzUW9ZMjl1Wm1sbktTQjdYRzRnSUhSb2NtOTNTV1pEWVc1alpXeHNZWFJwYjI1U1pYRjFaWE4wWldRb1kyOXVabWxuS1R0Y2JseHVJQ0F2THlCRmJuTjFjbVVnYUdWaFpHVnljeUJsZUdsemRGeHVJQ0JqYjI1bWFXY3VhR1ZoWkdWeWN5QTlJR052Ym1acFp5NW9aV0ZrWlhKeklIeDhJSHQ5TzF4dVhHNGdJQzh2SUZSeVlXNXpabTl5YlNCeVpYRjFaWE4wSUdSaGRHRmNiaUFnWTI5dVptbG5MbVJoZEdFZ1BTQjBjbUZ1YzJadmNtMUVZWFJoS0Z4dUlDQWdJR052Ym1acFp5NWtZWFJoTEZ4dUlDQWdJR052Ym1acFp5NW9aV0ZrWlhKekxGeHVJQ0FnSUdOdmJtWnBaeTUwY21GdWMyWnZjbTFTWlhGMVpYTjBYRzRnSUNrN1hHNWNiaUFnTHk4Z1JteGhkSFJsYmlCb1pXRmtaWEp6WEc0Z0lHTnZibVpwWnk1b1pXRmtaWEp6SUQwZ2RYUnBiSE11YldWeVoyVW9YRzRnSUNBZ1kyOXVabWxuTG1obFlXUmxjbk11WTI5dGJXOXVJSHg4SUh0OUxGeHVJQ0FnSUdOdmJtWnBaeTVvWldGa1pYSnpXMk52Ym1acFp5NXRaWFJvYjJSZElIeDhJSHQ5TEZ4dUlDQWdJR052Ym1acFp5NW9aV0ZrWlhKelhHNGdJQ2s3WEc1Y2JpQWdkWFJwYkhNdVptOXlSV0ZqYUNoY2JpQWdJQ0JiSjJSbGJHVjBaU2NzSUNkblpYUW5MQ0FuYUdWaFpDY3NJQ2R3YjNOMEp5d2dKM0IxZENjc0lDZHdZWFJqYUNjc0lDZGpiMjF0YjI0blhTeGNiaUFnSUNCbWRXNWpkR2x2YmlCamJHVmhia2hsWVdSbGNrTnZibVpwWnlodFpYUm9iMlFwSUh0Y2JpQWdJQ0FnSUdSbGJHVjBaU0JqYjI1bWFXY3VhR1ZoWkdWeWMxdHRaWFJvYjJSZE8xeHVJQ0FnSUgxY2JpQWdLVHRjYmx4dUlDQjJZWElnWVdSaGNIUmxjaUE5SUdOdmJtWnBaeTVoWkdGd2RHVnlJSHg4SUdSbFptRjFiSFJ6TG1Ga1lYQjBaWEk3WEc1Y2JpQWdjbVYwZFhKdUlHRmtZWEIwWlhJb1kyOXVabWxuS1M1MGFHVnVLR1oxYm1OMGFXOXVJRzl1UVdSaGNIUmxjbEpsYzI5c2RYUnBiMjRvY21WemNHOXVjMlVwSUh0Y2JpQWdJQ0IwYUhKdmQwbG1RMkZ1WTJWc2JHRjBhVzl1VW1WeGRXVnpkR1ZrS0dOdmJtWnBaeWs3WEc1Y2JpQWdJQ0F2THlCVWNtRnVjMlp2Y20wZ2NtVnpjRzl1YzJVZ1pHRjBZVnh1SUNBZ0lISmxjM0J2Ym5ObExtUmhkR0VnUFNCMGNtRnVjMlp2Y20xRVlYUmhLRnh1SUNBZ0lDQWdjbVZ6Y0c5dWMyVXVaR0YwWVN4Y2JpQWdJQ0FnSUhKbGMzQnZibk5sTG1obFlXUmxjbk1zWEc0Z0lDQWdJQ0JqYjI1bWFXY3VkSEpoYm5ObWIzSnRVbVZ6Y0c5dWMyVmNiaUFnSUNBcE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhKbGMzQnZibk5sTzF4dUlDQjlMQ0JtZFc1amRHbHZiaUJ2YmtGa1lYQjBaWEpTWldwbFkzUnBiMjRvY21WaGMyOXVLU0I3WEc0Z0lDQWdhV1lnS0NGcGMwTmhibU5sYkNoeVpXRnpiMjRwS1NCN1hHNGdJQ0FnSUNCMGFISnZkMGxtUTJGdVkyVnNiR0YwYVc5dVVtVnhkV1Z6ZEdWa0tHTnZibVpwWnlrN1hHNWNiaUFnSUNBZ0lDOHZJRlJ5WVc1elptOXliU0J5WlhOd2IyNXpaU0JrWVhSaFhHNGdJQ0FnSUNCcFppQW9jbVZoYzI5dUlDWW1JSEpsWVhOdmJpNXlaWE53YjI1elpTa2dlMXh1SUNBZ0lDQWdJQ0J5WldGemIyNHVjbVZ6Y0c5dWMyVXVaR0YwWVNBOUlIUnlZVzV6Wm05eWJVUmhkR0VvWEc0Z0lDQWdJQ0FnSUNBZ2NtVmhjMjl1TG5KbGMzQnZibk5sTG1SaGRHRXNYRzRnSUNBZ0lDQWdJQ0FnY21WaGMyOXVMbkpsYzNCdmJuTmxMbWhsWVdSbGNuTXNYRzRnSUNBZ0lDQWdJQ0FnWTI5dVptbG5MblJ5WVc1elptOXliVkpsYzNCdmJuTmxYRzRnSUNBZ0lDQWdJQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlGQnliMjFwYzJVdWNtVnFaV04wS0hKbFlYTnZiaWs3WEc0Z0lIMHBPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVMeW9xWEc0Z0tpQlZjR1JoZEdVZ1lXNGdSWEp5YjNJZ2QybDBhQ0IwYUdVZ2MzQmxZMmxtYVdWa0lHTnZibVpwWnl3Z1pYSnliM0lnWTI5a1pTd2dZVzVrSUhKbGMzQnZibk5sTGx4dUlDcGNiaUFxSUVCd1lYSmhiU0I3UlhKeWIzSjlJR1Z5Y205eUlGUm9aU0JsY25KdmNpQjBieUIxY0dSaGRHVXVYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnWTI5dVptbG5JRlJvWlNCamIyNW1hV2N1WEc0Z0tpQkFjR0Z5WVcwZ2UzTjBjbWx1WjMwZ1cyTnZaR1ZkSUZSb1pTQmxjbkp2Y2lCamIyUmxJQ2htYjNJZ1pYaGhiWEJzWlN3Z0owVkRUMDVPUVVKUFVsUkZSQ2NwTGx4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlGdHlaWEYxWlhOMFhTQlVhR1VnY21WeGRXVnpkQzVjYmlBcUlFQndZWEpoYlNCN1QySnFaV04wZlNCYmNtVnpjRzl1YzJWZElGUm9aU0J5WlhOd2IyNXpaUzVjYmlBcUlFQnlaWFIxY201eklIdEZjbkp2Y24wZ1ZHaGxJR1Z5Y205eUxseHVJQ292WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUdWdWFHRnVZMlZGY25KdmNpaGxjbkp2Y2l3Z1kyOXVabWxuTENCamIyUmxMQ0J5WlhGMVpYTjBMQ0J5WlhOd2IyNXpaU2tnZTF4dUlDQmxjbkp2Y2k1amIyNW1hV2NnUFNCamIyNW1hV2M3WEc0Z0lHbG1JQ2hqYjJSbEtTQjdYRzRnSUNBZ1pYSnliM0l1WTI5a1pTQTlJR052WkdVN1hHNGdJSDFjYmx4dUlDQmxjbkp2Y2k1eVpYRjFaWE4wSUQwZ2NtVnhkV1Z6ZER0Y2JpQWdaWEp5YjNJdWNtVnpjRzl1YzJVZ1BTQnlaWE53YjI1elpUdGNiaUFnWlhKeWIzSXVhWE5CZUdsdmMwVnljbTl5SUQwZ2RISjFaVHRjYmx4dUlDQmxjbkp2Y2k1MGIwcFRUMDRnUFNCbWRXNWpkR2x2YmlCMGIwcFRUMDRvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSHRjYmlBZ0lDQWdJQzh2SUZOMFlXNWtZWEprWEc0Z0lDQWdJQ0J0WlhOellXZGxPaUIwYUdsekxtMWxjM05oWjJVc1hHNGdJQ0FnSUNCdVlXMWxPaUIwYUdsekxtNWhiV1VzWEc0Z0lDQWdJQ0F2THlCTmFXTnliM052Wm5SY2JpQWdJQ0FnSUdSbGMyTnlhWEIwYVc5dU9pQjBhR2x6TG1SbGMyTnlhWEIwYVc5dUxGeHVJQ0FnSUNBZ2JuVnRZbVZ5T2lCMGFHbHpMbTUxYldKbGNpeGNiaUFnSUNBZ0lDOHZJRTF2ZW1sc2JHRmNiaUFnSUNBZ0lHWnBiR1ZPWVcxbE9pQjBhR2x6TG1acGJHVk9ZVzFsTEZ4dUlDQWdJQ0FnYkdsdVpVNTFiV0psY2pvZ2RHaHBjeTVzYVc1bFRuVnRZbVZ5TEZ4dUlDQWdJQ0FnWTI5c2RXMXVUblZ0WW1WeU9pQjBhR2x6TG1OdmJIVnRiazUxYldKbGNpeGNiaUFnSUNBZ0lITjBZV05yT2lCMGFHbHpMbk4wWVdOckxGeHVJQ0FnSUNBZ0x5OGdRWGhwYjNOY2JpQWdJQ0FnSUdOdmJtWnBaem9nZEdocGN5NWpiMjVtYVdjc1hHNGdJQ0FnSUNCamIyUmxPaUIwYUdsekxtTnZaR1ZjYmlBZ0lDQjlPMXh1SUNCOU8xeHVJQ0J5WlhSMWNtNGdaWEp5YjNJN1hHNTlPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdkWFJwYkhNZ1BTQnlaWEYxYVhKbEtDY3VMaTkxZEdsc2N5Y3BPMXh1WEc0dktpcGNiaUFxSUVOdmJtWnBaeTF6Y0dWamFXWnBZeUJ0WlhKblpTMW1kVzVqZEdsdmJpQjNhR2xqYUNCamNtVmhkR1Z6SUdFZ2JtVjNJR052Ym1acFp5MXZZbXBsWTNSY2JpQXFJR0o1SUcxbGNtZHBibWNnZEhkdklHTnZibVpwWjNWeVlYUnBiMjRnYjJKcVpXTjBjeUIwYjJkbGRHaGxjaTVjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdZMjl1Wm1sbk1WeHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJR052Ym1acFp6SmNiaUFxSUVCeVpYUjFjbTV6SUh0UFltcGxZM1I5SUU1bGR5QnZZbXBsWTNRZ2NtVnpkV3gwYVc1bklHWnliMjBnYldWeVoybHVaeUJqYjI1bWFXY3lJSFJ2SUdOdmJtWnBaekZjYmlBcUwxeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQnRaWEpuWlVOdmJtWnBaeWhqYjI1bWFXY3hMQ0JqYjI1bWFXY3lLU0I3WEc0Z0lDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXNWxlSFF0YkdsdVpTQnVieTF3WVhKaGJTMXlaV0Z6YzJsbmJseHVJQ0JqYjI1bWFXY3lJRDBnWTI5dVptbG5NaUI4ZkNCN2ZUdGNiaUFnZG1GeUlHTnZibVpwWnlBOUlIdDlPMXh1WEc0Z0lIWmhjaUIyWVd4MVpVWnliMjFEYjI1bWFXY3lTMlY1Y3lBOUlGc25kWEpzSnl3Z0oyMWxkR2h2WkNjc0lDZGtZWFJoSjEwN1hHNGdJSFpoY2lCdFpYSm5aVVJsWlhCUWNtOXdaWEowYVdWelMyVjVjeUE5SUZzbmFHVmhaR1Z5Y3ljc0lDZGhkWFJvSnl3Z0ozQnliM2g1Snl3Z0ozQmhjbUZ0Y3lkZE8xeHVJQ0IyWVhJZ1pHVm1ZWFZzZEZSdlEyOXVabWxuTWt0bGVYTWdQU0JiWEc0Z0lDQWdKMkpoYzJWVlVrd25MQ0FuZEhKaGJuTm1iM0p0VW1WeGRXVnpkQ2NzSUNkMGNtRnVjMlp2Y20xU1pYTndiMjV6WlNjc0lDZHdZWEpoYlhOVFpYSnBZV3hwZW1WeUp5eGNiaUFnSUNBbmRHbHRaVzkxZENjc0lDZDBhVzFsYjNWMFRXVnpjMkZuWlNjc0lDZDNhWFJvUTNKbFpHVnVkR2xoYkhNbkxDQW5ZV1JoY0hSbGNpY3NJQ2R5WlhOd2IyNXpaVlI1Y0dVbkxDQW5lSE55WmtOdmIydHBaVTVoYldVbkxGeHVJQ0FnSUNkNGMzSm1TR1ZoWkdWeVRtRnRaU2NzSUNkdmJsVndiRzloWkZCeWIyZHlaWE56Snl3Z0oyOXVSRzkzYm14dllXUlFjbTluY21WemN5Y3NJQ2RrWldOdmJYQnlaWE56Snl4Y2JpQWdJQ0FuYldGNFEyOXVkR1Z1ZEV4bGJtZDBhQ2NzSUNkdFlYaENiMlI1VEdWdVozUm9KeXdnSjIxaGVGSmxaR2x5WldOMGN5Y3NJQ2QwY21GdWMzQnZjblFuTENBbmFIUjBjRUZuWlc1MEp5eGNiaUFnSUNBbmFIUjBjSE5CWjJWdWRDY3NJQ2RqWVc1alpXeFViMnRsYmljc0lDZHpiMk5yWlhSUVlYUm9KeXdnSjNKbGMzQnZibk5sUlc1amIyUnBibWNuWEc0Z0lGMDdYRzRnSUhaaGNpQmthWEpsWTNSTlpYSm5aVXRsZVhNZ1BTQmJKM1poYkdsa1lYUmxVM1JoZEhWekoxMDdYRzVjYmlBZ1puVnVZM1JwYjI0Z1oyVjBUV1Z5WjJWa1ZtRnNkV1VvZEdGeVoyVjBMQ0J6YjNWeVkyVXBJSHRjYmlBZ0lDQnBaaUFvZFhScGJITXVhWE5RYkdGcGJrOWlhbVZqZENoMFlYSm5aWFFwSUNZbUlIVjBhV3h6TG1selVHeGhhVzVQWW1wbFkzUW9jMjkxY21ObEtTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIVjBhV3h6TG0xbGNtZGxLSFJoY21kbGRDd2djMjkxY21ObEtUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tIVjBhV3h6TG1selVHeGhhVzVQWW1wbFkzUW9jMjkxY21ObEtTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIVjBhV3h6TG0xbGNtZGxLSHQ5TENCemIzVnlZMlVwTzF4dUlDQWdJSDBnWld4elpTQnBaaUFvZFhScGJITXVhWE5CY25KaGVTaHpiM1Z5WTJVcEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2MyOTFjbU5sTG5Oc2FXTmxLQ2s3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCemIzVnlZMlU3WEc0Z0lIMWNibHh1SUNCbWRXNWpkR2x2YmlCdFpYSm5aVVJsWlhCUWNtOXdaWEowYVdWektIQnliM0FwSUh0Y2JpQWdJQ0JwWmlBb0lYVjBhV3h6TG1selZXNWtaV1pwYm1Wa0tHTnZibVpwWnpKYmNISnZjRjBwS1NCN1hHNGdJQ0FnSUNCamIyNW1hV2RiY0hKdmNGMGdQU0JuWlhSTlpYSm5aV1JXWVd4MVpTaGpiMjVtYVdjeFczQnliM0JkTENCamIyNW1hV2N5VzNCeWIzQmRLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLQ0YxZEdsc2N5NXBjMVZ1WkdWbWFXNWxaQ2hqYjI1bWFXY3hXM0J5YjNCZEtTa2dlMXh1SUNBZ0lDQWdZMjl1Wm1sblczQnliM0JkSUQwZ1oyVjBUV1Z5WjJWa1ZtRnNkV1VvZFc1a1pXWnBibVZrTENCamIyNW1hV2N4VzNCeWIzQmRLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0IxZEdsc2N5NW1iM0pGWVdOb0tIWmhiSFZsUm5KdmJVTnZibVpwWnpKTFpYbHpMQ0JtZFc1amRHbHZiaUIyWVd4MVpVWnliMjFEYjI1bWFXY3lLSEJ5YjNBcElIdGNiaUFnSUNCcFppQW9JWFYwYVd4ekxtbHpWVzVrWldacGJtVmtLR052Ym1acFp6SmJjSEp2Y0YwcEtTQjdYRzRnSUNBZ0lDQmpiMjVtYVdkYmNISnZjRjBnUFNCblpYUk5aWEpuWldSV1lXeDFaU2gxYm1SbFptbHVaV1FzSUdOdmJtWnBaekpiY0hKdmNGMHBPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNWNiaUFnZFhScGJITXVabTl5UldGamFDaHRaWEpuWlVSbFpYQlFjbTl3WlhKMGFXVnpTMlY1Y3l3Z2JXVnlaMlZFWldWd1VISnZjR1Z5ZEdsbGN5azdYRzVjYmlBZ2RYUnBiSE11Wm05eVJXRmphQ2hrWldaaGRXeDBWRzlEYjI1bWFXY3lTMlY1Y3l3Z1puVnVZM1JwYjI0Z1pHVm1ZWFZzZEZSdlEyOXVabWxuTWlod2NtOXdLU0I3WEc0Z0lDQWdhV1lnS0NGMWRHbHNjeTVwYzFWdVpHVm1hVzVsWkNoamIyNW1hV2N5VzNCeWIzQmRLU2tnZTF4dUlDQWdJQ0FnWTI5dVptbG5XM0J5YjNCZElEMGdaMlYwVFdWeVoyVmtWbUZzZFdVb2RXNWtaV1pwYm1Wa0xDQmpiMjVtYVdjeVczQnliM0JkS1R0Y2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0NGMWRHbHNjeTVwYzFWdVpHVm1hVzVsWkNoamIyNW1hV2N4VzNCeWIzQmRLU2tnZTF4dUlDQWdJQ0FnWTI5dVptbG5XM0J5YjNCZElEMGdaMlYwVFdWeVoyVmtWbUZzZFdVb2RXNWtaV1pwYm1Wa0xDQmpiMjVtYVdjeFczQnliM0JkS1R0Y2JpQWdJQ0I5WEc0Z0lIMHBPMXh1WEc0Z0lIVjBhV3h6TG1admNrVmhZMmdvWkdseVpXTjBUV1Z5WjJWTFpYbHpMQ0JtZFc1amRHbHZiaUJ0WlhKblpTaHdjbTl3S1NCN1hHNGdJQ0FnYVdZZ0tIQnliM0FnYVc0Z1kyOXVabWxuTWlrZ2UxeHVJQ0FnSUNBZ1kyOXVabWxuVzNCeWIzQmRJRDBnWjJWMFRXVnlaMlZrVm1Gc2RXVW9ZMjl1Wm1sbk1WdHdjbTl3WFN3Z1kyOXVabWxuTWx0d2NtOXdYU2s3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2h3Y205d0lHbHVJR052Ym1acFp6RXBJSHRjYmlBZ0lDQWdJR052Ym1acFoxdHdjbTl3WFNBOUlHZGxkRTFsY21kbFpGWmhiSFZsS0hWdVpHVm1hVzVsWkN3Z1kyOXVabWxuTVZ0d2NtOXdYU2s3WEc0Z0lDQWdmVnh1SUNCOUtUdGNibHh1SUNCMllYSWdZWGhwYjNOTFpYbHpJRDBnZG1Gc2RXVkdjbTl0UTI5dVptbG5Na3RsZVhOY2JpQWdJQ0F1WTI5dVkyRjBLRzFsY21kbFJHVmxjRkJ5YjNCbGNuUnBaWE5MWlhsektWeHVJQ0FnSUM1amIyNWpZWFFvWkdWbVlYVnNkRlJ2UTI5dVptbG5Na3RsZVhNcFhHNGdJQ0FnTG1OdmJtTmhkQ2hrYVhKbFkzUk5aWEpuWlV0bGVYTXBPMXh1WEc0Z0lIWmhjaUJ2ZEdobGNrdGxlWE1nUFNCUFltcGxZM1JjYmlBZ0lDQXVhMlY1Y3loamIyNW1hV2N4S1Z4dUlDQWdJQzVqYjI1allYUW9UMkpxWldOMExtdGxlWE1vWTI5dVptbG5NaWtwWEc0Z0lDQWdMbVpwYkhSbGNpaG1kVzVqZEdsdmJpQm1hV3gwWlhKQmVHbHZjMHRsZVhNb2EyVjVLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdZWGhwYjNOTFpYbHpMbWx1WkdWNFQyWW9hMlY1S1NBOVBUMGdMVEU3WEc0Z0lDQWdmU2s3WEc1Y2JpQWdkWFJwYkhNdVptOXlSV0ZqYUNodmRHaGxja3RsZVhNc0lHMWxjbWRsUkdWbGNGQnliM0JsY25ScFpYTXBPMXh1WEc0Z0lISmxkSFZ5YmlCamIyNW1hV2M3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ1kzSmxZWFJsUlhKeWIzSWdQU0J5WlhGMWFYSmxLQ2N1TDJOeVpXRjBaVVZ5Y205eUp5azdYRzVjYmk4cUtseHVJQ29nVW1WemIyeDJaU0J2Y2lCeVpXcGxZM1FnWVNCUWNtOXRhWE5sSUdKaGMyVmtJRzl1SUhKbGMzQnZibk5sSUhOMFlYUjFjeTVjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMFoxYm1OMGFXOXVmU0J5WlhOdmJIWmxJRUVnWm5WdVkzUnBiMjRnZEdoaGRDQnlaWE52YkhabGN5QjBhR1VnY0hKdmJXbHpaUzVjYmlBcUlFQndZWEpoYlNCN1JuVnVZM1JwYjI1OUlISmxhbVZqZENCQklHWjFibU4wYVc5dUlIUm9ZWFFnY21WcVpXTjBjeUIwYUdVZ2NISnZiV2x6WlM1Y2JpQXFJRUJ3WVhKaGJTQjdiMkpxWldOMGZTQnlaWE53YjI1elpTQlVhR1VnY21WemNHOXVjMlV1WEc0Z0tpOWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdjMlYwZEd4bEtISmxjMjlzZG1Vc0lISmxhbVZqZEN3Z2NtVnpjRzl1YzJVcElIdGNiaUFnZG1GeUlIWmhiR2xrWVhSbFUzUmhkSFZ6SUQwZ2NtVnpjRzl1YzJVdVkyOXVabWxuTG5aaGJHbGtZWFJsVTNSaGRIVnpPMXh1SUNCcFppQW9JWEpsYzNCdmJuTmxMbk4wWVhSMWN5QjhmQ0FoZG1Gc2FXUmhkR1ZUZEdGMGRYTWdmSHdnZG1Gc2FXUmhkR1ZUZEdGMGRYTW9jbVZ6Y0c5dWMyVXVjM1JoZEhWektTa2dlMXh1SUNBZ0lISmxjMjlzZG1Vb2NtVnpjRzl1YzJVcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxhbVZqZENoamNtVmhkR1ZGY25KdmNpaGNiaUFnSUNBZ0lDZFNaWEYxWlhOMElHWmhhV3hsWkNCM2FYUm9JSE4wWVhSMWN5QmpiMlJsSUNjZ0t5QnlaWE53YjI1elpTNXpkR0YwZFhNc1hHNGdJQ0FnSUNCeVpYTndiMjV6WlM1amIyNW1hV2NzWEc0Z0lDQWdJQ0J1ZFd4c0xGeHVJQ0FnSUNBZ2NtVnpjRzl1YzJVdWNtVnhkV1Z6ZEN4Y2JpQWdJQ0FnSUhKbGMzQnZibk5sWEc0Z0lDQWdLU2s3WEc0Z0lIMWNibjA3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUIxZEdsc2N5QTlJSEpsY1hWcGNtVW9KeTR2TGk0dmRYUnBiSE1uS1R0Y2JseHVMeW9xWEc0Z0tpQlVjbUZ1YzJadmNtMGdkR2hsSUdSaGRHRWdabTl5SUdFZ2NtVnhkV1Z6ZENCdmNpQmhJSEpsYzNCdmJuTmxYRzRnS2x4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOFUzUnlhVzVuZlNCa1lYUmhJRlJvWlNCa1lYUmhJSFJ2SUdKbElIUnlZVzV6Wm05eWJXVmtYRzRnS2lCQWNHRnlZVzBnZTBGeWNtRjVmU0JvWldGa1pYSnpJRlJvWlNCb1pXRmtaWEp6SUdadmNpQjBhR1VnY21WeGRXVnpkQ0J2Y2lCeVpYTndiMjV6WlZ4dUlDb2dRSEJoY21GdElIdEJjbkpoZVh4R2RXNWpkR2x2Ym4wZ1ptNXpJRUVnYzJsdVoyeGxJR1oxYm1OMGFXOXVJRzl5SUVGeWNtRjVJRzltSUdaMWJtTjBhVzl1YzF4dUlDb2dRSEpsZEhWeWJuTWdleXA5SUZSb1pTQnlaWE4xYkhScGJtY2dkSEpoYm5ObWIzSnRaV1FnWkdGMFlWeHVJQ292WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUhSeVlXNXpabTl5YlVSaGRHRW9aR0YwWVN3Z2FHVmhaR1Z5Y3l3Z1ptNXpLU0I3WEc0Z0lDOHFaWE5zYVc1MElHNXZMWEJoY21GdExYSmxZWE56YVdkdU9qQXFMMXh1SUNCMWRHbHNjeTVtYjNKRllXTm9LR1p1Y3l3Z1puVnVZM1JwYjI0Z2RISmhibk5tYjNKdEtHWnVLU0I3WEc0Z0lDQWdaR0YwWVNBOUlHWnVLR1JoZEdFc0lHaGxZV1JsY25NcE8xeHVJQ0I5S1R0Y2JseHVJQ0J5WlhSMWNtNGdaR0YwWVR0Y2JuMDdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQjFkR2xzY3lBOUlISmxjWFZwY21Vb0p5NHZkWFJwYkhNbktUdGNiblpoY2lCdWIzSnRZV3hwZW1WSVpXRmtaWEpPWVcxbElEMGdjbVZ4ZFdseVpTZ25MaTlvWld4d1pYSnpMMjV2Y20xaGJHbDZaVWhsWVdSbGNrNWhiV1VuS1R0Y2JseHVkbUZ5SUVSRlJrRlZURlJmUTA5T1ZFVk9WRjlVV1ZCRklEMGdlMXh1SUNBblEyOXVkR1Z1ZEMxVWVYQmxKem9nSjJGd2NHeHBZMkYwYVc5dUwzZ3RkM2QzTFdadmNtMHRkWEpzWlc1amIyUmxaQ2RjYm4wN1hHNWNibVoxYm1OMGFXOXVJSE5sZEVOdmJuUmxiblJVZVhCbFNXWlZibk5sZENob1pXRmtaWEp6TENCMllXeDFaU2tnZTF4dUlDQnBaaUFvSVhWMGFXeHpMbWx6Vlc1a1pXWnBibVZrS0dobFlXUmxjbk1wSUNZbUlIVjBhV3h6TG1selZXNWtaV1pwYm1Wa0tHaGxZV1JsY25OYkowTnZiblJsYm5RdFZIbHdaU2RkS1NrZ2UxeHVJQ0FnSUdobFlXUmxjbk5iSjBOdmJuUmxiblF0Vkhsd1pTZGRJRDBnZG1Gc2RXVTdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnWjJWMFJHVm1ZWFZzZEVGa1lYQjBaWElvS1NCN1hHNGdJSFpoY2lCaFpHRndkR1Z5TzF4dUlDQnBaaUFvZEhsd1pXOW1JRmhOVEVoMGRIQlNaWEYxWlhOMElDRTlQU0FuZFc1a1pXWnBibVZrSnlrZ2UxeHVJQ0FnSUM4dklFWnZjaUJpY205M2MyVnljeUIxYzJVZ1dFaFNJR0ZrWVhCMFpYSmNiaUFnSUNCaFpHRndkR1Z5SUQwZ2NtVnhkV2x5WlNnbkxpOWhaR0Z3ZEdWeWN5OTRhSEluS1R0Y2JpQWdmU0JsYkhObElHbG1JQ2gwZVhCbGIyWWdjSEp2WTJWemN5QWhQVDBnSjNWdVpHVm1hVzVsWkNjZ0ppWWdUMkpxWldOMExuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5NWpZV3hzS0hCeWIyTmxjM01wSUQwOVBTQW5XMjlpYW1WamRDQndjbTlqWlhOelhTY3BJSHRjYmlBZ0lDQXZMeUJHYjNJZ2JtOWtaU0IxYzJVZ1NGUlVVQ0JoWkdGd2RHVnlYRzRnSUNBZ1lXUmhjSFJsY2lBOUlISmxjWFZwY21Vb0p5NHZZV1JoY0hSbGNuTXZhSFIwY0NjcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCaFpHRndkR1Z5TzF4dWZWeHVYRzUyWVhJZ1pHVm1ZWFZzZEhNZ1BTQjdYRzRnSUdGa1lYQjBaWEk2SUdkbGRFUmxabUYxYkhSQlpHRndkR1Z5S0Nrc1hHNWNiaUFnZEhKaGJuTm1iM0p0VW1WeGRXVnpkRG9nVzJaMWJtTjBhVzl1SUhSeVlXNXpabTl5YlZKbGNYVmxjM1FvWkdGMFlTd2dhR1ZoWkdWeWN5a2dlMXh1SUNBZ0lHNXZjbTFoYkdsNlpVaGxZV1JsY2s1aGJXVW9hR1ZoWkdWeWN5d2dKMEZqWTJWd2RDY3BPMXh1SUNBZ0lHNXZjbTFoYkdsNlpVaGxZV1JsY2s1aGJXVW9hR1ZoWkdWeWN5d2dKME52Ym5SbGJuUXRWSGx3WlNjcE8xeHVJQ0FnSUdsbUlDaDFkR2xzY3k1cGMwWnZjbTFFWVhSaEtHUmhkR0VwSUh4OFhHNGdJQ0FnSUNCMWRHbHNjeTVwYzBGeWNtRjVRblZtWm1WeUtHUmhkR0VwSUh4OFhHNGdJQ0FnSUNCMWRHbHNjeTVwYzBKMVptWmxjaWhrWVhSaEtTQjhmRnh1SUNBZ0lDQWdkWFJwYkhNdWFYTlRkSEpsWVcwb1pHRjBZU2tnZkh4Y2JpQWdJQ0FnSUhWMGFXeHpMbWx6Um1sc1pTaGtZWFJoS1NCOGZGeHVJQ0FnSUNBZ2RYUnBiSE11YVhOQ2JHOWlLR1JoZEdFcFhHNGdJQ0FnS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWkdGMFlUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tIVjBhV3h6TG1selFYSnlZWGxDZFdabVpYSldhV1YzS0dSaGRHRXBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdaR0YwWVM1aWRXWm1aWEk3WEc0Z0lDQWdmVnh1SUNBZ0lHbG1JQ2gxZEdsc2N5NXBjMVZTVEZObFlYSmphRkJoY21GdGN5aGtZWFJoS1NrZ2UxeHVJQ0FnSUNBZ2MyVjBRMjl1ZEdWdWRGUjVjR1ZKWmxWdWMyVjBLR2hsWVdSbGNuTXNJQ2RoY0hCc2FXTmhkR2x2Ymk5NExYZDNkeTFtYjNKdExYVnliR1Z1WTI5a1pXUTdZMmhoY25ObGREMTFkR1l0T0NjcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUdSaGRHRXVkRzlUZEhKcGJtY29LVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLSFYwYVd4ekxtbHpUMkpxWldOMEtHUmhkR0VwS1NCN1hHNGdJQ0FnSUNCelpYUkRiMjUwWlc1MFZIbHdaVWxtVlc1elpYUW9hR1ZoWkdWeWN5d2dKMkZ3Y0d4cFkyRjBhVzl1TDJwemIyNDdZMmhoY25ObGREMTFkR1l0T0NjcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUVwVFQwNHVjM1J5YVc1bmFXWjVLR1JoZEdFcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdaR0YwWVR0Y2JpQWdmVjBzWEc1Y2JpQWdkSEpoYm5ObWIzSnRVbVZ6Y0c5dWMyVTZJRnRtZFc1amRHbHZiaUIwY21GdWMyWnZjbTFTWlhOd2IyNXpaU2hrWVhSaEtTQjdYRzRnSUNBZ0x5cGxjMnhwYm5RZ2JtOHRjR0Z5WVcwdGNtVmhjM05wWjI0Nk1Db3ZYRzRnSUNBZ2FXWWdLSFI1Y0dWdlppQmtZWFJoSUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUNBZ1pHRjBZU0E5SUVwVFQwNHVjR0Z5YzJVb1pHRjBZU2s3WEc0Z0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1NCN0lDOHFJRWxuYm05eVpTQXFMeUI5WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCa1lYUmhPMXh1SUNCOVhTeGNibHh1SUNBdktpcGNiaUFnSUNvZ1FTQjBhVzFsYjNWMElHbHVJRzFwYkd4cGMyVmpiMjVrY3lCMGJ5QmhZbTl5ZENCaElISmxjWFZsYzNRdUlFbG1JSE5sZENCMGJ5QXdJQ2hrWldaaGRXeDBLU0JoWEc0Z0lDQXFJSFJwYldWdmRYUWdhWE1nYm05MElHTnlaV0YwWldRdVhHNGdJQ0FxTDF4dUlDQjBhVzFsYjNWME9pQXdMRnh1WEc0Z0lIaHpjbVpEYjI5cmFXVk9ZVzFsT2lBbldGTlNSaTFVVDB0RlRpY3NYRzRnSUhoemNtWklaV0ZrWlhKT1lXMWxPaUFuV0MxWVUxSkdMVlJQUzBWT0p5eGNibHh1SUNCdFlYaERiMjUwWlc1MFRHVnVaM1JvT2lBdE1TeGNiaUFnYldGNFFtOWtlVXhsYm1kMGFEb2dMVEVzWEc1Y2JpQWdkbUZzYVdSaGRHVlRkR0YwZFhNNklHWjFibU4wYVc5dUlIWmhiR2xrWVhSbFUzUmhkSFZ6S0hOMFlYUjFjeWtnZTF4dUlDQWdJSEpsZEhWeWJpQnpkR0YwZFhNZ1BqMGdNakF3SUNZbUlITjBZWFIxY3lBOElETXdNRHRjYmlBZ2ZWeHVmVHRjYmx4dVpHVm1ZWFZzZEhNdWFHVmhaR1Z5Y3lBOUlIdGNiaUFnWTI5dGJXOXVPaUI3WEc0Z0lDQWdKMEZqWTJWd2RDYzZJQ2RoY0hCc2FXTmhkR2x2Ymk5cWMyOXVMQ0IwWlhoMEwzQnNZV2x1TENBcUx5b25YRzRnSUgxY2JuMDdYRzVjYm5WMGFXeHpMbVp2Y2tWaFkyZ29XeWRrWld4bGRHVW5MQ0FuWjJWMEp5d2dKMmhsWVdRblhTd2dablZ1WTNScGIyNGdabTl5UldGamFFMWxkR2h2WkU1dlJHRjBZU2h0WlhSb2IyUXBJSHRjYmlBZ1pHVm1ZWFZzZEhNdWFHVmhaR1Z5YzF0dFpYUm9iMlJkSUQwZ2UzMDdYRzU5S1R0Y2JseHVkWFJwYkhNdVptOXlSV0ZqYUNoYkozQnZjM1FuTENBbmNIVjBKeXdnSjNCaGRHTm9KMTBzSUdaMWJtTjBhVzl1SUdadmNrVmhZMmhOWlhSb2IyUlhhWFJvUkdGMFlTaHRaWFJvYjJRcElIdGNiaUFnWkdWbVlYVnNkSE11YUdWaFpHVnljMXR0WlhSb2IyUmRJRDBnZFhScGJITXViV1Z5WjJVb1JFVkdRVlZNVkY5RFQwNVVSVTVVWDFSWlVFVXBPMXh1ZlNrN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdaR1ZtWVhWc2RITTdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnWW1sdVpDaG1iaXdnZEdocGMwRnlaeWtnZTF4dUlDQnlaWFIxY200Z1puVnVZM1JwYjI0Z2QzSmhjQ2dwSUh0Y2JpQWdJQ0IyWVhJZ1lYSm5jeUE5SUc1bGR5QkJjbkpoZVNoaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvS1R0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeVozTXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUdGeVozTmJhVjBnUFNCaGNtZDFiV1Z1ZEhOYmFWMDdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJtYmk1aGNIQnNlU2gwYUdselFYSm5MQ0JoY21kektUdGNiaUFnZlR0Y2JuMDdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQjFkR2xzY3lBOUlISmxjWFZwY21Vb0p5NHZMaTR2ZFhScGJITW5LVHRjYmx4dVpuVnVZM1JwYjI0Z1pXNWpiMlJsS0haaGJDa2dlMXh1SUNCeVpYUjFjbTRnWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0haaGJDa3VYRzRnSUNBZ2NtVndiR0ZqWlNndkpUTkJMMmRwTENBbk9pY3BMbHh1SUNBZ0lISmxjR3hoWTJVb0x5VXlOQzluTENBbkpDY3BMbHh1SUNBZ0lISmxjR3hoWTJVb0x5VXlReTluYVN3Z0p5d25LUzVjYmlBZ0lDQnlaWEJzWVdObEtDOGxNakF2Wnl3Z0p5c25LUzVjYmlBZ0lDQnlaWEJzWVdObEtDOGxOVUl2WjJrc0lDZGJKeWt1WEc0Z0lDQWdjbVZ3YkdGalpTZ3ZKVFZFTDJkcExDQW5YU2NwTzF4dWZWeHVYRzR2S2lwY2JpQXFJRUoxYVd4a0lHRWdWVkpNSUdKNUlHRndjR1Z1WkdsdVp5QndZWEpoYlhNZ2RHOGdkR2hsSUdWdVpGeHVJQ3BjYmlBcUlFQndZWEpoYlNCN2MzUnlhVzVuZlNCMWNtd2dWR2hsSUdKaGMyVWdiMllnZEdobElIVnliQ0FvWlM1bkxpd2dhSFIwY0RvdkwzZDNkeTVuYjI5bmJHVXVZMjl0S1Z4dUlDb2dRSEJoY21GdElIdHZZbXBsWTNSOUlGdHdZWEpoYlhOZElGUm9aU0J3WVhKaGJYTWdkRzhnWW1VZ1lYQndaVzVrWldSY2JpQXFJRUJ5WlhSMWNtNXpJSHR6ZEhKcGJtZDlJRlJvWlNCbWIzSnRZWFIwWldRZ2RYSnNYRzRnS2k5Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z1luVnBiR1JWVWt3b2RYSnNMQ0J3WVhKaGJYTXNJSEJoY21GdGMxTmxjbWxoYkdsNlpYSXBJSHRjYmlBZ0x5cGxjMnhwYm5RZ2JtOHRjR0Z5WVcwdGNtVmhjM05wWjI0Nk1Db3ZYRzRnSUdsbUlDZ2hjR0Z5WVcxektTQjdYRzRnSUNBZ2NtVjBkWEp1SUhWeWJEdGNiaUFnZlZ4dVhHNGdJSFpoY2lCelpYSnBZV3hwZW1Wa1VHRnlZVzF6TzF4dUlDQnBaaUFvY0dGeVlXMXpVMlZ5YVdGc2FYcGxjaWtnZTF4dUlDQWdJSE5sY21saGJHbDZaV1JRWVhKaGJYTWdQU0J3WVhKaGJYTlRaWEpwWVd4cGVtVnlLSEJoY21GdGN5azdYRzRnSUgwZ1pXeHpaU0JwWmlBb2RYUnBiSE11YVhOVlVreFRaV0Z5WTJoUVlYSmhiWE1vY0dGeVlXMXpLU2tnZTF4dUlDQWdJSE5sY21saGJHbDZaV1JRWVhKaGJYTWdQU0J3WVhKaGJYTXVkRzlUZEhKcGJtY29LVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IyWVhJZ2NHRnlkSE1nUFNCYlhUdGNibHh1SUNBZ0lIVjBhV3h6TG1admNrVmhZMmdvY0dGeVlXMXpMQ0JtZFc1amRHbHZiaUJ6WlhKcFlXeHBlbVVvZG1Gc0xDQnJaWGtwSUh0Y2JpQWdJQ0FnSUdsbUlDaDJZV3dnUFQwOUlHNTFiR3dnZkh3Z2RIbHdaVzltSUhaaGJDQTlQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdU8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnBaaUFvZFhScGJITXVhWE5CY25KaGVTaDJZV3dwS1NCN1hHNGdJQ0FnSUNBZ0lHdGxlU0E5SUd0bGVTQXJJQ2RiWFNjN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCMllXd2dQU0JiZG1Gc1hUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdkWFJwYkhNdVptOXlSV0ZqYUNoMllXd3NJR1oxYm1OMGFXOXVJSEJoY25ObFZtRnNkV1VvZGlrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvZFhScGJITXVhWE5FWVhSbEtIWXBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RpQTlJSFl1ZEc5SlUwOVRkSEpwYm1jb0tUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2gxZEdsc2N5NXBjMDlpYW1WamRDaDJLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lIWWdQU0JLVTA5T0xuTjBjbWx1WjJsbWVTaDJLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCd1lYSjBjeTV3ZFhOb0tHVnVZMjlrWlNoclpYa3BJQ3NnSnowbklDc2daVzVqYjJSbEtIWXBLVHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDBwTzF4dVhHNGdJQ0FnYzJWeWFXRnNhWHBsWkZCaGNtRnRjeUE5SUhCaGNuUnpMbXB2YVc0b0p5WW5LVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHpaWEpwWVd4cGVtVmtVR0Z5WVcxektTQjdYRzRnSUNBZ2RtRnlJR2hoYzJodFlYSnJTVzVrWlhnZ1BTQjFjbXd1YVc1a1pYaFBaaWduSXljcE8xeHVJQ0FnSUdsbUlDaG9ZWE5vYldGeWEwbHVaR1Y0SUNFOVBTQXRNU2tnZTF4dUlDQWdJQ0FnZFhKc0lEMGdkWEpzTG5Oc2FXTmxLREFzSUdoaGMyaHRZWEpyU1c1a1pYZ3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIVnliQ0FyUFNBb2RYSnNMbWx1WkdWNFQyWW9KejhuS1NBOVBUMGdMVEVnUHlBblB5Y2dPaUFuSmljcElDc2djMlZ5YVdGc2FYcGxaRkJoY21GdGN6dGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjFjbXc3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzR2S2lwY2JpQXFJRU55WldGMFpYTWdZU0J1WlhjZ1ZWSk1JR0o1SUdOdmJXSnBibWx1WnlCMGFHVWdjM0JsWTJsbWFXVmtJRlZTVEhOY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTNOMGNtbHVaMzBnWW1GelpWVlNUQ0JVYUdVZ1ltRnpaU0JWVWt4Y2JpQXFJRUJ3WVhKaGJTQjdjM1J5YVc1bmZTQnlaV3hoZEdsMlpWVlNUQ0JVYUdVZ2NtVnNZWFJwZG1VZ1ZWSk1YRzRnS2lCQWNtVjBkWEp1Y3lCN2MzUnlhVzVuZlNCVWFHVWdZMjl0WW1sdVpXUWdWVkpNWEc0Z0tpOWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdZMjl0WW1sdVpWVlNUSE1vWW1GelpWVlNUQ3dnY21Wc1lYUnBkbVZWVWt3cElIdGNiaUFnY21WMGRYSnVJSEpsYkdGMGFYWmxWVkpNWEc0Z0lDQWdQeUJpWVhObFZWSk1MbkpsY0d4aFkyVW9MMXhjTHlza0x5d2dKeWNwSUNzZ0p5OG5JQ3NnY21Wc1lYUnBkbVZWVWt3dWNtVndiR0ZqWlNndlhseGNMeXN2TENBbkp5bGNiaUFnSUNBNklHSmhjMlZWVWt3N1hHNTlPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdkWFJwYkhNZ1BTQnlaWEYxYVhKbEtDY3VMeTR1TDNWMGFXeHpKeWs3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ0tGeHVJQ0IxZEdsc2N5NXBjMU4wWVc1a1lYSmtRbkp2ZDNObGNrVnVkaWdwSUQ5Y2JseHVJQ0F2THlCVGRHRnVaR0Z5WkNCaWNtOTNjMlZ5SUdWdWRuTWdjM1Z3Y0c5eWRDQmtiMk4xYldWdWRDNWpiMjlyYVdWY2JpQWdJQ0FvWm5WdVkzUnBiMjRnYzNSaGJtUmhjbVJDY205M2MyVnlSVzUyS0NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0FnSUNBZ2QzSnBkR1U2SUdaMWJtTjBhVzl1SUhkeWFYUmxLRzVoYldVc0lIWmhiSFZsTENCbGVIQnBjbVZ6TENCd1lYUm9MQ0JrYjIxaGFXNHNJSE5sWTNWeVpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUhaaGNpQmpiMjlyYVdVZ1BTQmJYVHRjYmlBZ0lDQWdJQ0FnSUNCamIyOXJhV1V1Y0hWemFDaHVZVzFsSUNzZ0p6MG5JQ3NnWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0haaGJIVmxLU2s3WEc1Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZFhScGJITXVhWE5PZFcxaVpYSW9aWGh3YVhKbGN5a3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZiMnRwWlM1d2RYTm9LQ2RsZUhCcGNtVnpQU2NnS3lCdVpYY2dSR0YwWlNobGVIQnBjbVZ6S1M1MGIwZE5WRk4wY21sdVp5Z3BLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2RYUnBiSE11YVhOVGRISnBibWNvY0dGMGFDa3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZiMnRwWlM1d2RYTm9LQ2R3WVhSb1BTY2dLeUJ3WVhSb0tUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvZFhScGJITXVhWE5UZEhKcGJtY29aRzl0WVdsdUtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXZhMmxsTG5CMWMyZ29KMlJ2YldGcGJqMG5JQ3NnWkc5dFlXbHVLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2MyVmpkWEpsSUQwOVBTQjBjblZsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI5cmFXVXVjSFZ6YUNnbmMyVmpkWEpsSnlrN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUNBZ1pHOWpkVzFsYm5RdVkyOXZhMmxsSUQwZ1kyOXZhMmxsTG1wdmFXNG9KenNnSnlrN1hHNGdJQ0FnSUNBZ0lIMHNYRzVjYmlBZ0lDQWdJQ0FnY21WaFpEb2dablZ1WTNScGIyNGdjbVZoWkNodVlXMWxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RtRnlJRzFoZEdOb0lEMGdaRzlqZFcxbGJuUXVZMjl2YTJsbExtMWhkR05vS0c1bGR5QlNaV2RGZUhBb0p5aGVmRHRjWEZ4Y2N5b3BLQ2NnS3lCdVlXMWxJQ3NnSnlrOUtGdGVPMTBxS1NjcEtUdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdLRzFoZEdOb0lEOGdaR1ZqYjJSbFZWSkpRMjl0Y0c5dVpXNTBLRzFoZEdOb1d6TmRLU0E2SUc1MWJHd3BPMXh1SUNBZ0lDQWdJQ0I5TEZ4dVhHNGdJQ0FnSUNBZ0lISmxiVzkyWlRvZ1puVnVZM1JwYjI0Z2NtVnRiM1psS0c1aGJXVXBJSHRjYmlBZ0lDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbEtHNWhiV1VzSUNjbkxDQkVZWFJsTG01dmR5Z3BJQzBnT0RZME1EQXdNREFwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOU8xeHVJQ0FnSUgwcEtDa2dPbHh1WEc0Z0lDOHZJRTV2YmlCemRHRnVaR0Z5WkNCaWNtOTNjMlZ5SUdWdWRpQW9kMlZpSUhkdmNtdGxjbk1zSUhKbFlXTjBMVzVoZEdsMlpTa2diR0ZqYXlCdVpXVmtaV1FnYzNWd2NHOXlkQzVjYmlBZ0lDQW9ablZ1WTNScGIyNGdibTl1VTNSaGJtUmhjbVJDY205M2MyVnlSVzUyS0NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0FnSUNBZ2QzSnBkR1U2SUdaMWJtTjBhVzl1SUhkeWFYUmxLQ2tnZTMwc1hHNGdJQ0FnSUNBZ0lISmxZV1E2SUdaMWJtTjBhVzl1SUhKbFlXUW9LU0I3SUhKbGRIVnliaUJ1ZFd4c095QjlMRnh1SUNBZ0lDQWdJQ0J5WlcxdmRtVTZJR1oxYm1OMGFXOXVJSEpsYlc5MlpTZ3BJSHQ5WEc0Z0lDQWdJQ0I5TzF4dUlDQWdJSDBwS0NsY2JpazdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYmk4cUtseHVJQ29nUkdWMFpYSnRhVzVsY3lCM2FHVjBhR1Z5SUhSb1pTQnpjR1ZqYVdacFpXUWdWVkpNSUdseklHRmljMjlzZFhSbFhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0emRISnBibWQ5SUhWeWJDQlVhR1VnVlZKTUlIUnZJSFJsYzNSY2JpQXFJRUJ5WlhSMWNtNXpJSHRpYjI5c1pXRnVmU0JVY25WbElHbG1JSFJvWlNCemNHVmphV1pwWldRZ1ZWSk1JR2x6SUdGaWMyOXNkWFJsTENCdmRHaGxjbmRwYzJVZ1ptRnNjMlZjYmlBcUwxeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQnBjMEZpYzI5c2RYUmxWVkpNS0hWeWJDa2dlMXh1SUNBdkx5QkJJRlZTVENCcGN5QmpiMjV6YVdSbGNtVmtJR0ZpYzI5c2RYUmxJR2xtSUdsMElHSmxaMmx1Y3lCM2FYUm9JRndpUEhOamFHVnRaVDQ2THk5Y0lpQnZjaUJjSWk4dlhDSWdLSEJ5YjNSdlkyOXNMWEpsYkdGMGFYWmxJRlZTVENrdVhHNGdJQzh2SUZKR1F5QXpPVGcySUdSbFptbHVaWE1nYzJOb1pXMWxJRzVoYldVZ1lYTWdZU0J6WlhGMVpXNWpaU0J2WmlCamFHRnlZV04wWlhKeklHSmxaMmx1Ym1sdVp5QjNhWFJvSUdFZ2JHVjBkR1Z5SUdGdVpDQm1iMnhzYjNkbFpGeHVJQ0F2THlCaWVTQmhibmtnWTI5dFltbHVZWFJwYjI0Z2IyWWdiR1YwZEdWeWN5d2daR2xuYVhSekxDQndiSFZ6TENCd1pYSnBiMlFzSUc5eUlHaDVjR2hsYmk1Y2JpQWdjbVYwZFhKdUlDOWVLRnRoTFhwZFcyRXRlbHhjWkZ4Y0sxeGNMVnhjTGwwcU9pay9YRnd2WEZ3dkwya3VkR1Z6ZENoMWNtd3BPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVMeW9xWEc0Z0tpQkVaWFJsY20xcGJtVnpJSGRvWlhSb1pYSWdkR2hsSUhCaGVXeHZZV1FnYVhNZ1lXNGdaWEp5YjNJZ2RHaHliM2R1SUdKNUlFRjRhVzl6WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHNxZlNCd1lYbHNiMkZrSUZSb1pTQjJZV3gxWlNCMGJ5QjBaWE4wWEc0Z0tpQkFjbVYwZFhKdWN5QjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjBhR1VnY0dGNWJHOWhaQ0JwY3lCaGJpQmxjbkp2Y2lCMGFISnZkMjRnWW5rZ1FYaHBiM01zSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlHbHpRWGhwYjNORmNuSnZjaWh3WVhsc2IyRmtLU0I3WEc0Z0lISmxkSFZ5YmlBb2RIbHdaVzltSUhCaGVXeHZZV1FnUFQwOUlDZHZZbXBsWTNRbktTQW1KaUFvY0dGNWJHOWhaQzVwYzBGNGFXOXpSWEp5YjNJZ1BUMDlJSFJ5ZFdVcE8xeHVmVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dWRtRnlJSFYwYVd4eklEMGdjbVZ4ZFdseVpTZ25MaTh1TGk5MWRHbHNjeWNwTzF4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlDaGNiaUFnZFhScGJITXVhWE5UZEdGdVpHRnlaRUp5YjNkelpYSkZibllvS1NBL1hHNWNiaUFnTHk4Z1UzUmhibVJoY21RZ1luSnZkM05sY2lCbGJuWnpJR2hoZG1VZ1puVnNiQ0J6ZFhCd2IzSjBJRzltSUhSb1pTQkJVRWx6SUc1bFpXUmxaQ0IwYnlCMFpYTjBYRzRnSUM4dklIZG9aWFJvWlhJZ2RHaGxJSEpsY1hWbGMzUWdWVkpNSUdseklHOW1JSFJvWlNCellXMWxJRzl5YVdkcGJpQmhjeUJqZFhKeVpXNTBJR3h2WTJGMGFXOXVMbHh1SUNBZ0lDaG1kVzVqZEdsdmJpQnpkR0Z1WkdGeVpFSnliM2R6WlhKRmJuWW9LU0I3WEc0Z0lDQWdJQ0IyWVhJZ2JYTnBaU0E5SUM4b2JYTnBaWHgwY21sa1pXNTBLUzlwTG5SbGMzUW9ibUYyYVdkaGRHOXlMblZ6WlhKQloyVnVkQ2s3WEc0Z0lDQWdJQ0IyWVhJZ2RYSnNVR0Z5YzJsdVowNXZaR1VnUFNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLQ2RoSnlrN1hHNGdJQ0FnSUNCMllYSWdiM0pwWjJsdVZWSk1PMXh1WEc0Z0lDQWdJQ0F2S2lwY2JpQWdJQ0FxSUZCaGNuTmxJR0VnVlZKTUlIUnZJR1JwYzJOdmRtVnlJR2wwSjNNZ1kyOXRjRzl1Wlc1MGMxeHVJQ0FnSUNwY2JpQWdJQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0IxY213Z1ZHaGxJRlZTVENCMGJ5QmlaU0J3WVhKelpXUmNiaUFnSUNBcUlFQnlaWFIxY201eklIdFBZbXBsWTNSOVhHNGdJQ0FnS2k5Y2JpQWdJQ0FnSUdaMWJtTjBhVzl1SUhKbGMyOXNkbVZWVWt3b2RYSnNLU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQm9jbVZtSUQwZ2RYSnNPMXh1WEc0Z0lDQWdJQ0FnSUdsbUlDaHRjMmxsS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJRWxGSUc1bFpXUnpJR0YwZEhKcFluVjBaU0J6WlhRZ2RIZHBZMlVnZEc4Z2JtOXliV0ZzYVhwbElIQnliM0JsY25ScFpYTmNiaUFnSUNBZ0lDQWdJQ0IxY214UVlYSnphVzVuVG05a1pTNXpaWFJCZEhSeWFXSjFkR1VvSjJoeVpXWW5MQ0JvY21WbUtUdGNiaUFnSUNBZ0lDQWdJQ0JvY21WbUlEMGdkWEpzVUdGeWMybHVaMDV2WkdVdWFISmxaanRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lIVnliRkJoY25OcGJtZE9iMlJsTG5ObGRFRjBkSEpwWW5WMFpTZ25hSEpsWmljc0lHaHlaV1lwTzF4dVhHNGdJQ0FnSUNBZ0lDOHZJSFZ5YkZCaGNuTnBibWRPYjJSbElIQnliM1pwWkdWeklIUm9aU0JWY214VmRHbHNjeUJwYm5SbGNtWmhZMlVnTFNCb2RIUndPaTh2ZFhKc0xuTndaV011ZDJoaGRIZG5MbTl5Wnk4amRYSnNkWFJwYkhOY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0FnSUNBZ0lDQm9jbVZtT2lCMWNteFFZWEp6YVc1blRtOWtaUzVvY21WbUxGeHVJQ0FnSUNBZ0lDQWdJSEJ5YjNSdlkyOXNPaUIxY214UVlYSnphVzVuVG05a1pTNXdjbTkwYjJOdmJDQS9JSFZ5YkZCaGNuTnBibWRPYjJSbExuQnliM1J2WTI5c0xuSmxjR3hoWTJVb0x6b2tMeXdnSnljcElEb2dKeWNzWEc0Z0lDQWdJQ0FnSUNBZ2FHOXpkRG9nZFhKc1VHRnljMmx1WjA1dlpHVXVhRzl6ZEN4Y2JpQWdJQ0FnSUNBZ0lDQnpaV0Z5WTJnNklIVnliRkJoY25OcGJtZE9iMlJsTG5ObFlYSmphQ0EvSUhWeWJGQmhjbk5wYm1kT2IyUmxMbk5sWVhKamFDNXlaWEJzWVdObEtDOWVYRncvTHl3Z0p5Y3BJRG9nSnljc1hHNGdJQ0FnSUNBZ0lDQWdhR0Z6YURvZ2RYSnNVR0Z5YzJsdVowNXZaR1V1YUdGemFDQS9JSFZ5YkZCaGNuTnBibWRPYjJSbExtaGhjMmd1Y21Wd2JHRmpaU2d2WGlNdkxDQW5KeWtnT2lBbkp5eGNiaUFnSUNBZ0lDQWdJQ0JvYjNOMGJtRnRaVG9nZFhKc1VHRnljMmx1WjA1dlpHVXVhRzl6ZEc1aGJXVXNYRzRnSUNBZ0lDQWdJQ0FnY0c5eWREb2dkWEpzVUdGeWMybHVaMDV2WkdVdWNHOXlkQ3hjYmlBZ0lDQWdJQ0FnSUNCd1lYUm9ibUZ0WlRvZ0tIVnliRkJoY25OcGJtZE9iMlJsTG5CaGRHaHVZVzFsTG1Ob1lYSkJkQ2d3S1NBOVBUMGdKeThuS1NBL1hHNGdJQ0FnSUNBZ0lDQWdJQ0IxY214UVlYSnphVzVuVG05a1pTNXdZWFJvYm1GdFpTQTZYRzRnSUNBZ0lDQWdJQ0FnSUNBbkx5Y2dLeUIxY214UVlYSnphVzVuVG05a1pTNXdZWFJvYm1GdFpWeHVJQ0FnSUNBZ0lDQjlPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J2Y21sbmFXNVZVa3dnUFNCeVpYTnZiSFpsVlZKTUtIZHBibVJ2ZHk1c2IyTmhkR2x2Ymk1b2NtVm1LVHRjYmx4dUlDQWdJQ0FnTHlvcVhHNGdJQ0FnS2lCRVpYUmxjbTFwYm1VZ2FXWWdZU0JWVWt3Z2MyaGhjbVZ6SUhSb1pTQnpZVzFsSUc5eWFXZHBiaUJoY3lCMGFHVWdZM1Z5Y21WdWRDQnNiMk5oZEdsdmJseHVJQ0FnSUNwY2JpQWdJQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0J5WlhGMVpYTjBWVkpNSUZSb1pTQlZVa3dnZEc4Z2RHVnpkRnh1SUNBZ0lDb2dRSEpsZEhWeWJuTWdlMkp2YjJ4bFlXNTlJRlJ5ZFdVZ2FXWWdWVkpNSUhOb1lYSmxjeUIwYUdVZ2MyRnRaU0J2Y21sbmFXNHNJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ0FnSUNvdlhHNGdJQ0FnSUNCeVpYUjFjbTRnWm5WdVkzUnBiMjRnYVhOVlVreFRZVzFsVDNKcFoybHVLSEpsY1hWbGMzUlZVa3dwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJSEJoY25ObFpDQTlJQ2gxZEdsc2N5NXBjMU4wY21sdVp5aHlaWEYxWlhOMFZWSk1LU2tnUHlCeVpYTnZiSFpsVlZKTUtISmxjWFZsYzNSVlVrd3BJRG9nY21WeGRXVnpkRlZTVER0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUNod1lYSnpaV1F1Y0hKdmRHOWpiMndnUFQwOUlHOXlhV2RwYmxWU1RDNXdjbTkwYjJOdmJDQW1KbHh1SUNBZ0lDQWdJQ0FnSUNBZ2NHRnljMlZrTG1odmMzUWdQVDA5SUc5eWFXZHBibFZTVEM1b2IzTjBLVHRjYmlBZ0lDQWdJSDA3WEc0Z0lDQWdmU2tvS1NBNlhHNWNiaUFnTHk4Z1RtOXVJSE4wWVc1a1lYSmtJR0p5YjNkelpYSWdaVzUyY3lBb2QyVmlJSGR2Y210bGNuTXNJSEpsWVdOMExXNWhkR2wyWlNrZ2JHRmpheUJ1WldWa1pXUWdjM1Z3Y0c5eWRDNWNiaUFnSUNBb1puVnVZM1JwYjI0Z2JtOXVVM1JoYm1SaGNtUkNjbTkzYzJWeVJXNTJLQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVJR2x6VlZKTVUyRnRaVTl5YVdkcGJpZ3BJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJ5ZFdVN1hHNGdJQ0FnSUNCOU8xeHVJQ0FnSUgwcEtDbGNiaWs3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUIxZEdsc2N5QTlJSEpsY1hWcGNtVW9KeTR1TDNWMGFXeHpKeWs3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z2JtOXliV0ZzYVhwbFNHVmhaR1Z5VG1GdFpTaG9aV0ZrWlhKekxDQnViM0p0WVd4cGVtVmtUbUZ0WlNrZ2UxeHVJQ0IxZEdsc2N5NW1iM0pGWVdOb0tHaGxZV1JsY25Nc0lHWjFibU4wYVc5dUlIQnliMk5sYzNOSVpXRmtaWElvZG1Gc2RXVXNJRzVoYldVcElIdGNiaUFnSUNCcFppQW9ibUZ0WlNBaFBUMGdibTl5YldGc2FYcGxaRTVoYldVZ0ppWWdibUZ0WlM1MGIxVndjR1Z5UTJGelpTZ3BJRDA5UFNCdWIzSnRZV3hwZW1Wa1RtRnRaUzUwYjFWd2NHVnlRMkZ6WlNncEtTQjdYRzRnSUNBZ0lDQm9aV0ZrWlhKelcyNXZjbTFoYkdsNlpXUk9ZVzFsWFNBOUlIWmhiSFZsTzF4dUlDQWdJQ0FnWkdWc1pYUmxJR2hsWVdSbGNuTmJibUZ0WlYwN1hHNGdJQ0FnZlZ4dUlDQjlLVHRjYm4wN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCMWRHbHNjeUE5SUhKbGNYVnBjbVVvSnk0dkxpNHZkWFJwYkhNbktUdGNibHh1THk4Z1NHVmhaR1Z5Y3lCM2FHOXpaU0JrZFhCc2FXTmhkR1Z6SUdGeVpTQnBaMjV2Y21Wa0lHSjVJRzV2WkdWY2JpOHZJR011Wmk0Z2FIUjBjSE02THk5dWIyUmxhbk11YjNKbkwyRndhUzlvZEhSd0xtaDBiV3dqYUhSMGNGOXRaWE56WVdkbFgyaGxZV1JsY25OY2JuWmhjaUJwWjI1dmNtVkVkWEJzYVdOaGRHVlBaaUE5SUZ0Y2JpQWdKMkZuWlNjc0lDZGhkWFJvYjNKcGVtRjBhVzl1Snl3Z0oyTnZiblJsYm5RdGJHVnVaM1JvSnl3Z0oyTnZiblJsYm5RdGRIbHdaU2NzSUNkbGRHRm5KeXhjYmlBZ0oyVjRjR2x5WlhNbkxDQW5abkp2YlNjc0lDZG9iM04wSnl3Z0oybG1MVzF2WkdsbWFXVmtMWE5wYm1ObEp5d2dKMmxtTFhWdWJXOWthV1pwWldRdGMybHVZMlVuTEZ4dUlDQW5iR0Z6ZEMxdGIyUnBabWxsWkNjc0lDZHNiMk5oZEdsdmJpY3NJQ2R0WVhndFptOXlkMkZ5WkhNbkxDQW5jSEp2ZUhrdFlYVjBhRzl5YVhwaGRHbHZiaWNzWEc0Z0lDZHlaV1psY21WeUp5d2dKM0psZEhKNUxXRm1kR1Z5Snl3Z0ozVnpaWEl0WVdkbGJuUW5YRzVkTzF4dVhHNHZLaXBjYmlBcUlGQmhjbk5sSUdobFlXUmxjbk1nYVc1MGJ5QmhiaUJ2WW1wbFkzUmNiaUFxWEc0Z0tpQmdZR0JjYmlBcUlFUmhkR1U2SUZkbFpDd2dNamNnUVhWbklESXdNVFFnTURnNk5UZzZORGtnUjAxVVhHNGdLaUJEYjI1MFpXNTBMVlI1Y0dVNklHRndjR3hwWTJGMGFXOXVMMnB6YjI1Y2JpQXFJRU52Ym01bFkzUnBiMjQ2SUd0bFpYQXRZV3hwZG1WY2JpQXFJRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5PaUJqYUhWdWEyVmtYRzRnS2lCZ1lHQmNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UxTjBjbWx1WjMwZ2FHVmhaR1Z5Y3lCSVpXRmtaWEp6SUc1bFpXUnBibWNnZEc4Z1ltVWdjR0Z5YzJWa1hHNGdLaUJBY21WMGRYSnVjeUI3VDJKcVpXTjBmU0JJWldGa1pYSnpJSEJoY25ObFpDQnBiblJ2SUdGdUlHOWlhbVZqZEZ4dUlDb3ZYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJSEJoY25ObFNHVmhaR1Z5Y3lob1pXRmtaWEp6S1NCN1hHNGdJSFpoY2lCd1lYSnpaV1FnUFNCN2ZUdGNiaUFnZG1GeUlHdGxlVHRjYmlBZ2RtRnlJSFpoYkR0Y2JpQWdkbUZ5SUdrN1hHNWNiaUFnYVdZZ0tDRm9aV0ZrWlhKektTQjdJSEpsZEhWeWJpQndZWEp6WldRN0lIMWNibHh1SUNCMWRHbHNjeTVtYjNKRllXTm9LR2hsWVdSbGNuTXVjM0JzYVhRb0oxeGNiaWNwTENCbWRXNWpkR2x2YmlCd1lYSnpaWElvYkdsdVpTa2dlMXh1SUNBZ0lHa2dQU0JzYVc1bExtbHVaR1Y0VDJZb0p6b25LVHRjYmlBZ0lDQnJaWGtnUFNCMWRHbHNjeTUwY21sdEtHeHBibVV1YzNWaWMzUnlLREFzSUdrcEtTNTBiMHh2ZDJWeVEyRnpaU2dwTzF4dUlDQWdJSFpoYkNBOUlIVjBhV3h6TG5SeWFXMG9iR2x1WlM1emRXSnpkSElvYVNBcklERXBLVHRjYmx4dUlDQWdJR2xtSUNoclpYa3BJSHRjYmlBZ0lDQWdJR2xtSUNod1lYSnpaV1JiYTJWNVhTQW1KaUJwWjI1dmNtVkVkWEJzYVdOaGRHVlBaaTVwYm1SbGVFOW1LR3RsZVNrZ1BqMGdNQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTQ3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0JwWmlBb2EyVjVJRDA5UFNBbmMyVjBMV052YjJ0cFpTY3BJSHRjYmlBZ0lDQWdJQ0FnY0dGeWMyVmtXMnRsZVYwZ1BTQW9jR0Z5YzJWa1cydGxlVjBnUHlCd1lYSnpaV1JiYTJWNVhTQTZJRnRkS1M1amIyNWpZWFFvVzNaaGJGMHBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjR0Z5YzJWa1cydGxlVjBnUFNCd1lYSnpaV1JiYTJWNVhTQS9JSEJoY25ObFpGdHJaWGxkSUNzZ0p5d2dKeUFySUhaaGJDQTZJSFpoYkR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMHBPMXh1WEc0Z0lISmxkSFZ5YmlCd1lYSnpaV1E3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzR2S2lwY2JpQXFJRk41Ym5SaFkzUnBZeUJ6ZFdkaGNpQm1iM0lnYVc1MmIydHBibWNnWVNCbWRXNWpkR2x2YmlCaGJtUWdaWGh3WVc1a2FXNW5JR0Z1SUdGeWNtRjVJR1p2Y2lCaGNtZDFiV1Z1ZEhNdVhHNGdLbHh1SUNvZ1EyOXRiVzl1SUhWelpTQmpZWE5sSUhkdmRXeGtJR0psSUhSdklIVnpaU0JnUm5WdVkzUnBiMjR1Y0hKdmRHOTBlWEJsTG1Gd2NHeDVZQzVjYmlBcVhHNGdLaUFnWUdCZ2FuTmNiaUFxSUNCbWRXNWpkR2x2YmlCbUtIZ3NJSGtzSUhvcElIdDlYRzRnS2lBZ2RtRnlJR0Z5WjNNZ1BTQmJNU3dnTWl3Z00xMDdYRzRnS2lBZ1ppNWhjSEJzZVNodWRXeHNMQ0JoY21kektUdGNiaUFxSUNCZ1lHQmNiaUFxWEc0Z0tpQlhhWFJvSUdCemNISmxZV1JnSUhSb2FYTWdaWGhoYlhCc1pTQmpZVzRnWW1VZ2NtVXRkM0pwZEhSbGJpNWNiaUFxWEc0Z0tpQWdZR0JnYW5OY2JpQXFJQ0J6Y0hKbFlXUW9ablZ1WTNScGIyNG9lQ3dnZVN3Z2Vpa2dlMzBwS0ZzeExDQXlMQ0F6WFNrN1hHNGdLaUFnWUdCZ1hHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ1kyRnNiR0poWTJ0Y2JpQXFJRUJ5WlhSMWNtNXpJSHRHZFc1amRHbHZibjFjYmlBcUwxeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQnpjSEpsWVdRb1kyRnNiR0poWTJzcElIdGNiaUFnY21WMGRYSnVJR1oxYm1OMGFXOXVJSGR5WVhBb1lYSnlLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHTmhiR3hpWVdOckxtRndjR3g1S0c1MWJHd3NJR0Z5Y2lrN1hHNGdJSDA3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ1ltbHVaQ0E5SUhKbGNYVnBjbVVvSnk0dmFHVnNjR1Z5Y3k5aWFXNWtKeWs3WEc1Y2JpOHFaMnh2WW1Gc0lIUnZVM1J5YVc1bk9uUnlkV1VxTDF4dVhHNHZMeUIxZEdsc2N5QnBjeUJoSUd4cFluSmhjbmtnYjJZZ1oyVnVaWEpwWXlCb1pXeHdaWElnWm5WdVkzUnBiMjV6SUc1dmJpMXpjR1ZqYVdacFl5QjBieUJoZUdsdmMxeHVYRzUyWVhJZ2RHOVRkSEpwYm1jZ1BTQlBZbXBsWTNRdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bk8xeHVYRzR2S2lwY2JpQXFJRVJsZEdWeWJXbHVaU0JwWmlCaElIWmhiSFZsSUdseklHRnVJRUZ5Y21GNVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUhaaGJDQlVhR1VnZG1Gc2RXVWdkRzhnZEdWemRGeHVJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUZSeWRXVWdhV1lnZG1Gc2RXVWdhWE1nWVc0Z1FYSnlZWGtzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMEZ5Y21GNUtIWmhiQ2tnZTF4dUlDQnlaWFIxY200Z2RHOVRkSEpwYm1jdVkyRnNiQ2gyWVd3cElEMDlQU0FuVzI5aWFtVmpkQ0JCY25KaGVWMG5PMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUhWdVpHVm1hVzVsWkZ4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0IyWVd3Z1ZHaGxJSFpoYkhWbElIUnZJSFJsYzNSY2JpQXFJRUJ5WlhSMWNtNXpJSHRpYjI5c1pXRnVmU0JVY25WbElHbG1JSFJvWlNCMllXeDFaU0JwY3lCMWJtUmxabWx1WldRc0lHOTBhR1Z5ZDJselpTQm1ZV3h6WlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJwYzFWdVpHVm1hVzVsWkNoMllXd3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUIyWVd3Z1BUMDlJQ2QxYm1SbFptbHVaV1FuTzF4dWZWeHVYRzR2S2lwY2JpQXFJRVJsZEdWeWJXbHVaU0JwWmlCaElIWmhiSFZsSUdseklHRWdRblZtWm1WeVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUhaaGJDQlVhR1VnZG1Gc2RXVWdkRzhnZEdWemRGeHVJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUZSeWRXVWdhV1lnZG1Gc2RXVWdhWE1nWVNCQ2RXWm1aWElzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMEoxWm1abGNpaDJZV3dwSUh0Y2JpQWdjbVYwZFhKdUlIWmhiQ0FoUFQwZ2JuVnNiQ0FtSmlBaGFYTlZibVJsWm1sdVpXUW9kbUZzS1NBbUppQjJZV3d1WTI5dWMzUnlkV04wYjNJZ0lUMDlJRzUxYkd3Z0ppWWdJV2x6Vlc1a1pXWnBibVZrS0haaGJDNWpiMjV6ZEhKMVkzUnZjaWxjYmlBZ0lDQW1KaUIwZVhCbGIyWWdkbUZzTG1OdmJuTjBjblZqZEc5eUxtbHpRblZtWm1WeUlEMDlQU0FuWm5WdVkzUnBiMjRuSUNZbUlIWmhiQzVqYjI1emRISjFZM1J2Y2k1cGMwSjFabVpsY2loMllXd3BPMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUJoSUhaaGJIVmxJR2x6SUdGdUlFRnljbUY1UW5WbVptVnlYRzRnS2x4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlIWmhiQ0JVYUdVZ2RtRnNkV1VnZEc4Z2RHVnpkRnh1SUNvZ1FISmxkSFZ5Ym5NZ2UySnZiMnhsWVc1OUlGUnlkV1VnYVdZZ2RtRnNkV1VnYVhNZ1lXNGdRWEp5WVhsQ2RXWm1aWElzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMEZ5Y21GNVFuVm1abVZ5S0haaGJDa2dlMXh1SUNCeVpYUjFjbTRnZEc5VGRISnBibWN1WTJGc2JDaDJZV3dwSUQwOVBTQW5XMjlpYW1WamRDQkJjbkpoZVVKMVptWmxjbDBuTzF4dWZWeHVYRzR2S2lwY2JpQXFJRVJsZEdWeWJXbHVaU0JwWmlCaElIWmhiSFZsSUdseklHRWdSbTl5YlVSaGRHRmNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2RtRnNJRlJvWlNCMllXeDFaU0IwYnlCMFpYTjBYRzRnS2lCQWNtVjBkWEp1Y3lCN1ltOXZiR1ZoYm4wZ1ZISjFaU0JwWmlCMllXeDFaU0JwY3lCaGJpQkdiM0p0UkdGMFlTd2diM1JvWlhKM2FYTmxJR1poYkhObFhHNGdLaTljYm1aMWJtTjBhVzl1SUdselJtOXliVVJoZEdFb2RtRnNLU0I3WEc0Z0lISmxkSFZ5YmlBb2RIbHdaVzltSUVadmNtMUVZWFJoSUNFOVBTQW5kVzVrWldacGJtVmtKeWtnSmlZZ0tIWmhiQ0JwYm5OMFlXNWpaVzltSUVadmNtMUVZWFJoS1R0Y2JuMWNibHh1THlvcVhHNGdLaUJFWlhSbGNtMXBibVVnYVdZZ1lTQjJZV3gxWlNCcGN5QmhJSFpwWlhjZ2IyNGdZVzRnUVhKeVlYbENkV1ptWlhKY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnZG1Gc0lGUm9aU0IyWVd4MVpTQjBieUIwWlhOMFhHNGdLaUJBY21WMGRYSnVjeUI3WW05dmJHVmhibjBnVkhKMVpTQnBaaUIyWVd4MVpTQnBjeUJoSUhacFpYY2diMjRnWVc0Z1FYSnlZWGxDZFdabVpYSXNJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGMwRnljbUY1UW5WbVptVnlWbWxsZHloMllXd3BJSHRjYmlBZ2RtRnlJSEpsYzNWc2REdGNiaUFnYVdZZ0tDaDBlWEJsYjJZZ1FYSnlZWGxDZFdabVpYSWdJVDA5SUNkMWJtUmxabWx1WldRbktTQW1KaUFvUVhKeVlYbENkV1ptWlhJdWFYTldhV1YzS1NrZ2UxeHVJQ0FnSUhKbGMzVnNkQ0E5SUVGeWNtRjVRblZtWm1WeUxtbHpWbWxsZHloMllXd3BPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsYzNWc2RDQTlJQ2gyWVd3cElDWW1JQ2gyWVd3dVluVm1abVZ5S1NBbUppQW9kbUZzTG1KMVptWmxjaUJwYm5OMFlXNWpaVzltSUVGeWNtRjVRblZtWm1WeUtUdGNiaUFnZlZ4dUlDQnlaWFIxY200Z2NtVnpkV3gwTzF4dWZWeHVYRzR2S2lwY2JpQXFJRVJsZEdWeWJXbHVaU0JwWmlCaElIWmhiSFZsSUdseklHRWdVM1J5YVc1blhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUhaaGJDQlVhR1VnZG1Gc2RXVWdkRzhnZEdWemRGeHVJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUZSeWRXVWdhV1lnZG1Gc2RXVWdhWE1nWVNCVGRISnBibWNzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMU4wY21sdVp5aDJZV3dwSUh0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCMllXd2dQVDA5SUNkemRISnBibWNuTzF4dWZWeHVYRzR2S2lwY2JpQXFJRVJsZEdWeWJXbHVaU0JwWmlCaElIWmhiSFZsSUdseklHRWdUblZ0WW1WeVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUhaaGJDQlVhR1VnZG1Gc2RXVWdkRzhnZEdWemRGeHVJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUZSeWRXVWdhV1lnZG1Gc2RXVWdhWE1nWVNCT2RXMWlaWElzSUc5MGFHVnlkMmx6WlNCbVlXeHpaVnh1SUNvdlhHNW1kVzVqZEdsdmJpQnBjMDUxYldKbGNpaDJZV3dwSUh0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCMllXd2dQVDA5SUNkdWRXMWlaWEluTzF4dWZWeHVYRzR2S2lwY2JpQXFJRVJsZEdWeWJXbHVaU0JwWmlCaElIWmhiSFZsSUdseklHRnVJRTlpYW1WamRGeHVJQ3BjYmlBcUlFQndZWEpoYlNCN1QySnFaV04wZlNCMllXd2dWR2hsSUhaaGJIVmxJSFJ2SUhSbGMzUmNiaUFxSUVCeVpYUjFjbTV6SUh0aWIyOXNaV0Z1ZlNCVWNuVmxJR2xtSUhaaGJIVmxJR2x6SUdGdUlFOWlhbVZqZEN3Z2IzUm9aWEozYVhObElHWmhiSE5sWEc0Z0tpOWNibVoxYm1OMGFXOXVJR2x6VDJKcVpXTjBLSFpoYkNrZ2UxeHVJQ0J5WlhSMWNtNGdkbUZzSUNFOVBTQnVkV3hzSUNZbUlIUjVjR1Z2WmlCMllXd2dQVDA5SUNkdlltcGxZM1FuTzF4dWZWeHVYRzR2S2lwY2JpQXFJRVJsZEdWeWJXbHVaU0JwWmlCaElIWmhiSFZsSUdseklHRWdjR3hoYVc0Z1QySnFaV04wWEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJSFpoYkNCVWFHVWdkbUZzZFdVZ2RHOGdkR1Z6ZEZ4dUlDb2dRSEpsZEhWeWJpQjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjJZV3gxWlNCcGN5QmhJSEJzWVdsdUlFOWlhbVZqZEN3Z2IzUm9aWEozYVhObElHWmhiSE5sWEc0Z0tpOWNibVoxYm1OMGFXOXVJR2x6VUd4aGFXNVBZbXBsWTNRb2RtRnNLU0I3WEc0Z0lHbG1JQ2gwYjFOMGNtbHVaeTVqWVd4c0tIWmhiQ2tnSVQwOUlDZGJiMkpxWldOMElFOWlhbVZqZEYwbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNCOVhHNWNiaUFnZG1GeUlIQnliM1J2ZEhsd1pTQTlJRTlpYW1WamRDNW5aWFJRY205MGIzUjVjR1ZQWmloMllXd3BPMXh1SUNCeVpYUjFjbTRnY0hKdmRHOTBlWEJsSUQwOVBTQnVkV3hzSUh4OElIQnliM1J2ZEhsd1pTQTlQVDBnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaVHRjYm4xY2JseHVMeW9xWEc0Z0tpQkVaWFJsY20xcGJtVWdhV1lnWVNCMllXeDFaU0JwY3lCaElFUmhkR1ZjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdkbUZzSUZSb1pTQjJZV3gxWlNCMGJ5QjBaWE4wWEc0Z0tpQkFjbVYwZFhKdWN5QjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjJZV3gxWlNCcGN5QmhJRVJoZEdVc0lHOTBhR1Z5ZDJselpTQm1ZV3h6WlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJwYzBSaGRHVW9kbUZzS1NCN1hHNGdJSEpsZEhWeWJpQjBiMU4wY21sdVp5NWpZV3hzS0haaGJDa2dQVDA5SUNkYmIySnFaV04wSUVSaGRHVmRKenRjYm4xY2JseHVMeW9xWEc0Z0tpQkVaWFJsY20xcGJtVWdhV1lnWVNCMllXeDFaU0JwY3lCaElFWnBiR1ZjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdkbUZzSUZSb1pTQjJZV3gxWlNCMGJ5QjBaWE4wWEc0Z0tpQkFjbVYwZFhKdWN5QjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjJZV3gxWlNCcGN5QmhJRVpwYkdVc0lHOTBhR1Z5ZDJselpTQm1ZV3h6WlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJwYzBacGJHVW9kbUZzS1NCN1hHNGdJSEpsZEhWeWJpQjBiMU4wY21sdVp5NWpZV3hzS0haaGJDa2dQVDA5SUNkYmIySnFaV04wSUVacGJHVmRKenRjYm4xY2JseHVMeW9xWEc0Z0tpQkVaWFJsY20xcGJtVWdhV1lnWVNCMllXeDFaU0JwY3lCaElFSnNiMkpjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdkbUZzSUZSb1pTQjJZV3gxWlNCMGJ5QjBaWE4wWEc0Z0tpQkFjbVYwZFhKdWN5QjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjJZV3gxWlNCcGN5QmhJRUpzYjJJc0lHOTBhR1Z5ZDJselpTQm1ZV3h6WlZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJwYzBKc2IySW9kbUZzS1NCN1hHNGdJSEpsZEhWeWJpQjBiMU4wY21sdVp5NWpZV3hzS0haaGJDa2dQVDA5SUNkYmIySnFaV04wSUVKc2IySmRKenRjYm4xY2JseHVMeW9xWEc0Z0tpQkVaWFJsY20xcGJtVWdhV1lnWVNCMllXeDFaU0JwY3lCaElFWjFibU4wYVc5dVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUhaaGJDQlVhR1VnZG1Gc2RXVWdkRzhnZEdWemRGeHVJQ29nUUhKbGRIVnlibk1nZTJKdmIyeGxZVzU5SUZSeWRXVWdhV1lnZG1Gc2RXVWdhWE1nWVNCR2RXNWpkR2x2Yml3Z2IzUm9aWEozYVhObElHWmhiSE5sWEc0Z0tpOWNibVoxYm1OMGFXOXVJR2x6Um5WdVkzUnBiMjRvZG1Gc0tTQjdYRzRnSUhKbGRIVnliaUIwYjFOMGNtbHVaeTVqWVd4c0tIWmhiQ2tnUFQwOUlDZGJiMkpxWldOMElFWjFibU4wYVc5dVhTYzdYRzU5WEc1Y2JpOHFLbHh1SUNvZ1JHVjBaWEp0YVc1bElHbG1JR0VnZG1Gc2RXVWdhWE1nWVNCVGRISmxZVzFjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdkbUZzSUZSb1pTQjJZV3gxWlNCMGJ5QjBaWE4wWEc0Z0tpQkFjbVYwZFhKdWN5QjdZbTl2YkdWaGJuMGdWSEoxWlNCcFppQjJZV3gxWlNCcGN5QmhJRk4wY21WaGJTd2diM1JvWlhKM2FYTmxJR1poYkhObFhHNGdLaTljYm1aMWJtTjBhVzl1SUdselUzUnlaV0Z0S0haaGJDa2dlMXh1SUNCeVpYUjFjbTRnYVhOUFltcGxZM1FvZG1Gc0tTQW1KaUJwYzBaMWJtTjBhVzl1S0haaGJDNXdhWEJsS1R0Y2JuMWNibHh1THlvcVhHNGdLaUJFWlhSbGNtMXBibVVnYVdZZ1lTQjJZV3gxWlNCcGN5QmhJRlZTVEZObFlYSmphRkJoY21GdGN5QnZZbXBsWTNSY2JpQXFYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnZG1Gc0lGUm9aU0IyWVd4MVpTQjBieUIwWlhOMFhHNGdLaUJBY21WMGRYSnVjeUI3WW05dmJHVmhibjBnVkhKMVpTQnBaaUIyWVd4MVpTQnBjeUJoSUZWU1RGTmxZWEpqYUZCaGNtRnRjeUJ2WW1wbFkzUXNJRzkwYUdWeWQybHpaU0JtWVd4elpWeHVJQ292WEc1bWRXNWpkR2x2YmlCcGMxVlNURk5sWVhKamFGQmhjbUZ0Y3loMllXd3BJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJWVWt4VFpXRnlZMmhRWVhKaGJYTWdJVDA5SUNkMWJtUmxabWx1WldRbklDWW1JSFpoYkNCcGJuTjBZVzVqWlc5bUlGVlNURk5sWVhKamFGQmhjbUZ0Y3p0Y2JuMWNibHh1THlvcVhHNGdLaUJVY21sdElHVjRZMlZ6Y3lCM2FHbDBaWE53WVdObElHOW1aaUIwYUdVZ1ltVm5hVzV1YVc1bklHRnVaQ0JsYm1RZ2IyWWdZU0J6ZEhKcGJtZGNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UxTjBjbWx1WjMwZ2MzUnlJRlJvWlNCVGRISnBibWNnZEc4Z2RISnBiVnh1SUNvZ1FISmxkSFZ5Ym5NZ2UxTjBjbWx1WjMwZ1ZHaGxJRk4wY21sdVp5Qm1jbVZsWkNCdlppQmxlR05sYzNNZ2QyaHBkR1Z6Y0dGalpWeHVJQ292WEc1bWRXNWpkR2x2YmlCMGNtbHRLSE4wY2lrZ2UxeHVJQ0J5WlhSMWNtNGdjM1J5TG5KbGNHeGhZMlVvTDE1Y1hITXFMeXdnSnljcExuSmxjR3hoWTJVb0wxeGNjeW9rTHl3Z0p5Y3BPMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFUmxkR1Z5YldsdVpTQnBaaUIzWlNkeVpTQnlkVzV1YVc1bklHbHVJR0VnYzNSaGJtUmhjbVFnWW5KdmQzTmxjaUJsYm5acGNtOXViV1Z1ZEZ4dUlDcGNiaUFxSUZSb2FYTWdZV3hzYjNkeklHRjRhVzl6SUhSdklISjFiaUJwYmlCaElIZGxZaUIzYjNKclpYSXNJR0Z1WkNCeVpXRmpkQzF1WVhScGRtVXVYRzRnS2lCQ2IzUm9JR1Z1ZG1seWIyNXRaVzUwY3lCemRYQndiM0owSUZoTlRFaDBkSEJTWlhGMVpYTjBMQ0JpZFhRZ2JtOTBJR1oxYkd4NUlITjBZVzVrWVhKa0lHZHNiMkpoYkhNdVhHNGdLbHh1SUNvZ2QyVmlJSGR2Y210bGNuTTZYRzRnS2lBZ2RIbHdaVzltSUhkcGJtUnZkeUF0UGlCMWJtUmxabWx1WldSY2JpQXFJQ0IwZVhCbGIyWWdaRzlqZFcxbGJuUWdMVDRnZFc1a1pXWnBibVZrWEc0Z0tseHVJQ29nY21WaFkzUXRibUYwYVhabE9seHVJQ29nSUc1aGRtbG5ZWFJ2Y2k1d2NtOWtkV04wSUMwK0lDZFNaV0ZqZEU1aGRHbDJaU2RjYmlBcUlHNWhkR2wyWlhOamNtbHdkRnh1SUNvZ0lHNWhkbWxuWVhSdmNpNXdjbTlrZFdOMElDMCtJQ2RPWVhScGRtVlRZM0pwY0hRbklHOXlJQ2RPVXlkY2JpQXFMMXh1Wm5WdVkzUnBiMjRnYVhOVGRHRnVaR0Z5WkVKeWIzZHpaWEpGYm5Zb0tTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2JtRjJhV2RoZEc5eUlDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUppQW9ibUYyYVdkaGRHOXlMbkJ5YjJSMVkzUWdQVDA5SUNkU1pXRmpkRTVoZEdsMlpTY2dmSHhjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J1WVhacFoyRjBiM0l1Y0hKdlpIVmpkQ0E5UFQwZ0owNWhkR2wyWlZOamNtbHdkQ2NnZkh4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCdVlYWnBaMkYwYjNJdWNISnZaSFZqZENBOVBUMGdKMDVUSnlrcElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JpQWdjbVYwZFhKdUlDaGNiaUFnSUNCMGVYQmxiMllnZDJsdVpHOTNJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KbHh1SUNBZ0lIUjVjR1Z2WmlCa2IyTjFiV1Z1ZENBaFBUMGdKM1Z1WkdWbWFXNWxaQ2RjYmlBZ0tUdGNibjFjYmx4dUx5b3FYRzRnS2lCSmRHVnlZWFJsSUc5MlpYSWdZVzRnUVhKeVlYa2diM0lnWVc0Z1QySnFaV04wSUdsdWRtOXJhVzVuSUdFZ1puVnVZM1JwYjI0Z1ptOXlJR1ZoWTJnZ2FYUmxiUzVjYmlBcVhHNGdLaUJKWmlCZ2IySnFZQ0JwY3lCaGJpQkJjbkpoZVNCallXeHNZbUZqYXlCM2FXeHNJR0psSUdOaGJHeGxaQ0J3WVhOemFXNW5YRzRnS2lCMGFHVWdkbUZzZFdVc0lHbHVaR1Y0TENCaGJtUWdZMjl0Y0d4bGRHVWdZWEp5WVhrZ1ptOXlJR1ZoWTJnZ2FYUmxiUzVjYmlBcVhHNGdLaUJKWmlBbmIySnFKeUJwY3lCaGJpQlBZbXBsWTNRZ1kyRnNiR0poWTJzZ2QybHNiQ0JpWlNCallXeHNaV1FnY0dGemMybHVaMXh1SUNvZ2RHaGxJSFpoYkhWbExDQnJaWGtzSUdGdVpDQmpiMjF3YkdWMFpTQnZZbXBsWTNRZ1ptOXlJR1ZoWTJnZ2NISnZjR1Z5ZEhrdVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I4UVhKeVlYbDlJRzlpYWlCVWFHVWdiMkpxWldOMElIUnZJR2wwWlhKaGRHVmNiaUFxSUVCd1lYSmhiU0I3Um5WdVkzUnBiMjU5SUdadUlGUm9aU0JqWVd4c1ltRmpheUIwYnlCcGJuWnZhMlVnWm05eUlHVmhZMmdnYVhSbGJWeHVJQ292WEc1bWRXNWpkR2x2YmlCbWIzSkZZV05vS0c5aWFpd2dabTRwSUh0Y2JpQWdMeThnUkc5dUozUWdZbTkwYUdWeUlHbG1JRzV2SUhaaGJIVmxJSEJ5YjNacFpHVmtYRzRnSUdsbUlDaHZZbW9nUFQwOUlHNTFiR3dnZkh3Z2RIbHdaVzltSUc5aWFpQTlQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCeVpYUjFjbTQ3WEc0Z0lIMWNibHh1SUNBdkx5QkdiM0pqWlNCaGJpQmhjbkpoZVNCcFppQnViM1FnWVd4eVpXRmtlU0J6YjIxbGRHaHBibWNnYVhSbGNtRmliR1ZjYmlBZ2FXWWdLSFI1Y0dWdlppQnZZbW9nSVQwOUlDZHZZbXBsWTNRbktTQjdYRzRnSUNBZ0x5cGxjMnhwYm5RZ2JtOHRjR0Z5WVcwdGNtVmhjM05wWjI0Nk1Db3ZYRzRnSUNBZ2IySnFJRDBnVzI5aWFsMDdYRzRnSUgxY2JseHVJQ0JwWmlBb2FYTkJjbkpoZVNodlltb3BLU0I3WEc0Z0lDQWdMeThnU1hSbGNtRjBaU0J2ZG1WeUlHRnljbUY1SUhaaGJIVmxjMXh1SUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3TENCc0lEMGdiMkpxTG14bGJtZDBhRHNnYVNBOElHdzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ1ptNHVZMkZzYkNodWRXeHNMQ0J2WW1wYmFWMHNJR2tzSUc5aWFpazdYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDOHZJRWwwWlhKaGRHVWdiM1psY2lCdlltcGxZM1FnYTJWNWMxeHVJQ0FnSUdadmNpQW9kbUZ5SUd0bGVTQnBiaUJ2WW1vcElIdGNiaUFnSUNBZ0lHbG1JQ2hQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMbWhoYzA5M2JsQnliM0JsY25SNUxtTmhiR3dvYjJKcUxDQnJaWGtwS1NCN1hHNGdJQ0FnSUNBZ0lHWnVMbU5oYkd3b2JuVnNiQ3dnYjJKcVcydGxlVjBzSUd0bGVTd2diMkpxS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNibjFjYmx4dUx5b3FYRzRnS2lCQlkyTmxjSFJ6SUhaaGNtRnlaM01nWlhod1pXTjBhVzVuSUdWaFkyZ2dZWEpuZFcxbGJuUWdkRzhnWW1VZ1lXNGdiMkpxWldOMExDQjBhR1Z1WEc0Z0tpQnBiVzExZEdGaWJIa2diV1Z5WjJWeklIUm9aU0J3Y205d1pYSjBhV1Z6SUc5bUlHVmhZMmdnYjJKcVpXTjBJR0Z1WkNCeVpYUjFjbTV6SUhKbGMzVnNkQzVjYmlBcVhHNGdLaUJYYUdWdUlHMTFiSFJwY0d4bElHOWlhbVZqZEhNZ1kyOXVkR0ZwYmlCMGFHVWdjMkZ0WlNCclpYa2dkR2hsSUd4aGRHVnlJRzlpYW1WamRDQnBibHh1SUNvZ2RHaGxJR0Z5WjNWdFpXNTBjeUJzYVhOMElIZHBiR3dnZEdGclpTQndjbVZqWldSbGJtTmxMbHh1SUNwY2JpQXFJRVY0WVcxd2JHVTZYRzRnS2x4dUlDb2dZR0JnYW5OY2JpQXFJSFpoY2lCeVpYTjFiSFFnUFNCdFpYSm5aU2g3Wm05dk9pQXhNak45TENCN1ptOXZPaUEwTlRaOUtUdGNiaUFxSUdOdmJuTnZiR1V1Ykc5bktISmxjM1ZzZEM1bWIyOHBPeUF2THlCdmRYUndkWFJ6SURRMU5seHVJQ29nWUdCZ1hHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUc5aWFqRWdUMkpxWldOMElIUnZJRzFsY21kbFhHNGdLaUJBY21WMGRYSnVjeUI3VDJKcVpXTjBmU0JTWlhOMWJIUWdiMllnWVd4c0lHMWxjbWRsSUhCeWIzQmxjblJwWlhOY2JpQXFMMXh1Wm5WdVkzUnBiMjRnYldWeVoyVW9MeW9nYjJKcU1Td2diMkpxTWl3Z2IySnFNeXdnTGk0dUlDb3ZLU0I3WEc0Z0lIWmhjaUJ5WlhOMWJIUWdQU0I3ZlR0Y2JpQWdablZ1WTNScGIyNGdZWE56YVdkdVZtRnNkV1VvZG1Gc0xDQnJaWGtwSUh0Y2JpQWdJQ0JwWmlBb2FYTlFiR0ZwYms5aWFtVmpkQ2h5WlhOMWJIUmJhMlY1WFNrZ0ppWWdhWE5RYkdGcGJrOWlhbVZqZENoMllXd3BLU0I3WEc0Z0lDQWdJQ0J5WlhOMWJIUmJhMlY1WFNBOUlHMWxjbWRsS0hKbGMzVnNkRnRyWlhsZExDQjJZV3dwTzF4dUlDQWdJSDBnWld4elpTQnBaaUFvYVhOUWJHRnBiazlpYW1WamRDaDJZV3dwS1NCN1hHNGdJQ0FnSUNCeVpYTjFiSFJiYTJWNVhTQTlJRzFsY21kbEtIdDlMQ0IyWVd3cE8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FYTkJjbkpoZVNoMllXd3BLU0I3WEc0Z0lDQWdJQ0J5WlhOMWJIUmJhMlY1WFNBOUlIWmhiQzV6YkdsalpTZ3BPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCeVpYTjFiSFJiYTJWNVhTQTlJSFpoYkR0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYkNBOUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQm1iM0pGWVdOb0tHRnlaM1Z0Wlc1MGMxdHBYU3dnWVhOemFXZHVWbUZzZFdVcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYTjFiSFE3WEc1OVhHNWNiaThxS2x4dUlDb2dSWGgwWlc1a2N5QnZZbXBsWTNRZ1lTQmllU0J0ZFhSaFlteDVJR0ZrWkdsdVp5QjBieUJwZENCMGFHVWdjSEp2Y0dWeWRHbGxjeUJ2WmlCdlltcGxZM1FnWWk1Y2JpQXFYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnWVNCVWFHVWdiMkpxWldOMElIUnZJR0psSUdWNGRHVnVaR1ZrWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ1lpQlVhR1VnYjJKcVpXTjBJSFJ2SUdOdmNIa2djSEp2Y0dWeWRHbGxjeUJtY205dFhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdkR2hwYzBGeVp5QlVhR1VnYjJKcVpXTjBJSFJ2SUdKcGJtUWdablZ1WTNScGIyNGdkRzljYmlBcUlFQnlaWFIxY200Z2UwOWlhbVZqZEgwZ1ZHaGxJSEpsYzNWc2RHbHVaeUIyWVd4MVpTQnZaaUJ2WW1wbFkzUWdZVnh1SUNvdlhHNW1kVzVqZEdsdmJpQmxlSFJsYm1Rb1lTd2dZaXdnZEdocGMwRnlaeWtnZTF4dUlDQm1iM0pGWVdOb0tHSXNJR1oxYm1OMGFXOXVJR0Z6YzJsbmJsWmhiSFZsS0haaGJDd2dhMlY1S1NCN1hHNGdJQ0FnYVdZZ0tIUm9hWE5CY21jZ0ppWWdkSGx3Wlc5bUlIWmhiQ0E5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lDQWdZVnRyWlhsZElEMGdZbWx1WkNoMllXd3NJSFJvYVhOQmNtY3BPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCaFcydGxlVjBnUFNCMllXdzdYRzRnSUNBZ2ZWeHVJQ0I5S1R0Y2JpQWdjbVYwZFhKdUlHRTdYRzU5WEc1Y2JpOHFLbHh1SUNvZ1VtVnRiM1psSUdKNWRHVWdiM0prWlhJZ2JXRnlhMlZ5TGlCVWFHbHpJR05oZEdOb1pYTWdSVVlnUWtJZ1FrWWdLSFJvWlNCVlZFWXRPQ0JDVDAwcFhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0emRISnBibWQ5SUdOdmJuUmxiblFnZDJsMGFDQkNUMDFjYmlBcUlFQnlaWFIxY200Z2UzTjBjbWx1WjMwZ1kyOXVkR1Z1ZENCMllXeDFaU0IzYVhSb2IzVjBJRUpQVFZ4dUlDb3ZYRzVtZFc1amRHbHZiaUJ6ZEhKcGNFSlBUU2hqYjI1MFpXNTBLU0I3WEc0Z0lHbG1JQ2hqYjI1MFpXNTBMbU5vWVhKRGIyUmxRWFFvTUNrZ1BUMDlJREI0UmtWR1Jpa2dlMXh1SUNBZ0lHTnZiblJsYm5RZ1BTQmpiMjUwWlc1MExuTnNhV05sS0RFcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCamIyNTBaVzUwTzF4dWZWeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSHRjYmlBZ2FYTkJjbkpoZVRvZ2FYTkJjbkpoZVN4Y2JpQWdhWE5CY25KaGVVSjFabVpsY2pvZ2FYTkJjbkpoZVVKMVptWmxjaXhjYmlBZ2FYTkNkV1ptWlhJNklHbHpRblZtWm1WeUxGeHVJQ0JwYzBadmNtMUVZWFJoT2lCcGMwWnZjbTFFWVhSaExGeHVJQ0JwYzBGeWNtRjVRblZtWm1WeVZtbGxkem9nYVhOQmNuSmhlVUoxWm1abGNsWnBaWGNzWEc0Z0lHbHpVM1J5YVc1bk9pQnBjMU4wY21sdVp5eGNiaUFnYVhOT2RXMWlaWEk2SUdselRuVnRZbVZ5TEZ4dUlDQnBjMDlpYW1WamREb2dhWE5QWW1wbFkzUXNYRzRnSUdselVHeGhhVzVQWW1wbFkzUTZJR2x6VUd4aGFXNVBZbXBsWTNRc1hHNGdJR2x6Vlc1a1pXWnBibVZrT2lCcGMxVnVaR1ZtYVc1bFpDeGNiaUFnYVhORVlYUmxPaUJwYzBSaGRHVXNYRzRnSUdselJtbHNaVG9nYVhOR2FXeGxMRnh1SUNCcGMwSnNiMkk2SUdselFteHZZaXhjYmlBZ2FYTkdkVzVqZEdsdmJqb2dhWE5HZFc1amRHbHZiaXhjYmlBZ2FYTlRkSEpsWVcwNklHbHpVM1J5WldGdExGeHVJQ0JwYzFWU1RGTmxZWEpqYUZCaGNtRnRjem9nYVhOVlVreFRaV0Z5WTJoUVlYSmhiWE1zWEc0Z0lHbHpVM1JoYm1SaGNtUkNjbTkzYzJWeVJXNTJPaUJwYzFOMFlXNWtZWEprUW5KdmQzTmxja1Z1ZGl4Y2JpQWdabTl5UldGamFEb2dabTl5UldGamFDeGNiaUFnYldWeVoyVTZJRzFsY21kbExGeHVJQ0JsZUhSbGJtUTZJR1Y0ZEdWdVpDeGNiaUFnZEhKcGJUb2dkSEpwYlN4Y2JpQWdjM1J5YVhCQ1QwMDZJSE4wY21sd1FrOU5YRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnUjJWMFNXNTBjbWx1YzJsaklEMGdjbVZ4ZFdseVpTZ25aMlYwTFdsdWRISnBibk5wWXljcE8xeHVYRzUyWVhJZ1kyRnNiRUpwYm1RZ1BTQnlaWEYxYVhKbEtDY3VMeWNwTzF4dVhHNTJZWElnSkdsdVpHVjRUMllnUFNCallXeHNRbWx1WkNoSFpYUkpiblJ5YVc1emFXTW9KMU4wY21sdVp5NXdjbTkwYjNSNWNHVXVhVzVrWlhoUFppY3BLVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCallXeHNRbTkxYm1SSmJuUnlhVzV6YVdNb2JtRnRaU3dnWVd4c2IzZE5hWE56YVc1bktTQjdYRzVjZEhaaGNpQnBiblJ5YVc1emFXTWdQU0JIWlhSSmJuUnlhVzV6YVdNb2JtRnRaU3dnSVNGaGJHeHZkMDFwYzNOcGJtY3BPMXh1WEhScFppQW9kSGx3Wlc5bUlHbHVkSEpwYm5OcFl5QTlQVDBnSjJaMWJtTjBhVzl1SnlBbUppQWthVzVrWlhoUFppaHVZVzFsTENBbkxuQnliM1J2ZEhsd1pTNG5LU0ErSUMweEtTQjdYRzVjZEZ4MGNtVjBkWEp1SUdOaGJHeENhVzVrS0dsdWRISnBibk5wWXlrN1hHNWNkSDFjYmx4MGNtVjBkWEp1SUdsdWRISnBibk5wWXp0Y2JuMDdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQmlhVzVrSUQwZ2NtVnhkV2x5WlNnblpuVnVZM1JwYjI0dFltbHVaQ2NwTzF4dWRtRnlJRWRsZEVsdWRISnBibk5wWXlBOUlISmxjWFZwY21Vb0oyZGxkQzFwYm5SeWFXNXphV01uS1R0Y2JseHVkbUZ5SUNSaGNIQnNlU0E5SUVkbGRFbHVkSEpwYm5OcFl5Z25KVVoxYm1OMGFXOXVMbkJ5YjNSdmRIbHdaUzVoY0hCc2VTVW5LVHRjYm5aaGNpQWtZMkZzYkNBOUlFZGxkRWx1ZEhKcGJuTnBZeWduSlVaMWJtTjBhVzl1TG5CeWIzUnZkSGx3WlM1allXeHNKU2NwTzF4dWRtRnlJQ1J5Wldac1pXTjBRWEJ3YkhrZ1BTQkhaWFJKYm5SeWFXNXphV01vSnlWU1pXWnNaV04wTG1Gd2NHeDVKU2NzSUhSeWRXVXBJSHg4SUdKcGJtUXVZMkZzYkNna1kyRnNiQ3dnSkdGd2NHeDVLVHRjYmx4dWRtRnlJQ1JuVDFCRUlEMGdSMlYwU1c1MGNtbHVjMmxqS0NjbFQySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaVVuTENCMGNuVmxLVHRjYm5aaGNpQWtaR1ZtYVc1bFVISnZjR1Z5ZEhrZ1BTQkhaWFJKYm5SeWFXNXphV01vSnlWUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRIa2xKeXdnZEhKMVpTazdYRzUyWVhJZ0pHMWhlQ0E5SUVkbGRFbHVkSEpwYm5OcFl5Z25KVTFoZEdndWJXRjRKU2NwTzF4dVhHNXBaaUFvSkdSbFptbHVaVkJ5YjNCbGNuUjVLU0I3WEc1Y2RIUnllU0I3WEc1Y2RGeDBKR1JsWm1sdVpWQnliM0JsY25SNUtIdDlMQ0FuWVNjc0lIc2dkbUZzZFdVNklERWdmU2s3WEc1Y2RIMGdZMkYwWTJnZ0tHVXBJSHRjYmx4MFhIUXZMeUJKUlNBNElHaGhjeUJoSUdKeWIydGxiaUJrWldacGJtVlFjbTl3WlhKMGVWeHVYSFJjZENSa1pXWnBibVZRY205d1pYSjBlU0E5SUc1MWJHdzdYRzVjZEgxY2JuMWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJqWVd4c1FtbHVaQ2h2Y21sbmFXNWhiRVoxYm1OMGFXOXVLU0I3WEc1Y2RIWmhjaUJtZFc1aklEMGdKSEpsWm14bFkzUkJjSEJzZVNoaWFXNWtMQ0FrWTJGc2JDd2dZWEpuZFcxbGJuUnpLVHRjYmx4MGFXWWdLQ1JuVDFCRUlDWW1JQ1JrWldacGJtVlFjbTl3WlhKMGVTa2dlMXh1WEhSY2RIWmhjaUJrWlhOaklEMGdKR2RQVUVRb1puVnVZeXdnSjJ4bGJtZDBhQ2NwTzF4dVhIUmNkR2xtSUNoa1pYTmpMbU52Ym1acFozVnlZV0pzWlNrZ2UxeHVYSFJjZEZ4MEx5OGdiM0pwWjJsdVlXd2diR1Z1WjNSb0xDQndiSFZ6SUhSb1pTQnlaV05sYVhabGNpd2diV2x1ZFhNZ1lXNTVJR0ZrWkdsMGFXOXVZV3dnWVhKbmRXMWxiblJ6SUNoaFpuUmxjaUIwYUdVZ2NtVmpaV2wyWlhJcFhHNWNkRngwWEhRa1pHVm1hVzVsVUhKdmNHVnlkSGtvWEc1Y2RGeDBYSFJjZEdaMWJtTXNYRzVjZEZ4MFhIUmNkQ2RzWlc1bmRHZ25MRnh1WEhSY2RGeDBYSFI3SUhaaGJIVmxPaUF4SUNzZ0pHMWhlQ2d3TENCdmNtbG5hVzVoYkVaMWJtTjBhVzl1TG14bGJtZDBhQ0F0SUNoaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvSUMwZ01Ta3BJSDFjYmx4MFhIUmNkQ2s3WEc1Y2RGeDBmVnh1WEhSOVhHNWNkSEpsZEhWeWJpQm1kVzVqTzF4dWZUdGNibHh1ZG1GeUlHRndjR3g1UW1sdVpDQTlJR1oxYm1OMGFXOXVJR0Z3Y0d4NVFtbHVaQ2dwSUh0Y2JseDBjbVYwZFhKdUlDUnlaV1pzWldOMFFYQndiSGtvWW1sdVpDd2dKR0Z3Y0d4NUxDQmhjbWQxYldWdWRITXBPMXh1ZlR0Y2JseHVhV1lnS0NSa1pXWnBibVZRY205d1pYSjBlU2tnZTF4dVhIUWtaR1ZtYVc1bFVISnZjR1Z5ZEhrb2JXOWtkV3hsTG1WNGNHOXlkSE1zSUNkaGNIQnNlU2NzSUhzZ2RtRnNkV1U2SUdGd2NHeDVRbWx1WkNCOUtUdGNibjBnWld4elpTQjdYRzVjZEcxdlpIVnNaUzVsZUhCdmNuUnpMbUZ3Y0d4NUlEMGdZWEJ3YkhsQ2FXNWtPMXh1ZlZ4dUlpd2lMeXBuYkc5aVlXd2dkMmx1Wkc5M0xDQm5iRzlpWVd3cUwxeHVkbUZ5SUhWMGFXd2dQU0J5WlhGMWFYSmxLRndpZFhScGJGd2lLVnh1ZG1GeUlHRnpjMlZ5ZENBOUlISmxjWFZwY21Vb1hDSmhjM05sY25SY0lpbGNibVoxYm1OMGFXOXVJRzV2ZHlncElIc2djbVYwZFhKdUlHNWxkeUJFWVhSbEtDa3VaMlYwVkdsdFpTZ3BJSDFjYmx4dWRtRnlJSE5zYVdObElEMGdRWEp5WVhrdWNISnZkRzkwZVhCbExuTnNhV05sWEc1MllYSWdZMjl1YzI5c1pWeHVkbUZ5SUhScGJXVnpJRDBnZTMxY2JseHVhV1lnS0hSNWNHVnZaaUJuYkc5aVlXd2dJVDA5SUZ3aWRXNWtaV1pwYm1Wa1hDSWdKaVlnWjJ4dlltRnNMbU52Ym5OdmJHVXBJSHRjYmlBZ0lDQmpiMjV6YjJ4bElEMGdaMnh2WW1Gc0xtTnZibk52YkdWY2JuMGdaV3h6WlNCcFppQW9kSGx3Wlc5bUlIZHBibVJ2ZHlBaFBUMGdYQ0oxYm1SbFptbHVaV1JjSWlBbUppQjNhVzVrYjNjdVkyOXVjMjlzWlNrZ2UxeHVJQ0FnSUdOdmJuTnZiR1VnUFNCM2FXNWtiM2N1WTI5dWMyOXNaVnh1ZlNCbGJITmxJSHRjYmlBZ0lDQmpiMjV6YjJ4bElEMGdlMzFjYm4xY2JseHVkbUZ5SUdaMWJtTjBhVzl1Y3lBOUlGdGNiaUFnSUNCYmJHOW5MQ0JjSW14dloxd2lYU3hjYmlBZ0lDQmJhVzVtYnl3Z1hDSnBibVp2WENKZExGeHVJQ0FnSUZ0M1lYSnVMQ0JjSW5kaGNtNWNJbDBzWEc0Z0lDQWdXMlZ5Y205eUxDQmNJbVZ5Y205eVhDSmRMRnh1SUNBZ0lGdDBhVzFsTENCY0luUnBiV1ZjSWwwc1hHNGdJQ0FnVzNScGJXVkZibVFzSUZ3aWRHbHRaVVZ1WkZ3aVhTeGNiaUFnSUNCYmRISmhZMlVzSUZ3aWRISmhZMlZjSWwwc1hHNGdJQ0FnVzJScGNpd2dYQ0prYVhKY0lsMHNYRzRnSUNBZ1cyTnZibk52YkdWQmMzTmxjblFzSUZ3aVlYTnpaWEowWENKZFhHNWRYRzVjYm1admNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z1puVnVZM1JwYjI1ekxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdkbUZ5SUhSMWNHeGxJRDBnWm5WdVkzUnBiMjV6VzJsZFhHNGdJQ0FnZG1GeUlHWWdQU0IwZFhCc1pWc3dYVnh1SUNBZ0lIWmhjaUJ1WVcxbElEMGdkSFZ3YkdWYk1WMWNibHh1SUNBZ0lHbG1JQ2doWTI5dWMyOXNaVnR1WVcxbFhTa2dlMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxXMjVoYldWZElEMGdabHh1SUNBZ0lIMWNibjFjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCamIyNXpiMnhsWEc1Y2JtWjFibU4wYVc5dUlHeHZaeWdwSUh0OVhHNWNibVoxYm1OMGFXOXVJR2x1Wm04b0tTQjdYRzRnSUNBZ1kyOXVjMjlzWlM1c2IyY3VZWEJ3Ykhrb1kyOXVjMjlzWlN3Z1lYSm5kVzFsYm5SektWeHVmVnh1WEc1bWRXNWpkR2x2YmlCM1lYSnVLQ2tnZTF4dUlDQWdJR052Ym5OdmJHVXViRzluTG1Gd2NHeDVLR052Ym5OdmJHVXNJR0Z5WjNWdFpXNTBjeWxjYm4xY2JseHVablZ1WTNScGIyNGdaWEp5YjNJb0tTQjdYRzRnSUNBZ1kyOXVjMjlzWlM1M1lYSnVMbUZ3Y0d4NUtHTnZibk52YkdVc0lHRnlaM1Z0Wlc1MGN5bGNibjFjYmx4dVpuVnVZM1JwYjI0Z2RHbHRaU2hzWVdKbGJDa2dlMXh1SUNBZ0lIUnBiV1Z6VzJ4aFltVnNYU0E5SUc1dmR5Z3BYRzU5WEc1Y2JtWjFibU4wYVc5dUlIUnBiV1ZGYm1Rb2JHRmlaV3dwSUh0Y2JpQWdJQ0IyWVhJZ2RHbHRaU0E5SUhScGJXVnpXMnhoWW1Wc1hWeHVJQ0FnSUdsbUlDZ2hkR2x0WlNrZ2UxeHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1hDSk9ieUJ6ZFdOb0lHeGhZbVZzT2lCY0lpQXJJR3hoWW1Wc0tWeHVJQ0FnSUgxY2JseHVJQ0FnSUdSbGJHVjBaU0IwYVcxbGMxdHNZV0psYkYxY2JpQWdJQ0IyWVhJZ1pIVnlZWFJwYjI0Z1BTQnViM2NvS1NBdElIUnBiV1ZjYmlBZ0lDQmpiMjV6YjJ4bExteHZaeWhzWVdKbGJDQXJJRndpT2lCY0lpQXJJR1IxY21GMGFXOXVJQ3NnWENKdGMxd2lLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQjBjbUZqWlNncElIdGNiaUFnSUNCMllYSWdaWEp5SUQwZ2JtVjNJRVZ5Y205eUtDbGNiaUFnSUNCbGNuSXVibUZ0WlNBOUlGd2lWSEpoWTJWY0lseHVJQ0FnSUdWeWNpNXRaWE56WVdkbElEMGdkWFJwYkM1bWIzSnRZWFF1WVhCd2JIa29iblZzYkN3Z1lYSm5kVzFsYm5SektWeHVJQ0FnSUdOdmJuTnZiR1V1WlhKeWIzSW9aWEp5TG5OMFlXTnJLVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmthWElvYjJKcVpXTjBLU0I3WEc0Z0lDQWdZMjl1YzI5c1pTNXNiMmNvZFhScGJDNXBibk53WldOMEtHOWlhbVZqZENrZ0t5QmNJbHhjYmx3aUtWeHVmVnh1WEc1bWRXNWpkR2x2YmlCamIyNXpiMnhsUVhOelpYSjBLR1Y0Y0hKbGMzTnBiMjRwSUh0Y2JpQWdJQ0JwWmlBb0lXVjRjSEpsYzNOcGIyNHBJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHRnljaUE5SUhOc2FXTmxMbU5oYkd3b1lYSm5kVzFsYm5SekxDQXhLVnh1SUNBZ0lDQWdJQ0JoYzNObGNuUXViMnNvWm1Gc2MyVXNJSFYwYVd3dVptOXliV0YwTG1Gd2NHeDVLRzUxYkd3c0lHRnljaWtwWEc0Z0lDQWdmVnh1ZlZ4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnYTJWNWN5QTlJSEpsY1hWcGNtVW9KMjlpYW1WamRDMXJaWGx6SnlrN1hHNTJZWElnYUdGelUzbHRZbTlzY3lBOUlIUjVjR1Z2WmlCVGVXMWliMndnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVlnZEhsd1pXOW1JRk41YldKdmJDZ25abTl2SnlrZ1BUMDlJQ2R6ZVcxaWIyd25PMXh1WEc1MllYSWdkRzlUZEhJZ1BTQlBZbXBsWTNRdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bk8xeHVkbUZ5SUdOdmJtTmhkQ0E5SUVGeWNtRjVMbkJ5YjNSdmRIbHdaUzVqYjI1allYUTdYRzUyWVhJZ2IzSnBaMFJsWm1sdVpWQnliM0JsY25SNUlEMGdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblI1TzF4dVhHNTJZWElnYVhOR2RXNWpkR2x2YmlBOUlHWjFibU4wYVc5dUlDaG1iaWtnZTF4dVhIUnlaWFIxY200Z2RIbHdaVzltSUdadUlEMDlQU0FuWm5WdVkzUnBiMjRuSUNZbUlIUnZVM1J5TG1OaGJHd29abTRwSUQwOVBTQW5XMjlpYW1WamRDQkdkVzVqZEdsdmJsMG5PMXh1ZlR0Y2JseHVkbUZ5SUdGeVpWQnliM0JsY25SNVJHVnpZM0pwY0hSdmNuTlRkWEJ3YjNKMFpXUWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNWNkSFpoY2lCdlltb2dQU0I3ZlR0Y2JseDBkSEo1SUh0Y2JseDBYSFJ2Y21sblJHVm1hVzVsVUhKdmNHVnlkSGtvYjJKcUxDQW5lQ2NzSUhzZ1pXNTFiV1Z5WVdKc1pUb2dabUZzYzJVc0lIWmhiSFZsT2lCdlltb2dmU2s3WEc1Y2RGeDBMeThnWlhOc2FXNTBMV1JwYzJGaWJHVXRibVY0ZEMxc2FXNWxJRzV2TFhWdWRYTmxaQzEyWVhKekxDQnVieTF5WlhOMGNtbGpkR1ZrTFhONWJuUmhlRnh1WEhSY2RHWnZjaUFvZG1GeUlGOGdhVzRnYjJKcUtTQjdJQzh2SUdwelkzTTZhV2R1YjNKbElHUnBjMkZzYkc5M1ZXNTFjMlZrVm1GeWFXRmliR1Z6WEc1Y2RGeDBYSFJ5WlhSMWNtNGdabUZzYzJVN1hHNWNkRngwZlZ4dVhIUmNkSEpsZEhWeWJpQnZZbW91ZUNBOVBUMGdiMkpxTzF4dVhIUjlJR05oZEdOb0lDaGxLU0I3SUM4cUlIUm9hWE1nYVhNZ1NVVWdPQzRnS2k5Y2JseDBYSFJ5WlhSMWNtNGdabUZzYzJVN1hHNWNkSDFjYm4wN1hHNTJZWElnYzNWd2NHOXlkSE5FWlhOamNtbHdkRzl5Y3lBOUlHOXlhV2RFWldacGJtVlFjbTl3WlhKMGVTQW1KaUJoY21WUWNtOXdaWEowZVVSbGMyTnlhWEIwYjNKelUzVndjRzl5ZEdWa0tDazdYRzVjYm5aaGNpQmtaV1pwYm1WUWNtOXdaWEowZVNBOUlHWjFibU4wYVc5dUlDaHZZbXBsWTNRc0lHNWhiV1VzSUhaaGJIVmxMQ0J3Y21Wa2FXTmhkR1VwSUh0Y2JseDBhV1lnS0c1aGJXVWdhVzRnYjJKcVpXTjBJQ1ltSUNnaGFYTkdkVzVqZEdsdmJpaHdjbVZrYVdOaGRHVXBJSHg4SUNGd2NtVmthV05oZEdVb0tTa3BJSHRjYmx4MFhIUnlaWFIxY200N1hHNWNkSDFjYmx4MGFXWWdLSE4xY0hCdmNuUnpSR1Z6WTNKcGNIUnZjbk1wSUh0Y2JseDBYSFJ2Y21sblJHVm1hVzVsVUhKdmNHVnlkSGtvYjJKcVpXTjBMQ0J1WVcxbExDQjdYRzVjZEZ4MFhIUmpiMjVtYVdkMWNtRmliR1U2SUhSeWRXVXNYRzVjZEZ4MFhIUmxiblZ0WlhKaFlteGxPaUJtWVd4elpTeGNibHgwWEhSY2RIWmhiSFZsT2lCMllXeDFaU3hjYmx4MFhIUmNkSGR5YVhSaFlteGxPaUIwY25WbFhHNWNkRngwZlNrN1hHNWNkSDBnWld4elpTQjdYRzVjZEZ4MGIySnFaV04wVzI1aGJXVmRJRDBnZG1Gc2RXVTdYRzVjZEgxY2JuMDdYRzVjYm5aaGNpQmtaV1pwYm1WUWNtOXdaWEowYVdWeklEMGdablZ1WTNScGIyNGdLRzlpYW1WamRDd2diV0Z3S1NCN1hHNWNkSFpoY2lCd2NtVmthV05oZEdWeklEMGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQStJRElnUHlCaGNtZDFiV1Z1ZEhOYk1sMGdPaUI3ZlR0Y2JseDBkbUZ5SUhCeWIzQnpJRDBnYTJWNWN5aHRZWEFwTzF4dVhIUnBaaUFvYUdGelUzbHRZbTlzY3lrZ2UxeHVYSFJjZEhCeWIzQnpJRDBnWTI5dVkyRjBMbU5oYkd3b2NISnZjSE1zSUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNb2JXRndLU2s3WEc1Y2RIMWNibHgwWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCd2NtOXdjeTVzWlc1bmRHZzdJR2tnS3owZ01Ta2dlMXh1WEhSY2RHUmxabWx1WlZCeWIzQmxjblI1S0c5aWFtVmpkQ3dnY0hKdmNITmJhVjBzSUcxaGNGdHdjbTl3YzF0cFhWMHNJSEJ5WldScFkyRjBaWE5iY0hKdmNITmJhVjFkS1R0Y2JseDBmVnh1ZlR0Y2JseHVaR1ZtYVc1bFVISnZjR1Z5ZEdsbGN5NXpkWEJ3YjNKMGMwUmxjMk55YVhCMGIzSnpJRDBnSVNGemRYQndiM0owYzBSbGMyTnlhWEIwYjNKek8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1JsWm1sdVpWQnliM0JsY25ScFpYTTdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQkhaWFJKYm5SeWFXNXphV01nUFNCeVpYRjFhWEpsS0NkblpYUXRhVzUwY21sdWMybGpKeWs3WEc1Y2JuWmhjaUFrWjA5UVJDQTlJRWRsZEVsdWRISnBibk5wWXlnbkpVOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVVJsYzJOeWFYQjBiM0lsSnlrN1hHNXBaaUFvSkdkUFVFUXBJSHRjYmx4MGRISjVJSHRjYmx4MFhIUWtaMDlRUkNoYlhTd2dKMnhsYm1kMGFDY3BPMXh1WEhSOUlHTmhkR05vSUNobEtTQjdYRzVjZEZ4MEx5OGdTVVVnT0NCb1lYTWdZU0JpY205clpXNGdaMDlRUkZ4dVhIUmNkQ1JuVDFCRUlEMGdiblZzYkR0Y2JseDBmVnh1ZlZ4dVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlDUm5UMUJFTzF4dUlpd2lMeW9xWEc0Z0tpQkRiMlJsSUhKbFptRmpkRzl5WldRZ1puSnZiU0JOYjNwcGJHeGhJRVJsZG1Wc2IzQmxjaUJPWlhSM2IzSnJPbHh1SUNvZ2FIUjBjSE02THk5a1pYWmxiRzl3WlhJdWJXOTZhV3hzWVM1dmNtY3ZaVzR0VlZNdlpHOWpjeTlYWldJdlNtRjJZVk5qY21sd2RDOVNaV1psY21WdVkyVXZSMnh2WW1Gc1gwOWlhbVZqZEhNdlQySnFaV04wTDJGemMybG5ibHh1SUNvdlhHNWNiaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVablZ1WTNScGIyNGdZWE56YVdkdUtIUmhjbWRsZEN3Z1ptbHljM1JUYjNWeVkyVXBJSHRjYmlBZ2FXWWdLSFJoY21kbGRDQTlQVDBnZFc1a1pXWnBibVZrSUh4OElIUmhjbWRsZENBOVBUMGdiblZzYkNrZ2UxeHVJQ0FnSUhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0owTmhibTV2ZENCamIyNTJaWEowSUdacGNuTjBJR0Z5WjNWdFpXNTBJSFJ2SUc5aWFtVmpkQ2NwTzF4dUlDQjlYRzVjYmlBZ2RtRnlJSFJ2SUQwZ1QySnFaV04wS0hSaGNtZGxkQ2s3WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F4T3lCcElEd2dZWEpuZFcxbGJuUnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnZG1GeUlHNWxlSFJUYjNWeVkyVWdQU0JoY21kMWJXVnVkSE5iYVYwN1hHNGdJQ0FnYVdZZ0tHNWxlSFJUYjNWeVkyVWdQVDA5SUhWdVpHVm1hVzVsWkNCOGZDQnVaWGgwVTI5MWNtTmxJRDA5UFNCdWRXeHNLU0I3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQjJZWElnYTJWNWMwRnljbUY1SUQwZ1QySnFaV04wTG10bGVYTW9UMkpxWldOMEtHNWxlSFJUYjNWeVkyVXBLVHRjYmlBZ0lDQm1iM0lnS0haaGNpQnVaWGgwU1c1a1pYZ2dQU0F3TENCc1pXNGdQU0JyWlhselFYSnlZWGt1YkdWdVozUm9PeUJ1WlhoMFNXNWtaWGdnUENCc1pXNDdJRzVsZUhSSmJtUmxlQ3NyS1NCN1hHNGdJQ0FnSUNCMllYSWdibVY0ZEV0bGVTQTlJR3RsZVhOQmNuSmhlVnR1WlhoMFNXNWtaWGhkTzF4dUlDQWdJQ0FnZG1GeUlHUmxjMk1nUFNCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbEVaWE5qY21sd2RHOXlLRzVsZUhSVGIzVnlZMlVzSUc1bGVIUkxaWGtwTzF4dUlDQWdJQ0FnYVdZZ0tHUmxjMk1nSVQwOUlIVnVaR1ZtYVc1bFpDQW1KaUJrWlhOakxtVnVkVzFsY21GaWJHVXBJSHRjYmlBZ0lDQWdJQ0FnZEc5YmJtVjRkRXRsZVYwZ1BTQnVaWGgwVTI5MWNtTmxXMjVsZUhSTFpYbGRPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlZ4dUlDQnlaWFIxY200Z2RHODdYRzU5WEc1Y2JtWjFibU4wYVc5dUlIQnZiSGxtYVd4c0tDa2dlMXh1SUNCcFppQW9JVTlpYW1WamRDNWhjM05wWjI0cElIdGNiaUFnSUNCUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRIa29UMkpxWldOMExDQW5ZWE56YVdkdUp5d2dlMXh1SUNBZ0lDQWdaVzUxYldWeVlXSnNaVG9nWm1Gc2MyVXNYRzRnSUNBZ0lDQmpiMjVtYVdkMWNtRmliR1U2SUhSeWRXVXNYRzRnSUNBZ0lDQjNjbWwwWVdKc1pUb2dkSEoxWlN4Y2JpQWdJQ0FnSUhaaGJIVmxPaUJoYzNOcFoyNWNiaUFnSUNCOUtUdGNiaUFnZlZ4dWZWeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSHRjYmlBZ1lYTnphV2R1T2lCaGMzTnBaMjRzWEc0Z0lIQnZiSGxtYVd4c09pQndiMng1Wm1sc2JGeHVmVHRjYmlJc0lpOHZJRU52Y0hseWFXZG9kQ0JLYjNsbGJuUXNJRWx1WXk0Z1lXNWtJRzkwYUdWeUlFNXZaR1VnWTI5dWRISnBZblYwYjNKekxseHVMeTljYmk4dklGQmxjbTFwYzNOcGIyNGdhWE1nYUdWeVpXSjVJR2R5WVc1MFpXUXNJR1p5WldVZ2IyWWdZMmhoY21kbExDQjBieUJoYm5rZ2NHVnljMjl1SUc5aWRHRnBibWx1WnlCaFhHNHZMeUJqYjNCNUlHOW1JSFJvYVhNZ2MyOW1kSGRoY21VZ1lXNWtJR0Z6YzI5amFXRjBaV1FnWkc5amRXMWxiblJoZEdsdmJpQm1hV3hsY3lBb2RHaGxYRzR2THlCY0lsTnZablIzWVhKbFhDSXBMQ0IwYnlCa1pXRnNJR2x1SUhSb1pTQlRiMlowZDJGeVpTQjNhWFJvYjNWMElISmxjM1J5YVdOMGFXOXVMQ0JwYm1Oc2RXUnBibWRjYmk4dklIZHBkR2h2ZFhRZ2JHbHRhWFJoZEdsdmJpQjBhR1VnY21sbmFIUnpJSFJ2SUhWelpTd2dZMjl3ZVN3Z2JXOWthV1o1TENCdFpYSm5aU3dnY0hWaWJHbHphQ3hjYmk4dklHUnBjM1J5YVdKMWRHVXNJSE4xWW14cFkyVnVjMlVzSUdGdVpDOXZjaUJ6Wld4c0lHTnZjR2xsY3lCdlppQjBhR1VnVTI5bWRIZGhjbVVzSUdGdVpDQjBieUJ3WlhKdGFYUmNiaTh2SUhCbGNuTnZibk1nZEc4Z2QyaHZiU0IwYUdVZ1UyOW1kSGRoY21VZ2FYTWdablZ5Ym1semFHVmtJSFJ2SUdSdklITnZMQ0J6ZFdKcVpXTjBJSFJ2SUhSb1pWeHVMeThnWm05c2JHOTNhVzVuSUdOdmJtUnBkR2x2Ym5NNlhHNHZMMXh1THk4Z1ZHaGxJR0ZpYjNabElHTnZjSGx5YVdkb2RDQnViM1JwWTJVZ1lXNWtJSFJvYVhNZ2NHVnliV2x6YzJsdmJpQnViM1JwWTJVZ2MyaGhiR3dnWW1VZ2FXNWpiSFZrWldSY2JpOHZJR2x1SUdGc2JDQmpiM0JwWlhNZ2IzSWdjM1ZpYzNSaGJuUnBZV3dnY0c5eWRHbHZibk1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMbHh1THk5Y2JpOHZJRlJJUlNCVFQwWlVWMEZTUlNCSlV5QlFVazlXU1VSRlJDQmNJa0ZUSUVsVFhDSXNJRmRKVkVoUFZWUWdWMEZTVWtGT1ZGa2dUMFlnUVU1WklFdEpUa1FzSUVWWVVGSkZVMU5jYmk4dklFOVNJRWxOVUV4SlJVUXNJRWxPUTB4VlJFbE9SeUJDVlZRZ1RrOVVJRXhKVFVsVVJVUWdWRThnVkVoRklGZEJVbEpCVGxSSlJWTWdUMFpjYmk4dklFMUZVa05JUVU1VVFVSkpURWxVV1N3Z1JrbFVUa1ZUVXlCR1QxSWdRU0JRUVZKVVNVTlZURUZTSUZCVlVsQlBVMFVnUVU1RUlFNVBUa2xPUmxKSlRrZEZUVVZPVkM0Z1NVNWNiaTh2SUU1UElFVldSVTVVSUZOSVFVeE1JRlJJUlNCQlZWUklUMUpUSUU5U0lFTlBVRmxTU1VkSVZDQklUMHhFUlZKVElFSkZJRXhKUVVKTVJTQkdUMUlnUVU1WklFTk1RVWxOTEZ4dUx5OGdSRUZOUVVkRlV5QlBVaUJQVkVoRlVpQk1TVUZDU1V4SlZGa3NJRmRJUlZSSVJWSWdTVTRnUVU0Z1FVTlVTVTlPSUU5R0lFTlBUbFJTUVVOVUxDQlVUMUpVSUU5U1hHNHZMeUJQVkVoRlVsZEpVMFVzSUVGU1NWTkpUa2NnUmxKUFRTd2dUMVZVSUU5R0lFOVNJRWxPSUVOUFRrNUZRMVJKVDA0Z1YwbFVTQ0JVU0VVZ1UwOUdWRmRCVWtVZ1QxSWdWRWhGWEc0dkx5QlZVMFVnVDFJZ1QxUklSVklnUkVWQlRFbE9SMU1nU1U0Z1ZFaEZJRk5QUmxSWFFWSkZMbHh1WEc0bmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQlNJRDBnZEhsd1pXOW1JRkpsWm14bFkzUWdQVDA5SUNkdlltcGxZM1FuSUQ4Z1VtVm1iR1ZqZENBNklHNTFiR3hjYm5aaGNpQlNaV1pzWldOMFFYQndiSGtnUFNCU0lDWW1JSFI1Y0dWdlppQlNMbUZ3Y0d4NUlEMDlQU0FuWm5WdVkzUnBiMjRuWEc0Z0lEOGdVaTVoY0hCc2VWeHVJQ0E2SUdaMWJtTjBhVzl1SUZKbFpteGxZM1JCY0hCc2VTaDBZWEpuWlhRc0lISmxZMlZwZG1WeUxDQmhjbWR6S1NCN1hHNGdJQ0FnY21WMGRYSnVJRVoxYm1OMGFXOXVMbkJ5YjNSdmRIbHdaUzVoY0hCc2VTNWpZV3hzS0hSaGNtZGxkQ3dnY21WalpXbDJaWElzSUdGeVozTXBPMXh1SUNCOVhHNWNiblpoY2lCU1pXWnNaV04wVDNkdVMyVjVjMXh1YVdZZ0tGSWdKaVlnZEhsd1pXOW1JRkl1YjNkdVMyVjVjeUE5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNCU1pXWnNaV04wVDNkdVMyVjVjeUE5SUZJdWIzZHVTMlY1YzF4dWZTQmxiSE5sSUdsbUlDaFBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxUZVcxaWIyeHpLU0I3WEc0Z0lGSmxabXhsWTNSUGQyNUxaWGx6SUQwZ1puVnVZM1JwYjI0Z1VtVm1iR1ZqZEU5M2JrdGxlWE1vZEdGeVoyVjBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVTVoYldWektIUmhjbWRsZENsY2JpQWdJQ0FnSUM1amIyNWpZWFFvVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVUzbHRZbTlzY3loMFlYSm5aWFFwS1R0Y2JpQWdmVHRjYm4wZ1pXeHpaU0I3WEc0Z0lGSmxabXhsWTNSUGQyNUxaWGx6SUQwZ1puVnVZM1JwYjI0Z1VtVm1iR1ZqZEU5M2JrdGxlWE1vZEdGeVoyVjBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVTVoYldWektIUmhjbWRsZENrN1hHNGdJSDA3WEc1OVhHNWNibVoxYm1OMGFXOXVJRkJ5YjJObGMzTkZiV2wwVjJGeWJtbHVaeWgzWVhKdWFXNW5LU0I3WEc0Z0lHbG1JQ2hqYjI1emIyeGxJQ1ltSUdOdmJuTnZiR1V1ZDJGeWJpa2dZMjl1YzI5c1pTNTNZWEp1S0hkaGNtNXBibWNwTzF4dWZWeHVYRzUyWVhJZ1RuVnRZbVZ5U1hOT1lVNGdQU0JPZFcxaVpYSXVhWE5PWVU0Z2ZId2dablZ1WTNScGIyNGdUblZ0WW1WeVNYTk9ZVTRvZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUhaaGJIVmxJQ0U5UFNCMllXeDFaVHRjYm4xY2JseHVablZ1WTNScGIyNGdSWFpsYm5SRmJXbDBkR1Z5S0NrZ2UxeHVJQ0JGZG1WdWRFVnRhWFIwWlhJdWFXNXBkQzVqWVd4c0tIUm9hWE1wTzF4dWZWeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQkZkbVZ1ZEVWdGFYUjBaWEk3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeTV2Ym1ObElEMGdiMjVqWlR0Y2JseHVMeThnUW1GamEzZGhjbVJ6TFdOdmJYQmhkQ0IzYVhSb0lHNXZaR1VnTUM0eE1DNTRYRzVGZG1WdWRFVnRhWFIwWlhJdVJYWmxiblJGYldsMGRHVnlJRDBnUlhabGJuUkZiV2wwZEdWeU8xeHVYRzVGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExsOWxkbVZ1ZEhNZ1BTQjFibVJsWm1sdVpXUTdYRzVGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExsOWxkbVZ1ZEhORGIzVnVkQ0E5SURBN1hHNUZkbVZ1ZEVWdGFYUjBaWEl1Y0hKdmRHOTBlWEJsTGw5dFlYaE1hWE4wWlc1bGNuTWdQU0IxYm1SbFptbHVaV1E3WEc1Y2JpOHZJRUo1SUdSbFptRjFiSFFnUlhabGJuUkZiV2wwZEdWeWN5QjNhV3hzSUhCeWFXNTBJR0VnZDJGeWJtbHVaeUJwWmlCdGIzSmxJSFJvWVc0Z01UQWdiR2x6ZEdWdVpYSnpJR0Z5WlZ4dUx5OGdZV1JrWldRZ2RHOGdhWFF1SUZSb2FYTWdhWE1nWVNCMWMyVm1kV3dnWkdWbVlYVnNkQ0IzYUdsamFDQm9aV3h3Y3lCbWFXNWthVzVuSUcxbGJXOXllU0JzWldGcmN5NWNiblpoY2lCa1pXWmhkV3gwVFdGNFRHbHpkR1Z1WlhKeklEMGdNVEE3WEc1Y2JtWjFibU4wYVc5dUlHTm9aV05yVEdsemRHVnVaWElvYkdsemRHVnVaWElwSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUJzYVhOMFpXNWxjaUFoUFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMVJvWlNCY0lteHBjM1JsYm1WeVhDSWdZWEpuZFcxbGJuUWdiWFZ6ZENCaVpTQnZaaUIwZVhCbElFWjFibU4wYVc5dUxpQlNaV05sYVhabFpDQjBlWEJsSUNjZ0t5QjBlWEJsYjJZZ2JHbHpkR1Z1WlhJcE8xeHVJQ0I5WEc1OVhHNWNiazlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowZVNoRmRtVnVkRVZ0YVhSMFpYSXNJQ2RrWldaaGRXeDBUV0Y0VEdsemRHVnVaWEp6Snl3Z2UxeHVJQ0JsYm5WdFpYSmhZbXhsT2lCMGNuVmxMRnh1SUNCblpYUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQmtaV1poZFd4MFRXRjRUR2x6ZEdWdVpYSnpPMXh1SUNCOUxGeHVJQ0J6WlhRNklHWjFibU4wYVc5dUtHRnlaeWtnZTF4dUlDQWdJR2xtSUNoMGVYQmxiMllnWVhKbklDRTlQU0FuYm5WdFltVnlKeUI4ZkNCaGNtY2dQQ0F3SUh4OElFNTFiV0psY2tselRtRk9LR0Z5WnlrcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QlNZVzVuWlVWeWNtOXlLQ2RVYUdVZ2RtRnNkV1VnYjJZZ1hDSmtaV1poZFd4MFRXRjRUR2x6ZEdWdVpYSnpYQ0lnYVhNZ2IzVjBJRzltSUhKaGJtZGxMaUJKZENCdGRYTjBJR0psSUdFZ2JtOXVMVzVsWjJGMGFYWmxJRzUxYldKbGNpNGdVbVZqWldsMlpXUWdKeUFySUdGeVp5QXJJQ2N1SnlrN1hHNGdJQ0FnZlZ4dUlDQWdJR1JsWm1GMWJIUk5ZWGhNYVhOMFpXNWxjbk1nUFNCaGNtYzdYRzRnSUgxY2JuMHBPMXh1WEc1RmRtVnVkRVZ0YVhSMFpYSXVhVzVwZENBOUlHWjFibU4wYVc5dUtDa2dlMXh1WEc0Z0lHbG1JQ2gwYUdsekxsOWxkbVZ1ZEhNZ1BUMDlJSFZ1WkdWbWFXNWxaQ0I4ZkZ4dUlDQWdJQ0FnZEdocGN5NWZaWFpsYm5SeklEMDlQU0JQWW1wbFkzUXVaMlYwVUhKdmRHOTBlWEJsVDJZb2RHaHBjeWt1WDJWMlpXNTBjeWtnZTF4dUlDQWdJSFJvYVhNdVgyVjJaVzUwY3lBOUlFOWlhbVZqZEM1amNtVmhkR1VvYm5Wc2JDazdYRzRnSUNBZ2RHaHBjeTVmWlhabGJuUnpRMjkxYm5RZ1BTQXdPMXh1SUNCOVhHNWNiaUFnZEdocGN5NWZiV0Y0VEdsemRHVnVaWEp6SUQwZ2RHaHBjeTVmYldGNFRHbHpkR1Z1WlhKeklIeDhJSFZ1WkdWbWFXNWxaRHRjYm4wN1hHNWNiaTh2SUU5aWRtbHZkWE5zZVNCdWIzUWdZV3hzSUVWdGFYUjBaWEp6SUhOb2IzVnNaQ0JpWlNCc2FXMXBkR1ZrSUhSdklERXdMaUJVYUdseklHWjFibU4wYVc5dUlHRnNiRzkzYzF4dUx5OGdkR2hoZENCMGJ5QmlaU0JwYm1OeVpXRnpaV1F1SUZObGRDQjBieUI2WlhKdklHWnZjaUIxYm14cGJXbDBaV1F1WEc1RmRtVnVkRVZ0YVhSMFpYSXVjSEp2ZEc5MGVYQmxMbk5sZEUxaGVFeHBjM1JsYm1WeWN5QTlJR1oxYm1OMGFXOXVJSE5sZEUxaGVFeHBjM1JsYm1WeWN5aHVLU0I3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdiaUFoUFQwZ0oyNTFiV0psY2ljZ2ZId2diaUE4SURBZ2ZId2dUblZ0WW1WeVNYTk9ZVTRvYmlrcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1VtRnVaMlZGY25KdmNpZ25WR2hsSUhaaGJIVmxJRzltSUZ3aWJsd2lJR2x6SUc5MWRDQnZaaUJ5WVc1blpTNGdTWFFnYlhWemRDQmlaU0JoSUc1dmJpMXVaV2RoZEdsMlpTQnVkVzFpWlhJdUlGSmxZMlZwZG1Wa0lDY2dLeUJ1SUNzZ0p5NG5LVHRjYmlBZ2ZWeHVJQ0IwYUdsekxsOXRZWGhNYVhOMFpXNWxjbk1nUFNCdU8xeHVJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JuMDdYRzVjYm1aMWJtTjBhVzl1SUY5blpYUk5ZWGhNYVhOMFpXNWxjbk1vZEdoaGRDa2dlMXh1SUNCcFppQW9kR2hoZEM1ZmJXRjRUR2x6ZEdWdVpYSnpJRDA5UFNCMWJtUmxabWx1WldRcFhHNGdJQ0FnY21WMGRYSnVJRVYyWlc1MFJXMXBkSFJsY2k1a1pXWmhkV3gwVFdGNFRHbHpkR1Z1WlhKek8xeHVJQ0J5WlhSMWNtNGdkR2hoZEM1ZmJXRjRUR2x6ZEdWdVpYSnpPMXh1ZlZ4dVhHNUZkbVZ1ZEVWdGFYUjBaWEl1Y0hKdmRHOTBlWEJsTG1kbGRFMWhlRXhwYzNSbGJtVnljeUE5SUdaMWJtTjBhVzl1SUdkbGRFMWhlRXhwYzNSbGJtVnljeWdwSUh0Y2JpQWdjbVYwZFhKdUlGOW5aWFJOWVhoTWFYTjBaVzVsY25Nb2RHaHBjeWs3WEc1OU8xeHVYRzVGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExtVnRhWFFnUFNCbWRXNWpkR2x2YmlCbGJXbDBLSFI1Y0dVcElIdGNiaUFnZG1GeUlHRnlaM01nUFNCYlhUdGNiaUFnWm05eUlDaDJZWElnYVNBOUlERTdJR2tnUENCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvT3lCcEt5c3BJR0Z5WjNNdWNIVnphQ2hoY21kMWJXVnVkSE5iYVYwcE8xeHVJQ0IyWVhJZ1pHOUZjbkp2Y2lBOUlDaDBlWEJsSUQwOVBTQW5aWEp5YjNJbktUdGNibHh1SUNCMllYSWdaWFpsYm5SeklEMGdkR2hwY3k1ZlpYWmxiblJ6TzF4dUlDQnBaaUFvWlhabGJuUnpJQ0U5UFNCMWJtUmxabWx1WldRcFhHNGdJQ0FnWkc5RmNuSnZjaUE5SUNoa2IwVnljbTl5SUNZbUlHVjJaVzUwY3k1bGNuSnZjaUE5UFQwZ2RXNWtaV1pwYm1Wa0tUdGNiaUFnWld4elpTQnBaaUFvSVdSdlJYSnliM0lwWEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dVhHNGdJQzh2SUVsbUlIUm9aWEpsSUdseklHNXZJQ2RsY25KdmNpY2daWFpsYm5RZ2JHbHpkR1Z1WlhJZ2RHaGxiaUIwYUhKdmR5NWNiaUFnYVdZZ0tHUnZSWEp5YjNJcElIdGNiaUFnSUNCMllYSWdaWEk3WEc0Z0lDQWdhV1lnS0dGeVozTXViR1Z1WjNSb0lENGdNQ2xjYmlBZ0lDQWdJR1Z5SUQwZ1lYSm5jMXN3WFR0Y2JpQWdJQ0JwWmlBb1pYSWdhVzV6ZEdGdVkyVnZaaUJGY25KdmNpa2dlMXh1SUNBZ0lDQWdMeThnVG05MFpUb2dWR2hsSUdOdmJXMWxiblJ6SUc5dUlIUm9aU0JnZEdoeWIzZGdJR3hwYm1WeklHRnlaU0JwYm5SbGJuUnBiMjVoYkN3Z2RHaGxlU0J6YUc5M1hHNGdJQ0FnSUNBdkx5QjFjQ0JwYmlCT2IyUmxKM01nYjNWMGNIVjBJR2xtSUhSb2FYTWdjbVZ6ZFd4MGN5QnBiaUJoYmlCMWJtaGhibVJzWldRZ1pYaGpaWEIwYVc5dUxseHVJQ0FnSUNBZ2RHaHliM2NnWlhJN0lDOHZJRlZ1YUdGdVpHeGxaQ0FuWlhKeWIzSW5JR1YyWlc1MFhHNGdJQ0FnZlZ4dUlDQWdJQzh2SUVGMElHeGxZWE4wSUdkcGRtVWdjMjl0WlNCcmFXNWtJRzltSUdOdmJuUmxlSFFnZEc4Z2RHaGxJSFZ6WlhKY2JpQWdJQ0IyWVhJZ1pYSnlJRDBnYm1WM0lFVnljbTl5S0NkVmJtaGhibVJzWldRZ1pYSnliM0l1SnlBcklDaGxjaUEvSUNjZ0tDY2dLeUJsY2k1dFpYTnpZV2RsSUNzZ0p5a25JRG9nSnljcEtUdGNiaUFnSUNCbGNuSXVZMjl1ZEdWNGRDQTlJR1Z5TzF4dUlDQWdJSFJvY205M0lHVnljanNnTHk4Z1ZXNW9ZVzVrYkdWa0lDZGxjbkp2Y2ljZ1pYWmxiblJjYmlBZ2ZWeHVYRzRnSUhaaGNpQm9ZVzVrYkdWeUlEMGdaWFpsYm5SelczUjVjR1ZkTzF4dVhHNGdJR2xtSUNob1lXNWtiR1Z5SUQwOVBTQjFibVJsWm1sdVpXUXBYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1WEc0Z0lHbG1JQ2gwZVhCbGIyWWdhR0Z1Wkd4bGNpQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUZKbFpteGxZM1JCY0hCc2VTaG9ZVzVrYkdWeUxDQjBhR2x6TENCaGNtZHpLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IyWVhJZ2JHVnVJRDBnYUdGdVpHeGxjaTVzWlc1bmRHZzdYRzRnSUNBZ2RtRnlJR3hwYzNSbGJtVnljeUE5SUdGeWNtRjVRMnh2Ym1Vb2FHRnVaR3hsY2l3Z2JHVnVLVHRjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR3hsYmpzZ0t5dHBLVnh1SUNBZ0lDQWdVbVZtYkdWamRFRndjR3g1S0d4cGMzUmxibVZ5YzF0cFhTd2dkR2hwY3l3Z1lYSm5jeWs3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZEhKMVpUdGNibjA3WEc1Y2JtWjFibU4wYVc5dUlGOWhaR1JNYVhOMFpXNWxjaWgwWVhKblpYUXNJSFI1Y0dVc0lHeHBjM1JsYm1WeUxDQndjbVZ3Wlc1a0tTQjdYRzRnSUhaaGNpQnRPMXh1SUNCMllYSWdaWFpsYm5Sek8xeHVJQ0IyWVhJZ1pYaHBjM1JwYm1jN1hHNWNiaUFnWTJobFkydE1hWE4wWlc1bGNpaHNhWE4wWlc1bGNpazdYRzVjYmlBZ1pYWmxiblJ6SUQwZ2RHRnlaMlYwTGw5bGRtVnVkSE03WEc0Z0lHbG1JQ2hsZG1WdWRITWdQVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUdWMlpXNTBjeUE5SUhSaGNtZGxkQzVmWlhabGJuUnpJRDBnVDJKcVpXTjBMbU55WldGMFpTaHVkV3hzS1R0Y2JpQWdJQ0IwWVhKblpYUXVYMlYyWlc1MGMwTnZkVzUwSUQwZ01EdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQXZMeUJVYnlCaGRtOXBaQ0J5WldOMWNuTnBiMjRnYVc0Z2RHaGxJR05oYzJVZ2RHaGhkQ0IwZVhCbElEMDlQU0JjSW01bGQweHBjM1JsYm1WeVhDSWhJRUpsWm05eVpWeHVJQ0FnSUM4dklHRmtaR2x1WnlCcGRDQjBieUIwYUdVZ2JHbHpkR1Z1WlhKekxDQm1hWEp6ZENCbGJXbDBJRndpYm1WM1RHbHpkR1Z1WlhKY0lpNWNiaUFnSUNCcFppQW9aWFpsYm5SekxtNWxkMHhwYzNSbGJtVnlJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNBZ0lIUmhjbWRsZEM1bGJXbDBLQ2R1WlhkTWFYTjBaVzVsY2ljc0lIUjVjR1VzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCc2FYTjBaVzVsY2k1c2FYTjBaVzVsY2lBL0lHeHBjM1JsYm1WeUxteHBjM1JsYm1WeUlEb2diR2x6ZEdWdVpYSXBPMXh1WEc0Z0lDQWdJQ0F2THlCU1pTMWhjM05wWjI0Z1lHVjJaVzUwYzJBZ1ltVmpZWFZ6WlNCaElHNWxkMHhwYzNSbGJtVnlJR2hoYm1Sc1pYSWdZMjkxYkdRZ2FHRjJaU0JqWVhWelpXUWdkR2hsWEc0Z0lDQWdJQ0F2THlCMGFHbHpMbDlsZG1WdWRITWdkRzhnWW1VZ1lYTnphV2R1WldRZ2RHOGdZU0J1WlhjZ2IySnFaV04wWEc0Z0lDQWdJQ0JsZG1WdWRITWdQU0IwWVhKblpYUXVYMlYyWlc1MGN6dGNiaUFnSUNCOVhHNGdJQ0FnWlhocGMzUnBibWNnUFNCbGRtVnVkSE5iZEhsd1pWMDdYRzRnSUgxY2JseHVJQ0JwWmlBb1pYaHBjM1JwYm1jZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJQzh2SUU5d2RHbHRhWHBsSUhSb1pTQmpZWE5sSUc5bUlHOXVaU0JzYVhOMFpXNWxjaTRnUkc5dUozUWdibVZsWkNCMGFHVWdaWGgwY21FZ1lYSnlZWGtnYjJKcVpXTjBMbHh1SUNBZ0lHVjRhWE4wYVc1bklEMGdaWFpsYm5SelczUjVjR1ZkSUQwZ2JHbHpkR1Z1WlhJN1hHNGdJQ0FnS3l0MFlYSm5aWFF1WDJWMlpXNTBjME52ZFc1ME8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHbG1JQ2gwZVhCbGIyWWdaWGhwYzNScGJtY2dQVDA5SUNkbWRXNWpkR2x2YmljcElIdGNiaUFnSUNBZ0lDOHZJRUZrWkdsdVp5QjBhR1VnYzJWamIyNWtJR1ZzWlcxbGJuUXNJRzVsWldRZ2RHOGdZMmhoYm1kbElIUnZJR0Z5Y21GNUxseHVJQ0FnSUNBZ1pYaHBjM1JwYm1jZ1BTQmxkbVZ1ZEhOYmRIbHdaVjBnUFZ4dUlDQWdJQ0FnSUNCd2NtVndaVzVrSUQ4Z1cyeHBjM1JsYm1WeUxDQmxlR2x6ZEdsdVoxMGdPaUJiWlhocGMzUnBibWNzSUd4cGMzUmxibVZ5WFR0Y2JpQWdJQ0FnSUM4dklFbG1JSGRsSjNabElHRnNjbVZoWkhrZ1oyOTBJR0Z1SUdGeWNtRjVMQ0JxZFhOMElHRndjR1Z1WkM1Y2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0hCeVpYQmxibVFwSUh0Y2JpQWdJQ0FnSUdWNGFYTjBhVzVuTG5WdWMyaHBablFvYkdsemRHVnVaWElwTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQmxlR2x6ZEdsdVp5NXdkWE5vS0d4cGMzUmxibVZ5S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCRGFHVmpheUJtYjNJZ2JHbHpkR1Z1WlhJZ2JHVmhhMXh1SUNBZ0lHMGdQU0JmWjJWMFRXRjRUR2x6ZEdWdVpYSnpLSFJoY21kbGRDazdYRzRnSUNBZ2FXWWdLRzBnUGlBd0lDWW1JR1Y0YVhOMGFXNW5MbXhsYm1kMGFDQStJRzBnSmlZZ0lXVjRhWE4wYVc1bkxuZGhjbTVsWkNrZ2UxeHVJQ0FnSUNBZ1pYaHBjM1JwYm1jdWQyRnlibVZrSUQwZ2RISjFaVHRjYmlBZ0lDQWdJQzh2SUU1dklHVnljbTl5SUdOdlpHVWdabTl5SUhSb2FYTWdjMmx1WTJVZ2FYUWdhWE1nWVNCWFlYSnVhVzVuWEc0Z0lDQWdJQ0F2THlCbGMyeHBiblF0WkdsellXSnNaUzF1WlhoMExXeHBibVVnYm04dGNtVnpkSEpwWTNSbFpDMXplVzUwWVhoY2JpQWdJQ0FnSUhaaGNpQjNJRDBnYm1WM0lFVnljbTl5S0NkUWIzTnphV0pzWlNCRmRtVnVkRVZ0YVhSMFpYSWdiV1Z0YjNKNUlHeGxZV3NnWkdWMFpXTjBaV1F1SUNjZ0sxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmxlR2x6ZEdsdVp5NXNaVzVuZEdnZ0t5QW5JQ2NnS3lCVGRISnBibWNvZEhsd1pTa2dLeUFuSUd4cGMzUmxibVZ5Y3lBbklDdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdKMkZrWkdWa0xpQlZjMlVnWlcxcGRIUmxjaTV6WlhSTllYaE1hWE4wWlc1bGNuTW9LU0IwYnlBbklDdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdKMmx1WTNKbFlYTmxJR3hwYldsMEp5azdYRzRnSUNBZ0lDQjNMbTVoYldVZ1BTQW5UV0Y0VEdsemRHVnVaWEp6UlhoalpXVmtaV1JYWVhKdWFXNW5KenRjYmlBZ0lDQWdJSGN1WlcxcGRIUmxjaUE5SUhSaGNtZGxkRHRjYmlBZ0lDQWdJSGN1ZEhsd1pTQTlJSFI1Y0dVN1hHNGdJQ0FnSUNCM0xtTnZkVzUwSUQwZ1pYaHBjM1JwYm1jdWJHVnVaM1JvTzF4dUlDQWdJQ0FnVUhKdlkyVnpjMFZ0YVhSWFlYSnVhVzVuS0hjcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCMFlYSm5aWFE3WEc1OVhHNWNia1YyWlc1MFJXMXBkSFJsY2k1d2NtOTBiM1I1Y0dVdVlXUmtUR2x6ZEdWdVpYSWdQU0JtZFc1amRHbHZiaUJoWkdSTWFYTjBaVzVsY2loMGVYQmxMQ0JzYVhOMFpXNWxjaWtnZTF4dUlDQnlaWFIxY200Z1gyRmtaRXhwYzNSbGJtVnlLSFJvYVhNc0lIUjVjR1VzSUd4cGMzUmxibVZ5TENCbVlXeHpaU2s3WEc1OU8xeHVYRzVGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExtOXVJRDBnUlhabGJuUkZiV2wwZEdWeUxuQnliM1J2ZEhsd1pTNWhaR1JNYVhOMFpXNWxjanRjYmx4dVJYWmxiblJGYldsMGRHVnlMbkJ5YjNSdmRIbHdaUzV3Y21Wd1pXNWtUR2x6ZEdWdVpYSWdQVnh1SUNBZ0lHWjFibU4wYVc5dUlIQnlaWEJsYm1STWFYTjBaVzVsY2loMGVYQmxMQ0JzYVhOMFpXNWxjaWtnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRjloWkdSTWFYTjBaVzVsY2loMGFHbHpMQ0IwZVhCbExDQnNhWE4wWlc1bGNpd2dkSEoxWlNrN1hHNGdJQ0FnZlR0Y2JseHVablZ1WTNScGIyNGdiMjVqWlZkeVlYQndaWElvS1NCN1hHNGdJR2xtSUNnaGRHaHBjeTVtYVhKbFpDa2dlMXh1SUNBZ0lIUm9hWE11ZEdGeVoyVjBMbkpsYlc5MlpVeHBjM1JsYm1WeUtIUm9hWE11ZEhsd1pTd2dkR2hwY3k1M2NtRndSbTRwTzF4dUlDQWdJSFJvYVhNdVptbHlaV1FnUFNCMGNuVmxPMXh1SUNBZ0lHbG1JQ2hoY21kMWJXVnVkSE11YkdWdVozUm9JRDA5UFNBd0tWeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXViR2x6ZEdWdVpYSXVZMkZzYkNoMGFHbHpMblJoY21kbGRDazdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXViR2x6ZEdWdVpYSXVZWEJ3Ykhrb2RHaHBjeTUwWVhKblpYUXNJR0Z5WjNWdFpXNTBjeWs3WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z1gyOXVZMlZYY21Gd0tIUmhjbWRsZEN3Z2RIbHdaU3dnYkdsemRHVnVaWElwSUh0Y2JpQWdkbUZ5SUhOMFlYUmxJRDBnZXlCbWFYSmxaRG9nWm1Gc2MyVXNJSGR5WVhCR2Jqb2dkVzVrWldacGJtVmtMQ0IwWVhKblpYUTZJSFJoY21kbGRDd2dkSGx3WlRvZ2RIbHdaU3dnYkdsemRHVnVaWEk2SUd4cGMzUmxibVZ5SUgwN1hHNGdJSFpoY2lCM2NtRndjR1ZrSUQwZ2IyNWpaVmR5WVhCd1pYSXVZbWx1WkNoemRHRjBaU2s3WEc0Z0lIZHlZWEJ3WldRdWJHbHpkR1Z1WlhJZ1BTQnNhWE4wWlc1bGNqdGNiaUFnYzNSaGRHVXVkM0poY0VadUlEMGdkM0poY0hCbFpEdGNiaUFnY21WMGRYSnVJSGR5WVhCd1pXUTdYRzU5WEc1Y2JrVjJaVzUwUlcxcGRIUmxjaTV3Y205MGIzUjVjR1V1YjI1alpTQTlJR1oxYm1OMGFXOXVJRzl1WTJVb2RIbHdaU3dnYkdsemRHVnVaWElwSUh0Y2JpQWdZMmhsWTJ0TWFYTjBaVzVsY2loc2FYTjBaVzVsY2lrN1hHNGdJSFJvYVhNdWIyNG9kSGx3WlN3Z1gyOXVZMlZYY21Gd0tIUm9hWE1zSUhSNWNHVXNJR3hwYzNSbGJtVnlLU2s3WEc0Z0lISmxkSFZ5YmlCMGFHbHpPMXh1ZlR0Y2JseHVSWFpsYm5SRmJXbDBkR1Z5TG5CeWIzUnZkSGx3WlM1d2NtVndaVzVrVDI1alpVeHBjM1JsYm1WeUlEMWNiaUFnSUNCbWRXNWpkR2x2YmlCd2NtVndaVzVrVDI1alpVeHBjM1JsYm1WeUtIUjVjR1VzSUd4cGMzUmxibVZ5S1NCN1hHNGdJQ0FnSUNCamFHVmphMHhwYzNSbGJtVnlLR3hwYzNSbGJtVnlLVHRjYmlBZ0lDQWdJSFJvYVhNdWNISmxjR1Z1WkV4cGMzUmxibVZ5S0hSNWNHVXNJRjl2Ym1ObFYzSmhjQ2gwYUdsekxDQjBlWEJsTENCc2FYTjBaVzVsY2lrcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUNBZ2ZUdGNibHh1THk4Z1JXMXBkSE1nWVNBbmNtVnRiM1psVEdsemRHVnVaWEluSUdWMlpXNTBJR2xtSUdGdVpDQnZibXg1SUdsbUlIUm9aU0JzYVhOMFpXNWxjaUIzWVhNZ2NtVnRiM1psWkM1Y2JrVjJaVzUwUlcxcGRIUmxjaTV3Y205MGIzUjVjR1V1Y21WdGIzWmxUR2x6ZEdWdVpYSWdQVnh1SUNBZ0lHWjFibU4wYVc5dUlISmxiVzkyWlV4cGMzUmxibVZ5S0hSNWNHVXNJR3hwYzNSbGJtVnlLU0I3WEc0Z0lDQWdJQ0IyWVhJZ2JHbHpkQ3dnWlhabGJuUnpMQ0J3YjNOcGRHbHZiaXdnYVN3Z2IzSnBaMmx1WVd4TWFYTjBaVzVsY2p0Y2JseHVJQ0FnSUNBZ1kyaGxZMnRNYVhOMFpXNWxjaWhzYVhOMFpXNWxjaWs3WEc1Y2JpQWdJQ0FnSUdWMlpXNTBjeUE5SUhSb2FYTXVYMlYyWlc1MGN6dGNiaUFnSUNBZ0lHbG1JQ2hsZG1WdWRITWdQVDA5SUhWdVpHVm1hVzVsWkNsY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzVjYmlBZ0lDQWdJR3hwYzNRZ1BTQmxkbVZ1ZEhOYmRIbHdaVjA3WEc0Z0lDQWdJQ0JwWmlBb2JHbHpkQ0E5UFQwZ2RXNWtaV1pwYm1Wa0tWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjenRjYmx4dUlDQWdJQ0FnYVdZZ0tHeHBjM1FnUFQwOUlHeHBjM1JsYm1WeUlIeDhJR3hwYzNRdWJHbHpkR1Z1WlhJZ1BUMDlJR3hwYzNSbGJtVnlLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ3RMWFJvYVhNdVgyVjJaVzUwYzBOdmRXNTBJRDA5UFNBd0tWeHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyVjJaVzUwY3lBOUlFOWlhbVZqZEM1amNtVmhkR1VvYm5Wc2JDazdYRzRnSUNBZ0lDQWdJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJR1JsYkdWMFpTQmxkbVZ1ZEhOYmRIbHdaVjA3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLR1YyWlc1MGN5NXlaVzF2ZG1WTWFYTjBaVzVsY2lsY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVpXMXBkQ2duY21WdGIzWmxUR2x6ZEdWdVpYSW5MQ0IwZVhCbExDQnNhWE4wTG14cGMzUmxibVZ5SUh4OElHeHBjM1JsYm1WeUtUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2gwZVhCbGIyWWdiR2x6ZENBaFBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJQ0FnSUNCd2IzTnBkR2x2YmlBOUlDMHhPMXh1WEc0Z0lDQWdJQ0FnSUdadmNpQW9hU0E5SUd4cGMzUXViR1Z1WjNSb0lDMGdNVHNnYVNBK1BTQXdPeUJwTFMwcElIdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2JHbHpkRnRwWFNBOVBUMGdiR2x6ZEdWdVpYSWdmSHdnYkdsemRGdHBYUzVzYVhOMFpXNWxjaUE5UFQwZ2JHbHpkR1Z1WlhJcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUc5eWFXZHBibUZzVEdsemRHVnVaWElnUFNCc2FYTjBXMmxkTG14cGMzUmxibVZ5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdjRzl6YVhScGIyNGdQU0JwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLSEJ2YzJsMGFXOXVJRHdnTUNsY2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2RHaHBjenRjYmx4dUlDQWdJQ0FnSUNCcFppQW9jRzl6YVhScGIyNGdQVDA5SURBcFhHNGdJQ0FnSUNBZ0lDQWdiR2x6ZEM1emFHbG1kQ2dwTzF4dUlDQWdJQ0FnSUNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNCemNHeHBZMlZQYm1Vb2JHbHpkQ3dnY0c5emFYUnBiMjRwTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdhV1lnS0d4cGMzUXViR1Z1WjNSb0lEMDlQU0F4S1Z4dUlDQWdJQ0FnSUNBZ0lHVjJaVzUwYzF0MGVYQmxYU0E5SUd4cGMzUmJNRjA3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLR1YyWlc1MGN5NXlaVzF2ZG1WTWFYTjBaVzVsY2lBaFBUMGdkVzVrWldacGJtVmtLVnh1SUNBZ0lDQWdJQ0FnSUhSb2FYTXVaVzFwZENnbmNtVnRiM1psVEdsemRHVnVaWEluTENCMGVYQmxMQ0J2Y21sbmFXNWhiRXhwYzNSbGJtVnlJSHg4SUd4cGMzUmxibVZ5S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUNBZ2ZUdGNibHh1UlhabGJuUkZiV2wwZEdWeUxuQnliM1J2ZEhsd1pTNXZabVlnUFNCRmRtVnVkRVZ0YVhSMFpYSXVjSEp2ZEc5MGVYQmxMbkpsYlc5MlpVeHBjM1JsYm1WeU8xeHVYRzVGZG1WdWRFVnRhWFIwWlhJdWNISnZkRzkwZVhCbExuSmxiVzkyWlVGc2JFeHBjM1JsYm1WeWN5QTlYRzRnSUNBZ1puVnVZM1JwYjI0Z2NtVnRiM1psUVd4c1RHbHpkR1Z1WlhKektIUjVjR1VwSUh0Y2JpQWdJQ0FnSUhaaGNpQnNhWE4wWlc1bGNuTXNJR1YyWlc1MGN5d2dhVHRjYmx4dUlDQWdJQ0FnWlhabGJuUnpJRDBnZEdocGN5NWZaWFpsYm5Sek8xeHVJQ0FnSUNBZ2FXWWdLR1YyWlc1MGN5QTlQVDBnZFc1a1pXWnBibVZrS1Z4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN6dGNibHh1SUNBZ0lDQWdMeThnYm05MElHeHBjM1JsYm1sdVp5Qm1iM0lnY21WdGIzWmxUR2x6ZEdWdVpYSXNJRzV2SUc1bFpXUWdkRzhnWlcxcGRGeHVJQ0FnSUNBZ2FXWWdLR1YyWlc1MGN5NXlaVzF2ZG1WTWFYTjBaVzVsY2lBOVBUMGdkVzVrWldacGJtVmtLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaGhjbWQxYldWdWRITXViR1Z1WjNSb0lEMDlQU0F3S1NCN1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZlpYWmxiblJ6SUQwZ1QySnFaV04wTG1OeVpXRjBaU2h1ZFd4c0tUdGNiaUFnSUNBZ0lDQWdJQ0IwYUdsekxsOWxkbVZ1ZEhORGIzVnVkQ0E5SURBN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9aWFpsYm5SelczUjVjR1ZkSUNFOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9MUzEwYUdsekxsOWxkbVZ1ZEhORGIzVnVkQ0E5UFQwZ01DbGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVYMlYyWlc1MGN5QTlJRTlpYW1WamRDNWpjbVZoZEdVb2JuVnNiQ2s3WEc0Z0lDQWdJQ0FnSUNBZ1pXeHpaVnh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVnNaWFJsSUdWMlpXNTBjMXQwZVhCbFhUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0x5OGdaVzFwZENCeVpXMXZkbVZNYVhOMFpXNWxjaUJtYjNJZ1lXeHNJR3hwYzNSbGJtVnljeUJ2YmlCaGJHd2daWFpsYm5SelhHNGdJQ0FnSUNCcFppQW9ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDQTlQVDBnTUNrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnYTJWNWN5QTlJRTlpYW1WamRDNXJaWGx6S0dWMlpXNTBjeWs3WEc0Z0lDQWdJQ0FnSUhaaGNpQnJaWGs3WEc0Z0lDQWdJQ0FnSUdadmNpQW9hU0E5SURBN0lHa2dQQ0JyWlhsekxteGxibWQwYURzZ0t5dHBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2EyVjVJRDBnYTJWNWMxdHBYVHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9hMlY1SUQwOVBTQW5jbVZ0YjNabFRHbHpkR1Z1WlhJbktTQmpiMjUwYVc1MVpUdGNiaUFnSUNBZ0lDQWdJQ0IwYUdsekxuSmxiVzkyWlVGc2JFeHBjM1JsYm1WeWN5aHJaWGtwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIUm9hWE11Y21WdGIzWmxRV3hzVEdsemRHVnVaWEp6S0NkeVpXMXZkbVZNYVhOMFpXNWxjaWNwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbDlsZG1WdWRITWdQU0JQWW1wbFkzUXVZM0psWVhSbEtHNTFiR3dwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbDlsZG1WdWRITkRiM1Z1ZENBOUlEQTdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCc2FYTjBaVzVsY25NZ1BTQmxkbVZ1ZEhOYmRIbHdaVjA3WEc1Y2JpQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ2JHbHpkR1Z1WlhKeklEMDlQU0FuWm5WdVkzUnBiMjRuS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y21WdGIzWmxUR2x6ZEdWdVpYSW9kSGx3WlN3Z2JHbHpkR1Z1WlhKektUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCcFppQW9iR2x6ZEdWdVpYSnpJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNBZ0lDQWdMeThnVEVsR1R5QnZjbVJsY2x4dUlDQWdJQ0FnSUNCbWIzSWdLR2tnUFNCc2FYTjBaVzVsY25NdWJHVnVaM1JvSUMwZ01Uc2dhU0ErUFNBd095QnBMUzBwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TG5KbGJXOTJaVXhwYzNSbGJtVnlLSFI1Y0dVc0lHeHBjM1JsYm1WeWMxdHBYU2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUNBZ2ZUdGNibHh1Wm5WdVkzUnBiMjRnWDJ4cGMzUmxibVZ5Y3loMFlYSm5aWFFzSUhSNWNHVXNJSFZ1ZDNKaGNDa2dlMXh1SUNCMllYSWdaWFpsYm5SeklEMGdkR0Z5WjJWMExsOWxkbVZ1ZEhNN1hHNWNiaUFnYVdZZ0tHVjJaVzUwY3lBOVBUMGdkVzVrWldacGJtVmtLVnh1SUNBZ0lISmxkSFZ5YmlCYlhUdGNibHh1SUNCMllYSWdaWFpzYVhOMFpXNWxjaUE5SUdWMlpXNTBjMXQwZVhCbFhUdGNiaUFnYVdZZ0tHVjJiR2x6ZEdWdVpYSWdQVDA5SUhWdVpHVm1hVzVsWkNsY2JpQWdJQ0J5WlhSMWNtNGdXMTA3WEc1Y2JpQWdhV1lnS0hSNWNHVnZaaUJsZG14cGMzUmxibVZ5SUQwOVBTQW5ablZ1WTNScGIyNG5LVnh1SUNBZ0lISmxkSFZ5YmlCMWJuZHlZWEFnUHlCYlpYWnNhWE4wWlc1bGNpNXNhWE4wWlc1bGNpQjhmQ0JsZG14cGMzUmxibVZ5WFNBNklGdGxkbXhwYzNSbGJtVnlYVHRjYmx4dUlDQnlaWFIxY200Z2RXNTNjbUZ3SUQ5Y2JpQWdJQ0IxYm5keVlYQk1hWE4wWlc1bGNuTW9aWFpzYVhOMFpXNWxjaWtnT2lCaGNuSmhlVU5zYjI1bEtHVjJiR2x6ZEdWdVpYSXNJR1YyYkdsemRHVnVaWEl1YkdWdVozUm9LVHRjYm4xY2JseHVSWFpsYm5SRmJXbDBkR1Z5TG5CeWIzUnZkSGx3WlM1c2FYTjBaVzVsY25NZ1BTQm1kVzVqZEdsdmJpQnNhWE4wWlc1bGNuTW9kSGx3WlNrZ2UxeHVJQ0J5WlhSMWNtNGdYMnhwYzNSbGJtVnljeWgwYUdsekxDQjBlWEJsTENCMGNuVmxLVHRjYm4wN1hHNWNia1YyWlc1MFJXMXBkSFJsY2k1d2NtOTBiM1I1Y0dVdWNtRjNUR2x6ZEdWdVpYSnpJRDBnWm5WdVkzUnBiMjRnY21GM1RHbHpkR1Z1WlhKektIUjVjR1VwSUh0Y2JpQWdjbVYwZFhKdUlGOXNhWE4wWlc1bGNuTW9kR2hwY3l3Z2RIbHdaU3dnWm1Gc2MyVXBPMXh1ZlR0Y2JseHVSWFpsYm5SRmJXbDBkR1Z5TG14cGMzUmxibVZ5UTI5MWJuUWdQU0JtZFc1amRHbHZiaWhsYldsMGRHVnlMQ0IwZVhCbEtTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ1pXMXBkSFJsY2k1c2FYTjBaVzVsY2tOdmRXNTBJRDA5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ2NtVjBkWEp1SUdWdGFYUjBaWEl1YkdsemRHVnVaWEpEYjNWdWRDaDBlWEJsS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCeVpYUjFjbTRnYkdsemRHVnVaWEpEYjNWdWRDNWpZV3hzS0dWdGFYUjBaWElzSUhSNWNHVXBPMXh1SUNCOVhHNTlPMXh1WEc1RmRtVnVkRVZ0YVhSMFpYSXVjSEp2ZEc5MGVYQmxMbXhwYzNSbGJtVnlRMjkxYm5RZ1BTQnNhWE4wWlc1bGNrTnZkVzUwTzF4dVpuVnVZM1JwYjI0Z2JHbHpkR1Z1WlhKRGIzVnVkQ2gwZVhCbEtTQjdYRzRnSUhaaGNpQmxkbVZ1ZEhNZ1BTQjBhR2x6TGw5bGRtVnVkSE03WEc1Y2JpQWdhV1lnS0dWMlpXNTBjeUFoUFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ2RtRnlJR1YyYkdsemRHVnVaWElnUFNCbGRtVnVkSE5iZEhsd1pWMDdYRzVjYmlBZ0lDQnBaaUFvZEhsd1pXOW1JR1YyYkdsemRHVnVaWElnUFQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQXhPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9aWFpzYVhOMFpXNWxjaUFoUFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1pYWnNhWE4wWlc1bGNpNXNaVzVuZEdnN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SURBN1hHNTlYRzVjYmtWMlpXNTBSVzFwZEhSbGNpNXdjbTkwYjNSNWNHVXVaWFpsYm5ST1lXMWxjeUE5SUdaMWJtTjBhVzl1SUdWMlpXNTBUbUZ0WlhNb0tTQjdYRzRnSUhKbGRIVnliaUIwYUdsekxsOWxkbVZ1ZEhORGIzVnVkQ0ErSURBZ1B5QlNaV1pzWldOMFQzZHVTMlY1Y3loMGFHbHpMbDlsZG1WdWRITXBJRG9nVzEwN1hHNTlPMXh1WEc1bWRXNWpkR2x2YmlCaGNuSmhlVU5zYjI1bEtHRnljaXdnYmlrZ2UxeHVJQ0IyWVhJZ1kyOXdlU0E5SUc1bGR5QkJjbkpoZVNodUtUdGNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCdU95QXJLMmtwWEc0Z0lDQWdZMjl3ZVZ0cFhTQTlJR0Z5Y2x0cFhUdGNiaUFnY21WMGRYSnVJR052Y0hrN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhOd2JHbGpaVTl1WlNoc2FYTjBMQ0JwYm1SbGVDa2dlMXh1SUNCbWIzSWdLRHNnYVc1a1pYZ2dLeUF4SUR3Z2JHbHpkQzVzWlc1bmRHZzdJR2x1WkdWNEt5c3BYRzRnSUNBZ2JHbHpkRnRwYm1SbGVGMGdQU0JzYVhOMFcybHVaR1Y0SUNzZ01WMDdYRzRnSUd4cGMzUXVjRzl3S0NrN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUhWdWQzSmhjRXhwYzNSbGJtVnljeWhoY25JcElIdGNiaUFnZG1GeUlISmxkQ0E5SUc1bGR5QkJjbkpoZVNoaGNuSXViR1Z1WjNSb0tUdGNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCeVpYUXViR1Z1WjNSb095QXJLMmtwSUh0Y2JpQWdJQ0J5WlhSYmFWMGdQU0JoY25KYmFWMHViR2x6ZEdWdVpYSWdmSHdnWVhKeVcybGRPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQnlaWFE3WEc1OVhHNWNibVoxYm1OMGFXOXVJRzl1WTJVb1pXMXBkSFJsY2l3Z2JtRnRaU2tnZTF4dUlDQnlaWFIxY200Z2JtVjNJRkJ5YjIxcGMyVW9ablZ1WTNScGIyNGdLSEpsYzI5c2RtVXNJSEpsYW1WamRDa2dlMXh1SUNBZ0lHWjFibU4wYVc5dUlHVnljbTl5VEdsemRHVnVaWElvWlhKeUtTQjdYRzRnSUNBZ0lDQmxiV2wwZEdWeUxuSmxiVzkyWlV4cGMzUmxibVZ5S0c1aGJXVXNJSEpsYzI5c2RtVnlLVHRjYmlBZ0lDQWdJSEpsYW1WamRDaGxjbklwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR1oxYm1OMGFXOXVJSEpsYzI5c2RtVnlLQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tIUjVjR1Z2WmlCbGJXbDBkR1Z5TG5KbGJXOTJaVXhwYzNSbGJtVnlJRDA5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ0lDQWdJR1Z0YVhSMFpYSXVjbVZ0YjNabFRHbHpkR1Z1WlhJb0oyVnljbTl5Snl3Z1pYSnliM0pNYVhOMFpXNWxjaWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhOdmJIWmxLRnRkTG5Oc2FXTmxMbU5oYkd3b1lYSm5kVzFsYm5SektTazdYRzRnSUNBZ2ZUdGNibHh1SUNBZ0lHVjJaVzUwVkdGeVoyVjBRV2R1YjNOMGFXTkJaR1JNYVhOMFpXNWxjaWhsYldsMGRHVnlMQ0J1WVcxbExDQnlaWE52YkhabGNpd2dleUJ2Ym1ObE9pQjBjblZsSUgwcE8xeHVJQ0FnSUdsbUlDaHVZVzFsSUNFOVBTQW5aWEp5YjNJbktTQjdYRzRnSUNBZ0lDQmhaR1JGY25KdmNraGhibVJzWlhKSlprVjJaVzUwUlcxcGRIUmxjaWhsYldsMGRHVnlMQ0JsY25KdmNreHBjM1JsYm1WeUxDQjdJRzl1WTJVNklIUnlkV1VnZlNrN1hHNGdJQ0FnZlZ4dUlDQjlLVHRjYm4xY2JseHVablZ1WTNScGIyNGdZV1JrUlhKeWIzSklZVzVrYkdWeVNXWkZkbVZ1ZEVWdGFYUjBaWElvWlcxcGRIUmxjaXdnYUdGdVpHeGxjaXdnWm14aFozTXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQmxiV2wwZEdWeUxtOXVJRDA5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ1pYWmxiblJVWVhKblpYUkJaMjV2YzNScFkwRmtaRXhwYzNSbGJtVnlLR1Z0YVhSMFpYSXNJQ2RsY25KdmNpY3NJR2hoYm1Sc1pYSXNJR1pzWVdkektUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJsZG1WdWRGUmhjbWRsZEVGbmJtOXpkR2xqUVdSa1RHbHpkR1Z1WlhJb1pXMXBkSFJsY2l3Z2JtRnRaU3dnYkdsemRHVnVaWElzSUdac1lXZHpLU0I3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdaVzFwZEhSbGNpNXZiaUE5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lHbG1JQ2htYkdGbmN5NXZibU5sS1NCN1hHNGdJQ0FnSUNCbGJXbDBkR1Z5TG05dVkyVW9ibUZ0WlN3Z2JHbHpkR1Z1WlhJcE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0JsYldsMGRHVnlMbTl1S0c1aGJXVXNJR3hwYzNSbGJtVnlLVHRjYmlBZ0lDQjlYRzRnSUgwZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUdWdGFYUjBaWEl1WVdSa1JYWmxiblJNYVhOMFpXNWxjaUE5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lDOHZJRVYyWlc1MFZHRnlaMlYwSUdSdlpYTWdibTkwSUdoaGRtVWdZR1Z5Y205eVlDQmxkbVZ1ZENCelpXMWhiblJwWTNNZ2JHbHJaU0JPYjJSbFhHNGdJQ0FnTHk4Z1JYWmxiblJGYldsMGRHVnljeXdnZDJVZ1pHOGdibTkwSUd4cGMzUmxiaUJtYjNJZ1lHVnljbTl5WUNCbGRtVnVkSE1nYUdWeVpTNWNiaUFnSUNCbGJXbDBkR1Z5TG1Ga1pFVjJaVzUwVEdsemRHVnVaWElvYm1GdFpTd2dablZ1WTNScGIyNGdkM0poY0V4cGMzUmxibVZ5S0dGeVp5a2dlMXh1SUNBZ0lDQWdMeThnU1VVZ1pHOWxjeUJ1YjNRZ2FHRjJaU0JpZFdsc2RHbHVJR0I3SUc5dVkyVTZJSFJ5ZFdVZ2ZXQWdjM1Z3Y0c5eWRDQnpieUIzWlZ4dUlDQWdJQ0FnTHk4Z2FHRjJaU0IwYnlCa2J5QnBkQ0J0WVc1MVlXeHNlUzVjYmlBZ0lDQWdJR2xtSUNobWJHRm5jeTV2Ym1ObEtTQjdYRzRnSUNBZ0lDQWdJR1Z0YVhSMFpYSXVjbVZ0YjNabFJYWmxiblJNYVhOMFpXNWxjaWh1WVcxbExDQjNjbUZ3VEdsemRHVnVaWElwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnYkdsemRHVnVaWElvWVhKbktUdGNiaUFnSUNCOUtUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLQ2RVYUdVZ1hDSmxiV2wwZEdWeVhDSWdZWEpuZFcxbGJuUWdiWFZ6ZENCaVpTQnZaaUIwZVhCbElFVjJaVzUwUlcxcGRIUmxjaTRnVW1WalpXbDJaV1FnZEhsd1pTQW5JQ3NnZEhsd1pXOW1JR1Z0YVhSMFpYSXBPMXh1SUNCOVhHNTlYRzRpTENKY2JuWmhjaUJvWVhOUGQyNGdQU0JQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMbWhoYzA5M2JsQnliM0JsY25SNU8xeHVkbUZ5SUhSdlUzUnlhVzVuSUQwZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1Wnp0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQm1iM0pGWVdOb0lDaHZZbW9zSUdadUxDQmpkSGdwSUh0Y2JpQWdJQ0JwWmlBb2RHOVRkSEpwYm1jdVkyRnNiQ2htYmlrZ0lUMDlJQ2RiYjJKcVpXTjBJRVoxYm1OMGFXOXVYU2NwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25hWFJsY21GMGIzSWdiWFZ6ZENCaVpTQmhJR1oxYm1OMGFXOXVKeWs3WEc0Z0lDQWdmVnh1SUNBZ0lIWmhjaUJzSUQwZ2IySnFMbXhsYm1kMGFEdGNiaUFnSUNCcFppQW9iQ0E5UFQwZ0syd3BJSHRjYmlBZ0lDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCc095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR1p1TG1OaGJHd29ZM1I0TENCdlltcGJhVjBzSUdrc0lHOWlhaWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJySUdsdUlHOWlhaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0doaGMwOTNiaTVqWVd4c0tHOWlhaXdnYXlrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQm1iaTVqWVd4c0tHTjBlQ3dnYjJKcVcydGRMQ0JyTENCdlltb3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVmVHRjYmx4dUlpd2lMeW9nWlhOc2FXNTBMV1Z1ZGlCaWNtOTNjMlZ5SUNvdlhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlIUjVjR1Z2WmlCelpXeG1JRDA5SUNkdlltcGxZM1FuSUQ4Z2MyVnNaaTVHYjNKdFJHRjBZU0E2SUhkcGJtUnZkeTVHYjNKdFJHRjBZVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dUx5b2daWE5zYVc1MElHNXZMV2x1ZG1Gc2FXUXRkR2hwY3pvZ01TQXFMMXh1WEc1MllYSWdSVkpTVDFKZlRVVlRVMEZIUlNBOUlDZEdkVzVqZEdsdmJpNXdjbTkwYjNSNWNHVXVZbWx1WkNCallXeHNaV1FnYjI0Z2FXNWpiMjF3WVhScFlteGxJQ2M3WEc1MllYSWdjMnhwWTJVZ1BTQkJjbkpoZVM1d2NtOTBiM1I1Y0dVdWMyeHBZMlU3WEc1MllYSWdkRzlUZEhJZ1BTQlBZbXBsWTNRdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bk8xeHVkbUZ5SUdaMWJtTlVlWEJsSUQwZ0oxdHZZbXBsWTNRZ1JuVnVZM1JwYjI1ZEp6dGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaUJpYVc1a0tIUm9ZWFFwSUh0Y2JpQWdJQ0IyWVhJZ2RHRnlaMlYwSUQwZ2RHaHBjenRjYmlBZ0lDQnBaaUFvZEhsd1pXOW1JSFJoY21kbGRDQWhQVDBnSjJaMWJtTjBhVzl1SnlCOGZDQjBiMU4wY2k1allXeHNLSFJoY21kbGRDa2dJVDA5SUdaMWJtTlVlWEJsS1NCN1hHNGdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9SVkpTVDFKZlRVVlRVMEZIUlNBcklIUmhjbWRsZENrN1hHNGdJQ0FnZlZ4dUlDQWdJSFpoY2lCaGNtZHpJRDBnYzJ4cFkyVXVZMkZzYkNoaGNtZDFiV1Z1ZEhNc0lERXBPMXh1WEc0Z0lDQWdkbUZ5SUdKdmRXNWtPMXh1SUNBZ0lIWmhjaUJpYVc1a1pYSWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwYUdseklHbHVjM1JoYm1ObGIyWWdZbTkxYm1RcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhaaGNpQnlaWE4xYkhRZ1BTQjBZWEpuWlhRdVlYQndiSGtvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5eGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmhjbWR6TG1OdmJtTmhkQ2h6YkdsalpTNWpZV3hzS0dGeVozVnRaVzUwY3lrcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0U5aWFtVmpkQ2h5WlhOMWJIUXBJRDA5UFNCeVpYTjFiSFFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnY21WemRXeDBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR0Z5WjJWMExtRndjR3g1S0Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb1lYUXNYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZWEpuY3k1amIyNWpZWFFvYzJ4cFkyVXVZMkZzYkNoaGNtZDFiV1Z1ZEhNcEtWeHVJQ0FnSUNBZ0lDQWdJQ0FnS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUgwN1hHNWNiaUFnSUNCMllYSWdZbTkxYm1STVpXNW5kR2dnUFNCTllYUm9MbTFoZUNnd0xDQjBZWEpuWlhRdWJHVnVaM1JvSUMwZ1lYSm5jeTVzWlc1bmRHZ3BPMXh1SUNBZ0lIWmhjaUJpYjNWdVpFRnlaM01nUFNCYlhUdGNiaUFnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHSnZkVzVrVEdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lDQWdZbTkxYm1SQmNtZHpMbkIxYzJnb0p5UW5JQ3NnYVNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWW05MWJtUWdQU0JHZFc1amRHbHZiaWduWW1sdVpHVnlKeXdnSjNKbGRIVnliaUJtZFc1amRHbHZiaUFvSnlBcklHSnZkVzVrUVhKbmN5NXFiMmx1S0Njc0p5a2dLeUFuS1hzZ2NtVjBkWEp1SUdKcGJtUmxjaTVoY0hCc2VTaDBhR2x6TEdGeVozVnRaVzUwY3lrN0lIMG5LU2hpYVc1a1pYSXBPMXh1WEc0Z0lDQWdhV1lnS0hSaGNtZGxkQzV3Y205MGIzUjVjR1VwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJRVZ0Y0hSNUlEMGdablZ1WTNScGIyNGdSVzF3ZEhrb0tTQjdmVHRjYmlBZ0lDQWdJQ0FnUlcxd2RIa3VjSEp2ZEc5MGVYQmxJRDBnZEdGeVoyVjBMbkJ5YjNSdmRIbHdaVHRjYmlBZ0lDQWdJQ0FnWW05MWJtUXVjSEp2ZEc5MGVYQmxJRDBnYm1WM0lFVnRjSFI1S0NrN1hHNGdJQ0FnSUNBZ0lFVnRjSFI1TG5CeWIzUnZkSGx3WlNBOUlHNTFiR3c3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlHSnZkVzVrTzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1ZG1GeUlHbHRjR3hsYldWdWRHRjBhVzl1SUQwZ2NtVnhkV2x5WlNnbkxpOXBiWEJzWlcxbGJuUmhkR2x2YmljcE8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJRVoxYm1OMGFXOXVMbkJ5YjNSdmRIbHdaUzVpYVc1a0lIeDhJR2x0Y0d4bGJXVnVkR0YwYVc5dU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ2RXNWtaV1pwYm1Wa08xeHVYRzUyWVhJZ0pGTjViblJoZUVWeWNtOXlJRDBnVTNsdWRHRjRSWEp5YjNJN1hHNTJZWElnSkVaMWJtTjBhVzl1SUQwZ1JuVnVZM1JwYjI0N1hHNTJZWElnSkZSNWNHVkZjbkp2Y2lBOUlGUjVjR1ZGY25KdmNqdGNibHh1THk4Z1pYTnNhVzUwTFdScGMyRmliR1V0Ym1WNGRDMXNhVzVsSUdOdmJuTnBjM1JsYm5RdGNtVjBkWEp1WEc1MllYSWdaMlYwUlhaaGJHeGxaRU52Ym5OMGNuVmpkRzl5SUQwZ1puVnVZM1JwYjI0Z0tHVjRjSEpsYzNOcGIyNVRlVzUwWVhncElIdGNibHgwZEhKNUlIdGNibHgwWEhSeVpYUjFjbTRnSkVaMWJtTjBhVzl1S0NkY0luVnpaU0J6ZEhKcFkzUmNJanNnY21WMGRYSnVJQ2duSUNzZ1pYaHdjbVZ6YzJsdmJsTjViblJoZUNBcklDY3BMbU52Ym5OMGNuVmpkRzl5T3ljcEtDazdYRzVjZEgwZ1kyRjBZMmdnS0dVcElIdDlYRzU5TzF4dVhHNTJZWElnSkdkUFVFUWdQU0JQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eU8xeHVhV1lnS0NSblQxQkVLU0I3WEc1Y2RIUnllU0I3WEc1Y2RGeDBKR2RQVUVRb2UzMHNJQ2NuS1R0Y2JseDBmU0JqWVhSamFDQW9aU2tnZTF4dVhIUmNkQ1JuVDFCRUlEMGdiblZzYkRzZ0x5OGdkR2hwY3lCcGN5QkpSU0E0TENCM2FHbGphQ0JvWVhNZ1lTQmljbTlyWlc0Z1owOVFSRnh1WEhSOVhHNTlYRzVjYm5aaGNpQjBhSEp2ZDFSNWNHVkZjbkp2Y2lBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmx4MGRHaHliM2NnYm1WM0lDUlVlWEJsUlhKeWIzSW9LVHRjYm4wN1hHNTJZWElnVkdoeWIzZFVlWEJsUlhKeWIzSWdQU0FrWjA5UVJGeHVYSFEvSUNobWRXNWpkR2x2YmlBb0tTQjdYRzVjZEZ4MGRISjVJSHRjYmx4MFhIUmNkQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMVzVsZUhRdGJHbHVaU0J1YnkxMWJuVnpaV1F0Wlhod2NtVnpjMmx2Ym5Nc0lHNXZMV05oYkd4bGNpd2dibTh0Y21WemRISnBZM1JsWkMxd2NtOXdaWEowYVdWelhHNWNkRngwWEhSaGNtZDFiV1Z1ZEhNdVkyRnNiR1ZsT3lBdkx5QkpSU0E0SUdSdlpYTWdibTkwSUhSb2NtOTNJR2hsY21WY2JseDBYSFJjZEhKbGRIVnliaUIwYUhKdmQxUjVjR1ZGY25KdmNqdGNibHgwWEhSOUlHTmhkR05vSUNoallXeHNaV1ZVYUhKdmQzTXBJSHRjYmx4MFhIUmNkSFJ5ZVNCN1hHNWNkRngwWEhSY2RDOHZJRWxGSURnZ2RHaHliM2R6SUc5dUlFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVVJsYzJOeWFYQjBiM0lvWVhKbmRXMWxiblJ6TENBbkp5bGNibHgwWEhSY2RGeDBjbVYwZFhKdUlDUm5UMUJFS0dGeVozVnRaVzUwY3l3Z0oyTmhiR3hsWlNjcExtZGxkRHRjYmx4MFhIUmNkSDBnWTJGMFkyZ2dLR2RQVUVSMGFISnZkM01wSUh0Y2JseDBYSFJjZEZ4MGNtVjBkWEp1SUhSb2NtOTNWSGx3WlVWeWNtOXlPMXh1WEhSY2RGeDBmVnh1WEhSY2RIMWNibHgwZlNncEtWeHVYSFE2SUhSb2NtOTNWSGx3WlVWeWNtOXlPMXh1WEc1MllYSWdhR0Z6VTNsdFltOXNjeUE5SUhKbGNYVnBjbVVvSjJoaGN5MXplVzFpYjJ4ekp5a29LVHRjYmx4dWRtRnlJR2RsZEZCeWIzUnZJRDBnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bUlIeDhJR1oxYm1OMGFXOXVJQ2g0S1NCN0lISmxkSFZ5YmlCNExsOWZjSEp2ZEc5Zlh6c2dmVHNnTHk4Z1pYTnNhVzUwTFdScGMyRmliR1V0YkdsdVpTQnVieTF3Y205MGIxeHVYRzUyWVhJZ2JtVmxaSE5GZG1Gc0lEMGdlMzA3WEc1Y2JuWmhjaUJVZVhCbFpFRnljbUY1SUQwZ2RIbHdaVzltSUZWcGJuUTRRWEp5WVhrZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2daMlYwVUhKdmRHOG9WV2x1ZERoQmNuSmhlU2s3WEc1Y2JuWmhjaUJKVGxSU1NVNVRTVU5USUQwZ2UxeHVYSFFuSlVGblozSmxaMkYwWlVWeWNtOXlKU2M2SUhSNWNHVnZaaUJCWjJkeVpXZGhkR1ZGY25KdmNpQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QjFibVJsWm1sdVpXUWdPaUJCWjJkeVpXZGhkR1ZGY25KdmNpeGNibHgwSnlWQmNuSmhlU1VuT2lCQmNuSmhlU3hjYmx4MEp5VkJjbkpoZVVKMVptWmxjaVVuT2lCMGVYQmxiMllnUVhKeVlYbENkV1ptWlhJZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2dRWEp5WVhsQ2RXWm1aWElzWEc1Y2RDY2xRWEp5WVhsSmRHVnlZWFJ2Y2xCeWIzUnZkSGx3WlNVbk9pQm9ZWE5UZVcxaWIyeHpJRDhnWjJWMFVISnZkRzhvVzExYlUzbHRZbTlzTG1sMFpYSmhkRzl5WFNncEtTQTZJSFZ1WkdWbWFXNWxaQ3hjYmx4MEp5VkJjM2x1WTBaeWIyMVRlVzVqU1hSbGNtRjBiM0pRY205MGIzUjVjR1VsSnpvZ2RXNWtaV1pwYm1Wa0xGeHVYSFFuSlVGemVXNWpSblZ1WTNScGIyNGxKem9nYm1WbFpITkZkbUZzTEZ4dVhIUW5KVUZ6ZVc1alIyVnVaWEpoZEc5eUpTYzZJRzVsWldSelJYWmhiQ3hjYmx4MEp5VkJjM2x1WTBkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1SlNjNklHNWxaV1J6UlhaaGJDeGNibHgwSnlWQmMzbHVZMGwwWlhKaGRHOXlVSEp2ZEc5MGVYQmxKU2M2SUc1bFpXUnpSWFpoYkN4Y2JseDBKeVZCZEc5dGFXTnpKU2M2SUhSNWNHVnZaaUJCZEc5dGFXTnpJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSFZ1WkdWbWFXNWxaQ0E2SUVGMGIyMXBZM01zWEc1Y2RDY2xRbWxuU1c1MEpTYzZJSFI1Y0dWdlppQkNhV2RKYm5RZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2dRbWxuU1c1MExGeHVYSFFuSlVKdmIyeGxZVzRsSnpvZ1FtOXZiR1ZoYml4Y2JseDBKeVZFWVhSaFZtbGxkeVVuT2lCMGVYQmxiMllnUkdGMFlWWnBaWGNnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1JHRjBZVlpwWlhjc1hHNWNkQ2NsUkdGMFpTVW5PaUJFWVhSbExGeHVYSFFuSldSbFkyOWtaVlZTU1NVbk9pQmtaV052WkdWVlVra3NYRzVjZENjbFpHVmpiMlJsVlZKSlEyOXRjRzl1Wlc1MEpTYzZJR1JsWTI5a1pWVlNTVU52YlhCdmJtVnVkQ3hjYmx4MEp5VmxibU52WkdWVlVra2xKem9nWlc1amIyUmxWVkpKTEZ4dVhIUW5KV1Z1WTI5a1pWVlNTVU52YlhCdmJtVnVkQ1VuT2lCbGJtTnZaR1ZWVWtsRGIyMXdiMjVsYm5Rc1hHNWNkQ2NsUlhKeWIzSWxKem9nUlhKeWIzSXNYRzVjZENjbFpYWmhiQ1VuT2lCbGRtRnNMQ0F2THlCbGMyeHBiblF0WkdsellXSnNaUzFzYVc1bElHNXZMV1YyWVd4Y2JseDBKeVZGZG1Gc1JYSnliM0lsSnpvZ1JYWmhiRVZ5Y205eUxGeHVYSFFuSlVac2IyRjBNekpCY25KaGVTVW5PaUIwZVhCbGIyWWdSbXh2WVhRek1rRnljbUY1SUQwOVBTQW5kVzVrWldacGJtVmtKeUEvSUhWdVpHVm1hVzVsWkNBNklFWnNiMkYwTXpKQmNuSmhlU3hjYmx4MEp5VkdiRzloZERZMFFYSnlZWGtsSnpvZ2RIbHdaVzltSUVac2IyRjBOalJCY25KaGVTQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QjFibVJsWm1sdVpXUWdPaUJHYkc5aGREWTBRWEp5WVhrc1hHNWNkQ2NsUm1sdVlXeHBlbUYwYVc5dVVtVm5hWE4wY25rbEp6b2dkSGx3Wlc5bUlFWnBibUZzYVhwaGRHbHZibEpsWjJsemRISjVJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSFZ1WkdWbWFXNWxaQ0E2SUVacGJtRnNhWHBoZEdsdmJsSmxaMmx6ZEhKNUxGeHVYSFFuSlVaMWJtTjBhVzl1SlNjNklDUkdkVzVqZEdsdmJpeGNibHgwSnlWSFpXNWxjbUYwYjNKR2RXNWpkR2x2YmlVbk9pQnVaV1ZrYzBWMllXd3NYRzVjZENjbFNXNTBPRUZ5Y21GNUpTYzZJSFI1Y0dWdlppQkpiblE0UVhKeVlYa2dQVDA5SUNkMWJtUmxabWx1WldRbklEOGdkVzVrWldacGJtVmtJRG9nU1c1ME9FRnljbUY1TEZ4dVhIUW5KVWx1ZERFMlFYSnlZWGtsSnpvZ2RIbHdaVzltSUVsdWRERTJRWEp5WVhrZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2dTVzUwTVRaQmNuSmhlU3hjYmx4MEp5VkpiblF6TWtGeWNtRjVKU2M2SUhSNWNHVnZaaUJKYm5Rek1rRnljbUY1SUQwOVBTQW5kVzVrWldacGJtVmtKeUEvSUhWdVpHVm1hVzVsWkNBNklFbHVkRE15UVhKeVlYa3NYRzVjZENjbGFYTkdhVzVwZEdVbEp6b2dhWE5HYVc1cGRHVXNYRzVjZENjbGFYTk9ZVTRsSnpvZ2FYTk9ZVTRzWEc1Y2RDY2xTWFJsY21GMGIzSlFjbTkwYjNSNWNHVWxKem9nYUdGelUzbHRZbTlzY3lBL0lHZGxkRkJ5YjNSdktHZGxkRkJ5YjNSdktGdGRXMU41YldKdmJDNXBkR1Z5WVhSdmNsMG9LU2twSURvZ2RXNWtaV1pwYm1Wa0xGeHVYSFFuSlVwVFQwNGxKem9nZEhsd1pXOW1JRXBUVDA0Z1BUMDlJQ2R2WW1wbFkzUW5JRDhnU2xOUFRpQTZJSFZ1WkdWbWFXNWxaQ3hjYmx4MEp5Vk5ZWEFsSnpvZ2RIbHdaVzltSUUxaGNDQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QjFibVJsWm1sdVpXUWdPaUJOWVhBc1hHNWNkQ2NsVFdGd1NYUmxjbUYwYjNKUWNtOTBiM1I1Y0dVbEp6b2dkSGx3Wlc5bUlFMWhjQ0E5UFQwZ0ozVnVaR1ZtYVc1bFpDY2dmSHdnSVdoaGMxTjViV0p2YkhNZ1B5QjFibVJsWm1sdVpXUWdPaUJuWlhSUWNtOTBieWh1WlhjZ1RXRndLQ2xiVTNsdFltOXNMbWwwWlhKaGRHOXlYU2dwS1N4Y2JseDBKeVZOWVhSb0pTYzZJRTFoZEdnc1hHNWNkQ2NsVG5WdFltVnlKU2M2SUU1MWJXSmxjaXhjYmx4MEp5VlBZbXBsWTNRbEp6b2dUMkpxWldOMExGeHVYSFFuSlhCaGNuTmxSbXh2WVhRbEp6b2djR0Z5YzJWR2JHOWhkQ3hjYmx4MEp5VndZWEp6WlVsdWRDVW5PaUJ3WVhKelpVbHVkQ3hjYmx4MEp5VlFjbTl0YVhObEpTYzZJSFI1Y0dWdlppQlFjbTl0YVhObElEMDlQU0FuZFc1a1pXWnBibVZrSnlBL0lIVnVaR1ZtYVc1bFpDQTZJRkJ5YjIxcGMyVXNYRzVjZENjbFVISnZlSGtsSnpvZ2RIbHdaVzltSUZCeWIzaDVJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSFZ1WkdWbWFXNWxaQ0E2SUZCeWIzaDVMRnh1WEhRbkpWSmhibWRsUlhKeWIzSWxKem9nVW1GdVoyVkZjbkp2Y2l4Y2JseDBKeVZTWldabGNtVnVZMlZGY25KdmNpVW5PaUJTWldabGNtVnVZMlZGY25KdmNpeGNibHgwSnlWU1pXWnNaV04wSlNjNklIUjVjR1Z2WmlCU1pXWnNaV04wSUQwOVBTQW5kVzVrWldacGJtVmtKeUEvSUhWdVpHVm1hVzVsWkNBNklGSmxabXhsWTNRc1hHNWNkQ2NsVW1WblJYaHdKU2M2SUZKbFowVjRjQ3hjYmx4MEp5VlRaWFFsSnpvZ2RIbHdaVzltSUZObGRDQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QjFibVJsWm1sdVpXUWdPaUJUWlhRc1hHNWNkQ2NsVTJWMFNYUmxjbUYwYjNKUWNtOTBiM1I1Y0dVbEp6b2dkSGx3Wlc5bUlGTmxkQ0E5UFQwZ0ozVnVaR1ZtYVc1bFpDY2dmSHdnSVdoaGMxTjViV0p2YkhNZ1B5QjFibVJsWm1sdVpXUWdPaUJuWlhSUWNtOTBieWh1WlhjZ1UyVjBLQ2xiVTNsdFltOXNMbWwwWlhKaGRHOXlYU2dwS1N4Y2JseDBKeVZUYUdGeVpXUkJjbkpoZVVKMVptWmxjaVVuT2lCMGVYQmxiMllnVTJoaGNtVmtRWEp5WVhsQ2RXWm1aWElnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrSURvZ1UyaGhjbVZrUVhKeVlYbENkV1ptWlhJc1hHNWNkQ2NsVTNSeWFXNW5KU2M2SUZOMGNtbHVaeXhjYmx4MEp5VlRkSEpwYm1kSmRHVnlZWFJ2Y2xCeWIzUnZkSGx3WlNVbk9pQm9ZWE5UZVcxaWIyeHpJRDhnWjJWMFVISnZkRzhvSnlkYlUzbHRZbTlzTG1sMFpYSmhkRzl5WFNncEtTQTZJSFZ1WkdWbWFXNWxaQ3hjYmx4MEp5VlRlVzFpYjJ3bEp6b2dhR0Z6VTNsdFltOXNjeUEvSUZONWJXSnZiQ0E2SUhWdVpHVm1hVzVsWkN4Y2JseDBKeVZUZVc1MFlYaEZjbkp2Y2lVbk9pQWtVM2x1ZEdGNFJYSnliM0lzWEc1Y2RDY2xWR2h5YjNkVWVYQmxSWEp5YjNJbEp6b2dWR2h5YjNkVWVYQmxSWEp5YjNJc1hHNWNkQ2NsVkhsd1pXUkJjbkpoZVNVbk9pQlVlWEJsWkVGeWNtRjVMRnh1WEhRbkpWUjVjR1ZGY25KdmNpVW5PaUFrVkhsd1pVVnljbTl5TEZ4dVhIUW5KVlZwYm5RNFFYSnlZWGtsSnpvZ2RIbHdaVzltSUZWcGJuUTRRWEp5WVhrZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2dWV2x1ZERoQmNuSmhlU3hjYmx4MEp5VlZhVzUwT0VOc1lXMXdaV1JCY25KaGVTVW5PaUIwZVhCbGIyWWdWV2x1ZERoRGJHRnRjR1ZrUVhKeVlYa2dQVDA5SUNkMWJtUmxabWx1WldRbklEOGdkVzVrWldacGJtVmtJRG9nVldsdWREaERiR0Z0Y0dWa1FYSnlZWGtzWEc1Y2RDY2xWV2x1ZERFMlFYSnlZWGtsSnpvZ2RIbHdaVzltSUZWcGJuUXhOa0Z5Y21GNUlEMDlQU0FuZFc1a1pXWnBibVZrSnlBL0lIVnVaR1ZtYVc1bFpDQTZJRlZwYm5ReE5rRnljbUY1TEZ4dVhIUW5KVlZwYm5Rek1rRnljbUY1SlNjNklIUjVjR1Z2WmlCVmFXNTBNekpCY25KaGVTQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QjFibVJsWm1sdVpXUWdPaUJWYVc1ME16SkJjbkpoZVN4Y2JseDBKeVZWVWtsRmNuSnZjaVVuT2lCVlVrbEZjbkp2Y2l4Y2JseDBKeVZYWldGclRXRndKU2M2SUhSNWNHVnZaaUJYWldGclRXRndJRDA5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSFZ1WkdWbWFXNWxaQ0E2SUZkbFlXdE5ZWEFzWEc1Y2RDY2xWMlZoYTFKbFppVW5PaUIwZVhCbGIyWWdWMlZoYTFKbFppQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QjFibVJsWm1sdVpXUWdPaUJYWldGclVtVm1MRnh1WEhRbkpWZGxZV3RUWlhRbEp6b2dkSGx3Wlc5bUlGZGxZV3RUWlhRZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2RXNWtaV1pwYm1Wa0lEb2dWMlZoYTFObGRGeHVmVHRjYmx4dWRtRnlJR1J2UlhaaGJDQTlJR1oxYm1OMGFXOXVJR1J2UlhaaGJDaHVZVzFsS1NCN1hHNWNkSFpoY2lCMllXeDFaVHRjYmx4MGFXWWdLRzVoYldVZ1BUMDlJQ2NsUVhONWJtTkdkVzVqZEdsdmJpVW5LU0I3WEc1Y2RGeDBkbUZzZFdVZ1BTQm5aWFJGZG1Gc2JHVmtRMjl1YzNSeWRXTjBiM0lvSjJGemVXNWpJR1oxYm1OMGFXOXVJQ2dwSUh0OUp5azdYRzVjZEgwZ1pXeHpaU0JwWmlBb2JtRnRaU0E5UFQwZ0p5VkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpVW5LU0I3WEc1Y2RGeDBkbUZzZFdVZ1BTQm5aWFJGZG1Gc2JHVmtRMjl1YzNSeWRXTjBiM0lvSjJaMWJtTjBhVzl1S2lBb0tTQjdmU2NwTzF4dVhIUjlJR1ZzYzJVZ2FXWWdLRzVoYldVZ1BUMDlJQ2NsUVhONWJtTkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpVW5LU0I3WEc1Y2RGeDBkbUZzZFdVZ1BTQm5aWFJGZG1Gc2JHVmtRMjl1YzNSeWRXTjBiM0lvSjJGemVXNWpJR1oxYm1OMGFXOXVLaUFvS1NCN2ZTY3BPMXh1WEhSOUlHVnNjMlVnYVdZZ0tHNWhiV1VnUFQwOUlDY2xRWE41Ym1OSFpXNWxjbUYwYjNJbEp5a2dlMXh1WEhSY2RIWmhjaUJtYmlBOUlHUnZSWFpoYkNnbkpVRnplVzVqUjJWdVpYSmhkRzl5Um5WdVkzUnBiMjRsSnlrN1hHNWNkRngwYVdZZ0tHWnVLU0I3WEc1Y2RGeDBYSFIyWVd4MVpTQTlJR1p1TG5CeWIzUnZkSGx3WlR0Y2JseDBYSFI5WEc1Y2RIMGdaV3h6WlNCcFppQW9ibUZ0WlNBOVBUMGdKeVZCYzNsdVkwbDBaWEpoZEc5eVVISnZkRzkwZVhCbEpTY3BJSHRjYmx4MFhIUjJZWElnWjJWdUlEMGdaRzlGZG1Gc0tDY2xRWE41Ym1OSFpXNWxjbUYwYjNJbEp5azdYRzVjZEZ4MGFXWWdLR2RsYmlrZ2UxeHVYSFJjZEZ4MGRtRnNkV1VnUFNCblpYUlFjbTkwYnloblpXNHVjSEp2ZEc5MGVYQmxLVHRjYmx4MFhIUjlYRzVjZEgxY2JseHVYSFJKVGxSU1NVNVRTVU5UVzI1aGJXVmRJRDBnZG1Gc2RXVTdYRzVjYmx4MGNtVjBkWEp1SUhaaGJIVmxPMXh1ZlR0Y2JseHVkbUZ5SUV4RlIwRkRXVjlCVEVsQlUwVlRJRDBnZTF4dVhIUW5KVUZ5Y21GNVFuVm1abVZ5VUhKdmRHOTBlWEJsSlNjNklGc25RWEp5WVhsQ2RXWm1aWEluTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFFYSnlZWGxRY205MGIzUjVjR1VsSnpvZ1d5ZEJjbkpoZVNjc0lDZHdjbTkwYjNSNWNHVW5YU3hjYmx4MEp5VkJjbkpoZVZCeWIzUnZYMlZ1ZEhKcFpYTWxKem9nV3lkQmNuSmhlU2NzSUNkd2NtOTBiM1I1Y0dVbkxDQW5aVzUwY21sbGN5ZGRMRnh1WEhRbkpVRnljbUY1VUhKdmRHOWZabTl5UldGamFDVW5PaUJiSjBGeWNtRjVKeXdnSjNCeWIzUnZkSGx3WlNjc0lDZG1iM0pGWVdOb0oxMHNYRzVjZENjbFFYSnlZWGxRY205MGIxOXJaWGx6SlNjNklGc25RWEp5WVhrbkxDQW5jSEp2ZEc5MGVYQmxKeXdnSjJ0bGVYTW5YU3hjYmx4MEp5VkJjbkpoZVZCeWIzUnZYM1poYkhWbGN5VW5PaUJiSjBGeWNtRjVKeXdnSjNCeWIzUnZkSGx3WlNjc0lDZDJZV3gxWlhNblhTeGNibHgwSnlWQmMzbHVZMFoxYm1OMGFXOXVVSEp2ZEc5MGVYQmxKU2M2SUZzblFYTjVibU5HZFc1amRHbHZiaWNzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWQmMzbHVZMGRsYm1WeVlYUnZjaVVuT2lCYkowRnplVzVqUjJWdVpYSmhkRzl5Um5WdVkzUnBiMjRuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFFYTjVibU5IWlc1bGNtRjBiM0pRY205MGIzUjVjR1VsSnpvZ1d5ZEJjM2x1WTBkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1Snl3Z0ozQnliM1J2ZEhsd1pTY3NJQ2R3Y205MGIzUjVjR1VuWFN4Y2JseDBKeVZDYjI5c1pXRnVVSEp2ZEc5MGVYQmxKU2M2SUZzblFtOXZiR1ZoYmljc0lDZHdjbTkwYjNSNWNHVW5YU3hjYmx4MEp5VkVZWFJoVm1sbGQxQnliM1J2ZEhsd1pTVW5PaUJiSjBSaGRHRldhV1YzSnl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpVUmhkR1ZRY205MGIzUjVjR1VsSnpvZ1d5ZEVZWFJsSnl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpVVnljbTl5VUhKdmRHOTBlWEJsSlNjNklGc25SWEp5YjNJbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xSWFpoYkVWeWNtOXlVSEp2ZEc5MGVYQmxKU2M2SUZzblJYWmhiRVZ5Y205eUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVVpzYjJGME16SkJjbkpoZVZCeWIzUnZkSGx3WlNVbk9pQmJKMFpzYjJGME16SkJjbkpoZVNjc0lDZHdjbTkwYjNSNWNHVW5YU3hjYmx4MEp5VkdiRzloZERZMFFYSnlZWGxRY205MGIzUjVjR1VsSnpvZ1d5ZEdiRzloZERZMFFYSnlZWGtuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFJuVnVZM1JwYjI1UWNtOTBiM1I1Y0dVbEp6b2dXeWRHZFc1amRHbHZiaWNzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWSFpXNWxjbUYwYjNJbEp6b2dXeWRIWlc1bGNtRjBiM0pHZFc1amRHbHZiaWNzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWSFpXNWxjbUYwYjNKUWNtOTBiM1I1Y0dVbEp6b2dXeWRIWlc1bGNtRjBiM0pHZFc1amRHbHZiaWNzSUNkd2NtOTBiM1I1Y0dVbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xTVzUwT0VGeWNtRjVVSEp2ZEc5MGVYQmxKU2M2SUZzblNXNTBPRUZ5Y21GNUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVWx1ZERFMlFYSnlZWGxRY205MGIzUjVjR1VsSnpvZ1d5ZEpiblF4TmtGeWNtRjVKeXdnSjNCeWIzUnZkSGx3WlNkZExGeHVYSFFuSlVsdWRETXlRWEp5WVhsUWNtOTBiM1I1Y0dVbEp6b2dXeWRKYm5Rek1rRnljbUY1Snl3Z0ozQnliM1J2ZEhsd1pTZGRMRnh1WEhRbkpVcFRUMDVRWVhKelpTVW5PaUJiSjBwVFQwNG5MQ0FuY0dGeWMyVW5YU3hjYmx4MEp5VktVMDlPVTNSeWFXNW5hV1o1SlNjNklGc25TbE5QVGljc0lDZHpkSEpwYm1kcFpua25YU3hjYmx4MEp5Vk5ZWEJRY205MGIzUjVjR1VsSnpvZ1d5ZE5ZWEFuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFRuVnRZbVZ5VUhKdmRHOTBlWEJsSlNjNklGc25UblZ0WW1WeUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVTlpYW1WamRGQnliM1J2ZEhsd1pTVW5PaUJiSjA5aWFtVmpkQ2NzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWUFltcFFjbTkwYjE5MGIxTjBjbWx1WnlVbk9pQmJKMDlpYW1WamRDY3NJQ2R3Y205MGIzUjVjR1VuTENBbmRHOVRkSEpwYm1jblhTeGNibHgwSnlWUFltcFFjbTkwYjE5MllXeDFaVTltSlNjNklGc25UMkpxWldOMEp5d2dKM0J5YjNSdmRIbHdaU2NzSUNkMllXeDFaVTltSjEwc1hHNWNkQ2NsVUhKdmJXbHpaVkJ5YjNSdmRIbHdaU1VuT2lCYkoxQnliMjFwYzJVbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xVSEp2YldselpWQnliM1J2WDNSb1pXNGxKem9nV3lkUWNtOXRhWE5sSnl3Z0ozQnliM1J2ZEhsd1pTY3NJQ2QwYUdWdUoxMHNYRzVjZENjbFVISnZiV2x6WlY5aGJHd2xKem9nV3lkUWNtOXRhWE5sSnl3Z0oyRnNiQ2RkTEZ4dVhIUW5KVkJ5YjIxcGMyVmZjbVZxWldOMEpTYzZJRnNuVUhKdmJXbHpaU2NzSUNkeVpXcGxZM1FuWFN4Y2JseDBKeVZRY205dGFYTmxYM0psYzI5c2RtVWxKem9nV3lkUWNtOXRhWE5sSnl3Z0ozSmxjMjlzZG1VblhTeGNibHgwSnlWU1lXNW5aVVZ5Y205eVVISnZkRzkwZVhCbEpTYzZJRnNuVW1GdVoyVkZjbkp2Y2ljc0lDZHdjbTkwYjNSNWNHVW5YU3hjYmx4MEp5VlNaV1psY21WdVkyVkZjbkp2Y2xCeWIzUnZkSGx3WlNVbk9pQmJKMUpsWm1WeVpXNWpaVVZ5Y205eUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVkpsWjBWNGNGQnliM1J2ZEhsd1pTVW5PaUJiSjFKbFowVjRjQ2NzSUNkd2NtOTBiM1I1Y0dVblhTeGNibHgwSnlWVFpYUlFjbTkwYjNSNWNHVWxKem9nV3lkVFpYUW5MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsVTJoaGNtVmtRWEp5WVhsQ2RXWm1aWEpRY205MGIzUjVjR1VsSnpvZ1d5ZFRhR0Z5WldSQmNuSmhlVUoxWm1abGNpY3NJQ2R3Y205MGIzUjVjR1VuWFN4Y2JseDBKeVZUZEhKcGJtZFFjbTkwYjNSNWNHVWxKem9nV3lkVGRISnBibWNuTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFUzbHRZbTlzVUhKdmRHOTBlWEJsSlNjNklGc25VM2x0WW05c0p5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVk41Ym5SaGVFVnljbTl5VUhKdmRHOTBlWEJsSlNjNklGc25VM2x1ZEdGNFJYSnliM0luTENBbmNISnZkRzkwZVhCbEoxMHNYRzVjZENjbFZIbHdaV1JCY25KaGVWQnliM1J2ZEhsd1pTVW5PaUJiSjFSNWNHVmtRWEp5WVhrbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xWSGx3WlVWeWNtOXlVSEp2ZEc5MGVYQmxKU2M2SUZzblZIbHdaVVZ5Y205eUp5d2dKM0J5YjNSdmRIbHdaU2RkTEZ4dVhIUW5KVlZwYm5RNFFYSnlZWGxRY205MGIzUjVjR1VsSnpvZ1d5ZFZhVzUwT0VGeWNtRjVKeXdnSjNCeWIzUnZkSGx3WlNkZExGeHVYSFFuSlZWcGJuUTRRMnhoYlhCbFpFRnljbUY1VUhKdmRHOTBlWEJsSlNjNklGc25WV2x1ZERoRGJHRnRjR1ZrUVhKeVlYa25MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsVldsdWRERTJRWEp5WVhsUWNtOTBiM1I1Y0dVbEp6b2dXeWRWYVc1ME1UWkJjbkpoZVNjc0lDZHdjbTkwYjNSNWNHVW5YU3hjYmx4MEp5VlZhVzUwTXpKQmNuSmhlVkJ5YjNSdmRIbHdaU1VuT2lCYkoxVnBiblF6TWtGeWNtRjVKeXdnSjNCeWIzUnZkSGx3WlNkZExGeHVYSFFuSlZWU1NVVnljbTl5VUhKdmRHOTBlWEJsSlNjNklGc25WVkpKUlhKeWIzSW5MQ0FuY0hKdmRHOTBlWEJsSjEwc1hHNWNkQ2NsVjJWaGEwMWhjRkJ5YjNSdmRIbHdaU1VuT2lCYkoxZGxZV3ROWVhBbkxDQW5jSEp2ZEc5MGVYQmxKMTBzWEc1Y2RDY2xWMlZoYTFObGRGQnliM1J2ZEhsd1pTVW5PaUJiSjFkbFlXdFRaWFFuTENBbmNISnZkRzkwZVhCbEoxMWNibjA3WEc1Y2JuWmhjaUJpYVc1a0lEMGdjbVZ4ZFdseVpTZ25ablZ1WTNScGIyNHRZbWx1WkNjcE8xeHVkbUZ5SUdoaGMwOTNiaUE5SUhKbGNYVnBjbVVvSjJoaGN5Y3BPMXh1ZG1GeUlDUmpiMjVqWVhRZ1BTQmlhVzVrTG1OaGJHd29SblZ1WTNScGIyNHVZMkZzYkN3Z1FYSnlZWGt1Y0hKdmRHOTBlWEJsTG1OdmJtTmhkQ2s3WEc1MllYSWdKSE53YkdsalpVRndjR3g1SUQwZ1ltbHVaQzVqWVd4c0tFWjFibU4wYVc5dUxtRndjR3g1TENCQmNuSmhlUzV3Y205MGIzUjVjR1V1YzNCc2FXTmxLVHRjYm5aaGNpQWtjbVZ3YkdGalpTQTlJR0pwYm1RdVkyRnNiQ2hHZFc1amRHbHZiaTVqWVd4c0xDQlRkSEpwYm1jdWNISnZkRzkwZVhCbExuSmxjR3hoWTJVcE8xeHVkbUZ5SUNSemRISlRiR2xqWlNBOUlHSnBibVF1WTJGc2JDaEdkVzVqZEdsdmJpNWpZV3hzTENCVGRISnBibWN1Y0hKdmRHOTBlWEJsTG5Oc2FXTmxLVHRjYmx4dUx5b2dZV1JoY0hSbFpDQm1jbTl0SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5c2IyUmhjMmd2Ykc5a1lYTm9MMkpzYjJJdk5DNHhOeTR4TlM5a2FYTjBMMnh2WkdGemFDNXFjeU5NTmpjek5TMU1OamMwTkNBcUwxeHVkbUZ5SUhKbFVISnZjRTVoYldVZ1BTQXZXMTRsTGx0Y1hGMWRLM3hjWEZzb1B6b29MVDljWEdRcktEODZYRnd1WEZ4a0t5ay9LWHdvVzF3aUoxMHBLQ2cvT2lnL0lWeGNNaWxiWGx4Y1hGeGRmRnhjWEZ3dUtTby9LVnhjTWlsY1hGMThLRDg5S0Q4NlhGd3VmRnhjVzF4Y1hTa29QenBjWEM1OFhGeGJYRnhkZkNVa0tTa3ZaenRjYm5aaGNpQnlaVVZ6WTJGd1pVTm9ZWElnUFNBdlhGeGNYQ2hjWEZ4Y0tUOHZaenNnTHlvcUlGVnpaV1FnZEc4Z2JXRjBZMmdnWW1GamEzTnNZWE5vWlhNZ2FXNGdjSEp2Y0dWeWRIa2djR0YwYUhNdUlDb3ZYRzUyWVhJZ2MzUnlhVzVuVkc5UVlYUm9JRDBnWm5WdVkzUnBiMjRnYzNSeWFXNW5WRzlRWVhSb0tITjBjbWx1WnlrZ2UxeHVYSFIyWVhJZ1ptbHljM1FnUFNBa2MzUnlVMnhwWTJVb2MzUnlhVzVuTENBd0xDQXhLVHRjYmx4MGRtRnlJR3hoYzNRZ1BTQWtjM1J5VTJ4cFkyVW9jM1J5YVc1bkxDQXRNU2s3WEc1Y2RHbG1JQ2htYVhKemRDQTlQVDBnSnlVbklDWW1JR3hoYzNRZ0lUMDlJQ2NsSnlrZ2UxeHVYSFJjZEhSb2NtOTNJRzVsZHlBa1UzbHVkR0Y0UlhKeWIzSW9KMmx1ZG1Gc2FXUWdhVzUwY21sdWMybGpJSE41Ym5SaGVDd2daWGh3WldOMFpXUWdZMnh2YzJsdVp5QmdKV0FuS1R0Y2JseDBmU0JsYkhObElHbG1JQ2hzWVhOMElEMDlQU0FuSlNjZ0ppWWdabWx5YzNRZ0lUMDlJQ2NsSnlrZ2UxeHVYSFJjZEhSb2NtOTNJRzVsZHlBa1UzbHVkR0Y0UlhKeWIzSW9KMmx1ZG1Gc2FXUWdhVzUwY21sdWMybGpJSE41Ym5SaGVDd2daWGh3WldOMFpXUWdiM0JsYm1sdVp5QmdKV0FuS1R0Y2JseDBmVnh1WEhSMllYSWdjbVZ6ZFd4MElEMGdXMTA3WEc1Y2RDUnlaWEJzWVdObEtITjBjbWx1Wnl3Z2NtVlFjbTl3VG1GdFpTd2dablZ1WTNScGIyNGdLRzFoZEdOb0xDQnVkVzFpWlhJc0lIRjFiM1JsTENCemRXSlRkSEpwYm1jcElIdGNibHgwWEhSeVpYTjFiSFJiY21WemRXeDBMbXhsYm1kMGFGMGdQU0J4ZFc5MFpTQS9JQ1J5WlhCc1lXTmxLSE4xWWxOMGNtbHVaeXdnY21WRmMyTmhjR1ZEYUdGeUxDQW5KREVuS1NBNklHNTFiV0psY2lCOGZDQnRZWFJqYUR0Y2JseDBmU2s3WEc1Y2RISmxkSFZ5YmlCeVpYTjFiSFE3WEc1OU8xeHVMeW9nWlc1a0lHRmtZWEIwWVhScGIyNGdLaTljYmx4dWRtRnlJR2RsZEVKaGMyVkpiblJ5YVc1emFXTWdQU0JtZFc1amRHbHZiaUJuWlhSQ1lYTmxTVzUwY21sdWMybGpLRzVoYldVc0lHRnNiRzkzVFdsemMybHVaeWtnZTF4dVhIUjJZWElnYVc1MGNtbHVjMmxqVG1GdFpTQTlJRzVoYldVN1hHNWNkSFpoY2lCaGJHbGhjenRjYmx4MGFXWWdLR2hoYzA5M2JpaE1SVWRCUTFsZlFVeEpRVk5GVXl3Z2FXNTBjbWx1YzJsalRtRnRaU2twSUh0Y2JseDBYSFJoYkdsaGN5QTlJRXhGUjBGRFdWOUJURWxCVTBWVFcybHVkSEpwYm5OcFkwNWhiV1ZkTzF4dVhIUmNkR2x1ZEhKcGJuTnBZMDVoYldVZ1BTQW5KU2NnS3lCaGJHbGhjMXN3WFNBcklDY2xKenRjYmx4MGZWeHVYRzVjZEdsbUlDaG9ZWE5QZDI0b1NVNVVVa2xPVTBsRFV5d2dhVzUwY21sdWMybGpUbUZ0WlNrcElIdGNibHgwWEhSMllYSWdkbUZzZFdVZ1BTQkpUbFJTU1U1VFNVTlRXMmx1ZEhKcGJuTnBZMDVoYldWZE8xeHVYSFJjZEdsbUlDaDJZV3gxWlNBOVBUMGdibVZsWkhORmRtRnNLU0I3WEc1Y2RGeDBYSFIyWVd4MVpTQTlJR1J2UlhaaGJDaHBiblJ5YVc1emFXTk9ZVzFsS1R0Y2JseDBYSFI5WEc1Y2RGeDBhV1lnS0hSNWNHVnZaaUIyWVd4MVpTQTlQVDBnSjNWdVpHVm1hVzVsWkNjZ0ppWWdJV0ZzYkc5M1RXbHpjMmx1WnlrZ2UxeHVYSFJjZEZ4MGRHaHliM2NnYm1WM0lDUlVlWEJsUlhKeWIzSW9KMmx1ZEhKcGJuTnBZeUFuSUNzZ2JtRnRaU0FySUNjZ1pYaHBjM1J6TENCaWRYUWdhWE1nYm05MElHRjJZV2xzWVdKc1pTNGdVR3hsWVhObElHWnBiR1VnWVc0Z2FYTnpkV1VoSnlrN1hHNWNkRngwZlZ4dVhHNWNkRngwY21WMGRYSnVJSHRjYmx4MFhIUmNkR0ZzYVdGek9pQmhiR2xoY3l4Y2JseDBYSFJjZEc1aGJXVTZJR2x1ZEhKcGJuTnBZMDVoYldVc1hHNWNkRngwWEhSMllXeDFaVG9nZG1Gc2RXVmNibHgwWEhSOU8xeHVYSFI5WEc1Y2JseDBkR2h5YjNjZ2JtVjNJQ1JUZVc1MFlYaEZjbkp2Y2lnbmFXNTBjbWx1YzJsaklDY2dLeUJ1WVcxbElDc2dKeUJrYjJWeklHNXZkQ0JsZUdsemRDRW5LVHRjYm4wN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdSMlYwU1c1MGNtbHVjMmxqS0c1aGJXVXNJR0ZzYkc5M1RXbHpjMmx1WnlrZ2UxeHVYSFJwWmlBb2RIbHdaVzltSUc1aGJXVWdJVDA5SUNkemRISnBibWNuSUh4OElHNWhiV1V1YkdWdVozUm9JRDA5UFNBd0tTQjdYRzVjZEZ4MGRHaHliM2NnYm1WM0lDUlVlWEJsUlhKeWIzSW9KMmx1ZEhKcGJuTnBZeUJ1WVcxbElHMTFjM1FnWW1VZ1lTQnViMjR0Wlcxd2RIa2djM1J5YVc1bkp5azdYRzVjZEgxY2JseDBhV1lnS0dGeVozVnRaVzUwY3k1c1pXNW5kR2dnUGlBeElDWW1JSFI1Y0dWdlppQmhiR3h2ZDAxcGMzTnBibWNnSVQwOUlDZGliMjlzWldGdUp5a2dlMXh1WEhSY2RIUm9jbTkzSUc1bGR5QWtWSGx3WlVWeWNtOXlLQ2RjSW1Gc2JHOTNUV2x6YzJsdVoxd2lJR0Z5WjNWdFpXNTBJRzExYzNRZ1ltVWdZU0JpYjI5c1pXRnVKeWs3WEc1Y2RIMWNibHh1WEhSMllYSWdjR0Z5ZEhNZ1BTQnpkSEpwYm1kVWIxQmhkR2dvYm1GdFpTazdYRzVjZEhaaGNpQnBiblJ5YVc1emFXTkNZWE5sVG1GdFpTQTlJSEJoY25SekxteGxibWQwYUNBK0lEQWdQeUJ3WVhKMGMxc3dYU0E2SUNjbk8xeHVYRzVjZEhaaGNpQnBiblJ5YVc1emFXTWdQU0JuWlhSQ1lYTmxTVzUwY21sdWMybGpLQ2NsSnlBcklHbHVkSEpwYm5OcFkwSmhjMlZPWVcxbElDc2dKeVVuTENCaGJHeHZkMDFwYzNOcGJtY3BPMXh1WEhSMllYSWdhVzUwY21sdWMybGpVbVZoYkU1aGJXVWdQU0JwYm5SeWFXNXphV011Ym1GdFpUdGNibHgwZG1GeUlIWmhiSFZsSUQwZ2FXNTBjbWx1YzJsakxuWmhiSFZsTzF4dVhIUjJZWElnYzJ0cGNFWjFjblJvWlhKRFlXTm9hVzVuSUQwZ1ptRnNjMlU3WEc1Y2JseDBkbUZ5SUdGc2FXRnpJRDBnYVc1MGNtbHVjMmxqTG1Gc2FXRnpPMXh1WEhScFppQW9ZV3hwWVhNcElIdGNibHgwWEhScGJuUnlhVzV6YVdOQ1lYTmxUbUZ0WlNBOUlHRnNhV0Z6V3pCZE8xeHVYSFJjZENSemNHeHBZMlZCY0hCc2VTaHdZWEowY3l3Z0pHTnZibU5oZENoYk1Dd2dNVjBzSUdGc2FXRnpLU2s3WEc1Y2RIMWNibHh1WEhSbWIzSWdLSFpoY2lCcElEMGdNU3dnYVhOUGQyNGdQU0IwY25WbE95QnBJRHdnY0dGeWRITXViR1Z1WjNSb095QnBJQ3M5SURFcElIdGNibHgwWEhSMllYSWdjR0Z5ZENBOUlIQmhjblJ6VzJsZE8xeHVYSFJjZEhaaGNpQm1hWEp6ZENBOUlDUnpkSEpUYkdsalpTaHdZWEowTENBd0xDQXhLVHRjYmx4MFhIUjJZWElnYkdGemRDQTlJQ1J6ZEhKVGJHbGpaU2h3WVhKMExDQXRNU2s3WEc1Y2RGeDBhV1lnS0Z4dVhIUmNkRngwS0Z4dVhIUmNkRngwWEhRb1ptbHljM1FnUFQwOUlDZGNJaWNnZkh3Z1ptbHljM1FnUFQwOUlGd2lKMXdpSUh4OElHWnBjbk4wSUQwOVBTQW5ZQ2NwWEc1Y2RGeDBYSFJjZEh4OElDaHNZWE4wSUQwOVBTQW5YQ0luSUh4OElHeGhjM1FnUFQwOUlGd2lKMXdpSUh4OElHeGhjM1FnUFQwOUlDZGdKeWxjYmx4MFhIUmNkQ2xjYmx4MFhIUmNkQ1ltSUdacGNuTjBJQ0U5UFNCc1lYTjBYRzVjZEZ4MEtTQjdYRzVjZEZ4MFhIUjBhSEp2ZHlCdVpYY2dKRk41Ym5SaGVFVnljbTl5S0Nkd2NtOXdaWEowZVNCdVlXMWxjeUIzYVhSb0lIRjFiM1JsY3lCdGRYTjBJR2hoZG1VZ2JXRjBZMmhwYm1jZ2NYVnZkR1Z6SnlrN1hHNWNkRngwZlZ4dVhIUmNkR2xtSUNod1lYSjBJRDA5UFNBblkyOXVjM1J5ZFdOMGIzSW5JSHg4SUNGcGMwOTNiaWtnZTF4dVhIUmNkRngwYzJ0cGNFWjFjblJvWlhKRFlXTm9hVzVuSUQwZ2RISjFaVHRjYmx4MFhIUjlYRzVjYmx4MFhIUnBiblJ5YVc1emFXTkNZWE5sVG1GdFpTQXJQU0FuTGljZ0t5QndZWEowTzF4dVhIUmNkR2x1ZEhKcGJuTnBZMUpsWVd4T1lXMWxJRDBnSnlVbklDc2dhVzUwY21sdWMybGpRbUZ6WlU1aGJXVWdLeUFuSlNjN1hHNWNibHgwWEhScFppQW9hR0Z6VDNkdUtFbE9WRkpKVGxOSlExTXNJR2x1ZEhKcGJuTnBZMUpsWVd4T1lXMWxLU2tnZTF4dVhIUmNkRngwZG1Gc2RXVWdQU0JKVGxSU1NVNVRTVU5UVzJsdWRISnBibk5wWTFKbFlXeE9ZVzFsWFR0Y2JseDBYSFI5SUdWc2MyVWdhV1lnS0haaGJIVmxJQ0U5SUc1MWJHd3BJSHRjYmx4MFhIUmNkR2xtSUNnaEtIQmhjblFnYVc0Z2RtRnNkV1VwS1NCN1hHNWNkRngwWEhSY2RHbG1JQ2doWVd4c2IzZE5hWE56YVc1bktTQjdYRzVjZEZ4MFhIUmNkRngwZEdoeWIzY2dibVYzSUNSVWVYQmxSWEp5YjNJb0oySmhjMlVnYVc1MGNtbHVjMmxqSUdadmNpQW5JQ3NnYm1GdFpTQXJJQ2NnWlhocGMzUnpMQ0JpZFhRZ2RHaGxJSEJ5YjNCbGNuUjVJR2x6SUc1dmRDQmhkbUZwYkdGaWJHVXVKeWs3WEc1Y2RGeDBYSFJjZEgxY2JseDBYSFJjZEZ4MGNtVjBkWEp1SUhadmFXUWdkVzVrWldacGJtVmtPMXh1WEhSY2RGeDBmVnh1WEhSY2RGeDBhV1lnS0NSblQxQkVJQ1ltSUNocElDc2dNU2tnUGowZ2NHRnlkSE11YkdWdVozUm9LU0I3WEc1Y2RGeDBYSFJjZEhaaGNpQmtaWE5qSUQwZ0pHZFBVRVFvZG1Gc2RXVXNJSEJoY25RcE8xeHVYSFJjZEZ4MFhIUnBjMDkzYmlBOUlDRWhaR1Z6WXp0Y2JseHVYSFJjZEZ4MFhIUXZMeUJDZVNCamIyNTJaVzUwYVc5dUxDQjNhR1Z1SUdFZ1pHRjBZU0J3Y205d1pYSjBlU0JwY3lCamIyNTJaWEowWldRZ2RHOGdZVzRnWVdOalpYTnpiM0pjYmx4MFhIUmNkRngwTHk4Z2NISnZjR1Z5ZEhrZ2RHOGdaVzExYkdGMFpTQmhJR1JoZEdFZ2NISnZjR1Z5ZEhrZ2RHaGhkQ0JrYjJWeklHNXZkQ0J6ZFdabVpYSWdabkp2YlZ4dVhIUmNkRngwWEhRdkx5QjBhR1VnYjNabGNuSnBaR1VnYldsemRHRnJaU3dnZEdoaGRDQmhZMk5sYzNOdmNpZHpJR2RsZEhSbGNpQnBjeUJ0WVhKclpXUWdkMmwwYUZ4dVhIUmNkRngwWEhRdkx5QmhiaUJnYjNKcFoybHVZV3hXWVd4MVpXQWdjSEp2Y0dWeWRIa3VJRWhsY21Vc0lIZG9aVzRnZDJVZ1pHVjBaV04wSUhSb2FYTXNJSGRsWEc1Y2RGeDBYSFJjZEM4dklIVndhRzlzWkNCMGFHVWdhV3hzZFhOcGIyNGdZbmtnY0hKbGRHVnVaR2x1WnlCMGJ5QnpaV1VnZEdoaGRDQnZjbWxuYVc1aGJDQmtZWFJoWEc1Y2RGeDBYSFJjZEM4dklIQnliM0JsY25SNUxDQnBMbVV1TENCeVpYUjFjbTVwYm1jZ2RHaGxJSFpoYkhWbElISmhkR2hsY2lCMGFHRnVJSFJvWlNCblpYUjBaWEpjYmx4MFhIUmNkRngwTHk4Z2FYUnpaV3htTGx4dVhIUmNkRngwWEhScFppQW9hWE5QZDI0Z0ppWWdKMmRsZENjZ2FXNGdaR1Z6WXlBbUppQWhLQ2R2Y21sbmFXNWhiRlpoYkhWbEp5QnBiaUJrWlhOakxtZGxkQ2twSUh0Y2JseDBYSFJjZEZ4MFhIUjJZV3gxWlNBOUlHUmxjMk11WjJWME8xeHVYSFJjZEZ4MFhIUjlJR1ZzYzJVZ2UxeHVYSFJjZEZ4MFhIUmNkSFpoYkhWbElEMGdkbUZzZFdWYmNHRnlkRjA3WEc1Y2RGeDBYSFJjZEgxY2JseDBYSFJjZEgwZ1pXeHpaU0I3WEc1Y2RGeDBYSFJjZEdselQzZHVJRDBnYUdGelQzZHVLSFpoYkhWbExDQndZWEowS1R0Y2JseDBYSFJjZEZ4MGRtRnNkV1VnUFNCMllXeDFaVnR3WVhKMFhUdGNibHgwWEhSY2RIMWNibHh1WEhSY2RGeDBhV1lnS0dselQzZHVJQ1ltSUNGemEybHdSblZ5ZEdobGNrTmhZMmhwYm1jcElIdGNibHgwWEhSY2RGeDBTVTVVVWtsT1UwbERVMXRwYm5SeWFXNXphV05TWldGc1RtRnRaVjBnUFNCMllXeDFaVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjZEgxY2JseDBjbVYwZFhKdUlIWmhiSFZsTzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1ZG1GeUlHOXlhV2RUZVcxaWIyd2dQU0IwZVhCbGIyWWdVM2x0WW05c0lDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUppQlRlVzFpYjJ3N1hHNTJZWElnYUdGelUzbHRZbTlzVTJoaGJTQTlJSEpsY1hWcGNtVW9KeTR2YzJoaGJYTW5LVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCb1lYTk9ZWFJwZG1WVGVXMWliMnh6S0NrZ2UxeHVYSFJwWmlBb2RIbHdaVzltSUc5eWFXZFRlVzFpYjJ3Z0lUMDlJQ2RtZFc1amRHbHZiaWNwSUhzZ2NtVjBkWEp1SUdaaGJITmxPeUI5WEc1Y2RHbG1JQ2gwZVhCbGIyWWdVM2x0WW05c0lDRTlQU0FuWm5WdVkzUnBiMjRuS1NCN0lISmxkSFZ5YmlCbVlXeHpaVHNnZlZ4dVhIUnBaaUFvZEhsd1pXOW1JRzl5YVdkVGVXMWliMndvSjJadmJ5Y3BJQ0U5UFNBbmMzbHRZbTlzSnlrZ2V5QnlaWFIxY200Z1ptRnNjMlU3SUgxY2JseDBhV1lnS0hSNWNHVnZaaUJUZVcxaWIyd29KMkpoY2ljcElDRTlQU0FuYzNsdFltOXNKeWtnZXlCeVpYUjFjbTRnWm1Gc2MyVTdJSDFjYmx4dVhIUnlaWFIxY200Z2FHRnpVM2x0WW05c1UyaGhiU2dwTzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1THlvZ1pYTnNhVzUwSUdOdmJYQnNaWGhwZEhrNklGc3lMQ0F4T0Ywc0lHMWhlQzF6ZEdGMFpXMWxiblJ6T2lCYk1pd2dNek5kSUNvdlhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUlHaGhjMU41YldKdmJITW9LU0I3WEc1Y2RHbG1JQ2gwZVhCbGIyWWdVM2x0WW05c0lDRTlQU0FuWm5WdVkzUnBiMjRuSUh4OElIUjVjR1Z2WmlCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbFRlVzFpYjJ4eklDRTlQU0FuWm5WdVkzUnBiMjRuS1NCN0lISmxkSFZ5YmlCbVlXeHpaVHNnZlZ4dVhIUnBaaUFvZEhsd1pXOW1JRk41YldKdmJDNXBkR1Z5WVhSdmNpQTlQVDBnSjNONWJXSnZiQ2NwSUhzZ2NtVjBkWEp1SUhSeWRXVTdJSDFjYmx4dVhIUjJZWElnYjJKcUlEMGdlMzA3WEc1Y2RIWmhjaUJ6ZVcwZ1BTQlRlVzFpYjJ3b0ozUmxjM1FuS1R0Y2JseDBkbUZ5SUhONWJVOWlhaUE5SUU5aWFtVmpkQ2h6ZVcwcE8xeHVYSFJwWmlBb2RIbHdaVzltSUhONWJTQTlQVDBnSjNOMGNtbHVaeWNwSUhzZ2NtVjBkWEp1SUdaaGJITmxPeUI5WEc1Y2JseDBhV1lnS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWN1WTJGc2JDaHplVzBwSUNFOVBTQW5XMjlpYW1WamRDQlRlVzFpYjJ4ZEp5a2dleUJ5WlhSMWNtNGdabUZzYzJVN0lIMWNibHgwYVdZZ0tFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWRHOVRkSEpwYm1jdVkyRnNiQ2h6ZVcxUFltb3BJQ0U5UFNBblcyOWlhbVZqZENCVGVXMWliMnhkSnlrZ2V5QnlaWFIxY200Z1ptRnNjMlU3SUgxY2JseHVYSFF2THlCMFpXMXdJR1JwYzJGaWJHVmtJSEJsY2lCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdmJHcG9ZWEppTDI5aWFtVmpkQzVoYzNOcFoyNHZhWE56ZFdWekx6RTNYRzVjZEM4dklHbG1JQ2h6ZVcwZ2FXNXpkR0Z1WTJWdlppQlRlVzFpYjJ3cElIc2djbVYwZFhKdUlHWmhiSE5sT3lCOVhHNWNkQzh2SUhSbGJYQWdaR2x6WVdKc1pXUWdjR1Z5SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5WFpXSlNaV1pzWldOMGFXOXVMMmRsZEMxdmQyNHRjSEp2Y0dWeWRIa3RjM2x0WW05c2N5OXBjM04xWlhNdk5GeHVYSFF2THlCcFppQW9JU2h6ZVcxUFltb2dhVzV6ZEdGdVkyVnZaaUJUZVcxaWIyd3BLU0I3SUhKbGRIVnliaUJtWVd4elpUc2dmVnh1WEc1Y2RDOHZJR2xtSUNoMGVYQmxiMllnVTNsdFltOXNMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaeUFoUFQwZ0oyWjFibU4wYVc5dUp5a2dleUJ5WlhSMWNtNGdabUZzYzJVN0lIMWNibHgwTHk4Z2FXWWdLRk4wY21sdVp5aHplVzBwSUNFOVBTQlRlVzFpYjJ3dWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bkxtTmhiR3dvYzNsdEtTa2dleUJ5WlhSMWNtNGdabUZzYzJVN0lIMWNibHh1WEhSMllYSWdjM2x0Vm1Gc0lEMGdOREk3WEc1Y2RHOWlhbHR6ZVcxZElEMGdjM2x0Vm1Gc08xeHVYSFJtYjNJZ0tITjViU0JwYmlCdlltb3BJSHNnY21WMGRYSnVJR1poYkhObE95QjlJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMV3hwYm1VZ2JtOHRjbVZ6ZEhKcFkzUmxaQzF6ZVc1MFlYZ3NJRzV2TFhWdWNtVmhZMmhoWW14bExXeHZiM0JjYmx4MGFXWWdLSFI1Y0dWdlppQlBZbXBsWTNRdWEyVjVjeUE5UFQwZ0oyWjFibU4wYVc5dUp5QW1KaUJQWW1wbFkzUXVhMlY1Y3lodlltb3BMbXhsYm1kMGFDQWhQVDBnTUNrZ2V5QnlaWFIxY200Z1ptRnNjMlU3SUgxY2JseHVYSFJwWmlBb2RIbHdaVzltSUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6SUQwOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0c5aWFpa3ViR1Z1WjNSb0lDRTlQU0F3S1NCN0lISmxkSFZ5YmlCbVlXeHpaVHNnZlZ4dVhHNWNkSFpoY2lCemVXMXpJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVUzbHRZbTlzY3lodlltb3BPMXh1WEhScFppQW9jM2x0Y3k1c1pXNW5kR2dnSVQwOUlERWdmSHdnYzNsdGMxc3dYU0FoUFQwZ2MzbHRLU0I3SUhKbGRIVnliaUJtWVd4elpUc2dmVnh1WEc1Y2RHbG1JQ2doVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzV3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlM1allXeHNLRzlpYWl3Z2MzbHRLU2tnZXlCeVpYUjFjbTRnWm1Gc2MyVTdJSDFjYmx4dVhIUnBaaUFvZEhsd1pXOW1JRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVVSbGMyTnlhWEIwYjNJZ1BUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JseDBYSFIyWVhJZ1pHVnpZM0pwY0hSdmNpQTlJRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVVSbGMyTnlhWEIwYjNJb2IySnFMQ0J6ZVcwcE8xeHVYSFJjZEdsbUlDaGtaWE5qY21sd2RHOXlMblpoYkhWbElDRTlQU0J6ZVcxV1lXd2dmSHdnWkdWelkzSnBjSFJ2Y2k1bGJuVnRaWEpoWW14bElDRTlQU0IwY25WbEtTQjdJSEpsZEhWeWJpQm1ZV3h6WlRzZ2ZWeHVYSFI5WEc1Y2JseDBjbVYwZFhKdUlIUnlkV1U3WEc1OU8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ1ltbHVaQ0E5SUhKbGNYVnBjbVVvSjJaMWJtTjBhVzl1TFdKcGJtUW5LVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCaWFXNWtMbU5oYkd3b1JuVnVZM1JwYjI0dVkyRnNiQ3dnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzVvWVhOUGQyNVFjbTl3WlhKMGVTazdYRzRpTENKcFppQW9kSGx3Wlc5bUlFOWlhbVZqZEM1amNtVmhkR1VnUFQwOUlDZG1kVzVqZEdsdmJpY3BJSHRjYmlBZ0x5OGdhVzF3YkdWdFpXNTBZWFJwYjI0Z1puSnZiU0J6ZEdGdVpHRnlaQ0J1YjJSbExtcHpJQ2QxZEdsc0p5QnRiMlIxYkdWY2JpQWdiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQnBibWhsY21sMGN5aGpkRzl5TENCemRYQmxja04wYjNJcElIdGNiaUFnSUNCcFppQW9jM1Z3WlhKRGRHOXlLU0I3WEc0Z0lDQWdJQ0JqZEc5eUxuTjFjR1Z5WHlBOUlITjFjR1Z5UTNSdmNseHVJQ0FnSUNBZ1kzUnZjaTV3Y205MGIzUjVjR1VnUFNCUFltcGxZM1F1WTNKbFlYUmxLSE4xY0dWeVEzUnZjaTV3Y205MGIzUjVjR1VzSUh0Y2JpQWdJQ0FnSUNBZ1kyOXVjM1J5ZFdOMGIzSTZJSHRjYmlBZ0lDQWdJQ0FnSUNCMllXeDFaVG9nWTNSdmNpeGNiaUFnSUNBZ0lDQWdJQ0JsYm5WdFpYSmhZbXhsT2lCbVlXeHpaU3hjYmlBZ0lDQWdJQ0FnSUNCM2NtbDBZV0pzWlRvZ2RISjFaU3hjYmlBZ0lDQWdJQ0FnSUNCamIyNW1hV2QxY21GaWJHVTZJSFJ5ZFdWY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZTbGNiaUFnSUNCOVhHNGdJSDA3WEc1OUlHVnNjMlVnZTF4dUlDQXZMeUJ2YkdRZ2MyTm9iMjlzSUhOb2FXMGdabTl5SUc5c1pDQmljbTkzYzJWeWMxeHVJQ0J0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJR2x1YUdWeWFYUnpLR04wYjNJc0lITjFjR1Z5UTNSdmNpa2dlMXh1SUNBZ0lHbG1JQ2h6ZFhCbGNrTjBiM0lwSUh0Y2JpQWdJQ0FnSUdOMGIzSXVjM1Z3WlhKZklEMGdjM1Z3WlhKRGRHOXlYRzRnSUNBZ0lDQjJZWElnVkdWdGNFTjBiM0lnUFNCbWRXNWpkR2x2YmlBb0tTQjdmVnh1SUNBZ0lDQWdWR1Z0Y0VOMGIzSXVjSEp2ZEc5MGVYQmxJRDBnYzNWd1pYSkRkRzl5TG5CeWIzUnZkSGx3WlZ4dUlDQWdJQ0FnWTNSdmNpNXdjbTkwYjNSNWNHVWdQU0J1WlhjZ1ZHVnRjRU4wYjNJb0tWeHVJQ0FnSUNBZ1kzUnZjaTV3Y205MGIzUjVjR1V1WTI5dWMzUnlkV04wYjNJZ1BTQmpkRzl5WEc0Z0lDQWdmVnh1SUNCOVhHNTlYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQm9ZWE5VYjFOMGNtbHVaMVJoWnlBOUlIUjVjR1Z2WmlCVGVXMWliMndnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVlnZEhsd1pXOW1JRk41YldKdmJDNTBiMU4wY21sdVoxUmhaeUE5UFQwZ0ozTjViV0p2YkNjN1hHNTJZWElnWTJGc2JFSnZkVzVrSUQwZ2NtVnhkV2x5WlNnblkyRnNiQzFpYVc1a0wyTmhiR3hDYjNWdVpDY3BPMXh1WEc1MllYSWdKSFJ2VTNSeWFXNW5JRDBnWTJGc2JFSnZkVzVrS0NkUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuSnlrN1hHNWNiblpoY2lCcGMxTjBZVzVrWVhKa1FYSm5kVzFsYm5SeklEMGdablZ1WTNScGIyNGdhWE5CY21kMWJXVnVkSE1vZG1Gc2RXVXBJSHRjYmx4MGFXWWdLR2hoYzFSdlUzUnlhVzVuVkdGbklDWW1JSFpoYkhWbElDWW1JSFI1Y0dWdlppQjJZV3gxWlNBOVBUMGdKMjlpYW1WamRDY2dKaVlnVTNsdFltOXNMblJ2VTNSeWFXNW5WR0ZuSUdsdUlIWmhiSFZsS1NCN1hHNWNkRngwY21WMGRYSnVJR1poYkhObE8xeHVYSFI5WEc1Y2RISmxkSFZ5YmlBa2RHOVRkSEpwYm1jb2RtRnNkV1VwSUQwOVBTQW5XMjlpYW1WamRDQkJjbWQxYldWdWRITmRKenRjYm4wN1hHNWNiblpoY2lCcGMweGxaMkZqZVVGeVozVnRaVzUwY3lBOUlHWjFibU4wYVc5dUlHbHpRWEpuZFcxbGJuUnpLSFpoYkhWbEtTQjdYRzVjZEdsbUlDaHBjMU4wWVc1a1lYSmtRWEpuZFcxbGJuUnpLSFpoYkhWbEtTa2dlMXh1WEhSY2RISmxkSFZ5YmlCMGNuVmxPMXh1WEhSOVhHNWNkSEpsZEhWeWJpQjJZV3gxWlNBaFBUMGdiblZzYkNBbUpseHVYSFJjZEhSNWNHVnZaaUIyWVd4MVpTQTlQVDBnSjI5aWFtVmpkQ2NnSmlaY2JseDBYSFIwZVhCbGIyWWdkbUZzZFdVdWJHVnVaM1JvSUQwOVBTQW5iblZ0WW1WeUp5QW1KbHh1WEhSY2RIWmhiSFZsTG14bGJtZDBhQ0ErUFNBd0lDWW1YRzVjZEZ4MEpIUnZVM1J5YVc1bktIWmhiSFZsS1NBaFBUMGdKMXR2WW1wbFkzUWdRWEp5WVhsZEp5QW1KbHh1WEhSY2RDUjBiMU4wY21sdVp5aDJZV3gxWlM1allXeHNaV1VwSUQwOVBTQW5XMjlpYW1WamRDQkdkVzVqZEdsdmJsMG5PMXh1ZlR0Y2JseHVkbUZ5SUhOMWNIQnZjblJ6VTNSaGJtUmhjbVJCY21kMWJXVnVkSE1nUFNBb1puVnVZM1JwYjI0Z0tDa2dlMXh1WEhSeVpYUjFjbTRnYVhOVGRHRnVaR0Z5WkVGeVozVnRaVzUwY3loaGNtZDFiV1Z1ZEhNcE8xeHVmU2dwS1R0Y2JseHVhWE5UZEdGdVpHRnlaRUZ5WjNWdFpXNTBjeTVwYzB4bFoyRmplVUZ5WjNWdFpXNTBjeUE5SUdselRHVm5ZV041UVhKbmRXMWxiblJ6T3lBdkx5Qm1iM0lnZEdWemRITmNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0J6ZFhCd2IzSjBjMU4wWVc1a1lYSmtRWEpuZFcxbGJuUnpJRDhnYVhOVGRHRnVaR0Z5WkVGeVozVnRaVzUwY3lBNklHbHpUR1ZuWVdONVFYSm5kVzFsYm5Sek8xeHVJaXdpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzUyWVhJZ2RHOVRkSElnUFNCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTzF4dWRtRnlJR1p1Vkc5VGRISWdQU0JHZFc1amRHbHZiaTV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWM3WEc1MllYSWdhWE5HYmxKbFoyVjRJRDBnTDE1Y1hITXFLRDg2Wm5WdVkzUnBiMjRwUDF4Y0tpODdYRzUyWVhJZ2FHRnpWRzlUZEhKcGJtZFVZV2NnUFNCMGVYQmxiMllnVTNsdFltOXNJRDA5UFNBblpuVnVZM1JwYjI0bklDWW1JSFI1Y0dWdlppQlRlVzFpYjJ3dWRHOVRkSEpwYm1kVVlXY2dQVDA5SUNkemVXMWliMnduTzF4dWRtRnlJR2RsZEZCeWIzUnZJRDBnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bU8xeHVkbUZ5SUdkbGRFZGxibVZ5WVhSdmNrWjFibU1nUFNCbWRXNWpkR2x2YmlBb0tTQjdJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMV3hwYm1VZ1kyOXVjMmx6ZEdWdWRDMXlaWFIxY201Y2JseDBhV1lnS0NGb1lYTlViMU4wY21sdVoxUmhaeWtnZTF4dVhIUmNkSEpsZEhWeWJpQm1ZV3h6WlR0Y2JseDBmVnh1WEhSMGNua2dlMXh1WEhSY2RISmxkSFZ5YmlCR2RXNWpkR2x2YmlnbmNtVjBkWEp1SUdaMWJtTjBhVzl1S2lncElIdDlKeWtvS1R0Y2JseDBmU0JqWVhSamFDQW9aU2tnZTF4dVhIUjlYRzU5TzF4dWRtRnlJR2RsYm1WeVlYUnZja1oxYm1NZ1BTQm5aWFJIWlc1bGNtRjBiM0pHZFc1aktDazdYRzUyWVhJZ1IyVnVaWEpoZEc5eVJuVnVZM1JwYjI0Z1BTQm5aWFJRY205MGJ5QW1KaUJuWlc1bGNtRjBiM0pHZFc1aklEOGdaMlYwVUhKdmRHOG9aMlZ1WlhKaGRHOXlSblZ1WXlrZ09pQm1ZV3h6WlR0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQnBjMGRsYm1WeVlYUnZja1oxYm1OMGFXOXVLR1p1S1NCN1hHNWNkR2xtSUNoMGVYQmxiMllnWm00Z0lUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JseDBYSFJ5WlhSMWNtNGdabUZzYzJVN1hHNWNkSDFjYmx4MGFXWWdLR2x6Um01U1pXZGxlQzUwWlhOMEtHWnVWRzlUZEhJdVkyRnNiQ2htYmlrcEtTQjdYRzVjZEZ4MGNtVjBkWEp1SUhSeWRXVTdYRzVjZEgxY2JseDBhV1lnS0NGb1lYTlViMU4wY21sdVoxUmhaeWtnZTF4dVhIUmNkSFpoY2lCemRISWdQU0IwYjFOMGNpNWpZV3hzS0dadUtUdGNibHgwWEhSeVpYUjFjbTRnYzNSeUlEMDlQU0FuVzI5aWFtVmpkQ0JIWlc1bGNtRjBiM0pHZFc1amRHbHZibDBuTzF4dVhIUjlYRzVjZEhKbGRIVnliaUJuWlhSUWNtOTBieUFtSmlCblpYUlFjbTkwYnlobWJpa2dQVDA5SUVkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1TzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1THlvZ2FIUjBjRG92TDNkM2R5NWxZMjFoTFdsdWRHVnlibUYwYVc5dVlXd3ViM0puTDJWamJXRXRNall5THpZdU1DOGpjMlZqTFc1MWJXSmxjaTVwYzI1aGJpQXFMMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1SUdselRtRk9LSFpoYkhWbEtTQjdYRzVjZEhKbGRIVnliaUIyWVd4MVpTQWhQVDBnZG1Gc2RXVTdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWTJGc2JFSnBibVFnUFNCeVpYRjFhWEpsS0NkallXeHNMV0pwYm1RbktUdGNiblpoY2lCa1pXWnBibVVnUFNCeVpYRjFhWEpsS0Nka1pXWnBibVV0Y0hKdmNHVnlkR2xsY3ljcE8xeHVYRzUyWVhJZ2FXMXdiR1Z0Wlc1MFlYUnBiMjRnUFNCeVpYRjFhWEpsS0NjdUwybHRjR3hsYldWdWRHRjBhVzl1SnlrN1hHNTJZWElnWjJWMFVHOXNlV1pwYkd3Z1BTQnlaWEYxYVhKbEtDY3VMM0J2YkhsbWFXeHNKeWs3WEc1MllYSWdjMmhwYlNBOUlISmxjWFZwY21Vb0p5NHZjMmhwYlNjcE8xeHVYRzUyWVhJZ2NHOXNlV1pwYkd3Z1BTQmpZV3hzUW1sdVpDaG5aWFJRYjJ4NVptbHNiQ2dwTENCT2RXMWlaWElwTzF4dVhHNHZLaUJvZEhSd09pOHZkM2QzTG1WamJXRXRhVzUwWlhKdVlYUnBiMjVoYkM1dmNtY3ZaV050WVMweU5qSXZOaTR3THlOelpXTXRiblZ0WW1WeUxtbHpibUZ1SUNvdlhHNWNibVJsWm1sdVpTaHdiMng1Wm1sc2JDd2dlMXh1WEhSblpYUlFiMng1Wm1sc2JEb2daMlYwVUc5c2VXWnBiR3dzWEc1Y2RHbHRjR3hsYldWdWRHRjBhVzl1T2lCcGJYQnNaVzFsYm5SaGRHbHZiaXhjYmx4MGMyaHBiVG9nYzJocGJWeHVmU2s3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2NHOXNlV1pwYkd3N1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCcGJYQnNaVzFsYm5SaGRHbHZiaUE5SUhKbGNYVnBjbVVvSnk0dmFXMXdiR1Z0Wlc1MFlYUnBiMjRuS1R0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpQm5aWFJRYjJ4NVptbHNiQ2dwSUh0Y2JseDBhV1lnS0U1MWJXSmxjaTVwYzA1aFRpQW1KaUJPZFcxaVpYSXVhWE5PWVU0b1RtRk9LU0FtSmlBaFRuVnRZbVZ5TG1selRtRk9LQ2RoSnlrcElIdGNibHgwWEhSeVpYUjFjbTRnVG5WdFltVnlMbWx6VG1GT08xeHVYSFI5WEc1Y2RISmxkSFZ5YmlCcGJYQnNaVzFsYm5SaGRHbHZianRjYm4wN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCa1pXWnBibVVnUFNCeVpYRjFhWEpsS0Nka1pXWnBibVV0Y0hKdmNHVnlkR2xsY3ljcE8xeHVkbUZ5SUdkbGRGQnZiSGxtYVd4c0lEMGdjbVZ4ZFdseVpTZ25MaTl3YjJ4NVptbHNiQ2NwTzF4dVhHNHZLaUJvZEhSd09pOHZkM2QzTG1WamJXRXRhVzUwWlhKdVlYUnBiMjVoYkM1dmNtY3ZaV050WVMweU5qSXZOaTR3THlOelpXTXRiblZ0WW1WeUxtbHpibUZ1SUNvdlhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdjMmhwYlU1MWJXSmxja2x6VG1GT0tDa2dlMXh1WEhSMllYSWdjRzlzZVdacGJHd2dQU0JuWlhSUWIyeDVabWxzYkNncE8xeHVYSFJrWldacGJtVW9UblZ0WW1WeUxDQjdJR2x6VG1GT09pQndiMng1Wm1sc2JDQjlMQ0I3WEc1Y2RGeDBhWE5PWVU0NklHWjFibU4wYVc5dUlIUmxjM1JKYzA1aFRpZ3BJSHRjYmx4MFhIUmNkSEpsZEhWeWJpQk9kVzFpWlhJdWFYTk9ZVTRnSVQwOUlIQnZiSGxtYVd4c08xeHVYSFJjZEgxY2JseDBmU2s3WEc1Y2RISmxkSFZ5YmlCd2IyeDVabWxzYkR0Y2JuMDdYRzRpTENJbmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQm1iM0pGWVdOb0lEMGdjbVZ4ZFdseVpTZ25abTl5WldGamFDY3BPMXh1ZG1GeUlHRjJZV2xzWVdKc1pWUjVjR1ZrUVhKeVlYbHpJRDBnY21WeGRXbHlaU2duWVhaaGFXeGhZbXhsTFhSNWNHVmtMV0Z5Y21GNWN5Y3BPMXh1ZG1GeUlHTmhiR3hDYjNWdVpDQTlJSEpsY1hWcGNtVW9KMk5oYkd3dFltbHVaQzlqWVd4c1FtOTFibVFuS1R0Y2JseHVkbUZ5SUNSMGIxTjBjbWx1WnlBOUlHTmhiR3hDYjNWdVpDZ25UMkpxWldOMExuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5Y3BPMXh1ZG1GeUlHaGhjMU41YldKdmJITWdQU0J5WlhGMWFYSmxLQ2RvWVhNdGMzbHRZbTlzY3ljcEtDazdYRzUyWVhJZ2FHRnpWRzlUZEhKcGJtZFVZV2NnUFNCb1lYTlRlVzFpYjJ4eklDWW1JSFI1Y0dWdlppQlRlVzFpYjJ3dWRHOVRkSEpwYm1kVVlXY2dQVDA5SUNkemVXMWliMnduTzF4dVhHNTJZWElnZEhsd1pXUkJjbkpoZVhNZ1BTQmhkbUZwYkdGaWJHVlVlWEJsWkVGeWNtRjVjeWdwTzF4dVhHNTJZWElnSkdsdVpHVjRUMllnUFNCallXeHNRbTkxYm1Rb0owRnljbUY1TG5CeWIzUnZkSGx3WlM1cGJtUmxlRTltSnl3Z2RISjFaU2tnZkh3Z1puVnVZM1JwYjI0Z2FXNWtaWGhQWmloaGNuSmhlU3dnZG1Gc2RXVXBJSHRjYmx4MFptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQmhjbkpoZVM1c1pXNW5kR2c3SUdrZ0t6MGdNU2tnZTF4dVhIUmNkR2xtSUNoaGNuSmhlVnRwWFNBOVBUMGdkbUZzZFdVcElIdGNibHgwWEhSY2RISmxkSFZ5YmlCcE8xeHVYSFJjZEgxY2JseDBmVnh1WEhSeVpYUjFjbTRnTFRFN1hHNTlPMXh1ZG1GeUlDUnpiR2xqWlNBOUlHTmhiR3hDYjNWdVpDZ25VM1J5YVc1bkxuQnliM1J2ZEhsd1pTNXpiR2xqWlNjcE8xeHVkbUZ5SUhSdlUzUnlWR0ZuY3lBOUlIdDlPMXh1ZG1GeUlHZFBVRVFnUFNCeVpYRjFhWEpsS0NkbGN5MWhZbk4wY21GamRDOW9aV3h3WlhKekwyZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y2ljcE8xeHVkbUZ5SUdkbGRGQnliM1J2ZEhsd1pVOW1JRDBnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bU95QXZMeUJ5WlhGMWFYSmxLQ2RuWlhSd2NtOTBiM1I1Y0dWdlppY3BPMXh1YVdZZ0tHaGhjMVJ2VTNSeWFXNW5WR0ZuSUNZbUlHZFBVRVFnSmlZZ1oyVjBVSEp2ZEc5MGVYQmxUMllwSUh0Y2JseDBabTl5UldGamFDaDBlWEJsWkVGeWNtRjVjeXdnWm5WdVkzUnBiMjRnS0hSNWNHVmtRWEp5WVhrcElIdGNibHgwWEhSMllYSWdZWEp5SUQwZ2JtVjNJR2RzYjJKaGJGdDBlWEJsWkVGeWNtRjVYU2dwTzF4dVhIUmNkR2xtSUNnaEtGTjViV0p2YkM1MGIxTjBjbWx1WjFSaFp5QnBiaUJoY25JcEtTQjdYRzVjZEZ4MFhIUjBhSEp2ZHlCdVpYY2dSWFpoYkVWeWNtOXlLQ2QwYUdseklHVnVaMmx1WlNCb1lYTWdjM1Z3Y0c5eWRDQm1iM0lnVTNsdFltOXNMblJ2VTNSeWFXNW5WR0ZuTENCaWRYUWdKeUFySUhSNWNHVmtRWEp5WVhrZ0t5QW5JR1J2WlhNZ2JtOTBJR2hoZG1VZ2RHaGxJSEJ5YjNCbGNuUjVJU0JRYkdWaGMyVWdjbVZ3YjNKMElIUm9hWE11SnlrN1hHNWNkRngwZlZ4dVhIUmNkSFpoY2lCd2NtOTBieUE5SUdkbGRGQnliM1J2ZEhsd1pVOW1LR0Z5Y2lrN1hHNWNkRngwZG1GeUlHUmxjMk55YVhCMGIzSWdQU0JuVDFCRUtIQnliM1J2TENCVGVXMWliMnd1ZEc5VGRISnBibWRVWVdjcE8xeHVYSFJjZEdsbUlDZ2haR1Z6WTNKcGNIUnZjaWtnZTF4dVhIUmNkRngwZG1GeUlITjFjR1Z5VUhKdmRHOGdQU0JuWlhSUWNtOTBiM1I1Y0dWUFppaHdjbTkwYnlrN1hHNWNkRngwWEhSa1pYTmpjbWx3ZEc5eUlEMGdaMDlRUkNoemRYQmxjbEJ5YjNSdkxDQlRlVzFpYjJ3dWRHOVRkSEpwYm1kVVlXY3BPMXh1WEhSY2RIMWNibHgwWEhSMGIxTjBjbFJoWjNOYmRIbHdaV1JCY25KaGVWMGdQU0JrWlhOamNtbHdkRzl5TG1kbGREdGNibHgwZlNrN1hHNTlYRzVjYm5aaGNpQjBjbmxVZVhCbFpFRnljbUY1Y3lBOUlHWjFibU4wYVc5dUlIUnllVUZzYkZSNWNHVmtRWEp5WVhsektIWmhiSFZsS1NCN1hHNWNkSFpoY2lCaGJubFVjblZsSUQwZ1ptRnNjMlU3WEc1Y2RHWnZja1ZoWTJnb2RHOVRkSEpVWVdkekxDQm1kVzVqZEdsdmJpQW9aMlYwZEdWeUxDQjBlWEJsWkVGeWNtRjVLU0I3WEc1Y2RGeDBhV1lnS0NGaGJubFVjblZsS1NCN1hHNWNkRngwWEhSMGNua2dlMXh1WEhSY2RGeDBYSFJoYm5sVWNuVmxJRDBnWjJWMGRHVnlMbU5oYkd3b2RtRnNkV1VwSUQwOVBTQjBlWEJsWkVGeWNtRjVPMXh1WEhSY2RGeDBmU0JqWVhSamFDQW9aU2tnZXlBdktpb3ZJSDFjYmx4MFhIUjlYRzVjZEgwcE8xeHVYSFJ5WlhSMWNtNGdZVzU1VkhKMVpUdGNibjA3WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z2FYTlVlWEJsWkVGeWNtRjVLSFpoYkhWbEtTQjdYRzVjZEdsbUlDZ2hkbUZzZFdVZ2ZId2dkSGx3Wlc5bUlIWmhiSFZsSUNFOVBTQW5iMkpxWldOMEp5a2dleUJ5WlhSMWNtNGdabUZzYzJVN0lIMWNibHgwYVdZZ0tDRm9ZWE5VYjFOMGNtbHVaMVJoWnlrZ2UxeHVYSFJjZEhaaGNpQjBZV2NnUFNBa2MyeHBZMlVvSkhSdlUzUnlhVzVuS0haaGJIVmxLU3dnT0N3Z0xURXBPMXh1WEhSY2RISmxkSFZ5YmlBa2FXNWtaWGhQWmloMGVYQmxaRUZ5Y21GNWN5d2dkR0ZuS1NBK0lDMHhPMXh1WEhSOVhHNWNkR2xtSUNnaFowOVFSQ2tnZXlCeVpYUjFjbTRnWm1Gc2MyVTdJSDFjYmx4MGNtVjBkWEp1SUhSeWVWUjVjR1ZrUVhKeVlYbHpLSFpoYkhWbEtUdGNibjA3WEc0aUxDSW5kWE5sSUhOMGNtbGpkQ2M3WEc1Y2JuWmhjaUJ1ZFcxaVpYSkpjMDVoVGlBOUlHWjFibU4wYVc5dUlDaDJZV3gxWlNrZ2UxeHVYSFJ5WlhSMWNtNGdkbUZzZFdVZ0lUMDlJSFpoYkhWbE8xeHVmVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCcGN5aGhMQ0JpS1NCN1hHNWNkR2xtSUNoaElEMDlQU0F3SUNZbUlHSWdQVDA5SURBcElIdGNibHgwWEhSeVpYUjFjbTRnTVNBdklHRWdQVDA5SURFZ0x5QmlPMXh1WEhSOVhHNWNkR2xtSUNoaElEMDlQU0JpS1NCN1hHNWNkRngwY21WMGRYSnVJSFJ5ZFdVN1hHNWNkSDFjYmx4MGFXWWdLRzUxYldKbGNrbHpUbUZPS0dFcElDWW1JRzUxYldKbGNrbHpUbUZPS0dJcEtTQjdYRzVjZEZ4MGNtVjBkWEp1SUhSeWRXVTdYRzVjZEgxY2JseDBjbVYwZFhKdUlHWmhiSE5sTzF4dWZUdGNibHh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdaR1ZtYVc1bElEMGdjbVZ4ZFdseVpTZ25aR1ZtYVc1bExYQnliM0JsY25ScFpYTW5LVHRjYm5aaGNpQmpZV3hzUW1sdVpDQTlJSEpsY1hWcGNtVW9KMk5oYkd3dFltbHVaQ2NwTzF4dVhHNTJZWElnYVcxd2JHVnRaVzUwWVhScGIyNGdQU0J5WlhGMWFYSmxLQ2N1TDJsdGNHeGxiV1Z1ZEdGMGFXOXVKeWs3WEc1MllYSWdaMlYwVUc5c2VXWnBiR3dnUFNCeVpYRjFhWEpsS0NjdUwzQnZiSGxtYVd4c0p5azdYRzUyWVhJZ2MyaHBiU0E5SUhKbGNYVnBjbVVvSnk0dmMyaHBiU2NwTzF4dVhHNTJZWElnY0c5c2VXWnBiR3dnUFNCallXeHNRbWx1WkNoblpYUlFiMng1Wm1sc2JDZ3BMQ0JQWW1wbFkzUXBPMXh1WEc1a1pXWnBibVVvY0c5c2VXWnBiR3dzSUh0Y2JseDBaMlYwVUc5c2VXWnBiR3c2SUdkbGRGQnZiSGxtYVd4c0xGeHVYSFJwYlhCc1pXMWxiblJoZEdsdmJqb2dhVzF3YkdWdFpXNTBZWFJwYjI0c1hHNWNkSE5vYVcwNklITm9hVzFjYm4wcE8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSEJ2YkhsbWFXeHNPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdhVzF3YkdWdFpXNTBZWFJwYjI0Z1BTQnlaWEYxYVhKbEtDY3VMMmx0Y0d4bGJXVnVkR0YwYVc5dUp5azdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnWjJWMFVHOXNlV1pwYkd3b0tTQjdYRzVjZEhKbGRIVnliaUIwZVhCbGIyWWdUMkpxWldOMExtbHpJRDA5UFNBblpuVnVZM1JwYjI0bklEOGdUMkpxWldOMExtbHpJRG9nYVcxd2JHVnRaVzUwWVhScGIyNDdYRzU5TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWjJWMFVHOXNlV1pwYkd3Z1BTQnlaWEYxYVhKbEtDY3VMM0J2YkhsbWFXeHNKeWs3WEc1MllYSWdaR1ZtYVc1bElEMGdjbVZ4ZFdseVpTZ25aR1ZtYVc1bExYQnliM0JsY25ScFpYTW5LVHRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCemFHbHRUMkpxWldOMFNYTW9LU0I3WEc1Y2RIWmhjaUJ3YjJ4NVptbHNiQ0E5SUdkbGRGQnZiSGxtYVd4c0tDazdYRzVjZEdSbFptbHVaU2hQWW1wbFkzUXNJSHNnYVhNNklIQnZiSGxtYVd4c0lIMHNJSHRjYmx4MFhIUnBjem9nWm5WdVkzUnBiMjRnZEdWemRFOWlhbVZqZEVsektDa2dlMXh1WEhSY2RGeDBjbVYwZFhKdUlFOWlhbVZqZEM1cGN5QWhQVDBnY0c5c2VXWnBiR3c3WEc1Y2RGeDBmVnh1WEhSOUtUdGNibHgwY21WMGRYSnVJSEJ2YkhsbWFXeHNPMXh1ZlR0Y2JpSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVkbUZ5SUd0bGVYTlRhR2x0TzF4dWFXWWdLQ0ZQWW1wbFkzUXVhMlY1Y3lrZ2UxeHVYSFF2THlCdGIyUnBabWxsWkNCbWNtOXRJR2gwZEhCek9pOHZaMmwwYUhWaUxtTnZiUzlsY3kxemFHbHRjeTlsY3pVdGMyaHBiVnh1WEhSMllYSWdhR0Z6SUQwZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1b1lYTlBkMjVRY205d1pYSjBlVHRjYmx4MGRtRnlJSFJ2VTNSeUlEMGdUMkpxWldOMExuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp6dGNibHgwZG1GeUlHbHpRWEpuY3lBOUlISmxjWFZwY21Vb0p5NHZhWE5CY21kMWJXVnVkSE1uS1RzZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJHbHVaU0JuYkc5aVlXd3RjbVZ4ZFdseVpWeHVYSFIyWVhJZ2FYTkZiblZ0WlhKaFlteGxJRDBnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzV3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlR0Y2JseDBkbUZ5SUdoaGMwUnZiblJGYm5WdFFuVm5JRDBnSVdselJXNTFiV1Z5WVdKc1pTNWpZV3hzS0hzZ2RHOVRkSEpwYm1jNklHNTFiR3dnZlN3Z0ozUnZVM1J5YVc1bkp5azdYRzVjZEhaaGNpQm9ZWE5RY205MGIwVnVkVzFDZFdjZ1BTQnBjMFZ1ZFcxbGNtRmliR1V1WTJGc2JDaG1kVzVqZEdsdmJpQW9LU0I3ZlN3Z0ozQnliM1J2ZEhsd1pTY3BPMXh1WEhSMllYSWdaRzl1ZEVWdWRXMXpJRDBnVzF4dVhIUmNkQ2QwYjFOMGNtbHVaeWNzWEc1Y2RGeDBKM1J2VEc5allXeGxVM1J5YVc1bkp5eGNibHgwWEhRbmRtRnNkV1ZQWmljc1hHNWNkRngwSjJoaGMwOTNibEJ5YjNCbGNuUjVKeXhjYmx4MFhIUW5hWE5RY205MGIzUjVjR1ZQWmljc1hHNWNkRngwSjNCeWIzQmxjblI1U1hORmJuVnRaWEpoWW14bEp5eGNibHgwWEhRblkyOXVjM1J5ZFdOMGIzSW5YRzVjZEYwN1hHNWNkSFpoY2lCbGNYVmhiSE5EYjI1emRISjFZM1J2Y2xCeWIzUnZkSGx3WlNBOUlHWjFibU4wYVc5dUlDaHZLU0I3WEc1Y2RGeDBkbUZ5SUdOMGIzSWdQU0J2TG1OdmJuTjBjblZqZEc5eU8xeHVYSFJjZEhKbGRIVnliaUJqZEc5eUlDWW1JR04wYjNJdWNISnZkRzkwZVhCbElEMDlQU0J2TzF4dVhIUjlPMXh1WEhSMllYSWdaWGhqYkhWa1pXUkxaWGx6SUQwZ2UxeHVYSFJjZENSaGNIQnNhV05oZEdsdmJrTmhZMmhsT2lCMGNuVmxMRnh1WEhSY2RDUmpiMjV6YjJ4bE9pQjBjblZsTEZ4dVhIUmNkQ1JsZUhSbGNtNWhiRG9nZEhKMVpTeGNibHgwWEhRa1puSmhiV1U2SUhSeWRXVXNYRzVjZEZ4MEpHWnlZVzFsUld4bGJXVnVkRG9nZEhKMVpTeGNibHgwWEhRa1puSmhiV1Z6T2lCMGNuVmxMRnh1WEhSY2RDUnBibTVsY2tobGFXZG9kRG9nZEhKMVpTeGNibHgwWEhRa2FXNXVaWEpYYVdSMGFEb2dkSEoxWlN4Y2JseDBYSFFrYjI1dGIzcG1kV3hzYzJOeVpXVnVZMmhoYm1kbE9pQjBjblZsTEZ4dVhIUmNkQ1J2Ym0xdmVtWjFiR3h6WTNKbFpXNWxjbkp2Y2pvZ2RISjFaU3hjYmx4MFhIUWtiM1YwWlhKSVpXbG5hSFE2SUhSeWRXVXNYRzVjZEZ4MEpHOTFkR1Z5VjJsa2RHZzZJSFJ5ZFdVc1hHNWNkRngwSkhCaFoyVllUMlptYzJWME9pQjBjblZsTEZ4dVhIUmNkQ1J3WVdkbFdVOW1abk5sZERvZ2RISjFaU3hjYmx4MFhIUWtjR0Z5Wlc1ME9pQjBjblZsTEZ4dVhIUmNkQ1J6WTNKdmJHeE1aV1owT2lCMGNuVmxMRnh1WEhSY2RDUnpZM0p2Ykd4VWIzQTZJSFJ5ZFdVc1hHNWNkRngwSkhOamNtOXNiRmc2SUhSeWRXVXNYRzVjZEZ4MEpITmpjbTlzYkZrNklIUnlkV1VzWEc1Y2RGeDBKSE5sYkdZNklIUnlkV1VzWEc1Y2RGeDBKSGRsWW10cGRFbHVaR1Y0WldSRVFqb2dkSEoxWlN4Y2JseDBYSFFrZDJWaWEybDBVM1J2Y21GblpVbHVabTg2SUhSeWRXVXNYRzVjZEZ4MEpIZHBibVJ2ZHpvZ2RISjFaVnh1WEhSOU8xeHVYSFIyWVhJZ2FHRnpRWFYwYjIxaGRHbHZia1Z4ZFdGc2FYUjVRblZuSUQwZ0tHWjFibU4wYVc5dUlDZ3BJSHRjYmx4MFhIUXZLaUJuYkc5aVlXd2dkMmx1Wkc5M0lDb3ZYRzVjZEZ4MGFXWWdLSFI1Y0dWdlppQjNhVzVrYjNjZ1BUMDlJQ2QxYm1SbFptbHVaV1FuS1NCN0lISmxkSFZ5YmlCbVlXeHpaVHNnZlZ4dVhIUmNkR1p2Y2lBb2RtRnlJR3NnYVc0Z2QybHVaRzkzS1NCN1hHNWNkRngwWEhSMGNua2dlMXh1WEhSY2RGeDBYSFJwWmlBb0lXVjRZMngxWkdWa1MyVjVjMXNuSkNjZ0t5QnJYU0FtSmlCb1lYTXVZMkZzYkNoM2FXNWtiM2NzSUdzcElDWW1JSGRwYm1SdmQxdHJYU0FoUFQwZ2JuVnNiQ0FtSmlCMGVYQmxiMllnZDJsdVpHOTNXMnRkSUQwOVBTQW5iMkpxWldOMEp5a2dlMXh1WEhSY2RGeDBYSFJjZEhSeWVTQjdYRzVjZEZ4MFhIUmNkRngwWEhSbGNYVmhiSE5EYjI1emRISjFZM1J2Y2xCeWIzUnZkSGx3WlNoM2FXNWtiM2RiYTEwcE8xeHVYSFJjZEZ4MFhIUmNkSDBnWTJGMFkyZ2dLR1VwSUh0Y2JseDBYSFJjZEZ4MFhIUmNkSEpsZEhWeWJpQjBjblZsTzF4dVhIUmNkRngwWEhSY2RIMWNibHgwWEhSY2RGeDBmVnh1WEhSY2RGeDBmU0JqWVhSamFDQW9aU2tnZTF4dVhIUmNkRngwWEhSeVpYUjFjbTRnZEhKMVpUdGNibHgwWEhSY2RIMWNibHgwWEhSOVhHNWNkRngwY21WMGRYSnVJR1poYkhObE8xeHVYSFI5S0NrcE8xeHVYSFIyWVhJZ1pYRjFZV3h6UTI5dWMzUnlkV04wYjNKUWNtOTBiM1I1Y0dWSlprNXZkRUoxWjJkNUlEMGdablZ1WTNScGIyNGdLRzhwSUh0Y2JseDBYSFF2S2lCbmJHOWlZV3dnZDJsdVpHOTNJQ292WEc1Y2RGeDBhV1lnS0hSNWNHVnZaaUIzYVc1a2IzY2dQVDA5SUNkMWJtUmxabWx1WldRbklIeDhJQ0ZvWVhOQmRYUnZiV0YwYVc5dVJYRjFZV3hwZEhsQ2RXY3BJSHRjYmx4MFhIUmNkSEpsZEhWeWJpQmxjWFZoYkhORGIyNXpkSEoxWTNSdmNsQnliM1J2ZEhsd1pTaHZLVHRjYmx4MFhIUjlYRzVjZEZ4MGRISjVJSHRjYmx4MFhIUmNkSEpsZEhWeWJpQmxjWFZoYkhORGIyNXpkSEoxWTNSdmNsQnliM1J2ZEhsd1pTaHZLVHRjYmx4MFhIUjlJR05oZEdOb0lDaGxLU0I3WEc1Y2RGeDBYSFJ5WlhSMWNtNGdabUZzYzJVN1hHNWNkRngwZlZ4dVhIUjlPMXh1WEc1Y2RHdGxlWE5UYUdsdElEMGdablZ1WTNScGIyNGdhMlY1Y3lodlltcGxZM1FwSUh0Y2JseDBYSFIyWVhJZ2FYTlBZbXBsWTNRZ1BTQnZZbXBsWTNRZ0lUMDlJRzUxYkd3Z0ppWWdkSGx3Wlc5bUlHOWlhbVZqZENBOVBUMGdKMjlpYW1WamRDYzdYRzVjZEZ4MGRtRnlJR2x6Um5WdVkzUnBiMjRnUFNCMGIxTjBjaTVqWVd4c0tHOWlhbVZqZENrZ1BUMDlJQ2RiYjJKcVpXTjBJRVoxYm1OMGFXOXVYU2M3WEc1Y2RGeDBkbUZ5SUdselFYSm5kVzFsYm5SeklEMGdhWE5CY21kektHOWlhbVZqZENrN1hHNWNkRngwZG1GeUlHbHpVM1J5YVc1bklEMGdhWE5QWW1wbFkzUWdKaVlnZEc5VGRISXVZMkZzYkNodlltcGxZM1FwSUQwOVBTQW5XMjlpYW1WamRDQlRkSEpwYm1kZEp6dGNibHgwWEhSMllYSWdkR2hsUzJWNWN5QTlJRnRkTzF4dVhHNWNkRngwYVdZZ0tDRnBjMDlpYW1WamRDQW1KaUFoYVhOR2RXNWpkR2x2YmlBbUppQWhhWE5CY21kMWJXVnVkSE1wSUh0Y2JseDBYSFJjZEhSb2NtOTNJRzVsZHlCVWVYQmxSWEp5YjNJb0owOWlhbVZqZEM1clpYbHpJR05oYkd4bFpDQnZiaUJoSUc1dmJpMXZZbXBsWTNRbktUdGNibHgwWEhSOVhHNWNibHgwWEhSMllYSWdjMnRwY0ZCeWIzUnZJRDBnYUdGelVISnZkRzlGYm5WdFFuVm5JQ1ltSUdselJuVnVZM1JwYjI0N1hHNWNkRngwYVdZZ0tHbHpVM1J5YVc1bklDWW1JRzlpYW1WamRDNXNaVzVuZEdnZ1BpQXdJQ1ltSUNGb1lYTXVZMkZzYkNodlltcGxZM1FzSURBcEtTQjdYRzVjZEZ4MFhIUm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJRzlpYW1WamRDNXNaVzVuZEdnN0lDc3JhU2tnZTF4dVhIUmNkRngwWEhSMGFHVkxaWGx6TG5CMWMyZ29VM1J5YVc1bktHa3BLVHRjYmx4MFhIUmNkSDFjYmx4MFhIUjlYRzVjYmx4MFhIUnBaaUFvYVhOQmNtZDFiV1Z1ZEhNZ0ppWWdiMkpxWldOMExteGxibWQwYUNBK0lEQXBJSHRjYmx4MFhIUmNkR1p2Y2lBb2RtRnlJR29nUFNBd095QnFJRHdnYjJKcVpXTjBMbXhsYm1kMGFEc2dLeXRxS1NCN1hHNWNkRngwWEhSY2RIUm9aVXRsZVhNdWNIVnphQ2hUZEhKcGJtY29haWtwTzF4dVhIUmNkRngwZlZ4dVhIUmNkSDBnWld4elpTQjdYRzVjZEZ4MFhIUm1iM0lnS0haaGNpQnVZVzFsSUdsdUlHOWlhbVZqZENrZ2UxeHVYSFJjZEZ4MFhIUnBaaUFvSVNoemEybHdVSEp2ZEc4Z0ppWWdibUZ0WlNBOVBUMGdKM0J5YjNSdmRIbHdaU2NwSUNZbUlHaGhjeTVqWVd4c0tHOWlhbVZqZEN3Z2JtRnRaU2twSUh0Y2JseDBYSFJjZEZ4MFhIUjBhR1ZMWlhsekxuQjFjMmdvVTNSeWFXNW5LRzVoYldVcEtUdGNibHgwWEhSY2RGeDBmVnh1WEhSY2RGeDBmVnh1WEhSY2RIMWNibHh1WEhSY2RHbG1JQ2hvWVhORWIyNTBSVzUxYlVKMVp5a2dlMXh1WEhSY2RGeDBkbUZ5SUhOcmFYQkRiMjV6ZEhKMVkzUnZjaUE5SUdWeGRXRnNjME52Ym5OMGNuVmpkRzl5VUhKdmRHOTBlWEJsU1daT2IzUkNkV2RuZVNodlltcGxZM1FwTzF4dVhHNWNkRngwWEhSbWIzSWdLSFpoY2lCcklEMGdNRHNnYXlBOElHUnZiblJGYm5WdGN5NXNaVzVuZEdnN0lDc3JheWtnZTF4dVhIUmNkRngwWEhScFppQW9JU2h6YTJsd1EyOXVjM1J5ZFdOMGIzSWdKaVlnWkc5dWRFVnVkVzF6VzJ0ZElEMDlQU0FuWTI5dWMzUnlkV04wYjNJbktTQW1KaUJvWVhNdVkyRnNiQ2h2WW1wbFkzUXNJR1J2Ym5SRmJuVnRjMXRyWFNrcElIdGNibHgwWEhSY2RGeDBYSFIwYUdWTFpYbHpMbkIxYzJnb1pHOXVkRVZ1ZFcxelcydGRLVHRjYmx4MFhIUmNkRngwZlZ4dVhIUmNkRngwZlZ4dVhIUmNkSDFjYmx4MFhIUnlaWFIxY200Z2RHaGxTMlY1Y3p0Y2JseDBmVHRjYm4xY2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2EyVjVjMU5vYVcwN1hHNGlMQ0luZFhObElITjBjbWxqZENjN1hHNWNiblpoY2lCemJHbGpaU0E5SUVGeWNtRjVMbkJ5YjNSdmRIbHdaUzV6YkdsalpUdGNiblpoY2lCcGMwRnlaM01nUFNCeVpYRjFhWEpsS0NjdUwybHpRWEpuZFcxbGJuUnpKeWs3WEc1Y2JuWmhjaUJ2Y21sblMyVjVjeUE5SUU5aWFtVmpkQzVyWlhsek8xeHVkbUZ5SUd0bGVYTlRhR2x0SUQwZ2IzSnBaMHRsZVhNZ1B5Qm1kVzVqZEdsdmJpQnJaWGx6S0c4cElIc2djbVYwZFhKdUlHOXlhV2RMWlhsektHOHBPeUI5SURvZ2NtVnhkV2x5WlNnbkxpOXBiWEJzWlcxbGJuUmhkR2x2YmljcE8xeHVYRzUyWVhJZ2IzSnBaMmx1WVd4TFpYbHpJRDBnVDJKcVpXTjBMbXRsZVhNN1hHNWNibXRsZVhOVGFHbHRMbk5vYVcwZ1BTQm1kVzVqZEdsdmJpQnphR2x0VDJKcVpXTjBTMlY1Y3lncElIdGNibHgwYVdZZ0tFOWlhbVZqZEM1clpYbHpLU0I3WEc1Y2RGeDBkbUZ5SUd0bGVYTlhiM0pyYzFkcGRHaEJjbWQxYldWdWRITWdQU0FvWm5WdVkzUnBiMjRnS0NrZ2UxeHVYSFJjZEZ4MEx5OGdVMkZtWVhKcElEVXVNQ0JpZFdkY2JseDBYSFJjZEhaaGNpQmhjbWR6SUQwZ1QySnFaV04wTG10bGVYTW9ZWEpuZFcxbGJuUnpLVHRjYmx4MFhIUmNkSEpsZEhWeWJpQmhjbWR6SUNZbUlHRnlaM011YkdWdVozUm9JRDA5UFNCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvTzF4dVhIUmNkSDBvTVN3Z01pa3BPMXh1WEhSY2RHbG1JQ2doYTJWNWMxZHZjbXR6VjJsMGFFRnlaM1Z0Wlc1MGN5a2dlMXh1WEhSY2RGeDBUMkpxWldOMExtdGxlWE1nUFNCbWRXNWpkR2x2YmlCclpYbHpLRzlpYW1WamRDa2dleUF2THlCbGMyeHBiblF0WkdsellXSnNaUzFzYVc1bElHWjFibU10Ym1GdFpTMXRZWFJqYUdsdVoxeHVYSFJjZEZ4MFhIUnBaaUFvYVhOQmNtZHpLRzlpYW1WamRDa3BJSHRjYmx4MFhIUmNkRngwWEhSeVpYUjFjbTRnYjNKcFoybHVZV3hMWlhsektITnNhV05sTG1OaGJHd29iMkpxWldOMEtTazdYRzVjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkRngwY21WMGRYSnVJRzl5YVdkcGJtRnNTMlY1Y3lodlltcGxZM1FwTzF4dVhIUmNkRngwZlR0Y2JseDBYSFI5WEc1Y2RIMGdaV3h6WlNCN1hHNWNkRngwVDJKcVpXTjBMbXRsZVhNZ1BTQnJaWGx6VTJocGJUdGNibHgwZlZ4dVhIUnlaWFIxY200Z1QySnFaV04wTG10bGVYTWdmSHdnYTJWNWMxTm9hVzA3WEc1OU8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR3RsZVhOVGFHbHRPMXh1SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdkRzlUZEhJZ1BTQlBZbXBsWTNRdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bk8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJR2x6UVhKbmRXMWxiblJ6S0haaGJIVmxLU0I3WEc1Y2RIWmhjaUJ6ZEhJZ1BTQjBiMU4wY2k1allXeHNLSFpoYkhWbEtUdGNibHgwZG1GeUlHbHpRWEpuY3lBOUlITjBjaUE5UFQwZ0oxdHZZbXBsWTNRZ1FYSm5kVzFsYm5SelhTYzdYRzVjZEdsbUlDZ2hhWE5CY21kektTQjdYRzVjZEZ4MGFYTkJjbWR6SUQwZ2MzUnlJQ0U5UFNBblcyOWlhbVZqZENCQmNuSmhlVjBuSUNZbVhHNWNkRngwWEhSMllXeDFaU0FoUFQwZ2JuVnNiQ0FtSmx4dVhIUmNkRngwZEhsd1pXOW1JSFpoYkhWbElEMDlQU0FuYjJKcVpXTjBKeUFtSmx4dVhIUmNkRngwZEhsd1pXOW1JSFpoYkhWbExteGxibWQwYUNBOVBUMGdKMjUxYldKbGNpY2dKaVpjYmx4MFhIUmNkSFpoYkhWbExteGxibWQwYUNBK1BTQXdJQ1ltWEc1Y2RGeDBYSFIwYjFOMGNpNWpZV3hzS0haaGJIVmxMbU5oYkd4bFpTa2dQVDA5SUNkYmIySnFaV04wSUVaMWJtTjBhVzl1WFNjN1hHNWNkSDFjYmx4MGNtVjBkWEp1SUdselFYSm5jenRjYm4wN1hHNGlMQ0l2THlCemFHbHRJR1p2Y2lCMWMybHVaeUJ3Y205alpYTnpJR2x1SUdKeWIzZHpaWEpjYm5aaGNpQndjbTlqWlhOeklEMGdiVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQjdmVHRjYmx4dUx5OGdZMkZqYUdWa0lHWnliMjBnZDJoaGRHVjJaWElnWjJ4dlltRnNJR2x6SUhCeVpYTmxiblFnYzI4Z2RHaGhkQ0IwWlhOMElISjFibTVsY25NZ2RHaGhkQ0J6ZEhWaUlHbDBYRzR2THlCa2IyNG5kQ0JpY21WaGF5QjBhR2x1WjNNdUlDQkNkWFFnZDJVZ2JtVmxaQ0IwYnlCM2NtRndJR2wwSUdsdUlHRWdkSEo1SUdOaGRHTm9JR2x1SUdOaGMyVWdhWFFnYVhOY2JpOHZJSGR5WVhCd1pXUWdhVzRnYzNSeWFXTjBJRzF2WkdVZ1kyOWtaU0IzYUdsamFDQmtiMlZ6YmlkMElHUmxabWx1WlNCaGJua2daMnh2WW1Gc2N5NGdJRWwwSjNNZ2FXNXphV1JsSUdGY2JpOHZJR1oxYm1OMGFXOXVJR0psWTJGMWMyVWdkSEo1TDJOaGRHTm9aWE1nWkdWdmNIUnBiV2w2WlNCcGJpQmpaWEowWVdsdUlHVnVaMmx1WlhNdVhHNWNiblpoY2lCallXTm9aV1JUWlhSVWFXMWxiM1YwTzF4dWRtRnlJR05oWTJobFpFTnNaV0Z5VkdsdFpXOTFkRHRjYmx4dVpuVnVZM1JwYjI0Z1pHVm1ZWFZzZEZObGRGUnBiVzkxZENncElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjNObGRGUnBiV1Z2ZFhRZ2FHRnpJRzV2ZENCaVpXVnVJR1JsWm1sdVpXUW5LVHRjYm4xY2JtWjFibU4wYVc5dUlHUmxabUYxYkhSRGJHVmhjbFJwYldWdmRYUWdLQ2tnZTF4dUlDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25ZMnhsWVhKVWFXMWxiM1YwSUdoaGN5QnViM1FnWW1WbGJpQmtaV1pwYm1Wa0p5azdYRzU5WEc0b1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lIUnllU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBlWEJsYjJZZ2MyVjBWR2x0Wlc5MWRDQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWTJGamFHVmtVMlYwVkdsdFpXOTFkQ0E5SUhObGRGUnBiV1Z2ZFhRN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVdOb1pXUlRaWFJVYVcxbGIzVjBJRDBnWkdWbVlYVnNkRk5sZEZScGJXOTFkRHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ1kyRmphR1ZrVTJWMFZHbHRaVzkxZENBOUlHUmxabUYxYkhSVFpYUlVhVzF2ZFhRN1hHNGdJQ0FnZlZ4dUlDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwZVhCbGIyWWdZMnhsWVhKVWFXMWxiM1YwSUQwOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpZV05vWldSRGJHVmhjbFJwYldWdmRYUWdQU0JqYkdWaGNsUnBiV1Z2ZFhRN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVdOb1pXUkRiR1ZoY2xScGJXVnZkWFFnUFNCa1pXWmhkV3gwUTJ4bFlYSlVhVzFsYjNWME8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ2ZTQmpZWFJqYUNBb1pTa2dlMXh1SUNBZ0lDQWdJQ0JqWVdOb1pXUkRiR1ZoY2xScGJXVnZkWFFnUFNCa1pXWmhkV3gwUTJ4bFlYSlVhVzFsYjNWME8xeHVJQ0FnSUgxY2JuMGdLQ2twWEc1bWRXNWpkR2x2YmlCeWRXNVVhVzFsYjNWMEtHWjFiaWtnZTF4dUlDQWdJR2xtSUNoallXTm9aV1JUWlhSVWFXMWxiM1YwSUQwOVBTQnpaWFJVYVcxbGIzVjBLU0I3WEc0Z0lDQWdJQ0FnSUM4dmJtOXliV0ZzSUdWdWRtbHliMjFsYm5SeklHbHVJSE5oYm1VZ2MybDBkV0YwYVc5dWMxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2MyVjBWR2x0Wlc5MWRDaG1kVzRzSURBcE8xeHVJQ0FnSUgxY2JpQWdJQ0F2THlCcFppQnpaWFJVYVcxbGIzVjBJSGRoYzI0bmRDQmhkbUZwYkdGaWJHVWdZblYwSUhkaGN5QnNZWFIwWlhJZ1pHVm1hVzVsWkZ4dUlDQWdJR2xtSUNnb1kyRmphR1ZrVTJWMFZHbHRaVzkxZENBOVBUMGdaR1ZtWVhWc2RGTmxkRlJwYlc5MWRDQjhmQ0FoWTJGamFHVmtVMlYwVkdsdFpXOTFkQ2tnSmlZZ2MyVjBWR2x0Wlc5MWRDa2dlMXh1SUNBZ0lDQWdJQ0JqWVdOb1pXUlRaWFJVYVcxbGIzVjBJRDBnYzJWMFZHbHRaVzkxZER0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhObGRGUnBiV1Z2ZFhRb1puVnVMQ0F3S1R0Y2JpQWdJQ0I5WEc0Z0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUNBZ0x5OGdkMmhsYmlCM2FHVnVJSE52YldWaWIyUjVJR2hoY3lCelkzSmxkMlZrSUhkcGRHZ2djMlYwVkdsdFpXOTFkQ0JpZFhRZ2JtOGdTUzVGTGlCdFlXUmtibVZ6YzF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWTJGamFHVmtVMlYwVkdsdFpXOTFkQ2htZFc0c0lEQXBPMXh1SUNBZ0lIMGdZMkYwWTJnb1pTbDdYRzRnSUNBZ0lDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCWGFHVnVJSGRsSUdGeVpTQnBiaUJKTGtVdUlHSjFkQ0IwYUdVZ2MyTnlhWEIwSUdoaGN5QmlaV1Z1SUdWMllXeGxaQ0J6YnlCSkxrVXVJR1J2WlhOdUozUWdkSEoxYzNRZ2RHaGxJR2RzYjJKaGJDQnZZbXBsWTNRZ2QyaGxiaUJqWVd4c1pXUWdibTl5YldGc2JIbGNiaUFnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJqWVdOb1pXUlRaWFJVYVcxbGIzVjBMbU5oYkd3b2JuVnNiQ3dnWm5WdUxDQXdLVHRjYmlBZ0lDQWdJQ0FnZlNCallYUmphQ2hsS1h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUhOaGJXVWdZWE1nWVdKdmRtVWdZblYwSUhkb1pXNGdhWFFuY3lCaElIWmxjbk5wYjI0Z2IyWWdTUzVGTGlCMGFHRjBJRzExYzNRZ2FHRjJaU0IwYUdVZ1oyeHZZbUZzSUc5aWFtVmpkQ0JtYjNJZ0ozUm9hWE1uTENCb2IzQm1kV3hzZVNCdmRYSWdZMjl1ZEdWNGRDQmpiM0p5WldOMElHOTBhR1Z5ZDJselpTQnBkQ0IzYVd4c0lIUm9jbTkzSUdFZ1oyeHZZbUZzSUdWeWNtOXlYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnWTJGamFHVmtVMlYwVkdsdFpXOTFkQzVqWVd4c0tIUm9hWE1zSUdaMWJpd2dNQ2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JseHVmVnh1Wm5WdVkzUnBiMjRnY25WdVEyeGxZWEpVYVcxbGIzVjBLRzFoY210bGNpa2dlMXh1SUNBZ0lHbG1JQ2hqWVdOb1pXUkRiR1ZoY2xScGJXVnZkWFFnUFQwOUlHTnNaV0Z5VkdsdFpXOTFkQ2tnZTF4dUlDQWdJQ0FnSUNBdkwyNXZjbTFoYkNCbGJuWnBjbTl0Wlc1MGN5QnBiaUJ6WVc1bElITnBkSFZoZEdsdmJuTmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHTnNaV0Z5VkdsdFpXOTFkQ2h0WVhKclpYSXBPMXh1SUNBZ0lIMWNiaUFnSUNBdkx5QnBaaUJqYkdWaGNsUnBiV1Z2ZFhRZ2QyRnpiaWQwSUdGMllXbHNZV0pzWlNCaWRYUWdkMkZ6SUd4aGRIUmxjaUJrWldacGJtVmtYRzRnSUNBZ2FXWWdLQ2hqWVdOb1pXUkRiR1ZoY2xScGJXVnZkWFFnUFQwOUlHUmxabUYxYkhSRGJHVmhjbFJwYldWdmRYUWdmSHdnSVdOaFkyaGxaRU5zWldGeVZHbHRaVzkxZENrZ0ppWWdZMnhsWVhKVWFXMWxiM1YwS1NCN1hHNGdJQ0FnSUNBZ0lHTmhZMmhsWkVOc1pXRnlWR2x0Wlc5MWRDQTlJR05zWldGeVZHbHRaVzkxZER0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdOc1pXRnlWR2x0Wlc5MWRDaHRZWEpyWlhJcE8xeHVJQ0FnSUgxY2JpQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQXZMeUIzYUdWdUlIZG9aVzRnYzI5dFpXSnZaSGtnYUdGeklITmpjbVYzWldRZ2QybDBhQ0J6WlhSVWFXMWxiM1YwSUdKMWRDQnVieUJKTGtVdUlHMWhaR1J1WlhOelhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCallXTm9aV1JEYkdWaGNsUnBiV1Z2ZFhRb2JXRnlhMlZ5S1R0Y2JpQWdJQ0I5SUdOaGRHTm9JQ2hsS1h0Y2JpQWdJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJRmRvWlc0Z2QyVWdZWEpsSUdsdUlFa3VSUzRnWW5WMElIUm9aU0J6WTNKcGNIUWdhR0Z6SUdKbFpXNGdaWFpoYkdWa0lITnZJRWt1UlM0Z1pHOWxjMjRuZENBZ2RISjFjM1FnZEdobElHZHNiMkpoYkNCdlltcGxZM1FnZDJobGJpQmpZV3hzWldRZ2JtOXliV0ZzYkhsY2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQmpZV05vWldSRGJHVmhjbFJwYldWdmRYUXVZMkZzYkNodWRXeHNMQ0J0WVhKclpYSXBPMXh1SUNBZ0lDQWdJQ0I5SUdOaGRHTm9JQ2hsS1h0Y2JpQWdJQ0FnSUNBZ0lDQWdJQzh2SUhOaGJXVWdZWE1nWVdKdmRtVWdZblYwSUhkb1pXNGdhWFFuY3lCaElIWmxjbk5wYjI0Z2IyWWdTUzVGTGlCMGFHRjBJRzExYzNRZ2FHRjJaU0IwYUdVZ1oyeHZZbUZzSUc5aWFtVmpkQ0JtYjNJZ0ozUm9hWE1uTENCb2IzQm1kV3hzZVNCdmRYSWdZMjl1ZEdWNGRDQmpiM0p5WldOMElHOTBhR1Z5ZDJselpTQnBkQ0IzYVd4c0lIUm9jbTkzSUdFZ1oyeHZZbUZzSUdWeWNtOXlMbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdVMjl0WlNCMlpYSnphVzl1Y3lCdlppQkpMa1V1SUdoaGRtVWdaR2xtWm1WeVpXNTBJSEoxYkdWeklHWnZjaUJqYkdWaGNsUnBiV1Z2ZFhRZ2RuTWdjMlYwVkdsdFpXOTFkRnh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdOaFkyaGxaRU5zWldGeVZHbHRaVzkxZEM1allXeHNLSFJvYVhNc0lHMWhjbXRsY2lrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNCOVhHNWNibHh1WEc1OVhHNTJZWElnY1hWbGRXVWdQU0JiWFR0Y2JuWmhjaUJrY21GcGJtbHVaeUE5SUdaaGJITmxPMXh1ZG1GeUlHTjFjbkpsYm5SUmRXVjFaVHRjYm5aaGNpQnhkV1YxWlVsdVpHVjRJRDBnTFRFN1hHNWNibVoxYm1OMGFXOXVJR05zWldGdVZYQk9aWGgwVkdsamF5Z3BJSHRjYmlBZ0lDQnBaaUFvSVdSeVlXbHVhVzVuSUh4OElDRmpkWEp5Wlc1MFVYVmxkV1VwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJSDFjYmlBZ0lDQmtjbUZwYm1sdVp5QTlJR1poYkhObE8xeHVJQ0FnSUdsbUlDaGpkWEp5Wlc1MFVYVmxkV1V1YkdWdVozUm9LU0I3WEc0Z0lDQWdJQ0FnSUhGMVpYVmxJRDBnWTNWeWNtVnVkRkYxWlhWbExtTnZibU5oZENoeGRXVjFaU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjWFZsZFdWSmJtUmxlQ0E5SUMweE8xeHVJQ0FnSUgxY2JpQWdJQ0JwWmlBb2NYVmxkV1V1YkdWdVozUm9LU0I3WEc0Z0lDQWdJQ0FnSUdSeVlXbHVVWFZsZFdVb0tUdGNiaUFnSUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdSeVlXbHVVWFZsZFdVb0tTQjdYRzRnSUNBZ2FXWWdLR1J5WVdsdWFXNW5LU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnlianRjYmlBZ0lDQjlYRzRnSUNBZ2RtRnlJSFJwYldWdmRYUWdQU0J5ZFc1VWFXMWxiM1YwS0dOc1pXRnVWWEJPWlhoMFZHbGpheWs3WEc0Z0lDQWdaSEpoYVc1cGJtY2dQU0IwY25WbE8xeHVYRzRnSUNBZ2RtRnlJR3hsYmlBOUlIRjFaWFZsTG14bGJtZDBhRHRjYmlBZ0lDQjNhR2xzWlNoc1pXNHBJSHRjYmlBZ0lDQWdJQ0FnWTNWeWNtVnVkRkYxWlhWbElEMGdjWFZsZFdVN1hHNGdJQ0FnSUNBZ0lIRjFaWFZsSUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDZ3JLM0YxWlhWbFNXNWtaWGdnUENCc1pXNHBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hqZFhKeVpXNTBVWFZsZFdVcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpkWEp5Wlc1MFVYVmxkV1ZiY1hWbGRXVkpibVJsZUYwdWNuVnVLQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnY1hWbGRXVkpibVJsZUNBOUlDMHhPMXh1SUNBZ0lDQWdJQ0JzWlc0Z1BTQnhkV1YxWlM1c1pXNW5kR2c3WEc0Z0lDQWdmVnh1SUNBZ0lHTjFjbkpsYm5SUmRXVjFaU0E5SUc1MWJHdzdYRzRnSUNBZ1pISmhhVzVwYm1jZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0J5ZFc1RGJHVmhjbFJwYldWdmRYUW9kR2x0Wlc5MWRDazdYRzU5WEc1Y2JuQnliMk5sYzNNdWJtVjRkRlJwWTJzZ1BTQm1kVzVqZEdsdmJpQW9ablZ1S1NCN1hHNGdJQ0FnZG1GeUlHRnlaM01nUFNCdVpYY2dRWEp5WVhrb1lYSm5kVzFsYm5SekxteGxibWQwYUNBdElERXBPMXh1SUNBZ0lHbG1JQ2hoY21kMWJXVnVkSE11YkdWdVozUm9JRDRnTVNrZ2UxeHVJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTVRzZ2FTQThJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnWVhKbmMxdHBJQzBnTVYwZ1BTQmhjbWQxYldWdWRITmJhVjA3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lDQWdjWFZsZFdVdWNIVnphQ2h1WlhjZ1NYUmxiU2htZFc0c0lHRnlaM01wS1R0Y2JpQWdJQ0JwWmlBb2NYVmxkV1V1YkdWdVozUm9JRDA5UFNBeElDWW1JQ0ZrY21GcGJtbHVaeWtnZTF4dUlDQWdJQ0FnSUNCeWRXNVVhVzFsYjNWMEtHUnlZV2x1VVhWbGRXVXBPMXh1SUNBZ0lIMWNibjA3WEc1Y2JpOHZJSFk0SUd4cGEyVnpJSEJ5WldScFkzUnBZbXhsSUc5aWFtVmpkSE5jYm1aMWJtTjBhVzl1SUVsMFpXMG9ablZ1TENCaGNuSmhlU2tnZTF4dUlDQWdJSFJvYVhNdVpuVnVJRDBnWm5WdU8xeHVJQ0FnSUhSb2FYTXVZWEp5WVhrZ1BTQmhjbkpoZVR0Y2JuMWNia2wwWlcwdWNISnZkRzkwZVhCbExuSjFiaUE5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNCMGFHbHpMbVoxYmk1aGNIQnNlU2h1ZFd4c0xDQjBhR2x6TG1GeWNtRjVLVHRjYm4wN1hHNXdjbTlqWlhOekxuUnBkR3hsSUQwZ0oySnliM2R6WlhJbk8xeHVjSEp2WTJWemN5NWljbTkzYzJWeUlEMGdkSEoxWlR0Y2JuQnliMk5sYzNNdVpXNTJJRDBnZTMwN1hHNXdjbTlqWlhOekxtRnlaM1lnUFNCYlhUdGNibkJ5YjJObGMzTXVkbVZ5YzJsdmJpQTlJQ2NuT3lBdkx5QmxiWEIwZVNCemRISnBibWNnZEc4Z1lYWnZhV1FnY21WblpYaHdJR2x6YzNWbGMxeHVjSEp2WTJWemN5NTJaWEp6YVc5dWN5QTlJSHQ5TzF4dVhHNW1kVzVqZEdsdmJpQnViMjl3S0NrZ2UzMWNibHh1Y0hKdlkyVnpjeTV2YmlBOUlHNXZiM0E3WEc1d2NtOWpaWE56TG1Ga1pFeHBjM1JsYm1WeUlEMGdibTl2Y0R0Y2JuQnliMk5sYzNNdWIyNWpaU0E5SUc1dmIzQTdYRzV3Y205alpYTnpMbTltWmlBOUlHNXZiM0E3WEc1d2NtOWpaWE56TG5KbGJXOTJaVXhwYzNSbGJtVnlJRDBnYm05dmNEdGNibkJ5YjJObGMzTXVjbVZ0YjNabFFXeHNUR2x6ZEdWdVpYSnpJRDBnYm05dmNEdGNibkJ5YjJObGMzTXVaVzFwZENBOUlHNXZiM0E3WEc1d2NtOWpaWE56TG5CeVpYQmxibVJNYVhOMFpXNWxjaUE5SUc1dmIzQTdYRzV3Y205alpYTnpMbkJ5WlhCbGJtUlBibU5sVEdsemRHVnVaWElnUFNCdWIyOXdPMXh1WEc1d2NtOWpaWE56TG14cGMzUmxibVZ5Y3lBOUlHWjFibU4wYVc5dUlDaHVZVzFsS1NCN0lISmxkSFZ5YmlCYlhTQjlYRzVjYm5CeWIyTmxjM011WW1sdVpHbHVaeUE5SUdaMWJtTjBhVzl1SUNodVlXMWxLU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZHdjbTlqWlhOekxtSnBibVJwYm1jZ2FYTWdibTkwSUhOMWNIQnZjblJsWkNjcE8xeHVmVHRjYmx4dWNISnZZMlZ6Y3k1amQyUWdQU0JtZFc1amRHbHZiaUFvS1NCN0lISmxkSFZ5YmlBbkx5Y2dmVHRjYm5CeWIyTmxjM011WTJoa2FYSWdQU0JtZFc1amRHbHZiaUFvWkdseUtTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0Nkd2NtOWpaWE56TG1Ob1pHbHlJR2x6SUc1dmRDQnpkWEJ3YjNKMFpXUW5LVHRjYm4wN1hHNXdjbTlqWlhOekxuVnRZWE5ySUQwZ1puVnVZM1JwYjI0b0tTQjdJSEpsZEhWeWJpQXdPeUI5TzF4dUlpd2lMeThnUTI5d2VYSnBaMmgwSUVwdmVXVnVkQ3dnU1c1akxpQmhibVFnYjNSb1pYSWdUbTlrWlNCamIyNTBjbWxpZFhSdmNuTXVYRzR2TDF4dUx5OGdVR1Z5YldsemMybHZiaUJwY3lCb1pYSmxZbmtnWjNKaGJuUmxaQ3dnWm5KbFpTQnZaaUJqYUdGeVoyVXNJSFJ2SUdGdWVTQndaWEp6YjI0Z2IySjBZV2x1YVc1bklHRmNiaTh2SUdOdmNIa2diMllnZEdocGN5QnpiMlowZDJGeVpTQmhibVFnWVhOemIyTnBZWFJsWkNCa2IyTjFiV1Z1ZEdGMGFXOXVJR1pwYkdWeklDaDBhR1ZjYmk4dklGd2lVMjltZEhkaGNtVmNJaWtzSUhSdklHUmxZV3dnYVc0Z2RHaGxJRk52Wm5SM1lYSmxJSGRwZEdodmRYUWdjbVZ6ZEhKcFkzUnBiMjRzSUdsdVkyeDFaR2x1WjF4dUx5OGdkMmwwYUc5MWRDQnNhVzFwZEdGMGFXOXVJSFJvWlNCeWFXZG9kSE1nZEc4Z2RYTmxMQ0JqYjNCNUxDQnRiMlJwWm5rc0lHMWxjbWRsTENCd2RXSnNhWE5vTEZ4dUx5OGdaR2x6ZEhKcFluVjBaU3dnYzNWaWJHbGpaVzV6WlN3Z1lXNWtMMjl5SUhObGJHd2dZMjl3YVdWeklHOW1JSFJvWlNCVGIyWjBkMkZ5WlN3Z1lXNWtJSFJ2SUhCbGNtMXBkRnh1THk4Z2NHVnljMjl1Y3lCMGJ5QjNhRzl0SUhSb1pTQlRiMlowZDJGeVpTQnBjeUJtZFhKdWFYTm9aV1FnZEc4Z1pHOGdjMjhzSUhOMVltcGxZM1FnZEc4Z2RHaGxYRzR2THlCbWIyeHNiM2RwYm1jZ1kyOXVaR2wwYVc5dWN6cGNiaTh2WEc0dkx5QlVhR1VnWVdKdmRtVWdZMjl3ZVhKcFoyaDBJRzV2ZEdsalpTQmhibVFnZEdocGN5QndaWEp0YVhOemFXOXVJRzV2ZEdsalpTQnphR0ZzYkNCaVpTQnBibU5zZFdSbFpGeHVMeThnYVc0Z1lXeHNJR052Y0dsbGN5QnZjaUJ6ZFdKemRHRnVkR2xoYkNCd2IzSjBhVzl1Y3lCdlppQjBhR1VnVTI5bWRIZGhjbVV1WEc0dkwxeHVMeThnVkVoRklGTlBSbFJYUVZKRklFbFRJRkJTVDFaSlJFVkVJRndpUVZNZ1NWTmNJaXdnVjBsVVNFOVZWQ0JYUVZKU1FVNVVXU0JQUmlCQlRsa2dTMGxPUkN3Z1JWaFFVa1ZUVTF4dUx5OGdUMUlnU1UxUVRFbEZSQ3dnU1U1RFRGVkVTVTVISUVKVlZDQk9UMVFnVEVsTlNWUkZSQ0JVVHlCVVNFVWdWMEZTVWtGT1ZFbEZVeUJQUmx4dUx5OGdUVVZTUTBoQlRsUkJRa2xNU1ZSWkxDQkdTVlJPUlZOVElFWlBVaUJCSUZCQlVsUkpRMVZNUVZJZ1VGVlNVRTlUUlNCQlRrUWdUazlPU1U1R1VrbE9SMFZOUlU1VUxpQkpUbHh1THk4Z1RrOGdSVlpGVGxRZ1UwaEJURXdnVkVoRklFRlZWRWhQVWxNZ1QxSWdRMDlRV1ZKSlIwaFVJRWhQVEVSRlVsTWdRa1VnVEVsQlFreEZJRVpQVWlCQlRsa2dRMHhCU1Uwc1hHNHZMeUJFUVUxQlIwVlRJRTlTSUU5VVNFVlNJRXhKUVVKSlRFbFVXU3dnVjBoRlZFaEZVaUJKVGlCQlRpQkJRMVJKVDA0Z1QwWWdRMDlPVkZKQlExUXNJRlJQVWxRZ1QxSmNiaTh2SUU5VVNFVlNWMGxUUlN3Z1FWSkpVMGxPUnlCR1VrOU5MQ0JQVlZRZ1QwWWdUMUlnU1U0Z1EwOU9Ua1ZEVkVsUFRpQlhTVlJJSUZSSVJTQlRUMFpVVjBGU1JTQlBVaUJVU0VWY2JpOHZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVXlCSlRpQlVTRVVnVTA5R1ZGZEJVa1V1WEc1Y2JpZDFjMlVnYzNSeWFXTjBKenRjYmx4dUx5OGdTV1lnYjJKcUxtaGhjMDkzYmxCeWIzQmxjblI1SUdoaGN5QmlaV1Z1SUc5MlpYSnlhV1JrWlc0c0lIUm9aVzRnWTJGc2JHbHVaMXh1THk4Z2IySnFMbWhoYzA5M2JsQnliM0JsY25SNUtIQnliM0FwSUhkcGJHd2dZbkpsWVdzdVhHNHZMeUJUWldVNklHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOXFiM2xsYm5RdmJtOWtaUzlwYzNOMVpYTXZNVGN3TjF4dVpuVnVZM1JwYjI0Z2FHRnpUM2R1VUhKdmNHVnlkSGtvYjJKcUxDQndjbTl3S1NCN1hHNGdJSEpsZEhWeWJpQlBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1TG1OaGJHd29iMkpxTENCd2NtOXdLVHRjYm4xY2JseHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHhjeXdnYzJWd0xDQmxjU3dnYjNCMGFXOXVjeWtnZTF4dUlDQnpaWEFnUFNCelpYQWdmSHdnSnlZbk8xeHVJQ0JsY1NBOUlHVnhJSHg4SUNjOUp6dGNiaUFnZG1GeUlHOWlhaUE5SUh0OU8xeHVYRzRnSUdsbUlDaDBlWEJsYjJZZ2NYTWdJVDA5SUNkemRISnBibWNuSUh4OElIRnpMbXhsYm1kMGFDQTlQVDBnTUNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ2WW1vN1hHNGdJSDFjYmx4dUlDQjJZWElnY21WblpYaHdJRDBnTDF4Y0t5OW5PMXh1SUNCeGN5QTlJSEZ6TG5Od2JHbDBLSE5sY0NrN1hHNWNiaUFnZG1GeUlHMWhlRXRsZVhNZ1BTQXhNREF3TzF4dUlDQnBaaUFvYjNCMGFXOXVjeUFtSmlCMGVYQmxiMllnYjNCMGFXOXVjeTV0WVhoTFpYbHpJRDA5UFNBbmJuVnRZbVZ5SnlrZ2UxeHVJQ0FnSUcxaGVFdGxlWE1nUFNCdmNIUnBiMjV6TG0xaGVFdGxlWE03WEc0Z0lIMWNibHh1SUNCMllYSWdiR1Z1SUQwZ2NYTXViR1Z1WjNSb08xeHVJQ0F2THlCdFlYaExaWGx6SUR3OUlEQWdiV1ZoYm5NZ2RHaGhkQ0IzWlNCemFHOTFiR1FnYm05MElHeHBiV2wwSUd0bGVYTWdZMjkxYm5SY2JpQWdhV1lnS0cxaGVFdGxlWE1nUGlBd0lDWW1JR3hsYmlBK0lHMWhlRXRsZVhNcElIdGNiaUFnSUNCc1pXNGdQU0J0WVhoTFpYbHpPMXh1SUNCOVhHNWNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCc1pXNDdJQ3NyYVNrZ2UxeHVJQ0FnSUhaaGNpQjRJRDBnY1hOYmFWMHVjbVZ3YkdGalpTaHlaV2RsZUhBc0lDY2xNakFuS1N4Y2JpQWdJQ0FnSUNBZ2FXUjRJRDBnZUM1cGJtUmxlRTltS0dWeEtTeGNiaUFnSUNBZ0lDQWdhM04wY2l3Z2RuTjBjaXdnYXl3Z2RqdGNibHh1SUNBZ0lHbG1JQ2hwWkhnZ1BqMGdNQ2tnZTF4dUlDQWdJQ0FnYTNOMGNpQTlJSGd1YzNWaWMzUnlLREFzSUdsa2VDazdYRzRnSUNBZ0lDQjJjM1J5SUQwZ2VDNXpkV0p6ZEhJb2FXUjRJQ3NnTVNrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR3R6ZEhJZ1BTQjRPMXh1SUNBZ0lDQWdkbk4wY2lBOUlDY25PMXh1SUNBZ0lIMWNibHh1SUNBZ0lHc2dQU0JrWldOdlpHVlZVa2xEYjIxd2IyNWxiblFvYTNOMGNpazdYRzRnSUNBZ2RpQTlJR1JsWTI5a1pWVlNTVU52YlhCdmJtVnVkQ2gyYzNSeUtUdGNibHh1SUNBZ0lHbG1JQ2doYUdGelQzZHVVSEp2Y0dWeWRIa29iMkpxTENCcktTa2dlMXh1SUNBZ0lDQWdiMkpxVzJ0ZElEMGdkanRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLRUZ5Y21GNUxtbHpRWEp5WVhrb2IySnFXMnRkS1NrZ2UxeHVJQ0FnSUNBZ2IySnFXMnRkTG5CMWMyZ29kaWs3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHOWlhbHRyWFNBOUlGdHZZbXBiYTEwc0lIWmRPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQnZZbW83WEc1OU8xeHVJaXdpTHk4Z1EyOXdlWEpwWjJoMElFcHZlV1Z1ZEN3Z1NXNWpMaUJoYm1RZ2IzUm9aWElnVG05a1pTQmpiMjUwY21saWRYUnZjbk11WEc0dkwxeHVMeThnVUdWeWJXbHpjMmx2YmlCcGN5Qm9aWEpsWW5rZ1ozSmhiblJsWkN3Z1puSmxaU0J2WmlCamFHRnlaMlVzSUhSdklHRnVlU0J3WlhKemIyNGdiMkowWVdsdWFXNW5JR0ZjYmk4dklHTnZjSGtnYjJZZ2RHaHBjeUJ6YjJaMGQyRnlaU0JoYm1RZ1lYTnpiMk5wWVhSbFpDQmtiMk4xYldWdWRHRjBhVzl1SUdacGJHVnpJQ2gwYUdWY2JpOHZJRndpVTI5bWRIZGhjbVZjSWlrc0lIUnZJR1JsWVd3Z2FXNGdkR2hsSUZOdlpuUjNZWEpsSUhkcGRHaHZkWFFnY21WemRISnBZM1JwYjI0c0lHbHVZMngxWkdsdVoxeHVMeThnZDJsMGFHOTFkQ0JzYVcxcGRHRjBhVzl1SUhSb1pTQnlhV2RvZEhNZ2RHOGdkWE5sTENCamIzQjVMQ0J0YjJScFpua3NJRzFsY21kbExDQndkV0pzYVhOb0xGeHVMeThnWkdsemRISnBZblYwWlN3Z2MzVmliR2xqWlc1elpTd2dZVzVrTDI5eUlITmxiR3dnWTI5d2FXVnpJRzltSUhSb1pTQlRiMlowZDJGeVpTd2dZVzVrSUhSdklIQmxjbTFwZEZ4dUx5OGdjR1Z5YzI5dWN5QjBieUIzYUc5dElIUm9aU0JUYjJaMGQyRnlaU0JwY3lCbWRYSnVhWE5vWldRZ2RHOGdaRzhnYzI4c0lITjFZbXBsWTNRZ2RHOGdkR2hsWEc0dkx5Qm1iMnhzYjNkcGJtY2dZMjl1WkdsMGFXOXVjenBjYmk4dlhHNHZMeUJVYUdVZ1lXSnZkbVVnWTI5d2VYSnBaMmgwSUc1dmRHbGpaU0JoYm1RZ2RHaHBjeUJ3WlhKdGFYTnphVzl1SUc1dmRHbGpaU0J6YUdGc2JDQmlaU0JwYm1Oc2RXUmxaRnh1THk4Z2FXNGdZV3hzSUdOdmNHbGxjeUJ2Y2lCemRXSnpkR0Z1ZEdsaGJDQndiM0owYVc5dWN5QnZaaUIwYUdVZ1UyOW1kSGRoY21VdVhHNHZMMXh1THk4Z1ZFaEZJRk5QUmxSWFFWSkZJRWxUSUZCU1QxWkpSRVZFSUZ3aVFWTWdTVk5jSWl3Z1YwbFVTRTlWVkNCWFFWSlNRVTVVV1NCUFJpQkJUbGtnUzBsT1JDd2dSVmhRVWtWVFUxeHVMeThnVDFJZ1NVMVFURWxGUkN3Z1NVNURURlZFU1U1SElFSlZWQ0JPVDFRZ1RFbE5TVlJGUkNCVVR5QlVTRVVnVjBGU1VrRk9WRWxGVXlCUFJseHVMeThnVFVWU1EwaEJUbFJCUWtsTVNWUlpMQ0JHU1ZST1JWTlRJRVpQVWlCQklGQkJVbFJKUTFWTVFWSWdVRlZTVUU5VFJTQkJUa1FnVGs5T1NVNUdVa2xPUjBWTlJVNVVMaUJKVGx4dUx5OGdUazhnUlZaRlRsUWdVMGhCVEV3Z1ZFaEZJRUZWVkVoUFVsTWdUMUlnUTA5UVdWSkpSMGhVSUVoUFRFUkZVbE1nUWtVZ1RFbEJRa3hGSUVaUFVpQkJUbGtnUTB4QlNVMHNYRzR2THlCRVFVMUJSMFZUSUU5U0lFOVVTRVZTSUV4SlFVSkpURWxVV1N3Z1YwaEZWRWhGVWlCSlRpQkJUaUJCUTFSSlQwNGdUMFlnUTA5T1ZGSkJRMVFzSUZSUFVsUWdUMUpjYmk4dklFOVVTRVZTVjBsVFJTd2dRVkpKVTBsT1J5QkdVazlOTENCUFZWUWdUMFlnVDFJZ1NVNGdRMDlPVGtWRFZFbFBUaUJYU1ZSSUlGUklSU0JUVDBaVVYwRlNSU0JQVWlCVVNFVmNiaTh2SUZWVFJTQlBVaUJQVkVoRlVpQkVSVUZNU1U1SFV5QkpUaUJVU0VVZ1UwOUdWRmRCVWtVdVhHNWNiaWQxYzJVZ2MzUnlhV04wSnp0Y2JseHVkbUZ5SUhOMGNtbHVaMmxtZVZCeWFXMXBkR2wyWlNBOUlHWjFibU4wYVc5dUtIWXBJSHRjYmlBZ2MzZHBkR05vSUNoMGVYQmxiMllnZGlrZ2UxeHVJQ0FnSUdOaGMyVWdKM04wY21sdVp5YzZYRzRnSUNBZ0lDQnlaWFIxY200Z2RqdGNibHh1SUNBZ0lHTmhjMlVnSjJKdmIyeGxZVzRuT2x4dUlDQWdJQ0FnY21WMGRYSnVJSFlnUHlBbmRISjFaU2NnT2lBblptRnNjMlVuTzF4dVhHNGdJQ0FnWTJGelpTQW5iblZ0WW1WeUp6cGNiaUFnSUNBZ0lISmxkSFZ5YmlCcGMwWnBibWwwWlNoMktTQS9JSFlnT2lBbkp6dGNibHh1SUNBZ0lHUmxabUYxYkhRNlhHNGdJQ0FnSUNCeVpYUjFjbTRnSnljN1hHNGdJSDFjYm4wN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNG9iMkpxTENCelpYQXNJR1Z4TENCdVlXMWxLU0I3WEc0Z0lITmxjQ0E5SUhObGNDQjhmQ0FuSmljN1hHNGdJR1Z4SUQwZ1pYRWdmSHdnSnowbk8xeHVJQ0JwWmlBb2IySnFJRDA5UFNCdWRXeHNLU0I3WEc0Z0lDQWdiMkpxSUQwZ2RXNWtaV1pwYm1Wa08xeHVJQ0I5WEc1Y2JpQWdhV1lnS0hSNWNHVnZaaUJ2WW1vZ1BUMDlJQ2R2WW1wbFkzUW5LU0I3WEc0Z0lDQWdjbVYwZFhKdUlFOWlhbVZqZEM1clpYbHpLRzlpYWlrdWJXRndLR1oxYm1OMGFXOXVLR3NwSUh0Y2JpQWdJQ0FnSUhaaGNpQnJjeUE5SUdWdVkyOWtaVlZTU1VOdmJYQnZibVZ1ZENoemRISnBibWRwWm5sUWNtbHRhWFJwZG1Vb2F5a3BJQ3NnWlhFN1hHNGdJQ0FnSUNCcFppQW9RWEp5WVhrdWFYTkJjbkpoZVNodlltcGJhMTBwS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCdlltcGJhMTB1YldGd0tHWjFibU4wYVc5dUtIWXBJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYTNNZ0t5QmxibU52WkdWVlVrbERiMjF3YjI1bGJuUW9jM1J5YVc1bmFXWjVVSEpwYldsMGFYWmxLSFlwS1R0Y2JpQWdJQ0FnSUNBZ2ZTa3VhbTlwYmloelpYQXBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHdHpJQ3NnWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0hOMGNtbHVaMmxtZVZCeWFXMXBkR2wyWlNodlltcGJhMTBwS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5S1M1cWIybHVLSE5sY0NrN1hHNWNiaUFnZlZ4dVhHNGdJR2xtSUNnaGJtRnRaU2tnY21WMGRYSnVJQ2NuTzF4dUlDQnlaWFIxY200Z1pXNWpiMlJsVlZKSlEyOXRjRzl1Wlc1MEtITjBjbWx1WjJsbWVWQnlhVzFwZEdsMlpTaHVZVzFsS1NrZ0t5QmxjU0FyWEc0Z0lDQWdJQ0FnSUNCbGJtTnZaR1ZWVWtsRGIyMXdiMjVsYm5Rb2MzUnlhVzVuYVdaNVVISnBiV2wwYVhabEtHOWlhaWtwTzF4dWZUdGNiaUlzSWlkMWMyVWdjM1J5YVdOMEp6dGNibHh1Wlhod2IzSjBjeTVrWldOdlpHVWdQU0JsZUhCdmNuUnpMbkJoY25ObElEMGdjbVZ4ZFdseVpTZ25MaTlrWldOdlpHVW5LVHRjYm1WNGNHOXlkSE11Wlc1amIyUmxJRDBnWlhod2IzSjBjeTV6ZEhKcGJtZHBabmtnUFNCeVpYRjFhWEpsS0NjdUwyVnVZMjlrWlNjcE8xeHVJaXdpYVcxd2IzSjBJSHNnU1cxbmRYSkRiR2xsYm5RZ2ZTQm1jbTl0SUNjdUxpOWpiR2xsYm5Rbk8xeHVhVzF3YjNKMElIc2dRVXhDVlUxZlJVNUVVRTlKVGxRZ2ZTQm1jbTl0SUNjdUxpOWpiMjF0YjI0dlpXNWtjRzlwYm5Sekp6dGNibWx0Y0c5eWRDQjdJRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVXNJRUZzWW5WdFJHRjBZU0I5SUdaeWIyMGdKeTR1TDJOdmJXMXZiaTkwZVhCbGN5YzdYRzVwYlhCdmNuUWdleUJuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObElIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwzVjBhV3h6Snp0Y2JseHVaWGh3YjNKMElHRnplVzVqSUdaMWJtTjBhVzl1SUdkbGRFRnNZblZ0S0Z4dUlDQmpiR2xsYm5RNklFbHRaM1Z5UTJ4cFpXNTBMRnh1SUNCaGJHSjFiVWhoYzJnNklITjBjbWx1WjF4dUtUb2dVSEp2YldselpUeEpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBFRnNZblZ0UkdGMFlUNCtJSHRjYmlBZ1kyOXVjM1FnZFhKc0lEMGdZQ1I3UVV4Q1ZVMWZSVTVFVUU5SlRsUjlMeVI3WVd4aWRXMUlZWE5vZldBN1hHNGdJSEpsZEhWeWJpQm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sS0dGM1lXbDBJR05zYVdWdWRDNXlaWEYxWlhOMEtIdDFjbXg5S1NrZ1lYTWdTVzFuZFhKQmNHbFNaWE53YjI1elpUeEJiR0oxYlVSaGRHRStPMXh1ZlZ4dUlpd2laWGh3YjNKMElDb2dabkp2YlNBbkxpOW5aWFJCYkdKMWJTYzdYRzRpTENKcGJYQnZjblFnZXlCRmRtVnVkRVZ0YVhSMFpYSWdmU0JtY205dElDZGxkbVZ1ZEhNbk8xeHVhVzF3YjNKMElIc2daMlYwUVhWMGFHOXlhWHBoZEdsdmJraGxZV1JsY2lCOUlHWnliMjBnSnk0dloyVjBRWFYwYUc5eWFYcGhkR2x2YmtobFlXUmxjaWM3WEc1cGJYQnZjblFnZTF4dUlDQmtaV3hsZEdWSmJXRm5aU3hjYmlBZ1ptRjJiM0pwZEdWSmJXRm5aU3hjYmlBZ1oyVjBTVzFoWjJVc1hHNGdJSFZ3Ykc5aFpDeGNiaUFnZFhCa1lYUmxTVzFoWjJVc1hHNGdJRlZ3WkdGMFpVbHRZV2RsVUdGNWJHOWhaQ3hjYm4wZ1puSnZiU0FuTGk5cGJXRm5aU2M3WEc1cGJYQnZjblFnZTF4dUlDQkhZV3hzWlhKNVQzQjBhVzl1Y3l4Y2JpQWdaMlYwUjJGc2JHVnllU3hjYmlBZ1oyVjBVM1ZpY21Wa1pHbDBSMkZzYkdWeWVTeGNiaUFnVTNWaWNtVmtaR2wwUjJGc2JHVnllVTl3ZEdsdmJuTXNYRzRnSUhObFlYSmphRWRoYkd4bGNua3NYRzRnSUZObFlYSmphRWRoYkd4bGNubFBjSFJwYjI1ekxGeHVmU0JtY205dElDY3VMMmRoYkd4bGNua25PMXh1YVcxd2IzSjBJSHNnWjJWMFFXeGlkVzBnZlNCbWNtOXRJQ2N1TDJGc1luVnRKenRjYm1sdGNHOXlkQ0I3SUVsTlIxVlNYMEZRU1Y5UVVrVkdTVmdnZlNCbWNtOXRJQ2N1TDJOdmJXMXZiaTlsYm1Sd2IybHVkSE1uTzF4dWFXMXdiM0owSUh0Y2JpQWdRV3hpZFcxRVlYUmhMRnh1SUNCRGNtVmtaVzUwYVdGc2N5eGNiaUFnUjJGc2JHVnllVVJoZEdFc1hHNGdJRWx0WVdkbFJHRjBZU3hjYmlBZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlN4Y2JpQWdVR0Y1Ykc5aFpDeGNibjBnWm5KdmJTQW5MaTlqYjIxdGIyNHZkSGx3WlhNbk8xeHVYRzVqYjI1emRDQlZVMFZTUVVkRlRsUWdQU0FuYVcxbmRYSXZibVY0ZENBb2FIUjBjSE02THk5bmFYUm9kV0l1WTI5dEwydGhhVzFoYkd4bFlTOXViMlJsTFdsdFozVnlLU2M3WEc1Y2JtbHRjRzl5ZENCaGVHbHZjeXdnZXlCQmVHbHZjMGx1YzNSaGJtTmxMQ0JCZUdsdmMxSmxjM0J2Ym5ObExDQkJlR2x2YzFKbGNYVmxjM1JEYjI1bWFXY2dmU0JtY205dElDZGhlR2x2Y3ljN1hHNWNibVY0Y0c5eWRDQmpiR0Z6Y3lCSmJXZDFja05zYVdWdWRDQmxlSFJsYm1SeklFVjJaVzUwUlcxcGRIUmxjaUI3WEc0Z0lIQnlhWFpoZEdVZ2NHeGhhVzVHWlhSamFHVnlPaUJCZUdsdmMwbHVjM1JoYm1ObE8xeHVJQ0J3Y21sMllYUmxJR1psZEdOb1pYSTZJRUY0YVc5elNXNXpkR0Z1WTJVN1hHNWNiaUFnWTI5dWMzUnlkV04wYjNJb2NtVmhaRzl1YkhrZ1kzSmxaR1Z1ZEdsaGJITTZJRU55WldSbGJuUnBZV3h6S1NCN1hHNGdJQ0FnYzNWd1pYSW9LVHRjYmx4dUlDQWdJSFJvYVhNdWNHeGhhVzVHWlhSamFHVnlJRDBnWVhocGIzTXVZM0psWVhSbEtIdGNiaUFnSUNBZ0lHSmhjMlZWVWt3NklFbE5SMVZTWDBGUVNWOVFVa1ZHU1Znc1hHNGdJQ0FnSUNCb1pXRmtaWEp6T2lCN1hHNGdJQ0FnSUNBZ0lDZFZjMlZ5TFVGblpXNTBKem9nVlZORlVrRkhSVTVVTEZ4dUlDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUhKbGMzQnZibk5sVkhsd1pUb2dKMnB6YjI0bkxGeHVJQ0FnSUgwcE8xeHVJQ0FnSUhSb2FYTXVabVYwWTJobGNpQTlJR0Y0YVc5ekxtTnlaV0YwWlNoN1hHNGdJQ0FnSUNCaVlYTmxWVkpNT2lCSlRVZFZVbDlCVUVsZlVGSkZSa2xZTEZ4dUlDQWdJQ0FnYUdWaFpHVnljem9nZTF4dUlDQWdJQ0FnSUNBblZYTmxjaTFCWjJWdWRDYzZJRlZUUlZKQlIwVk9WQ3hjYmlBZ0lDQWdJSDBzWEc0Z0lDQWdJQ0J5WlhOd2IyNXpaVlI1Y0dVNklDZHFjMjl1Snl4Y2JpQWdJQ0I5S1R0Y2JpQWdJQ0IwYUdsekxtWmxkR05vWlhJdWFXNTBaWEpqWlhCMGIzSnpMbkpsY1hWbGMzUXVkWE5sS0Z4dUlDQWdJQ0FnWVhONWJtTWdLR052Ym1acFp6b2dRWGhwYjNOU1pYRjFaWE4wUTI5dVptbG5LU0E5UGlCN1hHNGdJQ0FnSUNBZ0lHTnZibVpwWnk1b1pXRmtaWEp6SUQwZ1kyOXVabWxuTG1obFlXUmxjbk1nUHlCamIyNW1hV2N1YUdWaFpHVnljeUE2SUh0OU8xeHVJQ0FnSUNBZ0lDQmpiMjVtYVdjdWFHVmhaR1Z5Y3k1aGRYUm9iM0pwZW1GMGFXOXVJRDBnWVhkaGFYUWdaMlYwUVhWMGFHOXlhWHBoZEdsdmJraGxZV1JsY2loMGFHbHpLVHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR052Ym1acFp6dGNiaUFnSUNBZ0lIMHNYRzRnSUNBZ0lDQW9aVG9nUlhKeWIzSXBJRDArSUZCeWIyMXBjMlV1Y21WcVpXTjBLR1VwWEc0Z0lDQWdLVHRjYmlBZ2ZWeHVYRzRnSUhCc1lXbHVVbVZ4ZFdWemRDaHZjSFJwYjI1ek9pQkJlR2x2YzFKbGNYVmxjM1JEYjI1bWFXY3BPaUJRY205dGFYTmxQRUY0YVc5elVtVnpjRzl1YzJVOGRXNXJibTkzYmo0K0lIdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NXdiR0ZwYmtabGRHTm9aWElvYjNCMGFXOXVjeWs3WEc0Z0lIMWNibHh1SUNCeVpYRjFaWE4wS0c5d2RHbHZibk02SUVGNGFXOXpVbVZ4ZFdWemRFTnZibVpwWnlBOUlIdDlLVG9nVUhKdmJXbHpaVHhCZUdsdmMxSmxjM0J2Ym5ObFBIVnVhMjV2ZDI0K1BpQjdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVabVYwWTJobGNpaHZjSFJwYjI1ektUdGNiaUFnZlZ4dVhHNGdJR1JsYkdWMFpVbHRZV2RsS0dsdFlXZGxTR0Z6YURvZ2MzUnlhVzVuS1RvZ1VISnZiV2x6WlR4SmJXZDFja0Z3YVZKbGMzQnZibk5sUEdKdmIyeGxZVzQrUGlCN1hHNGdJQ0FnY21WMGRYSnVJR1JsYkdWMFpVbHRZV2RsS0hSb2FYTXNJR2x0WVdkbFNHRnphQ2s3WEc0Z0lIMWNibHh1SUNCbVlYWnZjbWwwWlVsdFlXZGxLR2x0WVdkbFNHRnphRG9nYzNSeWFXNW5LVG9nVUhKdmJXbHpaVHhKYldkMWNrRndhVkpsYzNCdmJuTmxQSE4wY21sdVp6NCtJSHRjYmlBZ0lDQnlaWFIxY200Z1ptRjJiM0pwZEdWSmJXRm5aU2gwYUdsekxDQnBiV0ZuWlVoaGMyZ3BPMXh1SUNCOVhHNWNiaUFnWjJWMFFXeGlkVzBvWVd4aWRXMUlZWE5vT2lCemRISnBibWNwT2lCUWNtOXRhWE5sUEVsdFozVnlRWEJwVW1WemNHOXVjMlU4UVd4aWRXMUVZWFJoUGo0Z2UxeHVJQ0FnSUhKbGRIVnliaUJuWlhSQmJHSjFiU2gwYUdsekxDQmhiR0oxYlVoaGMyZ3BPMXh1SUNCOVhHNWNiaUFnWjJWMFIyRnNiR1Z5ZVNodmNIUnBiMjV6T2lCSFlXeHNaWEo1VDNCMGFXOXVjeWs2SUZCeWIyMXBjMlU4U1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhIWVd4c1pYSjVSR0YwWVQ0K0lIdGNiaUFnSUNCeVpYUjFjbTRnWjJWMFIyRnNiR1Z5ZVNoMGFHbHpMQ0J2Y0hScGIyNXpLVHRjYmlBZ2ZWeHVYRzRnSUdkbGRGTjFZbkpsWkdScGRFZGhiR3hsY25rb1hHNGdJQ0FnYjNCMGFXOXVjem9nVTNWaWNtVmtaR2wwUjJGc2JHVnllVTl3ZEdsdmJuTmNiaUFnS1RvZ1VISnZiV2x6WlR4SmJXZDFja0Z3YVZKbGMzQnZibk5sUEVkaGJHeGxjbmxFWVhSaFBqNGdlMXh1SUNBZ0lISmxkSFZ5YmlCblpYUlRkV0p5WldSa2FYUkhZV3hzWlhKNUtIUm9hWE1zSUc5d2RHbHZibk1wTzF4dUlDQjlYRzVjYmlBZ2MyVmhjbU5vUjJGc2JHVnllU2hjYmlBZ0lDQnZjSFJwYjI1ek9pQlRaV0Z5WTJoSFlXeHNaWEo1VDNCMGFXOXVjMXh1SUNBcE9pQlFjbTl0YVhObFBFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVOFIyRnNiR1Z5ZVVSaGRHRStQaUI3WEc0Z0lDQWdjbVYwZFhKdUlITmxZWEpqYUVkaGJHeGxjbmtvZEdocGN5d2diM0IwYVc5dWN5azdYRzRnSUgxY2JseHVJQ0JuWlhSSmJXRm5aU2hwYldGblpVaGhjMmc2SUhOMGNtbHVaeWs2SUZCeWIyMXBjMlU4U1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhKYldGblpVUmhkR0UrUGlCN1hHNGdJQ0FnY21WMGRYSnVJR2RsZEVsdFlXZGxLSFJvYVhNc0lHbHRZV2RsU0dGemFDazdYRzRnSUgxY2JseHVJQ0IxY0dSaGRHVkpiV0ZuWlNoY2JpQWdJQ0J3WVhsc2IyRmtPaUJWY0dSaGRHVkpiV0ZuWlZCaGVXeHZZV1FnZkNCVmNHUmhkR1ZKYldGblpWQmhlV3h2WVdSYlhWeHVJQ0FwT2lCUWNtOXRhWE5sUEVsdFozVnlRWEJwVW1WemNHOXVjMlU4WW05dmJHVmhiajRnZkNCSmJXZDFja0Z3YVZKbGMzQnZibk5sUEdKdmIyeGxZVzQrVzEwK0lIdGNiaUFnSUNCeVpYUjFjbTRnZFhCa1lYUmxTVzFoWjJVb2RHaHBjeXdnY0dGNWJHOWhaQ2s3WEc0Z0lIMWNibHh1SUNCMWNHeHZZV1FvWEc0Z0lDQWdjR0Y1Ykc5aFpEb2djM1J5YVc1bklId2djM1J5YVc1blcxMGdmQ0JRWVhsc2IyRmtJSHdnVUdGNWJHOWhaRnRkWEc0Z0lDazZJRkJ5YjIxcGMyVThTVzFuZFhKQmNHbFNaWE53YjI1elpUeEpiV0ZuWlVSaGRHRStJSHdnU1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhKYldGblpVUmhkR0UrVzEwK0lIdGNiaUFnSUNCeVpYUjFjbTRnZFhCc2IyRmtLSFJvYVhNc0lIQmhlV3h2WVdRcE8xeHVJQ0I5WEc1OVhHNGlMQ0psZUhCdmNuUWdZMjl1YzNRZ1NVMUhWVkpmUVZCSlgxQlNSVVpKV0NBOUlDZG9kSFJ3Y3pvdkwyRndhUzVwYldkMWNpNWpiMjBuTzF4dVhHNWxlSEJ2Y25RZ1kyOXVjM1FnUVZCSlgxWkZVbE5KVDA0Z1BTQW5NeWM3WEc1Y2JtVjRjRzl5ZENCamIyNXpkQ0JCVlZSSVQxSkpXa1ZmUlU1RVVFOUpUbFFnUFNBbmIyRjFkR2d5TDJGMWRHaHZjbWw2WlNjN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCQlRFSlZUVjlGVGtSUVQwbE9WQ0E5SUdBa2UwRlFTVjlXUlZKVFNVOU9mUzloYkdKMWJXQTdYRzVjYm1WNGNHOXlkQ0JqYjI1emRDQkpUVUZIUlY5RlRrUlFUMGxPVkNBOUlHQWtlMEZRU1Y5V1JWSlRTVTlPZlM5cGJXRm5aV0E3WEc1Y2JtVjRjRzl5ZENCamIyNXpkQ0JWVUV4UFFVUmZSVTVFVUU5SlRsUWdQU0JnSkh0QlVFbGZWa1ZTVTBsUFRuMHZkWEJzYjJGa1lEdGNibHh1Wlhod2IzSjBJR052Ym5OMElFZEJURXhGVWxsZlJVNUVVRTlKVGxRZ1BTQmdKSHRCVUVsZlZrVlNVMGxQVG4wdloyRnNiR1Z5ZVdBN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCVFZVSlNSVVJFU1ZSZlIwRk1URVZTV1Y5RlRrUlFUMGxPVkNBOUlHQWtlMEZRU1Y5V1JWSlRTVTlPZlM5bllXeHNaWEo1TDNKZ08xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1UwVkJVa05JWDBkQlRFeEZVbGxmUlU1RVVFOUpUbFFnUFNCZ0pIdEJVRWxmVmtWU1UwbFBUbjB2WjJGc2JHVnllUzl6WldGeVkyaGdPMXh1SWl3aWFXMXdiM0owSUhzZ1VtVmhaR0ZpYkdVZ2ZTQm1jbTl0SUZ3aWMzUnlaV0Z0WENJN1hHNWNibVY0Y0c5eWRDQnBiblJsY21aaFkyVWdRV05qWlhOelZHOXJaVzRnZTF4dUlDQmhZMk5sYzNOVWIydGxiam9nYzNSeWFXNW5PMXh1ZlZ4dVhHNWxlSEJ2Y25RZ2FXNTBaWEptWVdObElFTnNhV1Z1ZEVsa0lIdGNiaUFnWTJ4cFpXNTBTV1E2SUhOMGNtbHVaenRjYm4xY2JseHVaWGh3YjNKMElHbHVkR1Z5Wm1GalpTQk1iMmRwYmlCbGVIUmxibVJ6SUVOc2FXVnVkRWxrSUh0Y2JpQWdkWE5sY201aGJXVTZJSE4wY21sdVp6dGNiaUFnY0dGemMzZHZjbVE2SUhOMGNtbHVaenRjYm4xY2JseHVaWGh3YjNKMElIUjVjR1VnUTNKbFpHVnVkR2xoYkhNZ1BTQkJZMk5sYzNOVWIydGxiaUI4SUVOc2FXVnVkRWxrSUh3Z1RHOW5hVzQ3WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCcGMwRmpZMlZ6YzFSdmEyVnVLR0Z5WnpvZ2RXNXJibTkzYmlrNklHRnlaeUJwY3lCQlkyTmxjM05VYjJ0bGJpQjdYRzRnSUhKbGRIVnliaUFvWVhKbklHRnpJRUZqWTJWemMxUnZhMlZ1S1M1aFkyTmxjM05VYjJ0bGJpQWhQVDBnZFc1a1pXWnBibVZrTzF4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdhWE5EYkdsbGJuUkpaQ2hoY21jNklIVnVhMjV2ZDI0cE9pQmhjbWNnYVhNZ1EyeHBaVzUwU1dRZ2UxeHVJQ0J5WlhSMWNtNGdLR0Z5WnlCaGN5QkRiR2xsYm5SSlpDa3VZMnhwWlc1MFNXUWdJVDA5SUhWdVpHVm1hVzVsWkR0Y2JuMWNibHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJR2x6VEc5bmFXNG9ZWEpuT2lCMWJtdHViM2R1S1RvZ1lYSm5JR2x6SUV4dloybHVJSHRjYmlBZ2NtVjBkWEp1SUNoY2JpQWdJQ0FvWVhKbklHRnpJRXh2WjJsdUtTNWpiR2xsYm5SSlpDQWhQVDBnZFc1a1pXWnBibVZrSUNZbVhHNGdJQ0FnS0dGeVp5QmhjeUJNYjJkcGJpa3VkWE5sY201aGJXVWdJVDA5SUhWdVpHVm1hVzVsWkNBbUpseHVJQ0FnSUNoaGNtY2dZWE1nVEc5bmFXNHBMbkJoYzNOM2IzSmtJQ0U5UFNCMWJtUmxabWx1WldSY2JpQWdLVHRjYm4xY2JseHVhVzUwWlhKbVlXTmxJRU52YlcxdmJrUmhkR0VnZTF4dUlDQnBaRG9nYzNSeWFXNW5PMXh1SUNCMGFYUnNaVG9nYzNSeWFXNW5JSHdnYm5Wc2JEdGNiaUFnWkdWelkzSnBjSFJwYjI0NklITjBjbWx1WnlCOElHNTFiR3c3WEc0Z0lHUmhkR1YwYVcxbE9pQnVkVzFpWlhJN1hHNGdJR3hwYm1zNklITjBjbWx1Wnp0Y2JseHVJQ0JoWkY5amIyNW1hV2MvT2lCN1hHNGdJQ0FnYzJGbVpVWnNZV2R6T2lCemRISnBibWRiWFR0Y2JpQWdJQ0JvYVdkb1VtbHphMFpzWVdkek9pQnpkSEpwYm1kYlhUdGNiaUFnSUNCMWJuTmhabVZHYkdGbmN6b2djM1J5YVc1blcxMDdYRzRnSUNBZ2QyRnNiRlZ1YzJGbVpVWnNZV2R6T2lCemRISnBibWRiWFR0Y2JpQWdJQ0J6YUc5M2MwRmtjem9nWW05dmJHVmhianRjYmlBZ2ZUdGNiaUFnWVdSZmRIbHdaVG9nYm5WdFltVnlPMXh1SUNCaFpGOTFjbXc2SUhOMGNtbHVaenRjYmx4dUlDQmhZMk52ZFc1MFgzVnliRG9nYzNSeWFXNW5JSHdnYm5Wc2JEdGNiaUFnWVdOamIzVnVkRjlwWkRvZ2MzUnlhVzVuSUh3Z2JuVnNiRHRjYmlBZ1ptRjJiM0pwZEdVNklHSnZiMnhsWVc0N1hHNGdJR2x6WDJGa09pQmliMjlzWldGdU8xeHVJQ0JwYzE5aGJHSjFiVG9nWW05dmJHVmhianRjYmlBZ2FXNWZaMkZzYkdWeWVUb2dZbTl2YkdWaGJqdGNiaUFnYVc1ZmJXOXpkRjkyYVhKaGJEb2dZbTl2YkdWaGJqdGNiaUFnYm5ObWR6b2dZbTl2YkdWaGJpQjhJRzUxYkd3N1hHNGdJSE5sWTNScGIyNDZJSE4wY21sdVp5QjhJRzUxYkd3N1hHNGdJSFJoWjNNNklFRnljbUY1UEh0Y2JpQWdJQ0J1WVcxbE9pQnpkSEpwYm1jN1hHNGdJQ0FnWkdsemNHeGhlVjl1WVcxbE9pQnpkSEpwYm1jN1hHNGdJQ0FnWm05c2JHOTNaWEp6T2lCdWRXMWlaWEk3WEc0Z0lDQWdkRzkwWVd4ZmFYUmxiWE02SUc1MWJXSmxjanRjYmlBZ0lDQm1iMnhzYjNkcGJtYzZJR0p2YjJ4bFlXNDdYRzRnSUNBZ2FYTmZkMmhwZEdWc2FYTjBaV1E2SUdKdmIyeGxZVzQ3WEc0Z0lDQWdZbUZqYTJkeWIzVnVaRjlvWVhOb09pQnpkSEpwYm1jN1hHNGdJQ0FnZEdoMWJXSnVZV2xzWDJoaGMyZzZJSE4wY21sdVp5QjhJRzUxYkd3N1hHNGdJQ0FnWVdOalpXNTBPaUJ6ZEhKcGJtYzdYRzRnSUNBZ1ltRmphMmR5YjNWdVpGOXBjMTloYm1sdFlYUmxaRG9nWW05dmJHVmhianRjYmlBZ0lDQjBhSFZ0WW01aGFXeGZhWE5mWVc1cGJXRjBaV1E2SUdKdmIyeGxZVzQ3WEc0Z0lDQWdhWE5mY0hKdmJXOTBaV1E2SUdKdmIyeGxZVzQ3WEc0Z0lDQWdaR1Z6WTNKcGNIUnBiMjQ2SUhOMGNtbHVaenRjYmlBZ0lDQnNiMmR2WDJoaGMyZzZJSE4wY21sdVp5QjhJRzUxYkd3N1hHNGdJQ0FnYkc5bmIxOWtaWE4wYVc1aGRHbHZibDkxY213NklITjBjbWx1WnlCOElHNTFiR3c3WEc0Z0lDQWdaR1Z6WTNKcGNIUnBiMjVmWVc1dWIzUmhkR2x2Ym5NNklGSmxZMjl5WkR4emRISnBibWNzSUhWdWEyNXZkMjQrTzF4dUlDQjlQanRjYmlBZ2RHOXdhV002SUhOMGNtbHVaeUI4SUc1MWJHdzdYRzRnSUhSdmNHbGpYMmxrT2lCemRISnBibWNnZkNCdWRXeHNPMXh1SUNCMmIzUmxPaUJ1ZFd4c08xeHVYRzRnSUdOdmJXMWxiblJmWTI5MWJuUTZJRzUxYldKbGNpQjhJRzUxYkd3N1hHNGdJR1poZG05eWFYUmxYMk52ZFc1ME9pQnVkVzFpWlhJZ2ZDQnVkV3hzTzF4dUlDQjFjSE02SUc1MWJXSmxjaUI4SUc1MWJHdzdYRzRnSUdSdmQyNXpPaUJ1ZFcxaVpYSWdmQ0J1ZFd4c08xeHVJQ0J6WTI5eVpUb2diblZ0WW1WeUlId2diblZzYkR0Y2JpQWdjRzlwYm5Sek9pQnVkVzFpWlhJZ2ZDQnVkV3hzTzF4dUlDQjJhV1YzY3pvZ2JuVnRZbVZ5TzF4dWZWeHVaWGh3YjNKMElHbHVkR1Z5Wm1GalpTQkpiV0ZuWlVSaGRHRWdaWGgwWlc1a2N5QkRiMjF0YjI1RVlYUmhJSHRjYmlBZ2RIbHdaVG9nYzNSeWFXNW5PMXh1SUNCM2FXUjBhRG9nYm5WdFltVnlPMXh1SUNCb1pXbG5hSFE2SUc1MWJXSmxjanRjYmlBZ2MybDZaVG9nYm5WdFltVnlPMXh1SUNCa1pXeGxkR1ZvWVhOb1B6b2djM1J5YVc1bk8xeHVJQ0JpWVc1a2QybGtkR2c2SUc1MWJXSmxjanRjYmlBZ1lXNXBiV0YwWldRNklHSnZiMnhsWVc0N1hHNGdJR2hoYzE5emIzVnVaRG9nWW05dmJHVmhianRjYmlBZ1pXUnBkR1ZrT2lCemRISnBibWM3WEc0Z0lHMXdORjl6YVhwbFB6b2diblZ0WW1WeU8xeHVJQ0J0Y0RRL09pQnpkSEpwYm1jN1hHNGdJR2RwWm5ZL09pQnpkSEpwYm1jN1hHNGdJR2hzY3o4NklITjBjbWx1Wnp0Y2JpQWdiRzl2Y0dsdVp6ODZJR0p2YjJ4bFlXNDdYRzRnSUhCeWIyTmxjM05wYm1jL09pQjdYRzRnSUNBZ2MzUmhkSFZ6T2lBbmNHVnVaR2x1WnljZ2ZDQW5ZMjl0Y0d4bGRHVmtKenRjYmlBZ2ZUdGNibjFjYmx4dVpYaHdiM0owSUdsdWRHVnlabUZqWlNCQmJHSjFiVVJoZEdFZ1pYaDBaVzVrY3lCRGIyMXRiMjVFWVhSaElIdGNiaUFnWTI5MlpYSTZJSE4wY21sdVp5QjhJRzUxYkd3N1hHNGdJR052ZG1WeVgzZHBaSFJvT2lCdWRXMWlaWElnZkNCdWRXeHNPMXh1SUNCamIzWmxjbDlvWldsbmFIUTZJRzUxYldKbGNpQjhJRzUxYkd3N1hHNGdJR3hoZVc5MWREb2djM1J5YVc1bk8xeHVJQ0J3Y21sMllXTjVPaUJ6ZEhKcGJtYzdYRzRnSUdsdVkyeDFaR1ZmWVd4aWRXMWZZV1J6T2lCaWIyOXNaV0Z1TzF4dUlDQnBiV0ZuWlhNNklFbHRZV2RsUkdGMFlWdGRPMXh1SUNCcGJXRm5aWE5mWTI5MWJuUTZJRzUxYldKbGNqdGNibjFjYmx4dVpYaHdiM0owSUhSNWNHVWdSMkZzYkdWeWVVUmhkR0VnUFNCQmNuSmhlVHhKYldGblpVUmhkR0VnZkNCQmJHSjFiVVJoZEdFK08xeHVaWGh3YjNKMElHbHVkR1Z5Wm1GalpTQlFZWGxzYjJGa0lIdGNiaUFnYVcxaFoyVS9PaUJ6ZEhKcGJtYzdYRzRnSUdKaGMyVTJORDg2SUhOMGNtbHVaenRjYmlBZ2RIbHdaVDg2SUNkemRISmxZVzBuSUh3Z0ozVnliQ2NnZkNBblltRnpaVFkwSnp0Y2JpQWdibUZ0WlQ4NklITjBjbWx1Wnp0Y2JpQWdkR2wwYkdVL09pQnpkSEpwYm1jN1hHNGdJR1JsYzJOeWFYQjBhVzl1UHpvZ2MzUnlhVzVuTzF4dUlDQmhiR0oxYlQ4NklITjBjbWx1Wnp0Y2JpQWdjM1J5WldGdFB6b2dVbVZoWkdGaWJHVTdYRzRnSUdScGMyRmliR1ZmWVhWa2FXOC9PaUFuTVNjZ2ZDQW5NQ2M3WEc1OVhHNWxlSEJ2Y25RZ2FXNTBaWEptWVdObElFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVOFhHNGdJRlFnUFNCU1pXTnZjbVE4YzNSeWFXNW5MQ0IxYm10dWIzZHVQaUI4SUZKbFkyOXlaRHh6ZEhKcGJtY3NJSFZ1YTI1dmQyNCtXMTBnZkNCemRISnBibWNnZkNCaWIyOXNaV0Z1SUh3Z1NXMWhaMlZFWVhSaElId2dSMkZzYkdWeWVVUmhkR0VnZkNCQmJHSjFiVVJoZEdGY2JqNGdlMXh1SUNCa1lYUmhPaUJVTzF4dUlDQnpkR0YwZFhNNklHNTFiV0psY2p0Y2JpQWdjM1ZqWTJWemN6b2dZbTl2YkdWaGJqdGNibjBpTENKcGJYQnZjblFnZXlCQmVHbHZjMUpsYzNCdmJuTmxJSDBnWm5KdmJTQW5ZWGhwYjNNbk8xeHVhVzF3YjNKMElFWnZjbTFFWVhSaElHWnliMjBnSjJadmNtMHRaR0YwWVNjN1hHNXBiWEJ2Y25RZ2V5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObExDQlFZWGxzYjJGa0lIMGdabkp2YlNBbkxpOTBlWEJsY3ljN1hHNXBiWEJ2Y25RZ2V5QlNaV0ZrWVdKc1pTQjlJR1p5YjIwZ0ozTjBjbVZoYlNjN1hHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQnBjMEpoYzJVMk5DaHdZWGxzYjJGa09pQnpkSEpwYm1jZ2ZDQlFZWGxzYjJGa0tUb2dZbTl2YkdWaGJpQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2NHRjViRzloWkNBOVBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZEhsd1pXOW1JSEJoZVd4dllXUXVZbUZ6WlRZMElDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUppQndZWGxzYjJGa0xuUjVjR1VnUFQwOUlDZGlZWE5sTmpRbk8xeHVmVnh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnYVhOSmJXRm5aVlZ5YkNod1lYbHNiMkZrT2lCemRISnBibWNnZkNCUVlYbHNiMkZrS1RvZ1ltOXZiR1ZoYmlCN1hHNGdJR2xtSUNoMGVYQmxiMllnY0dGNWJHOWhaQ0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCeVpYUjFjbTRnZEhKMVpUdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ2NHRjViRzloWkM1cGJXRm5aU0FoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dKaVlnY0dGNWJHOWhaQzUwZVhCbElEMDlQU0FuZFhKc0p6dGNibjFjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdselUzUnlaV0Z0S0hCaGVXeHZZV1E2SUhOMGNtbHVaeUI4SUZCaGVXeHZZV1FwT2lCaWIyOXNaV0Z1SUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUJ3WVhsc2IyRmtJRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ2NHRjViRzloWkM1emRISmxZVzBnSVQwOUlDZDFibVJsWm1sdVpXUW5PMXh1ZlZ4dVhHNHZMeUJVVDBSUE9pQlNaV1poWTNSdmNpQjBhR2x6SUhSdklHSmxJR0VnZFc1cGNYVmxJRzVoYldVZ2IyWWdjMjl0WlNCcmFXNWtJQ2hoSUdoaGMyZy9LVnh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJR2RsZEZOdmRYSmpaU2h3WVhsc2IyRmtPaUJ6ZEhKcGJtY2dmQ0JRWVhsc2IyRmtLVG9nYzNSeWFXNW5JSHdnVW1WaFpHRmliR1VnZTF4dUlDQnBaaUFvZEhsd1pXOW1JSEJoZVd4dllXUWdQVDA5SUNkemRISnBibWNuS1NCN1hHNGdJQ0FnY21WMGRYSnVJSEJoZVd4dllXUTdYRzRnSUgxY2JseHVJQ0JwWmlBb2FYTkNZWE5sTmpRb2NHRjViRzloWkNrcElIdGNiaUFnSUNCeVpYUjFjbTRnWENKd1lYbHNiMkZrTG1KaGMyVTJORndpSUdGeklITjBjbWx1Wnp0Y2JpQWdmU0JsYkhObElHbG1JQ2hwYzFOMGNtVmhiU2h3WVhsc2IyRmtLU2tnZTF4dUlDQWdJSEpsZEhWeWJpQmNJbkJoZVd4dllXUXVjM1J5WldGdFhDSWdZWE1nYzNSeWFXNW5PMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsZEhWeWJpQndZWGxzYjJGa0xtbHRZV2RsSUdGeklITjBjbWx1Wnp0Y2JpQWdmVnh1ZlZ4dVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1kzSmxZWFJsUm05eWJTaHdZWGxzYjJGa09pQnpkSEpwYm1jZ2ZDQlFZWGxzYjJGa0tUb2dSbTl5YlVSaGRHRWdlMXh1SUNCamIyNXpkQ0JtYjNKdElEMGdibVYzSUVadmNtMUVZWFJoS0NrN1hHNWNiaUFnYVdZZ0tIUjVjR1Z2WmlCd1lYbHNiMkZrSUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lHWnZjbTB1WVhCd1pXNWtLQ2RwYldGblpTY3NJSEJoZVd4dllXUXBPMXh1SUNBZ0lISmxkSFZ5YmlCbWIzSnRPMXh1SUNCOVhHNWNiaUFnWm05eUlDaGpiMjV6ZENCYmEyVjVMQ0IyWVd4MVpWMGdiMllnVDJKcVpXTjBMbVZ1ZEhKcFpYTW9jR0Y1Ykc5aFpDa3BJSHRjYmlBZ0lDQmpiMjV6ZENCemRYQndiM0owWldSVmNHeHZZV1JQWW1wbFkzUlVlWEJsY3lBOUlGc25ZbUZ6WlRZMEp5d2dKM04wY21WaGJTZGRYRzRnSUNBZ2FXWWdLSE4xY0hCdmNuUmxaRlZ3Ykc5aFpFOWlhbVZqZEZSNWNHVnpMbWx1WkdWNFQyWW9hMlY1S1NBaFBUMGdMVEVwSUh0Y2JpQWdJQ0FnSUdsbUlDaHpkWEJ3YjNKMFpXUlZjR3h2WVdSUFltcGxZM1JVZVhCbGN5NXBibVJsZUU5bUtIQmhlV3h2WVdRdWRIbHdaU0JoY3lCemRISnBibWNwSUNFOVBTQXRNU2tnZTF4dUlDQWdJQ0FnSUNCbWIzSnRMbUZ3Y0dWdVpDaHJaWGtzSUhCaGVXeHZZV1FwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQm1iM0p0TG1Gd2NHVnVaQ2hyWlhrc0lIWmhiSFZsS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJR1p2Y20wN1hHNTlYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObEtGeHVJQ0J5WlhOd2IyNXpaVG9nUVhocGIzTlNaWE53YjI1elpWeHVLVG9nU1cxbmRYSkJjR2xTWlhOd2IyNXpaU0I3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdjbVZ6Y0c5dWMyVXVaR0YwWVQ4dWMzUmhkSFZ6SUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmlCMGVYQmxiMllnY21WemNHOXVjMlV1WkdGMFlUOHVjM1ZqWTJWemN5QWhQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCeVpYUjFjbTRnY21WemNHOXVjMlV1WkdGMFlWeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIdGNiaUFnSUNCa1lYUmhPaUJ5WlhOd2IyNXpaUzVrWVhSaExGeHVJQ0FnSUhOMFlYUjFjem9nY21WemNHOXVjMlV1YzNSaGRIVnpMRnh1SUNBZ0lDOHZJRlJQUkU4NklHUmxkR1Z5YldsdVpTQjBhR1VnYzNWalkyVnpjeUJ2WmlCMGFHVWdZMkZzYkQ5Y2JpQWdJQ0J6ZFdOalpYTnpPaUIwY25WbExGeHVJQ0I5WEc1OVhHNGlMQ0pwYlhCdmNuUWdleUJKYldkMWNrTnNhV1Z1ZENCOUlHWnliMjBnSnk0dUwyTnNhV1Z1ZENjN1hHNXBiWEJ2Y25RZ2V5QkhRVXhNUlZKWlgwVk9SRkJQU1U1VUxDQkpUVWRWVWw5QlVFbGZVRkpGUmtsWUlIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwyVnVaSEJ2YVc1MGN5YzdYRzVwYlhCdmNuUWdleUJKYldkMWNrRndhVkpsYzNCdmJuTmxMQ0JIWVd4c1pYSjVSR0YwWVNCOUlHWnliMjBnSnk0dUwyTnZiVzF2Ymk5MGVYQmxjeWM3WEc1cGJYQnZjblFnZXlCVlVrd2dmU0JtY205dElDZDFjbXduTzF4dWFXMXdiM0owSUhzZ1oyVjBTVzFuZFhKQmNHbFNaWE53YjI1elpVWnliMjFTWlhOd2IyNXpaU0I5SUdaeWIyMGdKeTR1TDJOdmJXMXZiaTkxZEdsc2N5YzdYRzVjYm1WNGNHOXlkQ0IwZVhCbElFTnZiVzF2YmxObFkzUnBiMjVRY205d2N5QTlJSHRjYmlBZ2MyOXlkRDg2SUNkMmFYSmhiQ2NnZkNBbmRHOXdKeUI4SUNkMGFXMWxKenRjYmlBZ2NHRm5aVDg2SUc1MWJXSmxjanRjYm4wN1hHNWNibVY0Y0c5eWRDQjBlWEJsSUVodmRGTmxZM1JwYjI0Z1BTQkRiMjF0YjI1VFpXTjBhVzl1VUhKdmNITWdKaUI3WEc0Z0lITmxZM1JwYjI0NklDZG9iM1FuTzF4dWZUdGNibHh1Wlhod2IzSjBJSFI1Y0dVZ1ZHOXdVMlZqZEdsdmJpQTlJRU52YlcxdmJsTmxZM1JwYjI1UWNtOXdjeUFtSUh0Y2JpQWdjMlZqZEdsdmJqb2dKM1J2Y0NjN1hHNGdJSGRwYm1SdmR6ODZJQ2RrWVhrbklId2dKM2RsWldzbklId2dKMjF2Ym5Sb0p5QjhJQ2Q1WldGeUp5QjhJQ2RoYkd3bk8xeHVmVHRjYmx4dVpYaHdiM0owSUhSNWNHVWdWWE5sY2xObFkzUnBiMjRnUFNCUGJXbDBQRU52YlcxdmJsTmxZM1JwYjI1UWNtOXdjeXdnSjNOdmNuUW5QaUFtSUh0Y2JpQWdjMlZqZEdsdmJqb2dKM1Z6WlhJbk8xeHVJQ0J6YjNKMFB6b2dKM1pwY21Gc0p5QjhJQ2QwYjNBbklId2dKM1JwYldVbklId2dKM0pwYzJsdVp5YzdYRzU5TzF4dVhHNWxlSEJ2Y25RZ2RIbHdaU0JUWldOMGFXOXVUM0IwYVc5dWN5QTlJRWh2ZEZObFkzUnBiMjRnZkNCVWIzQlRaV04wYVc5dUlId2dWWE5sY2xObFkzUnBiMjQ3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRkJ5WlhObGJuUmhkR2x2Yms5d2RHbHZibk1nUFNCN1hHNGdJSE5vYjNkV2FYSmhiRDg2SUdKdmIyeGxZVzQ3WEc0Z0lHMWhkSFZ5WlQ4NklHSnZiMnhsWVc0N1hHNGdJR0ZzWW5WdFgzQnlaWFpwWlhkelB6b2dZbTl2YkdWaGJqdGNibjA3WEc1Y2JtVjRjRzl5ZENCMGVYQmxJRWRoYkd4bGNubFBjSFJwYjI1eklEMGdVMlZqZEdsdmJrOXdkR2x2Ym5NZ0ppQlFjbVZ6Wlc1MFlYUnBiMjVQY0hScGIyNXpPMXh1WEc1amIyNXpkQ0JrWldaaGRXeDBUM0IwYVc5dWN6b2dSMkZzYkdWeWVVOXdkR2x2Ym5NZ1BTQjdYRzRnSUhObFkzUnBiMjQ2SUNkb2IzUW5MRnh1SUNCemIzSjBPaUFuZG1seVlXd25MRnh1ZlR0Y2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHTnZibk4wY25WamRFZGhiR3hsY25sVmNtd29iM0IwYVc5dWN6b2dSMkZzYkdWeWVVOXdkR2x2Ym5NcE9pQlZVa3dnZTF4dUlDQmpiMjV6ZENCdFpYSm5aV1JQY0hScGIyNXpJRDBnVDJKcVpXTjBMbUZ6YzJsbmJpaDdmU3dnWkdWbVlYVnNkRTl3ZEdsdmJuTXNJRzl3ZEdsdmJuTXBPMXh1WEc0Z0lHeGxkQ0IxY21rZ1BTQmdKSHR0WlhKblpXUlBjSFJwYjI1ekxuTmxZM1JwYjI1OVlEdGNibHh1SUNCcFppQW9iV1Z5WjJWa1QzQjBhVzl1Y3k1emIzSjBLU0I3WEc0Z0lDQWdkWEpwSUNzOUlHQXZKSHR0WlhKblpXUlBjSFJwYjI1ekxuTnZjblI5WUR0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2h0WlhKblpXUlBjSFJwYjI1ekxuTmxZM1JwYjI0Z1BUMDlJQ2QwYjNBbklDWW1JRzFsY21kbFpFOXdkR2x2Ym5NdWQybHVaRzkzS1NCN1hHNGdJQ0FnZFhKcElDczlJR0F2Skh0dFpYSm5aV1JQY0hScGIyNXpMbmRwYm1SdmQzMWdPMXh1SUNCOVhHNWNiaUFnYVdZZ0tHMWxjbWRsWkU5d2RHbHZibk11Y0dGblpTa2dlMXh1SUNBZ0lIVnlhU0FyUFNCZ0x5UjdiV1Z5WjJWa1QzQjBhVzl1Y3k1d1lXZGxmV0E3WEc0Z0lIMWNibHh1SUNCamIyNXpkQ0IxY213Z1BTQnVaWGNnVlZKTUtHQWtlMGxOUjFWU1gwRlFTVjlRVWtWR1NWaDlMeVI3UjBGTVRFVlNXVjlGVGtSUVQwbE9WSDB2Skh0MWNtbDlZQ2s3WEc1Y2JpQWdhV1lnS0cxbGNtZGxaRTl3ZEdsdmJuTXVjMmh2ZDFacGNtRnNJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNCMWNtd3VjMlZoY21Ob1VHRnlZVzF6TG1Gd2NHVnVaQ2duYzJodmQxWnBjbUZzSnl3Z2JXVnlaMlZrVDNCMGFXOXVjeTV6YUc5M1ZtbHlZV3d1ZEc5VGRISnBibWNvS1NrN1hHNGdJSDFjYmx4dUlDQnBaaUFvYldWeVoyVmtUM0IwYVc5dWN5NXRZWFIxY21VZ0lUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJSFZ5YkM1elpXRnlZMmhRWVhKaGJYTXVZWEJ3Wlc1a0tDZHRZWFIxY21VbkxDQnRaWEpuWldSUGNIUnBiMjV6TG0xaGRIVnlaUzUwYjFOMGNtbHVaeWdwS1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2h0WlhKblpXUlBjSFJwYjI1ekxtRnNZblZ0WDNCeVpYWnBaWGR6SUNFOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQjFjbXd1YzJWaGNtTm9VR0Z5WVcxekxtRndjR1Z1WkNoY2JpQWdJQ0FnSUNkaGJHSjFiVjl3Y21WMmFXVjNjeWNzWEc0Z0lDQWdJQ0J0WlhKblpXUlBjSFJwYjI1ekxtRnNZblZ0WDNCeVpYWnBaWGR6TG5SdlUzUnlhVzVuS0NsY2JpQWdJQ0FwTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhWeWJEdGNibjFjYmx4dVpYaHdiM0owSUdGemVXNWpJR1oxYm1OMGFXOXVJR2RsZEVkaGJHeGxjbmtvWEc0Z0lHTnNhV1Z1ZERvZ1NXMW5kWEpEYkdsbGJuUXNYRzRnSUc5d2RHbHZibk02SUVkaGJHeGxjbmxQY0hScGIyNXpJRDBnWkdWbVlYVnNkRTl3ZEdsdmJuTmNiaWs2SUZCeWIyMXBjMlU4U1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhIWVd4c1pYSjVSR0YwWVQ0K0lIdGNiaUFnWTI5dWMzUWdleUJ3WVhSb2JtRnRaU0I5SUQwZ1kyOXVjM1J5ZFdOMFIyRnNiR1Z5ZVZWeWJDaHZjSFJwYjI1ektUdGNiaUFnTHk4Z2MybHVZMlVnZDJVbmNtVWdkWE5wYm1jZ2NISmxabWw0VlhKc0lIZHBkR2dnWjI5MExDQjNaU0JvWVhabElIUnZJSEpsYlc5MlpTQjBhR1VnYzNSaGNuUnBibWNnYzJ4aGMyZ2diM0lnYVhRbmJHd2dkR2h5YjNkY2JpQWdZMjl1YzNRZ1ptbHVZV3hRWVhSb2JtRnRaU0E5SUhCaGRHaHVZVzFsTG5Oc2FXTmxLREVwTzF4dVhHNGdJSEpsZEhWeWJpQm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sS0dGM1lXbDBJR05zYVdWdWRDNXlaWEYxWlhOMEtIc2dkWEpzT2lCbWFXNWhiRkJoZEdodVlXMWxJSDBwS1NCaGN5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBFZGhiR3hsY25sRVlYUmhQanRjYm4xY2JpSXNJbWx0Y0c5eWRDQjdJRWx0WjNWeVEyeHBaVzUwSUgwZ1puSnZiU0FuTGk0dlkyeHBaVzUwSnp0Y2JtbHRjRzl5ZENCN1hHNGdJRk5WUWxKRlJFUkpWRjlIUVV4TVJWSlpYMFZPUkZCUFNVNVVMRnh1SUNCSlRVZFZVbDlCVUVsZlVGSkZSa2xZTEZ4dWZTQm1jbTl0SUNjdUxpOWpiMjF0YjI0dlpXNWtjRzlwYm5Sekp6dGNibWx0Y0c5eWRDQjdJRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVXNJRWRoYkd4bGNubEVZWFJoSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDNSNWNHVnpKenRjYm1sdGNHOXlkQ0I3SUZWU1RDQjlJR1p5YjIwZ0ozVnliQ2M3WEc1cGJYQnZjblFnZXlCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxJSDBnWm5KdmJTQW5MaTR2WTI5dGJXOXVMM1YwYVd4ekp6dGNibHh1Wlhod2IzSjBJSFI1Y0dVZ1ZHbHRaVTl3ZEdsdmJuTWdQU0I3WEc0Z0lITjFZbkpsWkdScGREb2djM1J5YVc1bk8xeHVJQ0J6YjNKMFB6b2dKM1JwYldVbk8xeHVJQ0J3WVdkbFB6b2diblZ0WW1WeU8xeHVmVHRjYmx4dVpYaHdiM0owSUhSNWNHVWdWRzl3VDNCMGFXOXVjeUE5SUU5dGFYUThWR2x0WlU5d2RHbHZibk1zSUNkemIzSjBKejRnSmlCN1hHNGdJSE52Y25RL09pQW5kRzl3Snp0Y2JpQWdkMmx1Wkc5M1B6b2dKMlJoZVNjZ2ZDQW5kMlZsYXljZ2ZDQW5iVzl1ZEdnbklId2dKM2xsWVhJbklId2dKMkZzYkNjN1hHNTlPMXh1WEc1bGVIQnZjblFnZEhsd1pTQlRkV0p5WldSa2FYUkhZV3hzWlhKNVQzQjBhVzl1Y3lBOUlGUnBiV1ZQY0hScGIyNXpJSHdnVkc5d1QzQjBhVzl1Y3p0Y2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHTnZibk4wY25WamRGTjFZbkpsWkdScGRFZGhiR3hsY25sVmNtd29YRzRnSUc5d2RHbHZibk02SUZOMVluSmxaR1JwZEVkaGJHeGxjbmxQY0hScGIyNXpYRzRwT2lCVlVrd2dlMXh1SUNCc1pYUWdkWEpwSUQwZ1lDUjdiM0IwYVc5dWN5NXpkV0p5WldSa2FYUjlZRHRjYmx4dUlDQnBaaUFvYjNCMGFXOXVjeTV6YjNKMEtTQjdYRzRnSUNBZ2RYSnBJQ3M5SUdBdkpIdHZjSFJwYjI1ekxuTnZjblI5WUR0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2h2Y0hScGIyNXpMbk52Y25RZ1BUMDlJQ2QwYjNBbklDWW1JRzl3ZEdsdmJuTXVkMmx1Wkc5M0tTQjdYRzRnSUNBZ2RYSnBJQ3M5SUdBdkpIdHZjSFJwYjI1ekxuZHBibVJ2ZDMxZ08xeHVJQ0I5WEc1Y2JpQWdhV1lnS0c5d2RHbHZibk11Y0dGblpTa2dlMXh1SUNBZ0lIVnlhU0FyUFNCZ0x5UjdiM0IwYVc5dWN5NXdZV2RsZldBN1hHNGdJSDFjYmx4dUlDQmpiMjV6ZENCMWNtd2dQU0J1WlhjZ1ZWSk1LRnh1SUNBZ0lHQWtlMGxOUjFWU1gwRlFTVjlRVWtWR1NWaDlMeVI3VTFWQ1VrVkVSRWxVWDBkQlRFeEZVbGxmUlU1RVVFOUpUbFI5THlSN2RYSnBmV0JjYmlBZ0tUdGNibHh1SUNCeVpYUjFjbTRnZFhKc08xeHVmVnh1WEc1bGVIQnZjblFnWVhONWJtTWdablZ1WTNScGIyNGdaMlYwVTNWaWNtVmtaR2wwUjJGc2JHVnllU2hjYmlBZ1kyeHBaVzUwT2lCSmJXZDFja05zYVdWdWRDeGNiaUFnYjNCMGFXOXVjem9nVTNWaWNtVmtaR2wwUjJGc2JHVnllVTl3ZEdsdmJuTmNiaWs2SUZCeWIyMXBjMlU4U1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhIWVd4c1pYSjVSR0YwWVQ0K0lIdGNiaUFnWTI5dWMzUWdleUJ3WVhSb2JtRnRaU0I5SUQwZ1kyOXVjM1J5ZFdOMFUzVmljbVZrWkdsMFIyRnNiR1Z5ZVZWeWJDaHZjSFJwYjI1ektUdGNiaUFnTHk4Z2MybHVZMlVnZDJVbmNtVWdkWE5wYm1jZ2NISmxabWw0VlhKc0lIZHBkR2dnWjI5MExDQjNaU0JvWVhabElIUnZJSEpsYlc5MlpTQjBhR1VnYzNSaGNuUnBibWNnYzJ4aGMyZ2diM0lnYVhRbmJHd2dkR2h5YjNkY2JpQWdZMjl1YzNRZ1ptbHVZV3hRWVhSb2JtRnRaU0E5SUhCaGRHaHVZVzFsTG5Oc2FXTmxLREVwTzF4dVhHNGdJSEpsZEhWeWJpQm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sS0dGM1lXbDBJR05zYVdWdWRDNXlaWEYxWlhOMEtIc2dkWEpzT2lCbWFXNWhiRkJoZEdodVlXMWxJSDBwS1NCaGN5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBFZGhiR3hsY25sRVlYUmhQanRjYm4xY2JpSXNJbVY0Y0c5eWRDQXFJR1p5YjIwZ0p5NHZaMlYwUjJGc2JHVnllU2M3WEc1bGVIQnZjblFnS2lCbWNtOXRJQ2N1TDJkbGRGTjFZbkpsWkdScGRFZGhiR3hsY25rbk8xeHVaWGh3YjNKMElDb2dabkp2YlNBbkxpOXpaV0Z5WTJoSFlXeHNaWEo1Snp0Y2JpSXNJbWx0Y0c5eWRDQjdJRWx0WjNWeVEyeHBaVzUwSUgwZ1puSnZiU0FuTGk0dlkyeHBaVzUwSnp0Y2JtbHRjRzl5ZENCN0lGTkZRVkpEU0Y5SFFVeE1SVkpaWDBWT1JGQlBTVTVVTENCSlRVZFZVbDlCVUVsZlVGSkZSa2xZSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDJWdVpIQnZhVzUwY3ljN1hHNXBiWEJ2Y25RZ2V5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObExDQkhZV3hzWlhKNVJHRjBZU0I5SUdaeWIyMGdKeTR1TDJOdmJXMXZiaTkwZVhCbGN5YzdYRzVwYlhCdmNuUWdleUJuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObElIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwzVjBhV3h6Snp0Y2JtbHRjRzl5ZENCN0lGVlNUQ0I5SUdaeWIyMGdKM1Z5YkNjN1hHNWNibVY0Y0c5eWRDQjBlWEJsSUZObFlYSmphRTl3ZEdsdmJuTWdQU0I3WEc0Z0lIRS9PaUJ6ZEhKcGJtYzdYRzRnSUhGMVpYSjVQem9nYzNSeWFXNW5PMXh1SUNCemIzSjBQem9nSjNScGJXVW5JSHdnSjNacGNtRnNKenRjYmlBZ2NHRm5aVDg2SUc1MWJXSmxjanRjYm4wN1hHNWNibVY0Y0c5eWRDQjBlWEJsSUZSdmNGTmxZWEpqYUU5d2RHbHZibk1nUFNCUGJXbDBQRk5sWVhKamFFOXdkR2x2Ym5Nc0lDZHpiM0owSno0Z0ppQjdYRzRnSUhOdmNuUS9PaUFuZEc5d0p6dGNiaUFnZDJsdVpHOTNQem9nSjJSaGVTY2dmQ0FuZDJWbGF5Y2dmQ0FuYlc5dWRHZ25JSHdnSjNsbFlYSW5JSHdnSjJGc2JDYzdYRzU5TzF4dVhHNWxlSEJ2Y25RZ2RIbHdaU0JCWkhaaGJtTmxaRk5sWVhKamFGRjFaWEo1VUdGeVlXMWxkR1Z5Y3lBOUlIdGNiaUFnY1Y5aGJHdy9PaUJ6ZEhKcGJtYzdYRzRnSUhGZllXNTVQem9nYzNSeWFXNW5PMXh1SUNCeFgyVjRZV04wYkhrL09pQnpkSEpwYm1jN1hHNGdJSEZmYm05MFB6b2djM1J5YVc1bk8xeHVJQ0J4WDNSNWNHVS9PaUFuYW5Cbkp5QjhJQ2R3Ym1jbklId2dKMmRwWmljZ2ZDQW5ZVzVwWjJsbUp5QjhJQ2RoYkdKMWJTYzdYRzRnSUhGZmMybDZaVjl3ZUQ4NklDZHpiV0ZzYkNjZ2ZDQW5iV1ZrSnlCOElDZGlhV2NuSUh3Z0oyeHlaeWNnZkNBbmFIVm5aU2M3WEc1OU8xeHVYRzVqYjI1emRDQmhaSFpoYm1ObFpGQmhjbUZ0WlhSbGNuTTZJRUZ5Y21GNVBHdGxlVzltSUVGa2RtRnVZMlZrVTJWaGNtTm9VWFZsY25sUVlYSmhiV1YwWlhKelBpQTlJRnRjYmlBZ0ozRmZZV3hzSnl4Y2JpQWdKM0ZmWVc1NUp5eGNiaUFnSjNGZlpYaGhZM1JzZVNjc1hHNGdJQ2R4WDI1dmRDY3NYRzRnSUNkeFgzUjVjR1VuTEZ4dUlDQW5jVjl6YVhwbFgzQjRKeXhjYmwwN1hHNWNibVY0Y0c5eWRDQjBlWEJsSUZObFlYSmphRWRoYkd4bGNubFBjSFJwYjI1eklEMGdLRk5sWVhKamFFOXdkR2x2Ym5NZ2ZDQlViM0JUWldGeVkyaFBjSFJwYjI1ektTQW1YRzRnSUVGa2RtRnVZMlZrVTJWaGNtTm9VWFZsY25sUVlYSmhiV1YwWlhKek8xeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdZMjl1YzNSeWRXTjBVMlZoY21Ob1IyRnNiR1Z5ZVZWeWJDaHZjSFJwYjI1ek9pQlRaV0Z5WTJoSFlXeHNaWEo1VDNCMGFXOXVjeWs2SUZWU1RDQjdYRzRnSUd4bGRDQjFjbWtnUFNBbkp6dGNibHh1SUNCcFppQW9iM0IwYVc5dWN5NXpiM0owS1NCN1hHNGdJQ0FnZFhKcElDczlJR0F2Skh0dmNIUnBiMjV6TG5OdmNuUjlZRHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHZjSFJwYjI1ekxuTnZjblFnUFQwOUlDZDBiM0FuSUNZbUlHOXdkR2x2Ym5NdWQybHVaRzkzS1NCN1hHNGdJQ0FnZFhKcElDczlJR0F2Skh0dmNIUnBiMjV6TG5kcGJtUnZkMzFnTzF4dUlDQjlYRzVjYmlBZ2FXWWdLRzl3ZEdsdmJuTXVjR0ZuWlNrZ2UxeHVJQ0FnSUhWeWFTQXJQU0JnTHlSN2IzQjBhVzl1Y3k1d1lXZGxmV0E3WEc0Z0lIMWNibHh1SUNCamIyNXpkQ0IxY213Z1BTQnVaWGNnVlZKTUtHQWtlMGxOUjFWU1gwRlFTVjlRVWtWR1NWaDlMeVI3VTBWQlVrTklYMGRCVEV4RlVsbGZSVTVFVUU5SlRsUjlKSHQxY21sOVlDazdYRzVjYmlBZ1lXUjJZVzVqWldSUVlYSmhiV1YwWlhKekxtWnZja1ZoWTJnb0tIQmhjbUZ0S1NBOVBpQjdYRzRnSUNBZ2FXWWdLRzl3ZEdsdmJuTmJjR0Z5WVcxZFB5NXNaVzVuZEdncElIdGNiaUFnSUNBZ0lIVnliQzV6WldGeVkyaFFZWEpoYlhNdVlYQndaVzVrS0hCaGNtRnRMQ0J2Y0hScGIyNXpXM0JoY21GdFhTQmhjeUJ6ZEhKcGJtY3BPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNWNiaUFnYVdZZ0tDRjFjbXd1YzJWaGNtTm9LU0I3WEc0Z0lDQWdZMjl1YzNRZ2NYVmxjbmtnUFNCdmNIUnBiMjV6TG5FZ2ZId2diM0IwYVc5dWN5NXhkV1Z5ZVR0Y2JpQWdJQ0JwWmlBb0lYRjFaWEo1S1NCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjA1dklIRjFaWEo1SUhkaGN5QndjbTkyYVdSbFpDY3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lIVnliQzV6WldGeVkyaFFZWEpoYlhNdVlYQndaVzVrS0NkeEp5d2djWFZsY25rcE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlIVnliRHRjYm4xY2JseHVaWGh3YjNKMElHRnplVzVqSUdaMWJtTjBhVzl1SUhObFlYSmphRWRoYkd4bGNua29YRzRnSUdOc2FXVnVkRG9nU1cxbmRYSkRiR2xsYm5Rc1hHNGdJRzl3ZEdsdmJuTTZJRk5sWVhKamFFZGhiR3hsY25sUGNIUnBiMjV6WEc0cE9pQlFjbTl0YVhObFBFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVOFIyRnNiR1Z5ZVVSaGRHRStQaUI3WEc0Z0lHTnZibk4wSUhzZ2NHRjBhRzVoYldVZ2ZTQTlJR052Ym5OMGNuVmpkRk5sWVhKamFFZGhiR3hsY25sVmNtd29iM0IwYVc5dWN5azdYRzRnSUM4dklITnBibU5sSUhkbEozSmxJSFZ6YVc1bklIQnlaV1pwZUZWeWJDQjNhWFJvSUdkdmRDd2dkMlVnYUdGMlpTQjBieUJ5WlcxdmRtVWdkR2hsSUhOMFlYSjBhVzVuSUhOc1lYTm9JRzl5SUdsMEoyeHNJSFJvY205M1hHNGdJR052Ym5OMElHWnBibUZzVUdGMGFHNWhiV1VnUFNCd1lYUm9ibUZ0WlM1emJHbGpaU2d4S1R0Y2JseHVJQ0J5WlhSMWNtNGdaMlYwU1cxbmRYSkJjR2xTWlhOd2IyNXpaVVp5YjIxU1pYTndiMjV6WlNoaGQyRnBkQ0JqYkdsbGJuUXVjbVZ4ZFdWemRDaDdJSFZ5YkRvZ1ptbHVZV3hRWVhSb2JtRnRaU0I5S1NrZ1lYTWdTVzFuZFhKQmNHbFNaWE53YjI1elpUeEhZV3hzWlhKNVJHRjBZVDQ3WEc1OVhHNGlMQ0pwYlhCdmNuUWdlMXh1SUNCQlkyTmxjM05VYjJ0bGJpeGNiaUFnYVhOQlkyTmxjM05VYjJ0bGJpeGNiaUFnYVhORGJHbGxiblJKWkN4Y2JpQWdhWE5NYjJkcGJpeGNibjBnWm5KdmJTQW5MaTlqYjIxdGIyNHZkSGx3WlhNbk8xeHVhVzF3YjNKMElIc2dTVzFuZFhKRGJHbGxiblFnZlNCbWNtOXRJQ2N1TDJOc2FXVnVkQ2M3WEc1cGJYQnZjblFnZXlCSlRVZFZVbDlCVUVsZlVGSkZSa2xZTENCQlZWUklUMUpKV2tWZlJVNUVVRTlKVGxRZ2ZTQm1jbTl0SUNjdUwyTnZiVzF2Ymk5bGJtUndiMmx1ZEhNbk8xeHVYRzVsZUhCdmNuUWdZWE41Ym1NZ1puVnVZM1JwYjI0Z1oyVjBRWFYwYUc5eWFYcGhkR2x2YmtobFlXUmxjaWhjYmlBZ1kyeHBaVzUwT2lCSmJXZDFja05zYVdWdWRGeHVLVG9nVUhKdmJXbHpaVHh6ZEhKcGJtYytJSHRjYmlBZ2FXWWdLR2x6UVdOalpYTnpWRzlyWlc0b1kyeHBaVzUwTG1OeVpXUmxiblJwWVd4ektTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCZ1FtVmhjbVZ5SUNSN1kyeHBaVzUwTG1OeVpXUmxiblJwWVd4ekxtRmpZMlZ6YzFSdmEyVnVmV0E3WEc0Z0lIMWNibHh1SUNCcFppQW9hWE5EYkdsbGJuUkpaQ2hqYkdsbGJuUXVZM0psWkdWdWRHbGhiSE1wSUNZbUlDRnBjMHh2WjJsdUtHTnNhV1Z1ZEM1amNtVmtaVzUwYVdGc2N5a3BJSHRjYmlBZ0lDQnlaWFIxY200Z1lFTnNhV1Z1ZEMxSlJDQWtlMk5zYVdWdWRDNWpjbVZrWlc1MGFXRnNjeTVqYkdsbGJuUkpaSDFnTzF4dUlDQjlYRzVjYmlBZ1kyOXVjM1FnZXlCamJHbGxiblJKWkN3Z2RYTmxjbTVoYldVc0lIQmhjM04zYjNKa0lIMGdQU0JqYkdsbGJuUXVZM0psWkdWdWRHbGhiSE03WEc1Y2JpQWdZMjl1YzNRZ2IzQjBhVzl1Y3pvZ1VtVmpiM0prUEhOMGNtbHVaeXdnZFc1cmJtOTNiajRnUFNCN1hHNGdJQ0FnZFhKc09pQkJWVlJJVDFKSldrVmZSVTVFVUU5SlRsUXNYRzRnSUNBZ1ltRnpaVlZTVERvZ1NVMUhWVkpmUVZCSlgxQlNSVVpKV0N4Y2JpQWdJQ0J3WVhKaGJYTTZJSHRjYmlBZ0lDQWdJR05zYVdWdWRGOXBaRG9nWTJ4cFpXNTBTV1FzWEc0Z0lDQWdJQ0J5WlhOd2IyNXpaVjkwZVhCbE9pQW5kRzlyWlc0bkxGeHVJQ0FnSUgwc1hHNGdJSDA3WEc1Y2JpQWdiR1YwSUhKbGMzQnZibk5sSUQwZ1lYZGhhWFFnWTJ4cFpXNTBMbkJzWVdsdVVtVnhkV1Z6ZENodmNIUnBiMjV6S1R0Y2JseHVJQ0JqYjI1emRDQmpiMjlyYVdWeklEMGdRWEp5WVhrdWFYTkJjbkpoZVNoeVpYTndiMjV6WlM1b1pXRmtaWEp6V3lkelpYUXRZMjl2YTJsbEoxMHBYRzRnSUNBZ1B5QnlaWE53YjI1elpTNW9aV0ZrWlhKeld5ZHpaWFF0WTI5dmEybGxKMTFiTUYxY2JpQWdJQ0E2SUhKbGMzQnZibk5sTG1obFlXUmxjbk5iSjNObGRDMWpiMjlyYVdVblhUdGNibHh1SUNCcFppQW9JV052YjJ0cFpYTXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owNXZJR052YjJ0cFpYTWdkMlZ5WlNCelpYUWdaSFZ5YVc1bklHRjFkR2h2Y21sNllYUnBiMjRuS1R0Y2JpQWdmVnh1WEc0Z0lHTnZibk4wSUcxaGRHTm9aWE1nUFNCamIyOXJhV1Z6TG0xaGRHTm9LQ2NvWG53N0tWdHpYU3BoZFhSb2IzSnBlbVZmZEc5clpXNDlLRnRlTzEwcUtTY3BPMXh1WEc0Z0lHbG1JQ2doYldGMFkyaGxjeUI4ZkNCdFlYUmphR1Z6TG14bGJtZDBhQ0E4SURNcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjFWdVlXSnNaU0IwYnlCbWFXNWtJR0YxZEdodmNtbDZaVjkwYjJ0bGJpQmpiMjlyYVdVbktUdGNiaUFnZlZ4dVhHNGdJR052Ym5OMElHRjFkR2h2Y21sNlpWUnZhMlZ1SUQwZ2JXRjBZMmhsYzFzeVhUdGNibHh1SUNCdmNIUnBiMjV6TG0xbGRHaHZaQ0E5SUNkUVQxTlVKenRjYmlBZ2IzQjBhVzl1Y3k1a1lYUmhJRDBnZTF4dUlDQWdJSFZ6WlhKdVlXMWxMRnh1SUNBZ0lIQmhjM04zYjNKa0xGeHVJQ0FnSUdGc2JHOTNPaUJoZFhSb2IzSnBlbVZVYjJ0bGJpeGNiaUFnZlR0Y2JseHVJQ0J2Y0hScGIyNXpMbVp2Ykd4dmQxSmxaR2x5WldOMElEMGdabUZzYzJVN1hHNGdJRzl3ZEdsdmJuTXVhR1ZoWkdWeWN5QTlJSHRjYmlBZ0lDQmpiMjlyYVdVNklHQmhkWFJvYjNKcGVtVmZkRzlyWlc0OUpIdGhkWFJvYjNKcGVtVlViMnRsYm4xZ0xGeHVJQ0I5TzF4dVhHNGdJSEpsYzNCdmJuTmxJRDBnWVhkaGFYUWdZMnhwWlc1MExuQnNZV2x1VW1WeGRXVnpkQ2h2Y0hScGIyNXpLVHRjYmlBZ1kyOXVjM1FnYkc5allYUnBiMjRnUFNCeVpYTndiMjV6WlM1b1pXRmtaWEp6TG14dlkyRjBhVzl1TzF4dUlDQnBaaUFvSVd4dlkyRjBhVzl1S1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RWYm1GaWJHVWdkRzhnY0dGeWMyVWdiRzlqWVhScGIyNG5LVHRjYmlBZ2ZWeHVYRzRnSUdOdmJuTjBJSFJ2YTJWdUlEMGdTbE5QVGk1d1lYSnpaU2hjYmlBZ0lDQW5lMXdpSnlBclhHNGdJQ0FnSUNCa1pXTnZaR1ZWVWtrb2JHOWpZWFJwYjI0dWMyeHBZMlVvYkc5allYUnBiMjR1YVc1a1pYaFBaaWduSXljcElDc2dNU2twWEc0Z0lDQWdJQ0FnSUM1eVpYQnNZV05sS0M5Y0lpOW5MQ0FuWEZ4Y1hGd2lKeWxjYmlBZ0lDQWdJQ0FnTG5KbGNHeGhZMlVvTHlZdlp5d2dKMXdpTEZ3aUp5bGNiaUFnSUNBZ0lDQWdMbkpsY0d4aFkyVW9MejB2Wnl3Z0oxd2lPbHdpSnlrZ0sxeHVJQ0FnSUNBZ0oxd2lmU2RjYmlBZ0tUdGNibHh1SUNCamIyNXpkQ0JoWTJObGMzTlViMnRsYmlBOUlIUnZhMlZ1TG1GalkyVnpjMTkwYjJ0bGJqdGNiaUFnS0NoamJHbGxiblF1WTNKbFpHVnVkR2xoYkhNZ1lYTWdkVzVyYm05M2Jpa2dZWE1nUVdOalpYTnpWRzlyWlc0cExtRmpZMlZ6YzFSdmEyVnVJRDBnWVdOalpYTnpWRzlyWlc0N1hHNGdJRnh1SUNCeVpYUjFjbTRnWUVKbFlYSmxjaUFrZTJGalkyVnpjMVJ2YTJWdWZXQTdYRzU5WEc0aUxDSnBiWEJ2Y25RZ2V5QkpiV2QxY2tOc2FXVnVkQ0I5SUdaeWIyMGdKeTR1TDJOc2FXVnVkQ2M3WEc1cGJYQnZjblFnZXlCSlRVRkhSVjlGVGtSUVQwbE9WQ0I5SUdaeWIyMGdKeTR1TDJOdmJXMXZiaTlsYm1Sd2IybHVkSE1uTzF4dWFXMXdiM0owSUhzZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlNCOUlHWnliMjBnSnk0dUwyTnZiVzF2Ymk5MGVYQmxjeWM3WEc1cGJYQnZjblFnZXlCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxJSDBnWm5KdmJTQW5MaTR2WTI5dGJXOXVMM1YwYVd4ekp6dGNibHh1Wlhod2IzSjBJR0Z6ZVc1aklHWjFibU4wYVc5dUlHUmxiR1YwWlVsdFlXZGxLRnh1SUNCamJHbGxiblE2SUVsdFozVnlRMnhwWlc1MExGeHVJQ0JwYldGblpVaGhjMmc2SUhOMGNtbHVaMXh1S1RvZ1VISnZiV2x6WlR4SmJXZDFja0Z3YVZKbGMzQnZibk5sUEdKdmIyeGxZVzQrUGlCN1hHNGdJR052Ym5OMElIVnliQ0E5SUdBa2UwbE5RVWRGWDBWT1JGQlBTVTVVZlM4a2UybHRZV2RsU0dGemFIMWdPMXh1SUNCeVpYUjFjbTRnWjJWMFNXMW5kWEpCY0dsU1pYTndiMjV6WlVaeWIyMVNaWE53YjI1elpTaGhkMkZwZENCamJHbGxiblF1Y21WeGRXVnpkQ2g3SUhWeWJDd2diV1YwYUc5a09pQW5SRVZNUlZSRkp5QjlLU2tnWVhNZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlR4aWIyOXNaV0Z1UGp0Y2JuMWNiaUlzSW1sdGNHOXlkQ0I3SUVsdFozVnlRMnhwWlc1MElIMGdabkp2YlNBbkxpNHZZMnhwWlc1MEp6dGNibWx0Y0c5eWRDQjdJRWxOUVVkRlgwVk9SRkJQU1U1VUlIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwyVnVaSEJ2YVc1MGN5YzdYRzVwYlhCdmNuUWdleUJKYldkMWNrRndhVkpsYzNCdmJuTmxJSDBnWm5KdmJTQW5MaTR2WTI5dGJXOXVMM1I1Y0dWekp6dGNibWx0Y0c5eWRDQjdJR2RsZEVsdFozVnlRWEJwVW1WemNHOXVjMlZHY205dFVtVnpjRzl1YzJVZ2ZTQm1jbTl0SUNjdUxpOWpiMjF0YjI0dmRYUnBiSE1uTzF4dVhHNWxlSEJ2Y25RZ1lYTjVibU1nWm5WdVkzUnBiMjRnWm1GMmIzSnBkR1ZKYldGblpTaGNiaUFnWTJ4cFpXNTBPaUJKYldkMWNrTnNhV1Z1ZEN4Y2JpQWdhVzFoWjJWSVlYTm9PaUJ6ZEhKcGJtZGNiaWs2SUZCeWIyMXBjMlU4U1cxbmRYSkJjR2xTWlhOd2IyNXpaVHduWm1GMmIzSnBkR1ZrSno0K0lIdGNiaUFnWTI5dWMzUWdkWEpzSUQwZ1lDUjdTVTFCUjBWZlJVNUVVRTlKVGxSOUx5UjdhVzFoWjJWSVlYTm9mUzltWVhadmNtbDBaV0E3WEc0Z0lISmxkSFZ5YmlCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxLR0YzWVdsMElHTnNhV1Z1ZEM1eVpYRjFaWE4wS0hzZ2RYSnNMQ0J0WlhSb2IyUTZJQ2RRVDFOVUp5QjlLU2tnWVhNZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlR3blptRjJiM0pwZEdWa0p6NDdYRzU5WEc0aUxDSnBiWEJ2Y25RZ2V5QkpiV2QxY2tOc2FXVnVkQ0I5SUdaeWIyMGdKeTR1TDJOc2FXVnVkQ2M3WEc1cGJYQnZjblFnZXlCSlRVRkhSVjlGVGtSUVQwbE9WQ0I5SUdaeWIyMGdKeTR1TDJOdmJXMXZiaTlsYm1Sd2IybHVkSE1uTzF4dWFXMXdiM0owSUhzZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlN3Z1NXMWhaMlZFWVhSaElIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwzUjVjR1Z6Snp0Y2JtbHRjRzl5ZENCN0lHZGxkRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVkdjbTl0VW1WemNHOXVjMlVnZlNCbWNtOXRJQ2N1TGk5amIyMXRiMjR2ZFhScGJITW5PMXh1WEc1bGVIQnZjblFnWVhONWJtTWdablZ1WTNScGIyNGdaMlYwU1cxaFoyVW9YRzRnSUdOc2FXVnVkRG9nU1cxbmRYSkRiR2xsYm5Rc1hHNGdJR2x0WVdkbFNHRnphRG9nYzNSeWFXNW5YRzRwT2lCUWNtOXRhWE5sUEVsdFozVnlRWEJwVW1WemNHOXVjMlU4U1cxaFoyVkVZWFJoUGo0Z2UxeHVJQ0JqYjI1emRDQjFjbXdnUFNCZ0pIdEpUVUZIUlY5RlRrUlFUMGxPVkgwdkpIdHBiV0ZuWlVoaGMyaDlZRHRjYmlBZ2NtVjBkWEp1SUdkbGRFbHRaM1Z5UVhCcFVtVnpjRzl1YzJWR2NtOXRVbVZ6Y0c5dWMyVW9ZWGRoYVhRZ1kyeHBaVzUwTG5KbGNYVmxjM1FvZXlCMWNtd2dmU2twSUdGeklFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVOFNXMWhaMlZFWVhSaFBseHVmVnh1SWl3aVpYaHdiM0owSUNvZ1puSnZiU0FuTGk5a1pXeGxkR1ZKYldGblpTYzdYRzVsZUhCdmNuUWdLaUJtY205dElDY3VMMlpoZG05eWFYUmxTVzFoWjJVbk8xeHVaWGh3YjNKMElDb2dabkp2YlNBbkxpOW5aWFJKYldGblpTYzdYRzVsZUhCdmNuUWdLaUJtY205dElDY3VMM1Z3WkdGMFpVbHRZV2RsSnp0Y2JtVjRjRzl5ZENBcUlHWnliMjBnSnk0dmRYQnNiMkZrSnp0Y2JpSXNJbWx0Y0c5eWRDQjdJRWx0WjNWeVEyeHBaVzUwSUgwZ1puSnZiU0FuTGk0dlkyeHBaVzUwSnp0Y2JtbHRjRzl5ZENCN0lFbE5RVWRGWDBWT1JGQlBTVTVVSUgwZ1puSnZiU0FuTGk0dlkyOXRiVzl1TDJWdVpIQnZhVzUwY3ljN1hHNXBiWEJ2Y25RZ2V5QmpjbVZoZEdWR2IzSnRMQ0JuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObElIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwzVjBhV3h6Snp0Y2JtbHRjRzl5ZENCN0lGQmhlV3h2WVdRc0lFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVZ2ZTQm1jbTl0SUNjdUxpOWpiMjF0YjI0dmRIbHdaWE1uTzF4dVhHNWxlSEJ2Y25RZ2FXNTBaWEptWVdObElGVndaR0YwWlVsdFlXZGxVR0Y1Ykc5aFpGeHVJQ0JsZUhSbGJtUnpJRkJwWTJzOFVHRjViRzloWkN3Z0ozUnBkR3hsSnlCOElDZGtaWE5qY21sd2RHbHZiaWMrSUh0Y2JpQWdhVzFoWjJWSVlYTm9PaUJ6ZEhKcGJtYzdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHbHpWbUZzYVdSVmNHUmhkR1ZRWVhsc2IyRmtLSEE2SUZWd1pHRjBaVWx0WVdkbFVHRjViRzloWkNrZ2UxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlIQXVkR2wwYkdVZ1BUMDlJQ2R6ZEhKcGJtY25JSHg4SUhSNWNHVnZaaUJ3TG1SbGMyTnlhWEIwYVc5dUlEMDlQU0FuYzNSeWFXNW5KenRjYm4xY2JseHVaWGh3YjNKMElHRnplVzVqSUdaMWJtTjBhVzl1SUhWd1pHRjBaVWx0WVdkbEtGeHVJQ0JqYkdsbGJuUTZJRWx0WjNWeVEyeHBaVzUwTEZ4dUlDQndZWGxzYjJGa09pQlZjR1JoZEdWSmJXRm5aVkJoZVd4dllXUWdmQ0JWY0dSaGRHVkpiV0ZuWlZCaGVXeHZZV1JiWFZ4dUtUb2dVSEp2YldselpUeEpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBHSnZiMnhsWVc0K0lId2dTVzFuZFhKQmNHbFNaWE53YjI1elpUeGliMjlzWldGdVBsdGRQaUI3WEc0Z0lHbG1JQ2hCY25KaGVTNXBjMEZ5Y21GNUtIQmhlV3h2WVdRcEtTQjdYRzRnSUNBZ1kyOXVjM1FnY0hKdmJXbHpaWE1nUFNCd1lYbHNiMkZrTG0xaGNDZ29jRG9nVlhCa1lYUmxTVzFoWjJWUVlYbHNiMkZrS1NBOVBpQjdYRzRnSUNBZ0lDQnBaaUFvSVdselZtRnNhV1JWY0dSaGRHVlFZWGxzYjJGa0tIQXBLU0I3WEc0Z0lDQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduVlhCa1lYUmxJSEpsY1hWcGNtVnpJR0VnZEdsMGJHVWdZVzVrTDI5eUlHUmxjMk55YVhCMGFXOXVKeWs3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdOdmJuTjBJSFZ5YkNBOUlHQWtlMGxOUVVkRlgwVk9SRkJQU1U1VWZTOGtlM0F1YVcxaFoyVklZWE5vZldBN1hHNGdJQ0FnSUNCamIyNXpkQ0JtYjNKdElEMGdZM0psWVhSbFJtOXliU2h3S1R0Y2JpQWdJQ0FnSUM4cUlHVnpiR2x1ZENCdWJ5MWhjM2x1WXkxd2NtOXRhWE5sTFdWNFpXTjFkRzl5T2lBd0lDb3ZYRzRnSUNBZ0lDQnlaWFIxY200Z2JtVjNJRkJ5YjIxcGMyVW9ZWE41Ym1NZ1puVnVZM1JwYjI0b2NtVnpiMngyWlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnlaWE52YkhabEtHZGxkRWx0WjNWeVFYQnBVbVZ6Y0c5dWMyVkdjbTl0VW1WemNHOXVjMlVvWVhkaGFYUWdZMnhwWlc1MExuSmxjWFZsYzNRb2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZFhKc0xGeHVJQ0FnSUNBZ0lDQWdJQ0FnYldWMGFHOWtPaUFuVUU5VFZDY3NYRzRnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhPaUJtYjNKdExGeHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2NtVnpiMngyWlVKdlpIbFBibXg1T2lCMGNuVmxMRnh1SUNBZ0lDQWdJQ0FnSUgwcEtTQmhjeUJKYldkMWNrRndhVkpsYzNCdmJuTmxQR0p2YjJ4bFlXNCtLVnh1SUNBZ0lDQWdJQ0I5S1NCaGN5QlFjbTl0YVhObFBFbHRaM1Z5UVhCcFVtVnpjRzl1YzJVOFltOXZiR1ZoYmo0K08xeHVJQ0FnSUgwcE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUdGM1lXbDBJRkJ5YjIxcGMyVXVZV3hzS0hCeWIyMXBjMlZ6S1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2doYVhOV1lXeHBaRlZ3WkdGMFpWQmhlV3h2WVdRb2NHRjViRzloWkNrcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjFWd1pHRjBaU0J5WlhGMWFYSmxjeUJoSUhScGRHeGxJR0Z1WkM5dmNpQmtaWE5qY21sd2RHbHZiaWNwTzF4dUlDQjlYRzVjYmlBZ1kyOXVjM1FnZFhKc0lEMGdZQ1I3U1UxQlIwVmZSVTVFVUU5SlRsUjlMeVI3Y0dGNWJHOWhaQzVwYldGblpVaGhjMmg5WUR0Y2JpQWdZMjl1YzNRZ1ptOXliU0E5SUdOeVpXRjBaVVp2Y20wb2NHRjViRzloWkNrN1hHNGdJSEpsZEhWeWJpQm5aWFJKYldkMWNrRndhVkpsYzNCdmJuTmxSbkp2YlZKbGMzQnZibk5sS0dGM1lXbDBJR05zYVdWdWRDNXlaWEYxWlhOMEtIdGNiaUFnSUNCMWNtd3NYRzRnSUNBZ2JXVjBhRzlrT2lBblVFOVRWQ2NzWEc0Z0lDQWdaR0YwWVRvZ1ptOXliU3hjYmlBZ0lDQXZMeUJ5WlhOdmJIWmxRbTlrZVU5dWJIazZJSFJ5ZFdVc1hHNGdJSDBwS1NCaGN5QkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBHSnZiMnhsWVc0K1hHNTlYRzRpTENKcGJYQnZjblFnZXlCSmJXZDFja05zYVdWdWRDQjlJR1p5YjIwZ0p5NHVMMk5zYVdWdWRDYzdYRzVwYlhCdmNuUWdlMXh1SUNCamNtVmhkR1ZHYjNKdExGeHVJQ0JuWlhSSmJXZDFja0Z3YVZKbGMzQnZibk5sUm5KdmJWSmxjM0J2Ym5ObExGeHVJQ0F2THlCblpYUlRiM1Z5WTJVc1hHNTlJR1p5YjIwZ0p5NHVMMk52YlcxdmJpOTFkR2xzY3ljN1hHNXBiWEJ2Y25RZ2V5QlFZWGxzYjJGa0xDQkpiV2QxY2tGd2FWSmxjM0J2Ym5ObExDQkpiV0ZuWlVSaGRHRWdmU0JtY205dElDY3VMaTlqYjIxdGIyNHZkSGx3WlhNbk8xeHVhVzF3YjNKMElIc2dWVkJNVDBGRVgwVk9SRkJQU1U1VUlIMGdabkp2YlNBbkxpNHZZMjl0Ylc5dUwyVnVaSEJ2YVc1MGN5YzdYRzVjYm1WNGNHOXlkQ0JoYzNsdVl5Qm1kVzVqZEdsdmJpQjFjR3h2WVdRb1hHNGdJR05zYVdWdWREb2dTVzFuZFhKRGJHbGxiblFzWEc0Z0lIQmhlV3h2WVdRNklITjBjbWx1WnlCOElITjBjbWx1WjF0ZElId2dVR0Y1Ykc5aFpDQjhJRkJoZVd4dllXUmJYVnh1S1RvZ1VISnZiV2x6WlR4SmJXZDFja0Z3YVZKbGMzQnZibk5sUEVsdFlXZGxSR0YwWVQ0Z2ZDQkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFBFbHRZV2RsUkdGMFlUNWJYVDRnZTF4dUlDQnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaHdZWGxzYjJGa0tTa2dlMXh1SUNBZ0lHTnZibk4wSUhCeWIyMXBjMlZ6SUQwZ2NHRjViRzloWkM1dFlYQW9LSEE2SUhOMGNtbHVaeUI4SUZCaGVXeHZZV1FwSUQwK0lIdGNiaUFnSUNBZ0lHTnZibk4wSUdadmNtMGdQU0JqY21WaGRHVkdiM0p0S0hBcE8xeHVYRzRnSUNBZ0lDQXZLaUJsYzJ4cGJuUWdibTh0WVhONWJtTXRjSEp2YldselpTMWxlR1ZqZFhSdmNqb2dNQ0FxTDF4dUlDQWdJQ0FnY21WMGRYSnVJRzVsZHlCUWNtOXRhWE5sS0dGemVXNWpJQ2h5WlhOdmJIWmxLU0E5UGlCN1hHNGdJQ0FnSUNBZ0lISmxjMjlzZG1Vb1oyVjBTVzFuZFhKQmNHbFNaWE53YjI1elpVWnliMjFTWlhOd2IyNXpaU2hjYmlBZ0lDQWdJQ0FnSUNBZ0lHRjNZV2wwSUdOc2FXVnVkQzV5WlhGMVpYTjBLSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdkWEpzT2lCVlVFeFBRVVJmUlU1RVVFOUpUbFFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRzFsZEdodlpEb2dKMUJQVTFRbkxGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCa1lYUmhPaUJtYjNKdExGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCdmJsVndiRzloWkZCeWIyZHlaWE56T2lBb2NISnZaM0psYzNORmRtVnVkQ2tnUFQ0Z2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTnZibk52YkdVdWJHOW5LSHNnY0hKdlozSmxjM05GZG1WdWRDQjlLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYkdsbGJuUXVaVzFwZENnbmRYQnNiMkZrVUhKdlozSmxjM01uTENCN0lDNHVMbkJ5YjJkeVpYTnpSWFpsYm5RZ2ZTazdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMHNYRzRnSUNBZ0lDQWdJQ0FnSUNCOUtWeHVJQ0FnSUNBZ0lDQWdJQ2tnWVhNZ1NXMW5kWEpCY0dsU1pYTndiMjV6WlR4SmJXRm5aVVJoZEdFK0tUdGNiaUFnSUNBZ0lIMHBJR0Z6SUZCeWIyMXBjMlU4U1cxbmRYSkJjR2xTWlhOd2IyNXpaVHhKYldGblpVUmhkR0UrUGp0Y2JpQWdJQ0I5S1R0Y2JpQWdJQ0J5WlhSMWNtNGdZWGRoYVhRZ1VISnZiV2x6WlM1aGJHd29jSEp2YldselpYTXBPMXh1SUNCOVhHNWNiaUFnWTI5dWMzUWdabTl5YlNBOUlHTnlaV0YwWlVadmNtMG9jR0Y1Ykc5aFpDazdYRzRnSUM4dklHTnZibk4wSUdsa0lEMGdSR0YwWlM1dWIzY3VkRzlUZEhKcGJtY29LVHRjYmlBZ1kyOXVjM1FnY21WeGRXVnpkQ0E5SUdGM1lXbDBJR05zYVdWdWRDNXlaWEYxWlhOMEtIdGNiaUFnSUNCMWNtdzZJRlZRVEU5QlJGOUZUa1JRVDBsT1ZDeGNiaUFnSUNCdFpYUm9iMlE2SUNkUVQxTlVKeXhjYmlBZ0lDQmtZWFJoT2lCbWIzSnRMRnh1SUNBZ0lHOXVWWEJzYjJGa1VISnZaM0psYzNNNklDaHdjbTluY21WemMwVjJaVzUwS1NBOVBpQjdYRzRnSUNBZ0lDQmpiMjV6YjJ4bExteHZaeWg3SUhCeWIyZHlaWE56UlhabGJuUWdmU2s3WEc0Z0lDQWdJQ0JqYkdsbGJuUXVaVzFwZENnbmRYQnNiMkZrVUhKdlozSmxjM01uTENCN0lDNHVMbkJ5YjJkeVpYTnpSWFpsYm5RZ2ZTazdYRzRnSUNBZ2ZTeGNiaUFnZlNrN1hHNWNiaUFnY21WMGRYSnVJRkJ5YjIxcGMyVXVjbVZ6YjJ4MlpTaGNiaUFnSUNCblpYUkpiV2QxY2tGd2FWSmxjM0J2Ym5ObFJuSnZiVkpsYzNCdmJuTmxLSEpsY1hWbGMzUXBJR0Z6SUVsdFozVnlRWEJwVW1WemNHOXVjMlU4U1cxaFoyVkVZWFJoUGx4dUlDQXBPMXh1ZlZ4dUlpd2lMeW9oSUNvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FYSEpjYmtOdmNIbHlhV2RvZENBb1l5a2dUV2xqY205emIyWjBJRU52Y25CdmNtRjBhVzl1TGx4eVhHNWNjbHh1VUdWeWJXbHpjMmx2YmlCMGJ5QjFjMlVzSUdOdmNIa3NJRzF2WkdsbWVTd2dZVzVrTDI5eUlHUnBjM1J5YVdKMWRHVWdkR2hwY3lCemIyWjBkMkZ5WlNCbWIzSWdZVzU1WEhKY2JuQjFjbkJ2YzJVZ2QybDBhQ0J2Y2lCM2FYUm9iM1YwSUdabFpTQnBjeUJvWlhKbFlua2daM0poYm5SbFpDNWNjbHh1WEhKY2JsUklSU0JUVDBaVVYwRlNSU0JKVXlCUVVrOVdTVVJGUkNCY0lrRlRJRWxUWENJZ1FVNUVJRlJJUlNCQlZWUklUMUlnUkVsVFEweEJTVTFUSUVGTVRDQlhRVkpTUVU1VVNVVlRJRmRKVkVoY2NseHVVa1ZIUVZKRUlGUlBJRlJJU1ZNZ1UwOUdWRmRCVWtVZ1NVNURURlZFU1U1SElFRk1UQ0JKVFZCTVNVVkVJRmRCVWxKQlRsUkpSVk1nVDBZZ1RVVlNRMGhCVGxSQlFrbE1TVlJaWEhKY2JrRk9SQ0JHU1ZST1JWTlRMaUJKVGlCT1R5QkZWa1ZPVkNCVFNFRk1UQ0JVU0VVZ1FWVlVTRTlTSUVKRklFeEpRVUpNUlNCR1QxSWdRVTVaSUZOUVJVTkpRVXdzSUVSSlVrVkRWQ3hjY2x4dVNVNUVTVkpGUTFRc0lFOVNJRU5QVGxORlVWVkZUbFJKUVV3Z1JFRk5RVWRGVXlCUFVpQkJUbGtnUkVGTlFVZEZVeUJYU0VGVVUwOUZWa1ZTSUZKRlUxVk1WRWxPUnlCR1VrOU5YSEpjYmt4UFUxTWdUMFlnVlZORkxDQkVRVlJCSUU5U0lGQlNUMFpKVkZNc0lGZElSVlJJUlZJZ1NVNGdRVTRnUVVOVVNVOU9JRTlHSUVOUFRsUlNRVU5VTENCT1JVZE1TVWRGVGtORklFOVNYSEpjYms5VVNFVlNJRlJQVWxSSlQxVlRJRUZEVkVsUFRpd2dRVkpKVTBsT1J5QlBWVlFnVDBZZ1QxSWdTVTRnUTA5T1RrVkRWRWxQVGlCWFNWUklJRlJJUlNCVlUwVWdUMUpjY2x4dVVFVlNSazlTVFVGT1EwVWdUMFlnVkVoSlV5QlRUMFpVVjBGU1JTNWNjbHh1S2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb2dLaTljY2x4dUx5b2daMnh2WW1Gc0lGSmxabXhsWTNRc0lGQnliMjFwYzJVZ0tpOWNjbHh1WEhKY2JuWmhjaUJsZUhSbGJtUlRkR0YwYVdOeklEMGdablZ1WTNScGIyNG9aQ3dnWWlrZ2UxeHlYRzRnSUNBZ1pYaDBaVzVrVTNSaGRHbGpjeUE5SUU5aWFtVmpkQzV6WlhSUWNtOTBiM1I1Y0dWUFppQjhmRnh5WEc0Z0lDQWdJQ0FnSUNoN0lGOWZjSEp2ZEc5Zlh6b2dXMTBnZlNCcGJuTjBZVzVqWlc5bUlFRnljbUY1SUNZbUlHWjFibU4wYVc5dUlDaGtMQ0JpS1NCN0lHUXVYMTl3Y205MGIxOWZJRDBnWWpzZ2ZTa2dmSHhjY2x4dUlDQWdJQ0FnSUNCbWRXNWpkR2x2YmlBb1pDd2dZaWtnZXlCbWIzSWdLSFpoY2lCd0lHbHVJR0lwSUdsbUlDaGlMbWhoYzA5M2JsQnliM0JsY25SNUtIQXBLU0JrVzNCZElEMGdZbHR3WFRzZ2ZUdGNjbHh1SUNBZ0lISmxkSFZ5YmlCbGVIUmxibVJUZEdGMGFXTnpLR1FzSUdJcE8xeHlYRzU5TzF4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmWlhoMFpXNWtjeWhrTENCaUtTQjdYSEpjYmlBZ0lDQmxlSFJsYm1SVGRHRjBhV056S0dRc0lHSXBPMXh5WEc0Z0lDQWdablZ1WTNScGIyNGdYMThvS1NCN0lIUm9hWE11WTI5dWMzUnlkV04wYjNJZ1BTQmtPeUI5WEhKY2JpQWdJQ0JrTG5CeWIzUnZkSGx3WlNBOUlHSWdQVDA5SUc1MWJHd2dQeUJQWW1wbFkzUXVZM0psWVhSbEtHSXBJRG9nS0Y5ZkxuQnliM1J2ZEhsd1pTQTlJR0l1Y0hKdmRHOTBlWEJsTENCdVpYY2dYMThvS1NrN1hISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQjJZWElnWDE5aGMzTnBaMjRnUFNCbWRXNWpkR2x2YmlncElIdGNjbHh1SUNBZ0lGOWZZWE56YVdkdUlEMGdUMkpxWldOMExtRnpjMmxuYmlCOGZDQm1kVzVqZEdsdmJpQmZYMkZ6YzJsbmJpaDBLU0I3WEhKY2JpQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2N5d2dhU0E5SURFc0lHNGdQU0JoY21kMWJXVnVkSE11YkdWdVozUm9PeUJwSUR3Z2Jqc2dhU3NyS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhNZ1BTQmhjbWQxYldWdWRITmJhVjA3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJSEFnYVc0Z2N5a2dhV1lnS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1YUdGelQzZHVVSEp2Y0dWeWRIa3VZMkZzYkNoekxDQndLU2tnZEZ0d1hTQTlJSE5iY0YwN1hISmNiaUFnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwTzF4eVhHNGdJQ0FnZlZ4eVhHNGdJQ0FnY21WMGRYSnVJRjlmWVhOemFXZHVMbUZ3Y0d4NUtIUm9hWE1zSUdGeVozVnRaVzUwY3lrN1hISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmZYM0psYzNRb2N5d2daU2tnZTF4eVhHNGdJQ0FnZG1GeUlIUWdQU0I3ZlR0Y2NseHVJQ0FnSUdadmNpQW9kbUZ5SUhBZ2FXNGdjeWtnYVdZZ0tFOWlhbVZqZEM1d2NtOTBiM1I1Y0dVdWFHRnpUM2R1VUhKdmNHVnlkSGt1WTJGc2JDaHpMQ0J3S1NBbUppQmxMbWx1WkdWNFQyWW9jQ2tnUENBd0tWeHlYRzRnSUNBZ0lDQWdJSFJiY0YwZ1BTQnpXM0JkTzF4eVhHNGdJQ0FnYVdZZ0tITWdJVDBnYm5Wc2JDQW1KaUIwZVhCbGIyWWdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjeUE5UFQwZ1hDSm1kVzVqZEdsdmJsd2lLVnh5WEc0Z0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdMQ0J3SUQwZ1QySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVVM2x0WW05c2N5aHpLVHNnYVNBOElIQXViR1Z1WjNSb095QnBLeXNwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHVXVhVzVrWlhoUFppaHdXMmxkS1NBOElEQWdKaVlnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzV3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlM1allXeHNLSE1zSUhCYmFWMHBLVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZEZ0d1cybGRYU0E5SUhOYmNGdHBYVjA3WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ2NtVjBkWEp1SUhRN1hISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmZYMlJsWTI5eVlYUmxLR1JsWTI5eVlYUnZjbk1zSUhSaGNtZGxkQ3dnYTJWNUxDQmtaWE5qS1NCN1hISmNiaUFnSUNCMllYSWdZeUE5SUdGeVozVnRaVzUwY3k1c1pXNW5kR2dzSUhJZ1BTQmpJRHdnTXlBL0lIUmhjbWRsZENBNklHUmxjMk1nUFQwOUlHNTFiR3dnUHlCa1pYTmpJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNpaDBZWEpuWlhRc0lHdGxlU2tnT2lCa1pYTmpMQ0JrTzF4eVhHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCU1pXWnNaV04wSUQwOVBTQmNJbTlpYW1WamRGd2lJQ1ltSUhSNWNHVnZaaUJTWldac1pXTjBMbVJsWTI5eVlYUmxJRDA5UFNCY0ltWjFibU4wYVc5dVhDSXBJSElnUFNCU1pXWnNaV04wTG1SbFkyOXlZWFJsS0dSbFkyOXlZWFJ2Y25Nc0lIUmhjbWRsZEN3Z2EyVjVMQ0JrWlhOaktUdGNjbHh1SUNBZ0lHVnNjMlVnWm05eUlDaDJZWElnYVNBOUlHUmxZMjl5WVhSdmNuTXViR1Z1WjNSb0lDMGdNVHNnYVNBK1BTQXdPeUJwTFMwcElHbG1JQ2hrSUQwZ1pHVmpiM0poZEc5eWMxdHBYU2tnY2lBOUlDaGpJRHdnTXlBL0lHUW9jaWtnT2lCaklENGdNeUEvSUdRb2RHRnlaMlYwTENCclpYa3NJSElwSURvZ1pDaDBZWEpuWlhRc0lHdGxlU2twSUh4OElISTdYSEpjYmlBZ0lDQnlaWFIxY200Z1l5QStJRE1nSmlZZ2NpQW1KaUJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb2RHRnlaMlYwTENCclpYa3NJSElwTENCeU8xeHlYRzU5WEhKY2JseHlYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdYMTl3WVhKaGJTaHdZWEpoYlVsdVpHVjRMQ0JrWldOdmNtRjBiM0lwSUh0Y2NseHVJQ0FnSUhKbGRIVnliaUJtZFc1amRHbHZiaUFvZEdGeVoyVjBMQ0JyWlhrcElIc2daR1ZqYjNKaGRHOXlLSFJoY21kbGRDd2dhMlY1TENCd1lYSmhiVWx1WkdWNEtUc2dmVnh5WEc1OVhISmNibHh5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWDE5dFpYUmhaR0YwWVNodFpYUmhaR0YwWVV0bGVTd2diV1YwWVdSaGRHRldZV3gxWlNrZ2UxeHlYRzRnSUNBZ2FXWWdLSFI1Y0dWdlppQlNaV1pzWldOMElEMDlQU0JjSW05aWFtVmpkRndpSUNZbUlIUjVjR1Z2WmlCU1pXWnNaV04wTG0xbGRHRmtZWFJoSUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lwSUhKbGRIVnliaUJTWldac1pXTjBMbTFsZEdGa1lYUmhLRzFsZEdGa1lYUmhTMlY1TENCdFpYUmhaR0YwWVZaaGJIVmxLVHRjY2x4dWZWeHlYRzVjY2x4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUY5ZllYZGhhWFJsY2loMGFHbHpRWEpuTENCZllYSm5kVzFsYm5SekxDQlFMQ0JuWlc1bGNtRjBiM0lwSUh0Y2NseHVJQ0FnSUdaMWJtTjBhVzl1SUdGa2IzQjBLSFpoYkhWbEtTQjdJSEpsZEhWeWJpQjJZV3gxWlNCcGJuTjBZVzVqWlc5bUlGQWdQeUIyWVd4MVpTQTZJRzVsZHlCUUtHWjFibU4wYVc5dUlDaHlaWE52YkhabEtTQjdJSEpsYzI5c2RtVW9kbUZzZFdVcE95QjlLVHNnZlZ4eVhHNGdJQ0FnY21WMGRYSnVJRzVsZHlBb1VDQjhmQ0FvVUNBOUlGQnliMjFwYzJVcEtTaG1kVzVqZEdsdmJpQW9jbVZ6YjJ4MlpTd2djbVZxWldOMEtTQjdYSEpjYmlBZ0lDQWdJQ0FnWm5WdVkzUnBiMjRnWm5Wc1ptbHNiR1ZrS0haaGJIVmxLU0I3SUhSeWVTQjdJSE4wWlhBb1oyVnVaWEpoZEc5eUxtNWxlSFFvZG1Gc2RXVXBLVHNnZlNCallYUmphQ0FvWlNrZ2V5QnlaV3BsWTNRb1pTazdJSDBnZlZ4eVhHNGdJQ0FnSUNBZ0lHWjFibU4wYVc5dUlISmxhbVZqZEdWa0tIWmhiSFZsS1NCN0lIUnllU0I3SUhOMFpYQW9aMlZ1WlhKaGRHOXlXMXdpZEdoeWIzZGNJbDBvZG1Gc2RXVXBLVHNnZlNCallYUmphQ0FvWlNrZ2V5QnlaV3BsWTNRb1pTazdJSDBnZlZ4eVhHNGdJQ0FnSUNBZ0lHWjFibU4wYVc5dUlITjBaWEFvY21WemRXeDBLU0I3SUhKbGMzVnNkQzVrYjI1bElEOGdjbVZ6YjJ4MlpTaHlaWE4xYkhRdWRtRnNkV1VwSURvZ1lXUnZjSFFvY21WemRXeDBMblpoYkhWbEtTNTBhR1Z1S0daMWJHWnBiR3hsWkN3Z2NtVnFaV04wWldRcE95QjlYSEpjYmlBZ0lDQWdJQ0FnYzNSbGNDZ29aMlZ1WlhKaGRHOXlJRDBnWjJWdVpYSmhkRzl5TG1Gd2NHeDVLSFJvYVhOQmNtY3NJRjloY21kMWJXVnVkSE1nZkh3Z1cxMHBLUzV1WlhoMEtDa3BPMXh5WEc0Z0lDQWdmU2s3WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgyZGxibVZ5WVhSdmNpaDBhR2x6UVhKbkxDQmliMlI1S1NCN1hISmNiaUFnSUNCMllYSWdYeUE5SUhzZ2JHRmlaV3c2SURBc0lITmxiblE2SUdaMWJtTjBhVzl1S0NrZ2V5QnBaaUFvZEZzd1hTQW1JREVwSUhSb2NtOTNJSFJiTVYwN0lISmxkSFZ5YmlCMFd6RmRPeUI5TENCMGNubHpPaUJiWFN3Z2IzQnpPaUJiWFNCOUxDQm1MQ0I1TENCMExDQm5PMXh5WEc0Z0lDQWdjbVYwZFhKdUlHY2dQU0I3SUc1bGVIUTZJSFpsY21Jb01Da3NJRndpZEdoeWIzZGNJam9nZG1WeVlpZ3hLU3dnWENKeVpYUjFjbTVjSWpvZ2RtVnlZaWd5S1NCOUxDQjBlWEJsYjJZZ1UzbHRZbTlzSUQwOVBTQmNJbVoxYm1OMGFXOXVYQ0lnSmlZZ0tHZGJVM2x0WW05c0xtbDBaWEpoZEc5eVhTQTlJR1oxYm1OMGFXOXVLQ2tnZXlCeVpYUjFjbTRnZEdocGN6c2dmU2tzSUdjN1hISmNiaUFnSUNCbWRXNWpkR2x2YmlCMlpYSmlLRzRwSUhzZ2NtVjBkWEp1SUdaMWJtTjBhVzl1SUNoMktTQjdJSEpsZEhWeWJpQnpkR1Z3S0Z0dUxDQjJYU2s3SUgwN0lIMWNjbHh1SUNBZ0lHWjFibU4wYVc5dUlITjBaWEFvYjNBcElIdGNjbHh1SUNBZ0lDQWdJQ0JwWmlBb1ppa2dkR2h5YjNjZ2JtVjNJRlI1Y0dWRmNuSnZjaWhjSWtkbGJtVnlZWFJ2Y2lCcGN5QmhiSEpsWVdSNUlHVjRaV04xZEdsdVp5NWNJaWs3WEhKY2JpQWdJQ0FnSUNBZ2QyaHBiR1VnS0Y4cElIUnllU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNobUlEMGdNU3dnZVNBbUppQW9kQ0E5SUc5d1d6QmRJQ1lnTWlBL0lIbGJYQ0p5WlhSMWNtNWNJbDBnT2lCdmNGc3dYU0EvSUhsYlhDSjBhSEp2ZDF3aVhTQjhmQ0FvS0hRZ1BTQjVXMXdpY21WMGRYSnVYQ0pkS1NBbUppQjBMbU5oYkd3b2VTa3NJREFwSURvZ2VTNXVaWGgwS1NBbUppQWhLSFFnUFNCMExtTmhiR3dvZVN3Z2IzQmJNVjBwS1M1a2IyNWxLU0J5WlhSMWNtNGdkRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hrZ1BTQXdMQ0IwS1NCdmNDQTlJRnR2Y0Zzd1hTQW1JRElzSUhRdWRtRnNkV1ZkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J6ZDJsMFkyZ2dLRzl3V3pCZEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqWVhObElEQTZJR05oYzJVZ01Ub2dkQ0E5SUc5d095QmljbVZoYXp0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHTmhjMlVnTkRvZ1h5NXNZV0psYkNzck95QnlaWFIxY200Z2V5QjJZV3gxWlRvZ2IzQmJNVjBzSUdSdmJtVTZJR1poYkhObElIMDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqWVhObElEVTZJRjh1YkdGaVpXd3JLenNnZVNBOUlHOXdXekZkT3lCdmNDQTlJRnN3WFRzZ1kyOXVkR2x1ZFdVN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpZWE5sSURjNklHOXdJRDBnWHk1dmNITXVjRzl3S0NrN0lGOHVkSEo1Y3k1d2IzQW9LVHNnWTI5dWRHbHVkV1U3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCa1pXWmhkV3gwT2x4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaEtIUWdQU0JmTG5SeWVYTXNJSFFnUFNCMExteGxibWQwYUNBK0lEQWdKaVlnZEZ0MExteGxibWQwYUNBdElERmRLU0FtSmlBb2IzQmJNRjBnUFQwOUlEWWdmSHdnYjNCYk1GMGdQVDA5SURJcEtTQjdJRjhnUFNBd095QmpiMjUwYVc1MVpUc2dmVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2h2Y0Zzd1hTQTlQVDBnTXlBbUppQW9JWFFnZkh3Z0tHOXdXekZkSUQ0Z2RGc3dYU0FtSmlCdmNGc3hYU0E4SUhSYk0xMHBLU2tnZXlCZkxteGhZbVZzSUQwZ2IzQmJNVjA3SUdKeVpXRnJPeUI5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdhV1lnS0c5d1d6QmRJRDA5UFNBMklDWW1JRjh1YkdGaVpXd2dQQ0IwV3pGZEtTQjdJRjh1YkdGaVpXd2dQU0IwV3pGZE95QjBJRDBnYjNBN0lHSnlaV0ZyT3lCOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tIUWdKaVlnWHk1c1lXSmxiQ0E4SUhSYk1sMHBJSHNnWHk1c1lXSmxiQ0E5SUhSYk1sMDdJRjh1YjNCekxuQjFjMmdvYjNBcE95QmljbVZoYXpzZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaDBXekpkS1NCZkxtOXdjeTV3YjNBb0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCZkxuUnllWE11Y0c5d0tDazdJR052Ym5ScGJuVmxPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHOXdJRDBnWW05a2VTNWpZV3hzS0hSb2FYTkJjbWNzSUY4cE8xeHlYRzRnSUNBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUhzZ2IzQWdQU0JiTml3Z1pWMDdJSGtnUFNBd095QjlJR1pwYm1Gc2JIa2dleUJtSUQwZ2RDQTlJREE3SUgxY2NseHVJQ0FnSUNBZ0lDQnBaaUFvYjNCYk1GMGdKaUExS1NCMGFISnZkeUJ2Y0ZzeFhUc2djbVYwZFhKdUlIc2dkbUZzZFdVNklHOXdXekJkSUQ4Z2IzQmJNVjBnT2lCMmIybGtJREFzSUdSdmJtVTZJSFJ5ZFdVZ2ZUdGNjbHh1SUNBZ0lIMWNjbHh1ZlZ4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmWTNKbFlYUmxRbWx1WkdsdVp5aHZMQ0J0TENCckxDQnJNaWtnZTF4eVhHNGdJQ0FnYVdZZ0tHc3lJRDA5UFNCMWJtUmxabWx1WldRcElHc3lJRDBnYXp0Y2NseHVJQ0FnSUc5YmF6SmRJRDBnYlZ0clhUdGNjbHh1ZlZ4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmWlhod2IzSjBVM1JoY2lodExDQmxlSEJ2Y25SektTQjdYSEpjYmlBZ0lDQm1iM0lnS0haaGNpQndJR2x1SUcwcElHbG1JQ2h3SUNFOVBTQmNJbVJsWm1GMWJIUmNJaUFtSmlBaFpYaHdiM0owY3k1b1lYTlBkMjVRY205d1pYSjBlU2h3S1NrZ1pYaHdiM0owYzF0d1hTQTlJRzFiY0YwN1hISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmZYM1poYkhWbGN5aHZLU0I3WEhKY2JpQWdJQ0IyWVhJZ2N5QTlJSFI1Y0dWdlppQlRlVzFpYjJ3Z1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQlRlVzFpYjJ3dWFYUmxjbUYwYjNJc0lHMGdQU0J6SUNZbUlHOWJjMTBzSUdrZ1BTQXdPMXh5WEc0Z0lDQWdhV1lnS0cwcElISmxkSFZ5YmlCdExtTmhiR3dvYnlrN1hISmNiaUFnSUNCcFppQW9ieUFtSmlCMGVYQmxiMllnYnk1c1pXNW5kR2dnUFQwOUlGd2liblZ0WW1WeVhDSXBJSEpsZEhWeWJpQjdYSEpjYmlBZ0lDQWdJQ0FnYm1WNGREb2dablZ1WTNScGIyNGdLQ2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2J5QW1KaUJwSUQ0OUlHOHViR1Z1WjNSb0tTQnZJRDBnZG05cFpDQXdPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2V5QjJZV3gxWlRvZ2J5QW1KaUJ2VzJrcksxMHNJR1J2Ym1VNklDRnZJSDA3WEhKY2JpQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ2ZUdGNjbHh1SUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9jeUEvSUZ3aVQySnFaV04wSUdseklHNXZkQ0JwZEdWeVlXSnNaUzVjSWlBNklGd2lVM2x0WW05c0xtbDBaWEpoZEc5eUlHbHpJRzV2ZENCa1pXWnBibVZrTGx3aUtUdGNjbHh1ZlZ4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmY21WaFpDaHZMQ0J1S1NCN1hISmNiaUFnSUNCMllYSWdiU0E5SUhSNWNHVnZaaUJUZVcxaWIyd2dQVDA5SUZ3aVpuVnVZM1JwYjI1Y0lpQW1KaUJ2VzFONWJXSnZiQzVwZEdWeVlYUnZjbDA3WEhKY2JpQWdJQ0JwWmlBb0lXMHBJSEpsZEhWeWJpQnZPMXh5WEc0Z0lDQWdkbUZ5SUdrZ1BTQnRMbU5oYkd3b2J5a3NJSElzSUdGeUlEMGdXMTBzSUdVN1hISmNiaUFnSUNCMGNua2dlMXh5WEc0Z0lDQWdJQ0FnSUhkb2FXeGxJQ2dvYmlBOVBUMGdkbTlwWkNBd0lIeDhJRzR0TFNBK0lEQXBJQ1ltSUNFb2NpQTlJR2t1Ym1WNGRDZ3BLUzVrYjI1bEtTQmhjaTV3ZFhOb0tISXVkbUZzZFdVcE8xeHlYRzRnSUNBZ2ZWeHlYRzRnSUNBZ1kyRjBZMmdnS0dWeWNtOXlLU0I3SUdVZ1BTQjdJR1Z5Y205eU9pQmxjbkp2Y2lCOU95QjlYSEpjYmlBZ0lDQm1hVzVoYkd4NUlIdGNjbHh1SUNBZ0lDQWdJQ0IwY25rZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9jaUFtSmlBaGNpNWtiMjVsSUNZbUlDaHRJRDBnYVZ0Y0luSmxkSFZ5Ymx3aVhTa3BJRzB1WTJGc2JDaHBLVHRjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdabWx1WVd4c2VTQjdJR2xtSUNobEtTQjBhSEp2ZHlCbExtVnljbTl5T3lCOVhISmNiaUFnSUNCOVhISmNiaUFnSUNCeVpYUjFjbTRnWVhJN1hISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmZYM053Y21WaFpDZ3BJSHRjY2x4dUlDQWdJR1p2Y2lBb2RtRnlJR0Z5SUQwZ1cxMHNJR2tnUFNBd095QnBJRHdnWVhKbmRXMWxiblJ6TG14bGJtZDBhRHNnYVNzcktWeHlYRzRnSUNBZ0lDQWdJR0Z5SUQwZ1lYSXVZMjl1WTJGMEtGOWZjbVZoWkNoaGNtZDFiV1Z1ZEhOYmFWMHBLVHRjY2x4dUlDQWdJSEpsZEhWeWJpQmhjanRjY2x4dWZWeHlYRzVjY2x4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUY5ZmMzQnlaV0ZrUVhKeVlYbHpLQ2tnZTF4eVhHNGdJQ0FnWm05eUlDaDJZWElnY3lBOUlEQXNJR2tnUFNBd0xDQnBiQ0E5SUdGeVozVnRaVzUwY3k1c1pXNW5kR2c3SUdrZ1BDQnBiRHNnYVNzcktTQnpJQ3M5SUdGeVozVnRaVzUwYzF0cFhTNXNaVzVuZEdnN1hISmNiaUFnSUNCbWIzSWdLSFpoY2lCeUlEMGdRWEp5WVhrb2N5a3NJR3NnUFNBd0xDQnBJRDBnTURzZ2FTQThJR2xzT3lCcEt5c3BYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaDJZWElnWVNBOUlHRnlaM1Z0Wlc1MGMxdHBYU3dnYWlBOUlEQXNJR3BzSUQwZ1lTNXNaVzVuZEdnN0lHb2dQQ0JxYkRzZ2Fpc3JMQ0JyS3lzcFhISmNiaUFnSUNBZ0lDQWdJQ0FnSUhKYmExMGdQU0JoVzJwZE8xeHlYRzRnSUNBZ2NtVjBkWEp1SUhJN1hISmNibjA3WEhKY2JseHlYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdYMTloZDJGcGRDaDJLU0I3WEhKY2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3lCcGJuTjBZVzVqWlc5bUlGOWZZWGRoYVhRZ1B5QW9kR2hwY3k1MklEMGdkaXdnZEdocGN5a2dPaUJ1WlhjZ1gxOWhkMkZwZENoMktUdGNjbHh1ZlZ4eVhHNWNjbHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJRjlmWVhONWJtTkhaVzVsY21GMGIzSW9kR2hwYzBGeVp5d2dYMkZ5WjNWdFpXNTBjeXdnWjJWdVpYSmhkRzl5S1NCN1hISmNiaUFnSUNCcFppQW9JVk41YldKdmJDNWhjM2x1WTBsMFpYSmhkRzl5S1NCMGFISnZkeUJ1WlhjZ1ZIbHdaVVZ5Y205eUtGd2lVM2x0WW05c0xtRnplVzVqU1hSbGNtRjBiM0lnYVhNZ2JtOTBJR1JsWm1sdVpXUXVYQ0lwTzF4eVhHNGdJQ0FnZG1GeUlHY2dQU0JuWlc1bGNtRjBiM0l1WVhCd2JIa29kR2hwYzBGeVp5d2dYMkZ5WjNWdFpXNTBjeUI4ZkNCYlhTa3NJR2tzSUhFZ1BTQmJYVHRjY2x4dUlDQWdJSEpsZEhWeWJpQnBJRDBnZTMwc0lIWmxjbUlvWENKdVpYaDBYQ0lwTENCMlpYSmlLRndpZEdoeWIzZGNJaWtzSUhabGNtSW9YQ0p5WlhSMWNtNWNJaWtzSUdsYlUzbHRZbTlzTG1GemVXNWpTWFJsY21GMGIzSmRJRDBnWm5WdVkzUnBiMjRnS0NrZ2V5QnlaWFIxY200Z2RHaHBjenNnZlN3Z2FUdGNjbHh1SUNBZ0lHWjFibU4wYVc5dUlIWmxjbUlvYmlrZ2V5QnBaaUFvWjF0dVhTa2dhVnR1WFNBOUlHWjFibU4wYVc5dUlDaDJLU0I3SUhKbGRIVnliaUJ1WlhjZ1VISnZiV2x6WlNobWRXNWpkR2x2YmlBb1lTd2dZaWtnZXlCeExuQjFjMmdvVzI0c0lIWXNJR0VzSUdKZEtTQStJREVnZkh3Z2NtVnpkVzFsS0c0c0lIWXBPeUI5S1RzZ2ZUc2dmVnh5WEc0Z0lDQWdablZ1WTNScGIyNGdjbVZ6ZFcxbEtHNHNJSFlwSUhzZ2RISjVJSHNnYzNSbGNDaG5XMjVkS0hZcEtUc2dmU0JqWVhSamFDQW9aU2tnZXlCelpYUjBiR1VvY1Zzd1hWc3pYU3dnWlNrN0lIMGdmVnh5WEc0Z0lDQWdablZ1WTNScGIyNGdjM1JsY0NoeUtTQjdJSEl1ZG1Gc2RXVWdhVzV6ZEdGdVkyVnZaaUJmWDJGM1lXbDBJRDhnVUhKdmJXbHpaUzV5WlhOdmJIWmxLSEl1ZG1Gc2RXVXVkaWt1ZEdobGJpaG1kV3htYVd4c0xDQnlaV3BsWTNRcElEb2djMlYwZEd4bEtIRmJNRjFiTWwwc0lISXBPeUI5WEhKY2JpQWdJQ0JtZFc1amRHbHZiaUJtZFd4bWFXeHNLSFpoYkhWbEtTQjdJSEpsYzNWdFpTaGNJbTVsZUhSY0lpd2dkbUZzZFdVcE95QjlYSEpjYmlBZ0lDQm1kVzVqZEdsdmJpQnlaV3BsWTNRb2RtRnNkV1VwSUhzZ2NtVnpkVzFsS0Z3aWRHaHliM2RjSWl3Z2RtRnNkV1VwT3lCOVhISmNiaUFnSUNCbWRXNWpkR2x2YmlCelpYUjBiR1VvWml3Z2Rpa2dleUJwWmlBb1ppaDJLU3dnY1M1emFHbG1kQ2dwTENCeExteGxibWQwYUNrZ2NtVnpkVzFsS0hGYk1GMWJNRjBzSUhGYk1GMWJNVjBwT3lCOVhISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmZYMkZ6ZVc1alJHVnNaV2RoZEc5eUtHOHBJSHRjY2x4dUlDQWdJSFpoY2lCcExDQndPMXh5WEc0Z0lDQWdjbVYwZFhKdUlHa2dQU0I3ZlN3Z2RtVnlZaWhjSW01bGVIUmNJaWtzSUhabGNtSW9YQ0owYUhKdmQxd2lMQ0JtZFc1amRHbHZiaUFvWlNrZ2V5QjBhSEp2ZHlCbE95QjlLU3dnZG1WeVlpaGNJbkpsZEhWeWJsd2lLU3dnYVZ0VGVXMWliMnd1YVhSbGNtRjBiM0pkSUQwZ1puVnVZM1JwYjI0Z0tDa2dleUJ5WlhSMWNtNGdkR2hwY3pzZ2ZTd2dhVHRjY2x4dUlDQWdJR1oxYm1OMGFXOXVJSFpsY21Jb2Jpd2daaWtnZXlCcFcyNWRJRDBnYjF0dVhTQS9JR1oxYm1OMGFXOXVJQ2gyS1NCN0lISmxkSFZ5YmlBb2NDQTlJQ0Z3S1NBL0lIc2dkbUZzZFdVNklGOWZZWGRoYVhRb2IxdHVYU2gyS1Nrc0lHUnZibVU2SUc0Z1BUMDlJRndpY21WMGRYSnVYQ0lnZlNBNklHWWdQeUJtS0hZcElEb2dkanNnZlNBNklHWTdJSDFjY2x4dWZWeHlYRzVjY2x4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUY5ZllYTjVibU5XWVd4MVpYTW9ieWtnZTF4eVhHNGdJQ0FnYVdZZ0tDRlRlVzFpYjJ3dVlYTjVibU5KZEdWeVlYUnZjaWtnZEdoeWIzY2dibVYzSUZSNWNHVkZjbkp2Y2loY0lsTjViV0p2YkM1aGMzbHVZMGwwWlhKaGRHOXlJR2x6SUc1dmRDQmtaV1pwYm1Wa0xsd2lLVHRjY2x4dUlDQWdJSFpoY2lCdElEMGdiMXRUZVcxaWIyd3VZWE41Ym1OSmRHVnlZWFJ2Y2wwc0lHazdYSEpjYmlBZ0lDQnlaWFIxY200Z2JTQS9JRzB1WTJGc2JDaHZLU0E2SUNodklEMGdkSGx3Wlc5bUlGOWZkbUZzZFdWeklEMDlQU0JjSW1aMWJtTjBhVzl1WENJZ1B5QmZYM1poYkhWbGN5aHZLU0E2SUc5YlUzbHRZbTlzTG1sMFpYSmhkRzl5WFNncExDQnBJRDBnZTMwc0lIWmxjbUlvWENKdVpYaDBYQ0lwTENCMlpYSmlLRndpZEdoeWIzZGNJaWtzSUhabGNtSW9YQ0p5WlhSMWNtNWNJaWtzSUdsYlUzbHRZbTlzTG1GemVXNWpTWFJsY21GMGIzSmRJRDBnWm5WdVkzUnBiMjRnS0NrZ2V5QnlaWFIxY200Z2RHaHBjenNnZlN3Z2FTazdYSEpjYmlBZ0lDQm1kVzVqZEdsdmJpQjJaWEppS0c0cElIc2dhVnR1WFNBOUlHOWJibDBnSmlZZ1puVnVZM1JwYjI0Z0tIWXBJSHNnY21WMGRYSnVJRzVsZHlCUWNtOXRhWE5sS0daMWJtTjBhVzl1SUNoeVpYTnZiSFpsTENCeVpXcGxZM1FwSUhzZ2RpQTlJRzliYmwwb2Rpa3NJSE5sZEhSc1pTaHlaWE52YkhabExDQnlaV3BsWTNRc0lIWXVaRzl1WlN3Z2RpNTJZV3gxWlNrN0lIMHBPeUI5T3lCOVhISmNiaUFnSUNCbWRXNWpkR2x2YmlCelpYUjBiR1VvY21WemIyeDJaU3dnY21WcVpXTjBMQ0JrTENCMktTQjdJRkJ5YjIxcGMyVXVjbVZ6YjJ4MlpTaDJLUzUwYUdWdUtHWjFibU4wYVc5dUtIWXBJSHNnY21WemIyeDJaU2g3SUhaaGJIVmxPaUIyTENCa2IyNWxPaUJrSUgwcE95QjlMQ0J5WldwbFkzUXBPeUI5WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCZlgyMWhhMlZVWlcxd2JHRjBaVTlpYW1WamRDaGpiMjlyWldRc0lISmhkeWtnZTF4eVhHNGdJQ0FnYVdZZ0tFOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBlU2tnZXlCUFltcGxZM1F1WkdWbWFXNWxVSEp2Y0dWeWRIa29ZMjl2YTJWa0xDQmNJbkpoZDF3aUxDQjdJSFpoYkhWbE9pQnlZWGNnZlNrN0lIMGdaV3h6WlNCN0lHTnZiMnRsWkM1eVlYY2dQU0J5WVhjN0lIMWNjbHh1SUNBZ0lISmxkSFZ5YmlCamIyOXJaV1E3WEhKY2JuMDdYSEpjYmx4eVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1gxOXBiWEJ2Y25SVGRHRnlLRzF2WkNrZ2UxeHlYRzRnSUNBZ2FXWWdLRzF2WkNBbUppQnRiMlF1WDE5bGMwMXZaSFZzWlNrZ2NtVjBkWEp1SUcxdlpEdGNjbHh1SUNBZ0lIWmhjaUJ5WlhOMWJIUWdQU0I3ZlR0Y2NseHVJQ0FnSUdsbUlDaHRiMlFnSVQwZ2JuVnNiQ2tnWm05eUlDaDJZWElnYXlCcGJpQnRiMlFwSUdsbUlDaFBZbXBsWTNRdWFHRnpUM2R1VUhKdmNHVnlkSGt1WTJGc2JDaHRiMlFzSUdzcEtTQnlaWE4xYkhSYmExMGdQU0J0YjJSYmExMDdYSEpjYmlBZ0lDQnlaWE4xYkhRdVpHVm1ZWFZzZENBOUlHMXZaRHRjY2x4dUlDQWdJSEpsZEhWeWJpQnlaWE4xYkhRN1hISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmZYMmx0Y0c5eWRFUmxabUYxYkhRb2JXOWtLU0I3WEhKY2JpQWdJQ0J5WlhSMWNtNGdLRzF2WkNBbUppQnRiMlF1WDE5bGMwMXZaSFZzWlNrZ1B5QnRiMlFnT2lCN0lHUmxabUYxYkhRNklHMXZaQ0I5TzF4eVhHNTlYSEpjYmx4eVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1gxOWpiR0Z6YzFCeWFYWmhkR1ZHYVdWc1pFZGxkQ2h5WldObGFYWmxjaXdnY0hKcGRtRjBaVTFoY0NrZ2UxeHlYRzRnSUNBZ2FXWWdLQ0Z3Y21sMllYUmxUV0Z3TG1oaGN5aHlaV05sYVhabGNpa3BJSHRjY2x4dUlDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1ZIbHdaVVZ5Y205eUtGd2lZWFIwWlcxd2RHVmtJSFJ2SUdkbGRDQndjbWwyWVhSbElHWnBaV3hrSUc5dUlHNXZiaTFwYm5OMFlXNWpaVndpS1R0Y2NseHVJQ0FnSUgxY2NseHVJQ0FnSUhKbGRIVnliaUJ3Y21sMllYUmxUV0Z3TG1kbGRDaHlaV05sYVhabGNpazdYSEpjYm4xY2NseHVYSEpjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJmWDJOc1lYTnpVSEpwZG1GMFpVWnBaV3hrVTJWMEtISmxZMlZwZG1WeUxDQndjbWwyWVhSbFRXRndMQ0IyWVd4MVpTa2dlMXh5WEc0Z0lDQWdhV1lnS0NGd2NtbDJZWFJsVFdGd0xtaGhjeWh5WldObGFYWmxjaWtwSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dWSGx3WlVWeWNtOXlLRndpWVhSMFpXMXdkR1ZrSUhSdklITmxkQ0J3Y21sMllYUmxJR1pwWld4a0lHOXVJRzV2YmkxcGJuTjBZVzVqWlZ3aUtUdGNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lIQnlhWFpoZEdWTllYQXVjMlYwS0hKbFkyVnBkbVZ5TENCMllXeDFaU2s3WEhKY2JpQWdJQ0J5WlhSMWNtNGdkbUZzZFdVN1hISmNibjFjY2x4dUlpd2lMeW9oSUdoMGRIQnpPaTh2YlhSb2N5NWlaUzl3ZFc1NVkyOWtaU0IyTVM0ekxqSWdZbmtnUUcxaGRHaHBZWE1nS2k5Y2Jqc29ablZ1WTNScGIyNG9jbTl2ZENrZ2UxeHVYRzVjZEM4cUtpQkVaWFJsWTNRZ1puSmxaU0IyWVhKcFlXSnNaWE1nS2k5Y2JseDBkbUZ5SUdaeVpXVkZlSEJ2Y25SeklEMGdkSGx3Wlc5bUlHVjRjRzl5ZEhNZ1BUMGdKMjlpYW1WamRDY2dKaVlnWlhod2IzSjBjeUFtSmx4dVhIUmNkQ0ZsZUhCdmNuUnpMbTV2WkdWVWVYQmxJQ1ltSUdWNGNHOXlkSE03WEc1Y2RIWmhjaUJtY21WbFRXOWtkV3hsSUQwZ2RIbHdaVzltSUcxdlpIVnNaU0E5UFNBbmIySnFaV04wSnlBbUppQnRiMlIxYkdVZ0ppWmNibHgwWEhRaGJXOWtkV3hsTG01dlpHVlVlWEJsSUNZbUlHMXZaSFZzWlR0Y2JseDBkbUZ5SUdaeVpXVkhiRzlpWVd3Z1BTQjBlWEJsYjJZZ1oyeHZZbUZzSUQwOUlDZHZZbXBsWTNRbklDWW1JR2RzYjJKaGJEdGNibHgwYVdZZ0tGeHVYSFJjZEdaeVpXVkhiRzlpWVd3dVoyeHZZbUZzSUQwOVBTQm1jbVZsUjJ4dlltRnNJSHg4WEc1Y2RGeDBabkpsWlVkc2IySmhiQzUzYVc1a2IzY2dQVDA5SUdaeVpXVkhiRzlpWVd3Z2ZIeGNibHgwWEhSbWNtVmxSMnh2WW1Gc0xuTmxiR1lnUFQwOUlHWnlaV1ZIYkc5aVlXeGNibHgwS1NCN1hHNWNkRngwY205dmRDQTlJR1p5WldWSGJHOWlZV3c3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1ZHaGxJR0J3ZFc1NVkyOWtaV0FnYjJKcVpXTjBMbHh1WEhRZ0tpQkFibUZ0WlNCd2RXNTVZMjlrWlZ4dVhIUWdLaUJBZEhsd1pTQlBZbXBsWTNSY2JseDBJQ292WEc1Y2RIWmhjaUJ3ZFc1NVkyOWtaU3hjYmx4dVhIUXZLaW9nU0dsbmFHVnpkQ0J3YjNOcGRHbDJaU0J6YVdkdVpXUWdNekl0WW1sMElHWnNiMkYwSUhaaGJIVmxJQ292WEc1Y2RHMWhlRWx1ZENBOUlESXhORGMwT0RNMk5EY3NJQzh2SUdGcllTNGdNSGczUmtaR1JrWkdSaUJ2Y2lBeVhqTXhMVEZjYmx4dVhIUXZLaW9nUW05dmRITjBjbWx1WnlCd1lYSmhiV1YwWlhKeklDb3ZYRzVjZEdKaGMyVWdQU0F6Tml4Y2JseDBkRTFwYmlBOUlERXNYRzVjZEhSTllYZ2dQU0F5Tml4Y2JseDBjMnRsZHlBOUlETTRMRnh1WEhSa1lXMXdJRDBnTnpBd0xGeHVYSFJwYm1sMGFXRnNRbWxoY3lBOUlEY3lMRnh1WEhScGJtbDBhV0ZzVGlBOUlERXlPQ3dnTHk4Z01IZzRNRnh1WEhSa1pXeHBiV2wwWlhJZ1BTQW5MU2NzSUM4dklDZGNYSGd5UkNkY2JseHVYSFF2S2lvZ1VtVm5kV3hoY2lCbGVIQnlaWE56YVc5dWN5QXFMMXh1WEhSeVpXZGxlRkIxYm5samIyUmxJRDBnTDE1NGJpMHRMeXhjYmx4MGNtVm5aWGhPYjI1QlUwTkpTU0E5SUM5YlhseGNlREl3TFZ4Y2VEZEZYUzhzSUM4dklIVnVjSEpwYm5SaFlteGxJRUZUUTBsSklHTm9ZWEp6SUNzZ2JtOXVMVUZUUTBsSklHTm9ZWEp6WEc1Y2RISmxaMlY0VTJWd1lYSmhkRzl5Y3lBOUlDOWJYRng0TWtWY1hIVXpNREF5WEZ4MVJrWXdSVnhjZFVaR05qRmRMMmNzSUM4dklGSkdReUF6TkRrd0lITmxjR0Z5WVhSdmNuTmNibHh1WEhRdktpb2dSWEp5YjNJZ2JXVnpjMkZuWlhNZ0tpOWNibHgwWlhKeWIzSnpJRDBnZTF4dVhIUmNkQ2R2ZG1WeVpteHZkeWM2SUNkUGRtVnlabXh2ZHpvZ2FXNXdkWFFnYm1WbFpITWdkMmxrWlhJZ2FXNTBaV2RsY25NZ2RHOGdjSEp2WTJWemN5Y3NYRzVjZEZ4MEoyNXZkQzFpWVhOcFl5YzZJQ2RKYkd4bFoyRnNJR2x1Y0hWMElENDlJREI0T0RBZ0tHNXZkQ0JoSUdKaGMybGpJR052WkdVZ2NHOXBiblFwSnl4Y2JseDBYSFFuYVc1MllXeHBaQzFwYm5CMWRDYzZJQ2RKYm5aaGJHbGtJR2x1Y0hWMEoxeHVYSFI5TEZ4dVhHNWNkQzhxS2lCRGIyNTJaVzVwWlc1alpTQnphRzl5ZEdOMWRITWdLaTljYmx4MFltRnpaVTFwYm5WelZFMXBiaUE5SUdKaGMyVWdMU0IwVFdsdUxGeHVYSFJtYkc5dmNpQTlJRTFoZEdndVpteHZiM0lzWEc1Y2RITjBjbWx1WjBaeWIyMURhR0Z5UTI5a1pTQTlJRk4wY21sdVp5NW1jbTl0UTJoaGNrTnZaR1VzWEc1Y2JseDBMeW9xSUZSbGJYQnZjbUZ5ZVNCMllYSnBZV0pzWlNBcUwxeHVYSFJyWlhrN1hHNWNibHgwTHlvdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTb3ZYRzVjYmx4MEx5b3FYRzVjZENBcUlFRWdaMlZ1WlhKcFl5Qmxjbkp2Y2lCMWRHbHNhWFI1SUdaMWJtTjBhVzl1TGx4dVhIUWdLaUJBY0hKcGRtRjBaVnh1WEhRZ0tpQkFjR0Z5WVcwZ2UxTjBjbWx1WjMwZ2RIbHdaU0JVYUdVZ1pYSnliM0lnZEhsd1pTNWNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UwVnljbTl5ZlNCVWFISnZkM01nWVNCZ1VtRnVaMlZGY25KdmNtQWdkMmwwYUNCMGFHVWdZWEJ3YkdsallXSnNaU0JsY25KdmNpQnRaWE56WVdkbExseHVYSFFnS2k5Y2JseDBablZ1WTNScGIyNGdaWEp5YjNJb2RIbHdaU2tnZTF4dVhIUmNkSFJvY205M0lGSmhibWRsUlhKeWIzSW9aWEp5YjNKelczUjVjR1ZkS1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkJJR2RsYm1WeWFXTWdZRUZ5Y21GNUkyMWhjR0FnZFhScGJHbDBlU0JtZFc1amRHbHZiaTVjYmx4MElDb2dRSEJ5YVhaaGRHVmNibHgwSUNvZ1FIQmhjbUZ0SUh0QmNuSmhlWDBnWVhKeVlYa2dWR2hsSUdGeWNtRjVJSFJ2SUdsMFpYSmhkR1VnYjNabGNpNWNibHgwSUNvZ1FIQmhjbUZ0SUh0R2RXNWpkR2x2Ym4wZ1kyRnNiR0poWTJzZ1ZHaGxJR1oxYm1OMGFXOXVJSFJvWVhRZ1oyVjBjeUJqWVd4c1pXUWdabTl5SUdWMlpYSjVJR0Z5Y21GNVhHNWNkQ0FxSUdsMFpXMHVYRzVjZENBcUlFQnlaWFIxY201eklIdEJjbkpoZVgwZ1FTQnVaWGNnWVhKeVlYa2diMllnZG1Gc2RXVnpJSEpsZEhWeWJtVmtJR0o1SUhSb1pTQmpZV3hzWW1GamF5Qm1kVzVqZEdsdmJpNWNibHgwSUNvdlhHNWNkR1oxYm1OMGFXOXVJRzFoY0NoaGNuSmhlU3dnWm00cElIdGNibHgwWEhSMllYSWdiR1Z1WjNSb0lEMGdZWEp5WVhrdWJHVnVaM1JvTzF4dVhIUmNkSFpoY2lCeVpYTjFiSFFnUFNCYlhUdGNibHgwWEhSM2FHbHNaU0FvYkdWdVozUm9MUzBwSUh0Y2JseDBYSFJjZEhKbGMzVnNkRnRzWlc1bmRHaGRJRDBnWm00b1lYSnlZWGxiYkdWdVozUm9YU2s3WEc1Y2RGeDBmVnh1WEhSY2RISmxkSFZ5YmlCeVpYTjFiSFE3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1FTQnphVzF3YkdVZ1lFRnljbUY1STIxaGNHQXRiR2xyWlNCM2NtRndjR1Z5SUhSdklIZHZjbXNnZDJsMGFDQmtiMjFoYVc0Z2JtRnRaU0J6ZEhKcGJtZHpJRzl5SUdWdFlXbHNYRzVjZENBcUlHRmtaSEpsYzNObGN5NWNibHgwSUNvZ1FIQnlhWFpoZEdWY2JseDBJQ29nUUhCaGNtRnRJSHRUZEhKcGJtZDlJR1J2YldGcGJpQlVhR1VnWkc5dFlXbHVJRzVoYldVZ2IzSWdaVzFoYVd3Z1lXUmtjbVZ6Y3k1Y2JseDBJQ29nUUhCaGNtRnRJSHRHZFc1amRHbHZibjBnWTJGc2JHSmhZMnNnVkdobElHWjFibU4wYVc5dUlIUm9ZWFFnWjJWMGN5QmpZV3hzWldRZ1ptOXlJR1YyWlhKNVhHNWNkQ0FxSUdOb1lYSmhZM1JsY2k1Y2JseDBJQ29nUUhKbGRIVnlibk1nZTBGeWNtRjVmU0JCSUc1bGR5QnpkSEpwYm1jZ2IyWWdZMmhoY21GamRHVnljeUJ5WlhSMWNtNWxaQ0JpZVNCMGFHVWdZMkZzYkdKaFkydGNibHgwSUNvZ1puVnVZM1JwYjI0dVhHNWNkQ0FxTDF4dVhIUm1kVzVqZEdsdmJpQnRZWEJFYjIxaGFXNG9jM1J5YVc1bkxDQm1iaWtnZTF4dVhIUmNkSFpoY2lCd1lYSjBjeUE5SUhOMGNtbHVaeTV6Y0d4cGRDZ25RQ2NwTzF4dVhIUmNkSFpoY2lCeVpYTjFiSFFnUFNBbkp6dGNibHgwWEhScFppQW9jR0Z5ZEhNdWJHVnVaM1JvSUQ0Z01Ta2dlMXh1WEhSY2RGeDBMeThnU1c0Z1pXMWhhV3dnWVdSa2NtVnpjMlZ6TENCdmJteDVJSFJvWlNCa2IyMWhhVzRnYm1GdFpTQnphRzkxYkdRZ1ltVWdjSFZ1ZVdOdlpHVmtMaUJNWldGMlpWeHVYSFJjZEZ4MEx5OGdkR2hsSUd4dlkyRnNJSEJoY25RZ0tHa3VaUzRnWlhabGNubDBhR2x1WnlCMWNDQjBieUJnUUdBcElHbHVkR0ZqZEM1Y2JseDBYSFJjZEhKbGMzVnNkQ0E5SUhCaGNuUnpXekJkSUNzZ0owQW5PMXh1WEhSY2RGeDBjM1J5YVc1bklEMGdjR0Z5ZEhOYk1WMDdYRzVjZEZ4MGZWeHVYSFJjZEM4dklFRjJiMmxrSUdCemNHeHBkQ2h5WldkbGVDbGdJR1p2Y2lCSlJUZ2dZMjl0Y0dGMGFXSnBiR2wwZVM0Z1UyVmxJQ014Tnk1Y2JseDBYSFJ6ZEhKcGJtY2dQU0J6ZEhKcGJtY3VjbVZ3YkdGalpTaHlaV2RsZUZObGNHRnlZWFJ2Y25Nc0lDZGNYSGd5UlNjcE8xeHVYSFJjZEhaaGNpQnNZV0psYkhNZ1BTQnpkSEpwYm1jdWMzQnNhWFFvSnk0bktUdGNibHgwWEhSMllYSWdaVzVqYjJSbFpDQTlJRzFoY0Noc1lXSmxiSE1zSUdadUtTNXFiMmx1S0NjdUp5azdYRzVjZEZ4MGNtVjBkWEp1SUhKbGMzVnNkQ0FySUdWdVkyOWtaV1E3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1EzSmxZWFJsY3lCaGJpQmhjbkpoZVNCamIyNTBZV2x1YVc1bklIUm9aU0J1ZFcxbGNtbGpJR052WkdVZ2NHOXBiblJ6SUc5bUlHVmhZMmdnVlc1cFkyOWtaVnh1WEhRZ0tpQmphR0Z5WVdOMFpYSWdhVzRnZEdobElITjBjbWx1Wnk0Z1YyaHBiR1VnU21GMllWTmpjbWx3ZENCMWMyVnpJRlZEVXkweUlHbHVkR1Z5Ym1Gc2JIa3NYRzVjZENBcUlIUm9hWE1nWm5WdVkzUnBiMjRnZDJsc2JDQmpiMjUyWlhKMElHRWdjR0ZwY2lCdlppQnpkWEp5YjJkaGRHVWdhR0ZzZG1WeklDaGxZV05vSUc5bUlIZG9hV05vWEc1Y2RDQXFJRlZEVXkweUlHVjRjRzl6WlhNZ1lYTWdjMlZ3WVhKaGRHVWdZMmhoY21GamRHVnljeWtnYVc1MGJ5QmhJSE5wYm1kc1pTQmpiMlJsSUhCdmFXNTBMRnh1WEhRZ0tpQnRZWFJqYUdsdVp5QlZWRVl0TVRZdVhHNWNkQ0FxSUVCelpXVWdZSEIxYm5samIyUmxMblZqY3pJdVpXNWpiMlJsWUZ4dVhIUWdLaUJBYzJWbElEeG9kSFJ3Y3pvdkwyMWhkR2hwWVhOaWVXNWxibk11WW1VdmJtOTBaWE12YW1GMllYTmpjbWx3ZEMxbGJtTnZaR2x1Wno1Y2JseDBJQ29nUUcxbGJXSmxjazltSUhCMWJubGpiMlJsTG5WamN6SmNibHgwSUNvZ1FHNWhiV1VnWkdWamIyUmxYRzVjZENBcUlFQndZWEpoYlNCN1UzUnlhVzVuZlNCemRISnBibWNnVkdobElGVnVhV052WkdVZ2FXNXdkWFFnYzNSeWFXNW5JQ2hWUTFNdE1pa3VYRzVjZENBcUlFQnlaWFIxY201eklIdEJjbkpoZVgwZ1ZHaGxJRzVsZHlCaGNuSmhlU0J2WmlCamIyUmxJSEJ2YVc1MGN5NWNibHgwSUNvdlhHNWNkR1oxYm1OMGFXOXVJSFZqY3pKa1pXTnZaR1VvYzNSeWFXNW5LU0I3WEc1Y2RGeDBkbUZ5SUc5MWRIQjFkQ0E5SUZ0ZExGeHVYSFJjZENBZ0lDQmpiM1Z1ZEdWeUlEMGdNQ3hjYmx4MFhIUWdJQ0FnYkdWdVozUm9JRDBnYzNSeWFXNW5MbXhsYm1kMGFDeGNibHgwWEhRZ0lDQWdkbUZzZFdVc1hHNWNkRngwSUNBZ0lHVjRkSEpoTzF4dVhIUmNkSGRvYVd4bElDaGpiM1Z1ZEdWeUlEd2diR1Z1WjNSb0tTQjdYRzVjZEZ4MFhIUjJZV3gxWlNBOUlITjBjbWx1Wnk1amFHRnlRMjlrWlVGMEtHTnZkVzUwWlhJckt5azdYRzVjZEZ4MFhIUnBaaUFvZG1Gc2RXVWdQajBnTUhoRU9EQXdJQ1ltSUhaaGJIVmxJRHc5SURCNFJFSkdSaUFtSmlCamIzVnVkR1Z5SUR3Z2JHVnVaM1JvS1NCN1hHNWNkRngwWEhSY2RDOHZJR2hwWjJnZ2MzVnljbTluWVhSbExDQmhibVFnZEdobGNtVWdhWE1nWVNCdVpYaDBJR05vWVhKaFkzUmxjbHh1WEhSY2RGeDBYSFJsZUhSeVlTQTlJSE4wY21sdVp5NWphR0Z5UTI5a1pVRjBLR052ZFc1MFpYSXJLeWs3WEc1Y2RGeDBYSFJjZEdsbUlDZ29aWGgwY21FZ0ppQXdlRVpETURBcElEMDlJREI0UkVNd01Da2dleUF2THlCc2IzY2djM1Z5Y205bllYUmxYRzVjZEZ4MFhIUmNkRngwYjNWMGNIVjBMbkIxYzJnb0tDaDJZV3gxWlNBbUlEQjRNMFpHS1NBOFBDQXhNQ2tnS3lBb1pYaDBjbUVnSmlBd2VETkdSaWtnS3lBd2VERXdNREF3S1R0Y2JseDBYSFJjZEZ4MGZTQmxiSE5sSUh0Y2JseDBYSFJjZEZ4MFhIUXZMeUIxYm0xaGRHTm9aV1FnYzNWeWNtOW5ZWFJsT3lCdmJteDVJR0Z3Y0dWdVpDQjBhR2x6SUdOdlpHVWdkVzVwZEN3Z2FXNGdZMkZ6WlNCMGFHVWdibVY0ZEZ4dVhIUmNkRngwWEhSY2RDOHZJR052WkdVZ2RXNXBkQ0JwY3lCMGFHVWdhR2xuYUNCemRYSnliMmRoZEdVZ2IyWWdZU0J6ZFhKeWIyZGhkR1VnY0dGcGNseHVYSFJjZEZ4MFhIUmNkRzkxZEhCMWRDNXdkWE5vS0haaGJIVmxLVHRjYmx4MFhIUmNkRngwWEhSamIzVnVkR1Z5TFMwN1hHNWNkRngwWEhSY2RIMWNibHgwWEhSY2RIMGdaV3h6WlNCN1hHNWNkRngwWEhSY2RHOTFkSEIxZEM1d2RYTm9LSFpoYkhWbEtUdGNibHgwWEhSY2RIMWNibHgwWEhSOVhHNWNkRngwY21WMGRYSnVJRzkxZEhCMWREdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJEY21WaGRHVnpJR0VnYzNSeWFXNW5JR0poYzJWa0lHOXVJR0Z1SUdGeWNtRjVJRzltSUc1MWJXVnlhV01nWTI5a1pTQndiMmx1ZEhNdVhHNWNkQ0FxSUVCelpXVWdZSEIxYm5samIyUmxMblZqY3pJdVpHVmpiMlJsWUZ4dVhIUWdLaUJBYldWdFltVnlUMllnY0hWdWVXTnZaR1V1ZFdOek1seHVYSFFnS2lCQWJtRnRaU0JsYm1OdlpHVmNibHgwSUNvZ1FIQmhjbUZ0SUh0QmNuSmhlWDBnWTI5a1pWQnZhVzUwY3lCVWFHVWdZWEp5WVhrZ2IyWWdiblZ0WlhKcFl5QmpiMlJsSUhCdmFXNTBjeTVjYmx4MElDb2dRSEpsZEhWeWJuTWdlMU4wY21sdVozMGdWR2hsSUc1bGR5QlZibWxqYjJSbElITjBjbWx1WnlBb1ZVTlRMVElwTGx4dVhIUWdLaTljYmx4MFpuVnVZM1JwYjI0Z2RXTnpNbVZ1WTI5a1pTaGhjbkpoZVNrZ2UxeHVYSFJjZEhKbGRIVnliaUJ0WVhBb1lYSnlZWGtzSUdaMWJtTjBhVzl1S0haaGJIVmxLU0I3WEc1Y2RGeDBYSFIyWVhJZ2IzVjBjSFYwSUQwZ0p5YzdYRzVjZEZ4MFhIUnBaaUFvZG1Gc2RXVWdQaUF3ZUVaR1JrWXBJSHRjYmx4MFhIUmNkRngwZG1Gc2RXVWdMVDBnTUhneE1EQXdNRHRjYmx4MFhIUmNkRngwYjNWMGNIVjBJQ3M5SUhOMGNtbHVaMFp5YjIxRGFHRnlRMjlrWlNoMllXeDFaU0ErUGo0Z01UQWdKaUF3ZUROR1JpQjhJREI0UkRnd01DazdYRzVjZEZ4MFhIUmNkSFpoYkhWbElEMGdNSGhFUXpBd0lId2dkbUZzZFdVZ0ppQXdlRE5HUmp0Y2JseDBYSFJjZEgxY2JseDBYSFJjZEc5MWRIQjFkQ0FyUFNCemRISnBibWRHY205dFEyaGhja052WkdVb2RtRnNkV1VwTzF4dVhIUmNkRngwY21WMGRYSnVJRzkxZEhCMWREdGNibHgwWEhSOUtTNXFiMmx1S0NjbktUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJEYjI1MlpYSjBjeUJoSUdKaGMybGpJR052WkdVZ2NHOXBiblFnYVc1MGJ5QmhJR1JwWjJsMEwybHVkR1ZuWlhJdVhHNWNkQ0FxSUVCelpXVWdZR1JwWjJsMFZHOUNZWE5wWXlncFlGeHVYSFFnS2lCQWNISnBkbUYwWlZ4dVhIUWdLaUJBY0dGeVlXMGdlMDUxYldKbGNuMGdZMjlrWlZCdmFXNTBJRlJvWlNCaVlYTnBZeUJ1ZFcxbGNtbGpJR052WkdVZ2NHOXBiblFnZG1Gc2RXVXVYRzVjZENBcUlFQnlaWFIxY201eklIdE9kVzFpWlhKOUlGUm9aU0J1ZFcxbGNtbGpJSFpoYkhWbElHOW1JR0VnWW1GemFXTWdZMjlrWlNCd2IybHVkQ0FvWm05eUlIVnpaU0JwYmx4dVhIUWdLaUJ5WlhCeVpYTmxiblJwYm1jZ2FXNTBaV2RsY25NcElHbHVJSFJvWlNCeVlXNW5aU0JnTUdBZ2RHOGdZR0poYzJVZ0xTQXhZQ3dnYjNJZ1lHSmhjMlZnSUdsbVhHNWNkQ0FxSUhSb1pTQmpiMlJsSUhCdmFXNTBJR1J2WlhNZ2JtOTBJSEpsY0hKbGMyVnVkQ0JoSUhaaGJIVmxMbHh1WEhRZ0tpOWNibHgwWm5WdVkzUnBiMjRnWW1GemFXTlViMFJwWjJsMEtHTnZaR1ZRYjJsdWRDa2dlMXh1WEhSY2RHbG1JQ2hqYjJSbFVHOXBiblFnTFNBME9DQThJREV3S1NCN1hHNWNkRngwWEhSeVpYUjFjbTRnWTI5a1pWQnZhVzUwSUMwZ01qSTdYRzVjZEZ4MGZWeHVYSFJjZEdsbUlDaGpiMlJsVUc5cGJuUWdMU0EyTlNBOElESTJLU0I3WEc1Y2RGeDBYSFJ5WlhSMWNtNGdZMjlrWlZCdmFXNTBJQzBnTmpVN1hHNWNkRngwZlZ4dVhIUmNkR2xtSUNoamIyUmxVRzlwYm5RZ0xTQTVOeUE4SURJMktTQjdYRzVjZEZ4MFhIUnlaWFIxY200Z1kyOWtaVkJ2YVc1MElDMGdPVGM3WEc1Y2RGeDBmVnh1WEhSY2RISmxkSFZ5YmlCaVlYTmxPMXh1WEhSOVhHNWNibHgwTHlvcVhHNWNkQ0FxSUVOdmJuWmxjblJ6SUdFZ1pHbG5hWFF2YVc1MFpXZGxjaUJwYm5SdklHRWdZbUZ6YVdNZ1kyOWtaU0J3YjJsdWRDNWNibHgwSUNvZ1FITmxaU0JnWW1GemFXTlViMFJwWjJsMEtDbGdYRzVjZENBcUlFQndjbWwyWVhSbFhHNWNkQ0FxSUVCd1lYSmhiU0I3VG5WdFltVnlmU0JrYVdkcGRDQlVhR1VnYm5WdFpYSnBZeUIyWVd4MVpTQnZaaUJoSUdKaGMybGpJR052WkdVZ2NHOXBiblF1WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHRPZFcxaVpYSjlJRlJvWlNCaVlYTnBZeUJqYjJSbElIQnZhVzUwSUhkb2IzTmxJSFpoYkhWbElDaDNhR1Z1SUhWelpXUWdabTl5WEc1Y2RDQXFJSEpsY0hKbGMyVnVkR2x1WnlCcGJuUmxaMlZ5Y3lrZ2FYTWdZR1JwWjJsMFlDd2dkMmhwWTJnZ2JtVmxaSE1nZEc4Z1ltVWdhVzRnZEdobElISmhibWRsWEc1Y2RDQXFJR0F3WUNCMGJ5QmdZbUZ6WlNBdElERmdMaUJKWmlCZ1pteGhaMkFnYVhNZ2JtOXVMWHBsY204c0lIUm9aU0IxY0hCbGNtTmhjMlVnWm05eWJTQnBjMXh1WEhRZ0tpQjFjMlZrT3lCbGJITmxMQ0IwYUdVZ2JHOTNaWEpqWVhObElHWnZjbTBnYVhNZ2RYTmxaQzRnVkdobElHSmxhR0YyYVc5eUlHbHpJSFZ1WkdWbWFXNWxaRnh1WEhRZ0tpQnBaaUJnWm14aFoyQWdhWE1nYm05dUxYcGxjbThnWVc1a0lHQmthV2RwZEdBZ2FHRnpJRzV2SUhWd2NHVnlZMkZ6WlNCbWIzSnRMbHh1WEhRZ0tpOWNibHgwWm5WdVkzUnBiMjRnWkdsbmFYUlViMEpoYzJsaktHUnBaMmwwTENCbWJHRm5LU0I3WEc1Y2RGeDBMeThnSURBdUxqSTFJRzFoY0NCMGJ5QkJVME5KU1NCaExpNTZJRzl5SUVFdUxscGNibHgwWEhRdkx5QXlOaTR1TXpVZ2JXRndJSFJ2SUVGVFEwbEpJREF1TGpsY2JseDBYSFJ5WlhSMWNtNGdaR2xuYVhRZ0t5QXlNaUFySURjMUlDb2dLR1JwWjJsMElEd2dNallwSUMwZ0tDaG1iR0ZuSUNFOUlEQXBJRHc4SURVcE8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRUpwWVhNZ1lXUmhjSFJoZEdsdmJpQm1kVzVqZEdsdmJpQmhjeUJ3WlhJZ2MyVmpkR2x2YmlBekxqUWdiMllnVWtaRElETTBPVEl1WEc1Y2RDQXFJR2gwZEhBNkx5OTBiMjlzY3k1cFpYUm1MbTl5Wnk5b2RHMXNMM0ptWXpNME9USWpjMlZqZEdsdmJpMHpMalJjYmx4MElDb2dRSEJ5YVhaaGRHVmNibHgwSUNvdlhHNWNkR1oxYm1OMGFXOXVJR0ZrWVhCMEtHUmxiSFJoTENCdWRXMVFiMmx1ZEhNc0lHWnBjbk4wVkdsdFpTa2dlMXh1WEhSY2RIWmhjaUJySUQwZ01EdGNibHgwWEhSa1pXeDBZU0E5SUdacGNuTjBWR2x0WlNBL0lHWnNiMjl5S0dSbGJIUmhJQzhnWkdGdGNDa2dPaUJrWld4MFlTQStQaUF4TzF4dVhIUmNkR1JsYkhSaElDczlJR1pzYjI5eUtHUmxiSFJoSUM4Z2JuVnRVRzlwYm5SektUdGNibHgwWEhSbWIzSWdLQzhxSUc1dklHbHVhWFJwWVd4cGVtRjBhVzl1SUNvdk95QmtaV3gwWVNBK0lHSmhjMlZOYVc1MWMxUk5hVzRnS2lCMFRXRjRJRDQrSURFN0lHc2dLejBnWW1GelpTa2dlMXh1WEhSY2RGeDBaR1ZzZEdFZ1BTQm1iRzl2Y2loa1pXeDBZU0F2SUdKaGMyVk5hVzUxYzFSTmFXNHBPMXh1WEhSY2RIMWNibHgwWEhSeVpYUjFjbTRnWm14dmIzSW9heUFySUNoaVlYTmxUV2x1ZFhOVVRXbHVJQ3NnTVNrZ0tpQmtaV3gwWVNBdklDaGtaV3gwWVNBcklITnJaWGNwS1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkRiMjUyWlhKMGN5QmhJRkIxYm5samIyUmxJSE4wY21sdVp5QnZaaUJCVTBOSlNTMXZibXg1SUhONWJXSnZiSE1nZEc4Z1lTQnpkSEpwYm1jZ2IyWWdWVzVwWTI5a1pWeHVYSFFnS2lCemVXMWliMnh6TGx4dVhIUWdLaUJBYldWdFltVnlUMllnY0hWdWVXTnZaR1ZjYmx4MElDb2dRSEJoY21GdElIdFRkSEpwYm1kOUlHbHVjSFYwSUZSb1pTQlFkVzU1WTI5a1pTQnpkSEpwYm1jZ2IyWWdRVk5EU1VrdGIyNXNlU0J6ZVcxaWIyeHpMbHh1WEhRZ0tpQkFjbVYwZFhKdWN5QjdVM1J5YVc1bmZTQlVhR1VnY21WemRXeDBhVzVuSUhOMGNtbHVaeUJ2WmlCVmJtbGpiMlJsSUhONWJXSnZiSE11WEc1Y2RDQXFMMXh1WEhSbWRXNWpkR2x2YmlCa1pXTnZaR1VvYVc1d2RYUXBJSHRjYmx4MFhIUXZMeUJFYjI0bmRDQjFjMlVnVlVOVExUSmNibHgwWEhSMllYSWdiM1YwY0hWMElEMGdXMTBzWEc1Y2RGeDBJQ0FnSUdsdWNIVjBUR1Z1WjNSb0lEMGdhVzV3ZFhRdWJHVnVaM1JvTEZ4dVhIUmNkQ0FnSUNCdmRYUXNYRzVjZEZ4MElDQWdJR2tnUFNBd0xGeHVYSFJjZENBZ0lDQnVJRDBnYVc1cGRHbGhiRTRzWEc1Y2RGeDBJQ0FnSUdKcFlYTWdQU0JwYm1sMGFXRnNRbWxoY3l4Y2JseDBYSFFnSUNBZ1ltRnphV01zWEc1Y2RGeDBJQ0FnSUdvc1hHNWNkRngwSUNBZ0lHbHVaR1Y0TEZ4dVhIUmNkQ0FnSUNCdmJHUnBMRnh1WEhSY2RDQWdJQ0IzTEZ4dVhIUmNkQ0FnSUNCckxGeHVYSFJjZENBZ0lDQmthV2RwZEN4Y2JseDBYSFFnSUNBZ2RDeGNibHgwWEhRZ0lDQWdMeW9xSUVOaFkyaGxaQ0JqWVd4amRXeGhkR2x2YmlCeVpYTjFiSFJ6SUNvdlhHNWNkRngwSUNBZ0lHSmhjMlZOYVc1MWMxUTdYRzVjYmx4MFhIUXZMeUJJWVc1a2JHVWdkR2hsSUdKaGMybGpJR052WkdVZ2NHOXBiblJ6T2lCc1pYUWdZR0poYzJsallDQmlaU0IwYUdVZ2JuVnRZbVZ5SUc5bUlHbHVjSFYwSUdOdlpHVmNibHgwWEhRdkx5QndiMmx1ZEhNZ1ltVm1iM0psSUhSb1pTQnNZWE4wSUdSbGJHbHRhWFJsY2l3Z2IzSWdZREJnSUdsbUlIUm9aWEpsSUdseklHNXZibVVzSUhSb1pXNGdZMjl3ZVZ4dVhIUmNkQzh2SUhSb1pTQm1hWEp6ZENCaVlYTnBZeUJqYjJSbElIQnZhVzUwY3lCMGJ5QjBhR1VnYjNWMGNIVjBMbHh1WEc1Y2RGeDBZbUZ6YVdNZ1BTQnBibkIxZEM1c1lYTjBTVzVrWlhoUFppaGtaV3hwYldsMFpYSXBPMXh1WEhSY2RHbG1JQ2hpWVhOcFl5QThJREFwSUh0Y2JseDBYSFJjZEdKaGMybGpJRDBnTUR0Y2JseDBYSFI5WEc1Y2JseDBYSFJtYjNJZ0tHb2dQU0F3T3lCcUlEd2dZbUZ6YVdNN0lDc3JhaWtnZTF4dVhIUmNkRngwTHk4Z2FXWWdhWFFuY3lCdWIzUWdZU0JpWVhOcFl5QmpiMlJsSUhCdmFXNTBYRzVjZEZ4MFhIUnBaaUFvYVc1d2RYUXVZMmhoY2tOdlpHVkJkQ2hxS1NBK1BTQXdlRGd3S1NCN1hHNWNkRngwWEhSY2RHVnljbTl5S0NkdWIzUXRZbUZ6YVdNbktUdGNibHgwWEhSY2RIMWNibHgwWEhSY2RHOTFkSEIxZEM1d2RYTm9LR2x1Y0hWMExtTm9ZWEpEYjJSbFFYUW9haWtwTzF4dVhIUmNkSDFjYmx4dVhIUmNkQzh2SUUxaGFXNGdaR1ZqYjJScGJtY2diRzl2Y0RvZ2MzUmhjblFnYW5WemRDQmhablJsY2lCMGFHVWdiR0Z6ZENCa1pXeHBiV2wwWlhJZ2FXWWdZVzU1SUdKaGMybGpJR052WkdWY2JseDBYSFF2THlCd2IybHVkSE1nZDJWeVpTQmpiM0JwWldRN0lITjBZWEowSUdGMElIUm9aU0JpWldkcGJtNXBibWNnYjNSb1pYSjNhWE5sTGx4dVhHNWNkRngwWm05eUlDaHBibVJsZUNBOUlHSmhjMmxqSUQ0Z01DQS9JR0poYzJsaklDc2dNU0E2SURBN0lHbHVaR1Y0SUR3Z2FXNXdkWFJNWlc1bmRHZzdJQzhxSUc1dklHWnBibUZzSUdWNGNISmxjM05wYjI0Z0tpOHBJSHRjYmx4dVhIUmNkRngwTHk4Z1lHbHVaR1Y0WUNCcGN5QjBhR1VnYVc1a1pYZ2diMllnZEdobElHNWxlSFFnWTJoaGNtRmpkR1Z5SUhSdklHSmxJR052Ym5OMWJXVmtMbHh1WEhSY2RGeDBMeThnUkdWamIyUmxJR0VnWjJWdVpYSmhiR2w2WldRZ2RtRnlhV0ZpYkdVdGJHVnVaM1JvSUdsdWRHVm5aWElnYVc1MGJ5QmdaR1ZzZEdGZ0xGeHVYSFJjZEZ4MEx5OGdkMmhwWTJnZ1oyVjBjeUJoWkdSbFpDQjBieUJnYVdBdUlGUm9aU0J2ZG1WeVpteHZkeUJqYUdWamEybHVaeUJwY3lCbFlYTnBaWEpjYmx4MFhIUmNkQzh2SUdsbUlIZGxJR2x1WTNKbFlYTmxJR0JwWUNCaGN5QjNaU0JuYnl3Z2RHaGxiaUJ6ZFdKMGNtRmpkQ0J2Wm1ZZ2FYUnpJSE4wWVhKMGFXNW5YRzVjZEZ4MFhIUXZMeUIyWVd4MVpTQmhkQ0IwYUdVZ1pXNWtJSFJ2SUc5aWRHRnBiaUJnWkdWc2RHRmdMbHh1WEhSY2RGeDBabTl5SUNodmJHUnBJRDBnYVN3Z2R5QTlJREVzSUdzZ1BTQmlZWE5sT3lBdktpQnVieUJqYjI1a2FYUnBiMjRnS2k4N0lHc2dLejBnWW1GelpTa2dlMXh1WEc1Y2RGeDBYSFJjZEdsbUlDaHBibVJsZUNBK1BTQnBibkIxZEV4bGJtZDBhQ2tnZTF4dVhIUmNkRngwWEhSY2RHVnljbTl5S0NkcGJuWmhiR2xrTFdsdWNIVjBKeWs3WEc1Y2RGeDBYSFJjZEgxY2JseHVYSFJjZEZ4MFhIUmthV2RwZENBOUlHSmhjMmxqVkc5RWFXZHBkQ2hwYm5CMWRDNWphR0Z5UTI5a1pVRjBLR2x1WkdWNEt5c3BLVHRjYmx4dVhIUmNkRngwWEhScFppQW9aR2xuYVhRZ1BqMGdZbUZ6WlNCOGZDQmthV2RwZENBK0lHWnNiMjl5S0NodFlYaEpiblFnTFNCcEtTQXZJSGNwS1NCN1hHNWNkRngwWEhSY2RGeDBaWEp5YjNJb0oyOTJaWEptYkc5M0p5azdYRzVjZEZ4MFhIUmNkSDFjYmx4dVhIUmNkRngwWEhScElDczlJR1JwWjJsMElDb2dkenRjYmx4MFhIUmNkRngwZENBOUlHc2dQRDBnWW1saGN5QS9JSFJOYVc0Z09pQW9heUErUFNCaWFXRnpJQ3NnZEUxaGVDQS9JSFJOWVhnZ09pQnJJQzBnWW1saGN5azdYRzVjYmx4MFhIUmNkRngwYVdZZ0tHUnBaMmwwSUR3Z2RDa2dlMXh1WEhSY2RGeDBYSFJjZEdKeVpXRnJPMXh1WEhSY2RGeDBYSFI5WEc1Y2JseDBYSFJjZEZ4MFltRnpaVTFwYm5WelZDQTlJR0poYzJVZ0xTQjBPMXh1WEhSY2RGeDBYSFJwWmlBb2R5QStJR1pzYjI5eUtHMWhlRWx1ZENBdklHSmhjMlZOYVc1MWMxUXBLU0I3WEc1Y2RGeDBYSFJjZEZ4MFpYSnliM0lvSjI5MlpYSm1iRzkzSnlrN1hHNWNkRngwWEhSY2RIMWNibHh1WEhSY2RGeDBYSFIzSUNvOUlHSmhjMlZOYVc1MWMxUTdYRzVjYmx4MFhIUmNkSDFjYmx4dVhIUmNkRngwYjNWMElEMGdiM1YwY0hWMExteGxibWQwYUNBcklERTdYRzVjZEZ4MFhIUmlhV0Z6SUQwZ1lXUmhjSFFvYVNBdElHOXNaR2tzSUc5MWRDd2diMnhrYVNBOVBTQXdLVHRjYmx4dVhIUmNkRngwTHk4Z1lHbGdJSGRoY3lCemRYQndiM05sWkNCMGJ5QjNjbUZ3SUdGeWIzVnVaQ0JtY205dElHQnZkWFJnSUhSdklHQXdZQ3hjYmx4MFhIUmNkQzh2SUdsdVkzSmxiV1Z1ZEdsdVp5QmdibUFnWldGamFDQjBhVzFsTENCemJ5QjNaU2RzYkNCbWFYZ2dkR2hoZENCdWIzYzZYRzVjZEZ4MFhIUnBaaUFvWm14dmIzSW9hU0F2SUc5MWRDa2dQaUJ0WVhoSmJuUWdMU0J1S1NCN1hHNWNkRngwWEhSY2RHVnljbTl5S0NkdmRtVnlabXh2ZHljcE8xeHVYSFJjZEZ4MGZWeHVYRzVjZEZ4MFhIUnVJQ3M5SUdac2IyOXlLR2tnTHlCdmRYUXBPMXh1WEhSY2RGeDBhU0FsUFNCdmRYUTdYRzVjYmx4MFhIUmNkQzh2SUVsdWMyVnlkQ0JnYm1BZ1lYUWdjRzl6YVhScGIyNGdZR2xnSUc5bUlIUm9aU0J2ZFhSd2RYUmNibHgwWEhSY2RHOTFkSEIxZEM1emNHeHBZMlVvYVNzckxDQXdMQ0J1S1R0Y2JseHVYSFJjZEgxY2JseHVYSFJjZEhKbGRIVnliaUIxWTNNeVpXNWpiMlJsS0c5MWRIQjFkQ2s3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1EyOXVkbVZ5ZEhNZ1lTQnpkSEpwYm1jZ2IyWWdWVzVwWTI5a1pTQnplVzFpYjJ4eklDaGxMbWN1SUdFZ1pHOXRZV2x1SUc1aGJXVWdiR0ZpWld3cElIUnZJR0ZjYmx4MElDb2dVSFZ1ZVdOdlpHVWdjM1J5YVc1bklHOW1JRUZUUTBsSkxXOXViSGtnYzNsdFltOXNjeTVjYmx4MElDb2dRRzFsYldKbGNrOW1JSEIxYm5samIyUmxYRzVjZENBcUlFQndZWEpoYlNCN1UzUnlhVzVuZlNCcGJuQjFkQ0JVYUdVZ2MzUnlhVzVuSUc5bUlGVnVhV052WkdVZ2MzbHRZbTlzY3k1Y2JseDBJQ29nUUhKbGRIVnlibk1nZTFOMGNtbHVaMzBnVkdobElISmxjM1ZzZEdsdVp5QlFkVzU1WTI5a1pTQnpkSEpwYm1jZ2IyWWdRVk5EU1VrdGIyNXNlU0J6ZVcxaWIyeHpMbHh1WEhRZ0tpOWNibHgwWm5WdVkzUnBiMjRnWlc1amIyUmxLR2x1Y0hWMEtTQjdYRzVjZEZ4MGRtRnlJRzRzWEc1Y2RGeDBJQ0FnSUdSbGJIUmhMRnh1WEhSY2RDQWdJQ0JvWVc1a2JHVmtRMUJEYjNWdWRDeGNibHgwWEhRZ0lDQWdZbUZ6YVdOTVpXNW5kR2dzWEc1Y2RGeDBJQ0FnSUdKcFlYTXNYRzVjZEZ4MElDQWdJR29zWEc1Y2RGeDBJQ0FnSUcwc1hHNWNkRngwSUNBZ0lIRXNYRzVjZEZ4MElDQWdJR3NzWEc1Y2RGeDBJQ0FnSUhRc1hHNWNkRngwSUNBZ0lHTjFjbkpsYm5SV1lXeDFaU3hjYmx4MFhIUWdJQ0FnYjNWMGNIVjBJRDBnVzEwc1hHNWNkRngwSUNBZ0lDOHFLaUJnYVc1d2RYUk1aVzVuZEdoZ0lIZHBiR3dnYUc5c1pDQjBhR1VnYm5WdFltVnlJRzltSUdOdlpHVWdjRzlwYm5SeklHbHVJR0JwYm5CMWRHQXVJQ292WEc1Y2RGeDBJQ0FnSUdsdWNIVjBUR1Z1WjNSb0xGeHVYSFJjZENBZ0lDQXZLaW9nUTJGamFHVmtJR05oYkdOMWJHRjBhVzl1SUhKbGMzVnNkSE1nS2k5Y2JseDBYSFFnSUNBZ2FHRnVaR3hsWkVOUVEyOTFiblJRYkhWelQyNWxMRnh1WEhSY2RDQWdJQ0JpWVhObFRXbHVkWE5VTEZ4dVhIUmNkQ0FnSUNCeFRXbHVkWE5VTzF4dVhHNWNkRngwTHk4Z1EyOXVkbVZ5ZENCMGFHVWdhVzV3ZFhRZ2FXNGdWVU5UTFRJZ2RHOGdWVzVwWTI5a1pWeHVYSFJjZEdsdWNIVjBJRDBnZFdOek1tUmxZMjlrWlNocGJuQjFkQ2s3WEc1Y2JseDBYSFF2THlCRFlXTm9aU0IwYUdVZ2JHVnVaM1JvWEc1Y2RGeDBhVzV3ZFhSTVpXNW5kR2dnUFNCcGJuQjFkQzVzWlc1bmRHZzdYRzVjYmx4MFhIUXZMeUJKYm1sMGFXRnNhWHBsSUhSb1pTQnpkR0YwWlZ4dVhIUmNkRzRnUFNCcGJtbDBhV0ZzVGp0Y2JseDBYSFJrWld4MFlTQTlJREE3WEc1Y2RGeDBZbWxoY3lBOUlHbHVhWFJwWVd4Q2FXRnpPMXh1WEc1Y2RGeDBMeThnU0dGdVpHeGxJSFJvWlNCaVlYTnBZeUJqYjJSbElIQnZhVzUwYzF4dVhIUmNkR1p2Y2lBb2FpQTlJREE3SUdvZ1BDQnBibkIxZEV4bGJtZDBhRHNnS3l0cUtTQjdYRzVjZEZ4MFhIUmpkWEp5Wlc1MFZtRnNkV1VnUFNCcGJuQjFkRnRxWFR0Y2JseDBYSFJjZEdsbUlDaGpkWEp5Wlc1MFZtRnNkV1VnUENBd2VEZ3dLU0I3WEc1Y2RGeDBYSFJjZEc5MWRIQjFkQzV3ZFhOb0tITjBjbWx1WjBaeWIyMURhR0Z5UTI5a1pTaGpkWEp5Wlc1MFZtRnNkV1VwS1R0Y2JseDBYSFJjZEgxY2JseDBYSFI5WEc1Y2JseDBYSFJvWVc1a2JHVmtRMUJEYjNWdWRDQTlJR0poYzJsalRHVnVaM1JvSUQwZ2IzVjBjSFYwTG14bGJtZDBhRHRjYmx4dVhIUmNkQzh2SUdCb1lXNWtiR1ZrUTFCRGIzVnVkR0FnYVhNZ2RHaGxJRzUxYldKbGNpQnZaaUJqYjJSbElIQnZhVzUwY3lCMGFHRjBJR2hoZG1VZ1ltVmxiaUJvWVc1a2JHVmtPMXh1WEhSY2RDOHZJR0JpWVhOcFkweGxibWQwYUdBZ2FYTWdkR2hsSUc1MWJXSmxjaUJ2WmlCaVlYTnBZeUJqYjJSbElIQnZhVzUwY3k1Y2JseHVYSFJjZEM4dklFWnBibWx6YUNCMGFHVWdZbUZ6YVdNZ2MzUnlhVzVuSUMwZ2FXWWdhWFFnYVhNZ2JtOTBJR1Z0Y0hSNUlDMGdkMmwwYUNCaElHUmxiR2x0YVhSbGNseHVYSFJjZEdsbUlDaGlZWE5wWTB4bGJtZDBhQ2tnZTF4dVhIUmNkRngwYjNWMGNIVjBMbkIxYzJnb1pHVnNhVzFwZEdWeUtUdGNibHgwWEhSOVhHNWNibHgwWEhRdkx5Qk5ZV2x1SUdWdVkyOWthVzVuSUd4dmIzQTZYRzVjZEZ4MGQyaHBiR1VnS0doaGJtUnNaV1JEVUVOdmRXNTBJRHdnYVc1d2RYUk1aVzVuZEdncElIdGNibHh1WEhSY2RGeDBMeThnUVd4c0lHNXZiaTFpWVhOcFl5QmpiMlJsSUhCdmFXNTBjeUE4SUc0Z2FHRjJaU0JpWldWdUlHaGhibVJzWldRZ1lXeHlaV0ZrZVM0Z1JtbHVaQ0IwYUdVZ2JtVjRkRnh1WEhSY2RGeDBMeThnYkdGeVoyVnlJRzl1WlRwY2JseDBYSFJjZEdadmNpQW9iU0E5SUcxaGVFbHVkQ3dnYWlBOUlEQTdJR29nUENCcGJuQjFkRXhsYm1kMGFEc2dLeXRxS1NCN1hHNWNkRngwWEhSY2RHTjFjbkpsYm5SV1lXeDFaU0E5SUdsdWNIVjBXMnBkTzF4dVhIUmNkRngwWEhScFppQW9ZM1Z5Y21WdWRGWmhiSFZsSUQ0OUlHNGdKaVlnWTNWeWNtVnVkRlpoYkhWbElEd2diU2tnZTF4dVhIUmNkRngwWEhSY2RHMGdQU0JqZFhKeVpXNTBWbUZzZFdVN1hHNWNkRngwWEhSY2RIMWNibHgwWEhSY2RIMWNibHh1WEhSY2RGeDBMeThnU1c1amNtVmhjMlVnWUdSbGJIUmhZQ0JsYm05MVoyZ2dkRzhnWVdSMllXNWpaU0IwYUdVZ1pHVmpiMlJsY2lkeklEeHVMR2srSUhOMFlYUmxJSFJ2SUR4dExEQStMRnh1WEhSY2RGeDBMeThnWW5WMElHZDFZWEprSUdGbllXbHVjM1FnYjNabGNtWnNiM2RjYmx4MFhIUmNkR2hoYm1Sc1pXUkRVRU52ZFc1MFVHeDFjMDl1WlNBOUlHaGhibVJzWldSRFVFTnZkVzUwSUNzZ01UdGNibHgwWEhSY2RHbG1JQ2h0SUMwZ2JpQStJR1pzYjI5eUtDaHRZWGhKYm5RZ0xTQmtaV3gwWVNrZ0x5Qm9ZVzVrYkdWa1ExQkRiM1Z1ZEZCc2RYTlBibVVwS1NCN1hHNWNkRngwWEhSY2RHVnljbTl5S0NkdmRtVnlabXh2ZHljcE8xeHVYSFJjZEZ4MGZWeHVYRzVjZEZ4MFhIUmtaV3gwWVNBclBTQW9iU0F0SUc0cElDb2dhR0Z1Wkd4bFpFTlFRMjkxYm5SUWJIVnpUMjVsTzF4dVhIUmNkRngwYmlBOUlHMDdYRzVjYmx4MFhIUmNkR1p2Y2lBb2FpQTlJREE3SUdvZ1BDQnBibkIxZEV4bGJtZDBhRHNnS3l0cUtTQjdYRzVjZEZ4MFhIUmNkR04xY25KbGJuUldZV3gxWlNBOUlHbHVjSFYwVzJwZE8xeHVYRzVjZEZ4MFhIUmNkR2xtSUNoamRYSnlaVzUwVm1Gc2RXVWdQQ0J1SUNZbUlDc3JaR1ZzZEdFZ1BpQnRZWGhKYm5RcElIdGNibHgwWEhSY2RGeDBYSFJsY25KdmNpZ25iM1psY21ac2IzY25LVHRjYmx4MFhIUmNkRngwZlZ4dVhHNWNkRngwWEhSY2RHbG1JQ2hqZFhKeVpXNTBWbUZzZFdVZ1BUMGdiaWtnZTF4dVhIUmNkRngwWEhSY2RDOHZJRkpsY0hKbGMyVnVkQ0JrWld4MFlTQmhjeUJoSUdkbGJtVnlZV3hwZW1Wa0lIWmhjbWxoWW14bExXeGxibWQwYUNCcGJuUmxaMlZ5WEc1Y2RGeDBYSFJjZEZ4MFptOXlJQ2h4SUQwZ1pHVnNkR0VzSUdzZ1BTQmlZWE5sT3lBdktpQnVieUJqYjI1a2FYUnBiMjRnS2k4N0lHc2dLejBnWW1GelpTa2dlMXh1WEhSY2RGeDBYSFJjZEZ4MGRDQTlJR3NnUEQwZ1ltbGhjeUEvSUhSTmFXNGdPaUFvYXlBK1BTQmlhV0Z6SUNzZ2RFMWhlQ0EvSUhSTllYZ2dPaUJySUMwZ1ltbGhjeWs3WEc1Y2RGeDBYSFJjZEZ4MFhIUnBaaUFvY1NBOElIUXBJSHRjYmx4MFhIUmNkRngwWEhSY2RGeDBZbkpsWVdzN1hHNWNkRngwWEhSY2RGeDBYSFI5WEc1Y2RGeDBYSFJjZEZ4MFhIUnhUV2x1ZFhOVUlEMGdjU0F0SUhRN1hHNWNkRngwWEhSY2RGeDBYSFJpWVhObFRXbHVkWE5VSUQwZ1ltRnpaU0F0SUhRN1hHNWNkRngwWEhSY2RGeDBYSFJ2ZFhSd2RYUXVjSFZ6YUNoY2JseDBYSFJjZEZ4MFhIUmNkRngwYzNSeWFXNW5Sbkp2YlVOb1lYSkRiMlJsS0dScFoybDBWRzlDWVhOcFl5aDBJQ3NnY1UxcGJuVnpWQ0FsSUdKaGMyVk5hVzUxYzFRc0lEQXBLVnh1WEhSY2RGeDBYSFJjZEZ4MEtUdGNibHgwWEhSY2RGeDBYSFJjZEhFZ1BTQm1iRzl2Y2loeFRXbHVkWE5VSUM4Z1ltRnpaVTFwYm5WelZDazdYRzVjZEZ4MFhIUmNkRngwZlZ4dVhHNWNkRngwWEhSY2RGeDBiM1YwY0hWMExuQjFjMmdvYzNSeWFXNW5Sbkp2YlVOb1lYSkRiMlJsS0dScFoybDBWRzlDWVhOcFl5aHhMQ0F3S1NrcE8xeHVYSFJjZEZ4MFhIUmNkR0pwWVhNZ1BTQmhaR0Z3ZENoa1pXeDBZU3dnYUdGdVpHeGxaRU5RUTI5MWJuUlFiSFZ6VDI1bExDQm9ZVzVrYkdWa1ExQkRiM1Z1ZENBOVBTQmlZWE5wWTB4bGJtZDBhQ2s3WEc1Y2RGeDBYSFJjZEZ4MFpHVnNkR0VnUFNBd08xeHVYSFJjZEZ4MFhIUmNkQ3NyYUdGdVpHeGxaRU5RUTI5MWJuUTdYRzVjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkSDFjYmx4dVhIUmNkRngwS3l0a1pXeDBZVHRjYmx4MFhIUmNkQ3NyYmp0Y2JseHVYSFJjZEgxY2JseDBYSFJ5WlhSMWNtNGdiM1YwY0hWMExtcHZhVzRvSnljcE8xeHVYSFI5WEc1Y2JseDBMeW9xWEc1Y2RDQXFJRU52Ym5abGNuUnpJR0VnVUhWdWVXTnZaR1VnYzNSeWFXNW5JSEpsY0hKbGMyVnVkR2x1WnlCaElHUnZiV0ZwYmlCdVlXMWxJRzl5SUdGdUlHVnRZV2xzSUdGa1pISmxjM05jYmx4MElDb2dkRzhnVlc1cFkyOWtaUzRnVDI1c2VTQjBhR1VnVUhWdWVXTnZaR1ZrSUhCaGNuUnpJRzltSUhSb1pTQnBibkIxZENCM2FXeHNJR0psSUdOdmJuWmxjblJsWkN3Z2FTNWxMbHh1WEhRZ0tpQnBkQ0JrYjJWemJpZDBJRzFoZEhSbGNpQnBaaUI1YjNVZ1kyRnNiQ0JwZENCdmJpQmhJSE4wY21sdVp5QjBhR0YwSUdoaGN5QmhiSEpsWVdSNUlHSmxaVzVjYmx4MElDb2dZMjl1ZG1WeWRHVmtJSFJ2SUZWdWFXTnZaR1V1WEc1Y2RDQXFJRUJ0WlcxaVpYSlBaaUJ3ZFc1NVkyOWtaVnh1WEhRZ0tpQkFjR0Z5WVcwZ2UxTjBjbWx1WjMwZ2FXNXdkWFFnVkdobElGQjFibmxqYjJSbFpDQmtiMjFoYVc0Z2JtRnRaU0J2Y2lCbGJXRnBiQ0JoWkdSeVpYTnpJSFJ2WEc1Y2RDQXFJR052Ym5abGNuUWdkRzhnVlc1cFkyOWtaUzVjYmx4MElDb2dRSEpsZEhWeWJuTWdlMU4wY21sdVozMGdWR2hsSUZWdWFXTnZaR1VnY21Wd2NtVnpaVzUwWVhScGIyNGdiMllnZEdobElHZHBkbVZ1SUZCMWJubGpiMlJsWEc1Y2RDQXFJSE4wY21sdVp5NWNibHgwSUNvdlhHNWNkR1oxYm1OMGFXOXVJSFJ2Vlc1cFkyOWtaU2hwYm5CMWRDa2dlMXh1WEhSY2RISmxkSFZ5YmlCdFlYQkViMjFoYVc0b2FXNXdkWFFzSUdaMWJtTjBhVzl1S0hOMGNtbHVaeWtnZTF4dVhIUmNkRngwY21WMGRYSnVJSEpsWjJWNFVIVnVlV052WkdVdWRHVnpkQ2h6ZEhKcGJtY3BYRzVjZEZ4MFhIUmNkRDhnWkdWamIyUmxLSE4wY21sdVp5NXpiR2xqWlNnMEtTNTBiMHh2ZDJWeVEyRnpaU2dwS1Z4dVhIUmNkRngwWEhRNklITjBjbWx1Wnp0Y2JseDBYSFI5S1R0Y2JseDBmVnh1WEc1Y2RDOHFLbHh1WEhRZ0tpQkRiMjUyWlhKMGN5QmhJRlZ1YVdOdlpHVWdjM1J5YVc1bklISmxjSEpsYzJWdWRHbHVaeUJoSUdSdmJXRnBiaUJ1WVcxbElHOXlJR0Z1SUdWdFlXbHNJR0ZrWkhKbGMzTWdkRzljYmx4MElDb2dVSFZ1ZVdOdlpHVXVJRTl1YkhrZ2RHaGxJRzV2YmkxQlUwTkpTU0J3WVhKMGN5QnZaaUIwYUdVZ1pHOXRZV2x1SUc1aGJXVWdkMmxzYkNCaVpTQmpiMjUyWlhKMFpXUXNYRzVjZENBcUlHa3VaUzRnYVhRZ1pHOWxjMjRuZENCdFlYUjBaWElnYVdZZ2VXOTFJR05oYkd3Z2FYUWdkMmwwYUNCaElHUnZiV0ZwYmlCMGFHRjBKM01nWVd4eVpXRmtlU0JwYmx4dVhIUWdLaUJCVTBOSlNTNWNibHgwSUNvZ1FHMWxiV0psY2s5bUlIQjFibmxqYjJSbFhHNWNkQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0JwYm5CMWRDQlVhR1VnWkc5dFlXbHVJRzVoYldVZ2IzSWdaVzFoYVd3Z1lXUmtjbVZ6Y3lCMGJ5QmpiMjUyWlhKMExDQmhjeUJoWEc1Y2RDQXFJRlZ1YVdOdlpHVWdjM1J5YVc1bkxseHVYSFFnS2lCQWNtVjBkWEp1Y3lCN1UzUnlhVzVuZlNCVWFHVWdVSFZ1ZVdOdlpHVWdjbVZ3Y21WelpXNTBZWFJwYjI0Z2IyWWdkR2hsSUdkcGRtVnVJR1J2YldGcGJpQnVZVzFsSUc5eVhHNWNkQ0FxSUdWdFlXbHNJR0ZrWkhKbGMzTXVYRzVjZENBcUwxeHVYSFJtZFc1amRHbHZiaUIwYjBGVFEwbEpLR2x1Y0hWMEtTQjdYRzVjZEZ4MGNtVjBkWEp1SUcxaGNFUnZiV0ZwYmlocGJuQjFkQ3dnWm5WdVkzUnBiMjRvYzNSeWFXNW5LU0I3WEc1Y2RGeDBYSFJ5WlhSMWNtNGdjbVZuWlhoT2IyNUJVME5KU1M1MFpYTjBLSE4wY21sdVp5bGNibHgwWEhSY2RGeDBQeUFuZUc0dExTY2dLeUJsYm1OdlpHVW9jM1J5YVc1bktWeHVYSFJjZEZ4MFhIUTZJSE4wY21sdVp6dGNibHgwWEhSOUtUdGNibHgwZlZ4dVhHNWNkQzhxTFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwcUwxeHVYRzVjZEM4cUtpQkVaV1pwYm1VZ2RHaGxJSEIxWW14cFl5QkJVRWtnS2k5Y2JseDBjSFZ1ZVdOdlpHVWdQU0I3WEc1Y2RGeDBMeW9xWEc1Y2RGeDBJQ29nUVNCemRISnBibWNnY21Wd2NtVnpaVzUwYVc1bklIUm9aU0JqZFhKeVpXNTBJRkIxYm5samIyUmxMbXB6SUhabGNuTnBiMjRnYm5WdFltVnlMbHh1WEhSY2RDQXFJRUJ0WlcxaVpYSlBaaUJ3ZFc1NVkyOWtaVnh1WEhSY2RDQXFJRUIwZVhCbElGTjBjbWx1WjF4dVhIUmNkQ0FxTDF4dVhIUmNkQ2QyWlhKemFXOXVKem9nSnpFdU15NHlKeXhjYmx4MFhIUXZLaXBjYmx4MFhIUWdLaUJCYmlCdlltcGxZM1FnYjJZZ2JXVjBhRzlrY3lCMGJ5QmpiMjUyWlhKMElHWnliMjBnU21GMllWTmpjbWx3ZENkeklHbHVkR1Z5Ym1Gc0lHTm9ZWEpoWTNSbGNseHVYSFJjZENBcUlISmxjSEpsYzJWdWRHRjBhVzl1SUNoVlExTXRNaWtnZEc4Z1ZXNXBZMjlrWlNCamIyUmxJSEJ2YVc1MGN5d2dZVzVrSUdKaFkyc3VYRzVjZEZ4MElDb2dRSE5sWlNBOGFIUjBjSE02THk5dFlYUm9hV0Z6WW5sdVpXNXpMbUpsTDI1dmRHVnpMMnBoZG1GelkzSnBjSFF0Wlc1amIyUnBibWMrWEc1Y2RGeDBJQ29nUUcxbGJXSmxjazltSUhCMWJubGpiMlJsWEc1Y2RGeDBJQ29nUUhSNWNHVWdUMkpxWldOMFhHNWNkRngwSUNvdlhHNWNkRngwSjNWamN6SW5PaUI3WEc1Y2RGeDBYSFFuWkdWamIyUmxKem9nZFdOek1tUmxZMjlrWlN4Y2JseDBYSFJjZENkbGJtTnZaR1VuT2lCMVkzTXlaVzVqYjJSbFhHNWNkRngwZlN4Y2JseDBYSFFuWkdWamIyUmxKem9nWkdWamIyUmxMRnh1WEhSY2RDZGxibU52WkdVbk9pQmxibU52WkdVc1hHNWNkRngwSjNSdlFWTkRTVWtuT2lCMGIwRlRRMGxKTEZ4dVhIUmNkQ2QwYjFWdWFXTnZaR1VuT2lCMGIxVnVhV052WkdWY2JseDBmVHRjYmx4dVhIUXZLaW9nUlhod2IzTmxJR0J3ZFc1NVkyOWtaV0FnS2k5Y2JseDBMeThnVTI5dFpTQkJUVVFnWW5WcGJHUWdiM0IwYVcxcGVtVnljeXdnYkdsclpTQnlMbXB6TENCamFHVmpheUJtYjNJZ2MzQmxZMmxtYVdNZ1kyOXVaR2wwYVc5dUlIQmhkSFJsY201elhHNWNkQzh2SUd4cGEyVWdkR2hsSUdadmJHeHZkMmx1WnpwY2JseDBhV1lnS0Z4dVhIUmNkSFI1Y0dWdlppQmtaV1pwYm1VZ1BUMGdKMloxYm1OMGFXOXVKeUFtSmx4dVhIUmNkSFI1Y0dWdlppQmtaV1pwYm1VdVlXMWtJRDA5SUNkdlltcGxZM1FuSUNZbVhHNWNkRngwWkdWbWFXNWxMbUZ0WkZ4dVhIUXBJSHRjYmx4MFhIUmtaV1pwYm1Vb0ozQjFibmxqYjJSbEp5d2dablZ1WTNScGIyNG9LU0I3WEc1Y2RGeDBYSFJ5WlhSMWNtNGdjSFZ1ZVdOdlpHVTdYRzVjZEZ4MGZTazdYRzVjZEgwZ1pXeHpaU0JwWmlBb1puSmxaVVY0Y0c5eWRITWdKaVlnWm5KbFpVMXZaSFZzWlNrZ2UxeHVYSFJjZEdsbUlDaHRiMlIxYkdVdVpYaHdiM0owY3lBOVBTQm1jbVZsUlhod2IzSjBjeWtnZXlBdkx5QnBiaUJPYjJSbExtcHpJRzl5SUZKcGJtZHZTbE1nZGpBdU9DNHdLMXh1WEhSY2RGeDBabkpsWlUxdlpIVnNaUzVsZUhCdmNuUnpJRDBnY0hWdWVXTnZaR1U3WEc1Y2RGeDBmU0JsYkhObElIc2dMeThnYVc0Z1RtRnlkMmhoYkNCdmNpQlNhVzVuYjBwVElIWXdMamN1TUMxY2JseDBYSFJjZEdadmNpQW9hMlY1SUdsdUlIQjFibmxqYjJSbEtTQjdYRzVjZEZ4MFhIUmNkSEIxYm5samIyUmxMbWhoYzA5M2JsQnliM0JsY25SNUtHdGxlU2tnSmlZZ0tHWnlaV1ZGZUhCdmNuUnpXMnRsZVYwZ1BTQndkVzU1WTI5a1pWdHJaWGxkS1R0Y2JseDBYSFJjZEgxY2JseDBYSFI5WEc1Y2RIMGdaV3h6WlNCN0lDOHZJR2x1SUZKb2FXNXZJRzl5SUdFZ2QyVmlJR0p5YjNkelpYSmNibHgwWEhSeWIyOTBMbkIxYm5samIyUmxJRDBnY0hWdWVXTnZaR1U3WEc1Y2RIMWNibHh1ZlNoMGFHbHpLU2s3WEc0aUxDSXZMeUJEYjNCNWNtbG5hSFFnU205NVpXNTBMQ0JKYm1NdUlHRnVaQ0J2ZEdobGNpQk9iMlJsSUdOdmJuUnlhV0oxZEc5eWN5NWNiaTh2WEc0dkx5QlFaWEp0YVhOemFXOXVJR2x6SUdobGNtVmllU0JuY21GdWRHVmtMQ0JtY21WbElHOW1JR05vWVhKblpTd2dkRzhnWVc1NUlIQmxjbk52YmlCdlluUmhhVzVwYm1jZ1lWeHVMeThnWTI5d2VTQnZaaUIwYUdseklITnZablIzWVhKbElHRnVaQ0JoYzNOdlkybGhkR1ZrSUdSdlkzVnRaVzUwWVhScGIyNGdabWxzWlhNZ0tIUm9aVnh1THk4Z1hDSlRiMlowZDJGeVpWd2lLU3dnZEc4Z1pHVmhiQ0JwYmlCMGFHVWdVMjltZEhkaGNtVWdkMmwwYUc5MWRDQnlaWE4wY21samRHbHZiaXdnYVc1amJIVmthVzVuWEc0dkx5QjNhWFJvYjNWMElHeHBiV2wwWVhScGIyNGdkR2hsSUhKcFoyaDBjeUIwYnlCMWMyVXNJR052Y0hrc0lHMXZaR2xtZVN3Z2JXVnlaMlVzSUhCMVlteHBjMmdzWEc0dkx5QmthWE4wY21saWRYUmxMQ0J6ZFdKc2FXTmxibk5sTENCaGJtUXZiM0lnYzJWc2JDQmpiM0JwWlhNZ2IyWWdkR2hsSUZOdlpuUjNZWEpsTENCaGJtUWdkRzhnY0dWeWJXbDBYRzR2THlCd1pYSnpiMjV6SUhSdklIZG9iMjBnZEdobElGTnZablIzWVhKbElHbHpJR1oxY201cGMyaGxaQ0IwYnlCa2J5QnpieXdnYzNWaWFtVmpkQ0IwYnlCMGFHVmNiaTh2SUdadmJHeHZkMmx1WnlCamIyNWthWFJwYjI1ek9seHVMeTljYmk4dklGUm9aU0JoWW05MlpTQmpiM0I1Y21sbmFIUWdibTkwYVdObElHRnVaQ0IwYUdseklIQmxjbTFwYzNOcGIyNGdibTkwYVdObElITm9ZV3hzSUdKbElHbHVZMngxWkdWa1hHNHZMeUJwYmlCaGJHd2dZMjl3YVdWeklHOXlJSE4xWW5OMFlXNTBhV0ZzSUhCdmNuUnBiMjV6SUc5bUlIUm9aU0JUYjJaMGQyRnlaUzVjYmk4dlhHNHZMeUJVU0VVZ1UwOUdWRmRCVWtVZ1NWTWdVRkpQVmtsRVJVUWdYQ0pCVXlCSlUxd2lMQ0JYU1ZSSVQxVlVJRmRCVWxKQlRsUlpJRTlHSUVGT1dTQkxTVTVFTENCRldGQlNSVk5UWEc0dkx5QlBVaUJKVFZCTVNVVkVMQ0JKVGtOTVZVUkpUa2NnUWxWVUlFNVBWQ0JNU1UxSlZFVkVJRlJQSUZSSVJTQlhRVkpTUVU1VVNVVlRJRTlHWEc0dkx5Qk5SVkpEU0VGT1ZFRkNTVXhKVkZrc0lFWkpWRTVGVTFNZ1JrOVNJRUVnVUVGU1ZFbERWVXhCVWlCUVZWSlFUMU5GSUVGT1JDQk9UMDVKVGtaU1NVNUhSVTFGVGxRdUlFbE9YRzR2THlCT1R5QkZWa1ZPVkNCVFNFRk1UQ0JVU0VVZ1FWVlVTRTlTVXlCUFVpQkRUMUJaVWtsSFNGUWdTRTlNUkVWU1V5QkNSU0JNU1VGQ1RFVWdSazlTSUVGT1dTQkRURUZKVFN4Y2JpOHZJRVJCVFVGSFJWTWdUMUlnVDFSSVJWSWdURWxCUWtsTVNWUlpMQ0JYU0VWVVNFVlNJRWxPSUVGT0lFRkRWRWxQVGlCUFJpQkRUMDVVVWtGRFZDd2dWRTlTVkNCUFVseHVMeThnVDFSSVJWSlhTVk5GTENCQlVrbFRTVTVISUVaU1QwMHNJRTlWVkNCUFJpQlBVaUJKVGlCRFQwNU9SVU5VU1U5T0lGZEpWRWdnVkVoRklGTlBSbFJYUVZKRklFOVNJRlJJUlZ4dUx5OGdWVk5GSUU5U0lFOVVTRVZTSUVSRlFVeEpUa2RUSUVsT0lGUklSU0JUVDBaVVYwRlNSUzVjYmx4dUozVnpaU0J6ZEhKcFkzUW5PMXh1WEc1MllYSWdjSFZ1ZVdOdlpHVWdQU0J5WlhGMWFYSmxLQ2R3ZFc1NVkyOWtaU2NwTzF4dWRtRnlJSFYwYVd3Z1BTQnlaWEYxYVhKbEtDY3VMM1YwYVd3bktUdGNibHh1Wlhod2IzSjBjeTV3WVhKelpTQTlJSFZ5YkZCaGNuTmxPMXh1Wlhod2IzSjBjeTV5WlhOdmJIWmxJRDBnZFhKc1VtVnpiMngyWlR0Y2JtVjRjRzl5ZEhNdWNtVnpiMngyWlU5aWFtVmpkQ0E5SUhWeWJGSmxjMjlzZG1WUFltcGxZM1E3WEc1bGVIQnZjblJ6TG1admNtMWhkQ0E5SUhWeWJFWnZjbTFoZER0Y2JseHVaWGh3YjNKMGN5NVZjbXdnUFNCVmNtdzdYRzVjYm1aMWJtTjBhVzl1SUZWeWJDZ3BJSHRjYmlBZ2RHaHBjeTV3Y205MGIyTnZiQ0E5SUc1MWJHdzdYRzRnSUhSb2FYTXVjMnhoYzJobGN5QTlJRzUxYkd3N1hHNGdJSFJvYVhNdVlYVjBhQ0E5SUc1MWJHdzdYRzRnSUhSb2FYTXVhRzl6ZENBOUlHNTFiR3c3WEc0Z0lIUm9hWE11Y0c5eWRDQTlJRzUxYkd3N1hHNGdJSFJvYVhNdWFHOXpkRzVoYldVZ1BTQnVkV3hzTzF4dUlDQjBhR2x6TG1oaGMyZ2dQU0J1ZFd4c08xeHVJQ0IwYUdsekxuTmxZWEpqYUNBOUlHNTFiR3c3WEc0Z0lIUm9hWE11Y1hWbGNua2dQU0J1ZFd4c08xeHVJQ0IwYUdsekxuQmhkR2h1WVcxbElEMGdiblZzYkR0Y2JpQWdkR2hwY3k1d1lYUm9JRDBnYm5Wc2JEdGNiaUFnZEdocGN5NW9jbVZtSUQwZ2JuVnNiRHRjYm4xY2JseHVMeThnVW1WbVpYSmxibU5sT2lCU1JrTWdNems0Tml3Z1VrWkRJREU0TURnc0lGSkdReUF5TXprMlhHNWNiaTh2SUdSbFptbHVaU0IwYUdWelpTQm9aWEpsSUhOdklHRjBJR3hsWVhOMElIUm9aWGtnYjI1c2VTQm9ZWFpsSUhSdklHSmxYRzR2THlCamIyMXdhV3hsWkNCdmJtTmxJRzl1SUhSb1pTQm1hWEp6ZENCdGIyUjFiR1VnYkc5aFpDNWNiblpoY2lCd2NtOTBiMk52YkZCaGRIUmxjbTRnUFNBdlhpaGJZUzE2TUMwNUxpc3RYU3M2S1M5cExGeHVJQ0FnSUhCdmNuUlFZWFIwWlhKdUlEMGdMenBiTUMwNVhTb2tMeXhjYmx4dUlDQWdJQzh2SUZOd1pXTnBZV3dnWTJGelpTQm1iM0lnWVNCemFXMXdiR1VnY0dGMGFDQlZVa3hjYmlBZ0lDQnphVzF3YkdWUVlYUm9VR0YwZEdWeWJpQTlJQzllS0Z4Y0wxeGNMejhvUHlGY1hDOHBXMTVjWEQ5Y1hITmRLaWtvWEZ3L1cxNWNYSE5kS2lrL0pDOHNYRzVjYmlBZ0lDQXZMeUJTUmtNZ01qTTVOam9nWTJoaGNtRmpkR1Z5Y3lCeVpYTmxjblpsWkNCbWIzSWdaR1ZzYVcxcGRHbHVaeUJWVWt4ekxseHVJQ0FnSUM4dklGZGxJR0ZqZEhWaGJHeDVJR3AxYzNRZ1lYVjBieTFsYzJOaGNHVWdkR2hsYzJVdVhHNGdJQ0FnWkdWc2FXMXpJRDBnV3ljOEp5d2dKejRuTENBblhDSW5MQ0FuWUNjc0lDY2dKeXdnSjF4Y2NpY3NJQ2RjWEc0bkxDQW5YRngwSjEwc1hHNWNiaUFnSUNBdkx5QlNSa01nTWpNNU5qb2dZMmhoY21GamRHVnljeUJ1YjNRZ1lXeHNiM2RsWkNCbWIzSWdkbUZ5YVc5MWN5QnlaV0Z6YjI1ekxseHVJQ0FnSUhWdWQybHpaU0E5SUZzbmV5Y3NJQ2Q5Snl3Z0ozd25MQ0FuWEZ4Y1hDY3NJQ2RlSnl3Z0oyQW5YUzVqYjI1allYUW9aR1ZzYVcxektTeGNibHh1SUNBZ0lDOHZJRUZzYkc5M1pXUWdZbmtnVWtaRGN5d2dZblYwSUdOaGRYTmxJRzltSUZoVFV5QmhkSFJoWTJ0ekxpQWdRV3gzWVhseklHVnpZMkZ3WlNCMGFHVnpaUzVjYmlBZ0lDQmhkWFJ2UlhOallYQmxJRDBnV3lkY1hDY25YUzVqYjI1allYUW9kVzUzYVhObEtTeGNiaUFnSUNBdkx5QkRhR0Z5WVdOMFpYSnpJSFJvWVhRZ1lYSmxJRzVsZG1WeUlHVjJaWElnWVd4c2IzZGxaQ0JwYmlCaElHaHZjM1J1WVcxbExseHVJQ0FnSUM4dklFNXZkR1VnZEdoaGRDQmhibmtnYVc1MllXeHBaQ0JqYUdGeWN5QmhjbVVnWVd4emJ5Qm9ZVzVrYkdWa0xDQmlkWFFnZEdobGMyVmNiaUFnSUNBdkx5QmhjbVVnZEdobElHOXVaWE1nZEdoaGRDQmhjbVVnS21WNGNHVmpkR1ZrS2lCMGJ5QmlaU0J6WldWdUxDQnpieUIzWlNCbVlYTjBMWEJoZEdoY2JpQWdJQ0F2THlCMGFHVnRMbHh1SUNBZ0lHNXZia2h2YzNSRGFHRnljeUE5SUZzbkpTY3NJQ2N2Snl3Z0p6OG5MQ0FuT3ljc0lDY2pKMTB1WTI5dVkyRjBLR0YxZEc5RmMyTmhjR1VwTEZ4dUlDQWdJR2h2YzNSRmJtUnBibWREYUdGeWN5QTlJRnNuTHljc0lDYy9KeXdnSnlNblhTeGNiaUFnSUNCb2IzTjBibUZ0WlUxaGVFeGxiaUE5SURJMU5TeGNiaUFnSUNCb2IzTjBibUZ0WlZCaGNuUlFZWFIwWlhKdUlEMGdMMTViSzJFdGVqQXRPVUV0V2w4dFhYc3dMRFl6ZlNRdkxGeHVJQ0FnSUdodmMzUnVZVzFsVUdGeWRGTjBZWEowSUQwZ0wxNG9XeXRoTFhvd0xUbEJMVnBmTFYxN01DdzJNMzBwS0M0cUtTUXZMRnh1SUNBZ0lDOHZJSEJ5YjNSdlkyOXNjeUIwYUdGMElHTmhiaUJoYkd4dmR5QmNJblZ1YzJGbVpWd2lJR0Z1WkNCY0luVnVkMmx6WlZ3aUlHTm9ZWEp6TGx4dUlDQWdJSFZ1YzJGbVpWQnliM1J2WTI5c0lEMGdlMXh1SUNBZ0lDQWdKMnBoZG1GelkzSnBjSFFuT2lCMGNuVmxMRnh1SUNBZ0lDQWdKMnBoZG1GelkzSnBjSFE2SnpvZ2RISjFaVnh1SUNBZ0lIMHNYRzRnSUNBZ0x5OGdjSEp2ZEc5amIyeHpJSFJvWVhRZ2JtVjJaWElnYUdGMlpTQmhJR2h2YzNSdVlXMWxMbHh1SUNBZ0lHaHZjM1JzWlhOelVISnZkRzlqYjJ3Z1BTQjdYRzRnSUNBZ0lDQW5hbUYyWVhOamNtbHdkQ2M2SUhSeWRXVXNYRzRnSUNBZ0lDQW5hbUYyWVhOamNtbHdkRG9uT2lCMGNuVmxYRzRnSUNBZ2ZTeGNiaUFnSUNBdkx5QndjbTkwYjJOdmJITWdkR2hoZENCaGJIZGhlWE1nWTI5dWRHRnBiaUJoSUM4dklHSnBkQzVjYmlBZ0lDQnpiR0Z6YUdWa1VISnZkRzlqYjJ3Z1BTQjdYRzRnSUNBZ0lDQW5hSFIwY0NjNklIUnlkV1VzWEc0Z0lDQWdJQ0FuYUhSMGNITW5PaUIwY25WbExGeHVJQ0FnSUNBZ0oyWjBjQ2M2SUhSeWRXVXNYRzRnSUNBZ0lDQW5aMjl3YUdWeUp6b2dkSEoxWlN4Y2JpQWdJQ0FnSUNkbWFXeGxKem9nZEhKMVpTeGNiaUFnSUNBZ0lDZG9kSFJ3T2ljNklIUnlkV1VzWEc0Z0lDQWdJQ0FuYUhSMGNITTZKem9nZEhKMVpTeGNiaUFnSUNBZ0lDZG1kSEE2SnpvZ2RISjFaU3hjYmlBZ0lDQWdJQ2RuYjNCb1pYSTZKem9nZEhKMVpTeGNiaUFnSUNBZ0lDZG1hV3hsT2ljNklIUnlkV1ZjYmlBZ0lDQjlMRnh1SUNBZ0lIRjFaWEo1YzNSeWFXNW5JRDBnY21WeGRXbHlaU2duY1hWbGNubHpkSEpwYm1jbktUdGNibHh1Wm5WdVkzUnBiMjRnZFhKc1VHRnljMlVvZFhKc0xDQndZWEp6WlZGMVpYSjVVM1J5YVc1bkxDQnpiR0Z6YUdWelJHVnViM1JsU0c5emRDa2dlMXh1SUNCcFppQW9kWEpzSUNZbUlIVjBhV3d1YVhOUFltcGxZM1FvZFhKc0tTQW1KaUIxY213Z2FXNXpkR0Z1WTJWdlppQlZjbXdwSUhKbGRIVnliaUIxY213N1hHNWNiaUFnZG1GeUlIVWdQU0J1WlhjZ1ZYSnNPMXh1SUNCMUxuQmhjbk5sS0hWeWJDd2djR0Z5YzJWUmRXVnllVk4wY21sdVp5d2djMnhoYzJobGMwUmxibTkwWlVodmMzUXBPMXh1SUNCeVpYUjFjbTRnZFR0Y2JuMWNibHh1VlhKc0xuQnliM1J2ZEhsd1pTNXdZWEp6WlNBOUlHWjFibU4wYVc5dUtIVnliQ3dnY0dGeWMyVlJkV1Z5ZVZOMGNtbHVaeXdnYzJ4aGMyaGxjMFJsYm05MFpVaHZjM1FwSUh0Y2JpQWdhV1lnS0NGMWRHbHNMbWx6VTNSeWFXNW5LSFZ5YkNrcElIdGNiaUFnSUNCMGFISnZkeUJ1WlhjZ1ZIbHdaVVZ5Y205eUtGd2lVR0Z5WVcxbGRHVnlJQ2QxY213bklHMTFjM1FnWW1VZ1lTQnpkSEpwYm1jc0lHNXZkQ0JjSWlBcklIUjVjR1Z2WmlCMWNtd3BPMXh1SUNCOVhHNWNiaUFnTHk4Z1EyOXdlU0JqYUhKdmJXVXNJRWxGTENCdmNHVnlZU0JpWVdOcmMyeGhjMmd0YUdGdVpHeHBibWNnWW1Wb1lYWnBiM0l1WEc0Z0lDOHZJRUpoWTJzZ2MyeGhjMmhsY3lCaVpXWnZjbVVnZEdobElIRjFaWEo1SUhOMGNtbHVaeUJuWlhRZ1kyOXVkbVZ5ZEdWa0lIUnZJR1p2Y25kaGNtUWdjMnhoYzJobGMxeHVJQ0F2THlCVFpXVTZJR2gwZEhCek9pOHZZMjlrWlM1bmIyOW5iR1V1WTI5dEwzQXZZMmh5YjIxcGRXMHZhWE56ZFdWekwyUmxkR0ZwYkQ5cFpEMHlOVGt4Tmx4dUlDQjJZWElnY1hWbGNubEpibVJsZUNBOUlIVnliQzVwYm1SbGVFOW1LQ2MvSnlrc1hHNGdJQ0FnSUNCemNHeHBkSFJsY2lBOVhHNGdJQ0FnSUNBZ0lDQWdLSEYxWlhKNVNXNWtaWGdnSVQwOUlDMHhJQ1ltSUhGMVpYSjVTVzVrWlhnZ1BDQjFjbXd1YVc1a1pYaFBaaWduSXljcEtTQS9JQ2MvSnlBNklDY2pKeXhjYmlBZ0lDQWdJSFZUY0d4cGRDQTlJSFZ5YkM1emNHeHBkQ2h6Y0d4cGRIUmxjaWtzWEc0Z0lDQWdJQ0J6YkdGemFGSmxaMlY0SUQwZ0wxeGNYRnd2Wnp0Y2JpQWdkVk53YkdsMFd6QmRJRDBnZFZOd2JHbDBXekJkTG5KbGNHeGhZMlVvYzJ4aGMyaFNaV2RsZUN3Z0p5OG5LVHRjYmlBZ2RYSnNJRDBnZFZOd2JHbDBMbXB2YVc0b2MzQnNhWFIwWlhJcE8xeHVYRzRnSUhaaGNpQnlaWE4wSUQwZ2RYSnNPMXh1WEc0Z0lDOHZJSFJ5YVcwZ1ltVm1iM0psSUhCeWIyTmxaV1JwYm1jdVhHNGdJQzh2SUZSb2FYTWdhWE1nZEc4Z2MzVndjRzl5ZENCd1lYSnpaU0J6ZEhWbVppQnNhV3RsSUZ3aUlDQm9kSFJ3T2k4dlptOXZMbU52YlNBZ1hGeHVYQ0pjYmlBZ2NtVnpkQ0E5SUhKbGMzUXVkSEpwYlNncE8xeHVYRzRnSUdsbUlDZ2hjMnhoYzJobGMwUmxibTkwWlVodmMzUWdKaVlnZFhKc0xuTndiR2wwS0Njakp5a3ViR1Z1WjNSb0lEMDlQU0F4S1NCN1hHNGdJQ0FnTHk4Z1ZISjVJR1poYzNRZ2NHRjBhQ0J5WldkbGVIQmNiaUFnSUNCMllYSWdjMmx0Y0d4bFVHRjBhQ0E5SUhOcGJYQnNaVkJoZEdoUVlYUjBaWEp1TG1WNFpXTW9jbVZ6ZENrN1hHNGdJQ0FnYVdZZ0tITnBiWEJzWlZCaGRHZ3BJSHRjYmlBZ0lDQWdJSFJvYVhNdWNHRjBhQ0E5SUhKbGMzUTdYRzRnSUNBZ0lDQjBhR2x6TG1oeVpXWWdQU0J5WlhOME8xeHVJQ0FnSUNBZ2RHaHBjeTV3WVhSb2JtRnRaU0E5SUhOcGJYQnNaVkJoZEdoYk1WMDdYRzRnSUNBZ0lDQnBaaUFvYzJsdGNHeGxVR0YwYUZzeVhTa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuTmxZWEpqYUNBOUlITnBiWEJzWlZCaGRHaGJNbDA3WEc0Z0lDQWdJQ0FnSUdsbUlDaHdZWEp6WlZGMVpYSjVVM1J5YVc1bktTQjdYRzRnSUNBZ0lDQWdJQ0FnZEdocGN5NXhkV1Z5ZVNBOUlIRjFaWEo1YzNSeWFXNW5MbkJoY25ObEtIUm9hWE11YzJWaGNtTm9Mbk4xWW5OMGNpZ3hLU2s3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RHaHBjeTV4ZFdWeWVTQTlJSFJvYVhNdWMyVmhjbU5vTG5OMVluTjBjaWd4S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHdZWEp6WlZGMVpYSjVVM1J5YVc1bktTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWMyVmhjbU5vSUQwZ0p5YzdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNYVmxjbmtnUFNCN2ZUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxkSFZ5YmlCMGFHbHpPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSFpoY2lCd2NtOTBieUE5SUhCeWIzUnZZMjlzVUdGMGRHVnliaTVsZUdWaktISmxjM1FwTzF4dUlDQnBaaUFvY0hKdmRHOHBJSHRjYmlBZ0lDQndjbTkwYnlBOUlIQnliM1J2V3pCZE8xeHVJQ0FnSUhaaGNpQnNiM2RsY2xCeWIzUnZJRDBnY0hKdmRHOHVkRzlNYjNkbGNrTmhjMlVvS1R0Y2JpQWdJQ0IwYUdsekxuQnliM1J2WTI5c0lEMGdiRzkzWlhKUWNtOTBienRjYmlBZ0lDQnlaWE4wSUQwZ2NtVnpkQzV6ZFdKemRISW9jSEp2ZEc4dWJHVnVaM1JvS1R0Y2JpQWdmVnh1WEc0Z0lDOHZJR1pwWjNWeVpTQnZkWFFnYVdZZ2FYUW5jeUJuYjNRZ1lTQm9iM04wWEc0Z0lDOHZJSFZ6WlhKQWMyVnlkbVZ5SUdseklDcGhiSGRoZVhNcUlHbHVkR1Z5Y0hKbGRHVmtJR0Z6SUdFZ2FHOXpkRzVoYldVc0lHRnVaQ0IxY214Y2JpQWdMeThnY21WemIyeDFkR2x2YmlCM2FXeHNJSFJ5WldGMElDOHZabTl2TDJKaGNpQmhjeUJvYjNOMFBXWnZieXh3WVhSb1BXSmhjaUJpWldOaGRYTmxJSFJvWVhRbmMxeHVJQ0F2THlCb2IzY2dkR2hsSUdKeWIzZHpaWElnY21WemIyeDJaWE1nY21Wc1lYUnBkbVVnVlZKTWN5NWNiaUFnYVdZZ0tITnNZWE5vWlhORVpXNXZkR1ZJYjNOMElIeDhJSEJ5YjNSdklIeDhJSEpsYzNRdWJXRjBZMmdvTDE1Y1hDOWNYQzliWGtCY1hDOWRLMEJiWGtCY1hDOWRLeThwS1NCN1hHNGdJQ0FnZG1GeUlITnNZWE5vWlhNZ1BTQnlaWE4wTG5OMVluTjBjaWd3TENBeUtTQTlQVDBnSnk4dkp6dGNiaUFnSUNCcFppQW9jMnhoYzJobGN5QW1KaUFoS0hCeWIzUnZJQ1ltSUdodmMzUnNaWE56VUhKdmRHOWpiMnhiY0hKdmRHOWRLU2tnZTF4dUlDQWdJQ0FnY21WemRDQTlJSEpsYzNRdWMzVmljM1J5S0RJcE8xeHVJQ0FnSUNBZ2RHaHBjeTV6YkdGemFHVnpJRDBnZEhKMVpUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnBaaUFvSVdodmMzUnNaWE56VUhKdmRHOWpiMnhiY0hKdmRHOWRJQ1ltWEc0Z0lDQWdJQ0FvYzJ4aGMyaGxjeUI4ZkNBb2NISnZkRzhnSmlZZ0lYTnNZWE5vWldSUWNtOTBiMk52YkZ0d2NtOTBiMTBwS1NrZ2UxeHVYRzRnSUNBZ0x5OGdkR2hsY21VbmN5QmhJR2h2YzNSdVlXMWxMbHh1SUNBZ0lDOHZJSFJvWlNCbWFYSnpkQ0JwYm5OMFlXNWpaU0J2WmlBdkxDQS9MQ0E3TENCdmNpQWpJR1Z1WkhNZ2RHaGxJR2h2YzNRdVhHNGdJQ0FnTHk5Y2JpQWdJQ0F2THlCSlppQjBhR1Z5WlNCcGN5QmhiaUJBSUdsdUlIUm9aU0JvYjNOMGJtRnRaU3dnZEdobGJpQnViMjR0YUc5emRDQmphR0Z5Y3lBcVlYSmxLaUJoYkd4dmQyVmtYRzRnSUNBZ0x5OGdkRzhnZEdobElHeGxablFnYjJZZ2RHaGxJR3hoYzNRZ1FDQnphV2R1TENCMWJteGxjM01nYzI5dFpTQm9iM04wTFdWdVpHbHVaeUJqYUdGeVlXTjBaWEpjYmlBZ0lDQXZMeUJqYjIxbGN5QXFZbVZtYjNKbEtpQjBhR1VnUUMxemFXZHVMbHh1SUNBZ0lDOHZJRlZTVEhNZ1lYSmxJRzlpYm05NGFXOTFjeTVjYmlBZ0lDQXZMMXh1SUNBZ0lDOHZJR1Y0T2x4dUlDQWdJQzh2SUdoMGRIQTZMeTloUUdKQVl5OGdQVDRnZFhObGNqcGhRR0lnYUc5emREcGpYRzRnSUNBZ0x5OGdhSFIwY0RvdkwyRkFZajlBWXlBOVBpQjFjMlZ5T21FZ2FHOXpkRHBqSUhCaGRHZzZMejlBWTF4dVhHNGdJQ0FnTHk4Z2RqQXVNVElnVkU5RVR5aHBjMkZoWTNNcE9pQlVhR2x6SUdseklHNXZkQ0J4ZFdsMFpTQm9iM2NnUTJoeWIyMWxJR1J2WlhNZ2RHaHBibWR6TGx4dUlDQWdJQzh2SUZKbGRtbGxkeUJ2ZFhJZ2RHVnpkQ0JqWVhObElHRm5ZV2x1YzNRZ1luSnZkM05sY25NZ2JXOXlaU0JqYjIxd2NtVm9aVzV6YVhabGJIa3VYRzVjYmlBZ0lDQXZMeUJtYVc1a0lIUm9aU0JtYVhKemRDQnBibk4wWVc1alpTQnZaaUJoYm5rZ2FHOXpkRVZ1WkdsdVowTm9ZWEp6WEc0Z0lDQWdkbUZ5SUdodmMzUkZibVFnUFNBdE1UdGNiaUFnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHaHZjM1JGYm1ScGJtZERhR0Z5Y3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdkbUZ5SUdobFl5QTlJSEpsYzNRdWFXNWtaWGhQWmlob2IzTjBSVzVrYVc1blEyaGhjbk5iYVYwcE8xeHVJQ0FnSUNBZ2FXWWdLR2hsWXlBaFBUMGdMVEVnSmlZZ0tHaHZjM1JGYm1RZ1BUMDlJQzB4SUh4OElHaGxZeUE4SUdodmMzUkZibVFwS1Z4dUlDQWdJQ0FnSUNCb2IzTjBSVzVrSUQwZ2FHVmpPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR0YwSUhSb2FYTWdjRzlwYm5Rc0lHVnBkR2hsY2lCM1pTQm9ZWFpsSUdGdUlHVjRjR3hwWTJsMElIQnZhVzUwSUhkb1pYSmxJSFJvWlZ4dUlDQWdJQzh2SUdGMWRHZ2djRzl5ZEdsdmJpQmpZVzV1YjNRZ1oyOGdjR0Z6ZEN3Z2IzSWdkR2hsSUd4aGMzUWdRQ0JqYUdGeUlHbHpJSFJvWlNCa1pXTnBaR1Z5TGx4dUlDQWdJSFpoY2lCaGRYUm9MQ0JoZEZOcFoyNDdYRzRnSUNBZ2FXWWdLR2h2YzNSRmJtUWdQVDA5SUMweEtTQjdYRzRnSUNBZ0lDQXZMeUJoZEZOcFoyNGdZMkZ1SUdKbElHRnVlWGRvWlhKbExseHVJQ0FnSUNBZ1lYUlRhV2R1SUQwZ2NtVnpkQzVzWVhOMFNXNWtaWGhQWmlnblFDY3BPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBdkx5QmhkRk5wWjI0Z2JYVnpkQ0JpWlNCcGJpQmhkWFJvSUhCdmNuUnBiMjR1WEc0Z0lDQWdJQ0F2THlCb2RIUndPaTh2WVVCaUwyTkFaQ0E5UGlCb2IzTjBPbUlnWVhWMGFEcGhJSEJoZEdnNkwyTkFaRnh1SUNBZ0lDQWdZWFJUYVdkdUlEMGdjbVZ6ZEM1c1lYTjBTVzVrWlhoUFppZ25RQ2NzSUdodmMzUkZibVFwTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUU1dmR5QjNaU0JvWVhabElHRWdjRzl5ZEdsdmJpQjNhR2xqYUNCcGN5QmtaV1pwYm1sMFpXeDVJSFJvWlNCaGRYUm9MbHh1SUNBZ0lDOHZJRkIxYkd3Z2RHaGhkQ0J2Wm1ZdVhHNGdJQ0FnYVdZZ0tHRjBVMmxuYmlBaFBUMGdMVEVwSUh0Y2JpQWdJQ0FnSUdGMWRHZ2dQU0J5WlhOMExuTnNhV05sS0RBc0lHRjBVMmxuYmlrN1hHNGdJQ0FnSUNCeVpYTjBJRDBnY21WemRDNXpiR2xqWlNoaGRGTnBaMjRnS3lBeEtUdGNiaUFnSUNBZ0lIUm9hWE11WVhWMGFDQTlJR1JsWTI5a1pWVlNTVU52YlhCdmJtVnVkQ2hoZFhSb0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QjBhR1VnYUc5emRDQnBjeUIwYUdVZ2NtVnRZV2x1YVc1bklIUnZJSFJvWlNCc1pXWjBJRzltSUhSb1pTQm1hWEp6ZENCdWIyNHRhRzl6ZENCamFHRnlYRzRnSUNBZ2FHOXpkRVZ1WkNBOUlDMHhPMXh1SUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dibTl1U0c5emRFTm9ZWEp6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQjJZWElnYUdWaklEMGdjbVZ6ZEM1cGJtUmxlRTltS0c1dmJraHZjM1JEYUdGeWMxdHBYU2s3WEc0Z0lDQWdJQ0JwWmlBb2FHVmpJQ0U5UFNBdE1TQW1KaUFvYUc5emRFVnVaQ0E5UFQwZ0xURWdmSHdnYUdWaklEd2dhRzl6ZEVWdVpDa3BYRzRnSUNBZ0lDQWdJR2h2YzNSRmJtUWdQU0JvWldNN1hHNGdJQ0FnZlZ4dUlDQWdJQzh2SUdsbUlIZGxJSE4wYVd4c0lHaGhkbVVnYm05MElHaHBkQ0JwZEN3Z2RHaGxiaUIwYUdVZ1pXNTBhWEpsSUhSb2FXNW5JR2x6SUdFZ2FHOXpkQzVjYmlBZ0lDQnBaaUFvYUc5emRFVnVaQ0E5UFQwZ0xURXBYRzRnSUNBZ0lDQm9iM04wUlc1a0lEMGdjbVZ6ZEM1c1pXNW5kR2c3WEc1Y2JpQWdJQ0IwYUdsekxtaHZjM1FnUFNCeVpYTjBMbk5zYVdObEtEQXNJR2h2YzNSRmJtUXBPMXh1SUNBZ0lISmxjM1FnUFNCeVpYTjBMbk5zYVdObEtHaHZjM1JGYm1RcE8xeHVYRzRnSUNBZ0x5OGdjSFZzYkNCdmRYUWdjRzl5ZEM1Y2JpQWdJQ0IwYUdsekxuQmhjbk5sU0c5emRDZ3BPMXh1WEc0Z0lDQWdMeThnZDJVbmRtVWdhVzVrYVdOaGRHVmtJSFJvWVhRZ2RHaGxjbVVnYVhNZ1lTQm9iM04wYm1GdFpTeGNiaUFnSUNBdkx5QnpieUJsZG1WdUlHbG1JR2wwSjNNZ1pXMXdkSGtzSUdsMElHaGhjeUIwYnlCaVpTQndjbVZ6Wlc1MExseHVJQ0FnSUhSb2FYTXVhRzl6ZEc1aGJXVWdQU0IwYUdsekxtaHZjM1J1WVcxbElIeDhJQ2NuTzF4dVhHNGdJQ0FnTHk4Z2FXWWdhRzl6ZEc1aGJXVWdZbVZuYVc1eklIZHBkR2dnV3lCaGJtUWdaVzVrY3lCM2FYUm9JRjFjYmlBZ0lDQXZMeUJoYzNOMWJXVWdkR2hoZENCcGRDZHpJR0Z1SUVsUWRqWWdZV1JrY21WemN5NWNiaUFnSUNCMllYSWdhWEIyTmtodmMzUnVZVzFsSUQwZ2RHaHBjeTVvYjNOMGJtRnRaVnN3WFNBOVBUMGdKMXNuSUNZbVhHNGdJQ0FnSUNBZ0lIUm9hWE11YUc5emRHNWhiV1ZiZEdocGN5NW9iM04wYm1GdFpTNXNaVzVuZEdnZ0xTQXhYU0E5UFQwZ0oxMG5PMXh1WEc0Z0lDQWdMeThnZG1Gc2FXUmhkR1VnWVNCc2FYUjBiR1V1WEc0Z0lDQWdhV1lnS0NGcGNIWTJTRzl6ZEc1aGJXVXBJSHRjYmlBZ0lDQWdJSFpoY2lCb2IzTjBjR0Z5ZEhNZ1BTQjBhR2x6TG1odmMzUnVZVzFsTG5Od2JHbDBLQzljWEM0dktUdGNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3TENCc0lEMGdhRzl6ZEhCaGNuUnpMbXhsYm1kMGFEc2dhU0E4SUd3N0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNCMllYSWdjR0Z5ZENBOUlHaHZjM1J3WVhKMGMxdHBYVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRndZWEowS1NCamIyNTBhVzUxWlR0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0Z3WVhKMExtMWhkR05vS0dodmMzUnVZVzFsVUdGeWRGQmhkSFJsY200cEtTQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHNWxkM0JoY25RZ1BTQW5KenRjYmlBZ0lDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcUlEMGdNQ3dnYXlBOUlIQmhjblF1YkdWdVozUm9PeUJxSUR3Z2F6c2dhaXNyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb2NHRnlkQzVqYUdGeVEyOWtaVUYwS0dvcElENGdNVEkzS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUM4dklIZGxJSEpsY0d4aFkyVWdibTl1TFVGVFEwbEpJR05vWVhJZ2QybDBhQ0JoSUhSbGJYQnZjbUZ5ZVNCd2JHRmpaV2h2YkdSbGNseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QjNaU0J1WldWa0lIUm9hWE1nZEc4Z2JXRnJaU0J6ZFhKbElITnBlbVVnYjJZZ2FHOXpkRzVoYldVZ2FYTWdibTkwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQzh2SUdKeWIydGxiaUJpZVNCeVpYQnNZV05wYm1jZ2JtOXVMVUZUUTBsSklHSjVJRzV2ZEdocGJtZGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2JtVjNjR0Z5ZENBclBTQW5lQ2M3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCdVpYZHdZWEowSUNzOUlIQmhjblJiYWwwN1hHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJQzh2SUhkbElIUmxjM1FnWVdkaGFXNGdkMmwwYUNCQlUwTkpTU0JqYUdGeUlHOXViSGxjYmlBZ0lDQWdJQ0FnSUNCcFppQW9JVzVsZDNCaGNuUXViV0YwWTJnb2FHOXpkRzVoYldWUVlYSjBVR0YwZEdWeWJpa3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUIyWVd4cFpGQmhjblJ6SUQwZ2FHOXpkSEJoY25SekxuTnNhV05sS0RBc0lHa3BPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RtRnlJRzV2ZEVodmMzUWdQU0JvYjNOMGNHRnlkSE11YzJ4cFkyVW9hU0FySURFcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlHSnBkQ0E5SUhCaGNuUXViV0YwWTJnb2FHOXpkRzVoYldWUVlYSjBVM1JoY25RcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHSnBkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0IyWVd4cFpGQmhjblJ6TG5CMWMyZ29ZbWwwV3pGZEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2JtOTBTRzl6ZEM1MWJuTm9hV1owS0dKcGRGc3lYU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9ibTkwU0c5emRDNXNaVzVuZEdncElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2NtVnpkQ0E5SUNjdkp5QXJJRzV2ZEVodmMzUXVhbTlwYmlnbkxpY3BJQ3NnY21WemREdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWFHOXpkRzVoYldVZ1BTQjJZV3hwWkZCaGNuUnpMbXB2YVc0b0p5NG5LVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2gwYUdsekxtaHZjM1J1WVcxbExteGxibWQwYUNBK0lHaHZjM1J1WVcxbFRXRjRUR1Z1S1NCN1hHNGdJQ0FnSUNCMGFHbHpMbWh2YzNSdVlXMWxJRDBnSnljN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQzh2SUdodmMzUnVZVzFsY3lCaGNtVWdZV3gzWVhseklHeHZkMlZ5SUdOaGMyVXVYRzRnSUNBZ0lDQjBhR2x6TG1odmMzUnVZVzFsSUQwZ2RHaHBjeTVvYjNOMGJtRnRaUzUwYjB4dmQyVnlRMkZ6WlNncE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDZ2hhWEIyTmtodmMzUnVZVzFsS1NCN1hHNGdJQ0FnSUNBdkx5QkpSRTVCSUZOMWNIQnZjblE2SUZKbGRIVnlibk1nWVNCd2RXNTVZMjlrWldRZ2NtVndjbVZ6Wlc1MFlYUnBiMjRnYjJZZ1hDSmtiMjFoYVc1Y0lpNWNiaUFnSUNBZ0lDOHZJRWwwSUc5dWJIa2dZMjl1ZG1WeWRITWdjR0Z5ZEhNZ2IyWWdkR2hsSUdSdmJXRnBiaUJ1WVcxbElIUm9ZWFJjYmlBZ0lDQWdJQzh2SUdoaGRtVWdibTl1TFVGVFEwbEpJR05vWVhKaFkzUmxjbk1zSUdrdVpTNGdhWFFnWkc5bGMyNG5kQ0J0WVhSMFpYSWdhV1pjYmlBZ0lDQWdJQzh2SUhsdmRTQmpZV3hzSUdsMElIZHBkR2dnWVNCa2IyMWhhVzRnZEdoaGRDQmhiSEpsWVdSNUlHbHpJRUZUUTBsSkxXOXViSGt1WEc0Z0lDQWdJQ0IwYUdsekxtaHZjM1J1WVcxbElEMGdjSFZ1ZVdOdlpHVXVkRzlCVTBOSlNTaDBhR2x6TG1odmMzUnVZVzFsS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0IyWVhJZ2NDQTlJSFJvYVhNdWNHOXlkQ0EvSUNjNkp5QXJJSFJvYVhNdWNHOXlkQ0E2SUNjbk8xeHVJQ0FnSUhaaGNpQm9JRDBnZEdocGN5NW9iM04wYm1GdFpTQjhmQ0FuSnp0Y2JpQWdJQ0IwYUdsekxtaHZjM1FnUFNCb0lDc2djRHRjYmlBZ0lDQjBhR2x6TG1oeVpXWWdLejBnZEdocGN5NW9iM04wTzF4dVhHNGdJQ0FnTHk4Z2MzUnlhWEFnV3lCaGJtUWdYU0JtY205dElIUm9aU0JvYjNOMGJtRnRaVnh1SUNBZ0lDOHZJSFJvWlNCb2IzTjBJR1pwWld4a0lITjBhV3hzSUhKbGRHRnBibk1nZEdobGJTd2dkR2h2ZFdkb1hHNGdJQ0FnYVdZZ0tHbHdkalpJYjNOMGJtRnRaU2tnZTF4dUlDQWdJQ0FnZEdocGN5NW9iM04wYm1GdFpTQTlJSFJvYVhNdWFHOXpkRzVoYldVdWMzVmljM1J5S0RFc0lIUm9hWE11YUc5emRHNWhiV1V1YkdWdVozUm9JQzBnTWlrN1hHNGdJQ0FnSUNCcFppQW9jbVZ6ZEZzd1hTQWhQVDBnSnk4bktTQjdYRzRnSUNBZ0lDQWdJSEpsYzNRZ1BTQW5MeWNnS3lCeVpYTjBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJQzh2SUc1dmR5QnlaWE4wSUdseklITmxkQ0IwYnlCMGFHVWdjRzl6ZEMxb2IzTjBJSE4wZFdabUxseHVJQ0F2THlCamFHOXdJRzltWmlCaGJua2daR1ZzYVcwZ1kyaGhjbk11WEc0Z0lHbG1JQ2doZFc1ellXWmxVSEp2ZEc5amIyeGJiRzkzWlhKUWNtOTBiMTBwSUh0Y2JseHVJQ0FnSUM4dklFWnBjbk4wTENCdFlXdGxJREV3TUNVZ2MzVnlaU0IwYUdGMElHRnVlU0JjSW1GMWRHOUZjMk5oY0dWY0lpQmphR0Z5Y3lCblpYUmNiaUFnSUNBdkx5QmxjMk5oY0dWa0xDQmxkbVZ1SUdsbUlHVnVZMjlrWlZWU1NVTnZiWEJ2Ym1WdWRDQmtiMlZ6YmlkMElIUm9hVzVySUhSb1pYbGNiaUFnSUNBdkx5QnVaV1ZrSUhSdklHSmxMbHh1SUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3TENCc0lEMGdZWFYwYjBWelkyRndaUzVzWlc1bmRHZzdJR2tnUENCc095QnBLeXNwSUh0Y2JpQWdJQ0FnSUhaaGNpQmhaU0E5SUdGMWRHOUZjMk5oY0dWYmFWMDdYRzRnSUNBZ0lDQnBaaUFvY21WemRDNXBibVJsZUU5bUtHRmxLU0E5UFQwZ0xURXBYRzRnSUNBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lDQWdkbUZ5SUdWell5QTlJR1Z1WTI5a1pWVlNTVU52YlhCdmJtVnVkQ2hoWlNrN1hHNGdJQ0FnSUNCcFppQW9aWE5qSUQwOVBTQmhaU2tnZTF4dUlDQWdJQ0FnSUNCbGMyTWdQU0JsYzJOaGNHVW9ZV1VwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnY21WemRDQTlJSEpsYzNRdWMzQnNhWFFvWVdVcExtcHZhVzRvWlhOaktUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dVhHNGdJQzh2SUdOb2IzQWdiMlptSUdaeWIyMGdkR2hsSUhSaGFXd2dabWx5YzNRdVhHNGdJSFpoY2lCb1lYTm9JRDBnY21WemRDNXBibVJsZUU5bUtDY2pKeWs3WEc0Z0lHbG1JQ2hvWVhOb0lDRTlQU0F0TVNrZ2UxeHVJQ0FnSUM4dklHZHZkQ0JoSUdaeVlXZHRaVzUwSUhOMGNtbHVaeTVjYmlBZ0lDQjBhR2x6TG1oaGMyZ2dQU0J5WlhOMExuTjFZbk4wY2lob1lYTm9LVHRjYmlBZ0lDQnlaWE4wSUQwZ2NtVnpkQzV6YkdsalpTZ3dMQ0JvWVhOb0tUdGNiaUFnZlZ4dUlDQjJZWElnY1cwZ1BTQnlaWE4wTG1sdVpHVjRUMllvSno4bktUdGNiaUFnYVdZZ0tIRnRJQ0U5UFNBdE1Ta2dlMXh1SUNBZ0lIUm9hWE11YzJWaGNtTm9JRDBnY21WemRDNXpkV0p6ZEhJb2NXMHBPMXh1SUNBZ0lIUm9hWE11Y1hWbGNua2dQU0J5WlhOMExuTjFZbk4wY2loeGJTQXJJREVwTzF4dUlDQWdJR2xtSUNod1lYSnpaVkYxWlhKNVUzUnlhVzVuS1NCN1hHNGdJQ0FnSUNCMGFHbHpMbkYxWlhKNUlEMGdjWFZsY25semRISnBibWN1Y0dGeWMyVW9kR2hwY3k1eGRXVnllU2s3WEc0Z0lDQWdmVnh1SUNBZ0lISmxjM1FnUFNCeVpYTjBMbk5zYVdObEtEQXNJSEZ0S1R0Y2JpQWdmU0JsYkhObElHbG1JQ2h3WVhKelpWRjFaWEo1VTNSeWFXNW5LU0I3WEc0Z0lDQWdMeThnYm04Z2NYVmxjbmtnYzNSeWFXNW5MQ0JpZFhRZ2NHRnljMlZSZFdWeWVWTjBjbWx1WnlCemRHbHNiQ0J5WlhGMVpYTjBaV1JjYmlBZ0lDQjBhR2x6TG5ObFlYSmphQ0E5SUNjbk8xeHVJQ0FnSUhSb2FYTXVjWFZsY25rZ1BTQjdmVHRjYmlBZ2ZWeHVJQ0JwWmlBb2NtVnpkQ2tnZEdocGN5NXdZWFJvYm1GdFpTQTlJSEpsYzNRN1hHNGdJR2xtSUNoemJHRnphR1ZrVUhKdmRHOWpiMnhiYkc5M1pYSlFjbTkwYjEwZ0ppWmNiaUFnSUNBZ0lIUm9hWE11YUc5emRHNWhiV1VnSmlZZ0lYUm9hWE11Y0dGMGFHNWhiV1VwSUh0Y2JpQWdJQ0IwYUdsekxuQmhkR2h1WVcxbElEMGdKeThuTzF4dUlDQjlYRzVjYmlBZ0x5OTBieUJ6ZFhCd2IzSjBJR2gwZEhBdWNtVnhkV1Z6ZEZ4dUlDQnBaaUFvZEdocGN5NXdZWFJvYm1GdFpTQjhmQ0IwYUdsekxuTmxZWEpqYUNrZ2UxeHVJQ0FnSUhaaGNpQndJRDBnZEdocGN5NXdZWFJvYm1GdFpTQjhmQ0FuSnp0Y2JpQWdJQ0IyWVhJZ2N5QTlJSFJvYVhNdWMyVmhjbU5vSUh4OElDY25PMXh1SUNBZ0lIUm9hWE11Y0dGMGFDQTlJSEFnS3lCek8xeHVJQ0I5WEc1Y2JpQWdMeThnWm1sdVlXeHNlU3dnY21WamIyNXpkSEoxWTNRZ2RHaGxJR2h5WldZZ1ltRnpaV1FnYjI0Z2QyaGhkQ0JvWVhNZ1ltVmxiaUIyWVd4cFpHRjBaV1F1WEc0Z0lIUm9hWE11YUhKbFppQTlJSFJvYVhNdVptOXliV0YwS0NrN1hHNGdJSEpsZEhWeWJpQjBhR2x6TzF4dWZUdGNibHh1THk4Z1ptOXliV0YwSUdFZ2NHRnljMlZrSUc5aWFtVmpkQ0JwYm5SdklHRWdkWEpzSUhOMGNtbHVaMXh1Wm5WdVkzUnBiMjRnZFhKc1JtOXliV0YwS0c5aWFpa2dlMXh1SUNBdkx5Qmxibk4xY21VZ2FYUW5jeUJoYmlCdlltcGxZM1FzSUdGdVpDQnViM1FnWVNCemRISnBibWNnZFhKc0xseHVJQ0F2THlCSlppQnBkQ2R6SUdGdUlHOWlhaXdnZEdocGN5QnBjeUJoSUc1dkxXOXdMbHh1SUNBdkx5QjBhR2x6SUhkaGVTd2dlVzkxSUdOaGJpQmpZV3hzSUhWeWJGOW1iM0p0WVhRb0tTQnZiaUJ6ZEhKcGJtZHpYRzRnSUM4dklIUnZJR05zWldGdUlIVndJSEJ2ZEdWdWRHbGhiR3g1SUhkdmJtdDVJSFZ5YkhNdVhHNGdJR2xtSUNoMWRHbHNMbWx6VTNSeWFXNW5LRzlpYWlrcElHOWlhaUE5SUhWeWJGQmhjbk5sS0c5aWFpazdYRzRnSUdsbUlDZ2hLRzlpYWlCcGJuTjBZVzVqWlc5bUlGVnliQ2twSUhKbGRIVnliaUJWY213dWNISnZkRzkwZVhCbExtWnZjbTFoZEM1allXeHNLRzlpYWlrN1hHNGdJSEpsZEhWeWJpQnZZbW91Wm05eWJXRjBLQ2s3WEc1OVhHNWNibFZ5YkM1d2NtOTBiM1I1Y0dVdVptOXliV0YwSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUhaaGNpQmhkWFJvSUQwZ2RHaHBjeTVoZFhSb0lIeDhJQ2NuTzF4dUlDQnBaaUFvWVhWMGFDa2dlMXh1SUNBZ0lHRjFkR2dnUFNCbGJtTnZaR1ZWVWtsRGIyMXdiMjVsYm5Rb1lYVjBhQ2s3WEc0Z0lDQWdZWFYwYUNBOUlHRjFkR2d1Y21Wd2JHRmpaU2d2SlROQkwya3NJQ2M2SnlrN1hHNGdJQ0FnWVhWMGFDQXJQU0FuUUNjN1hHNGdJSDFjYmx4dUlDQjJZWElnY0hKdmRHOWpiMndnUFNCMGFHbHpMbkJ5YjNSdlkyOXNJSHg4SUNjbkxGeHVJQ0FnSUNBZ2NHRjBhRzVoYldVZ1BTQjBhR2x6TG5CaGRHaHVZVzFsSUh4OElDY25MRnh1SUNBZ0lDQWdhR0Z6YUNBOUlIUm9hWE11YUdGemFDQjhmQ0FuSnl4Y2JpQWdJQ0FnSUdodmMzUWdQU0JtWVd4elpTeGNiaUFnSUNBZ0lIRjFaWEo1SUQwZ0p5YzdYRzVjYmlBZ2FXWWdLSFJvYVhNdWFHOXpkQ2tnZTF4dUlDQWdJR2h2YzNRZ1BTQmhkWFJvSUNzZ2RHaHBjeTVvYjNOME8xeHVJQ0I5SUdWc2MyVWdhV1lnS0hSb2FYTXVhRzl6ZEc1aGJXVXBJSHRjYmlBZ0lDQm9iM04wSUQwZ1lYVjBhQ0FySUNoMGFHbHpMbWh2YzNSdVlXMWxMbWx1WkdWNFQyWW9Kem9uS1NBOVBUMGdMVEVnUDF4dUlDQWdJQ0FnSUNCMGFHbHpMbWh2YzNSdVlXMWxJRHBjYmlBZ0lDQWdJQ0FnSjFzbklDc2dkR2hwY3k1b2IzTjBibUZ0WlNBcklDZGRKeWs3WEc0Z0lDQWdhV1lnS0hSb2FYTXVjRzl5ZENrZ2UxeHVJQ0FnSUNBZ2FHOXpkQ0FyUFNBbk9pY2dLeUIwYUdsekxuQnZjblE3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnYVdZZ0tIUm9hWE11Y1hWbGNua2dKaVpjYmlBZ0lDQWdJSFYwYVd3dWFYTlBZbXBsWTNRb2RHaHBjeTV4ZFdWeWVTa2dKaVpjYmlBZ0lDQWdJRTlpYW1WamRDNXJaWGx6S0hSb2FYTXVjWFZsY25rcExteGxibWQwYUNrZ2UxeHVJQ0FnSUhGMVpYSjVJRDBnY1hWbGNubHpkSEpwYm1jdWMzUnlhVzVuYVdaNUtIUm9hWE11Y1hWbGNua3BPMXh1SUNCOVhHNWNiaUFnZG1GeUlITmxZWEpqYUNBOUlIUm9hWE11YzJWaGNtTm9JSHg4SUNoeGRXVnllU0FtSmlBb0p6OG5JQ3NnY1hWbGNua3BLU0I4ZkNBbkp6dGNibHh1SUNCcFppQW9jSEp2ZEc5amIyd2dKaVlnY0hKdmRHOWpiMnd1YzNWaWMzUnlLQzB4S1NBaFBUMGdKem9uS1NCd2NtOTBiMk52YkNBclBTQW5PaWM3WEc1Y2JpQWdMeThnYjI1c2VTQjBhR1VnYzJ4aGMyaGxaRkJ5YjNSdlkyOXNjeUJuWlhRZ2RHaGxJQzh2TGlBZ1RtOTBJRzFoYVd4MGJ6b3NJSGh0Y0hBNkxDQmxkR011WEc0Z0lDOHZJSFZ1YkdWemN5QjBhR1Y1SUdoaFpDQjBhR1Z0SUhSdklHSmxaMmx1SUhkcGRHZ3VYRzRnSUdsbUlDaDBhR2x6TG5Oc1lYTm9aWE1nZkh4Y2JpQWdJQ0FnSUNnaGNISnZkRzlqYjJ3Z2ZId2djMnhoYzJobFpGQnliM1J2WTI5c1czQnliM1J2WTI5c1hTa2dKaVlnYUc5emRDQWhQVDBnWm1Gc2MyVXBJSHRjYmlBZ0lDQm9iM04wSUQwZ0p5OHZKeUFySUNob2IzTjBJSHg4SUNjbktUdGNiaUFnSUNCcFppQW9jR0YwYUc1aGJXVWdKaVlnY0dGMGFHNWhiV1V1WTJoaGNrRjBLREFwSUNFOVBTQW5MeWNwSUhCaGRHaHVZVzFsSUQwZ0p5OG5JQ3NnY0dGMGFHNWhiV1U3WEc0Z0lIMGdaV3h6WlNCcFppQW9JV2h2YzNRcElIdGNiaUFnSUNCb2IzTjBJRDBnSnljN1hHNGdJSDFjYmx4dUlDQnBaaUFvYUdGemFDQW1KaUJvWVhOb0xtTm9ZWEpCZENnd0tTQWhQVDBnSnlNbktTQm9ZWE5vSUQwZ0p5TW5JQ3NnYUdGemFEdGNiaUFnYVdZZ0tITmxZWEpqYUNBbUppQnpaV0Z5WTJndVkyaGhja0YwS0RBcElDRTlQU0FuUHljcElITmxZWEpqYUNBOUlDYy9KeUFySUhObFlYSmphRHRjYmx4dUlDQndZWFJvYm1GdFpTQTlJSEJoZEdodVlXMWxMbkpsY0d4aFkyVW9MMXMvSTEwdlp5d2dablZ1WTNScGIyNG9iV0YwWTJncElIdGNiaUFnSUNCeVpYUjFjbTRnWlc1amIyUmxWVkpKUTI5dGNHOXVaVzUwS0cxaGRHTm9LVHRjYmlBZ2ZTazdYRzRnSUhObFlYSmphQ0E5SUhObFlYSmphQzV5WlhCc1lXTmxLQ2NqSnl3Z0p5VXlNeWNwTzF4dVhHNGdJSEpsZEhWeWJpQndjbTkwYjJOdmJDQXJJR2h2YzNRZ0t5QndZWFJvYm1GdFpTQXJJSE5sWVhKamFDQXJJR2hoYzJnN1hHNTlPMXh1WEc1bWRXNWpkR2x2YmlCMWNteFNaWE52YkhabEtITnZkWEpqWlN3Z2NtVnNZWFJwZG1VcElIdGNiaUFnY21WMGRYSnVJSFZ5YkZCaGNuTmxLSE52ZFhKalpTd2dabUZzYzJVc0lIUnlkV1VwTG5KbGMyOXNkbVVvY21Wc1lYUnBkbVVwTzF4dWZWeHVYRzVWY213dWNISnZkRzkwZVhCbExuSmxjMjlzZG1VZ1BTQm1kVzVqZEdsdmJpaHlaV3hoZEdsMlpTa2dlMXh1SUNCeVpYUjFjbTRnZEdocGN5NXlaWE52YkhabFQySnFaV04wS0hWeWJGQmhjbk5sS0hKbGJHRjBhWFpsTENCbVlXeHpaU3dnZEhKMVpTa3BMbVp2Y20xaGRDZ3BPMXh1ZlR0Y2JseHVablZ1WTNScGIyNGdkWEpzVW1WemIyeDJaVTlpYW1WamRDaHpiM1Z5WTJVc0lISmxiR0YwYVhabEtTQjdYRzRnSUdsbUlDZ2hjMjkxY21ObEtTQnlaWFIxY200Z2NtVnNZWFJwZG1VN1hHNGdJSEpsZEhWeWJpQjFjbXhRWVhKelpTaHpiM1Z5WTJVc0lHWmhiSE5sTENCMGNuVmxLUzV5WlhOdmJIWmxUMkpxWldOMEtISmxiR0YwYVhabEtUdGNibjFjYmx4dVZYSnNMbkJ5YjNSdmRIbHdaUzV5WlhOdmJIWmxUMkpxWldOMElEMGdablZ1WTNScGIyNG9jbVZzWVhScGRtVXBJSHRjYmlBZ2FXWWdLSFYwYVd3dWFYTlRkSEpwYm1jb2NtVnNZWFJwZG1VcEtTQjdYRzRnSUNBZ2RtRnlJSEpsYkNBOUlHNWxkeUJWY213b0tUdGNiaUFnSUNCeVpXd3VjR0Z5YzJVb2NtVnNZWFJwZG1Vc0lHWmhiSE5sTENCMGNuVmxLVHRjYmlBZ0lDQnlaV3hoZEdsMlpTQTlJSEpsYkR0Y2JpQWdmVnh1WEc0Z0lIWmhjaUJ5WlhOMWJIUWdQU0J1WlhjZ1ZYSnNLQ2s3WEc0Z0lIWmhjaUIwYTJWNWN5QTlJRTlpYW1WamRDNXJaWGx6S0hSb2FYTXBPMXh1SUNCbWIzSWdLSFpoY2lCMGF5QTlJREE3SUhScklEd2dkR3RsZVhNdWJHVnVaM1JvT3lCMGF5c3JLU0I3WEc0Z0lDQWdkbUZ5SUhSclpYa2dQU0IwYTJWNWMxdDBhMTA3WEc0Z0lDQWdjbVZ6ZFd4MFczUnJaWGxkSUQwZ2RHaHBjMXQwYTJWNVhUdGNiaUFnZlZ4dVhHNGdJQzh2SUdoaGMyZ2dhWE1nWVd4M1lYbHpJRzkyWlhKeWFXUmtaVzRzSUc1dklHMWhkSFJsY2lCM2FHRjBMbHh1SUNBdkx5QmxkbVZ1SUdoeVpXWTlYQ0pjSWlCM2FXeHNJSEpsYlc5MlpTQnBkQzVjYmlBZ2NtVnpkV3gwTG1oaGMyZ2dQU0J5Wld4aGRHbDJaUzVvWVhOb08xeHVYRzRnSUM4dklHbG1JSFJvWlNCeVpXeGhkR2wyWlNCMWNtd2dhWE1nWlcxd2RIa3NJSFJvWlc0Z2RHaGxjbVVuY3lCdWIzUm9hVzVuSUd4bFpuUWdkRzhnWkc4Z2FHVnlaUzVjYmlBZ2FXWWdLSEpsYkdGMGFYWmxMbWh5WldZZ1BUMDlJQ2NuS1NCN1hHNGdJQ0FnY21WemRXeDBMbWh5WldZZ1BTQnlaWE4xYkhRdVptOXliV0YwS0NrN1hHNGdJQ0FnY21WMGRYSnVJSEpsYzNWc2REdGNiaUFnZlZ4dVhHNGdJQzh2SUdoeVpXWnpJR3hwYTJVZ0x5OW1iMjh2WW1GeUlHRnNkMkY1Y3lCamRYUWdkRzhnZEdobElIQnliM1J2WTI5c0xseHVJQ0JwWmlBb2NtVnNZWFJwZG1VdWMyeGhjMmhsY3lBbUppQWhjbVZzWVhScGRtVXVjSEp2ZEc5amIyd3BJSHRjYmlBZ0lDQXZMeUIwWVd0bElHVjJaWEo1ZEdocGJtY2daWGhqWlhCMElIUm9aU0J3Y205MGIyTnZiQ0JtY205dElISmxiR0YwYVhabFhHNGdJQ0FnZG1GeUlISnJaWGx6SUQwZ1QySnFaV04wTG10bGVYTW9jbVZzWVhScGRtVXBPMXh1SUNBZ0lHWnZjaUFvZG1GeUlISnJJRDBnTURzZ2Ntc2dQQ0J5YTJWNWN5NXNaVzVuZEdnN0lISnJLeXNwSUh0Y2JpQWdJQ0FnSUhaaGNpQnlhMlY1SUQwZ2NtdGxlWE5iY210ZE8xeHVJQ0FnSUNBZ2FXWWdLSEpyWlhrZ0lUMDlJQ2R3Y205MGIyTnZiQ2NwWEc0Z0lDQWdJQ0FnSUhKbGMzVnNkRnR5YTJWNVhTQTlJSEpsYkdGMGFYWmxXM0pyWlhsZE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dmRYSnNVR0Z5YzJVZ1lYQndaVzVrY3lCMGNtRnBiR2x1WnlBdklIUnZJSFZ5YkhNZ2JHbHJaU0JvZEhSd09pOHZkM2QzTG1WNFlXMXdiR1V1WTI5dFhHNGdJQ0FnYVdZZ0tITnNZWE5vWldSUWNtOTBiMk52YkZ0eVpYTjFiSFF1Y0hKdmRHOWpiMnhkSUNZbVhHNGdJQ0FnSUNBZ0lISmxjM1ZzZEM1b2IzTjBibUZ0WlNBbUppQWhjbVZ6ZFd4MExuQmhkR2h1WVcxbEtTQjdYRzRnSUNBZ0lDQnlaWE4xYkhRdWNHRjBhQ0E5SUhKbGMzVnNkQzV3WVhSb2JtRnRaU0E5SUNjdkp6dGNiaUFnSUNCOVhHNWNiaUFnSUNCeVpYTjFiSFF1YUhKbFppQTlJSEpsYzNWc2RDNW1iM0p0WVhRb0tUdGNiaUFnSUNCeVpYUjFjbTRnY21WemRXeDBPMXh1SUNCOVhHNWNiaUFnYVdZZ0tISmxiR0YwYVhabExuQnliM1J2WTI5c0lDWW1JSEpsYkdGMGFYWmxMbkJ5YjNSdlkyOXNJQ0U5UFNCeVpYTjFiSFF1Y0hKdmRHOWpiMndwSUh0Y2JpQWdJQ0F2THlCcFppQnBkQ2R6SUdFZ2EyNXZkMjRnZFhKc0lIQnliM1J2WTI5c0xDQjBhR1Z1SUdOb1lXNW5hVzVuWEc0Z0lDQWdMeThnZEdobElIQnliM1J2WTI5c0lHUnZaWE1nZDJWcGNtUWdkR2hwYm1kelhHNGdJQ0FnTHk4Z1ptbHljM1FzSUdsbUlHbDBKM01nYm05MElHWnBiR1U2TENCMGFHVnVJSGRsSUUxVlUxUWdhR0YyWlNCaElHaHZjM1FzWEc0Z0lDQWdMeThnWVc1a0lHbG1JSFJvWlhKbElIZGhjeUJoSUhCaGRHaGNiaUFnSUNBdkx5QjBieUJpWldkcGJpQjNhWFJvTENCMGFHVnVJSGRsSUUxVlUxUWdhR0YyWlNCaElIQmhkR2d1WEc0Z0lDQWdMeThnYVdZZ2FYUWdhWE1nWm1sc1pUb3NJSFJvWlc0Z2RHaGxJR2h2YzNRZ2FYTWdaSEp2Y0hCbFpDeGNiaUFnSUNBdkx5QmlaV05oZFhObElIUm9ZWFFuY3lCcmJtOTNiaUIwYnlCaVpTQm9iM04wYkdWemN5NWNiaUFnSUNBdkx5QmhibmwwYUdsdVp5QmxiSE5sSUdseklHRnpjM1Z0WldRZ2RHOGdZbVVnWVdKemIyeDFkR1V1WEc0Z0lDQWdhV1lnS0NGemJHRnphR1ZrVUhKdmRHOWpiMnhiY21Wc1lYUnBkbVV1Y0hKdmRHOWpiMnhkS1NCN1hHNGdJQ0FnSUNCMllYSWdhMlY1Y3lBOUlFOWlhbVZqZEM1clpYbHpLSEpsYkdGMGFYWmxLVHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJSFlnUFNBd095QjJJRHdnYTJWNWN5NXNaVzVuZEdnN0lIWXJLeWtnZTF4dUlDQWdJQ0FnSUNCMllYSWdheUE5SUd0bGVYTmJkbDA3WEc0Z0lDQWdJQ0FnSUhKbGMzVnNkRnRyWFNBOUlISmxiR0YwYVhabFcydGRPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdjbVZ6ZFd4MExtaHlaV1lnUFNCeVpYTjFiSFF1Wm05eWJXRjBLQ2s3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdjbVZ6ZFd4ME8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGMzVnNkQzV3Y205MGIyTnZiQ0E5SUhKbGJHRjBhWFpsTG5CeWIzUnZZMjlzTzF4dUlDQWdJR2xtSUNnaGNtVnNZWFJwZG1VdWFHOXpkQ0FtSmlBaGFHOXpkR3hsYzNOUWNtOTBiMk52YkZ0eVpXeGhkR2wyWlM1d2NtOTBiMk52YkYwcElIdGNiaUFnSUNBZ0lIWmhjaUJ5Wld4UVlYUm9JRDBnS0hKbGJHRjBhWFpsTG5CaGRHaHVZVzFsSUh4OElDY25LUzV6Y0d4cGRDZ25MeWNwTzF4dUlDQWdJQ0FnZDJocGJHVWdLSEpsYkZCaGRHZ3ViR1Z1WjNSb0lDWW1JQ0VvY21Wc1lYUnBkbVV1YUc5emRDQTlJSEpsYkZCaGRHZ3VjMmhwWm5Rb0tTa3BPMXh1SUNBZ0lDQWdhV1lnS0NGeVpXeGhkR2wyWlM1b2IzTjBLU0J5Wld4aGRHbDJaUzVvYjNOMElEMGdKeWM3WEc0Z0lDQWdJQ0JwWmlBb0lYSmxiR0YwYVhabExtaHZjM1J1WVcxbEtTQnlaV3hoZEdsMlpTNW9iM04wYm1GdFpTQTlJQ2NuTzF4dUlDQWdJQ0FnYVdZZ0tISmxiRkJoZEdoYk1GMGdJVDA5SUNjbktTQnlaV3hRWVhSb0xuVnVjMmhwWm5Rb0p5Y3BPMXh1SUNBZ0lDQWdhV1lnS0hKbGJGQmhkR2d1YkdWdVozUm9JRHdnTWlrZ2NtVnNVR0YwYUM1MWJuTm9hV1owS0NjbktUdGNiaUFnSUNBZ0lISmxjM1ZzZEM1d1lYUm9ibUZ0WlNBOUlISmxiRkJoZEdndWFtOXBiaWduTHljcE8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J5WlhOMWJIUXVjR0YwYUc1aGJXVWdQU0J5Wld4aGRHbDJaUzV3WVhSb2JtRnRaVHRjYmlBZ0lDQjlYRzRnSUNBZ2NtVnpkV3gwTG5ObFlYSmphQ0E5SUhKbGJHRjBhWFpsTG5ObFlYSmphRHRjYmlBZ0lDQnlaWE4xYkhRdWNYVmxjbmtnUFNCeVpXeGhkR2wyWlM1eGRXVnllVHRjYmlBZ0lDQnlaWE4xYkhRdWFHOXpkQ0E5SUhKbGJHRjBhWFpsTG1odmMzUWdmSHdnSnljN1hHNGdJQ0FnY21WemRXeDBMbUYxZEdnZ1BTQnlaV3hoZEdsMlpTNWhkWFJvTzF4dUlDQWdJSEpsYzNWc2RDNW9iM04wYm1GdFpTQTlJSEpsYkdGMGFYWmxMbWh2YzNSdVlXMWxJSHg4SUhKbGJHRjBhWFpsTG1odmMzUTdYRzRnSUNBZ2NtVnpkV3gwTG5CdmNuUWdQU0J5Wld4aGRHbDJaUzV3YjNKME8xeHVJQ0FnSUM4dklIUnZJSE4xY0hCdmNuUWdhSFIwY0M1eVpYRjFaWE4wWEc0Z0lDQWdhV1lnS0hKbGMzVnNkQzV3WVhSb2JtRnRaU0I4ZkNCeVpYTjFiSFF1YzJWaGNtTm9LU0I3WEc0Z0lDQWdJQ0IyWVhJZ2NDQTlJSEpsYzNWc2RDNXdZWFJvYm1GdFpTQjhmQ0FuSnp0Y2JpQWdJQ0FnSUhaaGNpQnpJRDBnY21WemRXeDBMbk5sWVhKamFDQjhmQ0FuSnp0Y2JpQWdJQ0FnSUhKbGMzVnNkQzV3WVhSb0lEMGdjQ0FySUhNN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsYzNWc2RDNXpiR0Z6YUdWeklEMGdjbVZ6ZFd4MExuTnNZWE5vWlhNZ2ZId2djbVZzWVhScGRtVXVjMnhoYzJobGN6dGNiaUFnSUNCeVpYTjFiSFF1YUhKbFppQTlJSEpsYzNWc2RDNW1iM0p0WVhRb0tUdGNiaUFnSUNCeVpYUjFjbTRnY21WemRXeDBPMXh1SUNCOVhHNWNiaUFnZG1GeUlHbHpVMjkxY21ObFFXSnpJRDBnS0hKbGMzVnNkQzV3WVhSb2JtRnRaU0FtSmlCeVpYTjFiSFF1Y0dGMGFHNWhiV1V1WTJoaGNrRjBLREFwSUQwOVBTQW5MeWNwTEZ4dUlDQWdJQ0FnYVhOU1pXeEJZbk1nUFNBb1hHNGdJQ0FnSUNBZ0lDQWdjbVZzWVhScGRtVXVhRzl6ZENCOGZGeHVJQ0FnSUNBZ0lDQWdJSEpsYkdGMGFYWmxMbkJoZEdodVlXMWxJQ1ltSUhKbGJHRjBhWFpsTG5CaGRHaHVZVzFsTG1Ob1lYSkJkQ2d3S1NBOVBUMGdKeThuWEc0Z0lDQWdJQ0FwTEZ4dUlDQWdJQ0FnYlhWemRFVnVaRUZpY3lBOUlDaHBjMUpsYkVGaWN5QjhmQ0JwYzFOdmRYSmpaVUZpY3lCOGZGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FvY21WemRXeDBMbWh2YzNRZ0ppWWdjbVZzWVhScGRtVXVjR0YwYUc1aGJXVXBLU3hjYmlBZ0lDQWdJSEpsYlc5MlpVRnNiRVJ2ZEhNZ1BTQnRkWE4wUlc1a1FXSnpMRnh1SUNBZ0lDQWdjM0pqVUdGMGFDQTlJSEpsYzNWc2RDNXdZWFJvYm1GdFpTQW1KaUJ5WlhOMWJIUXVjR0YwYUc1aGJXVXVjM0JzYVhRb0p5OG5LU0I4ZkNCYlhTeGNiaUFnSUNBZ0lISmxiRkJoZEdnZ1BTQnlaV3hoZEdsMlpTNXdZWFJvYm1GdFpTQW1KaUJ5Wld4aGRHbDJaUzV3WVhSb2JtRnRaUzV6Y0d4cGRDZ25MeWNwSUh4OElGdGRMRnh1SUNBZ0lDQWdjSE41WTJodmRHbGpJRDBnY21WemRXeDBMbkJ5YjNSdlkyOXNJQ1ltSUNGemJHRnphR1ZrVUhKdmRHOWpiMnhiY21WemRXeDBMbkJ5YjNSdlkyOXNYVHRjYmx4dUlDQXZMeUJwWmlCMGFHVWdkWEpzSUdseklHRWdibTl1TFhOc1lYTm9aV1FnZFhKc0xDQjBhR1Z1SUhKbGJHRjBhWFpsWEc0Z0lDOHZJR3hwYm10eklHeHBhMlVnTGk0dkxpNGdjMmh2ZFd4a0lHSmxJR0ZpYkdWY2JpQWdMeThnZEc4Z1kzSmhkMndnZFhBZ2RHOGdkR2hsSUdodmMzUnVZVzFsTENCaGN5QjNaV3hzTGlBZ1ZHaHBjeUJwY3lCemRISmhibWRsTGx4dUlDQXZMeUJ5WlhOMWJIUXVjSEp2ZEc5amIyd2dhR0Z6SUdGc2NtVmhaSGtnWW1WbGJpQnpaWFFnWW5rZ2JtOTNMbHh1SUNBdkx5Qk1ZWFJsY2lCdmJpd2djSFYwSUhSb1pTQm1hWEp6ZENCd1lYUm9JSEJoY25RZ2FXNTBieUIwYUdVZ2FHOXpkQ0JtYVdWc1pDNWNiaUFnYVdZZ0tIQnplV05vYjNScFl5a2dlMXh1SUNBZ0lISmxjM1ZzZEM1b2IzTjBibUZ0WlNBOUlDY25PMXh1SUNBZ0lISmxjM1ZzZEM1d2IzSjBJRDBnYm5Wc2JEdGNiaUFnSUNCcFppQW9jbVZ6ZFd4MExtaHZjM1FwSUh0Y2JpQWdJQ0FnSUdsbUlDaHpjbU5RWVhSb1d6QmRJRDA5UFNBbkp5a2djM0pqVUdGMGFGc3dYU0E5SUhKbGMzVnNkQzVvYjNOME8xeHVJQ0FnSUNBZ1pXeHpaU0J6Y21OUVlYUm9MblZ1YzJocFpuUW9jbVZ6ZFd4MExtaHZjM1FwTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWE4xYkhRdWFHOXpkQ0E5SUNjbk8xeHVJQ0FnSUdsbUlDaHlaV3hoZEdsMlpTNXdjbTkwYjJOdmJDa2dlMXh1SUNBZ0lDQWdjbVZzWVhScGRtVXVhRzl6ZEc1aGJXVWdQU0J1ZFd4c08xeHVJQ0FnSUNBZ2NtVnNZWFJwZG1VdWNHOXlkQ0E5SUc1MWJHdzdYRzRnSUNBZ0lDQnBaaUFvY21Wc1lYUnBkbVV1YUc5emRDa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2NtVnNVR0YwYUZzd1hTQTlQVDBnSnljcElISmxiRkJoZEdoYk1GMGdQU0J5Wld4aGRHbDJaUzVvYjNOME8xeHVJQ0FnSUNBZ0lDQmxiSE5sSUhKbGJGQmhkR2d1ZFc1emFHbG1kQ2h5Wld4aGRHbDJaUzVvYjNOMEtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxiR0YwYVhabExtaHZjM1FnUFNCdWRXeHNPMXh1SUNBZ0lIMWNiaUFnSUNCdGRYTjBSVzVrUVdKeklEMGdiWFZ6ZEVWdVpFRmljeUFtSmlBb2NtVnNVR0YwYUZzd1hTQTlQVDBnSnljZ2ZId2djM0pqVUdGMGFGc3dYU0E5UFQwZ0p5Y3BPMXh1SUNCOVhHNWNiaUFnYVdZZ0tHbHpVbVZzUVdKektTQjdYRzRnSUNBZ0x5OGdhWFFuY3lCaFluTnZiSFYwWlM1Y2JpQWdJQ0J5WlhOMWJIUXVhRzl6ZENBOUlDaHlaV3hoZEdsMlpTNW9iM04wSUh4OElISmxiR0YwYVhabExtaHZjM1FnUFQwOUlDY25LU0EvWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpXeGhkR2wyWlM1b2IzTjBJRG9nY21WemRXeDBMbWh2YzNRN1hHNGdJQ0FnY21WemRXeDBMbWh2YzNSdVlXMWxJRDBnS0hKbGJHRjBhWFpsTG1odmMzUnVZVzFsSUh4OElISmxiR0YwYVhabExtaHZjM1J1WVcxbElEMDlQU0FuSnlrZ1AxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGJHRjBhWFpsTG1odmMzUnVZVzFsSURvZ2NtVnpkV3gwTG1odmMzUnVZVzFsTzF4dUlDQWdJSEpsYzNWc2RDNXpaV0Z5WTJnZ1BTQnlaV3hoZEdsMlpTNXpaV0Z5WTJnN1hHNGdJQ0FnY21WemRXeDBMbkYxWlhKNUlEMGdjbVZzWVhScGRtVXVjWFZsY25rN1hHNGdJQ0FnYzNKalVHRjBhQ0E5SUhKbGJGQmhkR2c3WEc0Z0lDQWdMeThnWm1Gc2JDQjBhSEp2ZFdkb0lIUnZJSFJvWlNCa2IzUXRhR0Z1Wkd4cGJtY2dZbVZzYjNjdVhHNGdJSDBnWld4elpTQnBaaUFvY21Wc1VHRjBhQzVzWlc1bmRHZ3BJSHRjYmlBZ0lDQXZMeUJwZENkeklISmxiR0YwYVhabFhHNGdJQ0FnTHk4Z2RHaHliM2NnWVhkaGVTQjBhR1VnWlhocGMzUnBibWNnWm1sc1pTd2dZVzVrSUhSaGEyVWdkR2hsSUc1bGR5QndZWFJvSUdsdWMzUmxZV1F1WEc0Z0lDQWdhV1lnS0NGemNtTlFZWFJvS1NCemNtTlFZWFJvSUQwZ1cxMDdYRzRnSUNBZ2MzSmpVR0YwYUM1d2IzQW9LVHRjYmlBZ0lDQnpjbU5RWVhSb0lEMGdjM0pqVUdGMGFDNWpiMjVqWVhRb2NtVnNVR0YwYUNrN1hHNGdJQ0FnY21WemRXeDBMbk5sWVhKamFDQTlJSEpsYkdGMGFYWmxMbk5sWVhKamFEdGNiaUFnSUNCeVpYTjFiSFF1Y1hWbGNua2dQU0J5Wld4aGRHbDJaUzV4ZFdWeWVUdGNiaUFnZlNCbGJITmxJR2xtSUNnaGRYUnBiQzVwYzA1MWJHeFBjbFZ1WkdWbWFXNWxaQ2h5Wld4aGRHbDJaUzV6WldGeVkyZ3BLU0I3WEc0Z0lDQWdMeThnYW5WemRDQndkV3hzSUc5MWRDQjBhR1VnYzJWaGNtTm9MbHh1SUNBZ0lDOHZJR3hwYTJVZ2FISmxaajBuUDJadmJ5Y3VYRzRnSUNBZ0x5OGdVSFYwSUhSb2FYTWdZV1owWlhJZ2RHaGxJRzkwYUdWeUlIUjNieUJqWVhObGN5QmlaV05oZFhObElHbDBJSE5wYlhCc2FXWnBaWE1nZEdobElHSnZiMnhsWVc1elhHNGdJQ0FnYVdZZ0tIQnplV05vYjNScFl5a2dlMXh1SUNBZ0lDQWdjbVZ6ZFd4MExtaHZjM1J1WVcxbElEMGdjbVZ6ZFd4MExtaHZjM1FnUFNCemNtTlFZWFJvTG5Ob2FXWjBLQ2s3WEc0Z0lDQWdJQ0F2TDI5alkyRjBhVzl1WVd4NUlIUm9aU0JoZFhSb0lHTmhiaUJuWlhRZ2MzUjFZMnNnYjI1c2VTQnBiaUJvYjNOMFhHNGdJQ0FnSUNBdkwzUm9hWE1nWlhOd1pXTnBZV3hzZVNCb1lYQndaVzV6SUdsdUlHTmhjMlZ6SUd4cGEyVmNiaUFnSUNBZ0lDOHZkWEpzTG5KbGMyOXNkbVZQWW1wbFkzUW9KMjFoYVd4MGJ6cHNiMk5oYkRGQVpHOXRZV2x1TVNjc0lDZHNiMk5oYkRKQVpHOXRZV2x1TWljcFhHNGdJQ0FnSUNCMllYSWdZWFYwYUVsdVNHOXpkQ0E5SUhKbGMzVnNkQzVvYjNOMElDWW1JSEpsYzNWc2RDNW9iM04wTG1sdVpHVjRUMllvSjBBbktTQStJREFnUDF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUXVhRzl6ZEM1emNHeHBkQ2duUUNjcElEb2dabUZzYzJVN1hHNGdJQ0FnSUNCcFppQW9ZWFYwYUVsdVNHOXpkQ2tnZTF4dUlDQWdJQ0FnSUNCeVpYTjFiSFF1WVhWMGFDQTlJR0YxZEdoSmJraHZjM1F1YzJocFpuUW9LVHRjYmlBZ0lDQWdJQ0FnY21WemRXeDBMbWh2YzNRZ1BTQnlaWE4xYkhRdWFHOXpkRzVoYldVZ1BTQmhkWFJvU1c1SWIzTjBMbk5vYVdaMEtDazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGMzVnNkQzV6WldGeVkyZ2dQU0J5Wld4aGRHbDJaUzV6WldGeVkyZzdYRzRnSUNBZ2NtVnpkV3gwTG5GMVpYSjVJRDBnY21Wc1lYUnBkbVV1Y1hWbGNuazdYRzRnSUNBZ0x5OTBieUJ6ZFhCd2IzSjBJR2gwZEhBdWNtVnhkV1Z6ZEZ4dUlDQWdJR2xtSUNnaGRYUnBiQzVwYzA1MWJHd29jbVZ6ZFd4MExuQmhkR2h1WVcxbEtTQjhmQ0FoZFhScGJDNXBjMDUxYkd3b2NtVnpkV3gwTG5ObFlYSmphQ2twSUh0Y2JpQWdJQ0FnSUhKbGMzVnNkQzV3WVhSb0lEMGdLSEpsYzNWc2RDNXdZWFJvYm1GdFpTQS9JSEpsYzNWc2RDNXdZWFJvYm1GdFpTQTZJQ2NuS1NBclhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ2h5WlhOMWJIUXVjMlZoY21Ob0lEOGdjbVZ6ZFd4MExuTmxZWEpqYUNBNklDY25LVHRjYmlBZ0lDQjlYRzRnSUNBZ2NtVnpkV3gwTG1oeVpXWWdQU0J5WlhOMWJIUXVabTl5YldGMEtDazdYRzRnSUNBZ2NtVjBkWEp1SUhKbGMzVnNkRHRjYmlBZ2ZWeHVYRzRnSUdsbUlDZ2hjM0pqVUdGMGFDNXNaVzVuZEdncElIdGNiaUFnSUNBdkx5QnVieUJ3WVhSb0lHRjBJR0ZzYkM0Z0lHVmhjM2t1WEc0Z0lDQWdMeThnZDJVbmRtVWdZV3h5WldGa2VTQm9ZVzVrYkdWa0lIUm9aU0J2ZEdobGNpQnpkSFZtWmlCaFltOTJaUzVjYmlBZ0lDQnlaWE4xYkhRdWNHRjBhRzVoYldVZ1BTQnVkV3hzTzF4dUlDQWdJQzh2ZEc4Z2MzVndjRzl5ZENCb2RIUndMbkpsY1hWbGMzUmNiaUFnSUNCcFppQW9jbVZ6ZFd4MExuTmxZWEpqYUNrZ2UxeHVJQ0FnSUNBZ2NtVnpkV3gwTG5CaGRHZ2dQU0FuTHljZ0t5QnlaWE4xYkhRdWMyVmhjbU5vTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWE4xYkhRdWNHRjBhQ0E5SUc1MWJHdzdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGMzVnNkQzVvY21WbUlEMGdjbVZ6ZFd4MExtWnZjbTFoZENncE8xeHVJQ0FnSUhKbGRIVnliaUJ5WlhOMWJIUTdYRzRnSUgxY2JseHVJQ0F2THlCcFppQmhJSFZ5YkNCRlRrUnpJR2x1SUM0Z2IzSWdMaTRzSUhSb1pXNGdhWFFnYlhWemRDQm5aWFFnWVNCMGNtRnBiR2x1WnlCemJHRnphQzVjYmlBZ0x5OGdhRzkzWlhabGNpd2dhV1lnYVhRZ1pXNWtjeUJwYmlCaGJubDBhR2x1WnlCbGJITmxJRzV2YmkxemJHRnphSGtzWEc0Z0lDOHZJSFJvWlc0Z2FYUWdiWFZ6ZENCT1QxUWdaMlYwSUdFZ2RISmhhV3hwYm1jZ2MyeGhjMmd1WEc0Z0lIWmhjaUJzWVhOMElEMGdjM0pqVUdGMGFDNXpiR2xqWlNndE1TbGJNRjA3WEc0Z0lIWmhjaUJvWVhOVWNtRnBiR2x1WjFOc1lYTm9JRDBnS0Z4dUlDQWdJQ0FnS0hKbGMzVnNkQzVvYjNOMElIeDhJSEpsYkdGMGFYWmxMbWh2YzNRZ2ZId2djM0pqVUdGMGFDNXNaVzVuZEdnZ1BpQXhLU0FtSmx4dUlDQWdJQ0FnS0d4aGMzUWdQVDA5SUNjdUp5QjhmQ0JzWVhOMElEMDlQU0FuTGk0bktTQjhmQ0JzWVhOMElEMDlQU0FuSnlrN1hHNWNiaUFnTHk4Z2MzUnlhWEFnYzJsdVoyeGxJR1J2ZEhNc0lISmxjMjlzZG1VZ1pHOTFZbXhsSUdSdmRITWdkRzhnY0dGeVpXNTBJR1JwY2x4dUlDQXZMeUJwWmlCMGFHVWdjR0YwYUNCMGNtbGxjeUIwYnlCbmJ5QmhZbTkyWlNCMGFHVWdjbTl2ZEN3Z1lIVndZQ0JsYm1SeklIVndJRDRnTUZ4dUlDQjJZWElnZFhBZ1BTQXdPMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdjM0pqVUdGMGFDNXNaVzVuZEdnN0lHa2dQajBnTURzZ2FTMHRLU0I3WEc0Z0lDQWdiR0Z6ZENBOUlITnlZMUJoZEdoYmFWMDdYRzRnSUNBZ2FXWWdLR3hoYzNRZ1BUMDlJQ2N1SnlrZ2UxeHVJQ0FnSUNBZ2MzSmpVR0YwYUM1emNHeHBZMlVvYVN3Z01TazdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHNZWE4wSUQwOVBTQW5MaTRuS1NCN1hHNGdJQ0FnSUNCemNtTlFZWFJvTG5Od2JHbGpaU2hwTENBeEtUdGNiaUFnSUNBZ0lIVndLeXM3WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2gxY0NrZ2UxeHVJQ0FnSUNBZ2MzSmpVR0YwYUM1emNHeHBZMlVvYVN3Z01TazdYRzRnSUNBZ0lDQjFjQzB0TzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUM4dklHbG1JSFJvWlNCd1lYUm9JR2x6SUdGc2JHOTNaV1FnZEc4Z1oyOGdZV0p2ZG1VZ2RHaGxJSEp2YjNRc0lISmxjM1J2Y21VZ2JHVmhaR2x1WnlBdUxuTmNiaUFnYVdZZ0tDRnRkWE4wUlc1a1FXSnpJQ1ltSUNGeVpXMXZkbVZCYkd4RWIzUnpLU0I3WEc0Z0lDQWdabTl5SUNnN0lIVndMUzA3SUhWd0tTQjdYRzRnSUNBZ0lDQnpjbU5RWVhSb0xuVnVjMmhwWm5Rb0p5NHVKeWs3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnYVdZZ0tHMTFjM1JGYm1SQlluTWdKaVlnYzNKalVHRjBhRnN3WFNBaFBUMGdKeWNnSmlaY2JpQWdJQ0FnSUNnaGMzSmpVR0YwYUZzd1hTQjhmQ0J6Y21OUVlYUm9XekJkTG1Ob1lYSkJkQ2d3S1NBaFBUMGdKeThuS1NrZ2UxeHVJQ0FnSUhOeVkxQmhkR2d1ZFc1emFHbG1kQ2duSnlrN1hHNGdJSDFjYmx4dUlDQnBaaUFvYUdGelZISmhhV3hwYm1kVGJHRnphQ0FtSmlBb2MzSmpVR0YwYUM1cWIybHVLQ2N2SnlrdWMzVmljM1J5S0MweEtTQWhQVDBnSnk4bktTa2dlMXh1SUNBZ0lITnlZMUJoZEdndWNIVnphQ2duSnlrN1hHNGdJSDFjYmx4dUlDQjJZWElnYVhOQlluTnZiSFYwWlNBOUlITnlZMUJoZEdoYk1GMGdQVDA5SUNjbklIeDhYRzRnSUNBZ0lDQW9jM0pqVUdGMGFGc3dYU0FtSmlCemNtTlFZWFJvV3pCZExtTm9ZWEpCZENnd0tTQTlQVDBnSnk4bktUdGNibHh1SUNBdkx5QndkWFFnZEdobElHaHZjM1FnWW1GamExeHVJQ0JwWmlBb2NITjVZMmh2ZEdsaktTQjdYRzRnSUNBZ2NtVnpkV3gwTG1odmMzUnVZVzFsSUQwZ2NtVnpkV3gwTG1odmMzUWdQU0JwYzBGaWMyOXNkWFJsSUQ4Z0p5Y2dPbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzNKalVHRjBhQzVzWlc1bmRHZ2dQeUJ6Y21OUVlYUm9Mbk5vYVdaMEtDa2dPaUFuSnp0Y2JpQWdJQ0F2TDI5alkyRjBhVzl1WVd4NUlIUm9aU0JoZFhSb0lHTmhiaUJuWlhRZ2MzUjFZMnNnYjI1c2VTQnBiaUJvYjNOMFhHNGdJQ0FnTHk5MGFHbHpJR1Z6Y0dWamFXRnNiSGtnYUdGd2NHVnVjeUJwYmlCallYTmxjeUJzYVd0bFhHNGdJQ0FnTHk5MWNtd3VjbVZ6YjJ4MlpVOWlhbVZqZENnbmJXRnBiSFJ2T214dlkyRnNNVUJrYjIxaGFXNHhKeXdnSjJ4dlkyRnNNa0JrYjIxaGFXNHlKeWxjYmlBZ0lDQjJZWElnWVhWMGFFbHVTRzl6ZENBOUlISmxjM1ZzZEM1b2IzTjBJQ1ltSUhKbGMzVnNkQzVvYjNOMExtbHVaR1Y0VDJZb0owQW5LU0ErSURBZ1AxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBMbWh2YzNRdWMzQnNhWFFvSjBBbktTQTZJR1poYkhObE8xeHVJQ0FnSUdsbUlDaGhkWFJvU1c1SWIzTjBLU0I3WEc0Z0lDQWdJQ0J5WlhOMWJIUXVZWFYwYUNBOUlHRjFkR2hKYmtodmMzUXVjMmhwWm5Rb0tUdGNiaUFnSUNBZ0lISmxjM1ZzZEM1b2IzTjBJRDBnY21WemRXeDBMbWh2YzNSdVlXMWxJRDBnWVhWMGFFbHVTRzl6ZEM1emFHbG1kQ2dwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUcxMWMzUkZibVJCWW5NZ1BTQnRkWE4wUlc1a1FXSnpJSHg4SUNoeVpYTjFiSFF1YUc5emRDQW1KaUJ6Y21OUVlYUm9MbXhsYm1kMGFDazdYRzVjYmlBZ2FXWWdLRzExYzNSRmJtUkJZbk1nSmlZZ0lXbHpRV0p6YjJ4MWRHVXBJSHRjYmlBZ0lDQnpjbU5RWVhSb0xuVnVjMmhwWm5Rb0p5Y3BPMXh1SUNCOVhHNWNiaUFnYVdZZ0tDRnpjbU5RWVhSb0xteGxibWQwYUNrZ2UxeHVJQ0FnSUhKbGMzVnNkQzV3WVhSb2JtRnRaU0E5SUc1MWJHdzdYRzRnSUNBZ2NtVnpkV3gwTG5CaGRHZ2dQU0J1ZFd4c08xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxjM1ZzZEM1d1lYUm9ibUZ0WlNBOUlITnlZMUJoZEdndWFtOXBiaWduTHljcE8xeHVJQ0I5WEc1Y2JpQWdMeTkwYnlCemRYQndiM0owSUhKbGNYVmxjM1F1YUhSMGNGeHVJQ0JwWmlBb0lYVjBhV3d1YVhOT2RXeHNLSEpsYzNWc2RDNXdZWFJvYm1GdFpTa2dmSHdnSVhWMGFXd3VhWE5PZFd4c0tISmxjM1ZzZEM1elpXRnlZMmdwS1NCN1hHNGdJQ0FnY21WemRXeDBMbkJoZEdnZ1BTQW9jbVZ6ZFd4MExuQmhkR2h1WVcxbElEOGdjbVZ6ZFd4MExuQmhkR2h1WVcxbElEb2dKeWNwSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDaHlaWE4xYkhRdWMyVmhjbU5vSUQ4Z2NtVnpkV3gwTG5ObFlYSmphQ0E2SUNjbktUdGNiaUFnZlZ4dUlDQnlaWE4xYkhRdVlYVjBhQ0E5SUhKbGJHRjBhWFpsTG1GMWRHZ2dmSHdnY21WemRXeDBMbUYxZEdnN1hHNGdJSEpsYzNWc2RDNXpiR0Z6YUdWeklEMGdjbVZ6ZFd4MExuTnNZWE5vWlhNZ2ZId2djbVZzWVhScGRtVXVjMnhoYzJobGN6dGNiaUFnY21WemRXeDBMbWh5WldZZ1BTQnlaWE4xYkhRdVptOXliV0YwS0NrN1hHNGdJSEpsZEhWeWJpQnlaWE4xYkhRN1hHNTlPMXh1WEc1VmNtd3VjSEp2ZEc5MGVYQmxMbkJoY25ObFNHOXpkQ0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0IyWVhJZ2FHOXpkQ0E5SUhSb2FYTXVhRzl6ZER0Y2JpQWdkbUZ5SUhCdmNuUWdQU0J3YjNKMFVHRjBkR1Z5Ymk1bGVHVmpLR2h2YzNRcE8xeHVJQ0JwWmlBb2NHOXlkQ2tnZTF4dUlDQWdJSEJ2Y25RZ1BTQndiM0owV3pCZE8xeHVJQ0FnSUdsbUlDaHdiM0owSUNFOVBTQW5PaWNwSUh0Y2JpQWdJQ0FnSUhSb2FYTXVjRzl5ZENBOUlIQnZjblF1YzNWaWMzUnlLREVwTzF4dUlDQWdJSDFjYmlBZ0lDQm9iM04wSUQwZ2FHOXpkQzV6ZFdKemRISW9NQ3dnYUc5emRDNXNaVzVuZEdnZ0xTQndiM0owTG14bGJtZDBhQ2s3WEc0Z0lIMWNiaUFnYVdZZ0tHaHZjM1FwSUhSb2FYTXVhRzl6ZEc1aGJXVWdQU0JvYjNOME8xeHVmVHRjYmlJc0lpZDFjMlVnYzNSeWFXTjBKenRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN1hHNGdJR2x6VTNSeWFXNW5PaUJtZFc1amRHbHZiaWhoY21jcElIdGNiaUFnSUNCeVpYUjFjbTRnZEhsd1pXOW1LR0Z5WnlrZ1BUMDlJQ2R6ZEhKcGJtY25PMXh1SUNCOUxGeHVJQ0JwYzA5aWFtVmpkRG9nWm5WdVkzUnBiMjRvWVhKbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUhSNWNHVnZaaWhoY21jcElEMDlQU0FuYjJKcVpXTjBKeUFtSmlCaGNtY2dJVDA5SUc1MWJHdzdYRzRnSUgwc1hHNGdJR2x6VG5Wc2JEb2dablZ1WTNScGIyNG9ZWEpuS1NCN1hHNGdJQ0FnY21WMGRYSnVJR0Z5WnlBOVBUMGdiblZzYkR0Y2JpQWdmU3hjYmlBZ2FYTk9kV3hzVDNKVmJtUmxabWx1WldRNklHWjFibU4wYVc5dUtHRnlaeWtnZTF4dUlDQWdJSEpsZEhWeWJpQmhjbWNnUFQwZ2JuVnNiRHRjYmlBZ2ZWeHVmVHRjYmlJc0ltMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0Z2FYTkNkV1ptWlhJb1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCaGNtY2dKaVlnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKMjlpYW1WamRDZGNiaUFnSUNBbUppQjBlWEJsYjJZZ1lYSm5MbU52Y0hrZ1BUMDlJQ2RtZFc1amRHbHZiaWRjYmlBZ0lDQW1KaUIwZVhCbGIyWWdZWEpuTG1acGJHd2dQVDA5SUNkbWRXNWpkR2x2YmlkY2JpQWdJQ0FtSmlCMGVYQmxiMllnWVhKbkxuSmxZV1JWU1c1ME9DQTlQVDBnSjJaMWJtTjBhVzl1Snp0Y2JuMGlMQ0l2THlCRGRYSnlaVzUwYkhrZ2FXNGdjM2x1WXlCM2FYUm9JRTV2WkdVdWFuTWdiR2xpTDJsdWRHVnlibUZzTDNWMGFXd3ZkSGx3WlhNdWFuTmNiaTh2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5dWIyUmxhbk12Ym05a1pTOWpiMjF0YVhRdk1URXlZMk0zWXpJM05UVXhNalUwWVdFeVlqRTNNRGs0Wm1JM056UTROamRtTURWbFpEQmtPVnh1WEc0bmRYTmxJSE4wY21samRDYzdYRzVjYm5aaGNpQnBjMEZ5WjNWdFpXNTBjMDlpYW1WamRDQTlJSEpsY1hWcGNtVW9KMmx6TFdGeVozVnRaVzUwY3ljcE8xeHVkbUZ5SUdselIyVnVaWEpoZEc5eVJuVnVZM1JwYjI0Z1BTQnlaWEYxYVhKbEtDZHBjeTFuWlc1bGNtRjBiM0l0Wm5WdVkzUnBiMjRuS1R0Y2JuWmhjaUIzYUdsamFGUjVjR1ZrUVhKeVlYa2dQU0J5WlhGMWFYSmxLQ2QzYUdsamFDMTBlWEJsWkMxaGNuSmhlU2NwTzF4dWRtRnlJR2x6Vkhsd1pXUkJjbkpoZVNBOUlISmxjWFZwY21Vb0oybHpMWFI1Y0dWa0xXRnljbUY1SnlrN1hHNWNibVoxYm1OMGFXOXVJSFZ1WTNWeWNubFVhR2x6S0dZcElIdGNiaUFnY21WMGRYSnVJR1l1WTJGc2JDNWlhVzVrS0dZcE8xeHVmVnh1WEc1MllYSWdRbWxuU1c1MFUzVndjRzl5ZEdWa0lEMGdkSGx3Wlc5bUlFSnBaMGx1ZENBaFBUMGdKM1Z1WkdWbWFXNWxaQ2M3WEc1MllYSWdVM2x0WW05c1UzVndjRzl5ZEdWa0lEMGdkSGx3Wlc5bUlGTjViV0p2YkNBaFBUMGdKM1Z1WkdWbWFXNWxaQ2M3WEc1Y2JuWmhjaUJQWW1wbFkzUlViMU4wY21sdVp5QTlJSFZ1WTNWeWNubFVhR2x6S0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWNwTzF4dVhHNTJZWElnYm5WdFltVnlWbUZzZFdVZ1BTQjFibU4xY25KNVZHaHBjeWhPZFcxaVpYSXVjSEp2ZEc5MGVYQmxMblpoYkhWbFQyWXBPMXh1ZG1GeUlITjBjbWx1WjFaaGJIVmxJRDBnZFc1amRYSnllVlJvYVhNb1UzUnlhVzVuTG5CeWIzUnZkSGx3WlM1MllXeDFaVTltS1R0Y2JuWmhjaUJpYjI5c1pXRnVWbUZzZFdVZ1BTQjFibU4xY25KNVZHaHBjeWhDYjI5c1pXRnVMbkJ5YjNSdmRIbHdaUzUyWVd4MVpVOW1LVHRjYmx4dWFXWWdLRUpwWjBsdWRGTjFjSEJ2Y25SbFpDa2dlMXh1SUNCMllYSWdZbWxuU1c1MFZtRnNkV1VnUFNCMWJtTjFjbko1VkdocGN5aENhV2RKYm5RdWNISnZkRzkwZVhCbExuWmhiSFZsVDJZcE8xeHVmVnh1WEc1cFppQW9VM2x0WW05c1UzVndjRzl5ZEdWa0tTQjdYRzRnSUhaaGNpQnplVzFpYjJ4V1lXeDFaU0E5SUhWdVkzVnljbmxVYUdsektGTjViV0p2YkM1d2NtOTBiM1I1Y0dVdWRtRnNkV1ZQWmlrN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdOb1pXTnJRbTk0WldSUWNtbHRhWFJwZG1Vb2RtRnNkV1VzSUhCeWIzUnZkSGx3WlZaaGJIVmxUMllwSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUIyWVd4MVpTQWhQVDBnSjI5aWFtVmpkQ2NwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJSDFjYmlBZ2RISjVJSHRjYmlBZ0lDQndjbTkwYjNSNWNHVldZV3gxWlU5bUtIWmhiSFZsS1R0Y2JpQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JpQWdmU0JqWVhSamFDaGxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQjlYRzU5WEc1Y2JtVjRjRzl5ZEhNdWFYTkJjbWQxYldWdWRITlBZbXBsWTNRZ1BTQnBjMEZ5WjNWdFpXNTBjMDlpYW1WamREdGNibVY0Y0c5eWRITXVhWE5IWlc1bGNtRjBiM0pHZFc1amRHbHZiaUE5SUdselIyVnVaWEpoZEc5eVJuVnVZM1JwYjI0N1hHNWxlSEJ2Y25SekxtbHpWSGx3WldSQmNuSmhlU0E5SUdselZIbHdaV1JCY25KaGVUdGNibHh1THk4Z1ZHRnJaVzRnWm5KdmJTQm9aWEpsSUdGdVpDQnRiMlJwWm1sbFpDQm1iM0lnWW1WMGRHVnlJR0p5YjNkelpYSWdjM1Z3Y0c5eWRGeHVMeThnYUhSMGNITTZMeTluYVhSb2RXSXVZMjl0TDNOcGJtUnlaWE52Y21oMWN5OXdMV2x6TFhCeWIyMXBjMlV2WW14dllpOWpaR0V6TldFMU1UTmlaR0V3TTJZNU56ZGhaRFZqWkdVellUQTNPV1F5TXpkbE9ESmtOMlZtTDJsdVpHVjRMbXB6WEc1bWRXNWpkR2x2YmlCcGMxQnliMjFwYzJVb2FXNXdkWFFwSUh0Y2JseDBjbVYwZFhKdUlDaGNibHgwWEhRb1hHNWNkRngwWEhSMGVYQmxiMllnVUhKdmJXbHpaU0FoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dKaVpjYmx4MFhIUmNkR2x1Y0hWMElHbHVjM1JoYm1ObGIyWWdVSEp2YldselpWeHVYSFJjZENrZ2ZIeGNibHgwWEhRb1hHNWNkRngwWEhScGJuQjFkQ0FoUFQwZ2JuVnNiQ0FtSmx4dVhIUmNkRngwZEhsd1pXOW1JR2x1Y0hWMElEMDlQU0FuYjJKcVpXTjBKeUFtSmx4dVhIUmNkRngwZEhsd1pXOW1JR2x1Y0hWMExuUm9aVzRnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVpjYmx4MFhIUmNkSFI1Y0dWdlppQnBibkIxZEM1allYUmphQ0E5UFQwZ0oyWjFibU4wYVc5dUoxeHVYSFJjZENsY2JseDBLVHRjYm4xY2JtVjRjRzl5ZEhNdWFYTlFjbTl0YVhObElEMGdhWE5RY205dGFYTmxPMXh1WEc1bWRXNWpkR2x2YmlCcGMwRnljbUY1UW5WbVptVnlWbWxsZHloMllXeDFaU2tnZTF4dUlDQnBaaUFvZEhsd1pXOW1JRUZ5Y21GNVFuVm1abVZ5SUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmlCQmNuSmhlVUoxWm1abGNpNXBjMVpwWlhjcElIdGNiaUFnSUNCeVpYUjFjbTRnUVhKeVlYbENkV1ptWlhJdWFYTldhV1YzS0haaGJIVmxLVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUFvWEc0Z0lDQWdhWE5VZVhCbFpFRnljbUY1S0haaGJIVmxLU0I4ZkZ4dUlDQWdJR2x6UkdGMFlWWnBaWGNvZG1Gc2RXVXBYRzRnSUNrN1hHNTlYRzVsZUhCdmNuUnpMbWx6UVhKeVlYbENkV1ptWlhKV2FXVjNJRDBnYVhOQmNuSmhlVUoxWm1abGNsWnBaWGM3WEc1Y2JseHVablZ1WTNScGIyNGdhWE5WYVc1ME9FRnljbUY1S0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCM2FHbGphRlI1Y0dWa1FYSnlZWGtvZG1Gc2RXVXBJRDA5UFNBblZXbHVkRGhCY25KaGVTYzdYRzU5WEc1bGVIQnZjblJ6TG1selZXbHVkRGhCY25KaGVTQTlJR2x6VldsdWREaEJjbkpoZVR0Y2JseHVablZ1WTNScGIyNGdhWE5WYVc1ME9FTnNZVzF3WldSQmNuSmhlU2gyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnZDJocFkyaFVlWEJsWkVGeWNtRjVLSFpoYkhWbEtTQTlQVDBnSjFWcGJuUTRRMnhoYlhCbFpFRnljbUY1Snp0Y2JuMWNibVY0Y0c5eWRITXVhWE5WYVc1ME9FTnNZVzF3WldSQmNuSmhlU0E5SUdselZXbHVkRGhEYkdGdGNHVmtRWEp5WVhrN1hHNWNibVoxYm1OMGFXOXVJR2x6VldsdWRERTJRWEp5WVhrb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlIZG9hV05vVkhsd1pXUkJjbkpoZVNoMllXeDFaU2tnUFQwOUlDZFZhVzUwTVRaQmNuSmhlU2M3WEc1OVhHNWxlSEJ2Y25SekxtbHpWV2x1ZERFMlFYSnlZWGtnUFNCcGMxVnBiblF4TmtGeWNtRjVPMXh1WEc1bWRXNWpkR2x2YmlCcGMxVnBiblF6TWtGeWNtRjVLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUIzYUdsamFGUjVjR1ZrUVhKeVlYa29kbUZzZFdVcElEMDlQU0FuVldsdWRETXlRWEp5WVhrbk8xeHVmVnh1Wlhod2IzSjBjeTVwYzFWcGJuUXpNa0Z5Y21GNUlEMGdhWE5WYVc1ME16SkJjbkpoZVR0Y2JseHVablZ1WTNScGIyNGdhWE5KYm5RNFFYSnlZWGtvZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUhkb2FXTm9WSGx3WldSQmNuSmhlU2gyWVd4MVpTa2dQVDA5SUNkSmJuUTRRWEp5WVhrbk8xeHVmVnh1Wlhod2IzSjBjeTVwYzBsdWREaEJjbkpoZVNBOUlHbHpTVzUwT0VGeWNtRjVPMXh1WEc1bWRXNWpkR2x2YmlCcGMwbHVkREUyUVhKeVlYa29kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJSGRvYVdOb1ZIbHdaV1JCY25KaGVTaDJZV3gxWlNrZ1BUMDlJQ2RKYm5ReE5rRnljbUY1Snp0Y2JuMWNibVY0Y0c5eWRITXVhWE5KYm5ReE5rRnljbUY1SUQwZ2FYTkpiblF4TmtGeWNtRjVPMXh1WEc1bWRXNWpkR2x2YmlCcGMwbHVkRE15UVhKeVlYa29kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJSGRvYVdOb1ZIbHdaV1JCY25KaGVTaDJZV3gxWlNrZ1BUMDlJQ2RKYm5Rek1rRnljbUY1Snp0Y2JuMWNibVY0Y0c5eWRITXVhWE5KYm5Rek1rRnljbUY1SUQwZ2FYTkpiblF6TWtGeWNtRjVPMXh1WEc1bWRXNWpkR2x2YmlCcGMwWnNiMkYwTXpKQmNuSmhlU2gyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnZDJocFkyaFVlWEJsWkVGeWNtRjVLSFpoYkhWbEtTQTlQVDBnSjBac2IyRjBNekpCY25KaGVTYzdYRzU5WEc1bGVIQnZjblJ6TG1selJteHZZWFF6TWtGeWNtRjVJRDBnYVhOR2JHOWhkRE15UVhKeVlYazdYRzVjYm1aMWJtTjBhVzl1SUdselJteHZZWFEyTkVGeWNtRjVLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUIzYUdsamFGUjVjR1ZrUVhKeVlYa29kbUZzZFdVcElEMDlQU0FuUm14dllYUTJORUZ5Y21GNUp6dGNibjFjYm1WNGNHOXlkSE11YVhOR2JHOWhkRFkwUVhKeVlYa2dQU0JwYzBac2IyRjBOalJCY25KaGVUdGNibHh1Wm5WdVkzUnBiMjRnYVhOQ2FXZEpiblEyTkVGeWNtRjVLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUIzYUdsamFGUjVjR1ZrUVhKeVlYa29kbUZzZFdVcElEMDlQU0FuUW1sblNXNTBOalJCY25KaGVTYzdYRzU5WEc1bGVIQnZjblJ6TG1selFtbG5TVzUwTmpSQmNuSmhlU0E5SUdselFtbG5TVzUwTmpSQmNuSmhlVHRjYmx4dVpuVnVZM1JwYjI0Z2FYTkNhV2RWYVc1ME5qUkJjbkpoZVNoMllXeDFaU2tnZTF4dUlDQnlaWFIxY200Z2QyaHBZMmhVZVhCbFpFRnljbUY1S0haaGJIVmxLU0E5UFQwZ0owSnBaMVZwYm5RMk5FRnljbUY1Snp0Y2JuMWNibVY0Y0c5eWRITXVhWE5DYVdkVmFXNTBOalJCY25KaGVTQTlJR2x6UW1sblZXbHVkRFkwUVhKeVlYazdYRzVjYm1aMWJtTjBhVzl1SUdselRXRndWRzlUZEhKcGJtY29kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJRTlpYW1WamRGUnZVM1J5YVc1bktIWmhiSFZsS1NBOVBUMGdKMXR2WW1wbFkzUWdUV0Z3WFNjN1hHNTlYRzVwYzAxaGNGUnZVM1J5YVc1bkxuZHZjbXRwYm1jZ1BTQW9YRzRnSUhSNWNHVnZaaUJOWVhBZ0lUMDlJQ2QxYm1SbFptbHVaV1FuSUNZbVhHNGdJR2x6VFdGd1ZHOVRkSEpwYm1jb2JtVjNJRTFoY0NncEtWeHVLVHRjYmx4dVpuVnVZM1JwYjI0Z2FYTk5ZWEFvZG1Gc2RXVXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQk5ZWEFnUFQwOUlDZDFibVJsWm1sdVpXUW5LU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdselRXRndWRzlUZEhKcGJtY3VkMjl5YTJsdVoxeHVJQ0FnSUQ4Z2FYTk5ZWEJVYjFOMGNtbHVaeWgyWVd4MVpTbGNiaUFnSUNBNklIWmhiSFZsSUdsdWMzUmhibU5sYjJZZ1RXRndPMXh1ZlZ4dVpYaHdiM0owY3k1cGMwMWhjQ0E5SUdselRXRndPMXh1WEc1bWRXNWpkR2x2YmlCcGMxTmxkRlJ2VTNSeWFXNW5LSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUlViMU4wY21sdVp5aDJZV3gxWlNrZ1BUMDlJQ2RiYjJKcVpXTjBJRk5sZEYwbk8xeHVmVnh1YVhOVFpYUlViMU4wY21sdVp5NTNiM0pyYVc1bklEMGdLRnh1SUNCMGVYQmxiMllnVTJWMElDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUpseHVJQ0JwYzFObGRGUnZVM1J5YVc1bktHNWxkeUJUWlhRb0tTbGNiaWs3WEc1bWRXNWpkR2x2YmlCcGMxTmxkQ2gyWVd4MVpTa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlGTmxkQ0E5UFQwZ0ozVnVaR1ZtYVc1bFpDY3BJSHRjYmlBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnYVhOVFpYUlViMU4wY21sdVp5NTNiM0pyYVc1blhHNGdJQ0FnUHlCcGMxTmxkRlJ2VTNSeWFXNW5LSFpoYkhWbEtWeHVJQ0FnSURvZ2RtRnNkV1VnYVc1emRHRnVZMlZ2WmlCVFpYUTdYRzU5WEc1bGVIQnZjblJ6TG1selUyVjBJRDBnYVhOVFpYUTdYRzVjYm1aMWJtTjBhVzl1SUdselYyVmhhMDFoY0ZSdlUzUnlhVzVuS0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCUFltcGxZM1JVYjFOMGNtbHVaeWgyWVd4MVpTa2dQVDA5SUNkYmIySnFaV04wSUZkbFlXdE5ZWEJkSnp0Y2JuMWNibWx6VjJWaGEwMWhjRlJ2VTNSeWFXNW5MbmR2Y210cGJtY2dQU0FvWEc0Z0lIUjVjR1Z2WmlCWFpXRnJUV0Z3SUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmx4dUlDQnBjMWRsWVd0TllYQlViMU4wY21sdVp5aHVaWGNnVjJWaGEwMWhjQ2dwS1Z4dUtUdGNibVoxYm1OMGFXOXVJR2x6VjJWaGEwMWhjQ2gyWVd4MVpTa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlGZGxZV3ROWVhBZ1BUMDlJQ2QxYm1SbFptbHVaV1FuS1NCN1hHNGdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHbHpWMlZoYTAxaGNGUnZVM1J5YVc1bkxuZHZjbXRwYm1kY2JpQWdJQ0EvSUdselYyVmhhMDFoY0ZSdlUzUnlhVzVuS0haaGJIVmxLVnh1SUNBZ0lEb2dkbUZzZFdVZ2FXNXpkR0Z1WTJWdlppQlhaV0ZyVFdGd08xeHVmVnh1Wlhod2IzSjBjeTVwYzFkbFlXdE5ZWEFnUFNCcGMxZGxZV3ROWVhBN1hHNWNibVoxYm1OMGFXOXVJR2x6VjJWaGExTmxkRlJ2VTNSeWFXNW5LSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUlViMU4wY21sdVp5aDJZV3gxWlNrZ1BUMDlJQ2RiYjJKcVpXTjBJRmRsWVd0VFpYUmRKenRjYm4xY2JtbHpWMlZoYTFObGRGUnZVM1J5YVc1bkxuZHZjbXRwYm1jZ1BTQW9YRzRnSUhSNWNHVnZaaUJYWldGclUyVjBJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KbHh1SUNCcGMxZGxZV3RUWlhSVWIxTjBjbWx1WnlodVpYY2dWMlZoYTFObGRDZ3BLVnh1S1R0Y2JtWjFibU4wYVc5dUlHbHpWMlZoYTFObGRDaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdhWE5YWldGclUyVjBWRzlUZEhKcGJtY29kbUZzZFdVcE8xeHVmVnh1Wlhod2IzSjBjeTVwYzFkbFlXdFRaWFFnUFNCcGMxZGxZV3RUWlhRN1hHNWNibVoxYm1OMGFXOXVJR2x6UVhKeVlYbENkV1ptWlhKVWIxTjBjbWx1WnloMllXeDFaU2tnZTF4dUlDQnlaWFIxY200Z1QySnFaV04wVkc5VGRISnBibWNvZG1Gc2RXVXBJRDA5UFNBblcyOWlhbVZqZENCQmNuSmhlVUoxWm1abGNsMG5PMXh1ZlZ4dWFYTkJjbkpoZVVKMVptWmxjbFJ2VTNSeWFXNW5MbmR2Y210cGJtY2dQU0FvWEc0Z0lIUjVjR1Z2WmlCQmNuSmhlVUoxWm1abGNpQWhQVDBnSjNWdVpHVm1hVzVsWkNjZ0ppWmNiaUFnYVhOQmNuSmhlVUoxWm1abGNsUnZVM1J5YVc1bktHNWxkeUJCY25KaGVVSjFabVpsY2lncEtWeHVLVHRjYm1aMWJtTjBhVzl1SUdselFYSnlZWGxDZFdabVpYSW9kbUZzZFdVcElIdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCQmNuSmhlVUoxWm1abGNpQTlQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdhWE5CY25KaGVVSjFabVpsY2xSdlUzUnlhVzVuTG5kdmNtdHBibWRjYmlBZ0lDQS9JR2x6UVhKeVlYbENkV1ptWlhKVWIxTjBjbWx1WnloMllXeDFaU2xjYmlBZ0lDQTZJSFpoYkhWbElHbHVjM1JoYm1ObGIyWWdRWEp5WVhsQ2RXWm1aWEk3WEc1OVhHNWxlSEJ2Y25SekxtbHpRWEp5WVhsQ2RXWm1aWElnUFNCcGMwRnljbUY1UW5WbVptVnlPMXh1WEc1bWRXNWpkR2x2YmlCcGMwUmhkR0ZXYVdWM1ZHOVRkSEpwYm1jb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlFOWlhbVZqZEZSdlUzUnlhVzVuS0haaGJIVmxLU0E5UFQwZ0oxdHZZbXBsWTNRZ1JHRjBZVlpwWlhkZEp6dGNibjFjYm1selJHRjBZVlpwWlhkVWIxTjBjbWx1Wnk1M2IzSnJhVzVuSUQwZ0tGeHVJQ0IwZVhCbGIyWWdRWEp5WVhsQ2RXWm1aWElnSVQwOUlDZDFibVJsWm1sdVpXUW5JQ1ltWEc0Z0lIUjVjR1Z2WmlCRVlYUmhWbWxsZHlBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NnSmlaY2JpQWdhWE5FWVhSaFZtbGxkMVJ2VTNSeWFXNW5LRzVsZHlCRVlYUmhWbWxsZHlodVpYY2dRWEp5WVhsQ2RXWm1aWElvTVNrc0lEQXNJREVwS1Z4dUtUdGNibVoxYm1OMGFXOXVJR2x6UkdGMFlWWnBaWGNvZG1Gc2RXVXBJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQkVZWFJoVm1sbGR5QTlQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdhWE5FWVhSaFZtbGxkMVJ2VTNSeWFXNW5MbmR2Y210cGJtZGNiaUFnSUNBL0lHbHpSR0YwWVZacFpYZFViMU4wY21sdVp5aDJZV3gxWlNsY2JpQWdJQ0E2SUhaaGJIVmxJR2x1YzNSaGJtTmxiMllnUkdGMFlWWnBaWGM3WEc1OVhHNWxlSEJ2Y25SekxtbHpSR0YwWVZacFpYY2dQU0JwYzBSaGRHRldhV1YzTzF4dVhHNW1kVzVqZEdsdmJpQnBjMU5vWVhKbFpFRnljbUY1UW5WbVptVnlWRzlUZEhKcGJtY29kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJRTlpYW1WamRGUnZVM1J5YVc1bktIWmhiSFZsS1NBOVBUMGdKMXR2WW1wbFkzUWdVMmhoY21Wa1FYSnlZWGxDZFdabVpYSmRKenRjYm4xY2JtbHpVMmhoY21Wa1FYSnlZWGxDZFdabVpYSlViMU4wY21sdVp5NTNiM0pyYVc1bklEMGdLRnh1SUNCMGVYQmxiMllnVTJoaGNtVmtRWEp5WVhsQ2RXWm1aWElnSVQwOUlDZDFibVJsWm1sdVpXUW5JQ1ltWEc0Z0lHbHpVMmhoY21Wa1FYSnlZWGxDZFdabVpYSlViMU4wY21sdVp5aHVaWGNnVTJoaGNtVmtRWEp5WVhsQ2RXWm1aWElvS1NsY2JpazdYRzVtZFc1amRHbHZiaUJwYzFOb1lYSmxaRUZ5Y21GNVFuVm1abVZ5S0haaGJIVmxLU0I3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdVMmhoY21Wa1FYSnlZWGxDZFdabVpYSWdQVDA5SUNkMWJtUmxabWx1WldRbktTQjdYRzRnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR2x6VTJoaGNtVmtRWEp5WVhsQ2RXWm1aWEpVYjFOMGNtbHVaeTUzYjNKcmFXNW5YRzRnSUNBZ1B5QnBjMU5vWVhKbFpFRnljbUY1UW5WbVptVnlWRzlUZEhKcGJtY29kbUZzZFdVcFhHNGdJQ0FnT2lCMllXeDFaU0JwYm5OMFlXNWpaVzltSUZOb1lYSmxaRUZ5Y21GNVFuVm1abVZ5TzF4dWZWeHVaWGh3YjNKMGN5NXBjMU5vWVhKbFpFRnljbUY1UW5WbVptVnlJRDBnYVhOVGFHRnlaV1JCY25KaGVVSjFabVpsY2p0Y2JseHVablZ1WTNScGIyNGdhWE5CYzNsdVkwWjFibU4wYVc5dUtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQlBZbXBsWTNSVWIxTjBjbWx1WnloMllXeDFaU2tnUFQwOUlDZGJiMkpxWldOMElFRnplVzVqUm5WdVkzUnBiMjVkSnp0Y2JuMWNibVY0Y0c5eWRITXVhWE5CYzNsdVkwWjFibU4wYVc5dUlEMGdhWE5CYzNsdVkwWjFibU4wYVc5dU8xeHVYRzVtZFc1amRHbHZiaUJwYzAxaGNFbDBaWEpoZEc5eUtIWmhiSFZsS1NCN1hHNGdJSEpsZEhWeWJpQlBZbXBsWTNSVWIxTjBjbWx1WnloMllXeDFaU2tnUFQwOUlDZGJiMkpxWldOMElFMWhjQ0JKZEdWeVlYUnZjbDBuTzF4dWZWeHVaWGh3YjNKMGN5NXBjMDFoY0VsMFpYSmhkRzl5SUQwZ2FYTk5ZWEJKZEdWeVlYUnZjanRjYmx4dVpuVnVZM1JwYjI0Z2FYTlRaWFJKZEdWeVlYUnZjaWgyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnVDJKcVpXTjBWRzlUZEhKcGJtY29kbUZzZFdVcElEMDlQU0FuVzI5aWFtVmpkQ0JUWlhRZ1NYUmxjbUYwYjNKZEp6dGNibjFjYm1WNGNHOXlkSE11YVhOVFpYUkpkR1Z5WVhSdmNpQTlJR2x6VTJWMFNYUmxjbUYwYjNJN1hHNWNibVoxYm1OMGFXOXVJR2x6UjJWdVpYSmhkRzl5VDJKcVpXTjBLSFpoYkhWbEtTQjdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUlViMU4wY21sdVp5aDJZV3gxWlNrZ1BUMDlJQ2RiYjJKcVpXTjBJRWRsYm1WeVlYUnZjbDBuTzF4dWZWeHVaWGh3YjNKMGN5NXBjMGRsYm1WeVlYUnZjazlpYW1WamRDQTlJR2x6UjJWdVpYSmhkRzl5VDJKcVpXTjBPMXh1WEc1bWRXNWpkR2x2YmlCcGMxZGxZa0Z6YzJWdFlteDVRMjl0Y0dsc1pXUk5iMlIxYkdVb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlFOWlhbVZqZEZSdlUzUnlhVzVuS0haaGJIVmxLU0E5UFQwZ0oxdHZZbXBsWTNRZ1YyVmlRWE56WlcxaWJIa3VUVzlrZFd4bFhTYzdYRzU5WEc1bGVIQnZjblJ6TG1selYyVmlRWE56WlcxaWJIbERiMjF3YVd4bFpFMXZaSFZzWlNBOUlHbHpWMlZpUVhOelpXMWliSGxEYjIxd2FXeGxaRTF2WkhWc1pUdGNibHh1Wm5WdVkzUnBiMjRnYVhOT2RXMWlaWEpQWW1wbFkzUW9kbUZzZFdVcElIdGNiaUFnY21WMGRYSnVJR05vWldOclFtOTRaV1JRY21sdGFYUnBkbVVvZG1Gc2RXVXNJRzUxYldKbGNsWmhiSFZsS1R0Y2JuMWNibVY0Y0c5eWRITXVhWE5PZFcxaVpYSlBZbXBsWTNRZ1BTQnBjMDUxYldKbGNrOWlhbVZqZER0Y2JseHVablZ1WTNScGIyNGdhWE5UZEhKcGJtZFBZbXBsWTNRb2RtRnNkV1VwSUh0Y2JpQWdjbVYwZFhKdUlHTm9aV05yUW05NFpXUlFjbWx0YVhScGRtVW9kbUZzZFdVc0lITjBjbWx1WjFaaGJIVmxLVHRjYm4xY2JtVjRjRzl5ZEhNdWFYTlRkSEpwYm1kUFltcGxZM1FnUFNCcGMxTjBjbWx1WjA5aWFtVmpkRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTkNiMjlzWldGdVQySnFaV04wS0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCamFHVmphMEp2ZUdWa1VISnBiV2wwYVhabEtIWmhiSFZsTENCaWIyOXNaV0Z1Vm1Gc2RXVXBPMXh1ZlZ4dVpYaHdiM0owY3k1cGMwSnZiMnhsWVc1UFltcGxZM1FnUFNCcGMwSnZiMnhsWVc1UFltcGxZM1E3WEc1Y2JtWjFibU4wYVc5dUlHbHpRbWxuU1c1MFQySnFaV04wS0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCQ2FXZEpiblJUZFhCd2IzSjBaV1FnSmlZZ1kyaGxZMnRDYjNobFpGQnlhVzFwZEdsMlpTaDJZV3gxWlN3Z1ltbG5TVzUwVm1Gc2RXVXBPMXh1ZlZ4dVpYaHdiM0owY3k1cGMwSnBaMGx1ZEU5aWFtVmpkQ0E5SUdselFtbG5TVzUwVDJKcVpXTjBPMXh1WEc1bWRXNWpkR2x2YmlCcGMxTjViV0p2YkU5aWFtVmpkQ2gyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnVTNsdFltOXNVM1Z3Y0c5eWRHVmtJQ1ltSUdOb1pXTnJRbTk0WldSUWNtbHRhWFJwZG1Vb2RtRnNkV1VzSUhONWJXSnZiRlpoYkhWbEtUdGNibjFjYm1WNGNHOXlkSE11YVhOVGVXMWliMnhQWW1wbFkzUWdQU0JwYzFONWJXSnZiRTlpYW1WamREdGNibHh1Wm5WdVkzUnBiMjRnYVhOQ2IzaGxaRkJ5YVcxcGRHbDJaU2gyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnS0Z4dUlDQWdJR2x6VG5WdFltVnlUMkpxWldOMEtIWmhiSFZsS1NCOGZGeHVJQ0FnSUdselUzUnlhVzVuVDJKcVpXTjBLSFpoYkhWbEtTQjhmRnh1SUNBZ0lHbHpRbTl2YkdWaGJrOWlhbVZqZENoMllXeDFaU2tnZkh4Y2JpQWdJQ0JwYzBKcFowbHVkRTlpYW1WamRDaDJZV3gxWlNrZ2ZIeGNiaUFnSUNCcGMxTjViV0p2YkU5aWFtVmpkQ2gyWVd4MVpTbGNiaUFnS1R0Y2JuMWNibVY0Y0c5eWRITXVhWE5DYjNobFpGQnlhVzFwZEdsMlpTQTlJR2x6UW05NFpXUlFjbWx0YVhScGRtVTdYRzVjYm1aMWJtTjBhVzl1SUdselFXNTVRWEp5WVhsQ2RXWm1aWElvZG1Gc2RXVXBJSHRjYmlBZ2NtVjBkWEp1SUhSNWNHVnZaaUJWYVc1ME9FRnljbUY1SUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmlBb1hHNGdJQ0FnYVhOQmNuSmhlVUoxWm1abGNpaDJZV3gxWlNrZ2ZIeGNiaUFnSUNCcGMxTm9ZWEpsWkVGeWNtRjVRblZtWm1WeUtIWmhiSFZsS1Z4dUlDQXBPMXh1ZlZ4dVpYaHdiM0owY3k1cGMwRnVlVUZ5Y21GNVFuVm1abVZ5SUQwZ2FYTkJibmxCY25KaGVVSjFabVpsY2p0Y2JseHVXeWRwYzFCeWIzaDVKeXdnSjJselJYaDBaWEp1WVd3bkxDQW5hWE5OYjJSMWJHVk9ZVzFsYzNCaFkyVlBZbXBsWTNRblhTNW1iM0pGWVdOb0tHWjFibU4wYVc5dUtHMWxkR2h2WkNrZ2UxeHVJQ0JQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1pYaHdiM0owY3l3Z2JXVjBhRzlrTENCN1hHNGdJQ0FnWlc1MWJXVnlZV0pzWlRvZ1ptRnNjMlVzWEc0Z0lDQWdkbUZzZFdVNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtHMWxkR2h2WkNBcklDY2dhWE1nYm05MElITjFjSEJ2Y25SbFpDQnBiaUIxYzJWeWJHRnVaQ2NwTzF4dUlDQWdJSDFjYmlBZ2ZTazdYRzU5S1R0Y2JpSXNJaTh2SUVOdmNIbHlhV2RvZENCS2IzbGxiblFzSUVsdVl5NGdZVzVrSUc5MGFHVnlJRTV2WkdVZ1kyOXVkSEpwWW5WMGIzSnpMbHh1THk5Y2JpOHZJRkJsY20xcGMzTnBiMjRnYVhNZ2FHVnlaV0o1SUdkeVlXNTBaV1FzSUdaeVpXVWdiMllnWTJoaGNtZGxMQ0IwYnlCaGJua2djR1Z5YzI5dUlHOWlkR0ZwYm1sdVp5QmhYRzR2THlCamIzQjVJRzltSUhSb2FYTWdjMjltZEhkaGNtVWdZVzVrSUdGemMyOWphV0YwWldRZ1pHOWpkVzFsYm5SaGRHbHZiaUJtYVd4bGN5QW9kR2hsWEc0dkx5QmNJbE52Wm5SM1lYSmxYQ0lwTENCMGJ5QmtaV0ZzSUdsdUlIUm9aU0JUYjJaMGQyRnlaU0IzYVhSb2IzVjBJSEpsYzNSeWFXTjBhVzl1TENCcGJtTnNkV1JwYm1kY2JpOHZJSGRwZEdodmRYUWdiR2x0YVhSaGRHbHZiaUIwYUdVZ2NtbG5hSFJ6SUhSdklIVnpaU3dnWTI5d2VTd2diVzlrYVdaNUxDQnRaWEpuWlN3Z2NIVmliR2x6YUN4Y2JpOHZJR1JwYzNSeWFXSjFkR1VzSUhOMVlteHBZMlZ1YzJVc0lHRnVaQzl2Y2lCelpXeHNJR052Y0dsbGN5QnZaaUIwYUdVZ1UyOW1kSGRoY21Vc0lHRnVaQ0IwYnlCd1pYSnRhWFJjYmk4dklIQmxjbk52Ym5NZ2RHOGdkMmh2YlNCMGFHVWdVMjltZEhkaGNtVWdhWE1nWm5WeWJtbHphR1ZrSUhSdklHUnZJSE52TENCemRXSnFaV04wSUhSdklIUm9aVnh1THk4Z1ptOXNiRzkzYVc1bklHTnZibVJwZEdsdmJuTTZYRzR2TDF4dUx5OGdWR2hsSUdGaWIzWmxJR052Y0hseWFXZG9kQ0J1YjNScFkyVWdZVzVrSUhSb2FYTWdjR1Z5YldsemMybHZiaUJ1YjNScFkyVWdjMmhoYkd3Z1ltVWdhVzVqYkhWa1pXUmNiaTh2SUdsdUlHRnNiQ0JqYjNCcFpYTWdiM0lnYzNWaWMzUmhiblJwWVd3Z2NHOXlkR2x2Ym5NZ2IyWWdkR2hsSUZOdlpuUjNZWEpsTGx4dUx5OWNiaTh2SUZSSVJTQlRUMFpVVjBGU1JTQkpVeUJRVWs5V1NVUkZSQ0JjSWtGVElFbFRYQ0lzSUZkSlZFaFBWVlFnVjBGU1VrRk9WRmtnVDBZZ1FVNVpJRXRKVGtRc0lFVllVRkpGVTFOY2JpOHZJRTlTSUVsTlVFeEpSVVFzSUVsT1EweFZSRWxPUnlCQ1ZWUWdUazlVSUV4SlRVbFVSVVFnVkU4Z1ZFaEZJRmRCVWxKQlRsUkpSVk1nVDBaY2JpOHZJRTFGVWtOSVFVNVVRVUpKVEVsVVdTd2dSa2xVVGtWVFV5QkdUMUlnUVNCUVFWSlVTVU5WVEVGU0lGQlZVbEJQVTBVZ1FVNUVJRTVQVGtsT1JsSkpUa2RGVFVWT1ZDNGdTVTVjYmk4dklFNVBJRVZXUlU1VUlGTklRVXhNSUZSSVJTQkJWVlJJVDFKVElFOVNJRU5QVUZsU1NVZElWQ0JJVDB4RVJWSlRJRUpGSUV4SlFVSk1SU0JHVDFJZ1FVNVpJRU5NUVVsTkxGeHVMeThnUkVGTlFVZEZVeUJQVWlCUFZFaEZVaUJNU1VGQ1NVeEpWRmtzSUZkSVJWUklSVklnU1U0Z1FVNGdRVU5VU1U5T0lFOUdJRU5QVGxSU1FVTlVMQ0JVVDFKVUlFOVNYRzR2THlCUFZFaEZVbGRKVTBVc0lFRlNTVk5KVGtjZ1JsSlBUU3dnVDFWVUlFOUdJRTlTSUVsT0lFTlBUazVGUTFSSlQwNGdWMGxVU0NCVVNFVWdVMDlHVkZkQlVrVWdUMUlnVkVoRlhHNHZMeUJWVTBVZ1QxSWdUMVJJUlZJZ1JFVkJURWxPUjFNZ1NVNGdWRWhGSUZOUFJsUlhRVkpGTGx4dVhHNTJZWElnWjJWMFQzZHVVSEp2Y0dWeWRIbEVaWE5qY21sd2RHOXljeUE5SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVUmxjMk55YVhCMGIzSnpJSHg4WEc0Z0lHWjFibU4wYVc5dUlHZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y25Nb2IySnFLU0I3WEc0Z0lDQWdkbUZ5SUd0bGVYTWdQU0JQWW1wbFkzUXVhMlY1Y3lodlltb3BPMXh1SUNBZ0lIWmhjaUJrWlhOamNtbHdkRzl5Y3lBOUlIdDlPMXh1SUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dhMlY1Y3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdaR1Z6WTNKcGNIUnZjbk5iYTJWNWMxdHBYVjBnUFNCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbEVaWE5qY21sd2RHOXlLRzlpYWl3Z2EyVjVjMXRwWFNrN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQmtaWE5qY21sd2RHOXljenRjYmlBZ2ZUdGNibHh1ZG1GeUlHWnZjbTFoZEZKbFowVjRjQ0E5SUM4bFczTmthaVZkTDJjN1hHNWxlSEJ2Y25SekxtWnZjbTFoZENBOUlHWjFibU4wYVc5dUtHWXBJSHRjYmlBZ2FXWWdLQ0ZwYzFOMGNtbHVaeWhtS1NrZ2UxeHVJQ0FnSUhaaGNpQnZZbXBsWTNSeklEMGdXMTA3WEc0Z0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JoY21kMWJXVnVkSE11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lHOWlhbVZqZEhNdWNIVnphQ2hwYm5Od1pXTjBLR0Z5WjNWdFpXNTBjMXRwWFNrcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdiMkpxWldOMGN5NXFiMmx1S0NjZ0p5azdYRzRnSUgxY2JseHVJQ0IyWVhJZ2FTQTlJREU3WEc0Z0lIWmhjaUJoY21keklEMGdZWEpuZFcxbGJuUnpPMXh1SUNCMllYSWdiR1Z1SUQwZ1lYSm5jeTVzWlc1bmRHZzdYRzRnSUhaaGNpQnpkSElnUFNCVGRISnBibWNvWmlrdWNtVndiR0ZqWlNobWIzSnRZWFJTWldkRmVIQXNJR1oxYm1OMGFXOXVLSGdwSUh0Y2JpQWdJQ0JwWmlBb2VDQTlQVDBnSnlVbEp5a2djbVYwZFhKdUlDY2xKenRjYmlBZ0lDQnBaaUFvYVNBK1BTQnNaVzRwSUhKbGRIVnliaUI0TzF4dUlDQWdJSE4zYVhSamFDQW9lQ2tnZTF4dUlDQWdJQ0FnWTJGelpTQW5KWE1uT2lCeVpYUjFjbTRnVTNSeWFXNW5LR0Z5WjNOYmFTc3JYU2s3WEc0Z0lDQWdJQ0JqWVhObElDY2xaQ2M2SUhKbGRIVnliaUJPZFcxaVpYSW9ZWEpuYzF0cEt5dGRLVHRjYmlBZ0lDQWdJR05oYzJVZ0p5VnFKenBjYmlBZ0lDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdTbE5QVGk1emRISnBibWRwWm5rb1lYSm5jMXRwS3l0ZEtUdGNiaUFnSUNBZ0lDQWdmU0JqWVhSamFDQW9YeWtnZTF4dUlDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlBblcwTnBjbU4xYkdGeVhTYzdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJR1JsWm1GMWJIUTZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjRPMXh1SUNBZ0lIMWNiaUFnZlNrN1hHNGdJR1p2Y2lBb2RtRnlJSGdnUFNCaGNtZHpXMmxkT3lCcElEd2diR1Z1T3lCNElEMGdZWEpuYzFzcksybGRLU0I3WEc0Z0lDQWdhV1lnS0dselRuVnNiQ2g0S1NCOGZDQWhhWE5QWW1wbFkzUW9lQ2twSUh0Y2JpQWdJQ0FnSUhOMGNpQXJQU0FuSUNjZ0t5QjRPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCemRISWdLejBnSnlBbklDc2dhVzV6Y0dWamRDaDRLVHRjYmlBZ0lDQjlYRzRnSUgxY2JpQWdjbVYwZFhKdUlITjBjanRjYm4wN1hHNWNibHh1THk4Z1RXRnlheUIwYUdGMElHRWdiV1YwYUc5a0lITm9iM1ZzWkNCdWIzUWdZbVVnZFhObFpDNWNiaTh2SUZKbGRIVnlibk1nWVNCdGIyUnBabWxsWkNCbWRXNWpkR2x2YmlCM2FHbGphQ0IzWVhKdWN5QnZibU5sSUdKNUlHUmxabUYxYkhRdVhHNHZMeUJKWmlBdExXNXZMV1JsY0hKbFkyRjBhVzl1SUdseklITmxkQ3dnZEdobGJpQnBkQ0JwY3lCaElHNXZMVzl3TGx4dVpYaHdiM0owY3k1a1pYQnlaV05oZEdVZ1BTQm1kVzVqZEdsdmJpaG1iaXdnYlhObktTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2NISnZZMlZ6Y3lBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NnSmlZZ2NISnZZMlZ6Y3k1dWIwUmxjSEpsWTJGMGFXOXVJRDA5UFNCMGNuVmxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWnVPMXh1SUNCOVhHNWNiaUFnTHk4Z1FXeHNiM2NnWm05eUlHUmxjSEpsWTJGMGFXNW5JSFJvYVc1bmN5QnBiaUIwYUdVZ2NISnZZMlZ6Y3lCdlppQnpkR0Z5ZEdsdVp5QjFjQzVjYmlBZ2FXWWdLSFI1Y0dWdlppQndjbTlqWlhOeklEMDlQU0FuZFc1a1pXWnBibVZrSnlrZ2UxeHVJQ0FnSUhKbGRIVnliaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJsZUhCdmNuUnpMbVJsY0hKbFkyRjBaU2htYml3Z2JYTm5LUzVoY0hCc2VTaDBhR2x6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUgwN1hHNGdJSDFjYmx4dUlDQjJZWElnZDJGeWJtVmtJRDBnWm1Gc2MyVTdYRzRnSUdaMWJtTjBhVzl1SUdSbGNISmxZMkYwWldRb0tTQjdYRzRnSUNBZ2FXWWdLQ0YzWVhKdVpXUXBJSHRjYmlBZ0lDQWdJR2xtSUNod2NtOWpaWE56TG5Sb2NtOTNSR1Z3Y21WallYUnBiMjRwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0cxelp5azdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSEJ5YjJObGMzTXVkSEpoWTJWRVpYQnlaV05oZEdsdmJpa2dlMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMblJ5WVdObEtHMXpaeWs3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMbVZ5Y205eUtHMXpaeWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0IzWVhKdVpXUWdQU0IwY25WbE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdabTR1WVhCd2JIa29kR2hwY3l3Z1lYSm5kVzFsYm5SektUdGNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQmtaWEJ5WldOaGRHVmtPMXh1ZlR0Y2JseHVYRzUyWVhJZ1pHVmlkV2R6SUQwZ2UzMDdYRzUyWVhJZ1pHVmlkV2RGYm5aU1pXZGxlQ0E5SUM5ZUpDODdYRzVjYm1sbUlDaHdjbTlqWlhOekxtVnVkaTVPVDBSRlgwUkZRbFZIS1NCN1hHNGdJSFpoY2lCa1pXSjFaMFZ1ZGlBOUlIQnliMk5sYzNNdVpXNTJMazVQUkVWZlJFVkNWVWM3WEc0Z0lHUmxZblZuUlc1MklEMGdaR1ZpZFdkRmJuWXVjbVZ3YkdGalpTZ3ZXM3hjWEZ4Y2UzMG9LVnRjWEYxZUpDcy9MbDB2Wnl3Z0oxeGNYRndrSmljcFhHNGdJQ0FnTG5KbGNHeGhZMlVvTDF4Y0tpOW5MQ0FuTGlvbktWeHVJQ0FnSUM1eVpYQnNZV05sS0M4c0wyY3NJQ2NrZkY0bktWeHVJQ0FnSUM1MGIxVndjR1Z5UTJGelpTZ3BPMXh1SUNCa1pXSjFaMFZ1ZGxKbFoyVjRJRDBnYm1WM0lGSmxaMFY0Y0NnblhpY2dLeUJrWldKMVowVnVkaUFySUNja0p5d2dKMmtuS1R0Y2JuMWNibVY0Y0c5eWRITXVaR1ZpZFdkc2IyY2dQU0JtZFc1amRHbHZiaWh6WlhRcElIdGNiaUFnYzJWMElEMGdjMlYwTG5SdlZYQndaWEpEWVhObEtDazdYRzRnSUdsbUlDZ2haR1ZpZFdkelczTmxkRjBwSUh0Y2JpQWdJQ0JwWmlBb1pHVmlkV2RGYm5aU1pXZGxlQzUwWlhOMEtITmxkQ2twSUh0Y2JpQWdJQ0FnSUhaaGNpQndhV1FnUFNCd2NtOWpaWE56TG5CcFpEdGNiaUFnSUNBZ0lHUmxZblZuYzF0elpYUmRJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJ0YzJjZ1BTQmxlSEJ2Y25SekxtWnZjbTFoZEM1aGNIQnNlU2hsZUhCdmNuUnpMQ0JoY21kMWJXVnVkSE1wTzF4dUlDQWdJQ0FnSUNCamIyNXpiMnhsTG1WeWNtOXlLQ2NsY3lBbFpEb2dKWE1uTENCelpYUXNJSEJwWkN3Z2JYTm5LVHRjYmlBZ0lDQWdJSDA3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHUmxZblZuYzF0elpYUmRJRDBnWm5WdVkzUnBiMjRvS1NCN2ZUdGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUdSbFluVm5jMXR6WlhSZE8xeHVmVHRjYmx4dVhHNHZLaXBjYmlBcUlFVmphRzl6SUhSb1pTQjJZV3gxWlNCdlppQmhJSFpoYkhWbExpQlVjbmx6SUhSdklIQnlhVzUwSUhSb1pTQjJZV3gxWlNCdmRYUmNiaUFxSUdsdUlIUm9aU0JpWlhOMElIZGhlU0J3YjNOemFXSnNaU0JuYVhabGJpQjBhR1VnWkdsbVptVnlaVzUwSUhSNWNHVnpMbHh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdUMkpxWldOMGZTQnZZbW9nVkdobElHOWlhbVZqZENCMGJ5QndjbWx1ZENCdmRYUXVYRzRnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnYjNCMGN5QlBjSFJwYjI1aGJDQnZjSFJwYjI1eklHOWlhbVZqZENCMGFHRjBJR0ZzZEdWeWN5QjBhR1VnYjNWMGNIVjBMbHh1SUNvdlhHNHZLaUJzWldkaFkzazZJRzlpYWl3Z2MyaHZkMGhwWkdSbGJpd2daR1Z3ZEdnc0lHTnZiRzl5Y3lvdlhHNW1kVzVqZEdsdmJpQnBibk53WldOMEtHOWlhaXdnYjNCMGN5a2dlMXh1SUNBdkx5QmtaV1poZFd4MElHOXdkR2x2Ym5OY2JpQWdkbUZ5SUdOMGVDQTlJSHRjYmlBZ0lDQnpaV1Z1T2lCYlhTeGNiaUFnSUNCemRIbHNhWHBsT2lCemRIbHNhWHBsVG05RGIyeHZjbHh1SUNCOU8xeHVJQ0F2THlCc1pXZGhZM2t1TGk1Y2JpQWdhV1lnS0dGeVozVnRaVzUwY3k1c1pXNW5kR2dnUGowZ015a2dZM1I0TG1SbGNIUm9JRDBnWVhKbmRXMWxiblJ6V3pKZE8xeHVJQ0JwWmlBb1lYSm5kVzFsYm5SekxteGxibWQwYUNBK1BTQTBLU0JqZEhndVkyOXNiM0p6SUQwZ1lYSm5kVzFsYm5Seld6TmRPMXh1SUNCcFppQW9hWE5DYjI5c1pXRnVLRzl3ZEhNcEtTQjdYRzRnSUNBZ0x5OGdiR1ZuWVdONUxpNHVYRzRnSUNBZ1kzUjRMbk5vYjNkSWFXUmtaVzRnUFNCdmNIUnpPMXh1SUNCOUlHVnNjMlVnYVdZZ0tHOXdkSE1wSUh0Y2JpQWdJQ0F2THlCbmIzUWdZVzRnWENKdmNIUnBiMjV6WENJZ2IySnFaV04wWEc0Z0lDQWdaWGh3YjNKMGN5NWZaWGgwWlc1a0tHTjBlQ3dnYjNCMGN5azdYRzRnSUgxY2JpQWdMeThnYzJWMElHUmxabUYxYkhRZ2IzQjBhVzl1YzF4dUlDQnBaaUFvYVhOVmJtUmxabWx1WldRb1kzUjRMbk5vYjNkSWFXUmtaVzRwS1NCamRIZ3VjMmh2ZDBocFpHUmxiaUE5SUdaaGJITmxPMXh1SUNCcFppQW9hWE5WYm1SbFptbHVaV1FvWTNSNExtUmxjSFJvS1NrZ1kzUjRMbVJsY0hSb0lEMGdNanRjYmlBZ2FXWWdLR2x6Vlc1a1pXWnBibVZrS0dOMGVDNWpiMnh2Y25NcEtTQmpkSGd1WTI5c2IzSnpJRDBnWm1Gc2MyVTdYRzRnSUdsbUlDaHBjMVZ1WkdWbWFXNWxaQ2hqZEhndVkzVnpkRzl0U1c1emNHVmpkQ2twSUdOMGVDNWpkWE4wYjIxSmJuTndaV04wSUQwZ2RISjFaVHRjYmlBZ2FXWWdLR04wZUM1amIyeHZjbk1wSUdOMGVDNXpkSGxzYVhwbElEMGdjM1I1YkdsNlpWZHBkR2hEYjJ4dmNqdGNiaUFnY21WMGRYSnVJR1p2Y20xaGRGWmhiSFZsS0dOMGVDd2diMkpxTENCamRIZ3VaR1Z3ZEdncE8xeHVmVnh1Wlhod2IzSjBjeTVwYm5Od1pXTjBJRDBnYVc1emNHVmpkRHRjYmx4dVhHNHZMeUJvZEhSd09pOHZaVzR1ZDJscmFYQmxaR2xoTG05eVp5OTNhV3RwTDBGT1UwbGZaWE5qWVhCbFgyTnZaR1VqWjNKaGNHaHBZM05jYm1sdWMzQmxZM1F1WTI5c2IzSnpJRDBnZTF4dUlDQW5ZbTlzWkNjZ09pQmJNU3dnTWpKZExGeHVJQ0FuYVhSaGJHbGpKeUE2SUZzekxDQXlNMTBzWEc0Z0lDZDFibVJsY214cGJtVW5JRG9nV3pRc0lESTBYU3hjYmlBZ0oybHVkbVZ5YzJVbklEb2dXemNzSURJM1hTeGNiaUFnSjNkb2FYUmxKeUE2SUZzek55d2dNemxkTEZ4dUlDQW5aM0psZVNjZ09pQmJPVEFzSURNNVhTeGNiaUFnSjJKc1lXTnJKeUE2SUZzek1Dd2dNemxkTEZ4dUlDQW5ZbXgxWlNjZ09pQmJNelFzSURNNVhTeGNiaUFnSjJONVlXNG5JRG9nV3pNMkxDQXpPVjBzWEc0Z0lDZG5jbVZsYmljZ09pQmJNeklzSURNNVhTeGNiaUFnSjIxaFoyVnVkR0VuSURvZ1d6TTFMQ0F6T1Ywc1hHNGdJQ2R5WldRbklEb2dXek14TENBek9WMHNYRzRnSUNkNVpXeHNiM2NuSURvZ1d6TXpMQ0F6T1YxY2JuMDdYRzVjYmk4dklFUnZiaWQwSUhWelpTQW5ZbXgxWlNjZ2JtOTBJSFpwYzJsaWJHVWdiMjRnWTIxa0xtVjRaVnh1YVc1emNHVmpkQzV6ZEhsc1pYTWdQU0I3WEc0Z0lDZHpjR1ZqYVdGc0p6b2dKMk41WVc0bkxGeHVJQ0FuYm5WdFltVnlKem9nSjNsbGJHeHZkeWNzWEc0Z0lDZGliMjlzWldGdUp6b2dKM2xsYkd4dmR5Y3NYRzRnSUNkMWJtUmxabWx1WldRbk9pQW5aM0psZVNjc1hHNGdJQ2R1ZFd4c0p6b2dKMkp2YkdRbkxGeHVJQ0FuYzNSeWFXNW5Kem9nSjJkeVpXVnVKeXhjYmlBZ0oyUmhkR1VuT2lBbmJXRm5aVzUwWVNjc1hHNGdJQzh2SUZ3aWJtRnRaVndpT2lCcGJuUmxiblJwYjI1aGJHeDVJRzV2ZENCemRIbHNhVzVuWEc0Z0lDZHlaV2RsZUhBbk9pQW5jbVZrSjF4dWZUdGNibHh1WEc1bWRXNWpkR2x2YmlCemRIbHNhWHBsVjJsMGFFTnZiRzl5S0hOMGNpd2djM1I1YkdWVWVYQmxLU0I3WEc0Z0lIWmhjaUJ6ZEhsc1pTQTlJR2x1YzNCbFkzUXVjM1I1YkdWelczTjBlV3hsVkhsd1pWMDdYRzVjYmlBZ2FXWWdLSE4wZVd4bEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUNkY1hIVXdNREZpV3ljZ0t5QnBibk53WldOMExtTnZiRzl5YzF0emRIbHNaVjFiTUYwZ0t5QW5iU2NnS3lCemRISWdLMXh1SUNBZ0lDQWdJQ0FnSUNBblhGeDFNREF4WWxzbklDc2dhVzV6Y0dWamRDNWpiMnh2Y25OYmMzUjViR1ZkV3pGZElDc2dKMjBuTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGRIVnliaUJ6ZEhJN1hHNGdJSDFjYm4xY2JseHVYRzVtZFc1amRHbHZiaUJ6ZEhsc2FYcGxUbTlEYjJ4dmNpaHpkSElzSUhOMGVXeGxWSGx3WlNrZ2UxeHVJQ0J5WlhSMWNtNGdjM1J5TzF4dWZWeHVYRzVjYm1aMWJtTjBhVzl1SUdGeWNtRjVWRzlJWVhOb0tHRnljbUY1S1NCN1hHNGdJSFpoY2lCb1lYTm9JRDBnZTMwN1hHNWNiaUFnWVhKeVlYa3VabTl5UldGamFDaG1kVzVqZEdsdmJpaDJZV3dzSUdsa2VDa2dlMXh1SUNBZ0lHaGhjMmhiZG1Gc1hTQTlJSFJ5ZFdVN1hHNGdJSDBwTzF4dVhHNGdJSEpsZEhWeWJpQm9ZWE5vTzF4dWZWeHVYRzVjYm1aMWJtTjBhVzl1SUdadmNtMWhkRlpoYkhWbEtHTjBlQ3dnZG1Gc2RXVXNJSEpsWTNWeWMyVlVhVzFsY3lrZ2UxeHVJQ0F2THlCUWNtOTJhV1JsSUdFZ2FHOXZheUJtYjNJZ2RYTmxjaTF6Y0dWamFXWnBaV1FnYVc1emNHVmpkQ0JtZFc1amRHbHZibk11WEc0Z0lDOHZJRU5vWldOcklIUm9ZWFFnZG1Gc2RXVWdhWE1nWVc0Z2IySnFaV04wSUhkcGRHZ2dZVzRnYVc1emNHVmpkQ0JtZFc1amRHbHZiaUJ2YmlCcGRGeHVJQ0JwWmlBb1kzUjRMbU4xYzNSdmJVbHVjM0JsWTNRZ0ppWmNiaUFnSUNBZ0lIWmhiSFZsSUNZbVhHNGdJQ0FnSUNCcGMwWjFibU4wYVc5dUtIWmhiSFZsTG1sdWMzQmxZM1FwSUNZbVhHNGdJQ0FnSUNBdkx5QkdhV3gwWlhJZ2IzVjBJSFJvWlNCMWRHbHNJRzF2WkhWc1pTd2dhWFFuY3lCcGJuTndaV04wSUdaMWJtTjBhVzl1SUdseklITndaV05wWVd4Y2JpQWdJQ0FnSUhaaGJIVmxMbWx1YzNCbFkzUWdJVDA5SUdWNGNHOXlkSE11YVc1emNHVmpkQ0FtSmx4dUlDQWdJQ0FnTHk4Z1FXeHpieUJtYVd4MFpYSWdiM1YwSUdGdWVTQndjbTkwYjNSNWNHVWdiMkpxWldOMGN5QjFjMmx1WnlCMGFHVWdZMmx5WTNWc1lYSWdZMmhsWTJzdVhHNGdJQ0FnSUNBaEtIWmhiSFZsTG1OdmJuTjBjblZqZEc5eUlDWW1JSFpoYkhWbExtTnZibk4wY25WamRHOXlMbkJ5YjNSdmRIbHdaU0E5UFQwZ2RtRnNkV1VwS1NCN1hHNGdJQ0FnZG1GeUlISmxkQ0E5SUhaaGJIVmxMbWx1YzNCbFkzUW9jbVZqZFhKelpWUnBiV1Z6TENCamRIZ3BPMXh1SUNBZ0lHbG1JQ2doYVhOVGRISnBibWNvY21WMEtTa2dlMXh1SUNBZ0lDQWdjbVYwSUQwZ1ptOXliV0YwVm1Gc2RXVW9ZM1I0TENCeVpYUXNJSEpsWTNWeWMyVlVhVzFsY3lrN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQnlaWFE3WEc0Z0lIMWNibHh1SUNBdkx5QlFjbWx0YVhScGRtVWdkSGx3WlhNZ1kyRnVibTkwSUdoaGRtVWdjSEp2Y0dWeWRHbGxjMXh1SUNCMllYSWdjSEpwYldsMGFYWmxJRDBnWm05eWJXRjBVSEpwYldsMGFYWmxLR04wZUN3Z2RtRnNkV1VwTzF4dUlDQnBaaUFvY0hKcGJXbDBhWFpsS1NCN1hHNGdJQ0FnY21WMGRYSnVJSEJ5YVcxcGRHbDJaVHRjYmlBZ2ZWeHVYRzRnSUM4dklFeHZiMnNnZFhBZ2RHaGxJR3RsZVhNZ2IyWWdkR2hsSUc5aWFtVmpkQzVjYmlBZ2RtRnlJR3RsZVhNZ1BTQlBZbXBsWTNRdWEyVjVjeWgyWVd4MVpTazdYRzRnSUhaaGNpQjJhWE5wWW14bFMyVjVjeUE5SUdGeWNtRjVWRzlJWVhOb0tHdGxlWE1wTzF4dVhHNGdJR2xtSUNoamRIZ3VjMmh2ZDBocFpHUmxiaWtnZTF4dUlDQWdJR3RsZVhNZ1BTQlBZbXBsWTNRdVoyVjBUM2R1VUhKdmNHVnlkSGxPWVcxbGN5aDJZV3gxWlNrN1hHNGdJSDFjYmx4dUlDQXZMeUJKUlNCa2IyVnpiaWQwSUcxaGEyVWdaWEp5YjNJZ1ptbGxiR1J6SUc1dmJpMWxiblZ0WlhKaFlteGxYRzRnSUM4dklHaDBkSEE2THk5dGMyUnVMbTFwWTNKdmMyOW1kQzVqYjIwdlpXNHRkWE12YkdsaWNtRnllUzlwWlM5a2QzYzFNbk5pZENoMlBYWnpMamswS1M1aGMzQjRYRzRnSUdsbUlDaHBjMFZ5Y205eUtIWmhiSFZsS1Z4dUlDQWdJQ0FnSmlZZ0tHdGxlWE11YVc1a1pYaFBaaWduYldWemMyRm5aU2NwSUQ0OUlEQWdmSHdnYTJWNWN5NXBibVJsZUU5bUtDZGtaWE5qY21sd2RHbHZiaWNwSUQ0OUlEQXBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHWnZjbTFoZEVWeWNtOXlLSFpoYkhWbEtUdGNiaUFnZlZ4dVhHNGdJQzh2SUZOdmJXVWdkSGx3WlNCdlppQnZZbXBsWTNRZ2QybDBhRzkxZENCd2NtOXdaWEowYVdWeklHTmhiaUJpWlNCemFHOXlkR04xZEhSbFpDNWNiaUFnYVdZZ0tHdGxlWE11YkdWdVozUm9JRDA5UFNBd0tTQjdYRzRnSUNBZ2FXWWdLR2x6Um5WdVkzUnBiMjRvZG1Gc2RXVXBLU0I3WEc0Z0lDQWdJQ0IyWVhJZ2JtRnRaU0E5SUhaaGJIVmxMbTVoYldVZ1B5QW5PaUFuSUNzZ2RtRnNkV1V1Ym1GdFpTQTZJQ2NuTzF4dUlDQWdJQ0FnY21WMGRYSnVJR04wZUM1emRIbHNhWHBsS0NkYlJuVnVZM1JwYjI0bklDc2dibUZ0WlNBcklDZGRKeXdnSjNOd1pXTnBZV3duS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0dselVtVm5SWGh3S0haaGJIVmxLU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR04wZUM1emRIbHNhWHBsS0ZKbFowVjRjQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWN1WTJGc2JDaDJZV3gxWlNrc0lDZHlaV2RsZUhBbktUdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHbHpSR0YwWlNoMllXeDFaU2twSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJqZEhndWMzUjViR2w2WlNoRVlYUmxMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaeTVqWVd4c0tIWmhiSFZsS1N3Z0oyUmhkR1VuS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0dselJYSnliM0lvZG1Gc2RXVXBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabTl5YldGMFJYSnliM0lvZG1Gc2RXVXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSFpoY2lCaVlYTmxJRDBnSnljc0lHRnljbUY1SUQwZ1ptRnNjMlVzSUdKeVlXTmxjeUE5SUZzbmV5Y3NJQ2Q5SjEwN1hHNWNiaUFnTHk4Z1RXRnJaU0JCY25KaGVTQnpZWGtnZEdoaGRDQjBhR1Y1SUdGeVpTQkJjbkpoZVZ4dUlDQnBaaUFvYVhOQmNuSmhlU2gyWVd4MVpTa3BJSHRjYmlBZ0lDQmhjbkpoZVNBOUlIUnlkV1U3WEc0Z0lDQWdZbkpoWTJWeklEMGdXeWRiSnl3Z0oxMG5YVHRjYmlBZ2ZWeHVYRzRnSUM4dklFMWhhMlVnWm5WdVkzUnBiMjV6SUhOaGVTQjBhR0YwSUhSb1pYa2dZWEpsSUdaMWJtTjBhVzl1YzF4dUlDQnBaaUFvYVhOR2RXNWpkR2x2YmloMllXeDFaU2twSUh0Y2JpQWdJQ0IyWVhJZ2JpQTlJSFpoYkhWbExtNWhiV1VnUHlBbk9pQW5JQ3NnZG1Gc2RXVXVibUZ0WlNBNklDY25PMXh1SUNBZ0lHSmhjMlVnUFNBbklGdEdkVzVqZEdsdmJpY2dLeUJ1SUNzZ0oxMG5PMXh1SUNCOVhHNWNiaUFnTHk4Z1RXRnJaU0JTWldkRmVIQnpJSE5oZVNCMGFHRjBJSFJvWlhrZ1lYSmxJRkpsWjBWNGNITmNiaUFnYVdZZ0tHbHpVbVZuUlhod0tIWmhiSFZsS1NrZ2UxeHVJQ0FnSUdKaGMyVWdQU0FuSUNjZ0t5QlNaV2RGZUhBdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bkxtTmhiR3dvZG1Gc2RXVXBPMXh1SUNCOVhHNWNiaUFnTHk4Z1RXRnJaU0JrWVhSbGN5QjNhWFJvSUhCeWIzQmxjblJwWlhNZ1ptbHljM1FnYzJGNUlIUm9aU0JrWVhSbFhHNGdJR2xtSUNocGMwUmhkR1VvZG1Gc2RXVXBLU0I3WEc0Z0lDQWdZbUZ6WlNBOUlDY2dKeUFySUVSaGRHVXVjSEp2ZEc5MGVYQmxMblJ2VlZSRFUzUnlhVzVuTG1OaGJHd29kbUZzZFdVcE8xeHVJQ0I5WEc1Y2JpQWdMeThnVFdGclpTQmxjbkp2Y2lCM2FYUm9JRzFsYzNOaFoyVWdabWx5YzNRZ2MyRjVJSFJvWlNCbGNuSnZjbHh1SUNCcFppQW9hWE5GY25KdmNpaDJZV3gxWlNrcElIdGNiaUFnSUNCaVlYTmxJRDBnSnlBbklDc2dabTl5YldGMFJYSnliM0lvZG1Gc2RXVXBPMXh1SUNCOVhHNWNiaUFnYVdZZ0tHdGxlWE11YkdWdVozUm9JRDA5UFNBd0lDWW1JQ2doWVhKeVlYa2dmSHdnZG1Gc2RXVXViR1Z1WjNSb0lEMDlJREFwS1NCN1hHNGdJQ0FnY21WMGRYSnVJR0p5WVdObGMxc3dYU0FySUdKaGMyVWdLeUJpY21GalpYTmJNVjA3WEc0Z0lIMWNibHh1SUNCcFppQW9jbVZqZFhKelpWUnBiV1Z6SUR3Z01Da2dlMXh1SUNBZ0lHbG1JQ2hwYzFKbFowVjRjQ2gyWVd4MVpTa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmpkSGd1YzNSNWJHbDZaU2hTWldkRmVIQXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5MbU5oYkd3b2RtRnNkV1VwTENBbmNtVm5aWGh3SnlrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmpkSGd1YzNSNWJHbDZaU2duVzA5aWFtVmpkRjBuTENBbmMzQmxZMmxoYkNjcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHTjBlQzV6WldWdUxuQjFjMmdvZG1Gc2RXVXBPMXh1WEc0Z0lIWmhjaUJ2ZFhSd2RYUTdYRzRnSUdsbUlDaGhjbkpoZVNrZ2UxeHVJQ0FnSUc5MWRIQjFkQ0E5SUdadmNtMWhkRUZ5Y21GNUtHTjBlQ3dnZG1Gc2RXVXNJSEpsWTNWeWMyVlVhVzFsY3l3Z2RtbHphV0pzWlV0bGVYTXNJR3RsZVhNcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHOTFkSEIxZENBOUlHdGxlWE11YldGd0tHWjFibU4wYVc5dUtHdGxlU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1p2Y20xaGRGQnliM0JsY25SNUtHTjBlQ3dnZG1Gc2RXVXNJSEpsWTNWeWMyVlVhVzFsY3l3Z2RtbHphV0pzWlV0bGVYTXNJR3RsZVN3Z1lYSnlZWGtwTzF4dUlDQWdJSDBwTzF4dUlDQjlYRzVjYmlBZ1kzUjRMbk5sWlc0dWNHOXdLQ2s3WEc1Y2JpQWdjbVYwZFhKdUlISmxaSFZqWlZSdlUybHVaMnhsVTNSeWFXNW5LRzkxZEhCMWRDd2dZbUZ6WlN3Z1luSmhZMlZ6S1R0Y2JuMWNibHh1WEc1bWRXNWpkR2x2YmlCbWIzSnRZWFJRY21sdGFYUnBkbVVvWTNSNExDQjJZV3gxWlNrZ2UxeHVJQ0JwWmlBb2FYTlZibVJsWm1sdVpXUW9kbUZzZFdVcEtWeHVJQ0FnSUhKbGRIVnliaUJqZEhndWMzUjViR2w2WlNnbmRXNWtaV1pwYm1Wa0p5d2dKM1Z1WkdWbWFXNWxaQ2NwTzF4dUlDQnBaaUFvYVhOVGRISnBibWNvZG1Gc2RXVXBLU0I3WEc0Z0lDQWdkbUZ5SUhOcGJYQnNaU0E5SUNkY1hDY25JQ3NnU2xOUFRpNXpkSEpwYm1kcFpua29kbUZzZFdVcExuSmxjR3hoWTJVb0wxNWNJbnhjSWlRdlp5d2dKeWNwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdWNtVndiR0ZqWlNndkp5OW5MQ0JjSWx4Y1hGd25YQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdWNtVndiR0ZqWlNndlhGeGNYRndpTDJjc0lDZGNJaWNwSUNzZ0oxeGNKeWM3WEc0Z0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLSE5wYlhCc1pTd2dKM04wY21sdVp5Y3BPMXh1SUNCOVhHNGdJR2xtSUNocGMwNTFiV0psY2loMllXeDFaU2twWEc0Z0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLQ2NuSUNzZ2RtRnNkV1VzSUNkdWRXMWlaWEluS1R0Y2JpQWdhV1lnS0dselFtOXZiR1ZoYmloMllXeDFaU2twWEc0Z0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLQ2NuSUNzZ2RtRnNkV1VzSUNkaWIyOXNaV0Z1SnlrN1hHNGdJQzh2SUVadmNpQnpiMjFsSUhKbFlYTnZiaUIwZVhCbGIyWWdiblZzYkNCcGN5QmNJbTlpYW1WamRGd2lMQ0J6YnlCemNHVmphV0ZzSUdOaGMyVWdhR1Z5WlM1Y2JpQWdhV1lnS0dselRuVnNiQ2gyWVd4MVpTa3BYRzRnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtDZHVkV3hzSnl3Z0oyNTFiR3duS1R0Y2JuMWNibHh1WEc1bWRXNWpkR2x2YmlCbWIzSnRZWFJGY25KdmNpaDJZV3gxWlNrZ2UxeHVJQ0J5WlhSMWNtNGdKMXNuSUNzZ1JYSnliM0l1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29kbUZzZFdVcElDc2dKMTBuTzF4dWZWeHVYRzVjYm1aMWJtTjBhVzl1SUdadmNtMWhkRUZ5Y21GNUtHTjBlQ3dnZG1Gc2RXVXNJSEpsWTNWeWMyVlVhVzFsY3l3Z2RtbHphV0pzWlV0bGVYTXNJR3RsZVhNcElIdGNiaUFnZG1GeUlHOTFkSEIxZENBOUlGdGRPMXh1SUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYkNBOUlIWmhiSFZsTG14bGJtZDBhRHNnYVNBOElHdzdJQ3NyYVNrZ2UxeHVJQ0FnSUdsbUlDaG9ZWE5QZDI1UWNtOXdaWEowZVNoMllXeDFaU3dnVTNSeWFXNW5LR2twS1NrZ2UxeHVJQ0FnSUNBZ2IzVjBjSFYwTG5CMWMyZ29abTl5YldGMFVISnZjR1Z5ZEhrb1kzUjRMQ0IyWVd4MVpTd2djbVZqZFhKelpWUnBiV1Z6TENCMmFYTnBZbXhsUzJWNWN5eGNiaUFnSUNBZ0lDQWdJQ0JUZEhKcGJtY29hU2tzSUhSeWRXVXBLVHRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2IzVjBjSFYwTG5CMWMyZ29KeWNwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0JyWlhsekxtWnZja1ZoWTJnb1puVnVZM1JwYjI0b2EyVjVLU0I3WEc0Z0lDQWdhV1lnS0NGclpYa3ViV0YwWTJnb0wxNWNYR1FySkM4cEtTQjdYRzRnSUNBZ0lDQnZkWFJ3ZFhRdWNIVnphQ2htYjNKdFlYUlFjbTl3WlhKMGVTaGpkSGdzSUhaaGJIVmxMQ0J5WldOMWNuTmxWR2x0WlhNc0lIWnBjMmxpYkdWTFpYbHpMRnh1SUNBZ0lDQWdJQ0FnSUd0bGVTd2dkSEoxWlNrcE8xeHVJQ0FnSUgxY2JpQWdmU2s3WEc0Z0lISmxkSFZ5YmlCdmRYUndkWFE3WEc1OVhHNWNibHh1Wm5WdVkzUnBiMjRnWm05eWJXRjBVSEp2Y0dWeWRIa29ZM1I0TENCMllXeDFaU3dnY21WamRYSnpaVlJwYldWekxDQjJhWE5wWW14bFMyVjVjeXdnYTJWNUxDQmhjbkpoZVNrZ2UxeHVJQ0IyWVhJZ2JtRnRaU3dnYzNSeUxDQmtaWE5qTzF4dUlDQmtaWE5qSUQwZ1QySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaWgyWVd4MVpTd2dhMlY1S1NCOGZDQjdJSFpoYkhWbE9pQjJZV3gxWlZ0clpYbGRJSDA3WEc0Z0lHbG1JQ2hrWlhOakxtZGxkQ2tnZTF4dUlDQWdJR2xtSUNoa1pYTmpMbk5sZENrZ2UxeHVJQ0FnSUNBZ2MzUnlJRDBnWTNSNExuTjBlV3hwZW1Vb0oxdEhaWFIwWlhJdlUyVjBkR1Z5WFNjc0lDZHpjR1ZqYVdGc0p5azdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUhOMGNpQTlJR04wZUM1emRIbHNhWHBsS0NkYlIyVjBkR1Z5WFNjc0lDZHpjR1ZqYVdGc0p5azdYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHbG1JQ2hrWlhOakxuTmxkQ2tnZTF4dUlDQWdJQ0FnYzNSeUlEMGdZM1I0TG5OMGVXeHBlbVVvSjF0VFpYUjBaWEpkSnl3Z0ozTndaV05wWVd3bktUdGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2FXWWdLQ0ZvWVhOUGQyNVFjbTl3WlhKMGVTaDJhWE5wWW14bFMyVjVjeXdnYTJWNUtTa2dlMXh1SUNBZ0lHNWhiV1VnUFNBbld5Y2dLeUJyWlhrZ0t5QW5YU2M3WEc0Z0lIMWNiaUFnYVdZZ0tDRnpkSElwSUh0Y2JpQWdJQ0JwWmlBb1kzUjRMbk5sWlc0dWFXNWtaWGhQWmloa1pYTmpMblpoYkhWbEtTQThJREFwSUh0Y2JpQWdJQ0FnSUdsbUlDaHBjMDUxYkd3b2NtVmpkWEp6WlZScGJXVnpLU2tnZTF4dUlDQWdJQ0FnSUNCemRISWdQU0JtYjNKdFlYUldZV3gxWlNoamRIZ3NJR1JsYzJNdWRtRnNkV1VzSUc1MWJHd3BPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjM1J5SUQwZ1ptOXliV0YwVm1Gc2RXVW9ZM1I0TENCa1pYTmpMblpoYkhWbExDQnlaV04xY25ObFZHbHRaWE1nTFNBeEtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHbG1JQ2h6ZEhJdWFXNWtaWGhQWmlnblhGeHVKeWtnUGlBdE1Ta2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb1lYSnlZWGtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnpkSElnUFNCemRISXVjM0JzYVhRb0oxeGNiaWNwTG0xaGNDaG1kVzVqZEdsdmJpaHNhVzVsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdKeUFnSnlBcklHeHBibVU3WEc0Z0lDQWdJQ0FnSUNBZ2ZTa3VhbTlwYmlnblhGeHVKeWt1YzNWaWMzUnlLRElwTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lITjBjaUE5SUNkY1hHNG5JQ3NnYzNSeUxuTndiR2wwS0NkY1hHNG5LUzV0WVhBb1puVnVZM1JwYjI0b2JHbHVaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlDY2dJQ0FuSUNzZ2JHbHVaVHRjYmlBZ0lDQWdJQ0FnSUNCOUtTNXFiMmx1S0NkY1hHNG5LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnpkSElnUFNCamRIZ3VjM1I1YkdsNlpTZ25XME5wY21OMWJHRnlYU2NzSUNkemNHVmphV0ZzSnlrN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUdsbUlDaHBjMVZ1WkdWbWFXNWxaQ2h1WVcxbEtTa2dlMXh1SUNBZ0lHbG1JQ2hoY25KaGVTQW1KaUJyWlhrdWJXRjBZMmdvTDE1Y1hHUXJKQzhwS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYzNSeU8xeHVJQ0FnSUgxY2JpQWdJQ0J1WVcxbElEMGdTbE5QVGk1emRISnBibWRwWm5rb0p5Y2dLeUJyWlhrcE8xeHVJQ0FnSUdsbUlDaHVZVzFsTG0xaGRHTm9LQzllWENJb1cyRXRla0V0V2w5ZFcyRXRla0V0V2w4d0xUbGRLaWxjSWlRdktTa2dlMXh1SUNBZ0lDQWdibUZ0WlNBOUlHNWhiV1V1YzNWaWMzUnlLREVzSUc1aGJXVXViR1Z1WjNSb0lDMGdNaWs3WEc0Z0lDQWdJQ0J1WVcxbElEMGdZM1I0TG5OMGVXeHBlbVVvYm1GdFpTd2dKMjVoYldVbktUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnYm1GdFpTQTlJRzVoYldVdWNtVndiR0ZqWlNndkp5OW5MQ0JjSWx4Y1hGd25YQ0lwWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM1eVpYQnNZV05sS0M5Y1hGeGNYQ0l2Wnl3Z0oxd2lKeWxjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTG5KbGNHeGhZMlVvTHloZVhDSjhYQ0lrS1M5bkxDQmNJaWRjSWlrN1hHNGdJQ0FnSUNCdVlXMWxJRDBnWTNSNExuTjBlV3hwZW1Vb2JtRnRaU3dnSjNOMGNtbHVaeWNwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ1WVcxbElDc2dKem9nSnlBcklITjBjanRjYm4xY2JseHVYRzVtZFc1amRHbHZiaUJ5WldSMVkyVlViMU5wYm1kc1pWTjBjbWx1WnlodmRYUndkWFFzSUdKaGMyVXNJR0p5WVdObGN5a2dlMXh1SUNCMllYSWdiblZ0VEdsdVpYTkZjM1FnUFNBd08xeHVJQ0IyWVhJZ2JHVnVaM1JvSUQwZ2IzVjBjSFYwTG5KbFpIVmpaU2htZFc1amRHbHZiaWh3Y21WMkxDQmpkWElwSUh0Y2JpQWdJQ0J1ZFcxTWFXNWxjMFZ6ZENzck8xeHVJQ0FnSUdsbUlDaGpkWEl1YVc1a1pYaFBaaWduWEZ4dUp5a2dQajBnTUNrZ2JuVnRUR2x1WlhORmMzUXJLenRjYmlBZ0lDQnlaWFIxY200Z2NISmxkaUFySUdOMWNpNXlaWEJzWVdObEtDOWNYSFV3TURGaVhGeGJYRnhrWEZ4a1AyMHZaeXdnSnljcExteGxibWQwYUNBcklERTdYRzRnSUgwc0lEQXBPMXh1WEc0Z0lHbG1JQ2hzWlc1bmRHZ2dQaUEyTUNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJpY21GalpYTmJNRjBnSzF4dUlDQWdJQ0FnSUNBZ0lDQW9ZbUZ6WlNBOVBUMGdKeWNnUHlBbkp5QTZJR0poYzJVZ0t5QW5YRnh1SUNjcElDdGNiaUFnSUNBZ0lDQWdJQ0FnSnlBbklDdGNiaUFnSUNBZ0lDQWdJQ0FnYjNWMGNIVjBMbXB2YVc0b0p5eGNYRzRnSUNjcElDdGNiaUFnSUNBZ0lDQWdJQ0FnSnlBbklDdGNiaUFnSUNBZ0lDQWdJQ0FnWW5KaFkyVnpXekZkTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUdKeVlXTmxjMXN3WFNBcklHSmhjMlVnS3lBbklDY2dLeUJ2ZFhSd2RYUXVhbTlwYmlnbkxDQW5LU0FySUNjZ0p5QXJJR0p5WVdObGMxc3hYVHRjYm4xY2JseHVYRzR2THlCT1QxUkZPaUJVYUdWelpTQjBlWEJsSUdOb1pXTnJhVzVuSUdaMWJtTjBhVzl1Y3lCcGJuUmxiblJwYjI1aGJHeDVJR1J2YmlkMElIVnpaU0JnYVc1emRHRnVZMlZ2Wm1CY2JpOHZJR0psWTJGMWMyVWdhWFFnYVhNZ1puSmhaMmxzWlNCaGJtUWdZMkZ1SUdKbElHVmhjMmxzZVNCbVlXdGxaQ0IzYVhSb0lHQlBZbXBsWTNRdVkzSmxZWFJsS0NsZ0xseHVaWGh3YjNKMGN5NTBlWEJsY3lBOUlISmxjWFZwY21Vb0p5NHZjM1Z3Y0c5eWRDOTBlWEJsY3ljcE8xeHVYRzVtZFc1amRHbHZiaUJwYzBGeWNtRjVLR0Z5S1NCN1hHNGdJSEpsZEhWeWJpQkJjbkpoZVM1cGMwRnljbUY1S0dGeUtUdGNibjFjYm1WNGNHOXlkSE11YVhOQmNuSmhlU0E5SUdselFYSnlZWGs3WEc1Y2JtWjFibU4wYVc5dUlHbHpRbTl2YkdWaGJpaGhjbWNwSUh0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkaWIyOXNaV0Z1Snp0Y2JuMWNibVY0Y0c5eWRITXVhWE5DYjI5c1pXRnVJRDBnYVhOQ2IyOXNaV0Z1TzF4dVhHNW1kVzVqZEdsdmJpQnBjMDUxYkd3b1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCaGNtY2dQVDA5SUc1MWJHdzdYRzU5WEc1bGVIQnZjblJ6TG1selRuVnNiQ0E5SUdselRuVnNiRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTk9kV3hzVDNKVmJtUmxabWx1WldRb1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCaGNtY2dQVDBnYm5Wc2JEdGNibjFjYm1WNGNHOXlkSE11YVhOT2RXeHNUM0pWYm1SbFptbHVaV1FnUFNCcGMwNTFiR3hQY2xWdVpHVm1hVzVsWkR0Y2JseHVablZ1WTNScGIyNGdhWE5PZFcxaVpYSW9ZWEpuS1NCN1hHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmJuVnRZbVZ5Snp0Y2JuMWNibVY0Y0c5eWRITXVhWE5PZFcxaVpYSWdQU0JwYzA1MWJXSmxjanRjYmx4dVpuVnVZM1JwYjI0Z2FYTlRkSEpwYm1jb1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnWVhKbklEMDlQU0FuYzNSeWFXNW5KenRjYm4xY2JtVjRjRzl5ZEhNdWFYTlRkSEpwYm1jZ1BTQnBjMU4wY21sdVp6dGNibHh1Wm5WdVkzUnBiMjRnYVhOVGVXMWliMndvWVhKbktTQjdYRzRnSUhKbGRIVnliaUIwZVhCbGIyWWdZWEpuSUQwOVBTQW5jM2x0WW05c0p6dGNibjFjYm1WNGNHOXlkSE11YVhOVGVXMWliMndnUFNCcGMxTjViV0p2YkR0Y2JseHVablZ1WTNScGIyNGdhWE5WYm1SbFptbHVaV1FvWVhKbktTQjdYRzRnSUhKbGRIVnliaUJoY21jZ1BUMDlJSFp2YVdRZ01EdGNibjFjYm1WNGNHOXlkSE11YVhOVmJtUmxabWx1WldRZ1BTQnBjMVZ1WkdWbWFXNWxaRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTlNaV2RGZUhBb2NtVXBJSHRjYmlBZ2NtVjBkWEp1SUdselQySnFaV04wS0hKbEtTQW1KaUJ2WW1wbFkzUlViMU4wY21sdVp5aHlaU2tnUFQwOUlDZGJiMkpxWldOMElGSmxaMFY0Y0Ywbk8xeHVmVnh1Wlhod2IzSjBjeTVwYzFKbFowVjRjQ0E5SUdselVtVm5SWGh3TzF4dVpYaHdiM0owY3k1MGVYQmxjeTVwYzFKbFowVjRjQ0E5SUdselVtVm5SWGh3TzF4dVhHNW1kVzVqZEdsdmJpQnBjMDlpYW1WamRDaGhjbWNwSUh0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkdlltcGxZM1FuSUNZbUlHRnlaeUFoUFQwZ2JuVnNiRHRjYm4xY2JtVjRjRzl5ZEhNdWFYTlBZbXBsWTNRZ1BTQnBjMDlpYW1WamREdGNibHh1Wm5WdVkzUnBiMjRnYVhORVlYUmxLR1FwSUh0Y2JpQWdjbVYwZFhKdUlHbHpUMkpxWldOMEtHUXBJQ1ltSUc5aWFtVmpkRlJ2VTNSeWFXNW5LR1FwSUQwOVBTQW5XMjlpYW1WamRDQkVZWFJsWFNjN1hHNTlYRzVsZUhCdmNuUnpMbWx6UkdGMFpTQTlJR2x6UkdGMFpUdGNibVY0Y0c5eWRITXVkSGx3WlhNdWFYTkVZWFJsSUQwZ2FYTkVZWFJsTzF4dVhHNW1kVzVqZEdsdmJpQnBjMFZ5Y205eUtHVXBJSHRjYmlBZ2NtVjBkWEp1SUdselQySnFaV04wS0dVcElDWW1YRzRnSUNBZ0lDQW9iMkpxWldOMFZHOVRkSEpwYm1jb1pTa2dQVDA5SUNkYmIySnFaV04wSUVWeWNtOXlYU2NnZkh3Z1pTQnBibk4wWVc1alpXOW1JRVZ5Y205eUtUdGNibjFjYm1WNGNHOXlkSE11YVhORmNuSnZjaUE5SUdselJYSnliM0k3WEc1bGVIQnZjblJ6TG5SNWNHVnpMbWx6VG1GMGFYWmxSWEp5YjNJZ1BTQnBjMFZ5Y205eU8xeHVYRzVtZFc1amRHbHZiaUJwYzBaMWJtTjBhVzl1S0dGeVp5a2dlMXh1SUNCeVpYUjFjbTRnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKMloxYm1OMGFXOXVKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTkdkVzVqZEdsdmJpQTlJR2x6Um5WdVkzUnBiMjQ3WEc1Y2JtWjFibU4wYVc5dUlHbHpVSEpwYldsMGFYWmxLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdZWEpuSUQwOVBTQnVkV3hzSUh4OFhHNGdJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1lYSm5JRDA5UFNBblltOXZiR1ZoYmljZ2ZIeGNiaUFnSUNBZ0lDQWdJSFI1Y0dWdlppQmhjbWNnUFQwOUlDZHVkVzFpWlhJbklIeDhYRzRnSUNBZ0lDQWdJQ0IwZVhCbGIyWWdZWEpuSUQwOVBTQW5jM1J5YVc1bkp5QjhmRnh1SUNBZ0lDQWdJQ0FnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKM041YldKdmJDY2dmSHdnSUM4dklFVlROaUJ6ZVcxaWIyeGNiaUFnSUNBZ0lDQWdJSFI1Y0dWdlppQmhjbWNnUFQwOUlDZDFibVJsWm1sdVpXUW5PMXh1ZlZ4dVpYaHdiM0owY3k1cGMxQnlhVzFwZEdsMlpTQTlJR2x6VUhKcGJXbDBhWFpsTzF4dVhHNWxlSEJ2Y25SekxtbHpRblZtWm1WeUlEMGdjbVZ4ZFdseVpTZ25MaTl6ZFhCd2IzSjBMMmx6UW5WbVptVnlKeWs3WEc1Y2JtWjFibU4wYVc5dUlHOWlhbVZqZEZSdlUzUnlhVzVuS0c4cElIdGNiaUFnY21WMGRYSnVJRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY3VZMkZzYkNodktUdGNibjFjYmx4dVhHNW1kVzVqZEdsdmJpQndZV1FvYmlrZ2UxeHVJQ0J5WlhSMWNtNGdiaUE4SURFd0lEOGdKekFuSUNzZ2JpNTBiMU4wY21sdVp5Z3hNQ2tnT2lCdUxuUnZVM1J5YVc1bktERXdLVHRjYm4xY2JseHVYRzUyWVhJZ2JXOXVkR2h6SUQwZ1d5ZEtZVzRuTENBblJtVmlKeXdnSjAxaGNpY3NJQ2RCY0hJbkxDQW5UV0Y1Snl3Z0owcDFiaWNzSUNkS2RXd25MQ0FuUVhWbkp5d2dKMU5sY0Njc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNkUFkzUW5MQ0FuVG05Mkp5d2dKMFJsWXlkZE8xeHVYRzR2THlBeU5pQkdaV0lnTVRZNk1UazZNelJjYm1aMWJtTjBhVzl1SUhScGJXVnpkR0Z0Y0NncElIdGNiaUFnZG1GeUlHUWdQU0J1WlhjZ1JHRjBaU2dwTzF4dUlDQjJZWElnZEdsdFpTQTlJRnR3WVdRb1pDNW5aWFJJYjNWeWN5Z3BLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjR0ZrS0dRdVoyVjBUV2x1ZFhSbGN5Z3BLU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdjR0ZrS0dRdVoyVjBVMlZqYjI1a2N5Z3BLVjB1YW05cGJpZ25PaWNwTzF4dUlDQnlaWFIxY200Z1cyUXVaMlYwUkdGMFpTZ3BMQ0J0YjI1MGFITmJaQzVuWlhSTmIyNTBhQ2dwWFN3Z2RHbHRaVjB1YW05cGJpZ25JQ2NwTzF4dWZWeHVYRzVjYmk4dklHeHZaeUJwY3lCcWRYTjBJR0VnZEdocGJpQjNjbUZ3Y0dWeUlIUnZJR052Ym5OdmJHVXViRzluSUhSb1lYUWdjSEpsY0dWdVpITWdZU0IwYVcxbGMzUmhiWEJjYm1WNGNHOXlkSE11Ykc5bklEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lHTnZibk52YkdVdWJHOW5LQ2NsY3lBdElDVnpKeXdnZEdsdFpYTjBZVzF3S0Nrc0lHVjRjRzl5ZEhNdVptOXliV0YwTG1Gd2NHeDVLR1Y0Y0c5eWRITXNJR0Z5WjNWdFpXNTBjeWtwTzF4dWZUdGNibHh1WEc0dktpcGNiaUFxSUVsdWFHVnlhWFFnZEdobElIQnliM1J2ZEhsd1pTQnRaWFJvYjJSeklHWnliMjBnYjI1bElHTnZibk4wY25WamRHOXlJR2x1ZEc4Z1lXNXZkR2hsY2k1Y2JpQXFYRzRnS2lCVWFHVWdSblZ1WTNScGIyNHVjSEp2ZEc5MGVYQmxMbWx1YUdWeWFYUnpJR1p5YjIwZ2JHRnVaeTVxY3lCeVpYZHlhWFIwWlc0Z1lYTWdZU0J6ZEdGdVpHRnNiMjVsWEc0Z0tpQm1kVzVqZEdsdmJpQW9ibTkwSUc5dUlFWjFibU4wYVc5dUxuQnliM1J2ZEhsd1pTa3VJRTVQVkVVNklFbG1JSFJvYVhNZ1ptbHNaU0JwY3lCMGJ5QmlaU0JzYjJGa1pXUmNiaUFxSUdSMWNtbHVaeUJpYjI5MGMzUnlZWEJ3YVc1bklIUm9hWE1nWm5WdVkzUnBiMjRnYm1WbFpITWdkRzhnWW1VZ2NtVjNjbWwwZEdWdUlIVnphVzVuSUhOdmJXVWdibUYwYVhabFhHNGdLaUJtZFc1amRHbHZibk1nWVhNZ2NISnZkRzkwZVhCbElITmxkSFZ3SUhWemFXNW5JRzV2Y20xaGJDQktZWFpoVTJOeWFYQjBJR1J2WlhNZ2JtOTBJSGR2Y21zZ1lYTmNiaUFxSUdWNGNHVmpkR1ZrSUdSMWNtbHVaeUJpYjI5MGMzUnlZWEJ3YVc1bklDaHpaV1VnYldseWNtOXlMbXB6SUdsdUlISXhNVFE1TURNcExseHVJQ3BjYmlBcUlFQndZWEpoYlNCN1puVnVZM1JwYjI1OUlHTjBiM0lnUTI5dWMzUnlkV04wYjNJZ1puVnVZM1JwYjI0Z2QyaHBZMmdnYm1WbFpITWdkRzhnYVc1b1pYSnBkQ0IwYUdWY2JpQXFJQ0FnSUNCd2NtOTBiM1I1Y0dVdVhHNGdLaUJBY0dGeVlXMGdlMloxYm1OMGFXOXVmU0J6ZFhCbGNrTjBiM0lnUTI5dWMzUnlkV04wYjNJZ1puVnVZM1JwYjI0Z2RHOGdhVzVvWlhKcGRDQndjbTkwYjNSNWNHVWdabkp2YlM1Y2JpQXFMMXh1Wlhod2IzSjBjeTVwYm1obGNtbDBjeUE5SUhKbGNYVnBjbVVvSjJsdWFHVnlhWFJ6SnlrN1hHNWNibVY0Y0c5eWRITXVYMlY0ZEdWdVpDQTlJR1oxYm1OMGFXOXVLRzl5YVdkcGJpd2dZV1JrS1NCN1hHNGdJQzh2SUVSdmJpZDBJR1J2SUdGdWVYUm9hVzVuSUdsbUlHRmtaQ0JwYzI0bmRDQmhiaUJ2WW1wbFkzUmNiaUFnYVdZZ0tDRmhaR1FnZkh3Z0lXbHpUMkpxWldOMEtHRmtaQ2twSUhKbGRIVnliaUJ2Y21sbmFXNDdYRzVjYmlBZ2RtRnlJR3RsZVhNZ1BTQlBZbXBsWTNRdWEyVjVjeWhoWkdRcE8xeHVJQ0IyWVhJZ2FTQTlJR3RsZVhNdWJHVnVaM1JvTzF4dUlDQjNhR2xzWlNBb2FTMHRLU0I3WEc0Z0lDQWdiM0pwWjJsdVcydGxlWE5iYVYxZElEMGdZV1JrVzJ0bGVYTmJhVjFkTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJ2Y21sbmFXNDdYRzU5TzF4dVhHNW1kVzVqZEdsdmJpQm9ZWE5QZDI1UWNtOXdaWEowZVNodlltb3NJSEJ5YjNBcElIdGNiaUFnY21WMGRYSnVJRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVhR0Z6VDNkdVVISnZjR1Z5ZEhrdVkyRnNiQ2h2WW1vc0lIQnliM0FwTzF4dWZWeHVYRzUyWVhJZ2EwTjFjM1J2YlZCeWIyMXBjMmxtYVdWa1UzbHRZbTlzSUQwZ2RIbHdaVzltSUZONWJXSnZiQ0FoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dQeUJUZVcxaWIyd29KM1YwYVd3dWNISnZiV2x6YVdaNUxtTjFjM1J2YlNjcElEb2dkVzVrWldacGJtVmtPMXh1WEc1bGVIQnZjblJ6TG5CeWIyMXBjMmxtZVNBOUlHWjFibU4wYVc5dUlIQnliMjFwYzJsbWVTaHZjbWxuYVc1aGJDa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlHOXlhV2RwYm1Gc0lDRTlQU0FuWm5WdVkzUnBiMjRuS1Z4dUlDQWdJSFJvY205M0lHNWxkeUJVZVhCbFJYSnliM0lvSjFSb1pTQmNJbTl5YVdkcGJtRnNYQ0lnWVhKbmRXMWxiblFnYlhWemRDQmlaU0J2WmlCMGVYQmxJRVoxYm1OMGFXOXVKeWs3WEc1Y2JpQWdhV1lnS0d0RGRYTjBiMjFRY205dGFYTnBabWxsWkZONWJXSnZiQ0FtSmlCdmNtbG5hVzVoYkZ0clEzVnpkRzl0VUhKdmJXbHphV1pwWldSVGVXMWliMnhkS1NCN1hHNGdJQ0FnZG1GeUlHWnVJRDBnYjNKcFoybHVZV3hiYTBOMWMzUnZiVkJ5YjIxcGMybG1hV1ZrVTNsdFltOXNYVHRjYmlBZ0lDQnBaaUFvZEhsd1pXOW1JR1p1SUNFOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdJQ0IwYUhKdmR5QnVaWGNnVkhsd1pVVnljbTl5S0NkVWFHVWdYQ0oxZEdsc0xuQnliMjFwYzJsbWVTNWpkWE4wYjIxY0lpQmhjbWQxYldWdWRDQnRkWE4wSUdKbElHOW1JSFI1Y0dVZ1JuVnVZM1JwYjI0bktUdGNiaUFnSUNCOVhHNGdJQ0FnVDJKcVpXTjBMbVJsWm1sdVpWQnliM0JsY25SNUtHWnVMQ0JyUTNWemRHOXRVSEp2YldsemFXWnBaV1JUZVcxaWIyd3NJSHRjYmlBZ0lDQWdJSFpoYkhWbE9pQm1iaXdnWlc1MWJXVnlZV0pzWlRvZ1ptRnNjMlVzSUhkeWFYUmhZbXhsT2lCbVlXeHpaU3dnWTI5dVptbG5kWEpoWW14bE9pQjBjblZsWEc0Z0lDQWdmU2s3WEc0Z0lDQWdjbVYwZFhKdUlHWnVPMXh1SUNCOVhHNWNiaUFnWm5WdVkzUnBiMjRnWm00b0tTQjdYRzRnSUNBZ2RtRnlJSEJ5YjIxcGMyVlNaWE52YkhabExDQndjbTl0YVhObFVtVnFaV04wTzF4dUlDQWdJSFpoY2lCd2NtOXRhWE5sSUQwZ2JtVjNJRkJ5YjIxcGMyVW9ablZ1WTNScGIyNGdLSEpsYzI5c2RtVXNJSEpsYW1WamRDa2dlMXh1SUNBZ0lDQWdjSEp2YldselpWSmxjMjlzZG1VZ1BTQnlaWE52YkhabE8xeHVJQ0FnSUNBZ2NISnZiV2x6WlZKbGFtVmpkQ0E5SUhKbGFtVmpkRHRjYmlBZ0lDQjlLVHRjYmx4dUlDQWdJSFpoY2lCaGNtZHpJRDBnVzEwN1hHNGdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJR0Z5WjNNdWNIVnphQ2hoY21kMWJXVnVkSE5iYVYwcE8xeHVJQ0FnSUgxY2JpQWdJQ0JoY21kekxuQjFjMmdvWm5WdVkzUnBiMjRnS0dWeWNpd2dkbUZzZFdVcElIdGNiaUFnSUNBZ0lHbG1JQ2hsY25JcElIdGNiaUFnSUNBZ0lDQWdjSEp2YldselpWSmxhbVZqZENobGNuSXBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdjSEp2YldselpWSmxjMjlzZG1Vb2RtRnNkV1VwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBwTzF4dVhHNGdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lHOXlhV2RwYm1Gc0xtRndjR3g1S0hSb2FYTXNJR0Z5WjNNcE8xeHVJQ0FnSUgwZ1kyRjBZMmdnS0dWeWNpa2dlMXh1SUNBZ0lDQWdjSEp2YldselpWSmxhbVZqZENobGNuSXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkSFZ5YmlCd2NtOXRhWE5sTzF4dUlDQjlYRzVjYmlBZ1QySnFaV04wTG5ObGRGQnliM1J2ZEhsd1pVOW1LR1p1TENCUFltcGxZM1F1WjJWMFVISnZkRzkwZVhCbFQyWW9iM0pwWjJsdVlXd3BLVHRjYmx4dUlDQnBaaUFvYTBOMWMzUnZiVkJ5YjIxcGMybG1hV1ZrVTNsdFltOXNLU0JQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1ptNHNJR3REZFhOMGIyMVFjbTl0YVhOcFptbGxaRk41YldKdmJDd2dlMXh1SUNBZ0lIWmhiSFZsT2lCbWJpd2daVzUxYldWeVlXSnNaVG9nWm1Gc2MyVXNJSGR5YVhSaFlteGxPaUJtWVd4elpTd2dZMjl1Wm1sbmRYSmhZbXhsT2lCMGNuVmxYRzRnSUgwcE8xeHVJQ0J5WlhSMWNtNGdUMkpxWldOMExtUmxabWx1WlZCeWIzQmxjblJwWlhNb1hHNGdJQ0FnWm00c1hHNGdJQ0FnWjJWMFQzZHVVSEp2Y0dWeWRIbEVaWE5qY21sd2RHOXljeWh2Y21sbmFXNWhiQ2xjYmlBZ0tUdGNibjFjYmx4dVpYaHdiM0owY3k1d2NtOXRhWE5wWm5rdVkzVnpkRzl0SUQwZ2EwTjFjM1J2YlZCeWIyMXBjMmxtYVdWa1UzbHRZbTlzWEc1Y2JtWjFibU4wYVc5dUlHTmhiR3hpWVdOcmFXWjVUMjVTWldwbFkzUmxaQ2h5WldGemIyNHNJR05pS1NCN1hHNGdJQzh2SUdBaGNtVmhjMjl1WUNCbmRXRnlaQ0JwYm5Od2FYSmxaQ0JpZVNCaWJIVmxZbWx5WkNBb1VtVm1PaUJvZEhSd2N6b3ZMMmR2Ynk1bmJDOTBOVWxUTmswcExseHVJQ0F2THlCQ1pXTmhkWE5sSUdCdWRXeHNZQ0JwY3lCaElITndaV05wWVd3Z1pYSnliM0lnZG1Gc2RXVWdhVzRnWTJGc2JHSmhZMnR6SUhkb2FXTm9JRzFsWVc1eklGd2libThnWlhKeWIzSmNiaUFnTHk4Z2IyTmpkWEp5WldSY0lpd2dkMlVnWlhKeWIzSXRkM0poY0NCemJ5QjBhR1VnWTJGc2JHSmhZMnNnWTI5dWMzVnRaWElnWTJGdUlHUnBjM1JwYm1kMWFYTm9JR0psZEhkbFpXNWNiaUFnTHk4Z1hDSjBhR1VnY0hKdmJXbHpaU0J5WldwbFkzUmxaQ0IzYVhSb0lHNTFiR3hjSWlCdmNpQmNJblJvWlNCd2NtOXRhWE5sSUdaMWJHWnBiR3hsWkNCM2FYUm9JSFZ1WkdWbWFXNWxaRndpTGx4dUlDQnBaaUFvSVhKbFlYTnZiaWtnZTF4dUlDQWdJSFpoY2lCdVpYZFNaV0Z6YjI0Z1BTQnVaWGNnUlhKeWIzSW9KMUJ5YjIxcGMyVWdkMkZ6SUhKbGFtVmpkR1ZrSUhkcGRHZ2dZU0JtWVd4emVTQjJZV3gxWlNjcE8xeHVJQ0FnSUc1bGQxSmxZWE52Ymk1eVpXRnpiMjRnUFNCeVpXRnpiMjQ3WEc0Z0lDQWdjbVZoYzI5dUlEMGdibVYzVW1WaGMyOXVPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQmpZaWh5WldGemIyNHBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmpZV3hzWW1GamEybG1lU2h2Y21sbmFXNWhiQ2tnZTF4dUlDQnBaaUFvZEhsd1pXOW1JRzl5YVdkcGJtRnNJQ0U5UFNBblpuVnVZM1JwYjI0bktTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpZ25WR2hsSUZ3aWIzSnBaMmx1WVd4Y0lpQmhjbWQxYldWdWRDQnRkWE4wSUdKbElHOW1JSFI1Y0dVZ1JuVnVZM1JwYjI0bktUdGNiaUFnZlZ4dVhHNGdJQzh2SUZkbElFUlBJRTVQVkNCeVpYUjFjbTRnZEdobElIQnliMjFwYzJVZ1lYTWdhWFFnWjJsMlpYTWdkR2hsSUhWelpYSWdZU0JtWVd4elpTQnpaVzV6WlNCMGFHRjBYRzRnSUM4dklIUm9aU0J3Y205dGFYTmxJR2x6SUdGamRIVmhiR3g1SUhOdmJXVm9iM2NnY21Wc1lYUmxaQ0IwYnlCMGFHVWdZMkZzYkdKaFkyc25jeUJsZUdWamRYUnBiMjVjYmlBZ0x5OGdZVzVrSUhSb1lYUWdkR2hsSUdOaGJHeGlZV05ySUhSb2NtOTNhVzVuSUhkcGJHd2djbVZxWldOMElIUm9aU0J3Y205dGFYTmxMbHh1SUNCbWRXNWpkR2x2YmlCallXeHNZbUZqYTJsbWFXVmtLQ2tnZTF4dUlDQWdJSFpoY2lCaGNtZHpJRDBnVzEwN1hHNGdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJR0Z5WjNNdWNIVnphQ2hoY21kMWJXVnVkSE5iYVYwcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhaaGNpQnRZWGxpWlVOaUlEMGdZWEpuY3k1d2IzQW9LVHRjYmlBZ0lDQnBaaUFvZEhsd1pXOW1JRzFoZVdKbFEySWdJVDA5SUNkbWRXNWpkR2x2YmljcElIdGNiaUFnSUNBZ0lIUm9jbTkzSUc1bGR5QlVlWEJsUlhKeWIzSW9KMVJvWlNCc1lYTjBJR0Z5WjNWdFpXNTBJRzExYzNRZ1ltVWdiMllnZEhsd1pTQkdkVzVqZEdsdmJpY3BPMXh1SUNBZ0lIMWNiaUFnSUNCMllYSWdjMlZzWmlBOUlIUm9hWE03WEc0Z0lDQWdkbUZ5SUdOaUlEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdiV0Y1WW1WRFlpNWhjSEJzZVNoelpXeG1MQ0JoY21kMWJXVnVkSE1wTzF4dUlDQWdJSDA3WEc0Z0lDQWdMeThnU1c0Z2RISjFaU0J1YjJSbElITjBlV3hsSUhkbElIQnliMk5sYzNNZ2RHaGxJR05oYkd4aVlXTnJJRzl1SUdCdVpYaDBWR2xqYTJBZ2QybDBhQ0JoYkd3Z2RHaGxYRzRnSUNBZ0x5OGdhVzF3YkdsallYUnBiMjV6SUNoemRHRmpheXdnWUhWdVkyRjFaMmgwUlhoalpYQjBhVzl1WUN3Z1lHRnplVzVqWDJodmIydHpZQ2xjYmlBZ0lDQnZjbWxuYVc1aGJDNWhjSEJzZVNoMGFHbHpMQ0JoY21kektWeHVJQ0FnSUNBZ0xuUm9aVzRvWm5WdVkzUnBiMjRvY21WMEtTQjdJSEJ5YjJObGMzTXVibVY0ZEZScFkyc29ZMkl1WW1sdVpDaHVkV3hzTENCdWRXeHNMQ0J5WlhRcEtTQjlMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1puVnVZM1JwYjI0b2NtVnFLU0I3SUhCeWIyTmxjM011Ym1WNGRGUnBZMnNvWTJGc2JHSmhZMnRwWm5sUGJsSmxhbVZqZEdWa0xtSnBibVFvYm5Wc2JDd2djbVZxTENCallpa3BJSDBwTzF4dUlDQjlYRzVjYmlBZ1QySnFaV04wTG5ObGRGQnliM1J2ZEhsd1pVOW1LR05oYkd4aVlXTnJhV1pwWldRc0lFOWlhbVZqZEM1blpYUlFjbTkwYjNSNWNHVlBaaWh2Y21sbmFXNWhiQ2twTzF4dUlDQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkR2xsY3loallXeHNZbUZqYTJsbWFXVmtMRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JuWlhSUGQyNVFjbTl3WlhKMGVVUmxjMk55YVhCMGIzSnpLRzl5YVdkcGJtRnNLU2s3WEc0Z0lISmxkSFZ5YmlCallXeHNZbUZqYTJsbWFXVmtPMXh1ZlZ4dVpYaHdiM0owY3k1allXeHNZbUZqYTJsbWVTQTlJR05oYkd4aVlXTnJhV1o1TzF4dUlpd2lKM1Z6WlNCemRISnBZM1FuTzF4dVhHNTJZWElnWm05eVJXRmphQ0E5SUhKbGNYVnBjbVVvSjJadmNtVmhZMmduS1R0Y2JuWmhjaUJoZG1GcGJHRmliR1ZVZVhCbFpFRnljbUY1Y3lBOUlISmxjWFZwY21Vb0oyRjJZV2xzWVdKc1pTMTBlWEJsWkMxaGNuSmhlWE1uS1R0Y2JuWmhjaUJqWVd4c1FtOTFibVFnUFNCeVpYRjFhWEpsS0NkallXeHNMV0pwYm1RdlkyRnNiRUp2ZFc1a0p5azdYRzVjYm5aaGNpQWtkRzlUZEhKcGJtY2dQU0JqWVd4c1FtOTFibVFvSjA5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWNuS1R0Y2JuWmhjaUJvWVhOVGVXMWliMnh6SUQwZ2NtVnhkV2x5WlNnbmFHRnpMWE41YldKdmJITW5LU2dwTzF4dWRtRnlJR2hoYzFSdlUzUnlhVzVuVkdGbklEMGdhR0Z6VTNsdFltOXNjeUFtSmlCMGVYQmxiMllnVTNsdFltOXNMblJ2VTNSeWFXNW5WR0ZuSUQwOVBTQW5jM2x0WW05c0p6dGNibHh1ZG1GeUlIUjVjR1ZrUVhKeVlYbHpJRDBnWVhaaGFXeGhZbXhsVkhsd1pXUkJjbkpoZVhNb0tUdGNibHh1ZG1GeUlDUnpiR2xqWlNBOUlHTmhiR3hDYjNWdVpDZ25VM1J5YVc1bkxuQnliM1J2ZEhsd1pTNXpiR2xqWlNjcE8xeHVkbUZ5SUhSdlUzUnlWR0ZuY3lBOUlIdDlPMXh1ZG1GeUlHZFBVRVFnUFNCeVpYRjFhWEpsS0NkbGN5MWhZbk4wY21GamRDOW9aV3h3WlhKekwyZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y2ljcE8xeHVkbUZ5SUdkbGRGQnliM1J2ZEhsd1pVOW1JRDBnVDJKcVpXTjBMbWRsZEZCeWIzUnZkSGx3WlU5bU95QXZMeUJ5WlhGMWFYSmxLQ2RuWlhSd2NtOTBiM1I1Y0dWdlppY3BPMXh1YVdZZ0tHaGhjMVJ2VTNSeWFXNW5WR0ZuSUNZbUlHZFBVRVFnSmlZZ1oyVjBVSEp2ZEc5MGVYQmxUMllwSUh0Y2JseDBabTl5UldGamFDaDBlWEJsWkVGeWNtRjVjeXdnWm5WdVkzUnBiMjRnS0hSNWNHVmtRWEp5WVhrcElIdGNibHgwWEhScFppQW9kSGx3Wlc5bUlHZHNiMkpoYkZ0MGVYQmxaRUZ5Y21GNVhTQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVYSFJjZEZ4MGRtRnlJR0Z5Y2lBOUlHNWxkeUJuYkc5aVlXeGJkSGx3WldSQmNuSmhlVjBvS1R0Y2JseDBYSFJjZEdsbUlDZ2hLRk41YldKdmJDNTBiMU4wY21sdVoxUmhaeUJwYmlCaGNuSXBLU0I3WEc1Y2RGeDBYSFJjZEhSb2NtOTNJRzVsZHlCRmRtRnNSWEp5YjNJb0ozUm9hWE1nWlc1bmFXNWxJR2hoY3lCemRYQndiM0owSUdadmNpQlRlVzFpYjJ3dWRHOVRkSEpwYm1kVVlXY3NJR0oxZENBbklDc2dkSGx3WldSQmNuSmhlU0FySUNjZ1pHOWxjeUJ1YjNRZ2FHRjJaU0IwYUdVZ2NISnZjR1Z5ZEhraElGQnNaV0Z6WlNCeVpYQnZjblFnZEdocGN5NG5LVHRjYmx4MFhIUmNkSDFjYmx4MFhIUmNkSFpoY2lCd2NtOTBieUE5SUdkbGRGQnliM1J2ZEhsd1pVOW1LR0Z5Y2lrN1hHNWNkRngwWEhSMllYSWdaR1Z6WTNKcGNIUnZjaUE5SUdkUFVFUW9jSEp2ZEc4c0lGTjViV0p2YkM1MGIxTjBjbWx1WjFSaFp5azdYRzVjZEZ4MFhIUnBaaUFvSVdSbGMyTnlhWEIwYjNJcElIdGNibHgwWEhSY2RGeDBkbUZ5SUhOMWNHVnlVSEp2ZEc4Z1BTQm5aWFJRY205MGIzUjVjR1ZQWmlod2NtOTBieWs3WEc1Y2RGeDBYSFJjZEdSbGMyTnlhWEIwYjNJZ1BTQm5UMUJFS0hOMWNHVnlVSEp2ZEc4c0lGTjViV0p2YkM1MGIxTjBjbWx1WjFSaFp5azdYRzVjZEZ4MFhIUjlYRzVjZEZ4MFhIUjBiMU4wY2xSaFozTmJkSGx3WldSQmNuSmhlVjBnUFNCa1pYTmpjbWx3ZEc5eUxtZGxkRHRjYmx4MFhIUjlYRzVjZEgwcE8xeHVmVnh1WEc1MllYSWdkSEo1Vkhsd1pXUkJjbkpoZVhNZ1BTQm1kVzVqZEdsdmJpQjBjbmxCYkd4VWVYQmxaRUZ5Y21GNWN5aDJZV3gxWlNrZ2UxeHVYSFIyWVhJZ1ptOTFibVJPWVcxbElEMGdabUZzYzJVN1hHNWNkR1p2Y2tWaFkyZ29kRzlUZEhKVVlXZHpMQ0JtZFc1amRHbHZiaUFvWjJWMGRHVnlMQ0IwZVhCbFpFRnljbUY1S1NCN1hHNWNkRngwYVdZZ0tDRm1iM1Z1WkU1aGJXVXBJSHRjYmx4MFhIUmNkSFJ5ZVNCN1hHNWNkRngwWEhSY2RIWmhjaUJ1WVcxbElEMGdaMlYwZEdWeUxtTmhiR3dvZG1Gc2RXVXBPMXh1WEhSY2RGeDBYSFJwWmlBb2JtRnRaU0E5UFQwZ2RIbHdaV1JCY25KaGVTa2dlMXh1WEhSY2RGeDBYSFJjZEdadmRXNWtUbUZ0WlNBOUlHNWhiV1U3WEc1Y2RGeDBYSFJjZEgxY2JseDBYSFJjZEgwZ1kyRjBZMmdnS0dVcElIdDlYRzVjZEZ4MGZWeHVYSFI5S1R0Y2JseDBjbVYwZFhKdUlHWnZkVzVrVG1GdFpUdGNibjA3WEc1Y2JuWmhjaUJwYzFSNWNHVmtRWEp5WVhrZ1BTQnlaWEYxYVhKbEtDZHBjeTEwZVhCbFpDMWhjbkpoZVNjcE8xeHVYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVJSGRvYVdOb1ZIbHdaV1JCY25KaGVTaDJZV3gxWlNrZ2UxeHVYSFJwWmlBb0lXbHpWSGx3WldSQmNuSmhlU2gyWVd4MVpTa3BJSHNnY21WMGRYSnVJR1poYkhObE95QjlYRzVjZEdsbUlDZ2hhR0Z6Vkc5VGRISnBibWRVWVdjcElIc2djbVYwZFhKdUlDUnpiR2xqWlNna2RHOVRkSEpwYm1jb2RtRnNkV1VwTENBNExDQXRNU2s3SUgxY2JseDBjbVYwZFhKdUlIUnllVlI1Y0dWa1FYSnlZWGx6S0haaGJIVmxLVHRjYm4wN1hHNGlMQ0l2THlCVWFHVWdiVzlrZFd4bElHTmhZMmhsWEc1MllYSWdYMTkzWldKd1lXTnJYMjF2WkhWc1pWOWpZV05vWlY5ZklEMGdlMzA3WEc1Y2JpOHZJRlJvWlNCeVpYRjFhWEpsSUdaMWJtTjBhVzl1WEc1bWRXNWpkR2x2YmlCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktHMXZaSFZzWlVsa0tTQjdYRzVjZEM4dklFTm9aV05ySUdsbUlHMXZaSFZzWlNCcGN5QnBiaUJqWVdOb1pWeHVYSFIyWVhJZ1kyRmphR1ZrVFc5a2RXeGxJRDBnWDE5M1pXSndZV05yWDIxdlpIVnNaVjlqWVdOb1pWOWZXMjF2WkhWc1pVbGtYVHRjYmx4MGFXWWdLR05oWTJobFpFMXZaSFZzWlNBaFBUMGdkVzVrWldacGJtVmtLU0I3WEc1Y2RGeDBjbVYwZFhKdUlHTmhZMmhsWkUxdlpIVnNaUzVsZUhCdmNuUnpPMXh1WEhSOVhHNWNkQzh2SUVOeVpXRjBaU0JoSUc1bGR5QnRiMlIxYkdVZ0tHRnVaQ0J3ZFhRZ2FYUWdhVzUwYnlCMGFHVWdZMkZqYUdVcFhHNWNkSFpoY2lCdGIyUjFiR1VnUFNCZlgzZGxZbkJoWTJ0ZmJXOWtkV3hsWDJOaFkyaGxYMTliYlc5a2RXeGxTV1JkSUQwZ2UxeHVYSFJjZEdsa09pQnRiMlIxYkdWSlpDeGNibHgwWEhSc2IyRmtaV1E2SUdaaGJITmxMRnh1WEhSY2RHVjRjRzl5ZEhNNklIdDlYRzVjZEgwN1hHNWNibHgwTHk4Z1JYaGxZM1YwWlNCMGFHVWdiVzlrZFd4bElHWjFibU4wYVc5dVhHNWNkRjlmZDJWaWNHRmphMTl0YjJSMWJHVnpYMTliYlc5a2RXeGxTV1JkTG1OaGJHd29iVzlrZFd4bExtVjRjRzl5ZEhNc0lHMXZaSFZzWlN3Z2JXOWtkV3hsTG1WNGNHOXlkSE1zSUY5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4cE8xeHVYRzVjZEM4dklFWnNZV2NnZEdobElHMXZaSFZzWlNCaGN5QnNiMkZrWldSY2JseDBiVzlrZFd4bExteHZZV1JsWkNBOUlIUnlkV1U3WEc1Y2JseDBMeThnVW1WMGRYSnVJSFJvWlNCbGVIQnZjblJ6SUc5bUlIUm9aU0J0YjJSMWJHVmNibHgwY21WMGRYSnVJRzF2WkhWc1pTNWxlSEJ2Y25Sek8xeHVmVnh1WEc0aUxDSXZMeUJrWldacGJtVWdaMlYwZEdWeUlHWjFibU4wYVc5dWN5Qm1iM0lnYUdGeWJXOXVlU0JsZUhCdmNuUnpYRzVmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmTG1RZ1BTQW9aWGh3YjNKMGN5d2daR1ZtYVc1cGRHbHZiaWtnUFQ0Z2UxeHVYSFJtYjNJb2RtRnlJR3RsZVNCcGJpQmtaV1pwYm1sMGFXOXVLU0I3WEc1Y2RGeDBhV1lvWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1dktHUmxabWx1YVhScGIyNHNJR3RsZVNrZ0ppWWdJVjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMTh1YnlobGVIQnZjblJ6TENCclpYa3BLU0I3WEc1Y2RGeDBYSFJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1pYaHdiM0owY3l3Z2EyVjVMQ0I3SUdWdWRXMWxjbUZpYkdVNklIUnlkV1VzSUdkbGREb2daR1ZtYVc1cGRHbHZibHRyWlhsZElIMHBPMXh1WEhSY2RIMWNibHgwZlZ4dWZUc2lMQ0pmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmTG1jZ1BTQW9ablZ1WTNScGIyNG9LU0I3WEc1Y2RHbG1JQ2gwZVhCbGIyWWdaMnh2WW1Gc1ZHaHBjeUE5UFQwZ0oyOWlhbVZqZENjcElISmxkSFZ5YmlCbmJHOWlZV3hVYUdsek8xeHVYSFIwY25rZ2UxeHVYSFJjZEhKbGRIVnliaUIwYUdseklIeDhJRzVsZHlCR2RXNWpkR2x2YmlnbmNtVjBkWEp1SUhSb2FYTW5LU2dwTzF4dVhIUjlJR05oZEdOb0lDaGxLU0I3WEc1Y2RGeDBhV1lnS0hSNWNHVnZaaUIzYVc1a2IzY2dQVDA5SUNkdlltcGxZM1FuS1NCeVpYUjFjbTRnZDJsdVpHOTNPMXh1WEhSOVhHNTlLU2dwT3lJc0lsOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHVieUE5SUNodlltb3NJSEJ5YjNBcElEMCtJQ2hQWW1wbFkzUXVjSEp2ZEc5MGVYQmxMbWhoYzA5M2JsQnliM0JsY25SNUxtTmhiR3dvYjJKcUxDQndjbTl3S1NraUxDSXZMeUJrWldacGJtVWdYMTlsYzAxdlpIVnNaU0J2YmlCbGVIQnZjblJ6WEc1ZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxuSWdQU0FvWlhod2IzSjBjeWtnUFQ0Z2UxeHVYSFJwWmloMGVYQmxiMllnVTNsdFltOXNJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUJUZVcxaWIyd3VkRzlUZEhKcGJtZFVZV2NwSUh0Y2JseDBYSFJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1pYaHdiM0owY3l3Z1UzbHRZbTlzTG5SdlUzUnlhVzVuVkdGbkxDQjdJSFpoYkhWbE9pQW5UVzlrZFd4bEp5QjlLVHRjYmx4MGZWeHVYSFJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1pYaHdiM0owY3l3Z0oxOWZaWE5OYjJSMWJHVW5MQ0I3SUhaaGJIVmxPaUIwY25WbElIMHBPMXh1ZlRzaUxDSmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZMbTV0WkNBOUlDaHRiMlIxYkdVcElEMCtJSHRjYmx4MGJXOWtkV3hsTG5CaGRHaHpJRDBnVzEwN1hHNWNkR2xtSUNnaGJXOWtkV3hsTG1Ob2FXeGtjbVZ1S1NCdGIyUjFiR1V1WTJocGJHUnlaVzRnUFNCYlhUdGNibHgwY21WMGRYSnVJRzF2WkhWc1pUdGNibjA3SWl3aVpYaHdiM0owSUhzZ1NXMW5kWEpEYkdsbGJuUWdmU0JtY205dElDY3VMMk5zYVdWdWRDYzdYRzRpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUo5XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJleHBvcnQgeyBCaWtlVGFnQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQnXG4iXSwic291cmNlUm9vdCI6IiJ9